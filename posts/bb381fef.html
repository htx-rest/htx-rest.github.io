<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java进阶之路（四） | 鲸落</title><meta name="author" content="鲸落"><meta name="copyright" content="鲸落"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="7 常用工具类7.1 Scanner工具类Java 的 Scanner 类是一个方便在控制台扫描用户输入的工具类，虽然它也可以扫描文件内容，但我们通常更喜欢它扮演前面的角色，因为扫描文件可以通过文件流来完成。 接下来，我们通过几个简单的示例讲一下 Scanner 类。 01、扫描控制台输入  通常，我们会使用 Scanner 类来扫描控制台输入，尤其是对于初学 Java 的人来说，这样会非常的酷，">
<meta property="og:type" content="article">
<meta property="og:title" content="Java进阶之路（四）">
<meta property="og:url" content="https://whalerest.top/posts/bb381fef.html">
<meta property="og:site_name" content="鲸落">
<meta property="og:description" content="7 常用工具类7.1 Scanner工具类Java 的 Scanner 类是一个方便在控制台扫描用户输入的工具类，虽然它也可以扫描文件内容，但我们通常更喜欢它扮演前面的角色，因为扫描文件可以通过文件流来完成。 接下来，我们通过几个简单的示例讲一下 Scanner 类。 01、扫描控制台输入  通常，我们会使用 Scanner 类来扫描控制台输入，尤其是对于初学 Java 的人来说，这样会非常的酷，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://whalerest.top/assets/u=595920241,2439700946&fm=253&fmt=auto&app=120&f=JPEG.webp">
<meta property="article:published_time" content="2023-10-13T12:18:40.000Z">
<meta property="article:modified_time" content="2023-10-16T02:50:57.438Z">
<meta property="article:author" content="鲸落">
<meta property="article:tag" content="常用工具类">
<meta property="article:tag" content="Java新特性">
<meta property="article:tag" content="Java网络编程">
<meta property="article:tag" content="Java NIO">
<meta property="article:tag" content="Java重要知识点">
<meta property="article:tag" content="Java并发编程">
<meta property="article:tag" content="JVM（java虚拟机）">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://whalerest.top/assets/u=595920241,2439700946&fm=253&fmt=auto&app=120&f=JPEG.webp"><link rel="shortcut icon" href="/"><link rel="canonical" href="https://whalerest.top/posts/bb381fef.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java进阶之路（四）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-10-16 10:50:57'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_4233300_xxm4hpxio1.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/element-ui@2.15.6/packages/theme-chalk/lib/index.css"><script src="https://npm.elemecdn.com/echarts@4.9.0/dist/echarts.min.js"></script><style id="themeColor"></style><style id="rightSide"></style><style id="transPercent"></style><style id="blurNum"></style><style id="settingStyle"></style><span id="fps"></span><style id="defineBg"></style><style id="menu_shadow"></style><div id="myscoll"></div><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/assets/mmexport1694508539292.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">281</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">243</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-youhuawenzhang"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-guidang"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei"></i><span> 分类</span></a></li><li><a class="site-page child" href="javascript:randomPost();"><i class="fa-fw iconfont icon-wode-zuji-copy"></i><span> 随便逛逛</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-xiuxianyinpin"></i><span> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/life/music/"><i class="fa-fw iconfont icon-tool"></i><span> 八音盒</span></a></li><li><a class="site-page child" href="/life/movies/"><i class="fa-fw iconfont icon-dianying"></i><span> 影院</span></a></li><li><a class="site-page child" href="/life/games/"><i class="fa-fw iconfont icon-youxi"></i><span> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-baoxiang21"></i><span> 八宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/box/gallery/"><i class="fa-fw iconfont icon-hualang"></i><span> 画廊</span></a></li><li><a class="site-page child" href="/box/animation/"><i class="fa-fw iconfont icon-donghua"></i><span> 动画</span></a></li><li><a class="site-page child" href="/box/nav/"><i class="fa-fw iconfont icon-a-06-wangzhidaohang"></i><span> 网址导航</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-tubiaozhizuomoban1"></i><span> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/social/fcircle/"><i class="fa-fw iconfont icon-iconfontzhizuobiaozhunbduan36"></i><span> 朋友圈</span></a></li><li><a class="site-page child" href="/comments/"><i class="fa-fw iconfont icon-liuyanban"></i><span> 留言板</span></a></li><li><a class="site-page child" href="/social/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-a-06-wangzhidaohang"></i><span> 网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/site/census/"><i class="fa-fw iconfont icon-a-06-wangzhidaohang"></i><span> 网站统计</span></a></li><li><a class="site-page child" href="/site/echarts/"><i class="fa-fw iconfont icon-tongji"></i><span> 文章统计</span></a></li><li><a class="site-page child" href="/site/time/"><i class="fa-fw iconfont icon-shalou"></i><span> 旧时光</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-geren"></i><span> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/personal/bb/"><i class="fa-fw iconfont icon-icon_liuyan"></i><span> 唠叨</span></a></li><li><a class="site-page child" href="/personal/love/"><i class="fa-fw iconfont icon-valentine_-email-love-message-send"></i><span> 恋爱小屋</span></a></li><li><a class="site-page child" href="/personal/about/"><i class="fa-fw iconfont icon-icon-lark-logo-old"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp')"><nav id="nav"><span id="blog-info"><a href="/" title="鲸落"><span class="site-name">鲸落</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-youhuawenzhang"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-guidang"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei"></i><span> 分类</span></a></li><li><a class="site-page child" href="javascript:randomPost();"><i class="fa-fw iconfont icon-wode-zuji-copy"></i><span> 随便逛逛</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-xiuxianyinpin"></i><span> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/life/music/"><i class="fa-fw iconfont icon-tool"></i><span> 八音盒</span></a></li><li><a class="site-page child" href="/life/movies/"><i class="fa-fw iconfont icon-dianying"></i><span> 影院</span></a></li><li><a class="site-page child" href="/life/games/"><i class="fa-fw iconfont icon-youxi"></i><span> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-baoxiang21"></i><span> 八宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/box/gallery/"><i class="fa-fw iconfont icon-hualang"></i><span> 画廊</span></a></li><li><a class="site-page child" href="/box/animation/"><i class="fa-fw iconfont icon-donghua"></i><span> 动画</span></a></li><li><a class="site-page child" href="/box/nav/"><i class="fa-fw iconfont icon-a-06-wangzhidaohang"></i><span> 网址导航</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-tubiaozhizuomoban1"></i><span> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/social/fcircle/"><i class="fa-fw iconfont icon-iconfontzhizuobiaozhunbduan36"></i><span> 朋友圈</span></a></li><li><a class="site-page child" href="/comments/"><i class="fa-fw iconfont icon-liuyanban"></i><span> 留言板</span></a></li><li><a class="site-page child" href="/social/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-a-06-wangzhidaohang"></i><span> 网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/site/census/"><i class="fa-fw iconfont icon-a-06-wangzhidaohang"></i><span> 网站统计</span></a></li><li><a class="site-page child" href="/site/echarts/"><i class="fa-fw iconfont icon-tongji"></i><span> 文章统计</span></a></li><li><a class="site-page child" href="/site/time/"><i class="fa-fw iconfont icon-shalou"></i><span> 旧时光</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-geren"></i><span> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/personal/bb/"><i class="fa-fw iconfont icon-icon_liuyan"></i><span> 唠叨</span></a></li><li><a class="site-page child" href="/personal/love/"><i class="fa-fw iconfont icon-valentine_-email-love-message-send"></i><span> 恋爱小屋</span></a></li><li><a class="site-page child" href="/personal/about/"><i class="fa-fw iconfont icon-icon-lark-logo-old"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java进阶之路（四）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-10-13T12:18:40.000Z" title="发表于 2023-10-13 20:18:40">2023-10-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-10-16T02:50:57.438Z" title="更新于 2023-10-16 10:50:57">2023-10-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E6%B8%A3%E7%AC%94%E8%AE%B0/">面渣笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">85.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>313分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java进阶之路（四）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="7-常用工具类"><a href="#7-常用工具类" class="headerlink" title="7 常用工具类"></a>7 常用工具类</h1><h2 id="7-1-Scanner工具类"><a href="#7-1-Scanner工具类" class="headerlink" title="7.1 Scanner工具类"></a>7.1 Scanner工具类</h2><p>Java 的 Scanner 类是一个方便在控制台扫描用户输入的工具类，虽然它也可以扫描文件内容，但我们通常更喜欢它扮演前面的角色，因为扫描文件可以通过文件流来完成。</p>
<p>接下来，我们通过几个简单的示例讲一下 Scanner 类。</p>
<p><strong>01、扫描控制台输入 </strong></p>
<p>通常，我们会使用 Scanner 类来扫描控制台输入，尤其是对于初学 Java 的人来说，这样会非常的酷，因为终于可以拿到我们自己想要输入的数据了。</p>
<p>来看下面的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Scanner scanner = new Scanner(System.in); // 创建 Scanner 对象，从标准输入流中读取数据</span><br><span class="line">System.out.print(&quot;请输入一个整数：&quot;);</span><br><span class="line">int num = scanner.nextInt(); // 获取用户输入的整数</span><br><span class="line">System.out.println(&quot;您输入的整数是：&quot; + num);</span><br><span class="line">scanner.nextLine(); // 读取换行符，避免影响下一次读取</span><br><span class="line">System.out.print(&quot;请输入一个字符串：&quot;);</span><br><span class="line">String str = scanner.nextLine(); // 获取用户输入的字符串</span><br><span class="line">System.out.println(&quot;您输入的字符串是：&quot; + str);</span><br><span class="line">scanner.close(); // 关闭 Scanner 对象</span><br></pre></td></tr></table></figure>
<p>运行后就可以在控制台交互了，对于新手来说，估计会觉得比较有趣。</p>
<p><img src="\assets\note\image-20231011145657922.png" alt="image-20231011145657922"></p>
<p>其中 System.in 返回的是一个字节输入流 InputStream，和 System.out 刚好对应。</p>
<p><img src="\assets\note\image-20231011145722053.png" alt="image-20231011145722053"></p>
<p><strong>1）nextLine </strong></p>
<p>nextLine() 方法会扫描输入流中的字符，直到遇到行末尾的换行符 \n ，然后将该行的内容作为字符串返回，同时， nextLine() 会将 Scanner 对象的位置移动到下一行的开头，以便下一次读取数据时从下一行的开头开始读取。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Scanner scanner = new Scanner(System.in); // 创建 Scanner 对象，从标准输入流中读取数据</span><br><span class="line">System.out.println(&quot;请输入多行文本，以空行结束：&quot;);</span><br><span class="line">StringBuilder sb = new StringBuilder(); // 创建 StringBuilder 对象，用于保存读取的文本</span><br><span class="line">String line = scanner.nextLine(); // 读取输入流中的第一行</span><br><span class="line">while (!line.isEmpty()) &#123; // 如果读取的行不为空，则继续读取下一行</span><br><span class="line">    sb.append(line).append(&quot;\n&quot;); // 将当前行的内容添加到 StringBuilder 对象中，并换行</span><br><span class="line">    line = scanner.nextLine(); // 读取下一行</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;您输入的文本是：\n&quot; + sb.toString()); // 打印读取的文本</span><br><span class="line">scanner.close(); // 关闭 Scanner 对象</span><br></pre></td></tr></table></figure>
<p><strong>2）nextInt </strong></p>
<p>nextInt() 用于从输入流中读取下一个整数并返回，如果输入流中没有整数，或者不是整数，将抛出 InputMismatchException 异常。</p>
<p><img src="\assets\note\image-20231011145927831.png" alt="image-20231011145927831"></p>
<p><strong>3）其他方法 </strong></p>
<p>除了以上两个常用的方法，Scanner 类中还有一些其他的方法：</p>
<ul>
<li>boolean hasNext() ：检查输入流是否还有下一个标记。</li>
<li>boolean hasNextLine() ：检查输入流是否还有下一行。</li>
<li>String next() ：读取输入流中的下一个标记（使用默认的分隔符，通常是空格或换行符）。</li>
<li>double nextDouble() ：读取输入流中的下一个双精度浮点数。</li>
</ul>
<p>来个 demo 吧。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Scanner scanner = new Scanner(System.in); // 创建 Scanner 对象，从标准输入流中读取数据</span><br><span class="line">System.out.print(&quot;请输入一个整数：&quot;);</span><br><span class="line">if (scanner.hasNextInt()) &#123; // 判断输入流中是否有下一个整数</span><br><span class="line">    int num = scanner.nextInt(); // 读取输入流中的下一个整数</span><br><span class="line">    System.out.println(&quot;您输入的整数是：&quot; + num);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    System.out.println(&quot;输入的不是整数！&quot;);</span><br><span class="line">&#125;</span><br><span class="line">scanner.nextLine(); // 读取输入流中的换行符</span><br><span class="line">System.out.print(&quot;请输入多个单词，以空格分隔：&quot;);</span><br><span class="line">while (scanner.hasNext()) &#123; // 判断输入流中是否还有下一个标记</span><br><span class="line">    String word = scanner.next(); // 读取输入流中的下一个单词</span><br><span class="line">    System.out.println(&quot;您输入的单词是：&quot; + word);</span><br><span class="line">&#125;</span><br><span class="line">scanner.nextLine(); // 读取输入流中的换行符</span><br><span class="line">System.out.print(&quot;请输入一个实数：&quot;);</span><br><span class="line">if (scanner.hasNextDouble()) &#123; // 判断输入流中是否有下一个实数</span><br><span class="line">    double num = scanner.nextDouble(); // 读取输入流中的下一个实数</span><br><span class="line">    System.out.println(&quot;您输入的实数是：&quot; + num);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    System.out.println(&quot;输入的不是实数！&quot;);</span><br><span class="line">&#125;</span><br><span class="line">scanner.nextLine(); // 读取输入流中的换行符</span><br><span class="line">System.out.print(&quot;请输入一个字符串：&quot;);</span><br><span class="line">if (scanner.hasNextLine()) &#123; // 判断输入流中是否有下一行</span><br><span class="line">    String line = scanner.nextLine(); // 读取输入流中的下一行</span><br><span class="line">    System.out.println(&quot;您输入的字符串是：&quot; + line);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    System.out.println(&quot;输入的不是字符串！&quot;);</span><br><span class="line">&#125;</span><br><span class="line">scanner.close(); // 关闭 Scanner 对象</span><br></pre></td></tr></table></figure>
<p><strong>02、扫描文件 </strong></p>
<p>当然了，Scanner 也是可以用来扫描文件的，方式也非常的简单，以下是代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    // 创建 File 对象，表示要扫描的文件</span><br><span class="line">    File file = new File(&quot;docs/安装环境.md&quot;);</span><br><span class="line">    Scanner scanner = new Scanner(file); // 创建 Scanner 对象，从文件中读取数据</span><br><span class="line">    while (scanner.hasNextLine()) &#123; // 判断文件中是否有下一行</span><br><span class="line">        String line = scanner.nextLine(); // 读取文件中的下一行</span><br><span class="line">        System.out.println(line); // 打印读取的行</span><br><span class="line">    &#125;</span><br><span class="line">    scanner.close(); // 关闭 Scanner 对象</span><br><span class="line">&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">    System.out.println(&quot;文件不存在！&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们首先创建了一个 File 对象，表示要扫描的文件。然后，我们使用 Scanner 类的构造方法来创建 Scanner 对象，将文件作为参数传递给构造方法。在 while 循环中，我们使用 hasNextLine() 方法来判断文件中是否有下一行，如果有，则使用 nextLine() 方法读取该行字符串，并使用 println() 方法将其打印出来。最后，我们在程序结束前使用 close() 方法关闭 Scanner 对象。</p>
<p>除了使用循环+nextLine，我们还可以使用 useDelimiter 方法设置文件结束符 \Z 来读取整个文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 创建 File 对象，表示要扫描的文件</span><br><span class="line">Scanner scanner = new Scanner(new File(&quot;docs/安装环境.md&quot;)); // 创建 Scanner 对象，从文</span><br><span class="line">件中读取数据</span><br><span class="line">scanner.useDelimiter(&quot;\\Z&quot;); // 设置分隔符为文件结尾</span><br><span class="line">if (scanner.hasNext()) &#123; // 判断文件中是否有下一行</span><br><span class="line">    String content = scanner.next(); // 读取文件中的下一行</span><br><span class="line">    System.out.println(content); // 打印读取的行</span><br><span class="line">&#125;</span><br><span class="line">scanner.close(); // 关闭 Scanner 对象</span><br></pre></td></tr></table></figure>
<p>正则表达式中的 \Z 表示输入的结尾，也就是文件结束符。在 Scanner 类中，我们可以使用 \Z 作为分隔符，以便读取整个文件内容。</p>
<p><strong>03、查找匹配项 </strong></p>
<p>除了上面提到的扫描控制台输入流、文件，Scanner 还提供了另外四个以 find 开头的查找匹配项的方法：</p>
<p><img src="\assets\note\image-20231012142345475.png" alt="image-20231012142345475"></p>
<p>来看示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String input = &quot;good good study, day day up.&quot;;</span><br><span class="line">Scanner scanner = new Scanner(input);</span><br><span class="line">String result;</span><br><span class="line">// 使用 findInLine() 方法查找字符串中的单词</span><br><span class="line">result = scanner.findInLine(&quot;study&quot;);</span><br><span class="line">System.out.println(&quot;findInLine(): &quot; + result); // 输出 &quot;study&quot;</span><br><span class="line">// 使用 findWithinHorizon() 方法查找字符串中的单词</span><br><span class="line">scanner = new Scanner(input);</span><br><span class="line">result = scanner.findWithinHorizon(&quot;study&quot;, 20);</span><br><span class="line">System.out.println(&quot;findWithinHorizon(): &quot; + result); // 输出 &quot;study&quot;</span><br><span class="line">scanner.close(); // 关闭 Scanner 对象</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们首先创建了一个字符串 input，表示要查找的文本。然后，我们使用 Scanner 类的构造方法创建 Scanner 对象，并将 input 作为输入流传递给该对象。接着，我们使用 findInLine() 方法和 findWithinHorizon() 方法分别查找字符串中的单词 “study”。其中， findInLine() 方法在当前行中查找匹配项，而 findWithinHorizon() 方法在指定的限制范围内查找匹配项。在本例中，我们将查找的范围<br>限制为前 20 个字符。</p>
<p>需要注意的是， findInLine() 方法和 findWithinHorizon() 方法都返回找到的匹配项。如果没有找到匹配项，则返回 null。此外， findInLine() 方法和 findWithinHorizon() 方法都会忽略默认的分隔符，因此需要使用正则表达式来指定查找的模式。在本例中，我们使用了字符串 “study” 作为查找的模式。</p>
<p>当然我们也可以使用正则表达式，比如说我们要在下面的文件中查找 openjdk 这个关键字。</p>
<p><img src="\assets\note\image-20231012142449036.png" alt="image-20231012142449036"></p>
<p>代码就可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 创建 File 对象，表示要扫描的文件</span><br><span class="line">Scanner scanner = new Scanner(new File(&quot;docs/安装环境.md&quot;)); // 创建 Scanner 对象，从文</span><br><span class="line">件中读取数据</span><br><span class="line">Pattern pattern = Pattern.compile(&quot;op..jdk&quot;);</span><br><span class="line">String result;</span><br><span class="line">while ((result = scanner.findWithinHorizon(pattern, 0)) != null) &#123;</span><br><span class="line">    System.out.println(&quot;findWithinHorizon(): &quot; + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们用正则表达式 pattern 来表示 openjdk 这个关键字， op..jdk 中的 . 表示任意字符，可以通过查找正则表达式去了解。</p>
<p>然后我们使用 while 循环来查找文件中所有的 openjdk ，其中 findWithinHorizon 方法的第二个参数如果为 0 则表示忽略边界，如果没找到，会返回 null。</p>
<p><img src="\assets\note\image-20231012142541300.png" alt="image-20231012142541300"></p>
<p>由于文件中有两个 openjdk 关键字，所以输出结果如下所示：</p>
<p><img src="\assets\note\image-20231012142557757.png" alt="image-20231012142557757"></p>
<p><strong>04、小结 </strong></p>
<p>总之，Scanner 类是一个功能强大的输入处理工具类，不仅可以扫描控制台的输入流，还可以扫描文件，并且提供了多种方法来读取不同类型的数据，比如 next() , nextInt() , nextLine() , nextDouble() 等。</p>
<p>除此之外，还可以通过 useDelimiter() 方法设置分隔符，通过 findInLine() , findWithinHorizon() 查找匹配项等。</p>
<h2 id="7-2-Arrays工具类"><a href="#7-2-Arrays工具类" class="headerlink" title="7.2 Arrays工具类"></a>7.2 Arrays工具类</h2><p>“哥，数组专用工具类是专门用来操作数组的吗？比如说创建数组、数组排序、数组检索等等。”三妹的提问其实已经把答案说了出来。</p>
<p>“是滴，这里说的数组专用工具类指的是 java.util.Arrays 类，基本上常见的数组操作，这个类都提供了静态方法可供直接调用。毕竟数组本身想完成这些操作还是挺麻烦的，有了这层封装，就方便多了。”在回答三妹的同时，我打开 Intellij IDEA，找到了 Arrays 类的源码。</p>
<p>“具体来说，数组操作可分为以下 9 种。”</p>
<ul>
<li>创建数组</li>
<li>比较数组</li>
<li>数组排序</li>
<li>数组检索</li>
<li>数组转流</li>
<li>打印数组</li>
<li>数组转 List</li>
<li>setAll（没想好中文名）</li>
<li>parallelPrefix（没想好中文名）</li>
</ul>
<p>“我们来一个一个学习。”</p>
<p><strong>01、创建数组 </strong></p>
<p>使用 Arrays 类创建数组可以通过以下三个方法：</p>
<ul>
<li>copyOf，复制指定的数组，截取或用 null 填充</li>
<li>copyOfRange，复制指定范围内的数组到一个新的数组</li>
<li>fill，对数组进行填充</li>
</ul>
<p><strong>1）copyOf </strong></p>
<p>直接来看例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String[] intro = new String[] &#123; &quot;沉&quot;, &quot;默&quot;, &quot;王&quot;, &quot;二&quot; &#125;;</span><br><span class="line">String[] revised = Arrays.copyOf(intro, 3);</span><br><span class="line">String[] expanded = Arrays.copyOf(intro, 5);</span><br><span class="line">System.out.println(Arrays.toString(revised));</span><br><span class="line">System.out.println(Arrays.toString(expanded));</span><br></pre></td></tr></table></figure>
<p>revised 和 expanded 是复制后的新数组，长度分别是 3 和 5，指定的数组长度是 4。来看一下输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[沉, 默, 王]</span><br><span class="line">[沉, 默, 王, 二, null]</span><br></pre></td></tr></table></figure>
<p>看到没？revised 截取了最后一位，因为长度是 3 嘛；expanded 用 null 填充了一位，因为长度是 5。</p>
<p>ArrayList（内部的数据结构用的就是数组）源码中的 grow() 方法就调用了 copyOf() 方法：当 ArrayList 初始大小不满足元素的增长时就会扩容。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private Object[] grow(int minCapacity) &#123;</span><br><span class="line">    return elementData = Arrays.copyOf(elementData,</span><br><span class="line">            newCapacity(minCapacity));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2）copyOfRange </strong></p>
<p>直接来看例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] intro = new String[] &#123; &quot;沉&quot;, &quot;默&quot;, &quot;王&quot;, &quot;二&quot; &#125;;</span><br><span class="line">String[] abridgement = Arrays.copyOfRange(intro, 0, 3);</span><br><span class="line">System.out.println(Arrays.toString(abridgement));</span><br></pre></td></tr></table></figure>
<p>copyOfRange() 方法需要三个参数，第一个是指定的数组，第二个是起始位置（包含），第三个是截止位置（不包含）。来看一下输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[沉, 默, 王]</span><br></pre></td></tr></table></figure>
<p>0 的位置是“沉”，3 的位置是“二”，也就是说截取了从 0 位（包含）到 3 位（不包含）的数组元素。那假如说下标超出了数组的长度，会发生什么呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] abridgementExpanded = Arrays.copyOfRange(intro, 0, 6);</span><br><span class="line">System.out.println(Arrays.toString(abridgementExpanded));</span><br></pre></td></tr></table></figure>
<p>结束位置此时为 6，超出了指定数组的长度 4，来看一下输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[沉, 默, 王, 二, null, null]</span><br></pre></td></tr></table></figure>
<p>仍然使用了 null 进行填充。</p>
<p>“为什么要这么做呢？”经过这段时间的学习，三妹的眼光越来越毒辣了，问的问题都恰到好处。</p>
<p>“嗯，我想是 Arrays 的设计者考虑到了数组越界的问题，不然每次调用 Arrays 类就要先判断很多次长度，很麻烦。”稍作思考后，我给出了这样一个回答。</p>
<p><strong>3）fill </strong></p>
<p>直接来看例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] stutter = new String[4];</span><br><span class="line">Arrays.fill(stutter, &quot;沉默王二&quot;);</span><br><span class="line">System.out.println(Arrays.toString(stutter));</span><br></pre></td></tr></table></figure>
<p>使用 new 关键字创建了一个长度为 4 的数组，然后使用 fill() 方法将 4 个位置填充为“沉默王二”，来看一下输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[沉默王二, 沉默王二, 沉默王二, 沉默王二]</span><br></pre></td></tr></table></figure>
<p>如果想要一个元素完全相同的数组时， fill() 方法就派上用场了。</p>
<p><strong>02、比较数组 </strong></p>
<p>Arrays 类的 equals() 方法用来判断两个数组是否相等，来看下面这个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String[] intro = new String[] &#123; &quot;沉&quot;, &quot;默&quot;, &quot;王&quot;, &quot;二&quot; &#125;;</span><br><span class="line">boolean result = Arrays.equals(new String[] &#123; &quot;沉&quot;, &quot;默&quot;, &quot;王&quot;, &quot;二&quot; &#125;, intro);</span><br><span class="line">System.out.println(result);</span><br><span class="line">boolean result1 = Arrays.equals(new String[] &#123; &quot;沉&quot;, &quot;默&quot;, &quot;王&quot;, &quot;三&quot; &#125;, intro);</span><br><span class="line">System.out.println(result1);</span><br></pre></td></tr></table></figure>
<p>输出结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure>
<p>指定的数组为沉默王二四个字，比较的数组一个是沉默王二，一个是沉默王三，所以 result 为 true，result1 为 false。</p>
<p>简单看一下 equals() 方法的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static boolean equals(Object[] a, Object[] a2) &#123;</span><br><span class="line">    if (a==a2)</span><br><span class="line">        return true;</span><br><span class="line">    if (a==null || a2==null)</span><br><span class="line">        return false;</span><br><span class="line">    int length = a.length;</span><br><span class="line">    if (a2.length != length)</span><br><span class="line">        return false;</span><br><span class="line">    for (int i=0; i&lt;length; i++) &#123;</span><br><span class="line">        if (!Objects.equals(a[i], a2[i]))</span><br><span class="line">            return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为数组是一个对象，所以先使用“\==”操作符进行判断，如果不相等，再判断是否为 null，其中一个为 null，返回 false；紧接着判断 length，不等的话，返回 false；否则的话，依次调用 Objects.equals() 比较相同位置上的元素是否相等。</p>
<p>“这段代码还是非常严谨的，对吧？三妹，这也就是我们学习源码的意义，欣赏的同时，可以学习源码作者清晰的编码思路。”我语重心长地给三妹讲。</p>
<p>除了 equals() 方法，还有另外一个诀窍可以判断两个数组是否相等，尽管可能会出现误差。那就是 Arrays.hashCode() 方法，先来看一下该方法的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static int hashCode(Object a[]) &#123;</span><br><span class="line">    if (a == null)</span><br><span class="line">        return 0;</span><br><span class="line">    int result = 1;</span><br><span class="line">    for (Object element : a)</span><br><span class="line">        result = 31 * result + (element == null ? 0 : element.hashCode());</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>哈希算法本身是非常严谨的，所以如果两个数组的哈希值相等，那几乎可以判断两个数组是相等的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] intro = new String[] &#123; &quot;沉&quot;, &quot;默&quot;, &quot;王&quot;, &quot;二&quot; &#125;;</span><br><span class="line">System.out.println(Arrays.hashCode(intro));</span><br><span class="line">System.out.println(Arrays.hashCode(new String[] &#123; &quot;沉&quot;, &quot;默&quot;, &quot;王&quot;, &quot;二&quot; &#125;));</span><br></pre></td></tr></table></figure>
<p>来看一下输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">868681617</span><br><span class="line">868681617</span><br></pre></td></tr></table></figure>
<p>两个数组的哈希值相等，毕竟元素是一样的。但这样确实不够严谨，优先使用 Objects.equals() 方法，当我们想快速确认两个数组是否相等时，可以通过比较 hashCode 来确认——算是投机取巧吧，高收益高风险，哈哈。</p>
<p><strong>03、数组排序 </strong></p>
<p>Arrays 类的 sort() 方法用来对数组进行排序，来看下面这个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] intro1 = new String[] &#123; &quot;chen&quot;, &quot;mo&quot;, &quot;wang&quot;, &quot;er&quot; &#125;;</span><br><span class="line">String[] sorted = Arrays.copyOf(intro1, 4);</span><br><span class="line">Arrays.sort(sorted);</span><br><span class="line">System.out.println(Arrays.toString(sorted));</span><br></pre></td></tr></table></figure>
<p>由于排序会改变原有的数组，所以我们使用了 copyOf() 方法重新复制了一份。来看一下输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[chen, er, mo, wang]</span><br></pre></td></tr></table></figure>
<p>可以看得出，按照的是首字母的升序进行排列的。基本数据类型是按照双轴快速排序的，引用数据类型是按照 TimSort 排序的，使用了 Peter McIlroy 的“乐观排序和信息理论复杂性”中的技术。</p>
<p>“哥，你说的这些排序算法我都不太懂啊！”三妹眨巴眨巴眼睛说。</p>
<p>“不要紧的，后面学了数据结构与算法后，就明白了，现在了解这个东西即可。”我赶紧甩出了安抚大法。</p>
<p><strong>04、数组检索 </strong></p>
<p>数组排序后就可以使用 Arrays 类的 binarySearch() 方法进行二分查找了。否则的话，只能线性检索，效率就会低很多。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String[] intro1 = new String[] &#123; &quot;chen&quot;, &quot;mo&quot;, &quot;wang&quot;, &quot;er&quot; &#125;;</span><br><span class="line">String[] sorted = Arrays.copyOf(intro1, 4);</span><br><span class="line">Arrays.sort(sorted);</span><br><span class="line">int exact = Arrays.binarySearch(sorted, &quot;wang&quot;);</span><br><span class="line">System.out.println(exact);</span><br><span class="line">int caseInsensitive = Arrays.binarySearch(sorted, &quot;Wang&quot;, </span><br><span class="line">String::compareToIgnoreCase);</span><br><span class="line">System.out.println(caseInsensitive);</span><br></pre></td></tr></table></figure>
<p> binarySearch() 方法既可以精确检索，也可以模糊检索，比如说忽略大小写。来看一下输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p>排序后的结果是 [chen, er, mo, wang] ，所以检索出来的下标是 3。</p>
<p>“三妹，记住了，以后如果要从数组或者集合中查找元素的话，尽量先排序，然后使用二分查找法，这样能提高检索的效率。”</p>
<p>三妹若有所思的点了点头。</p>
<p><strong>05、数组转流 </strong></p>
<p>“流是什么呀？”三妹好奇的问。</p>
<p>“流的英文单词是 Stream，它可以极大提高 Java 程序员的生产力，让程序员写出高效、干净、简洁的代码。 这种风格将要处理的集合看作是一种流，想象一下水流在管道中流过的样子，我们可以在管道中对流进行处理，比如筛选、排序等等。Stream 具体怎么使用，我们留到后面再详细地讲，这里你先有一个大致的印象就可以了。”我回答到。</p>
<p>Arrays 类的 stream() 方法可以将数组转换成流：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] intro = new String[] &#123; &quot;沉&quot;, &quot;默&quot;, &quot;王&quot;, &quot;二&quot; &#125;;</span><br><span class="line">System.out.println(Arrays.stream(intro).count());</span><br></pre></td></tr></table></figure>
<p>还可以为 stream() 方法指定起始下标和结束下标：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Arrays.stream(intro, 1, 2).count());</span><br></pre></td></tr></table></figure>
<p>如果下标的范围有误的时候，比如说从 2 到 1 结束，则程序会抛出 ArrayIndexOutOfBoundsException 异常：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.ArrayIndexOutOfBoundsException: origin(2) &gt; </span><br><span class="line">fence(1)</span><br><span class="line">    at java.base/java.util.Spliterators.checkFromToBounds(Spliterators.java:387)</span><br></pre></td></tr></table></figure>
<p><strong>06、打印数组 </strong></p>
<p>因为数组是一个对象，直接 System.out.println 的话，结果是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Ljava.lang.String;@3d075dc0</span><br></pre></td></tr></table></figure>
<p>最优雅的打印方式，是使用 Arrays.toString() ，其实前面讲过。来看一下该方法的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static String toString(Object[] a) &#123;</span><br><span class="line">    if (a == null)</span><br><span class="line">        return &quot;null&quot;;</span><br><span class="line">    int iMax = a.length - 1;</span><br><span class="line">    if (iMax == -1)</span><br><span class="line">        return &quot;[]&quot;;</span><br><span class="line">    StringBuilder b = new StringBuilder();</span><br><span class="line">    b.append(&#x27;[&#x27;);</span><br><span class="line">    for (int i = 0; ; i++) &#123;</span><br><span class="line">        b.append(String.valueOf(a[i]));</span><br><span class="line">        if (i == iMax)</span><br><span class="line">            return b.append(&#x27;]&#x27;).toString();</span><br><span class="line">        b.append(&quot;, &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>先判断 null，是的话，直接返回“null”字符串；</li>
<li>获取数组的长度，如果数组的长度为 0（ 等价于 length - 1 为 -1），返回中括号“[]”，表示数组为空的；</li>
<li>如果数组既不是 null，长度也不为 0，就声明 StringBuilder 对象，然后添加一个数组的开始标记“[”，之后再遍历数组，把每个元素添加进去；其中一个小技巧就是，当遇到末尾元素的时候（i == iMax），不再添加逗号和空格“, ”，而是添加数组的闭合标记“]”。</li>
</ul>
<p>“哥，我能不能问一个问题呀？”</p>
<p>“你问啊。”</p>
<p>“就是为什么判断数组长度为 0 的时候判断的是减 1 后比较 -1 呢？为什么不直接比较 0 呢？”</p>
<p>“呀，你这个问题问的很妙啊！”我想到三妹说一句“respect”，很强！“其实是和遍历数组的时候判断 i == iMax 有关了，否则这里就要用 i == iMax -1 来判断是否到达数组的最后一个元素了。”</p>
<p>“哦—————”三妹似乎明白了什么。</p>
<p><strong>07、数组转 List </strong></p>
<p>尽管数组非常强大，但它自身可以操作的工具方法很少，比如说判断数组中是否包含某个值。如果能转成 List 的话，就简便多了，因为 Java 的集合框架 List 中封装了很多常用的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] intro = new String[] &#123; &quot;沉&quot;, &quot;默&quot;, &quot;王&quot;, &quot;二&quot; &#125;;</span><br><span class="line">List&lt;String&gt; rets = Arrays.asList(intro);</span><br><span class="line">System.out.println(rets.contains(&quot;二&quot;));</span><br></pre></td></tr></table></figure>
<p>不过需要注意的是， Arrays.asList() 返回的是 java.util.Arrays.ArrayList ，并不是 java.util.ArrayList ，它的长度是固定的，无法进行元素的删除或者添加。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rets.add(&quot;三&quot;);</span><br><span class="line">rets.remove(&quot;二&quot;);</span><br></pre></td></tr></table></figure>
<p>这个在编码的时候一定要注意，否则在执行这两个方法的时候，会抛出异常：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException</span><br><span class="line">    at java.base/java.util.AbstractList.add(AbstractList.java:153)</span><br><span class="line">    at java.base/java.util.AbstractList.add(AbstractList.java:111)</span><br></pre></td></tr></table></figure>
<p>要想操作元素的话，需要多一步转化，转成真正的 java.util.ArrayList ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; rets1 = new ArrayList&lt;&gt;(Arrays.asList(intro));</span><br><span class="line">rets1.add(&quot;三&quot;);</span><br><span class="line">rets1.remove(&quot;二&quot;);</span><br></pre></td></tr></table></figure>
<p><strong>08、setAll </strong></p>
<p>Java 8 新增了 setAll() 方法，它提供了一个函数式编程的入口，可以对数组的元素进行填充：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int[] array = new int[10];</span><br><span class="line">Arrays.setAll(array, i -&gt; i * 10);</span><br><span class="line">System.out.println(Arrays.toString(array));</span><br></pre></td></tr></table></figure>
<p>“这段代码什么意思呢？”三妹问。</p>
<p>i 就相当于是数组的下标，值从 0 开始，到 9 结束，那么 i <em> 10 就意味着值从 0 </em> 10 开始，到 9 * 10 结束，来看一下输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0, 10, 20, 30, 40, 50, 60, 70, 80, 90]</span><br></pre></td></tr></table></figure>
<p>可以用来为新数组填充基于原来数组的新元素。</p>
<p><strong>09、parallelPrefix </strong></p>
<p>parallelPrefix() 方法和 setAll() 方法一样，也是 Java 8 之后提供的，提供了一个函数式编程的入口，通过遍历数组中的元素，将当前下标位置上的元素与它之前下标的元素进行操作，然后将操作后的结果覆盖当前下标位置上的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int[] arr = new int[] &#123; 1, 2, 3, 4&#125;;</span><br><span class="line">Arrays.parallelPrefix(arr, (left, right) -&gt; left + right);</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br></pre></td></tr></table></figure>
<p>上面代码中有一个 Lambda 表达式（ (left, right) -&gt; left + right ），是什么意思呢？上面这段代码等同于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int[] arr = new int[]&#123;1, 2, 3, 4&#125;;</span><br><span class="line">Arrays.parallelPrefix(arr, (left, right) -&gt; &#123;</span><br><span class="line">    System.out.println(left + &quot;，&quot; + right);</span><br><span class="line">    return left + right;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br></pre></td></tr></table></figure>
<p>来看一下输出结果就明白了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1，2</span><br><span class="line">3，3</span><br><span class="line">6，4</span><br><span class="line">[1, 3, 6, 10]</span><br></pre></td></tr></table></figure>
<p>也就是说， Lambda 表达式执行了三次：</p>
<ul>
<li>第一次是 1 和 2 相加，结果是 3，替换下标为 1 的位置</li>
<li>第二次是 3 和 3 相加，结果是 6，也就是第一次的结果和下标为 2 的元素相加的结果</li>
<li>第三次是 6 和 4 相加，结果是 10，也就是第二次的结果和下标为 3 的元素相加的结果</li>
</ul>
<p><strong>10、总结 </strong></p>
<p>“好了，三妹，就先学到这吧。如果你以后翻 Java 源码的时候，只要是用到数组的，尤其是 ArrayList 类，就可以看到 Arrays 类的很多影子。”</p>
<p>“嗯嗯，我先复习一下这节的内容。哥，你去休息吧。”</p>
<h2 id="7-3-StringUtils工具类"><a href="#7-3-StringUtils工具类" class="headerlink" title="7.3 StringUtils工具类"></a>7.3 StringUtils工具类</h2><p>字符串 （String）在我们的日常工作中，用得非常非常非常多。</p>
<p>在我们的代码中经常需要对字符串判空，截取字符串、转换大小写、分隔字符串、比较字符串、去掉多余空格、拼接字符串、使用正则表达式等等。</p>
<p>如果只用 String 类提供的那些方法，我们需要手写大量的额外代码，不然容易出现各种异常。</p>
<p>现在有个好消息是： org.apache.commons.lang3包下的 StringUtils工具类，给我们提供了非常丰富的选择。</p>
<p>Maven 坐标：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.12.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>StringUtils 提供了非常多实用的方法，大概有下图的四页到五页，我只截了两页，实在是太多了。</p>
<p><img src="\assets\note\image-20231012144531912.png" alt="image-20231012144531912"></p>
<p>接下来，我们来拿一些常用的方法举例说明。</p>
<p><strong>字符串判空 </strong></p>
<p>其实空字符串，不只是 null 一种，还有””，” “，”null”等等，多种情况。</p>
<p>StringUtils 给我们提供了多个判空的静态方法，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">String str1 = null;</span><br><span class="line">String str2 = &quot;&quot;;</span><br><span class="line">String str3 = &quot; &quot;;</span><br><span class="line">String str4 = &quot;abc&quot;;</span><br><span class="line">System.out.println(StringUtils.isEmpty(str1));</span><br><span class="line">System.out.println(StringUtils.isEmpty(str2));</span><br><span class="line">System.out.println(StringUtils.isEmpty(str3));</span><br><span class="line">System.out.println(StringUtils.isEmpty(str4));</span><br><span class="line">System.out.println(&quot;=====&quot;);</span><br><span class="line">System.out.println(StringUtils.isNotEmpty(str1));</span><br><span class="line">System.out.println(StringUtils.isNotEmpty(str2));</span><br><span class="line">System.out.println(StringUtils.isNotEmpty(str3));</span><br><span class="line">System.out.println(StringUtils.isNotEmpty(str4));</span><br><span class="line">System.out.println(&quot;=====&quot;);</span><br><span class="line">System.out.println(StringUtils.isBlank(str1));</span><br><span class="line">System.out.println(StringUtils.isBlank(str2));</span><br><span class="line">System.out.println(StringUtils.isBlank(str3));</span><br><span class="line">System.out.println(StringUtils.isBlank(str4));</span><br><span class="line">System.out.println(&quot;=====&quot;);</span><br><span class="line">System.out.println(StringUtils.isNotBlank(str1));</span><br><span class="line">System.out.println(StringUtils.isNotBlank(str2));</span><br><span class="line">System.out.println(StringUtils.isNotBlank(str3));</span><br><span class="line">System.out.println(StringUtils.isNotBlank(str4));</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">true</span><br><span class="line">false</span><br><span class="line">false</span><br><span class="line">=====</span><br><span class="line">false</span><br><span class="line">false</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">=====</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">false</span><br><span class="line">=====</span><br><span class="line">false</span><br><span class="line">false</span><br><span class="line">false</span><br><span class="line">true</span><br></pre></td></tr></table></figure>
<p>示例中的： isEmpty 、 isNotEmpty 、 isBlank和 isNotBlank ，这 4 个判空方法你们可以根据实际情况使用。</p>
<p>优先推荐使用 isBlank和 isNotBlank方法，因为它会把 “ “也考虑进去。</p>
<p><strong>分隔字符串 </strong></p>
<p>分隔字符串是常见需求，如果直接使用 String 类的 split 方法，就可能会出现空指针异常。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str1 = null;</span><br><span class="line">System.out.println(StringUtils.split(str1,&quot;,&quot;));</span><br><span class="line">System.out.println(str1.split(&quot;,&quot;));</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">null</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.NullPointerException</span><br><span class="line">\tat com.sue.jump.service.test1.UtilTest.main(UtilTest.java:21)</span><br></pre></td></tr></table></figure>
<p>使用 StringUtils 的 split 方法会返回 null，而使用 String 的 split 方法会报指针异常。</p>
<p><strong>判断是否纯数字 </strong></p>
<p>给定一个字符串，判断它是否为纯数字，可以使用 isNumeric方法。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String str1 = &quot;123&quot;;</span><br><span class="line">String str2 = &quot;123q&quot;;</span><br><span class="line">String str3 = &quot;0.33&quot;;</span><br><span class="line">System.out.println(StringUtils.isNumeric(str1));</span><br><span class="line">System.out.println(StringUtils.isNumeric(str2));</span><br><span class="line">System.out.println(StringUtils.isNumeric(str3));</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br><span class="line">false</span><br></pre></td></tr></table></figure>
<p><strong>将集合拼接成字符串 </strong></p>
<p>有时候，我们需要将某个集合的内容，拼接成一个字符串，然后输出，这时可以使用 join方法。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Lists.newArrayList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</span><br><span class="line">List&lt;Integer&gt; list2 = Lists.newArrayList(1, 2, 3);</span><br><span class="line">System.out.println(StringUtils.join(list, &quot;,&quot;));</span><br><span class="line">System.out.println(StringUtils.join(list2, &quot; &quot;));</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a,b,c</span><br><span class="line">1 2 3</span><br></pre></td></tr></table></figure>
<p><strong>其他方法 </strong></p>
<p>这里再列举一些，其他的方法可以自己去研究一下。</p>
<ul>
<li>trim(String str) ：去除字符串首尾的空白字符。</li>
<li>trimToEmpty(String str) ：去除字符串首尾的空白字符，如果字符串为 null，则返回空字符串。</li>
<li>trimToNull(String str) ：去除字符串首尾的空白字符，如果结果为空字符串，则返回 null。</li>
<li>equals(String str1, String str2) ：比较两个字符串是否相等。</li>
<li>equalsIgnoreCase(String str1, String str2) ：比较两个字符串是否相等，忽略大小写。</li>
<li>startsWith(String str, String prefix) ：检查字符串是否以指定的前缀开头。</li>
<li>endsWith(String str, String suffix) ：检查字符串是否以指定的后缀结尾。</li>
<li>contains(String str, CharSequence seq) ：检查字符串是否包含指定的字符序列。</li>
<li>indexOf(String str, CharSequence seq) ：返回指定字符序列在字符串中首次出现的索引，如果没有找到，则返回 -1。</li>
<li>lastIndexOf(String str, CharSequence seq) ：返回指定字符序列在字符串中最后一次出现的索引，如果没有找到，则返回 -1。</li>
<li>substring(String str, int start, int end) ：截取字符串中指定范围的子串。</li>
<li>replace(String str, String searchString, String replacement) ：替换字符串中所有出现的搜索字符串为指定的替换字符串。</li>
<li>replaceAll(String str, String regex, String replacement) ：使用正则表达式替换字符串中所有匹配的部分。</li>
<li>join(Iterable&lt;?&gt; iterable, String separator) ：使用指定的分隔符将可迭代对象中的元素连接为一个字符串。</li>
<li>split(String str, String separator) ：使用指定的分隔符将字符串分割为一个字符串数组。</li>
<li>capitalize(String str) ：将字符串的第一个字符转换为大写。</li>
<li>uncapitalize(String str) ：将字符串的第一个字符转换为小写。</li>
</ul>
<h2 id="7-4-Objects工具类"><a href="#7-4-Objects工具类" class="headerlink" title="7.4 Objects工具类"></a>7.4 Objects工具类</h2><p>Java 的 Objects 类是一个实用工具类，包含了一系列静态方法，用于处理对象。它位于 java.util 包中，自 Java 7 引入。Objects 类的主要目的是降低代码中的空指针异常 (NullPointerException) 风险，同时提供一些非常实用的方法供我们使用。</p>
<p><strong>对象判空 </strong></p>
<p>在 Java 中，万物皆对象，对象的判空可以说无处不在。Objects 的 isNull 方法用于判断对象是否为空，而 nonNull 方法判断对象是否不为空。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Integer integer = new Integer(1);</span><br><span class="line">if (Objects.isNull(integer)) &#123;</span><br><span class="line">    System.out.println(&quot;对象为空&quot;);</span><br><span class="line">&#125;</span><br><span class="line">if (Objects.nonNull(integer)) &#123;</span><br><span class="line">    System.out.println(&quot;对象不为空&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>对象为空时抛异常 </strong></p>
<p>如果我们想在对象为空时，抛出空指针异常，可以使用 Objects 的 requireNonNull 方法。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer integer1 = new Integer(128);</span><br><span class="line">Objects.requireNonNull(integer1);</span><br><span class="line">Objects.requireNonNull(integer1, &quot;参数不能为空&quot;);</span><br><span class="line">Objects.requireNonNull(integer1, () -&gt; &quot;参数不能为空&quot;);</span><br></pre></td></tr></table></figure>
<p><strong>判断两个对象是否相等 </strong></p>
<p>我们经常需要判断两个对象是否相等，Objects 给我们提供了 equals 方法，能非常方便的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer integer1 = new Integer(1);</span><br><span class="line">Integer integer2 = new Integer(1);</span><br><span class="line">System.out.println(Objects.equals(integer1, integer2));</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure>
<p>但使用这个方法有坑，比如例子改成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer integer1 = new Integer(1);</span><br><span class="line">Long integer2 = new Long(1);</span><br><span class="line">System.out.println(Objects.equals(integer1, integer2));</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">false</span><br></pre></td></tr></table></figure>
<p>不过，需要注意的是，虽然 Objects.equals() 方法本身是用来避免坑的，因为它可以处理 null 值的比较，而不会抛出空指针异常。然而，这并不意味着它没有任何潜在问题。实际上， Objects.equals() 方法的一个潜在问题是依赖于被比较对象的 equals() 方法实现。</p>
<p>当两个对象的类没有正确实现 equals() 方法时， Objects.equals() 方法可能会产生不符合预期的结果。举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class ObjectsDemo1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person person1 = new Person(&quot;沉默王二&quot;, 18);</span><br><span class="line">        Person person2 = new Person(&quot;沉默王二&quot;, 18);</span><br><span class="line">        System.out.println(Objects.equals(person1, person2)); // 输出：false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Person &#123;</span><br><span class="line">    String name;</span><br><span class="line">    int age;</span><br><span class="line">    Person(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，我们创建了一个名为 Person 的类，但是没有重写 equals() 方法。然后我们创建了两个具有相同属性的 Person 对象，并使用 Objects.equals() 方法比较它们。尽管这两个对象的属性是相同的，但输出结果却是 false。这是因为 Objects.equals() 方法依赖于对象的 equals() 方法，而在这个例子中，Person 类没有正确地实现 equals() 方法，所以默认情况下会使用 Object 类的 equals() 方法，它只比较对象引用是否相同。</p>
<p>为了解决这个问题，我们需要在 Person 类中重写 equals() 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">    if (this == obj) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (obj == null || getClass() != obj.getClass()) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    Person person = (Person) obj;</span><br><span class="line">    return age == person.age &amp;&amp; Objects.equals(name, person.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，当我们使用 Objects.equals() 方法比较两个具有相同属性的 Person 对象时，输出将是 true，符合我们的预期。</p>
<p><strong>获取对象的hashCode </strong></p>
<p>如果你想获取某个对象的 hashCode，可以使用 Objects 的 hashCode 方法。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = new String(&quot;沉默王二&quot;);</span><br><span class="line">System.out.println(Objects.hashCode(str));</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">867758096</span><br></pre></td></tr></table></figure>
<p><strong>比较两个对象 </strong></p>
<p>compare() 方法用于比较两个对象，通常用于自定义排序。它需要一个比较器 (Comparator) 作为参数。如果比较器为 null，则使用自然顺序。以下是一个 compare() 方法的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class ObjectsCompareDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        PersonCompare person1 = new PersonCompare(&quot;itwanger&quot;, 30);</span><br><span class="line">        PersonCompare person2 = new PersonCompare(&quot;chenqingyang&quot;, 25);</span><br><span class="line">        Comparator&lt;PersonCompare&gt; ageComparator = Comparator.comparingInt(p -&gt; </span><br><span class="line">p.age);</span><br><span class="line">        int ageComparisonResult = Objects.compare(person1, person2, ageComparator);</span><br><span class="line">        System.out.println(&quot;年龄排序: &quot; + ageComparisonResult); // 输出：1（表示 </span><br><span class="line">person1 的 age 在 person2 之后）</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class PersonCompare &#123;</span><br><span class="line">    String name;</span><br><span class="line">    int age;</span><br><span class="line">    PersonCompare(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>比较两个数组 </strong></p>
<p>deepEquals() 用于比较两个数组类型的对象，当对象是非数组的话，行为和 equals() 一致。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int[] array1 = &#123;1, 2, 3&#125;;</span><br><span class="line">int[] array2 = &#123;1, 2, 3&#125;;</span><br><span class="line">int[] array3 = &#123;1, 2, 4&#125;;</span><br><span class="line">System.out.println(Objects.deepEquals(array1, array2)); // 输出：true（因为 array1 和 array2 的内容相同）</span><br><span class="line">System.out.println(Objects.deepEquals(array1, array3)); // 输出：false（因为 array1 和 array3 的内容不同）</span><br><span class="line">// 对于非数组对象，deepEquals() 的行为与 equals() 相同</span><br><span class="line">String string1 = &quot;hello&quot;;</span><br><span class="line">String string2 = &quot;hello&quot;;</span><br><span class="line">String string3 = &quot;world&quot;;</span><br><span class="line">System.out.println(Objects.deepEquals(string1, string2)); // 输出：true（因为 string1 和 string2 相同）</span><br><span class="line">System.out.println(Objects.deepEquals(string1, string3)); // 输出：false（因为 string1 和 string3 不同）</span><br></pre></td></tr></table></figure>
<p>再来个二维数组的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String[][] nestedArray1 = &#123;&#123;&quot;A&quot;, &quot;B&quot;&#125;, &#123;&quot;C&quot;, &quot;D&quot;&#125;&#125;;</span><br><span class="line">String[][] nestedArray2 = &#123;&#123;&quot;A&quot;, &quot;B&quot;&#125;, &#123;&quot;C&quot;, &quot;D&quot;&#125;&#125;;</span><br><span class="line">String[][] nestedArray3 = &#123;&#123;&quot;A&quot;, &quot;B&quot;&#125;, &#123;&quot;C&quot;, &quot;E&quot;&#125;&#125;;</span><br><span class="line">System.out.println(Objects.deepEquals(nestedArray1, nestedArray2)); // 输出：true (因为嵌套数组元素相同)</span><br><span class="line">System.out.println(Objects.deepEquals(nestedArray1, nestedArray3)); // 输出：false (因为嵌套数组元素不同)</span><br></pre></td></tr></table></figure>
<p><strong>小结 </strong></p>
<p>除了上面提到的这些方法，Objects 还提供了一些其他的方法，比如说 toString，感兴趣的话可以试一下。</p>
<p><img src="\assets\note\image-20231012145518757.png" alt="image-20231012145518757"></p>
<p>总之，Objects 类提供的这些方法在许多情况下还是非常有用得，可以简化代码并减少出错的可能性。</p>
<h2 id="7-5-Collections工具类"><a href="#7-5-Collections工具类" class="headerlink" title="7.5 Collections工具类"></a>7.5 Collections工具类</h2><p>Collections 是 JDK 提供的一个工具类，位于 java.util 包下，提供了一系列的静态方法，方便我们对集合进行各种骚操作，算是集合框架的一个大管家。</p>
<p>还记得我们前面讲过的 Arrays 工具类吗？可以回去温习下。</p>
<p>Collections 的用法很简单，在 Intellij IDEA 中敲完 Collections. 之后就可以看到它提供的方法了，大致看一下方法名和参数就能知道这个方法是干嘛的。</p>
<p><img src="\assets\note\image-20231012145612062.png" alt="image-20231012145612062"></p>
<p>为了节省大家的学习时间，我将这些方法做了一些分类，并列举了一些简单的例子。</p>
<p><strong>01、排序操作 </strong></p>
<ul>
<li>reverse(List list) ：反转顺序</li>
<li>shuffle(List list) ：洗牌，将顺序打乱</li>
<li>sort(List list) ：自然升序</li>
<li>sort(List list, Comparator c) ：按照自定义的比较器排序</li>
<li>swap(List list, int i, int j) ：将 i 和 j 位置的元素交换位置</li>
</ul>
<p>来看例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list.add(&quot;沉默王二&quot;);</span><br><span class="line">list.add(&quot;沉默王三&quot;);</span><br><span class="line">list.add(&quot;沉默王四&quot;);</span><br><span class="line">list.add(&quot;沉默王五&quot;);</span><br><span class="line">list.add(&quot;沉默王六&quot;);</span><br><span class="line">System.out.println(&quot;原始顺序：&quot; + list);</span><br><span class="line">// 反转</span><br><span class="line">Collections.reverse(list);</span><br><span class="line">System.out.println(&quot;反转后：&quot; + list);</span><br><span class="line">// 洗牌</span><br><span class="line">Collections.shuffle(list);</span><br><span class="line">System.out.println(&quot;洗牌后：&quot; + list);</span><br><span class="line">// 自然升序</span><br><span class="line">Collections.sort(list);</span><br><span class="line">System.out.println(&quot;自然升序后：&quot; + list);</span><br><span class="line">// 交换</span><br><span class="line">Collections.swap(list, 2,4);</span><br><span class="line">System.out.println(&quot;交换后：&quot; + list);</span><br></pre></td></tr></table></figure>
<p>输出后：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原始顺序：[沉默王二, 沉默王三, 沉默王四, 沉默王五, 沉默王六]</span><br><span class="line">反转后：[沉默王六, 沉默王五, 沉默王四, 沉默王三, 沉默王二]</span><br><span class="line">洗牌后：[沉默王五, 沉默王二, 沉默王六, 沉默王三, 沉默王四]</span><br><span class="line">自然升序后：[沉默王三, 沉默王二, 沉默王五, 沉默王六, 沉默王四]</span><br><span class="line">交换后：[沉默王三, 沉默王二, 沉默王四, 沉默王六, 沉默王五]</span><br></pre></td></tr></table></figure>
<p><strong>02、查找操作 </strong></p>
<ul>
<li>binarySearch(List list, Object key) ：二分查找法，前提是 List 已经排序过了</li>
<li>max(Collection coll) ：返回最大元素</li>
<li>max(Collection coll, Comparator comp) ：根据自定义比较器，返回最大元素</li>
<li>min(Collection coll) ：返回最小元素</li>
<li>min(Collection coll, Comparator comp) ：根据自定义比较器，返回最小元素</li>
<li>fill(List list, Object obj) ：使用指定对象填充</li>
<li>frequency(Collection c, Object o) ：返回指定对象出现的次数</li>
</ul>
<p>来看例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;最大元素：&quot; + Collections.max(list));</span><br><span class="line">System.out.println(&quot;最小元素：&quot; + Collections.min(list));</span><br><span class="line">System.out.println(&quot;出现的次数：&quot; + Collections.frequency(list, &quot;沉默王二&quot;));</span><br><span class="line">// 没有排序直接调用二分查找，结果是不确定的</span><br><span class="line">System.out.println(&quot;排序前的二分查找结果：&quot; + Collections.binarySearch(list, &quot;沉默王</span><br><span class="line">二&quot;));</span><br><span class="line">Collections.sort(list);</span><br><span class="line">// 排序后，查找结果和预期一致</span><br><span class="line">System.out.println(&quot;排序后的二分查找结果：&quot; + Collections.binarySearch(list, &quot;沉默王</span><br><span class="line">二&quot;));</span><br><span class="line">Collections.fill(list, &quot;沉默王八&quot;);</span><br><span class="line">System.out.println(&quot;填充后的结果：&quot; + list);</span><br></pre></td></tr></table></figure>
<p>输出后：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">原始顺序：[沉默王二, 沉默王三, 沉默王四, 沉默王五, 沉默王六]</span><br><span class="line">最大元素：沉默王四</span><br><span class="line">最小元素：沉默王三</span><br><span class="line">出现的次数：1</span><br><span class="line">排序前的二分查找结果：0</span><br><span class="line">排序后的二分查找结果：1</span><br><span class="line">填充后的结果：[沉默王八, 沉默王八, 沉默王八, 沉默王八, 沉默王八]</span><br></pre></td></tr></table></figure>
<p><strong>03、同步控制 </strong></p>
<p>HashMap 是线程不安全的，这个我们前面讲到了。那其实 ArrayList 也是线程不安全的，没法在多线程环境下使用，那 Collections 工具类中提供了多个 synchronizedXxx 方法，这些方法会返回一个同步的对象，从而解决多线程中访问集合时的安全问题。</p>
<p><img src="\assets\note\image-20231012145844347.png" alt="image-20231012145844347"></p>
<p>使用起来也非常的简单：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SynchronizedList synchronizedList = Collections.synchronizedList(list);</span><br></pre></td></tr></table></figure>
<p>看一眼 SynchronizedList 的源码就明白了，不过是在方法里面使用 synchronized 关键字加了一层锁而已。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">static class SynchronizedList&lt;E&gt;</span><br><span class="line">    extends SynchronizedCollection&lt;E&gt;</span><br><span class="line">    implements List&lt;E&gt; &#123;</span><br><span class="line">    private static final long serialVersionUID = -7754090372962971524L;</span><br><span class="line">    final List&lt;E&gt; list;</span><br><span class="line">    SynchronizedList(List&lt;E&gt; list) &#123;</span><br><span class="line">        super(list); // 调用父类 SynchronizedCollection 的构造方法，传入 list</span><br><span class="line">        this.list = list; // 初始化成员变量 list</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取指定索引处的元素</span><br><span class="line">    public E get(int index) &#123;</span><br><span class="line">        synchronized (mutex) &#123;return list.get(index);&#125; // 加锁，调用 list 的 get 方法获</span><br><span class="line">取元素</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 在指定索引处插入指定元素</span><br><span class="line">    public void add(int index, E element) &#123;</span><br><span class="line">        synchronized (mutex) &#123;list.add(index, element);&#125; // 加锁，调用 list 的 add 方法</span><br><span class="line">插入元素</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 移除指定索引处的元素</span><br><span class="line">    public E remove(int index) &#123;</span><br><span class="line">        synchronized (mutex) &#123;return list.remove(index);&#125; // 加锁，调用 list 的 remove </span><br><span class="line">方法移除元素</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那这样的话，其实效率和那些直接在方法上加 synchronized 关键字的 Vector、Hashtable 差不多（JDK 1.0 时期就有了），而这些集合类基本上已经废弃了，几乎不怎么用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Vector&lt;E&gt;</span><br><span class="line">    extends AbstractList&lt;E&gt;</span><br><span class="line">    implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    // 获取指定索引处的元素</span><br><span class="line">    public synchronized E get(int index) &#123;</span><br><span class="line">        if (index &gt;= elementCount) // 如果索引超出了列表的大小，则抛出数组下标越界异常</span><br><span class="line">            throw new ArrayIndexOutOfBoundsException(index);</span><br><span class="line">        return elementData(index); // 返回指定索引处的元素</span><br><span class="line">    &#125;</span><br><span class="line">    // 移除指定索引处的元素</span><br><span class="line">    public synchronized E remove(int index) &#123;</span><br><span class="line">        modCount++; // 修改计数器，标识列表已被修改</span><br><span class="line">        if (index &gt;= elementCount) // 如果索引超出了列表的大小，则抛出数组下标越界异常</span><br><span class="line">            throw new ArrayIndexOutOfBoundsException(index);</span><br><span class="line">        E oldValue = elementData(index); // 获取指定索引处的元素</span><br><span class="line">        int numMoved = elementCount - index - 1; // 计算需要移动的元素个数</span><br><span class="line">        if (numMoved &gt; 0) // 如果需要移动元素</span><br><span class="line">            System.arraycopy(elementData, index+1, elementData, index,numMoved); // 将数组中的元素向左移动一位</span><br><span class="line">        elementData[--elementCount] = null; // 将最后一个元素设置为 null，等待垃圾回收</span><br><span class="line">        return oldValue; // 返回被移除的元素</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正确的做法是使用并发包下的 CopyOnWriteArrayList、ConcurrentHashMap。这些我们放到并发编程时再讲。</p>
<p><strong>04、不可变集合 </strong></p>
<ul>
<li>emptyXxx() ：制造一个空的不可变集合</li>
<li>singletonXxx() ：制造一个只有一个元素的不可变集合</li>
<li>unmodifiableXxx() ：为指定集合制作一个不可变集合</li>
</ul>
<p>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List emptyList = Collections.emptyList();</span><br><span class="line">emptyList.add(&quot;非空&quot;);</span><br><span class="line">System.out.println(emptyList);</span><br></pre></td></tr></table></figure>
<p>这段代码在执行的时候就抛出错误了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException</span><br><span class="line">    at java.util.AbstractList.add(AbstractList.java:148)</span><br><span class="line">    at java.util.AbstractList.add(AbstractList.java:108)</span><br><span class="line">    at com.itwanger.s64.Demo.main(Demo.java:61)</span><br></pre></td></tr></table></figure>
<p>这是因为 Collections.emptyList() 会返回一个 Collections 的内部类 EmptyList，而 EmptyList 并没有重写父类 AbstractList 的 add(int index, E element) 方法，所以执行的时候就抛出了不支持该操作的 UnsupportedOperationException 了。</p>
<p>这是从分析 add 方法源码得出的原因。除此之外，emptyList 方法是 final 的，返回的 EMPTY_LIST 也是 final 的，种种迹象表明 emptyList 返回的就是不可变对象，没法进行增伤改查。     </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static final &lt;T&gt; List&lt;T&gt; emptyList() &#123;</span><br><span class="line">    return (List&lt;T&gt;) EMPTY_LIST;</span><br><span class="line">&#125;</span><br><span class="line">public static final List EMPTY_LIST = new EmptyList&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p><strong>05、其他 </strong></p>
<p>还有两个方法比较常用：</p>
<ul>
<li>addAll(Collection&lt;? super T&gt; c, T… elements) ，往集合中添加元素</li>
<li>disjoint(Collection&lt;?&gt; c1, Collection&lt;?&gt; c2) ，判断两个集合是否没有交集</li>
</ul>
<p>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; allList = new ArrayList&lt;&gt;();</span><br><span class="line">Collections.addAll(allList, &quot;沉默王九&quot;,&quot;沉默王十&quot;,&quot;沉默王二&quot;);</span><br><span class="line">System.out.println(&quot;addAll 后：&quot; + allList);</span><br><span class="line">System.out.println(&quot;是否没有交集：&quot; + (Collections.disjoint(list, allList) ? &quot;是&quot; : &quot;否&quot;));</span><br></pre></td></tr></table></figure>
<p>输出后：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原始顺序：[沉默王二, 沉默王三, 沉默王四, 沉默王五, 沉默王六]</span><br><span class="line">addAll 后：[沉默王九, 沉默王十, 沉默王二]</span><br><span class="line">是否没有交集：否</span><br></pre></td></tr></table></figure>
<p><strong>06、CollectionUtils：Spring 和 Apache 都有提供的集合工具类 </strong></p>
<p>对集合操作，除了前面说的 JDK 原生 Collections 工具类， CollectionUtils工具类也很常用。</p>
<p>目前比较主流的是 Spring的 org.springframework.util包下的 CollectionUtils 工具类。</p>
<p><img src="\assets\note\image-20231012150329100.png" alt="image-20231012150329100"></p>
<p>和 Apache的 org.apache.commons.collections包下的 CollectionUtils 工具类。</p>
<p><img src="\assets\note\image-20231012150348343.png" alt="image-20231012150348343"></p>
<p>Maven 坐标如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-collections4&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.4&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>Apache 的方法比 Spring 的更多一些，我们就以 Apache 的为例，来介绍一下常用的方法。</p>
<p><strong>集合判空 </strong></p>
<p>通过 CollectionUtils 工具类的 isEmpty方法可以轻松判断集合是否为空， isNotEmpty方法判断集合不为空。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list.add(2);</span><br><span class="line">list.add(1);</span><br><span class="line">list.add(3);</span><br><span class="line">if (CollectionUtils.isEmpty(list)) &#123;</span><br><span class="line">    System.out.println(&quot;集合为空&quot;);</span><br><span class="line">&#125;</span><br><span class="line">if (CollectionUtils.isNotEmpty(list)) &#123;</span><br><span class="line">    System.out.println(&quot;集合不为空&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>对两个集合进行操作 </strong></p>
<p>有时候我们需要对已有的两个集合进行操作，比如取交集或者并集等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list.add(2);</span><br><span class="line">list.add(1);</span><br><span class="line">list.add(3);</span><br><span class="line">List&lt;Integer&gt; list2 = new ArrayList&lt;&gt;();</span><br><span class="line">list2.add(2);</span><br><span class="line">list2.add(4);</span><br><span class="line">//获取并集</span><br><span class="line">Collection&lt;Integer&gt; unionList = CollectionUtils.union(list, list2);</span><br><span class="line">System.out.println(unionList);</span><br><span class="line">//获取交集</span><br><span class="line">Collection&lt;Integer&gt; intersectionList = CollectionUtils.intersection(list, list2);</span><br><span class="line">System.out.println(intersectionList);</span><br><span class="line">//获取交集的补集</span><br><span class="line">Collection&lt;Integer&gt; disjunctionList = CollectionUtils.disjunction(list, list2);</span><br><span class="line">System.out.println(disjunctionList);</span><br><span class="line">//获取差集</span><br><span class="line">Collection&lt;Integer&gt; subtractList = CollectionUtils.subtract(list, list2);</span><br><span class="line">System.out.println(subtractList);</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4]</span><br><span class="line">[2]</span><br><span class="line">[1, 3, 4]</span><br><span class="line">[1, 3]</span><br></pre></td></tr></table></figure>
<p>说句实话，对两个集合的操作，在实际工作中用得挺多的，特别是很多批量的场景中。以前我们需要写一堆代码，但没想到有现成的轮子。</p>
<p><strong>07、小结 </strong></p>
<p>整体上，Collections 工具类作为集合框架的大管家，提供了一些非常便利的方法供我们调用，也非常容易掌握，没什么难点，看看方法的注释就能大致明白干嘛的。</p>
<p>不过，工具就放在那里，用是一回事，为什么要这么用就是另外一回事了。能不能提高自己的编码水平，很大程度上取决于你到底有没有去钻一钻源码，看这些设计 JDK 的大师们是如何写代码的，学会一招半式，在工作当中还是能很快脱颖而出的。</p>
<p>恐怕 JDK 的设计者是这个世界上最好的老师了，文档写得不能再详细了，代码写得不能再优雅了，基本上都达到了性能上的极致。</p>
<p>可能有人会说，工具类没什么鸟用，不过是调用下方法而已，但这就大错特错了：如果要你来写，你能写出来 Collections 这样一个工具类吗？</p>
<p>这才是高手要思考的一个问题。</p>
<h2 id="7-6-Hutool工具类库"><a href="#7-6-Hutool工具类库" class="headerlink" title="7.6 Hutool工具类库"></a>7.6 Hutool工具类库</h2><p>读者群里有个小伙伴感慨说，“Hutool 这款开源类库太厉害了，基本上该有该的工具类，它里面都有。”讲真的，我平常工作中也经常用 Hutool，它确实可以帮助我们简化每一行代码，使 Java 拥有函数式语言般的优雅，让 Java 语言变得“甜甜的”。</p>
<p>Hutool 的作者在官网上说，Hutool 是 Hu+tool 的自造词（好像不用说，我们也能猜得到），“Hu”用来致敬他的“前任”公司，“tool”就是工具的意思，谐音就有意思了，“糊涂”，寓意追求“万事都作糊涂观，无所谓失，无所谓得”（一个开源类库，上升到了哲学的高度，作者厉害了）。</p>
<p>看了一下开发团队的一个成员介绍，一个 Java 后端工具的作者竟然爱前端、爱数码，爱美女，嗯嗯嗯，确实“难得糊涂”（手动狗头）。</p>
<p>废话就说到这，来吧，实操走起！</p>
<p><strong>01、引入 Hutool </strong></p>
<p>Maven 项目只需要在 pom.xml 文件中添加以下依赖即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;cn.hutool&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;hutool-all&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.4.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>Hutool 的设计思想是尽量减少重复的定义，让项目中的 util 包尽量少。一个好的轮子可以在很大程度上避免“复制粘贴”，从而节省我们开发人员对项目中公用类库和公用工具方法的封装时间。同时呢，成熟的开源库也可以最大限度的避免封装不完善带来的 bug。</p>
<p>就像作者在官网上说的那样：</p>
<ul>
<li>以前，我们打开搜索引擎 -&gt; 搜“Java MD5 加密” -&gt; 打开某篇博客 -&gt; 复制粘贴 -&gt; 改改，变得好用些</li>
<li>有了 Hutool 以后呢，引入 Hutool -&gt; 直接 SecureUtil.md5()</li>
</ul>
<p>Hutool 对不仅对 JDK 底层的文件、流、加密解密、转码、正则、线程、XML等做了封装，还提供了以下这些组件：</p>
<p><img src="\assets\note\image-20231012150800077.png" alt="image-20231012150800077"></p>
<p>非常多，非常全面，鉴于此，我只挑选一些我喜欢的来介绍下（偷偷地告诉你，我就是想偷懒）。</p>
<p><strong>02、类型转换 </strong></p>
<p>类型转换在 Java 开发中很常见，尤其是从 HttpRequest 中获取参数的时候，前端传递的是整型，但后端只能先获取到字符串，然后再调用 parseXXX() 方法进行转换，还要加上判空，很繁琐。</p>
<p>Hutool 的 Convert 类可以简化这个操作，可以将任意可能的类型转换为指定类型，同时第二个参数 defaultValue 可用于在转换失败时返回一个默认值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String param = &quot;10&quot;;</span><br><span class="line">int paramInt = Convert.toInt(param);</span><br><span class="line">int paramIntDefault = Convert.toInt(param, 0);</span><br></pre></td></tr></table></figure>
<p>把字符串转换成日期：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String dateStr = &quot;2020年09月29日&quot;;</span><br><span class="line">Date date = Convert.toDate(dateStr);</span><br></pre></td></tr></table></figure>
<p>把字符串转成 Unicode：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String unicodeStr = &quot;沉默王二&quot;;</span><br><span class="line">String unicode = Convert.strToUnicode(unicodeStr);</span><br></pre></td></tr></table></figure>
<p><strong>03、日期时间 </strong></p>
<p>JDK 自带的 Date 和 Calendar 不太好用，Hutool 封装的 DateUtil 用起来就舒服多了！</p>
<p>获取当前日期：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date date = DateUtil.date();</span><br></pre></td></tr></table></figure>
<p>DateUtil.date() 返回的其实是 DateTime，它继承自 Date 对象，重写了 toString() 方法，返回 yyyy-MM-dd HH:mm:ss 格式的字符串。</p>
<p>有些小伙伴是不是想看看我写这篇文章的时间，输出一下给大家看看：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(date);// 2020-09-29 04:28:02</span><br></pre></td></tr></table></figure>
<p>字符串转日期：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String dateStr = &quot;2020-09-29&quot;;</span><br><span class="line">Date date = DateUtil.parse(dateStr);</span><br></pre></td></tr></table></figure>
<p>DateUtil.parse() 会自动识别一些常用的格式，比如说：</p>
<ul>
<li>yyyy-MM-dd HH:mm:ss</li>
<li>yyyy-MM-dd</li>
<li>HH:mm:ss</li>
<li>yyyy-MM-dd HH:mm</li>
<li>yyyy-MM-dd HH:mm:ss.SSS</li>
</ul>
<p>还可以识别带中文的：</p>
<ul>
<li>年月日时分秒</li>
</ul>
<p>格式化时间差：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String dateStr1 = &quot;2020-09-29 22:33:23&quot;;</span><br><span class="line">Date date1 = DateUtil.parse(dateStr1);</span><br><span class="line">String dateStr2 = &quot;2020-10-01 23:34:27&quot;;</span><br><span class="line">Date date2 = DateUtil.parse(dateStr2);</span><br><span class="line">long betweenDay = DateUtil.between(date1, date2, DateUnit.MS);</span><br><span class="line">// 输出：2天1小时1分4秒</span><br><span class="line">String formatBetween = DateUtil.formatBetween(betweenDay, </span><br><span class="line">BetweenFormater.Level.SECOND);</span><br></pre></td></tr></table></figure>
<p>星座和属相：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 射手座</span><br><span class="line">String zodiac = DateUtil.getZodiac(Month.DECEMBER.getValue(), 10);</span><br><span class="line">// 蛇</span><br><span class="line">String chineseZodiac = DateUtil.getChineseZodiac(1989);</span><br></pre></td></tr></table></figure>
<p><strong>04、IO 流相关 </strong></p>
<p>IO 操作包括读和写，应用的场景主要包括网络操作和文件操作，原生的 Java 类库区分字符流和字节流，字节流 InputStream 和 OutputStream 就有很多很多种，使用起来让人头皮发麻。</p>
<p>Hutool 封装了流操作工具类 IoUtil、文件读写操作工具类 FileUtil、文件类型判断工具类 FileTypeUtil 等等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BufferedInputStream in = FileUtil.getInputStream(&quot;hutool/origin.txt&quot;);</span><br><span class="line">BufferedOutputStream out = FileUtil.getOutputStream(&quot;hutool/to.txt&quot;);</span><br><span class="line">long copySize = IoUtil.copy(in, out, IoUtil.DEFAULT_BUFFER_SIZE);</span><br></pre></td></tr></table></figure>
<p>在 IO 操作中，文件的操作相对来说是比较复杂的，但使用频率也很高，几乎所有的项目中都躺着一个叫 FileUtil 或者 FileUtils 的工具类。Hutool 的 FileUtil 类包含以下几类操作：</p>
<ul>
<li>文件操作：包括文件目录的新建、删除、复制、移动、改名等</li>
<li>文件判断：判断文件或目录是否非空，是否为目录，是否为文件等等</li>
<li>绝对路径：针对 ClassPath 中的文件转换为绝对路径文件</li>
<li>文件名：主文件名，扩展名的获取</li>
<li>读操作：包括 getReader、readXXX 操作</li>
<li>写操作：包括 getWriter、writeXXX 操作</li>
</ul>
<p>顺带说说 classpath。</p>
<p>在实际编码当中，我们通常需要从某些文件里面读取一些数据，比如配置文件、文本文件、图片等等，那这些文件通常放在什么位置呢？</p>
<p><img src="\assets\note\image-20231012151243271.png" alt="image-20231012151243271"></p>
<p>放在项目结构图中的 resources 目录下，当项目编译后，会出现在 classes 目录下。对应磁盘上的目录如下图所示：</p>
<p><img src="\assets\note\image-20231012151304232.png" alt="image-20231012151304232"></p>
<p>当我们要读取文件的时候，我是不建议使用绝对路径的，因为操作系统不一样的话，文件的路径标识符也是不一样的。最好使用相对路径。</p>
<p>假设在 src/resources 下放了一个文件 origin.txt，文件的路径参数如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileUtil.getInputStream(&quot;origin.txt&quot;)</span><br></pre></td></tr></table></figure>
<p>假设文件放在 src/resources/hutool 目录下，则路径参数改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileUtil.getInputStream(&quot;hutool/origin.txt&quot;)</span><br></pre></td></tr></table></figure>
<p><strong>05、字符串工具 </strong></p>
<p>Hutool 封装的字符串工具类 StrUtil 和 Apache Commons Lang 包中的 StringUtils 类似，作者认为优势在于 Str 比 String 短，尽管我不觉得。不过，我倒是挺喜欢其中的一个方法的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String template = &quot;&#123;&#125;，一枚沉默但有趣的程序员，喜欢他的文章的话，请微信搜索&#123;&#125;&quot;;</span><br><span class="line">String str = StrUtil.format(template, &quot;沉默王二&quot;, &quot;沉默王二&quot;);</span><br><span class="line">// 沉默王二，一枚沉默但有趣的程序员，喜欢他的文章的话，请微信搜索沉默王二</span><br></pre></td></tr></table></figure>
<p><strong>06、反射工具 </strong></p>
<p>反射机制可以让 Java 变得更加灵活，因此在某些情况下，反射可以做到事半功倍的效果。Hutool 封装的反射工具 ReflectUtil 包括：</p>
<ul>
<li>获取构造方法</li>
<li>获取字段</li>
<li>获取字段值</li>
<li>获取方法</li>
<li>执行方法（对象方法和静态方法）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package com.itwanger.hutool.reflect;</span><br><span class="line">import cn.hutool.core.util.ReflectUtil;</span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">public class ReflectDemo &#123;</span><br><span class="line">    private int id;</span><br><span class="line">    public ReflectDemo() &#123;</span><br><span class="line">        System.out.println(&quot;构造方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void print() &#123;</span><br><span class="line">        System.out.println(&quot;我是沉默王二&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws IllegalAccessException &#123;</span><br><span class="line">        // 构建对象</span><br><span class="line">        ReflectDemo reflectDemo = ReflectUtil.newInstance(ReflectDemo.class);</span><br><span class="line">        // 获取构造方法</span><br><span class="line">        Constructor[] constructors = ReflectUtil.getConstructors(ReflectDemo.class);</span><br><span class="line">        for (Constructor constructor : constructors) &#123;</span><br><span class="line">            System.out.println(constructor.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        // 获取字段</span><br><span class="line">        Field field = ReflectUtil.getField(ReflectDemo.class, &quot;id&quot;);</span><br><span class="line">        field.setInt(reflectDemo, 10);</span><br><span class="line">        // 获取字段值</span><br><span class="line">        System.out.println(ReflectUtil.getFieldValue(reflectDemo, field));</span><br><span class="line">        // 获取所有方法</span><br><span class="line">        Method[] methods = ReflectUtil.getMethods(ReflectDemo.class);</span><br><span class="line">        for (Method m : methods) &#123;</span><br><span class="line">            System.out.println(m.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        // 获取指定方法</span><br><span class="line">        Method method = ReflectUtil.getMethod(ReflectDemo.class, &quot;print&quot;);</span><br><span class="line">        System.out.println(method.getName());</span><br><span class="line">        // 执行方法</span><br><span class="line">        ReflectUtil.invoke(reflectDemo, &quot;print&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>07、压缩工具 </strong></p>
<p>在 Java 中，对文件、文件夹打包压缩是一件很繁琐的事情，Hutool 封装的 ZipUtil 针对 java.util.zip 包做了优化，可以使用一个方法搞定压缩和解压，并且自动处理文件和目录的问题，不再需要用户判断，大大简化的压缩解压的复杂度。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZipUtil.zip(&quot;hutool&quot;, &quot;hutool.zip&quot;);</span><br><span class="line">File unzip = ZipUtil.unzip(&quot;hutool.zip&quot;, &quot;hutoolzip&quot;);</span><br></pre></td></tr></table></figure>
<p><strong>08、身份证工具 </strong></p>
<p>Hutool 封装的 IdcardUtil 可以用来对身份证进行验证，支持大陆 15 位、18 位身份证，港澳台 10 位身份证。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String ID_18 = &quot;321083197812162119&quot;;</span><br><span class="line">String ID_15 = &quot;150102880730303&quot;;</span><br><span class="line">boolean valid = IdcardUtil.isValidCard(ID_18);</span><br><span class="line">boolean valid15 = IdcardUtil.isValidCard(ID_15);</span><br></pre></td></tr></table></figure>
<p><strong>09、扩展 HashMap </strong></p>
<p>Java 中的 HashMap 是强类型的，而 Hutool 封装的 Dict 对键的类型要求没那么严格。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Dict dict = Dict.create()</span><br><span class="line">        .set(&quot;age&quot;, 18)</span><br><span class="line">        .set(&quot;name&quot;, &quot;沉默王二&quot;)</span><br><span class="line">        .set(&quot;birthday&quot;, DateTime.now());</span><br><span class="line">int age = dict.getInt(&quot;age&quot;);</span><br><span class="line">String name = dict.getStr(&quot;name&quot;);</span><br></pre></td></tr></table></figure>
<p><strong>10、控制台打印 </strong></p>
<p>本地编码的过程中，经常需要使用 System.out 打印结果，但是往往一些复杂的对象不支持直接打印，比如说数组，需要调用 Arrays.toString 。Hutool 封装的 Console 类借鉴了 JavaScript 中的 console.log() ，使得打印变成了一个非常便捷的方式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class ConsoleDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 打印字符串</span><br><span class="line">        Console.log(&quot;沉默王二，一枚有趣的程序员&quot;);</span><br><span class="line">        // 打印字符串模板</span><br><span class="line">        Console.log(&quot;洛阳是&#123;&#125;朝古都&quot;,13);</span><br><span class="line">        int [] ints = &#123;1,2,3,4&#125;;</span><br><span class="line">        // 打印数组</span><br><span class="line">        Console.log(ints);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>11、字段验证器 </strong></p>
<p>做 Web 开发的时候，后端通常需要对表单提交过来的数据进行验证。Hutool 封装的 Validator 可以进行很多有效的条件验证：</p>
<ul>
<li>是不是邮箱</li>
<li>是不是 IP V4、V6</li>
<li>是不是电话号码</li>
<li>等等</li>
</ul>
<p><img src="\assets\note\image-20231012151731368.png" alt="image-20231012151731368"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Validator.isEmail(&quot;沉默王二&quot;);</span><br><span class="line">Validator.isMobile(&quot;itwanger.com&quot;);</span><br></pre></td></tr></table></figure>
<p><strong>12、双向查找 Map </strong></p>
<p>Guava 中提供了一种特殊的 Map 结构，叫做 BiMap，实现了一种双向查找的功能，可以根据 key 查找 value，也可以根据 value 查找 key，Hutool 也提供这种 Map 结构。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BiMap&lt;String, String&gt; biMap = new BiMap&lt;&gt;(new HashMap&lt;&gt;());</span><br><span class="line">biMap.put(&quot;wanger&quot;, &quot;沉默王二&quot;);</span><br><span class="line">biMap.put(&quot;wangsan&quot;, &quot;沉默王三&quot;);</span><br><span class="line">// get value by key</span><br><span class="line">biMap.get(&quot;wanger&quot;);</span><br><span class="line">biMap.get(&quot;wangsan&quot;);</span><br><span class="line">// get key by value</span><br><span class="line">biMap.getKey(&quot;沉默王二&quot;);</span><br><span class="line">biMap.getKey(&quot;沉默王三&quot;);</span><br></pre></td></tr></table></figure>
<p>在实际的开发工作中，其实我更倾向于使用 Guava 的 BiMap，而不是 Hutool 的。这里提一下，主要是我发现了 Hutool 在线文档上的一处错误，提了个 issue（从中可以看出我一颗一丝不苟的心和一双清澈明亮的大眼睛啊）。</p>
<p><img src="\assets\note\image-20231012151845639.png" alt="image-20231012151845639"></p>
<p><strong>13、图片工具 </strong></p>
<p>Hutool 封装的 ImgUtil 可以对图片进行缩放、裁剪、转为黑白、加水印等操作。</p>
<p>缩放图片：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ImgUtil.scale(</span><br><span class="line">        FileUtil.file(&quot;hutool/wangsan.jpg&quot;),</span><br><span class="line">        FileUtil.file(&quot;hutool/wangsan_small.jpg&quot;),</span><br><span class="line">        0.5f</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>裁剪图片：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ImgUtil.cut(</span><br><span class="line">        FileUtil.file(&quot;hutool/wangsan.jpg&quot;),</span><br><span class="line">        FileUtil.file(&quot;hutool/wangsan_cut.jpg&quot;),</span><br><span class="line">        new Rectangle(200, 200, 100, 100)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>添加水印：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ImgUtil.pressText(//</span><br><span class="line">        FileUtil.file(&quot;hutool/wangsan.jpg&quot;),</span><br><span class="line">        FileUtil.file(&quot;hutool/wangsan_logo.jpg&quot;),</span><br><span class="line">        &quot;沉默王二&quot;, Color.WHITE,</span><br><span class="line">        new Font(&quot;黑体&quot;, Font.BOLD, 100),</span><br><span class="line">        0,</span><br><span class="line">        0,</span><br><span class="line">        0.8f</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><strong>14、配置文件 </strong></p>
<blockquote>
<p>众所周知，Java 中广泛应用的配置文件 Properties 存在一个特别大的诟病：不支持中文。每次使用时，如果想存放中文字符，就必须借助 IDE 相关插件才能转为 Unicode 符号，而这种反人类的符号在命令行下根本没法看。</p>
</blockquote>
<p>于是，Hutool 的 Setting 运用而生。Setting 除了兼容 Properties 文件格式外，还提供了一些特有功能，这些功能包括：</p>
<ul>
<li>各种编码方式支持</li>
<li>变量支持</li>
<li>分组支持</li>
</ul>
<p>先整个配置文件 example.setting，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name=沉默王二</span><br><span class="line">age=18</span><br></pre></td></tr></table></figure>
<p>再来读取和更新配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class SettingDemo &#123;</span><br><span class="line">    private final static String SETTING = &quot;hutool/example.setting&quot;;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 初始化 Setting</span><br><span class="line">        Setting setting = new Setting(SETTING);</span><br><span class="line">        // 读取</span><br><span class="line">        setting.getStr(&quot;name&quot;, &quot;沉默王二&quot;);</span><br><span class="line">        // 在配置文件变更时自动加载</span><br><span class="line">        setting.autoLoad(true);</span><br><span class="line">        // 通过代码方式增加键值对</span><br><span class="line">        setting.set(&quot;birthday&quot;, &quot;2020年09月29日&quot;);</span><br><span class="line">        setting.store(SETTING);</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
<p><strong>15、日志工厂 </strong></p>
<p>Hutool 封装的日志工厂 LogFactory 兼容了各大日志框架，使用起来也非常简便。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class LogDemo &#123;</span><br><span class="line">    private static final Log log = LogFactory.get();</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        log.debug(&quot;难得糊涂&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先通过 LogFactory.get() 自动识别引入的日志框架，从而创建对应日志框架的门面 Log 对象，然后调用 debug() 、 info() 等方法输出日志。</p>
<p>如果不想创建 Log 对象的话，可以使用 StaticLog，顾名思义，一个提供了静态方法的日志类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StaticLog.info(&quot;爽啊 &#123;&#125;.&quot;, &quot;沉默王二的文章&quot;);</span><br></pre></td></tr></table></figure>
<p><strong>16、缓存工具 </strong></p>
<p>CacheUtil 是 Hutool 封装的创建缓存的快捷工具类，可以创建不同的缓存对象：</p>
<ul>
<li>FIFOCache：先入先出，元素不停的加入缓存直到缓存满为止，当缓存满时，清理过期缓存对象，清理后依旧满则删除先入的缓存。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Cache&lt;String, String&gt; fifoCache = CacheUtil.newFIFOCache(3);</span><br><span class="line">fifoCache.put(&quot;key1&quot;, &quot;沉默王一&quot;);</span><br><span class="line">fifoCache.put(&quot;key2&quot;, &quot;沉默王二&quot;);</span><br><span class="line">fifoCache.put(&quot;key3&quot;, &quot;沉默王三&quot;);</span><br><span class="line">fifoCache.put(&quot;key4&quot;, &quot;沉默王四&quot;);</span><br><span class="line">// 大小为 3，所以 key3 放入后 key1 被清除</span><br><span class="line">String value1 = fifoCache.get(&quot;key1&quot;);</span><br></pre></td></tr></table></figure>
<ul>
<li>LFUCache，最少使用，根据使用次数来判定对象是否被持续缓存，当缓存满时清理过期对象，清理后依旧满的情况下清除最少访问的对象并将其他对象的访问数减去这个最少访问数，以便新对象进入后可以公平计数。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Cache&lt;String, String&gt; lfuCache = CacheUtil.newLFUCache(3);</span><br><span class="line">lfuCache.put(&quot;key1&quot;, &quot;沉默王一&quot;);</span><br><span class="line">// 使用次数+1</span><br><span class="line">lfuCache.get(&quot;key1&quot;);</span><br><span class="line">lfuCache.put(&quot;key2&quot;, &quot;沉默王二&quot;);</span><br><span class="line">lfuCache.put(&quot;key3&quot;, &quot;沉默王三&quot;);</span><br><span class="line">lfuCache.put(&quot;key4&quot;, &quot;沉默王四&quot;);</span><br><span class="line">// 由于缓存容量只有 3，当加入第 4 个元素的时候，最少使用的将被移除（2,3被移除）</span><br><span class="line">String value2 = lfuCache.get(&quot;key2&quot;);</span><br><span class="line">String value3 = lfuCache.get(&quot;key3&quot;);</span><br></pre></td></tr></table></figure>
<ul>
<li>LRUCache，最近最久未使用，根据使用时间来判定对象是否被持续缓存，当对象被访问时放入缓存，当缓存满了，最久未被使用的对象将被移除。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Cache&lt;String, String&gt; lruCache = CacheUtil.newLRUCache(3);</span><br><span class="line">lruCache.put(&quot;key1&quot;, &quot;沉默王一&quot;);</span><br><span class="line">lruCache.put(&quot;key2&quot;, &quot;沉默王二&quot;);</span><br><span class="line">lruCache.put(&quot;key3&quot;, &quot;沉默王三&quot;);</span><br><span class="line">// 使用时间近了</span><br><span class="line">lruCache.get(&quot;key1&quot;);</span><br><span class="line">lruCache.put(&quot;key4&quot;, &quot;沉默王四&quot;);</span><br><span class="line">// 由于缓存容量只有 3，当加入第 4 个元素的时候，最久使用的将被移除（2）</span><br><span class="line">String value2 = lruCache.get(&quot;key2&quot;);</span><br><span class="line">System.out.println(value2);</span><br></pre></td></tr></table></figure>
<p><strong>17、加密解密 </strong></p>
<p>加密分为三种：</p>
<ul>
<li>对称加密（symmetric），例如：AES、DES 等</li>
<li>非对称加密（asymmetric），例如：RSA、DSA 等</li>
<li>摘要加密（digest），例如：MD5、SHA-1、SHA-256、HMAC 等</li>
</ul>
<p>Hutool 针对这三种情况都做了封装：</p>
<ul>
<li>对称加密 SymmetricCrypto</li>
<li>非对称加密 AsymmetricCrypto</li>
<li>摘要加密 Digester</li>
</ul>
<p>快速加密工具类 SecureUtil 有以下这些方法：</p>
<p>1）对称加密</p>
<ul>
<li>SecureUtil.aes</li>
<li>SecureUtil.des</li>
</ul>
<p>2）非对称加密</p>
<ul>
<li>SecureUtil.rsa</li>
<li>SecureUtil.dsa</li>
</ul>
<p>3）摘要加密</p>
<ul>
<li>SecureUtil.md5</li>
<li>SecureUtil.sha1</li>
<li>SecureUtil.hmac</li>
<li>SecureUtil.hmacMd5</li>
<li>SecureUtil.hmacSha1</li>
</ul>
<p>只写一个简单的例子作为参考：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class SecureUtilDemo &#123;</span><br><span class="line">    static AES aes = SecureUtil.aes();</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String encry = aes.encryptHex(&quot;沉默王二&quot;);</span><br><span class="line">        System.out.println(encry);</span><br><span class="line">        String oo = aes.decryptStr(encry);</span><br><span class="line">        System.out.println(oo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>18、其他类库 </strong></p>
<p>Hutool 中的类库还有很多，尤其是一些对第三方类库的进一步封装，比如邮件工具 MailUtil，二维码工具 QrCodeUtil，Emoji 工具 EmojiUtil，小伙伴们可以参考 Hutool 的官方文档：<a target="_blank" rel="noopener" href="https://www.hutool.cn/">https://www.hutool.cn/</a></p>
<p>项目源码地址：<a target="_blank" rel="noopener" href="https://github.com/looly/hutool">https://github.com/looly/hutool</a></p>
<h2 id="7-7-Guava工具库"><a href="#7-7-Guava工具库" class="headerlink" title="7.7 Guava工具库"></a>7.7 Guava工具库</h2><p><strong>01、前世今生 </strong></p>
<p>你好呀，我是 Guava。</p>
<p>我由 Google 公司开源，目前在 GitHub 上已经有 39.9k 的铁粉了，由此可以证明我的受欢迎程度。</p>
<p><img src="\assets\note\image-20231012152604524.png" alt="image-20231012152604524"></p>
<p>我的身体里主要包含有这些常用的模块：集合 [collections] 、缓存 [caching] 、原生类型支持 [primitives support] 、并发库 [concurrency libraries] 、通用注解 [common annotations] 、字符串处理 [string processing] 、I/O 等。新版的 JDK 中已经直接把我引入了，可想而知我有多优秀，忍不住骄傲了。</p>
<p>这么说吧，学好如何使用我，能让你在编程中变得更快乐，写出更优雅的代码！</p>
<p><strong>02、引入 Guava </strong></p>
<p>如果你要在 Maven 项目使用我的话，需要先在 pom.xml 文件中引入我的依赖。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.google.guava&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;guava&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;30.1-jre&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>一点要求，JDK 版本需要在 8 以上。</p>
<p><strong>03、基本工具 </strong></p>
<p>Doug Lea，java.util.concurrent 包的作者，曾说过一句话：“null 真糟糕”。Tony Hoare，图灵奖得主、快速排序算法的作者，当然也是 null 的创建者，也曾说过类似的话：“null 的使用，让我损失了十亿美元。”鉴于此，我用 Optional 来表示可能为 null 的对象。</p>
<p><img src="\assets\note\image-20231012152712235.png" alt="image-20231012152712235"></p>
<p>代码示例如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Integer&gt; possible = Optional.of(5);</span><br><span class="line">possible.isPresent(); // returns true</span><br><span class="line">possible.get(); // returns 5</span><br></pre></td></tr></table></figure>
<p>我大哥 Java 在 JDK 8 中新增了 Optional 类，显然是从我这借鉴过去的，不过他的和我的有些不同。</p>
<ul>
<li>我的 Optional 是 abstract 的，意味着我可以有子类对象；我大哥的是 final 的，意味着没有子类对象。</li>
<li>我的 Optional 实现了 Serializable 接口，可以序列化；我大哥的没有。</li>
<li>我的一些方法和我大哥的也不尽相同。</li>
</ul>
<p>使用 Optional 除了赋予 null 语义，增加了可读性，最大的优点在于它是一种傻瓜式的防护。Optional 迫使你积极思考引用缺失的情况，因为你必须显式地从 Optional 获取引用。</p>
<p>除了 Optional 之外，我还提供了：</p>
<ul>
<li>参数校验</li>
<li>常见的 Object 方法，比如说 Objects.equals、Objects.hashCode，JDK 7 引入的 Objects 类提供同样的方法，当然也是从我这借鉴的灵感。</li>
<li>更强大的比较器</li>
</ul>
<p><strong>04、集合 </strong></p>
<p>首先我来说一下，为什么需要不可变集合。</p>
<ul>
<li>保证线程安全。在并发程序中，使用不可变集合既保证线程的安全性，也大大地增强了并发时的效率（跟并发锁方式相比）。</li>
<li>如果一个对象不需要支持修改操作，不可变的集合将会节省空间和时间的开销。</li>
<li>可以当作一个常量来对待，并且集合中的对象在以后也不会被改变。</li>
</ul>
<p>与 JDK 中提供的不可变集合相比，我提供的 Immutable 才是真正的不可变，我为什么这么说呢？来看下面这个示例。</p>
<p>下面的代码利用 JDK 的 Collections.unmodifiableList(list) 得到一个不可修改的集合 unmodifiableList。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List list = new ArrayList();</span><br><span class="line">list.add(&quot;雷军&quot;);</span><br><span class="line">list.add(&quot;乔布斯&quot;);</span><br><span class="line">List unmodifiableList = Collections.unmodifiableList(list);</span><br><span class="line">unmodifiableList.add(&quot;马云&quot;);</span><br></pre></td></tr></table></figure>
<p>运行代码将会出现以下异常：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException</span><br><span class="line">    at </span><br><span class="line">java.base/java.util.Collections$UnmodifiableCollection.add(Collections.java:1060)</span><br><span class="line">    at com.itwanger.guava.NullTest.main(NullTest.java:29)</span><br></pre></td></tr></table></figure>
<p>很好，执行 unmodifiableList.add() 的时候抛出了 UnsupportedOperationException 异常，说明 Collections.unmodifiableList() 返回了一个不可变集合。但真的是这样吗？</p>
<p>你可以把 unmodifiableList.add() 换成 list.add() 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List list = new ArrayList();</span><br><span class="line">list.add(&quot;雷军&quot;);</span><br><span class="line">list.add(&quot;乔布斯&quot;);</span><br><span class="line">List unmodifiableList = Collections.unmodifiableList(list);</span><br><span class="line">list.add(&quot;马云&quot;);</span><br></pre></td></tr></table></figure>
<p>再次执行的话，程序并没有报错，并且你会发现 unmodifiableList 中真的多了一个元素。说明什么呢？</p>
<p>Collections.unmodifiableList(…) 实现的不是真正的不可变集合，当原始集合被修改后，不可变集合里面的元素也是跟着发生变化。</p>
<p>我就不会犯这种错，来看下面的代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringArrayList = Lists.newArrayList(&quot;雷军&quot;,&quot;乔布斯&quot;);</span><br><span class="line">ImmutableList&lt;String&gt; immutableList = ImmutableList.copyOf(stringArrayList);</span><br><span class="line">immutableList.add(&quot;马云&quot;);</span><br></pre></td></tr></table></figure>
<p>尝试 immutableList.add() 的时候会抛出 UnsupportedOperationException 。我在源码中已经把 add() 方法废弃了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * Guaranteed to throw an exception and leave the collection unmodified.</span><br><span class="line">  *</span><br><span class="line">  * @throws UnsupportedOperationException always</span><br><span class="line">  * @deprecated Unsupported operation.</span><br><span class="line">  */</span><br><span class="line">@CanIgnoreReturnValue</span><br><span class="line">@Deprecated</span><br><span class="line">@Override</span><br><span class="line">public final boolean add(E e) &#123;</span><br><span class="line">  throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尝试 stringArrayList.add() 修改原集合的时候 immutableList 并不会因此而发生改变。</p>
<p>除了不可变集合以外，我还提供了新的集合类型，比如说：</p>
<ul>
<li>Multiset，可以多次添加相等的元素。当把 Multiset 看成普通的 Collection 时，它表现得就像无序的 </li>
<li>ArrayList；当把 Multiset 看作 Map<E, Integer> 时，它也提供了符合性能期望的查询操作。</li>
<li>Multimap，可以很容易地把一个键映射到多个值。</li>
<li>BiMap，一种特殊的 Map，可以用 inverse() 反转，BiMap<K, V> 的键值映射；保证值是唯一的，因此 values() 返回 Set 而不是普通的 Collection。</li>
</ul>
<p><strong>05、字符串处理 </strong></p>
<p>字符串表示字符的不可变序列，创建后就不能更改。在我们日常的工作中，字符串的使用非常频繁，熟练的对其操作可以极大的提升我们的工作效率。</p>
<p>我提供了连接器——Joiner，可以用分隔符把字符串序列连接起来。下面的代码将会返回“雷军; 乔布斯”，你可以使用 useForNull(String) 方法用某个字符串来替换 null，而不像 skipNulls() 方法那样直接忽略 null。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Joiner joiner = Joiner.on(&quot;; &quot;).skipNulls();</span><br><span class="line">return joiner.join(&quot;雷军&quot;, null, &quot;乔布斯&quot;);</span><br></pre></td></tr></table></figure>
<p>我还提供了拆分器—— Splitter，可以按照指定的分隔符把字符串序列进行拆分。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Splitter.on(&#x27;,&#x27;)</span><br><span class="line">        .trimResults()</span><br><span class="line">        .omitEmptyStrings()</span><br><span class="line">        .split(&quot;雷军,乔布斯,,   沉默王二&quot;);</span><br></pre></td></tr></table></figure>
<p><strong>06、缓存 </strong></p>
<p>缓存在很多场景下都是相当有用的。你应该知道，检索一个值的代价很高，尤其是需要不止一次获取值的时候，就应当考虑使用缓存。</p>
<p>我提供的 Cache 和 ConcurrentMap 很相似，但也不完全一样。最基本的区别是 ConcurrentMap 会一直保存所有添加的元素，直到显式地移除。相对地，我提供的 Cache 为了限制内存占用，通常都设定为自动回收元素。</p>
<p>如果你愿意消耗一些内存空间来提升速度，你能预料到某些键会被查询一次以上，缓存中存放的数据总量不会超出内存容量，就可以使用 Cache。</p>
<p>来个示例你感受下吧。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testCache() throws ExecutionException, InterruptedException &#123;</span><br><span class="line">    CacheLoader cacheLoader = new CacheLoader&lt;String, Animal&gt;() &#123;</span><br><span class="line">        // 如果找不到元素，会调用这里</span><br><span class="line">        @Override</span><br><span class="line">        public Animal load(String s) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    LoadingCache&lt;String, Animal&gt; loadingCache = CacheBuilder.newBuilder()</span><br><span class="line">        .maximumSize(1000) // 容量</span><br><span class="line">        .expireAfterWrite(3, TimeUnit.SECONDS) // 过期时间</span><br><span class="line">        .removalListener(new MyRemovalListener()) // 失效监听器</span><br><span class="line">        .build(cacheLoader); //</span><br><span class="line">    loadingCache.put(&quot;狗&quot;, new Animal(&quot;旺财&quot;, 1));</span><br><span class="line">    loadingCache.put(&quot;猫&quot;, new Animal(&quot;汤姆&quot;, 3));</span><br><span class="line">    loadingCache.put(&quot;狼&quot;, new Animal(&quot;灰太狼&quot;, 4));</span><br><span class="line">    loadingCache.invalidate(&quot;猫&quot;); // 手动失效</span><br><span class="line">    Animal animal = loadingCache.get(&quot;狼&quot;);</span><br><span class="line">    System.out.println(animal);</span><br><span class="line">    Thread.sleep(4 * 1000);</span><br><span class="line">    // 狼已经自动过去，获取为 null 值报错</span><br><span class="line">    System.out.println(loadingCache.get(&quot;狼&quot;));</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 缓存移除监听器</span><br><span class="line"> */</span><br><span class="line">class MyRemovalListener implements RemovalListener&lt;String, Animal&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onRemoval(RemovalNotification&lt;String, Animal&gt; notification) &#123;</span><br><span class="line">        String reason = String.format(&quot;key=%s,value=%s,reason=%s&quot;, </span><br><span class="line">notification.getKey(), notification.getValue(), notification.getCause());</span><br><span class="line">        System.out.println(reason);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Animal &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private Integer age;</span><br><span class="line">    public Animal(String name, Integer age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CacheLoader 中重写了 load 方法，这个方法会在查询缓存没有命中时被调用，我这里直接返回了 null，其实这样会在没有命中时抛出 CacheLoader returned null for key 异常信息。</p>
<p>MyRemovalListener 作为缓存元素失效时的监听类，在有元素缓存失效时会自动调用 onRemoval 方法，这里需要注意的是这个方法是同步方法，如果这里耗时较长，会阻塞直到处理完成。</p>
<p>LoadingCache 就是缓存的主要操作对象了，常用的就是其中的 put 和 get 方法了。</p>
<p><strong>07、集合工具 </strong></p>
<p>com.google.common.collect包下的集合工具： Lists也非常强大。</p>
<p><strong>创建空集合 </strong></p>
<p>有时候，我们想创建一个空集合。这时可以用Lists的 newArrayList方法，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Lists.newArrayList();</span><br></pre></td></tr></table></figure>
<p><strong>快速初始化集合 </strong></p>
<p>有时候，我们想给一个集合中初始化一些元素。这时可以用Lists的newArrayList方法，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Lists.newArrayList(1, 2, 3);</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3]</span><br></pre></td></tr></table></figure>
<p><strong>笛卡尔积 </strong></p>
<p>如果你想将两个集合做笛卡尔积 ，Lists的 cartesianProduct方法可以帮你实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list1 = Lists.newArrayList(1, 2, 3);</span><br><span class="line">List&lt;Integer&gt; list2 = Lists.newArrayList(4,5);</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; productList = Lists.cartesianProduct(list1,list2);</span><br><span class="line">System.out.println(productList);</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[1, 4], [1, 5], [2, 4], [2, 5], [3, 4], [3, 5]]</span><br></pre></td></tr></table></figure>
<p><strong>分页 </strong></p>
<p>如果你想将一个大集合分成若干个小集合 ，可以使用Lists的 partition方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Lists.newArrayList(1, 2, 3, 4, 5);</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; partitionList = Lists.partition(list, 2);</span><br><span class="line">System.out.println(partitionList);</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[1, 2], [3, 4], [5]]</span><br></pre></td></tr></table></figure>
<p>这个例子中，list有5条数据，我将list集合按大小为2，分成了3页，即变成3个小集合。</p>
<p>这个是我最喜欢的方法之一，经常在项目中使用。</p>
<p>比如有个需求：现在有5000个id，需要调用批量用户查询接口，查出用户数据。但如果你直接查5000个用户，单次接口响应时间可能会非常慢。如果改成分页处理，每次只查500个用户，异步调用10次接口，就不会有单次接口响应慢的问题。</p>
<p><strong>流处理 </strong></p>
<p>如果我们想把某个集合转换成另外一个接口，可以使用Lists的 transform方法。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Lists.newArrayList(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);</span><br><span class="line">List&lt;String&gt; transformList = Lists.transform(list, x -&gt; x.toUpperCase());</span><br><span class="line">System.out.println(transformList);</span><br></pre></td></tr></table></figure>
<p>将小写字母转换成了大写字母。</p>
<p><strong>颠倒顺序 </strong></p>
<p>Lists的有颠倒顺序的方法 reverse 。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Lists.newArrayList(3, 1, 2);</span><br><span class="line">List&lt;Integer&gt; reverseList = Lists.reverse(list);</span><br><span class="line">System.out.println(reverseList);</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2, 1, 3]</span><br></pre></td></tr></table></figure>
<p>list的原始顺序是312，使用 reverse方法颠倒顺序之后，变成了213。</p>
<p>Lists还有其他的好用的工具，我在这里只是抛砖引玉，有兴趣的小伙伴，可以仔细研究一下。</p>
<p><img src="\assets\note\image-20231012153730610.png" alt="image-20231012153730610"></p>
<p><strong>08、尾声 </strong></p>
<p>上面介绍了我认为最常用的功能，作为 Google 公司开源的 Java 开发核心库，个人觉得实用性还是很高的（不然呢？嘿嘿嘿）。引入到你的项目后不仅能快速的实现一些开发中常用的功能，而且还可以让代码更加的优雅简洁。</p>
<p>我觉得适用于每一个 Java 项目，至于其他的一些功能，比如说散列、事件总线、数学运算、反射，就等待你去发掘了。</p>
<h2 id="7-8-其他常用工具类"><a href="#7-8-其他常用工具类" class="headerlink" title="7.8 其他常用工具类"></a>7.8 其他常用工具类</h2><p>除了我们前面提到的 Java 原生工具类，比如说 Arrays、Objects、Collections、Scanner 等，还有一些第三方的工具类，比如说 Hutool、Guava 等，以及我们今天介绍的 IpUtil、CollectionUtils、StringUtils、MDC、ClassUtils、BeanUtils、ReflectionUtils 等等，在很大程度上能够提高我们的生产效率。</p>
<p>当然了，如果能好好看一下它们的源码，对技术功底的提升，也是有很大帮助的。</p>
<p><strong>IpUtil：获取本机 Ip </strong></p>
<p>获取本机 IP 算是比较常见的一个需求场景了，比如业务报警，可能就会带上出问题的机器 IP，方便直接上去看日志定位问题，那么问题来了，如何获取机器 IP 呢？</p>
<p><strong>1.基本方法 </strong></p>
<p>如何获取机器 IP？如果了解 InetAddress 这个工具类，就很容易写出一个简单的工具类，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static String getLocalIP() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        return InetAddress.getLocalHost().getHostAddress();</span><br><span class="line">    &#125; catch (UnknownHostException e) &#123;</span><br><span class="line">        throw new RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的实现有问题么？</p>
<p>当然没问题，拿我本机和阿里服务器执行一下，并没有问题如实的输出了预期的 IP</p>
<p>本机执行后截图如下：</p>
<p><img src="\assets\note\image-20231012154124001.png" alt="image-20231012154124001"></p>
<p>阿里云机器执行后截图如下：</p>
<p><img src="\assets\note\image-20231012154135124.png" alt="image-20231012154135124"></p>
<p><strong>2.进阶版 </strong></p>
<p>做一点简单的改动，获取 IPV4 的地址，源码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public static String getLocalIpByNetcard() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 枚举所有的网络接口</span><br><span class="line">        for (Enumeration&lt;NetworkInterface&gt; e = </span><br><span class="line">NetworkInterface.getNetworkInterfaces(); e.hasMoreElements(); ) &#123;</span><br><span class="line">            // 获取当前网络接口</span><br><span class="line">            NetworkInterface item = e.nextElement();</span><br><span class="line">            // 遍历当前网络接口的所有地址</span><br><span class="line">            for (InterfaceAddress address : item.getInterfaceAddresses()) &#123;</span><br><span class="line">                // 忽略回环地址和未启用的网络接口</span><br><span class="line">                if (item.isLoopback() || !item.isUp()) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                // 如果当前地址是 IPv4 地址，则返回其字符串表示</span><br><span class="line">                if (address.getAddress() instanceof Inet4Address) &#123;</span><br><span class="line">                    Inet4Address inet4Address = (Inet4Address) address.getAddress();</span><br><span class="line">                    return inet4Address.getHostAddress();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果没有找到任何 IPv4 地址，则返回本地主机地址</span><br><span class="line">        return InetAddress.getLocalHost().getHostAddress();</span><br><span class="line">    &#125; catch (SocketException | UnknownHostException e) &#123;</span><br><span class="line">        // 抛出运行时异常</span><br><span class="line">        throw new RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，这段代码只返回本机的 IPv4 地址，并且只返回第一个符合条件的地址。如果本机有多个网络接口或者每个接口有多个地址，则可能无法返回预期的地址。此外，如果找不到任何 IPv4 地址，则会返回本地主机地址。</p>
<p>再次测试，输出如下</p>
<p><img src="\assets\note\image-20231012154246072.png" alt="image-20231012154246072"></p>
<p><strong>3.完整工具类 </strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">import java.net.*;</span><br><span class="line">import java.util.Enumeration;</span><br><span class="line">public class IPUtil &#123;</span><br><span class="line">    public static final String DEFAULT_IP = &quot;127.0.0.1&quot;;</span><br><span class="line">    /**</span><br><span class="line">     * 直接根据第一个网卡地址作为其内网ipv4地址，避免返回 127.0.0.1</span><br><span class="line">     *</span><br><span class="line">     * @return 第一个符合条件的内网 IPv4 地址</span><br><span class="line">     */</span><br><span class="line">    public static String getLocalIpByNetcard() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 枚举所有的网络接口</span><br><span class="line">            for (Enumeration&lt;NetworkInterface&gt; e = </span><br><span class="line">NetworkInterface.getNetworkInterfaces(); e.hasMoreElements(); ) &#123;</span><br><span class="line">                // 获取当前网络接口</span><br><span class="line">                NetworkInterface item = e.nextElement();</span><br><span class="line">                // 遍历当前网络接口的所有地址</span><br><span class="line">                for (InterfaceAddress address : item.getInterfaceAddresses()) &#123;</span><br><span class="line">                    // 忽略回环地址和未启用的网络接口</span><br><span class="line">                    if (item.isLoopback() || !item.isUp()) &#123;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 如果当前地址是 IPv4 地址，则返回其字符串表示</span><br><span class="line">                    if (address.getAddress() instanceof Inet4Address) &#123;</span><br><span class="line">                        Inet4Address inet4Address = (Inet4Address) </span><br><span class="line">address.getAddress();</span><br><span class="line">                        return inet4Address.getHostAddress();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果没有找到符合条件的地址，则返回本地主机地址</span><br><span class="line">            return InetAddress.getLocalHost().getHostAddress();</span><br><span class="line">        &#125; catch (SocketException | UnknownHostException e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 获取本地主机地址</span><br><span class="line">     *</span><br><span class="line">     * @return 本地主机地址</span><br><span class="line">     */</span><br><span class="line">    public static String getLocalIP() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return InetAddress.getLocalHost().getHostAddress();</span><br><span class="line">        &#125; catch (UnknownHostException e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IPUtil 类中定义了两个方法，分别是 getLocalIpByNetcard() 和 getLocalIP() 。前者是获取本机的内网 IPv4 地址，避免了返回 127.0.0.1 的问题。后者是获取本地主机地址，如果本机有多个 IP 地址，则可能返回其中的任意一个。</p>
<p><strong>MDC：一个线程安全的参数传递工具类 </strong></p>
<p>MDC 是 org.slf4j 包下的一个类，它的全称是 Mapped Diagnostic Context，我们可以认为它是一个线程安全的存放诊断日志的容器。</p>
<p>MDC 的底层是用了 ThreadLocal 来保存数据的。</p>
<p>我们可以用它传递参数。</p>
<p>例如现在有这样一种场景：我们使用 RestTemplate调用远程接口时，有时需要在 header中传递信息，比如：traceId，source 等，便于在查询日志时能够串联一次完整的请求链路，快速定位问题。</p>
<p>这种业务场景就能通过 ClientHttpRequestInterceptor接口实现，具体做法如下：</p>
<p>第一步，定义一个 LogFilter 拦截所有接口请求，在 MDC 中设置 traceId：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class LogFilter implements Filter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void init(FilterConfig filterConfig) throws ServletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter(ServletRequest request, ServletResponse response, </span><br><span class="line">FilterChain chain) throws IOException, ServletException &#123;</span><br><span class="line">        MdcUtil.add(UUID.randomUUID().toString());</span><br><span class="line">        System.out.println(&quot;记录请求日志&quot;);</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">        System.out.println(&quot;记录响应日志&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二步，实现 ClientHttpRequestInterceptor接口，MDC 中获取当前请求的 traceId，然后设置到 header 中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class RestTemplateInterceptor implements ClientHttpRequestInterceptor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public ClientHttpResponse intercept(HttpRequest request, byte[] body, </span><br><span class="line">ClientHttpRequestExecution execution) throws IOException &#123;</span><br><span class="line">        request.getHeaders().set(&quot;traceId&quot;, MdcUtil.get());</span><br><span class="line">        return execution.execute(request, body);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三步，定义配置类，配置上面定义的 RestTemplateInterceptor类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class RestTemplateConfiguration &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public RestTemplate restTemplate() &#123;</span><br><span class="line">        RestTemplate restTemplate = new RestTemplate();</span><br><span class="line">       </span><br><span class="line"> restTemplate.setInterceptors(Collections.singletonList(restTemplateInterceptor()));</span><br><span class="line">        return restTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">    @Bean</span><br><span class="line">    public RestTemplateInterceptor restTemplateInterceptor() &#123;</span><br><span class="line">        return new RestTemplateInterceptor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 MdcUtil 其实是利用 MDC 工具在 ThreadLocal 中存储和获取 traceId</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class MdcUtil &#123;</span><br><span class="line">    private static final String TRACE_ID = &quot;TRACE_ID&quot;;</span><br><span class="line">    public static String get() &#123;</span><br><span class="line">        return MDC.get(TRACE_ID);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void add(String value) &#123;</span><br><span class="line">        MDC.put(TRACE_ID, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，这个例子中没有演示 MdcUtil 类的 add 方法具体调的地方，我们可以在 filter 中执行接口方法之前，生成 traceId，调用 MdcUtil 类的 add 方法添加到 MDC 中，然后在同一个请求的其他地方就能通过 MdcUtil 类的 get 方法获取到该 traceId。</p>
<p>能使用 MDC 保存 traceId 等参数的根本原因是，用户请求到应用服务器，Tomcat 会从线程池中分配一个线程去处理该请求。</p>
<p>那么该请求的整个过程中，保存到 MDC 的 ThreadLocal 中的参数，也是该线程独享的，所以不会有线程安全问题。</p>
<p><strong>ClassUtils </strong></p>
<p>spring 的 org.springframework.util包下的 ClassUtils类，它里面有很多让我们惊喜的功能。</p>
<p>它里面包含了类和对象相关的很多非常实用的方法。</p>
<p><strong>获取对象的所有接口 </strong></p>
<p>如果你想获取某个对象的所有接口，可以使用 ClassUtils 的 getAllInterfaces方法。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt;[] allInterfaces = ClassUtils.getAllInterfaces(new User());</span><br></pre></td></tr></table></figure>
<p><strong>获取某个类的包名 </strong></p>
<p>如果你想获取某个类的包名，可以使用 ClassUtils 的 getPackageName方法。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String packageName = ClassUtils.getPackageName(User.class);</span><br><span class="line">System.out.println(packageName);</span><br></pre></td></tr></table></figure>
<p><strong>判断某个类是否内部类 </strong></p>
<p>如果你想判断某个类是否内部类，可以使用 ClassUtils 的 isInnerClass方法。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(ClassUtils.isInnerClass(User.class));</span><br></pre></td></tr></table></figure>
<p><strong>判断对象是否代理对象 </strong></p>
<p>如果你想判断对象是否代理对象，可以使用 ClassUtils 的 isCglibProxy方法。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(ClassUtils.isCglibProxy(new User()));</span><br></pre></td></tr></table></figure>
<p>ClassUtils 还有很多有用的方法，等待着你去发掘。感兴趣的小伙伴，可以看看下面的内容：</p>
<p><img src="\assets\note\image-20231012154737388.png" alt="image-20231012154737388"></p>
<p><strong>BeanUtils </strong></p>
<p>Spring 给我们提供了一个 JavaBean的工具类，它在 org.springframework.beans包下面，它的名字叫做： BeanUtils 。</p>
<p>让我们一起看看这个工具可以带给我们哪些惊喜。</p>
<p><strong>拷贝对象的属性 </strong></p>
<p>曾几何时，你有没有这样的需求：把某个对象中的所有属性，都拷贝到另外一个对象中。这时就能使用 BeanUtils 的 copyProperties方法。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">User user1 = new User();</span><br><span class="line">user1.setId(1L);</span><br><span class="line">user1.setName(&quot;沉默王二&quot;);</span><br><span class="line">user1.setAddress(&quot;中国&quot;);</span><br><span class="line">User user2 = new User();</span><br><span class="line">BeanUtils.copyProperties(user1, user2);</span><br><span class="line">System.out.println(user2);</span><br></pre></td></tr></table></figure>
<p><strong>实例化某个类 </strong></p>
<p>如果你想通过反射实例化一个类的对象，可以使用 BeanUtils 的 instantiateClass方法。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User user = BeanUtils.instantiateClass(User.class);</span><br><span class="line">System.out.println(user);</span><br></pre></td></tr></table></figure>
<p><strong>获取指定类的指定方法 </strong></p>
<p>如果你想获取某个类的指定方法，可以使用 BeanUtils 的 findDeclaredMethod方法。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Method declaredMethod = BeanUtils.findDeclaredMethod(User.class, &quot;getId&quot;);</span><br><span class="line">System.out.println(declaredMethod.getName());</span><br></pre></td></tr></table></figure>
<p><strong>获取指定方法的参数 </strong></p>
<p>如果你想获取某个方法的参数，可以使用 BeanUtils 的 findPropertyForMethod方法。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Method declaredMethod = BeanUtils.findDeclaredMethod(User.class, &quot;getId&quot;);</span><br><span class="line">PropertyDescriptor propertyForMethod = </span><br><span class="line">BeanUtils.findPropertyForMethod(declaredMethod);</span><br><span class="line">System.out.println(propertyForMethod.getName());</span><br></pre></td></tr></table></figure>
<p>如果你对 BeanUtils 比较感兴趣，可以看看下面内容：</p>
<p><img src="\assets\note\image-20231012154931680.png" alt="image-20231012154931680"></p>
<p><strong>ReflectionUtils </strong></p>
<p>有时候，我们需要在项目中使用反射功能，如果使用最原始的方法来开发，代码量会非常多，而且很麻烦，它需要处理一大堆异常以及访问权限等问题。</p>
<p>好消息是 Spring 给我们提供了一个 ReflectionUtils工具，它在 org.springframework.util包下面。</p>
<p><strong>获取方法 </strong></p>
<p>如果你想获取某个类的某个方法，可以使用 ReflectionUtils 类的 findMethod方法。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Method method = ReflectionUtils.findMethod(User.class, &quot;getId&quot;);</span><br></pre></td></tr></table></figure>
<p><strong>获取字段 </strong></p>
<p>如果你想获取某个类的某个字段，可以使用 ReflectionUtils 类的 findField方法。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Field field = ReflectionUtils.findField(User.class, &quot;id&quot;);</span><br></pre></td></tr></table></figure>
<p><strong>执行方法 </strong></p>
<p>如果你想通过反射调用某个方法，传递参数，可以使用 ReflectionUtils 类的 invokeMethod方法。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReflectionUtils.invokeMethod(method, springContextsUtil.getBean(beanName), param);</span><br></pre></td></tr></table></figure>
<p><strong>判断字段是否常量 </strong></p>
<p>如果你想判断某个字段是否常量，可以使用 ReflectionUtils 类的 isPublicStaticFinal方法。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Field field = ReflectionUtils.findField(User.class, &quot;id&quot;);</span><br><span class="line">System.out.println(ReflectionUtils.isPublicStaticFinal(field));</span><br></pre></td></tr></table></figure>
<p><strong>判断是否 equals 方法 </strong></p>
<p>如果你想判断某个方法是否 equals 方法，可以使用 ReflectionUtils 类的 isEqualsMethod方法。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Method method = ReflectionUtils.findMethod(User.class, &quot;getId&quot;);</span><br><span class="line">System.out.println(ReflectionUtils.isEqualsMethod(method));</span><br></pre></td></tr></table></figure>
<p>当然这个类还有不少有趣的方法，感兴趣的朋友，可以看看下面内容：</p>
<p><img src="\assets\note\image-20231012155139162.png" alt="image-20231012155139162"></p>
<h1 id="8-Java新特性"><a href="#8-Java新特性" class="headerlink" title="8 Java新特性"></a>8 Java新特性</h1><h2 id="8-1-掌握Stream流"><a href="#8-1-掌握Stream流" class="headerlink" title="8.1 掌握Stream流"></a>8.1 掌握Stream流</h2><p>两个星期以前，就有读者强烈要求我写一篇 Java Stream 流的文章，我说市面上不是已经有很多了吗，结果你猜他怎么说：“就想看你写的啊！”你看你看，多么苍白的喜欢啊。那就“勉为其难”写一篇吧，嘻嘻。</p>
<p>单从“Stream”这个单词上来看，它似乎和 java.io 包下的 InputStream 和 OutputStream 有些关系。实际上呢，没毛关系。Java 8 新增的 Stream 是为了解放程序员操作集合（Collection）时的生产力，之所以能解放，很大一部分原因可以归功于同时出现的 Lambda 表达式——极大的提高了编程效率和程序可读性。</p>
<p>Stream 究竟是什么呢？</p>
<blockquote>
<p>Stream 就好像一个高级的迭代器，但只能遍历一次，就好像一江春水向东流；在流的过程中，对流中的元素执行一些操作，比如“过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等。</p>
</blockquote>
<p>要想操作流，首先需要有一个数据源，可以是数组或者集合。每次操作都会返回一个新的流对象，方便进行链式操作，但原有的流对象会保持不变。</p>
<p>流的操作可以分为两种类型：</p>
<p>1）中间操作，可以有多个，每次返回一个新的流，可进行链式操作。</p>
<p>2）终端操作，只能有一个，每次执行完，这个流也就用光光了，无法执行下一个操作，因此只能放在最后。</p>
<p>来举个例子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list.add(&quot;武汉加油&quot;);</span><br><span class="line">list.add(&quot;中国加油&quot;);</span><br><span class="line">list.add(&quot;世界加油&quot;);</span><br><span class="line">list.add(&quot;世界加油&quot;);</span><br><span class="line">long count = list.stream().distinct().count();</span><br><span class="line">System.out.println(count);</span><br></pre></td></tr></table></figure>
<p>distinct() 方法是一个中间操作（去重），它会返回一个新的流（没有共同元素）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; distinct();</span><br></pre></td></tr></table></figure>
<p>count() 方法是一个终端操作，返回流中的元素个数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">long count();</span><br></pre></td></tr></table></figure>
<p>中间操作不会立即执行，只有等到终端操作的时候，流才开始真正地遍历，用于映射、过滤等。通俗点说，就是一次遍历执行多个操作，性能就大大提高了。</p>
<p>理论部分就扯这么多，下面直接进入实战部分。</p>
<p><strong>01、创建流 </strong></p>
<p>如果是数组的话，可以使用 Arrays.stream() 或者 Stream.of() 创建流；如果是集合的话，可以直接使用 stream() 方法创建流，因为该方法已经添加到 Collection 接口中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class CreateStreamDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String[] arr = new String[]&#123;&quot;武汉加油&quot;, &quot;中国加油&quot;, &quot;世界加油&quot;&#125;;</span><br><span class="line">        Stream&lt;String&gt; stream = Arrays.stream(arr);</span><br><span class="line">        stream = Stream.of(&quot;武汉加油&quot;, &quot;中国加油&quot;, &quot;世界加油&quot;);</span><br><span class="line">        List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        list.add(&quot;武汉加油&quot;);</span><br><span class="line">        list.add(&quot;中国加油&quot;);</span><br><span class="line">        list.add(&quot;世界加油&quot;);</span><br><span class="line">        stream = list.stream();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看 Stream 源码的话，你会发现 of() 方法内部其实调用了 Arrays.stream() 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static&lt;T&gt; Stream&lt;T&gt; of(T... values) &#123;</span><br><span class="line">    return Arrays.stream(values);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，集合还可以调用 parallelStream() 方法创建并发流，默认使用的是 ForkJoinPool.commonPool()线程池。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Long&gt; aList = new ArrayList&lt;&gt;();</span><br><span class="line">Stream&lt;Long&gt; parallelStream = aList.parallelStream();</span><br></pre></td></tr></table></figure>
<p><strong>02、操作流 </strong></p>
<p>Stream 类提供了很多有用的操作流的方法，我来挑一些常用的给你介绍一下。</p>
<p><strong>1）过滤 </strong></p>
<p>通过 filter() 方法可以从流中筛选出我们想要的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class FilterStreamDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        list.add(&quot;周杰伦&quot;);</span><br><span class="line">        list.add(&quot;王力宏&quot;);</span><br><span class="line">        list.add(&quot;陶喆&quot;);</span><br><span class="line">        list.add(&quot;林俊杰&quot;);</span><br><span class="line">        Stream&lt;String&gt; stream = list.stream().filter(element -&gt; element.contains(&quot;王&quot;));</span><br><span class="line">        stream.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>filter() 方法接收的是一个 Predicate（Java 8 新增的一个函数式接口，接受一个输入参数返回一个布尔值结果）类型的参数，因此，我们可以直接将一个 Lambda 表达式传递给该方法，比如说 element -&gt; element.contains(“王”) 就是筛选出带有“王”的字符串。</p>
<p>forEach() 方法接收的是一个 Consumer（Java 8 新增的一个函数式接口，接受一个输入参数并且无返回的操作）类型的参数，类名 :: 方法名是 Java 8 引入的新语法， System.out 返回 PrintStream 类，println 方法你应该知道是打印的。</p>
<p>stream.forEach(System.out::println); 相当于在 for 循环中打印，类似于下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (String s : strs) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显，一行代码看起来更简洁一些。来看一下程序的输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">王力宏</span><br></pre></td></tr></table></figure>
<p><strong>2）映射 </strong></p>
<p>如果想通过某种操作把一个流中的元素转化成新的流中的元素，可以使用 map() 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class MapStreamDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        list.add(&quot;周杰伦&quot;);</span><br><span class="line">        list.add(&quot;王力宏&quot;);</span><br><span class="line">        list.add(&quot;陶喆&quot;);</span><br><span class="line">        list.add(&quot;林俊杰&quot;);</span><br><span class="line">        Stream&lt;Integer&gt; stream = list.stream().map(String::length);</span><br><span class="line">        stream.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>map() 方法接收的是一个 Function（Java 8 新增的一个函数式接口，接受一个输入参数 T，返回一个结果 R）类型的参数，此时参数 为 String 类的 length 方法，也就是把 Stream<String> 的流转成一个 Stream<Integer> 的流。</p>
<p>程序输出的结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p><strong>3）匹配 </strong></p>
<p>Stream 类提供了三个方法可供进行元素匹配，它们分别是：</p>
<ul>
<li>anyMatch() ，只要有一个元素匹配传入的条件，就返回 true。</li>
<li>allMatch() ，只有有一个元素不匹配传入的条件，就返回 false；如果全部匹配，则返回 true。</li>
<li>noneMatch() ，只要有一个元素匹配传入的条件，就返回 false；如果全部不匹配，则返回 true。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class MatchStreamDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        list.add(&quot;周杰伦&quot;);</span><br><span class="line">        list.add(&quot;王力宏&quot;);</span><br><span class="line">        list.add(&quot;陶喆&quot;);</span><br><span class="line">        list.add(&quot;林俊杰&quot;);</span><br><span class="line">        boolean  anyMatchFlag = list.stream().anyMatch(element -&gt; element.contains(&quot;王&quot;));</span><br><span class="line">        boolean  allMatchFlag = list.stream().allMatch(element -&gt; element.length() &gt; </span><br><span class="line">1);</span><br><span class="line">        boolean  noneMatchFlag = list.stream().noneMatch(element -&gt; </span><br><span class="line">element.endsWith(&quot;沉&quot;));</span><br><span class="line">        System.out.println(anyMatchFlag);</span><br><span class="line">        System.out.println(allMatchFlag);</span><br><span class="line">        System.out.println(noneMatchFlag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为“王力宏”以“王”字开头，所以 anyMatchFlag 应该为 true；因为“周杰伦”、“王力宏”、“陶喆”、“林俊杰”的字符串长度都大于 1，所以 allMatchFlag 为 true；因为 4 个字符串结尾都不是“沉”，所以 noneMatchFlag 为 true。</p>
<p>程序输出的结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">true</span><br><span class="line">true</span><br></pre></td></tr></table></figure>
<p><strong>4）组合 </strong></p>
<p>reduce() 方法的主要作用是把 Stream 中的元素组合起来，它有两种用法：</p>
<ul>
<li>Optional<T> reduce(BinaryOperator<T> accumulator)</li>
</ul>
<p>没有起始值，只有一个参数，就是运算规则，此时返回 Optional。</p>
<ul>
<li>T reduce(T identity, BinaryOperator<T> accumulator)</li>
</ul>
<p>有起始值，有运算规则，两个参数，此时返回的类型和起始值类型一致。</p>
<p>来看下面这个例子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class ReduceStreamDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Integer[] ints = &#123;0, 1, 2, 3&#125;;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(ints);</span><br><span class="line">        Optional&lt;Integer&gt; optional = list.stream().reduce((a, b) -&gt; a + b);</span><br><span class="line">        Optional&lt;Integer&gt; optional1 = list.stream().reduce(Integer::sum);</span><br><span class="line">        System.out.println(optional.orElse(0));</span><br><span class="line">        System.out.println(optional1.orElse(0));</span><br><span class="line">        int reduce = list.stream().reduce(6, (a, b) -&gt; a + b);</span><br><span class="line">        System.out.println(reduce);</span><br><span class="line">        int reduce1 = list.stream().reduce(6, Integer::sum);</span><br><span class="line">        System.out.println(reduce1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运算规则可以是 Lambda 表达式（比如 (a, b) -&gt; a + b ），也可以是类名::方法名（比如 Integer::sum ）。</p>
<p>程序运行的结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">6</span><br><span class="line">12</span><br><span class="line">12</span><br></pre></td></tr></table></figure>
<p>0、1、2、3 在没有起始值相加的时候结果为 6；有起始值 6 的时候结果为 12。</p>
<p><strong>03、转换流 </strong></p>
<p>既然可以把集合或者数组转成流，那么也应该有对应的方法，将流转换回去—— collect() 方法就满足了这种需求。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class CollectStreamDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        list.add(&quot;周杰伦&quot;);</span><br><span class="line">        list.add(&quot;王力宏&quot;);</span><br><span class="line">        list.add(&quot;陶喆&quot;);</span><br><span class="line">        list.add(&quot;林俊杰&quot;);</span><br><span class="line">        String[] strArray = list.stream().toArray(String[]::new);</span><br><span class="line">        System.out.println(Arrays.toString(strArray));</span><br><span class="line">        List&lt;Integer&gt; list1 = </span><br><span class="line">list.stream().map(String::length).collect(Collectors.toList());</span><br><span class="line">        List&lt;String&gt; list2 = </span><br><span class="line">list.stream().collect(Collectors.toCollection(ArrayList::new));</span><br><span class="line">        System.out.println(list1);</span><br><span class="line">        System.out.println(list2);</span><br><span class="line">        String str = list.stream().collect(Collectors.joining(&quot;, &quot;)).toString();</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>toArray() 方法可以将流转换成数组，你可能比较好奇的是 String[]::new ，它是什么东东呢？来看一下 toArray() 方法的源码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator);</span><br></pre></td></tr></table></figure>
<p>也就是说 String[]::new 是一个 IntFunction，一个可以产生所需的新数组的函数，可以通过反编译字节码看看它到底是什么：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] strArray = (String[])list.stream().toArray((x$0) -&gt; &#123;</span><br><span class="line">    return new String[x$0];</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(Arrays.toString(strArray));</span><br></pre></td></tr></table></figure>
<p>也就是相当于返回了一个指定长度的字符串数组。</p>
<p>当我们需要把一个集合按照某种规则转成另外一个集合的时候，就可以配套使用 map() 方法和 collect() 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list1 = </span><br><span class="line">list.stream().map(String::length).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<p>通过 stream() 方法创建集合的流后，再通过 map(String:length) 将其映射为字符串长度的一个新流，最后通过 collect() 方法将其转换成新的集合。</p>
<p>Collectors 是一个收集器的工具类，内置了一系列收集器实现，比如说 toList() 方法将元素收集到一个新的 java.util.List 中；比如说 toCollection() 方法将元素收集到一个新的 java.util.ArrayList 中；比如说 joining() 方法将元素收集到一个可以用分隔符指定的字符串中。</p>
<p>来看一下程序的输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[周杰伦, 王力宏, 陶喆, 林俊杰]</span><br><span class="line">[3, 3, 2, 3]</span><br><span class="line">[周杰伦, 王力宏, 陶喆, 林俊杰]</span><br><span class="line">周杰伦, 王力宏, 陶喆, 林俊杰</span><br></pre></td></tr></table></figure>
<h2 id="8-2-Optional最佳指南"><a href="#8-2-Optional最佳指南" class="headerlink" title="8.2 Optional最佳指南"></a>8.2 Optional最佳指南</h2><p>想学习，永远都不晚，尤其是针对 Java 8 里面的好东西，Optional 就是其中之一，该类提供了一种用于表示可选值而非空引用的类级别解决方案。作为一名 Java 程序员，我真的是烦透了 NullPointerException（NPE），尽管和它熟得就像一位老朋友，知道它也是迫不得已——程序正在使用一个对象却发现这个对象的值为 null，于是 Java 虚拟机就怒发冲冠地把它抛了出来当做替罪羊。</p>
<p>当然了，我们程序员是富有责任心的，不会坐视不管，于是就有了大量的 null 值检查。尽管有时候这种检查完全没有必要，但我们已经习惯了例行公事。终于，Java 8 看不下去了，就引入了 Optional，以便我们编写的代码不再那么刻薄呆板。</p>
<p><img src="\assets\note\image-20231012160955090.png" alt="image-20231012160955090"></p>
<p><strong>01、没有 Optional 会有什么问题 </strong></p>
<p>我们来模拟一个实际的应用场景。小王第一天上班，领导老马就给他安排了一个任务，要他从数据库中根据会员 ID 拉取一个会员的姓名，然后将姓名打印到控制台。虽然是新来的，但这个任务难不倒小王，于是他花了 10 分钟写下了这段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class WithoutOptionalDemo &#123;</span><br><span class="line">    class Member &#123;</span><br><span class="line">        private String name;</span><br><span class="line">        public String getName() &#123;</span><br><span class="line">            return name;</span><br><span class="line">        &#125;</span><br><span class="line">        public void setName(String name) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Member mem = getMemberByIdFromDB();</span><br><span class="line">        if (mem != null) &#123;</span><br><span class="line">            System.out.println(mem.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static Member getMemberByIdFromDB() &#123;</span><br><span class="line">        // 当前 ID 的会员不存在</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于当前 ID 的会员不存在，所以 getMemberByIdFromDB() 方法返回了 null 来作为没有获取到该会员的结果，那就意味着在打印会员姓名的时候要先对 mem 判空，否则就会抛出 NPE 异常，不信？让小王把 if (mem != null) 去掉试试，控制台立马打印错误堆栈给你颜色看看。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.NullPointerException</span><br><span class="line">    at </span><br><span class="line">com.cmower.dzone.optional.WithoutOptionalDemo.main(WithoutOptionalDemo.java:24)</span><br></pre></td></tr></table></figure>
<p><strong>02、Optional 是如何解决这个问题的 </strong></p>
<p>小王把代码提交后，就兴高采烈地去找老马要新的任务了。本着虚心学习的态度，小王请求老马看一下自己的代码，于是老王就告诉他应该尝试一下 Optional，可以避免没有必要的 null 值检查。现在，让我们来看看小王是如何通过 Optional 来解决上述问题的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class OptionalDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Optional&lt;Member&gt; optional = getMemberByIdFromDB();</span><br><span class="line">        optional.ifPresent(mem -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;会员姓名是：&quot; + mem.getName());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static Optional&lt;Member&gt; getMemberByIdFromDB() &#123;</span><br><span class="line">        boolean hasName = true;</span><br><span class="line">        if (hasName) &#123;</span><br><span class="line">            return Optional.of(new Member(&quot;沉默王二&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">        return Optional.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Member &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    // getter / setter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getMemberByIdFromDB() 方法返回了 Optional<Member> 作为结果，这样就表明 Member 可能存在，也可能不存在，这时候就可以在 Optional 的 ifPresent() 方法中使用 Lambda 表达式来直接打印结果。</p>
<p>Optional 之所以可以解决 NPE 的问题，是因为它明确的告诉我们，不需要对它进行判空。它就好像十字路口的路标，明确地告诉你该往哪走。</p>
<p><strong>03、创建 Optional 对象 </strong></p>
<p>1）可以使用静态方法 empty() 创建一个空的 Optional 对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; empty = Optional.empty();</span><br><span class="line">System.out.println(empty); // 输出：Optional.empty</span><br></pre></td></tr></table></figure>
<p>2）可以使用静态方法 of() 创建一个非空的 Optional 对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; opt = Optional.of(&quot;沉默王二&quot;);</span><br><span class="line">System.out.println(opt); // 输出：Optional[沉默王二]</span><br></pre></td></tr></table></figure>
<p>当然了，传递给 of() 方法的参数必须是非空的，也就是说不能为 null，否则仍然会抛出 NullPointerException。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String name = null;</span><br><span class="line">Optional&lt;String&gt; optnull = Optional.of(name);</span><br></pre></td></tr></table></figure>
<p>3）可以使用静态方法 ofNullable() 创建一个即可空又可非空的 Optional 对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String name = null;</span><br><span class="line">Optional&lt;String&gt; optOrNull = Optional.ofNullable(name);</span><br><span class="line">System.out.println(optOrNull); // 输出：Optional.empty</span><br></pre></td></tr></table></figure>
<p>ofNullable() 方法内部有一个三元表达式，如果为参数为 null，则返回私有常量 EMPTY；否则使用 new 关键字创建了一个新的 Optional 对象——不会再抛出 NPE 异常了。</p>
<p><strong>04、判断值是否存在 </strong></p>
<p>可以通过方法 isPresent() 判断一个 Optional 对象是否存在，如果存在，该方法返回 true，否则返回 false——取代了 obj != null 的判断。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; opt = Optional.of(&quot;沉默王二&quot;);</span><br><span class="line">System.out.println(opt.isPresent()); // 输出：true</span><br><span class="line">Optional&lt;String&gt; optOrNull = Optional.ofNullable(null);</span><br><span class="line">System.out.println(opt.isPresent()); // 输出：false</span><br></pre></td></tr></table></figure>
<p>Java 11 后还可以通过方法 isEmpty() 判断与 isPresent() 相反的结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; opt = Optional.of(&quot;沉默王二&quot;);</span><br><span class="line">System.out.println(opt.isPresent()); // 输出：false</span><br><span class="line">Optional&lt;String&gt; optOrNull = Optional.ofNullable(null);</span><br><span class="line">System.out.println(opt.isPresent()); // 输出：true</span><br></pre></td></tr></table></figure>
<p><strong>05、非空表达式 </strong></p>
<p>Optional 类有一个非常现代化的方法—— ifPresent() ，允许我们使用函数式编程的方式执行一些代码，因此，我把它称为非空表达式。如果没有该方法的话，我们通常需要先通过 isPresent() 方法对 Optional 对象进行判空后再执行相应的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; optOrNull = Optional.ofNullable(null);</span><br><span class="line">if (optOrNull.isPresent()) &#123;</span><br><span class="line">    System.out.println(optOrNull.get().length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了 ifPresent() 之后，情况就完全不同了，可以直接将 Lambda 表达式传递给该方法，代码更加简洁，更加直观。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; opt = Optional.of(&quot;沉默王二&quot;);</span><br><span class="line">opt.ifPresent(str -&gt; System.out.println(str.length()));</span><br></pre></td></tr></table></figure>
<p>Java 9 后还可以通过方法 ifPresentOrElse(action, emptyAction) 执行两种结果，非空时执行 action，空时执行 emptyAction。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; opt = Optional.of(&quot;沉默王二&quot;);</span><br><span class="line">opt.ifPresentOrElse(str -&gt; System.out.println(str.length()), () -&gt; </span><br><span class="line">System.out.println(&quot;为空&quot;));</span><br></pre></td></tr></table></figure>
<p><strong>06、设置（获取）默认值 </strong></p>
<p>有时候，我们在创建（获取） Optional 对象的时候，需要一个默认值， orElse() 和 orElseGet() 方法就派上用场了。</p>
<p>orElse() 方法用于返回包裹在 Optional 对象中的值，如果该值不为 null，则返回；否则返回默认值。该方法的参数类型和值得类型一致。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String nullName = null;</span><br><span class="line">String name = Optional.ofNullable(nullName).orElse(&quot;沉默王二&quot;);</span><br><span class="line">System.out.println(name); // 输出：沉默王二</span><br></pre></td></tr></table></figure>
<p>orElseGet() 方法与 orElse() 方法类似，但参数类型不同。如果 Optional 对象中的值为 null，则执行参数中的函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String nullName = null;</span><br><span class="line">String name = Optional.ofNullable(nullName).orElseGet(()-&gt;&quot;沉默王二&quot;);</span><br><span class="line">System.out.println(name); // 输出：沉默王二</span><br></pre></td></tr></table></figure>
<p>从输出结果以及代码的形式上来看，这两个方法极其相似，这不免引起我们的怀疑，Java 类库的设计者有必要这样做吗？</p>
<p>假设现在有这样一个获取默认值的方法，很传统的方式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static String getDefaultValue() &#123;</span><br><span class="line">    System.out.println(&quot;getDefaultValue&quot;);</span><br><span class="line">    return &quot;沉默王二&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，通过 orElse() 方法和 orElseGet() 方法分别调用 getDefaultValue() 方法返回默认值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String name = null;</span><br><span class="line">    System.out.println(&quot;orElse&quot;);</span><br><span class="line">    String name2 = Optional.ofNullable(name).orElse(getDefaultValue());</span><br><span class="line">    System.out.println(&quot;orElseGet&quot;);</span><br><span class="line">    String name3 = </span><br><span class="line">Optional.ofNullable(name).orElseGet(OrElseOptionalDemo::getDefaultValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：类名 :: 方法名是 Java 8 引入的语法，方法名后面是没有 () 的，表明该方法并不一定会被调用。</p>
<p>输出结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">orElse</span><br><span class="line">getDefaultValue</span><br><span class="line">orElseGet</span><br><span class="line">getDefaultValue</span><br></pre></td></tr></table></figure>
<p>输出结果是相似的，没什么太大的不同，这是在 Optional 对象的值为 null 的情况下。假如 Optional 对象的值不为 null 呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String name = &quot;沉默王三&quot;;</span><br><span class="line">    System.out.println(&quot;orElse&quot;);</span><br><span class="line">    String name2 = Optional.ofNullable(name).orElse(getDefaultValue());</span><br><span class="line">    System.out.println(&quot;orElseGet&quot;);</span><br><span class="line">    String name3 = </span><br><span class="line">Optional.ofNullable(name).orElseGet(OrElseOptionalDemo::getDefaultValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">orElse</span><br><span class="line">getDefaultValue</span><br><span class="line">orElseGet</span><br></pre></td></tr></table></figure>
<p>咦， orElseGet() 没有去调用 getDefaultValue() 。哪个方法的性能更佳，你明白了吧？</p>
<p><strong>07、获取值 </strong></p>
<p>直观从语义上来看， get() 方法才是最正宗的获取 Optional 对象值的方法，但很遗憾，该方法是有缺陷的，因为假如 Optional 对象的值为 null，该方法会抛出 NoSuchElementException 异常。这完全与我们使用 Optional 类的初衷相悖。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class GetOptionalDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String name = null;</span><br><span class="line">        Optional&lt;String&gt; optOrNull = Optional.ofNullable(name);</span><br><span class="line">        System.out.println(optOrNull.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段程序在运行时会抛出异常：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.util.NoSuchElementException: No value present</span><br><span class="line">    at java.base/java.util.Optional.get(Optional.java:141)</span><br><span class="line">    at com.cmower.dzone.optional.GetOptionalDemo.main(GetOptionalDemo.java:9)</span><br></pre></td></tr></table></figure>
<p>尽管抛出的异常是 NoSuchElementException 而不是 NPE，但在我们看来，显然是在“五十步笑百步”。建议 orElseGet() 方法获取 Optional 对象的值。</p>
<p><strong>08、过滤值 </strong></p>
<p>小王通过 Optional 类对之前的代码进行了升级，完成后又兴高采烈地跑去找老马要任务了。老马觉得这小伙子不错，头脑灵活，又干活积极，很值得培养，就又交给了小王一个新的任务：用户注册时对密码的长度进行检查。</p>
<p>小王拿到任务后，乐开了花，因为他刚要学习 Optional 类的 filter() 方法，这就派上了用场。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class FilterOptionalDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String password = &quot;12345&quot;;</span><br><span class="line">        Optional&lt;String&gt; opt = Optional.ofNullable(password);</span><br><span class="line">        System.out.println(opt.filter(pwd -&gt; pwd.length() &gt; 6).isPresent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>filter() 方法的参数类型为 Predicate（Java 8 新增的一个函数式接口），也就是说可以将一个 Lambda 表达式传递给该方法作为条件，如果表达式的结果为 false，则返回一个 EMPTY 的 Optional 对象，否则返回过滤后的 Optional 对象。</p>
<p>在上例中，由于 password 的长度为 5 ，所以程序输出的结果为 false。假设密码的长度要求在 6 到 10 位之间，那么还可以再追加一个条件。来看小王增加难度后的代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;String&gt; len6 = pwd -&gt; pwd.length() &gt; 6;</span><br><span class="line">Predicate&lt;String&gt; len10 = pwd -&gt; pwd.length() &lt; 10;</span><br><span class="line">password = &quot;1234567&quot;;</span><br><span class="line">opt = Optional.ofNullable(password);</span><br><span class="line">boolean result = opt.filter(len6.and(len10)).isPresent();</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure>
<p>这次程序输出的结果为 true，因为密码变成了 7 位，在 6 到 10 位之间。想象一下，假如小王使用 if-else 来完成这个任务，代码该有多冗长。</p>
<p><strong>09、转换值 </strong></p>
<p>小王检查完了密码的长度，仍然觉得不够尽兴，觉得要对密码的强度也进行检查，比如说密码不能是“password”，这样的密码太弱了。于是他又开始研究起了 map() 方法，该方法可以按照一定的规则将原有 Optional 对象转换为一个新的 Optional 对象，原有的 Optional 对象不会更改。</p>
<p>先来看小王写的一个简单的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class OptionalMapDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String name = &quot;沉默王二&quot;;</span><br><span class="line">        Optional&lt;String&gt; nameOptional = Optional.of(name);</span><br><span class="line">        Optional&lt;Integer&gt; intOpt = nameOptional</span><br><span class="line">                .map(String::length);</span><br><span class="line">        </span><br><span class="line">        System.out.println( intOpt.orElse(0));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面这个例子中， map() 方法的参数 String::length ，意味着要 将原有的字符串类型的 Optional 按照字符串长度重新生成一个新的 Optional 对象，类型为 Integer。</p>
<p>搞清楚了 map() 方法的基本用法后，小王决定把 map() 方法与 filter() 方法结合起来用，前者用于将密码转化为小写，后者用于判断长度以及是否是“password”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class OptionalMapFilterDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String password = &quot;password&quot;;</span><br><span class="line">        Optional&lt;String&gt;  opt = Optional.ofNullable(password);</span><br><span class="line">        Predicate&lt;String&gt; len6 = pwd -&gt; pwd.length() &gt; 6;</span><br><span class="line">        Predicate&lt;String&gt; len10 = pwd -&gt; pwd.length() &lt; 10;</span><br><span class="line">        Predicate&lt;String&gt; eq = pwd -&gt; pwd.equals(&quot;password&quot;);</span><br><span class="line">        boolean result = opt.map(String::toLowerCase).filter(len6.and(len10 ).and(eq)).isPresent();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，我亲爱的读者朋友，以上就是本文的全部内容了——可以说是史上最佳 Optional 指南了，能看到这里的都是最优秀的程序员，二哥必须要伸出大拇指为你点个赞。</p>
<h2 id="8-3-深入浅出Lambda表达式"><a href="#8-3-深入浅出Lambda表达式" class="headerlink" title="8.3 深入浅出Lambda表达式"></a>8.3 深入浅出Lambda表达式</h2><p>今天分享的主题是《Lambda 表达式入门》，这也是之前一些读者留言强烈要求我写一写的，不好意思，让你们久等了，现在来满足你们，为时不晚吧？</p>
<p><strong>01、初识 Lambda </strong></p>
<p>Lambda 表达式描述了一个代码块（或者叫匿名方法），可以将其作为参数传递给构造方法或者普通方法以便后续执行。考虑下面这段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">() -&gt; System.out.println(&quot;沉默王二&quot;)</span><br></pre></td></tr></table></figure>
<p>来从左到右解释一下， () 为 Lambda 表达式的参数列表（本例中没有参数）， -&gt; 标识这串代码为 Lambda 表达式（也就是说，看到 -&gt; 就知道这是 Lambda）， System.out.println(“沉默王二”) 为要执行的代码，即将“沉默王二”打印到标准输出流。</p>
<p>有点 Java 基础的同学应该不会对 Runnable 接口感到陌生，这是多线程的一个基础接口，它的定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Runnable</span><br><span class="line">&#123;</span><br><span class="line">   public abstract void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Runnable 接口非常简单，仅有一个抽象方法 run() ；细心的同学会发现一个陌生的注解 @FunctionalInterface ，这个注解是什么意思呢？</p>
<p>我看了它的源码，里面有这样一段注释：</p>
<blockquote>
<p>Note that instances of functional interfaces can be created with lambda expressions, method references, or constructor references.</p>
</blockquote>
<p>大致的意思就是说，通过 @FunctionalInterface 标记的接口可以通过 Lambda 表达式创建实例。具体怎么表现呢？</p>
<p>原来我们创建一个线程并启动它是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class LamadaTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;沉默王二&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 Lambda 表达式呢？只需要下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class LamadaTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Thread(() -&gt; System.out.println(&quot;沉默王二&quot;)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是不是很妙！比起匿名内部类，Lambda 表达式不仅易于理解，更大大简化了必须编写的代码数量。</p>
<p><strong>02、Lambda 语法 </strong></p>
<p>每个 Lambda 表达式都遵循以下法则：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( parameter-list ) -&gt; &#123; expression-or-statements &#125;</span><br></pre></td></tr></table></figure>
<p>() 中的 parameter-list 是以逗号分隔的参数。你可以指定参数的类型，也可以不指定（编译器会根据上下文进行推断）。Java 11 后，还可以使用 var 关键字作为参数类型，有点 JavaScript 的味道。</p>
<p>-&gt; 相当于 Lambda 的标识符，就好像见到圣旨就见到了皇上。</p>
<p>{} 中的 expression-or-statements 为 Lambda 的主体，可以是一行语句，也可以多行。</p>
<p>可以通过 Lambda 表达式干很多事情，比如说</p>
<p>1）为变量赋值，示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Runnable r = () -&gt; &#123; System.out.println(&quot;沉默王二&quot;); &#125;;</span><br><span class="line">r.run();</span><br></pre></td></tr></table></figure>
<p>2）作为 return 结果，示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static FileFilter getFilter(String ext)</span><br><span class="line">&#123;</span><br><span class="line">    return (pathname) -&gt; pathname.toString().endsWith(ext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3）作为数组元素，示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">final PathMatcher matchers[] =</span><br><span class="line">&#123;</span><br><span class="line">        (path) -&gt; path.toString().endsWith(&quot;txt&quot;),</span><br><span class="line">        (path) -&gt; path.toString().endsWith(&quot;java&quot;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>4）作为普通方法或者构造方法的参数，示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Thread(() -&gt; System.out.println(&quot;沉默王二&quot;)).start();</span><br></pre></td></tr></table></figure>
<p>需要注意 Lambda 表达式的作用域范围。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    int limit = 10;</span><br><span class="line">    Runnable r = () -&gt; &#123;</span><br><span class="line">        int limit = 5;</span><br><span class="line">        for (int i = 0; i &lt; limit; i++)</span><br><span class="line">            System.out.println(i);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码在编译的时候会提示错误：变量 limit 已经定义过了。</p>
<p>和匿名内部类一样，不要在 Lambda 表达式主体内对方法内的局部变量进行修改，否则编译也不会通过：Lambda 表达式中使用的变量必须是 final 的。</p>
<p><img src="\assets\note\image-20231012164303511.png" alt="image-20231012164303511"></p>
<p>这个问题发生的原因是因为 Java 规范中是这样规定的：</p>
<blockquote>
<p>Any local variable, formal parameter, or exception parameter used but not declared in a lambda expression must either be declared final or be effectively final (§4.12.4), or a compile-time error occurs where the use is attempted.</p>
</blockquote>
<p>大致的意思就是说，Lambda 表达式中要用到的，但又未在 Lambda 表达式中声明的变量，必须声明为 final 或者是 effectively final，否则就会出现编译错误。</p>
<p>关于 final 和 effectively final 的区别，可能有些小伙伴不太清楚，这里多说两句。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">final int a;</span><br><span class="line">a = 1;</span><br><span class="line">// a = 2;</span><br><span class="line">// 由于 a 是 final 的，所以不能被重新赋值</span><br><span class="line">int b;</span><br><span class="line">b = 1;</span><br><span class="line">// b 此后再未更改</span><br><span class="line">// b 就是 effectively final</span><br><span class="line">int c;</span><br><span class="line">c = 1;</span><br><span class="line">// c 先被赋值为 1，随后又被重新赋值为 2</span><br><span class="line">c = 2;</span><br><span class="line">// c 就不是 effectively final</span><br></pre></td></tr></table></figure>
<p>明白了 final 和 effectively final 的区别后，我们了解到，如果把 limit 定义为 final，那就无法在 Lambda 表达式中修改变量的值。那有什么好的解决办法呢？既能让编译器不发出警告，又能修改变量的值。</p>
<p>思前想后，试来试去，我终于找到了 3 个可行的解决方案：</p>
<p>1）把 limit 变量声明为 static。</p>
<p>2）把 limit 变量声明为 AtomicInteger。</p>
<p>3）使用数组。</p>
<p>下面我们来详细地一一介绍下。</p>
<p><strong>01）把 limit 变量声明为 static </strong></p>
<p>要想把 limit 变量声明为 static，就必须将 limit 变量放在 main() 方法外部，因为 main() 方法本身是 static 的。完整的代码示例如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class ModifyVariable2StaticInsideLambda &#123;</span><br><span class="line">    static int limit = 10;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Runnable r = () -&gt; &#123;</span><br><span class="line">            limit = 5;</span><br><span class="line">            for (int i = 0; i &lt; limit; i++) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        new Thread(r).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看一下程序输出的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>OK，该方案是可行的。</p>
<p><strong>02）把 limit 变量声明为 AtomicInteger </strong></p>
<p>AtomicInteger 可以确保 int 值的修改是原子性的，可以使用 set() 方法设置一个新的 int 值， get() 方法获取当前的 int 值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class ModifyVariable2AtomicInsideLambda &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final AtomicInteger limit = new AtomicInteger(10);</span><br><span class="line">        Runnable r = () -&gt; &#123;</span><br><span class="line">            limit.set(5);</span><br><span class="line">            for (int i = 0; i &lt; limit.get(); i++) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        new Thread(r).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看一下程序输出的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<p>OK，该方案也是可行的。</p>
<p><strong>03）使用数组 </strong></p>
<p>使用数组的方式略带一些欺骗的性质，在声明数组的时候设置为 final，但更改 int 的值时却修改的是数组的一个元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class ModifyVariable2ArrayInsideLambda &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final int [] limits = &#123;10&#125;;</span><br><span class="line">        Runnable r = () -&gt; &#123;</span><br><span class="line">            limits[0] = 5;</span><br><span class="line">            for (int i = 0; i &lt; limits[0]; i++) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        new Thread(r).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看一下程序输出的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<p>OK，该方案也是可行的。</p>
<p><strong>03、Lambda 和 this 关键字 </strong></p>
<p>Lambda 表达式并不会引入新的作用域，这一点和匿名内部类是不同的。也就是说，Lambda 表达式主体内使用的 this 关键字和其所在的类实例相同。</p>
<p>来看下面这个示例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class LamadaTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new LamadaTest().work();</span><br><span class="line">    &#125;</span><br><span class="line">    public void work() &#123;</span><br><span class="line">        System.out.printf(&quot;this = %s%n&quot;, this);</span><br><span class="line">        Runnable r = new Runnable()</span><br><span class="line">        &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run()</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.printf(&quot;this = %s%n&quot;, this);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        new Thread(r).start();</span><br><span class="line">        new Thread(() -&gt; System.out.printf(&quot;this = %s%n&quot;, this)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Tips： %s 代表当前位置输出字符串， %n 代表换行符，也可以使用 \n 代替，但 %n 是跨平台的。</p>
<p>work() 方法中的代码可以分为 3 个部分：</p>
<p>1）单独的 this 关键字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.printf(&quot;this = %s%n&quot;, this);</span><br></pre></td></tr></table></figure>
<p>其中 this 为 main() 方法中通过 new 关键字创建的 LamadaTest 对象—— new LamadaTest() 。</p>
<p>2）匿名内部类中的 this 关键字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Runnable r = new Runnable()</span><br><span class="line">&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.printf(&quot;this = %s%n&quot;, this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中 this 为 work() 方法中通过 new 关键字创建的 Runnable 对象—— new Runnable(){…} 。</p>
<p><strong>3）Lambda 表达式中的 this 关键字</strong></p>
<p>其中 this 关键字和 1）中的相同。</p>
<p>我们来看一下程序的输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this = com.cmower.java_demo.journal.LamadaTest@3feba861</span><br><span class="line">this = com.cmower.java_demo.journal.LamadaTest$1@64f033cb</span><br><span class="line">this = com.cmower.java_demo.journal.LamadaTest@3feba861</span><br></pre></td></tr></table></figure>
<p>符合我们分析的预期。</p>
<p><strong>04、最后 </strong></p>
<p>尽管 Lambda 表达式在简化 Java 编程方面做了很多令人惊讶的努力，但在某些情况下，不当的使用仍然会导致不必要的混乱，大家伙慎用。</p>
<p>好了，我亲爱的读者朋友们，以上就是本文的全部内容了。能在疫情期间坚持看技术文，二哥必须要伸出大拇指为你点个赞 。原创不易，如果觉得有点用的话，请不要吝啬你手中点赞的权力——因为这将是我写作的最强动力。</p>
<h2 id="8-4-Java-14-新特性"><a href="#8-4-Java-14-新特性" class="headerlink" title="8.4 Java 14 新特性"></a>8.4 Java 14 新特性</h2><p>Java 14 的时候，新增了记录 Record、模式匹配 instanceof 等新特性，转正了 Java 12 时的 switch 表达式，我们一起来过一遍。</p>
<p><img src="\assets\note\image-20231012165354353.png" alt="image-20231012165354353"></p>
<p><strong>01、下载 JDK 14 </strong></p>
<blockquote>
<p>截止到2023年03月30日，Java 20 已经发布了，不过不是 LTS（长期支持）版本，Java 17、11、8 是目前提供支持的 LTS 版本。</p>
</blockquote>
<p>要想开箱，得先下载 JDK 14（如果你有更高版本，当然也可以），不然拿什么开箱呢，对吧？有 2 处地方可供下载，Oracle 上可以下载商用版， jdk.java.net  上可以下载开源版。我们就选择后者吧。</p>
<p><img src="\assets\note\image-20231012165434591.png" alt="image-20231012165434591"></p>
<p>我目前用的是 Windows 操作系统，所以就选择 Windows 版的 zip 包进行下载，完成后记得解压。</p>
<p><strong>02、升级 IntelliJ IDEA </strong></p>
<blockquote>
<p>截止到 2023年03月30日，Intellij IDEA 的最新版本是 2023.1。 </p>
</blockquote>
<p>需要把 IDEA 升级到抢先体验版 2020.1 EAP（如果你当前使用的版本大于此，当然也可以），否则无法支持 Java 14 的新特性。</p>
<p><img src="\assets\note\image-20231012165509661.png" alt="image-20231012165509661"></p>
<p>社区版的下载地址如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[https://www.jetbrains.com/idea/nextversion/#section=windows]</span><br><span class="line">(https://www.jetbrains.com/idea/nextversion/#section=windows)</span><br></pre></td></tr></table></figure>
<p>安装的时候可以把之前的版本卸载，也可以选择保留。完成后，我们来新建一个 Java 14 的项目。</p>
<p><img src="\assets\note\image-20231012165543125.png" alt="image-20231012165543125"></p>
<p><strong>01、instanceof </strong></p>
<p>按照新特性的顺序，我们就先从 instanceof 说起吧。旧式的 instanceof 的用法如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class OldInstanceOf &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Object str = &quot;Java 14，真香&quot;;</span><br><span class="line">        if (str instanceof String) &#123;</span><br><span class="line">            String s = (String)str;</span><br><span class="line">            System.out.println(s.length());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要先使用 instanceof 在 if 条件中判断 str 的类型是否为 String（第一步），再在  if 语句中将 str 强转为字符串类型（第二步），并且要重新声明一个变量用于强转后的赋值（第三步）。</p>
<p>三个步骤也不算多，但总觉得应该还有更好的语法，这不，Java 14 就想到了这一层。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class NewInstanceOf &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Object str = &quot;Java 14，真香&quot;;</span><br><span class="line">        if (str instanceof String s) &#123;</span><br><span class="line">            System.out.println(s.length());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以直接在 if 条件判断类型的时候添加一个变量，就不需要再强转和声明新的变量了。是不是特别简洁？但模式匹配的 instanceof 在 Java 14 中是预览版的，默认是不启用的，所以这段代码会有一个奇怪的编译错误（Java 14 中不支持模式匹配的 instanceof）。</p>
<p><img src="\assets\note\image-20231012165647328.png" alt="image-20231012165647328"></p>
<p>那怎么解决这个问题呢？需要在项目配置中手动设置一下语言的版本。</p>
<p><img src="\assets\note\image-20231012165705923.png" alt="image-20231012165705923"></p>
<p>设置完成后，编译错误就随风飘走了。程序输出的结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure>
<p>不错不错，真香。想知道 Java 编译器在背后帮我们做了什么吗？看一下反编译后的字节码就明白了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class NewInstanceOf &#123;</span><br><span class="line">    public NewInstanceOf() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Object str = &quot;Java 14，真香&quot;;</span><br><span class="line">        String s;</span><br><span class="line">        if (str instanceof String &amp;&amp; (s = (String)str) == (String)str) &#123;</span><br><span class="line">            System.out.println(s.length());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 if 条件判断前，先声明了变量 s，然后在 if  条件中进行了强转 s = (String)str) ，并且判断了 s 和 str 是否相等。确实是一个解放开放者生产力的好特性，强烈希望这个特性在下个版本中转正。</p>
<p><strong>02、Records </strong></p>
<p>在之前的一篇文章中，我谈到了类的不可变性，它是这样定义的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public final class Writer &#123;</span><br><span class="line">    private final String name;</span><br><span class="line">    private final int age;</span><br><span class="line"></span><br><span class="line">    public Writer(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么，对于 Records 来说，一条 Record 就代表一个不变的状态。尽管它会提供诸如 equals() 、hashCode() 、 toString() 、构造方法，以及字段的 getter，但它无意替代可变对象的类（没有 setter），以及 Lombok 提供的功能。</p>
<p>来用 Records 替代一下上面这个 Writer 类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public record Writer(String name, int age) &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>你看，一行代码就搞定。关键是比之前的代码功能更丰富，来看一下反编译后的字节码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public final class Writer extends java.lang.Record &#123;</span><br><span class="line">    private final java.lang.String name;</span><br><span class="line">    private final int age;</span><br><span class="line">    public Writer(java.lang.String name, int age) &#123; /* compiled code */ &#125;</span><br><span class="line">    public java.lang.String toString() &#123; /* compiled code */ &#125;</span><br><span class="line">    public final int hashCode() &#123; /* compiled code */ &#125;</span><br><span class="line">    public final boolean equals(java.lang.Object o) &#123; /* compiled code */ &#125;</span><br><span class="line">    public java.lang.String name() &#123; /* compiled code */ &#125;</span><br><span class="line">    public int age() &#123; /* compiled code */ &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类是 final 的，字段是 private final 的，构造方法有两个参数， toString() 、 hashCode() 、 equals() 方法也有了，getter 方法也有了，只不过没有 get 前缀。但是没有 setter 方法，也就是说 Records 确实针对的是不可变对象——鉴定完毕。那怎么使用 Records 呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class WriterDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Writer writer = new Writer(&quot;沉默王二&quot;,18);</span><br><span class="line">        System.out.println(&quot;toString：&quot; + writer);</span><br><span class="line">        System.out.println(&quot;hashCode：&quot; + writer.hashCode());</span><br><span class="line">        System.out.println(&quot;name：&quot; + writer.name());</span><br><span class="line">        System.out.println(&quot;age：&quot; + writer.age());</span><br><span class="line">        Writer writer1 = new Writer(&quot;沉默王二&quot;, 18);</span><br><span class="line">        System.out.println(&quot;equals：&quot; + (writer.equals(writer1)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出的结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">toString：Writer[name=沉默王二, age=18]</span><br><span class="line">hashCode：1130697218</span><br><span class="line">name：沉默王二</span><br><span class="line">age：18</span><br><span class="line">equals：true</span><br></pre></td></tr></table></figure>
<p>不错不错，真香，以后定义不可变类时就简单了，强烈希望这个特性在下个版本中转正。</p>
<p><strong>03、switch 表达式 </strong></p>
<p>关于 switch 表达式，我在之前的一篇文章中已经详细说明了，点击传送门可以跳转过去看看。两周时间过去了，switch 表达式终于“媳妇熬成婆”，转正了，恭喜恭喜。</p>
<p>记得这篇文章发表到掘金的时候，被喷子各种无脑 diss，说：“还以为你有什么技巧，没想到用的是 Java 13，可我们还停留在 Java 8 啊！”这显然是一种固步自封的心态，非常不可取，程序员不应该这样。一个最简单的道理就是，Java 6 当年也很经典，不是被 Java 8 取代了吗？随着时间的推移，Java 8 早晚会被更划时代的新版本取代——总要进步嘛。</p>
<p>关于 switch 表达式，这里就简单地搬个例子给你瞧瞧：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class SwitchDemo &#123;</span><br><span class="line">    enum PlayerTypes &#123;</span><br><span class="line">        TENNIS,</span><br><span class="line">        FOOTBALL,</span><br><span class="line">        BASKETBALL,</span><br><span class="line">        PINGPANG,</span><br><span class="line">        UNKNOWN</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(createPlayer(PlayerTypes.BASKETBALL));</span><br><span class="line">    &#125;</span><br><span class="line">    private static String createPlayer(PlayerTypes playerType) &#123;</span><br><span class="line">        return switch (playerType) &#123;</span><br><span class="line">            case TENNIS -&gt; &quot;网球运动员费德勒&quot;;</span><br><span class="line">            case FOOTBALL -&gt; &quot;足球运动员C罗&quot;;</span><br><span class="line">            case BASKETBALL -&gt; &quot;篮球运动员詹姆斯&quot;;</span><br><span class="line">            case PINGPANG -&gt; &quot;乒乓球运动员马龙&quot;;</span><br><span class="line">            case UNKNOWN -&gt; throw new IllegalArgumentException(&quot;未知&quot;);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了可以使用 -&gt; 的新式语法，还可以作为 return 结果，真香。</p>
<p><strong>04、Text Blocks </strong></p>
<p>在文本块（Text Blocks）出现之前，如果我们需要拼接多行的字符串，就需要很多英文双引号和加号，看起来就好像老太婆的裹脚布，非常不雅。如果恰好要拼接一些 HTML 格式的文本（原生 SQL 也是如此）的话，还要通过空格进行排版，通过换行转义符 \n 进行换行，这些繁琐的工作对于一名开发人员来说，简直就是灾难。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class OldTextBlock &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String html = &quot;&lt;html&gt;\n&quot; +</span><br><span class="line">                &quot;    &lt;body&gt;\n&quot; +</span><br><span class="line">                &quot;        &lt;p&gt;Hello, world&lt;/p&gt;\n&quot; +</span><br><span class="line">                &quot;    &lt;/body&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;/html&gt;\n&quot;;</span><br><span class="line">        System.out.println(html);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java 14 就完全不同了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class NewTextBlock &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String html = &quot;&quot;&quot;</span><br><span class="line">              &lt;html&gt;</span><br><span class="line">                  &lt;body&gt;</span><br><span class="line">                      &lt;p&gt;Hello, world&lt;/p&gt;</span><br><span class="line">                  &lt;/body&gt;</span><br><span class="line">              &lt;/html&gt;</span><br><span class="line">              &quot;&quot;&quot;;</span><br><span class="line">        System.out.println(html);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多余的英文双引号、加号、换行转义符，统统不见了。仅仅是通过前后三个英文双引号就实现了。我只能说，香，它真的香！</p>
<h1 id="9-Java-网络编程"><a href="#9-Java-网络编程" class="headerlink" title="9 Java 网络编程"></a>9 Java 网络编程</h1><h2 id="9-1-了解网络编程的基础知识"><a href="#9-1-了解网络编程的基础知识" class="headerlink" title="9.1 了解网络编程的基础知识"></a>9.1 了解网络编程的基础知识</h2><p>   在学习 Java 网络编程之前，我们先来了解什么是计算机网络。</p>
<p>   计算机网络是指两台或更多的计算机组成的网络，在同一个网络中，任意两台计算机都可以直接通信，因为所有计算机都需要遵循同一种网络协议。</p>
<p>   下面是一张简化的网络拓扑图。</p>
<p><img src="\assets\note\image-20231012170657008.png" alt="image-20231012170657008"></p>
<ul>
<li>用户设备：Laptop，用于访问网络资源。</li>
<li>网络交换机：Switch，用于连接局域网内的设备，例如 Laptop 和 Router。</li>
<li>路由器：Router，用于连接不同网络，将局域网与互联网相连。</li>
<li>防火墙：Firewall，用于保护网络内部资源，阻止未经授权的访问。</li>
<li>互联网：Internet，提供连接到其他网络和全球信息资源。</li>
<li><p>服务器：Server，用于托管网络应用程序和数据。</p>
<p>那什么是互联网呢？互联网是网络的网络（Internet），即把很多计算机网络连接起来，形成一个全球统一的互联网。</p>
<p>对某个特定的计算机网络来说，它可能使用网络协议 ABC，而另一个计算机网络可能使用网络协议 XYZ。如果计算机网络各自的通讯协议不统一，就没法把不同的网络连接起来形成互联网。因此，为了把计算机网络接入互联网，就必须使用 TCP/IP 协议。</p>
</li>
</ul>
<p>TCP/IP 协议泛指互联网协议，其中最重要的两个协议是 TCP 协议和 IP 协议。只有使用 TCP/IP 协议的计算机才能够联入互联网，使用其他网络协议（例如 NetBIOS、AppleTalk 协议等）是无法联入互联网的。</p>
<p><strong>IP 地址 </strong></p>
<p>  在互联网中，一个 IP 地址用于唯一标识一个网络接口（Network Interface）。一台联入互联网的计算机肯定有一个 IP 地址，但也可能有多个 IP 地址。</p>
<p> IP 地址分为 IPv4 和 IPv6 两种。IPv4 采用 32 位地址，类似 101.202.99.12 ，而 IPv6 采用 128 位地址，类似 2001:0DA8:100A:0000:0000:1020:F2F3:1428 。IPv4 地址总共有 232 个（大约 42 亿），而 IPv6 地址则总共有 2128 个（大约 340 万亿亿亿亿），IPv4 的地址目前已耗尽，而 IPv6 的地址是根本用不完的。</p>
<p> IP 地址又分为公网 IP 地址和内网 IP 地址。公网 IP 地址可以直接被访问，内网 IP 地址只能在内网访问。内网 IP 地址类似于：</p>
<ul>
<li>192.168.x.x</li>
<li><p>10.x.x.x</p>
<p> 有一个特殊的 IP 地址，称之为本机地址，它总是 127.0.0.1 。</p>
<p> IPv4 地址实际上是一个 32 位整数。例如：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1707762444 = 0x65ca630c</span><br><span class="line">           = 65  ca  63 0c</span><br><span class="line">           = 101.202.99.12</span><br></pre></td></tr></table></figure>
<p>   如果一台计算机只有一个网卡，并且接入了网络，那么，它有一个本机地址 127.0.0.1 ，还有一个 IP 地址，例如 101.202.99.12 ，可以通过这个 IP 地址接入网络。</p>
<p>   如果一台计算机有两块网卡，那么除了本机地址，它可以有两个 IP 地址，可以分别接入两个网络。通常连接两个网络的设备是路由器或者交换机，它至少有两个 IP 地址，分别接入不同的网络，让网络之间连接起来。</p>
<p>  如果两台计算机位于同一个网络，那么他们之间可以直接通信，因为他们的 IP 地址前段是相同的，也就是网络号是相同的。网络号是 IP 地址通过子网掩码过滤后得到的。例如：</p>
<p>   某台计算机的 IP 是 101.202.99.2 ，子网掩码是 255.255.255.0 ，那么计算该计算机的网络号是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IP = 101.202.99.2</span><br><span class="line">Mask = 255.255.255.0</span><br><span class="line">Network = IP &amp; Mask = 101.202.99.0</span><br></pre></td></tr></table></figure>
<p>   每台计算机都需要正确配置 IP 地址和子网掩码，根据这两个就可以计算网络号，如果两台计算机计算出的网络号相同，说明两台计算机在同一个网络，可以直接通信。如果两台计算机计算出的网络号不同，那么两台计算机不在同一个网络，不能直接通信，它们之间必须通过路由器或者交换机这样的网络设备间接通信，我们把这种设备称为网关。</p>
<p>   网关的作用就是连接多个网络，负责把来自一个网络的数据包发到另一个网络，这个过程叫路由。</p>
<p>   所以，一台计算机的一个网卡会有 3 个关键配置：</p>
<ul>
<li>IP 地址，例如： 10.0.2.15</li>
<li>子网掩码，例如： 255.255.255.0</li>
<li>网关的 IP 地址，例如： 10.0.2.2</li>
</ul>
<p><em>域名 *</em></p>
<p>   因为直接记忆 IP 地址非常困难，所以我们通常使用域名访问某个特定的服务。域名解析服务器 DNS 负责把域名翻译成对应的 IP，客户端再根据 IP 地址访问服务器。</p>
<p>   用 nslookup可以查看域名对应的 IP 地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ nslookup www.tobebetterjavaer.com</span><br><span class="line">Server:  xxx.xxx.xxx.xxx</span><br><span class="line">Address: xxx.xxx.xxx.xxx#53</span><br><span class="line">Non-authoritative answer:</span><br><span class="line">Name:    www.tobebetterjavaer.com</span><br><span class="line">Address: 47.98.33.223</span><br></pre></td></tr></table></figure>
<p>有一个特殊的本机域名 localhost ，它对应的 IP 地址总是本机地址 127.0.0.1 。</p>
<p><strong>网络模型 </strong></p>
<p>由于计算机网络从底层的传输到高层的软件设计十分复杂，要合理地设计计算机网络模型，必须采用分层模型，每一层负责处理自己的操作。OSI（Open System Interconnect）网络模型是 ISO 组织定义的一个计算机互联的标准模型，注意它只是一个定义，目的是为了简化网络各层的操作，提供标准接口便于实现和维护。这个模型从上到下依次是：</p>
<ul>
<li>应用层，提供应用程序之间的通信；</li>
<li>表示层：处理数据格式，加解密等等；</li>
<li>会话层：负责建立和维护会话；</li>
<li>传输层：负责提供端到端的可靠传输；</li>
<li>网络层：负责根据目标地址选择路由来传输数据；</li>
<li>链路层和物理层负责把数据进行分片并且真正通过物理网络传输，例如，无线网、光纤等。</li>
</ul>
<p>互联网实际使用的 TCP/IP 模型并不是对应到 OSI 的 7 层模型，而是大致对应 OSI 的 5 层模型：</p>
<p><img src="\assets\note\image-20231012171450388.png" alt="image-20231012171450388"></p>
<p><strong>常用协议 </strong></p>
<p>IP 协议是一个分组交换，它不保证可靠传输。而 TCP 协议是传输控制协议，它是面向连接的协议，支持可靠传输和双向通信。TCP 协议是建立在 IP 协议之上的，简单地说，IP 协议只负责发数据包，不保证顺序和正确性，而 TCP 协议负责控制数据包传输，它在传输数据之前需要先建立连接，建立连接后才能传输数据，传输完后还需要断开连接。TCP 协议之所以能保证数据的可靠传输，是通过接收确认、超时重传这些机制实现的。并且，TCP 协议允许双向通信，即通信双方可以同时发送和接收数据。</p>
<p>TCP 协议也是应用最广泛的协议，许多高级协议都是建立在 TCP 协议之上的，例如 HTTP、SMTP 等。</p>
<p>TCP（传输控制协议）和 IP（互联网协议）通常一起使用，被称为 TCP/IP 协议。</p>
<p>TCP/IP 协议栈分为四层：应用层、传输层、网络层和链路层。IP 协议位于网络层，负责将数据包从源主机路由到目标主机；TCP 协议位于传输层，负责在源主机和目标主机之间建立可靠的连接并确保数据的有序传输。</p>
<p><img src="\assets\note\image-20231012171611979.png" alt="image-20231012171611979"></p>
<p>UDP 协议（User Datagram Protocol）是一种数据报文协议，它是无连接协议，不保证可靠传输。因为 UDP 协议在通信前不需要建立连接，因此它的传输效率比 TCP 高，而且 UDP 协议比 TCP 协议要简单得多。<br><img src="\assets\note\image-20231012171715508.png" alt="image-20231012171715508"></p>
<p>选择 UDP 协议时，传输的数据通常是能容忍丢失的，例如，一些语音视频通信的应用会选择 UDP 协议。</p>
<p><strong>小结 </strong></p>
<p>计算机网络的基本概念主要有：</p>
<ul>
<li>计算机网络：由两台或更多计算机组成的网络；</li>
<li>互联网：连接网络的网络；</li>
<li>IP 地址：计算机的网络接口（通常是网卡）在网络中的唯一标识；</li>
<li>网关：负责连接多个网络，并在多个网络之间转发数据的计算机，通常是路由器或交换机；</li>
<li>网络协议：互联网使用 TCP/IP 协议，它泛指互联网协议簇；</li>
<li>IP 协议：一种分组交换传输协议；</li>
<li>TCP 协议：一种面向连接，可靠传输的协议；</li>
<li>UDP 协议：一种无连接，不可靠传输的协议。</li>
</ul>
<h2 id="9-2-网络编程的核心套接字Socket"><a href="#9-2-网络编程的核心套接字Socket" class="headerlink" title="9.2 网络编程的核心套接字Socket"></a>9.2 网络编程的核心套接字Socket</h2><p>在古代，由于通信不便利，一些聪明的人就利用鸽子会飞且飞得比较快、会辨认方向的优点，对其进行了驯化，用来进行消息的传递——也就是所谓的“飞鸽传书”。而在 Java 中，网络套接字（Socket）扮演了同样的角色。</p>
<p>套接字（Socket）是一个抽象层，应用程序可以通过它发送或接收数据；就像操作文件那样可以打开、读写和关闭。套接字允许应用程序将 I/O 应用于网络中，并与其他应用程序进行通信。网络套接字是 IP 地址与端口的组合。</p>
<p><strong>01、ping 与 telnet </strong></p>
<p>“老王啊，能不能帮我看一下这个问题呢，明明本地可以进行网络通信，可等我部署到服务器上时就通信不了了，搞了半天也不知道什么原因，我看代码是没有问题的。”小二的语气中充满了沮丧。</p>
<p>“ping 过吗？或者 telnet 了吗？”老王头都没回，冷冰冰地扔出去了这句话。</p>
<p>“哦，我去试试。”小二心头掠过一丝愧疚。</p>
<p>ping 与 telnet 这两个命令，对调试网络程序有着非常大的帮助。</p>
<p>ping，一种计算机网络工具，用来测试数据包能否透过 IP 协议到达特定主机。ping 会向目标主机发出一个 ICMP 的请求回显数据包，并等待接收回显响应数据包。</p>
<p>例如，我们 ping 一下博客园。截图如下。</p>
<p><img src="\assets\note\image-20231012172050272.png" alt="image-20231012172050272"></p>
<p>telnet，Internet 远程登录服务的标准协议和主要方式，可以让我们坐在家里的计算机面前，登录到另一台远在天涯海角的远程计算机上。</p>
<p><img src="\assets\note\image-20231012172107961.png" alt="image-20231012172107961"></p>
<p>在 Windows 系统中，telnet 一般是默认安装的，但未激活（可以在控制面板中激活它）。</p>
<p>例如，我们 telnet 一下火（shui）土（mu）社区。截图如下。</p>
<p><img src="\assets\note\image-20231012172144042.png" alt="image-20231012172144042"></p>
<p>使用 telnet 登录远程计算机时，需要远程计算机上运行一个服务，它一直不停地等待那些希望和它进行连接的网络请求；当接收到一个客户端的网络连接时，它便唤醒正在监听网络连接请求的服务器进程，并为两者建立连接。连接会一直保持，直到某一方中止。</p>
<p>不过，需要注意的是，telnet 在格外重视安全的现代网络技术中并不受到重用。因为 telnet 是一个明文传输协议，用户的所有内容（包括用户名和密码）都没有经过加密，安全隐患非常大。</p>
<p><strong>02、Socket 实例 </strong></p>
<p>不知道你有没有体验一下 telnet 火土社区的那条命令，结果非常有趣。我们也可以通过 Java 的客户端套接字（Socket）实现，代码示例如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">try (Socket socket = new Socket(&quot;bbs.newsmth.net&quot;, 23);) &#123;</span><br><span class="line">    InputStream is = socket.getInputStream();</span><br><span class="line">    Scanner scanner = new Scanner(is, &quot;gbk&quot;);</span><br><span class="line">    while (scanner.hasNextLine()) &#123;</span><br><span class="line">        String line = scanner.nextLine();</span><br><span class="line">        System.out.println(line);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; catch (UnknownHostException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1）建立套接字连接非常简单，只需要一行代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Socket socket = new Socket(host, port)</span><br></pre></td></tr></table></figure>
<p>host 为主机名，port 为端口号（23 为默认的 telnet 端口号）。如果无法确定主机的 IP 地址，则抛出 UnknownHostException 异常；如果在创建套接字时发生 IO 错误，则抛出 IOException 异常。</p>
<p>需要注意的是，套接字在建立的时候，如果远程主机不可访问，这段代码就会阻塞很长时间，直到底层操作系统的限制而抛出异常。所以一般会在套接字建立后设置一个超时时间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Socket socket = new Socket(...);</span><br><span class="line">socket.setSoTimeout(10000); // 单位为毫秒</span><br></pre></td></tr></table></figure>
<p>2）套接字连接成功后，可以通过 java.net.Socket 类的 getInputStream() 方法获取输入流。有了 InputStream 对象后，可以借助文本扫描器类（Scanner）将其中的内容打印出来。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">InputStream is = socket.getInputStream();</span><br><span class="line">Scanner scanner = new Scanner(is, &quot;gbk&quot;);</span><br><span class="line">while (scanner.hasNextLine()) &#123;</span><br><span class="line">    String line = scanner.nextLine();</span><br><span class="line">    System.out.println(line);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>部分结果（完整结果自己亲手实践一下哦）如下图所示：</p>
<p><img src="\assets\note\image-20231012172449644.png" alt="image-20231012172449644"></p>
<p><strong>03、ServerSocket 实例 </strong></p>
<p>接下来，我们模拟一个远程服务，通过 java.net.ServerSocket 实现。代码示例如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">try (ServerSocket server = new ServerSocket(8888);</span><br><span class="line">        Socket socket = server.accept();</span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line">        Scanner scanner = new Scanner(is)) &#123;</span><br><span class="line">    PrintWriter pw = new PrintWriter(new OutputStreamWriter(os, &quot;gbk&quot;), true);</span><br><span class="line">    pw.println(&quot;你好啊，欢迎关注「沉默王二」 公众号，回复关键字「2048」 领取程序员进阶必读资料</span><br><span class="line">包&quot;);</span><br><span class="line">    boolean done = false;</span><br><span class="line">    while (!done &amp;&amp; scanner.hasNextLine()) &#123;</span><br><span class="line">        String line = scanner.nextLine();</span><br><span class="line">        System.out.println(line);</span><br><span class="line">        if (&quot;2048&quot;.equals(line)) &#123;</span><br><span class="line">            done = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; catch (UnknownHostException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1）建立服务器端的套接字也比较简单，只需要指定一个能够独占的端口号就可以了（0~1023 这些端口都已经被系统预留了）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerSocket server = new ServerSocket(8888);</span><br></pre></td></tr></table></figure>
<p>2）调用 ServerSocket 对象的 accept() 等待客户端套接字的连接请求。一旦监听到客户端的套接字请求，就会返回一个表示连接已建立的 Socket 对象，可以从中获取到输入流和输出流。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Socket socket = server.accept();</span><br><span class="line">InputStream is = socket.getInputStream();</span><br><span class="line">OutputStream os = socket.getOutputStream();</span><br></pre></td></tr></table></figure>
<p>客户端套接字发送的所有信息都会包裹在服务器端套接字的输入流中；而服务器端套接字发送的所有信息都会包裹在客户端套接字的输出流中。</p>
<p>3）服务器端可以通过以下代码向客户端发送消息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PrintWriter pw = new PrintWriter(new OutputStreamWriter(os, &quot;gbk&quot;), true);</span><br><span class="line">pw.println(&quot;你好啊，欢迎关注「沉默王二」 公众号，回复关键字「2048」 领取程序员进阶必读资料包&quot;);</span><br></pre></td></tr></table></figure>
<p>4）服务器端可以通过以下代码读取客户端发送过来的消息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Scanner scanner = new Scanner(is);</span><br><span class="line">boolean done = false;</span><br><span class="line">while (!done &amp;&amp; scanner.hasNextLine()) &#123;</span><br><span class="line">    String line = scanner.nextLine();</span><br><span class="line">    System.out.println(line);</span><br><span class="line">    if (&quot;2048&quot;.equals(line)) &#123;</span><br><span class="line">        done = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行该服务后，可以通过 telnet localhost 8888 命令连接该远程服务，不出所料，你将会看到以下信息。</p>
<p><img src="\assets\note\image-20231012172655575.png" alt="image-20231012172655575"></p>
<p>PS：可以在当前命令窗口中输入 2048，服务端收到该消息后会中断该套接字连接（当前窗口会显示“遗失对主机的连接”）。</p>
<p><strong>04、为多个客户端服务 </strong></p>
<p>非常遗憾的是，上面的例子中，服务器端只能为一个客户端服务——这不符合服务器端一对多的要求。</p>
<p>优化方案也非常简单（你应该也能想得到）：服务器端接收到客户端的套接字请求时，可以启动一个线程来处理，而主程序继续等待下一个连接。代码示例如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">try (ServerSocket server = new ServerSocket(8888)) &#123;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        Socket socket = server.accept();</span><br><span class="line">        Thread thread = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">              // 套接字处理程序</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程内部（ run(){} 方法里）用来处理套接字，代码示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    InputStream is = socket.getInputStream();</span><br><span class="line">    OutputStream os = socket.getOutputStream();</span><br><span class="line">    Scanner scanner = new Scanner(is);</span><br><span class="line">   // 其他代码省略</span><br><span class="line">   // 向客户端发送消息</span><br><span class="line">   // 读取客户端发送过来的消息</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务器端代码优化后重新运行，你就可以通过 telnet 命令测试了。打开一个命令行窗口输入 telnet localhost 8888 ，再打开一个新的命令行窗口输入 telnet localhost 8888 ，多个窗口都可以和服务器端进行通信，除非服务器端代码中断运行。</p>
<p><strong>05、加入多线程 </strong></p>
<p>多线程我们后面会详细讲，这里就主要是写个例子，好让大家感觉更有趣一些，其实也非常简单。</p>
<p>来看服务端：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">import java.net.ServerSocket;</span><br><span class="line">import java.net.Socket;</span><br><span class="line">public class MultiThreadedServer &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        int port = 12345;</span><br><span class="line">        ServerSocket serverSocket = new ServerSocket(port);</span><br><span class="line">        System.out.println(&quot;Server is listening on port &quot; + port);</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            Socket socket = serverSocket.accept();</span><br><span class="line">            System.out.println(&quot;Client connected&quot;);</span><br><span class="line">            new ClientHandler(socket).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class ClientHandler extends Thread &#123;</span><br><span class="line">    private Socket socket;</span><br><span class="line">    public ClientHandler(Socket socket) &#123;</span><br><span class="line">        this.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            InputStream input = socket.getInputStream();</span><br><span class="line">            BufferedReader reader = new BufferedReader(new InputStreamReader(input));</span><br><span class="line">            OutputStream output = socket.getOutputStream();</span><br><span class="line">            PrintWriter writer = new PrintWriter(output, true);</span><br><span class="line">            String line;</span><br><span class="line">            while ((line = reader.readLine()) != null) &#123;</span><br><span class="line">                System.out.println(&quot;Received: &quot; + line);</span><br><span class="line">                writer.println(&quot;Server: &quot; + line);</span><br><span class="line">            &#125;</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            System.out.println(&quot;Client disconnected&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们使用了一个 ClientHandler 类，该类继承自 Thread 类。这使得每个客户端连接都可以在单独的线程中处理，从而允许服务器同时处理多个客户端连接。当一个新客户端连接到服务器时，服务器会创建一个新的 ClientHandler 对象，并使用 start() 方法启动线程。ClientHandler 类的 run() 方法包含处理客户端请求的逻辑。</p>
<p>来看客户端代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">import java.net.Socket;</span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        String hostname = &quot;localhost&quot;;</span><br><span class="line">        int port = 12345;</span><br><span class="line">        Socket socket = new Socket(hostname, port);</span><br><span class="line">        System.out.println(&quot;Connected to the server&quot;);</span><br><span class="line">        InputStream input = socket.getInputStream();</span><br><span class="line">        BufferedReader reader = new BufferedReader(new InputStreamReader(input));</span><br><span class="line">        OutputStream output = socket.getOutputStream();</span><br><span class="line">        PrintWriter writer = new PrintWriter(output, true);</span><br><span class="line">        writer.println(&quot;Hello, server!&quot;);</span><br><span class="line">        String response = reader.readLine();</span><br><span class="line">        System.out.println(&quot;Server response: &quot; + response);</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动服务器端，然后多启动几个客户端，就可以体验到交互的乐趣了。</p>
<p><img src="\assets\note\image-20231012173056208.png" alt="image-20231012173056208"></p>
<p><strong>08、DatagramSocket 实例 </strong></p>
<p>DatagramSocket 类是 Java 中实现 UDP 协议的核心类。与基于 TCP 的 Socket 和 ServerSocket 类不同，DatagramSocket 类提供了无连接的通信服务，发送和接收数据包。由于无需建立连接，UDP 通常比 TCP 更快，但可能不如 TCP 可靠。</p>
<p>以下是一个简单的 DatagramSocket 示例，展示了如何使用 UDP 协议在客户端和服务器之间发送和接收消息。</p>
<p>服务器端代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.DatagramPacket;</span><br><span class="line">import java.net.DatagramSocket;</span><br><span class="line">public class UDPServer &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        int port = 12345;</span><br><span class="line">        DatagramSocket serverSocket = new DatagramSocket(port);</span><br><span class="line">        System.out.println(&quot;Server is listening on port &quot; + port);</span><br><span class="line">        byte[] buffer = new byte[1024];</span><br><span class="line">        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);</span><br><span class="line">        serverSocket.receive(packet);</span><br><span class="line">        String message = new String(packet.getData(), 0, packet.getLength());</span><br><span class="line">        System.out.println(&quot;Received: &quot; + message);</span><br><span class="line">        serverSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.*;</span><br><span class="line">public class UDPClient &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        String hostname = &quot;localhost&quot;;</span><br><span class="line">        int port = 12345;</span><br><span class="line">        InetAddress address = InetAddress.getByName(hostname);</span><br><span class="line">        DatagramSocket clientSocket = new DatagramSocket();</span><br><span class="line">        String message = &quot;Hello, server!&quot;;</span><br><span class="line">        byte[] buffer = message.getBytes();</span><br><span class="line">        DatagramPacket packet = new DatagramPacket(buffer, buffer.length, address, </span><br><span class="line">port);</span><br><span class="line">        clientSocket.send(packet);</span><br><span class="line">        System.out.println(&quot;Message sent&quot;);</span><br><span class="line">        clientSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，服务器端创建一个 DatagramSocket 对象并监听端口 12345。然后，它创建一个 DatagramPacket 对象，用于存储接收到的数据包。 serverSocket.receive(packet) 方法阻塞，直到收到一个数据包。收到数据包后，服务器从数据包中提取并打印消息。</p>
<p>客户端首先解析服务器的 IP 地址，然后创建一个 DatagramSocket 对象。接着，客户端创建一个包含要发送消息的 DatagramPacket 对象，并指定目标地址和端口。最后，客户端通过调用 clientSocket.send(packet) 方法发送数据包。</p>
<p>运行结果如下所示：</p>
<p><img src="\assets\note\image-20231012173305989.png" alt="image-20231012173305989"></p>
<p><strong>07、最后 </strong></p>
<p>如今大多数基于网络的软件，如浏览器、即时通讯工具甚至是 P2P 下载都是基于 Socket 实现的，所以掌握 Java Socket 编程还是蛮有必要的。Socket 编程也比较有趣，很多初学者都会编写一两个基于“客户端-服务器端”的小程序来提高自己的编程水平，建议你也试一试。</p>
<h2 id="9-3-用Socket实现一个HTTP服务器"><a href="#9-3-用Socket实现一个HTTP服务器" class="headerlink" title="9.3 用Socket实现一个HTTP服务器"></a>9.3 用Socket实现一个HTTP服务器</h2><p>作为一个 Java 后端，提供 HTTP 服务可以说是基本技能之一了，但是你真的了解 HTTP 协议么？你知道知道如何手撸一个 HTTP 服务器么？Tomcat 的底层是怎么支持 HTTP 服务的呢？大名鼎鼎的 Servlet 又是什么东西呢，该怎么使用呢？</p>
<p>在初学 Java 时，Socket 编程是逃不掉的一章；虽然在实际业务项目中，使用这个的可能性基本为 0， 但并不意味着不用学。本篇将主要介绍如何使用 Socket 来实现一个简单的 HTTP 服务器，提供常见的 get/post 请求支持，并在此过程中了解下 HTTP 协议。</p>
<p><strong>I. HTTP 服务器从 0 到 1 </strong></p>
<p>既然我们的目标是借助 Socket 来搭建 HTTP 服务器，那么我们首先需要确认两点，一是如何使用 Socket；另一个则是 HTTP 协议如何解析数据；下面分别进行说明。</p>
<p><strong>1.Socket 编程基础 </strong></p>
<p>我们这里主要是利用 ServerSocket 来绑定端口，提供 TCP 服务，基本使用姿势也比较简单，一般套路如下</p>
<ul>
<li>创建 ServerSocket 对象，绑定监听端口</li>
<li>通过 accept() 方法监听客户端请求</li>
<li>连接建立后，通过输入流读取客户端发送的请求信息</li>
<li>通过输出流向客户端发送响应信息</li>
<li>关闭相关资源</li>
</ul>
<p>对应的伪代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ServerSocket serverSocket = new ServerSocket(port, ip)</span><br><span class="line">serverSocket.accept();</span><br><span class="line">// 接收请求数据</span><br><span class="line">socket.getInputStream();</span><br><span class="line">// 返回数据给请求方</span><br><span class="line">out = socket.getOutputStream()</span><br><span class="line">out.print(xxx)</span><br><span class="line">out.flush();;</span><br><span class="line">// 关闭连接</span><br><span class="line">socket.close()</span><br></pre></td></tr></table></figure>
<p>具体的代码，我们前面的章节详细地讲过了，第一次来的小伙伴可以戳链接去学习一下。</p>
<p><strong>2.HTTP 协议 </strong></p>
<p>ServerSocket 走的是 TCP 协议，HTTP 协议本身是在 TCP 协议之上的一层。</p>
<p>TCP 是一种面向连接的、可靠的、基于字节流的传输层协议。TCP 在两个网络节点之间提供了一条可靠的通信信道，确保数据在传输过程中不会丢失、重复或乱序。TCP 使用握手过程建立连接，通过确认和重传机制确保数据可靠传输，并使用流量控制和拥塞控制算法来优化网络性能。</p>
<p>HTTP 是一个用于在 Web 浏览器和 Web 服务器之间传输超文本、图像、视频和其他媒体资源的应用层协议。HTTP 使用请求-响应模型，即客户端（通常是 Web 浏览器）发送请求给服务器，服务器处理请求并返回响应。HTTP 协议定义了一组方法（如 GET、POST、PUT、DELETE 等），用于指定请求的类型和目的。</p>
<p>此外，HTTP 协议还定义了一组状态代码（如 200、404、500 等），用于表示响应的结果。</p>
<p>HTTP 协议依赖于 TCP 协议来传输数据。当 Web 浏览器向 Web 服务器发送 HTTP 请求时，它首先使用 TCP 协议与服务器建立连接。一旦连接建立，HTTP 请求消息会被封装在 TCP 数据包中，然后通过 TCP 信道发送给服务器。服务器收到 TCP 数据包后，解包提取 HTTP 请求消息，处理请求并生成 HTTP 响应消息。最后，HTTP 响应消息被封装在 TCP 数据包中，并通过相同的 TCP 信道发送回客户端。客户端收到 TCP 数据包后，解包提取 HTTP 响应消息并显示给用户。</p>
<p><img src="\assets\note\image-20231012173621334.png" alt="image-20231012173621334"></p>
<p>这幅图展示了客户端（Web 浏览器）与服务器（Web 服务器）之间的 HTTP 请求和响应，它们通过可靠的、面向连接的 TCP 连接进行数据传输。</p>
<p>好，再说回 HTTP 服务器这件事，最需要关注的无非两点：</p>
<ul>
<li>请求的数据怎么按照 HTTP 协议解析出来</li>
<li>如何按照 HTTP 协议，返回数据</li>
</ul>
<p>所以我们需要知道数据格式的规范。</p>
<p><strong>请求消息</strong></p>
<p>HTTP 请求消息由请求行（Request Line）、请求头（Request Headers）、空行（Empty Line）、请求体（Request Body，可选）几个部分组成。</p>
<p>①、请求行又包含三个部分，HTTP 方法（例如 GET, POST, PUT, DELETE 等）、请求的目标 URL（通常是相对 URL，但也可以是绝对 URL）、HTTP 版本（例如 HTTP/1.1 或 HTTP/2），这些部分用空格分隔，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html HTTP/1.1</span><br></pre></td></tr></table></figure>
<p>②、请求头是一系列以键值对表示的元数据，用于描述请求的附加信息。每个请求头占一行，键和值之间用冒号（:）分隔。请求头包含诸如 Host、User-Agent、Content-Type、Content-Length、Accept 等信息。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Host: www.tobebetterjavaer.com</span><br><span class="line">User-Agent: Mozilla/5.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br></pre></td></tr></table></figure>
<p>③、请求头和请求体之间有一个空行，表示请求头的结束。</p>
<p>④、对于某些 HTTP 方法（例如 POST、PUT 等），还可以在请求消息中包含请求体。请求体用于传输要发送给服务器的数据。请求体的格式和内容取决于 Content-Type 请求头的值。</p>
<p>例如，当提交 HTML 表单时，请求体可能如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username=沉默王二&amp;password=123456</span><br></pre></td></tr></table></figure>
<p>将这些部分放在一起，就构成了一个完整的 HTTP 请求消息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST /login HTTP/1.1</span><br><span class="line">Host: Host: www.tobebetterjavaer.com</span><br><span class="line">User-Agent: Mozilla/5.0</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 29</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">username=沉默王二&amp;password=123456</span><br></pre></td></tr></table></figure>
<p>我用一张思维导图来表示下：</p>
<p><img src="\assets\note\image-20231012173838462.png" alt="image-20231012173838462"></p>
<p><strong>响应消息</strong></p>
<p>一个典型的 HTTP 响应消息由三部分组成：状态行（Status Line）、响应头（Response Headers）、响应体（Response Body）。</p>
<p><img src="\assets\note\image-20231012173958294.png" alt="image-20231012173958294"></p>
<p>上面两张图，可以让你对 HTTP 请求和响应有个直观映象，接下来开始抓重点。</p>
<p>不管是请求消息还是响应消息，都可以划分为三部分，这就为我们后面的处理简化了很多工作。</p>
<ul>
<li>第一行：状态行</li>
<li>第二行到第一个空行：header（请求头/相应头）</li>
<li>剩下所有：正文</li>
</ul>
<p><strong>3.HTTP 服务器设计 </strong></p>
<p>接下来进入正题，基于 Socket 创建一个 HTTP 服务器，使用 Socket 基本没啥太大的问题，我们需要额外关注以下两点：</p>
<ul>
<li>对请求数据进行解析</li>
<li>封装返回结果</li>
</ul>
<p><strong>a. 请求数据解析 </strong></p>
<p>我们从 Socket 中拿到所有的数据，然后解析为对应的 HTTP 请求，我们先定义个 Request 对象，内部保存一些基本的 HTTP 信息，接下来重点就是将 Socket 中的所有数据都捞出来，封装为 request 对象。</p>
<blockquote>
<p>注意 ，这些代码放在 HttpMessageParser 类中，随后会给出完整的代码。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public static class Request &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 请求方法 GET/POST/PUT/DELETE/OPTION...</span><br><span class="line">     */</span><br><span class="line">    private String method;</span><br><span class="line">    /**</span><br><span class="line">     * 请求的uri</span><br><span class="line">     */</span><br><span class="line">    private String uri;</span><br><span class="line">    /**</span><br><span class="line">     * HTTP版本</span><br><span class="line">     */</span><br><span class="line">    private String version;</span><br><span class="line">    /**</span><br><span class="line">     * 请求头</span><br><span class="line">     */</span><br><span class="line">    private Map&lt;String, String&gt; headers;</span><br><span class="line">    /**</span><br><span class="line">     * 请求参数相关</span><br><span class="line">     */</span><br><span class="line">    private String message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据前面的 HTTP 协议介绍，解析过程如下，我们先看请求行的解析过程。</p>
<p>请求行，包含三个基本要素：请求方法 + URI + HTTP 版本，用空格进行分割，所以解析代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 根据标准的HTTP协议，解析请求行</span><br><span class="line"> *</span><br><span class="line"> * @param reader</span><br><span class="line"> * @param request</span><br><span class="line"> */</span><br><span class="line">private static void decodeRequestLine(BufferedReader reader, Request request) throws </span><br><span class="line">IOException &#123;</span><br><span class="line">    String[] strs = StringUtils.split(reader.readLine(), &quot; &quot;);</span><br><span class="line">    assert strs.length == 3;</span><br><span class="line">    request.setMethod(strs[0]);</span><br><span class="line">    request.setUri(strs[1]);</span><br><span class="line">    request.setVersion(strs[2]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请求头的解析，从第二行，到第一个空白行之间的所有数据，都是请求头；请求头的格式也比较清晰，形如 key:value , 具体实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 根据标准 HTTP 协议，解析请求头</span><br><span class="line">    *</span><br><span class="line">    * @param reader  读取请求头的 BufferedReader 对象</span><br><span class="line">    * @param request 存储请求信息的 Request 对象</span><br><span class="line">    * @throws IOException 当读取请求头信息时发生 I/O 异常时，将抛出该异常</span><br><span class="line">    */</span><br><span class="line">private static void decodeRequestHeader(BufferedReader reader, Request request) </span><br><span class="line">throws IOException &#123;</span><br><span class="line">    // 创建一个 Map 对象，用于存储请求头信息</span><br><span class="line">    Map&lt;String, String&gt; headers = new HashMap&lt;&gt;(16);</span><br><span class="line">    // 读取请求头信息，每行都是一个键值对，以空行结束</span><br><span class="line">    String line = reader.readLine();</span><br><span class="line">    String[] kv;</span><br><span class="line">    while (!&quot;&quot;.equals(line)) &#123;</span><br><span class="line">        // 将每行请求头信息按冒号分隔，分别作为键和值存入 Map 中</span><br><span class="line">        kv = StringUtils.split(line, &quot;:&quot;);</span><br><span class="line">        assert kv.length == 2;</span><br><span class="line">        headers.put(kv[0].trim(), kv[1].trim());</span><br><span class="line">        line = reader.readLine();</span><br><span class="line">    &#125;</span><br><span class="line">    // 将解析出来的请求头信息存入 Request 对象中</span><br><span class="line">    request.setHeaders(headers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后就是正文的解析了，这一块需要注意一点，正文可能为空，也可能有数据；有数据时，我们要如何把所有的数据都取出来呢？</p>
<p>先看具体实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 根据标注HTTP协议，解析正文</span><br><span class="line"> *</span><br><span class="line"> * @param reader    输入流读取器，用于读取请求中的数据</span><br><span class="line"> * @param request   Request 对象，表示 HTTP 请求</span><br><span class="line"> * @throws IOException 当发生 I/O 错误时抛出</span><br><span class="line"> */</span><br><span class="line">private static void decodeRequestMessage(BufferedReader reader, Request request) </span><br><span class="line">throws IOException &#123;</span><br><span class="line">    // 从请求头中获取 Content-Length，如果没有，则默认为 0</span><br><span class="line">    int contentLen = Integer.parseInt(request.getHeaders().getOrDefault(&quot;Content-</span><br><span class="line">Length&quot;, &quot;0&quot;));</span><br><span class="line">    // 如果 Content-Length 为 0，表示没有请求正文，直接返回。</span><br><span class="line">    // 例如 GET 和 OPTIONS 请求通常不包含请求正文</span><br><span class="line">    if (contentLen == 0) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 根据 Content-Length 创建一个字符数组来存储请求正文</span><br><span class="line">    char[] message = new char[contentLen];</span><br><span class="line">    // 使用 BufferedReader 读取请求正文</span><br><span class="line">    reader.read(message);</span><br><span class="line">    // 将字符数组转换为字符串，并将其设置为 Request 对象的 message</span><br><span class="line">    request.setMessage(new String(message));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意上面我的使用姿势，首先是根据请求头中的 Content-Type的值，来获得正文的数据大小，因此我们获取的方式是创建一个这么大的 char[] 数组来读取流中所有数据，如果我们的数组比实际的小，则读不完；如果大，则数组中会有一些空的数据；</p>
<p>最后将上面的几个解析封装一下，完成 request 解析：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * HTTP 请求可以分为三部分：</span><br><span class="line"> * 1. 请求行：包括请求方法、URI 和 HTTP 协议版本</span><br><span class="line"> * 2. 请求头：从第二行开始，直到一个空行为止</span><br><span class="line"> * 3. 消息正文：紧跟在空行后的所有内容，长度由请求头中的 Content-Length 决定</span><br><span class="line"> *</span><br><span class="line"> * 本方法将 InputStream 中的 HTTP 请求数据解析为一个 Request 对象</span><br><span class="line"> *</span><br><span class="line"> * @param reqStream  包含 HTTP 请求数据的输入流</span><br><span class="line"> * @return           一个表示 HTTP 请求的 Request 对象</span><br><span class="line"> * @throws IOException 当发生 I/O 错误时抛出</span><br><span class="line"> */</span><br><span class="line">public static Request parse2request(InputStream reqStream) throws IOException &#123;</span><br><span class="line">    // 使用 BufferedReader 和 InputStreamReader 读取输入流中的数据</span><br><span class="line">    BufferedReader httpReader = new BufferedReader(new InputStreamReader(reqStream, </span><br><span class="line">&quot;UTF-8&quot;));</span><br><span class="line">    // 创建一个新的 Request 对象</span><br><span class="line">    Request httpRequest = new Request();</span><br><span class="line">    // 解析请求行并设置到 Request 对象中</span><br><span class="line">    decodeRequestLine(httpReader, httpRequest);</span><br><span class="line">    // 解析请求头并设置到 Request 对象中</span><br><span class="line">    decodeRequestHeader(httpReader, httpRequest);</span><br><span class="line">    // 解析消息正文并设置到 Request 对象中</span><br><span class="line">    decodeRequestMessage(httpReader, httpRequest);</span><br><span class="line">    // 返回解析后的 Request 对象</span><br><span class="line">    return httpRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，是请求结果的封装，给一个简单的进行演示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Response 类表示一个 HTTP 响应，包括版本、状态码、状态信息、响应头和响应正文。</span><br><span class="line">    */</span><br><span class="line">@Data</span><br><span class="line">public static class Response &#123;</span><br><span class="line">    private String version;</span><br><span class="line">    private int code;</span><br><span class="line">    private String status;</span><br><span class="line">    private Map&lt;String, String&gt; headers;</span><br><span class="line">    private String message;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">    * 根据给定的 Request 对象和响应字符串构建一个 HTTP 响应。</span><br><span class="line">    *</span><br><span class="line">    * @param request   用于构建响应的 Request 对象</span><br><span class="line">    * @param response  响应字符串</span><br><span class="line">    * @return          一个表示 HTTP 响应的字符串</span><br><span class="line">    */</span><br><span class="line">public static String buildResponse(Request request, String response) &#123;</span><br><span class="line">    // 创建一个新的 Response 对象，并设置版本、状态码和状态信息</span><br><span class="line">    Response httpResponse = new Response();</span><br><span class="line">    httpResponse.setCode(200);</span><br><span class="line">    httpResponse.setStatus(&quot;ok&quot;);</span><br><span class="line">    httpResponse.setVersion(request.getVersion());</span><br><span class="line">    // 设置响应头</span><br><span class="line">    Map&lt;String, String&gt; headers = new HashMap&lt;&gt;();</span><br><span class="line">    headers.put(&quot;Content-Type&quot;, &quot;application/json&quot;);</span><br><span class="line">    headers.put(&quot;Content-Length&quot;, String.valueOf(response.getBytes().length));</span><br><span class="line">    httpResponse.setHeaders(headers);</span><br><span class="line">    // 设置响应正文</span><br><span class="line">    httpResponse.setMessage(response);</span><br><span class="line">    // 构建响应字符串</span><br><span class="line">    StringBuilder builder = new StringBuilder();</span><br><span class="line">    buildResponseLine(httpResponse, builder);</span><br><span class="line">    buildResponseHeaders(httpResponse, builder);</span><br><span class="line">    buildResponseMessage(httpResponse, builder);</span><br><span class="line">    return builder.toString();</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">    * 构建响应行，包括版本、状态码和状态信息。</span><br><span class="line">    *</span><br><span class="line">    * @param response      用于构建响应行的 Response 对象</span><br><span class="line">    * @param stringBuilder 用于拼接响应字符串的 StringBuilder 对象</span><br><span class="line">    */</span><br><span class="line">private static void buildResponseLine(Response response, StringBuilder </span><br><span class="line">stringBuilder) &#123;</span><br><span class="line">    stringBuilder.append(response.getVersion()).append(&quot; </span><br><span class="line">&quot;).append(response.getCode()).append(&quot; &quot;)</span><br><span class="line">            .append(response.getStatus()).append(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">    * 构建响应头。</span><br><span class="line">    *</span><br><span class="line">    * @param response      用于构建响应头的 Response 对象</span><br><span class="line">    * @param stringBuilder 用于拼接响应字符串的 StringBuilder 对象</span><br><span class="line">    */</span><br><span class="line">private static void buildResponseHeaders(Response response, StringBuilder </span><br><span class="line">stringBuilder) &#123;</span><br><span class="line">    for (Map.Entry&lt;String, String&gt; entry : response.getHeaders().entrySet()) &#123;</span><br><span class="line">       </span><br><span class="line"> stringBuilder.append(entry.getKey()).append(&quot;:&quot;).append(entry.getValue()).append(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    stringBuilder.append(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">    * 构建响应正文。</span><br><span class="line">    *</span><br><span class="line">    * @param response      用于构建响应正文的 Response 对象</span><br><span class="line">    * @param stringBuilder 用于拼接响应字符串的 StringBuilder 对象</span><br><span class="line">    */</span><br><span class="line">private static void buildResponseMessage(Response response, StringBuilder </span><br><span class="line">stringBuilder) &#123;</span><br><span class="line">    stringBuilder.append(response.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>b. 请求任务 HttpTask </strong></p>
<p>每个请求，单独分配一个任务来干这个事情，就是为了支持并发，对于 ServerSocket 而言，接收到了一个请求，那就创建一个 HttpTask 任务来实现 HTTP 通信。</p>
<p>那么这个 httptask 干啥呢？</p>
<ul>
<li>从请求中捞数据</li>
<li>响应请求</li>
<li>封装结果并返回</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * HttpTask 类实现了 Runnable 接口，用于处理一个 HTTP 请求。</span><br><span class="line"> * 当在一个线程中执行时，该任务将处理一个 Socket 连接上的 HTTP 请求，</span><br><span class="line"> * 并发送响应消息。</span><br><span class="line"> */</span><br><span class="line">public class HttpTask implements Runnable &#123;</span><br><span class="line">    // 用于处理 HTTP 请求的 Socket</span><br><span class="line">    private Socket socket;</span><br><span class="line">    /**</span><br><span class="line">     * 构造一个新的 HttpTask，用于处理指定的 Socket 连接。</span><br><span class="line">     *</span><br><span class="line">     * @param socket  用于处理 HTTP 请求的 Socket</span><br><span class="line">     */</span><br><span class="line">    public HttpTask(Socket socket) &#123;</span><br><span class="line">        this.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 实现 Runnable 接口的 run 方法，用于处理 HTTP 请求并发送响应消息。</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        // 检查 socket 是否为 null，如果为 null 则抛出异常</span><br><span class="line">        if (socket == null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;socket can&#x27;t be null.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 获取 Socket 的输出流，并创建一个 PrintWriter 对象</span><br><span class="line">            OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">            PrintWriter out = new PrintWriter(outputStream);</span><br><span class="line">            // 从 Socket 的输入流中解析 HTTP 请求</span><br><span class="line">            HttpMessageParser.Request httpRequest = HttpMessageParser.parse2request(socket.getInputStream());</span><br><span class="line">            try &#123;</span><br><span class="line">                // 根据请求结果进行响应，省略返回</span><br><span class="line">                String result = null;</span><br><span class="line">                </span><br><span class="line">                // 根据请求和结果构建 HTTP 响应</span><br><span class="line">                String httpRes = HttpMessageParser.buildResponse(httpRequest, result);</span><br><span class="line">                // 将 HTTP 响应发送到客户端</span><br><span class="line">                out.print(httpRes);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                // 如果发生异常，构建一个包含异常信息的 HTTP 响应</span><br><span class="line">                String httpRes = HttpMessageParser.buildResponse(httpRequest, e.toString());</span><br><span class="line">                out.print(httpRes);</span><br><span class="line">            &#125;</span><br><span class="line">            // 刷新输出流，确保响应消息被发送</span><br><span class="line">            out.flush();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // 关闭 Socket 连接</span><br><span class="line">            try &#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>c. HTTP 服务搭建 </strong></p>
<p>前面的基本上把该干的事情都干了，剩下的就简单了，创建 ServerSocket ，绑定端口接收请求，我们在线程池中跑这个 HTTP 服务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public class BasicHttpServer &#123;</span><br><span class="line">    // 创建一个单线程执行器，用于启动 HTTP 服务器</span><br><span class="line">    private static ExecutorService bootstrapExecutor = Executors.newSingleThreadExecutor();</span><br><span class="line">    // 创建一个线程池，用于处理来自客户端的 HTTP 请求</span><br><span class="line">    private static ExecutorService taskExecutor;</span><br><span class="line">    // 设置服务器监听的端口号</span><br><span class="line">    private static int PORT = 8999;</span><br><span class="line">    // 启动 HTTP 服务器的方法</span><br><span class="line">    static void startHttpServer() &#123;</span><br><span class="line">        // 获取处理器可用核心数，用于设置线程池大小</span><br><span class="line">        int nThreads = Runtime.getRuntime().availableProcessors();</span><br><span class="line">        // 初始化线程池，设置线程池大小，队列大小和丢弃策略</span><br><span class="line">        taskExecutor =</span><br><span class="line">                new ThreadPoolExecutor(nThreads, nThreads, 0L, </span><br><span class="line">TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;&gt;(100),</span><br><span class="line">                        new ThreadPoolExecutor.DiscardPolicy());</span><br><span class="line">        // 循环尝试启动服务器，如果启动失败，则等待10秒后重试</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                ServerSocket serverSocket = new ServerSocket(PORT);</span><br><span class="line">                bootstrapExecutor.submit(new ServerThread(serverSocket));</span><br><span class="line">                break;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    // 重试，等待 10 秒</span><br><span class="line">                    TimeUnit.SECONDS.sleep(10);</span><br><span class="line">                &#125; catch (InterruptedException ie) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 关闭启动执行器</span><br><span class="line">        bootstrapExecutor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">    // HTTP 服务器主要任务类</span><br><span class="line">    private static class ServerThread implements Runnable &#123;</span><br><span class="line">        // 保存传递给构造函数的 ServerSocket 实例</span><br><span class="line">        private ServerSocket serverSocket;</span><br><span class="line">        // 构造函数</span><br><span class="line">        public ServerThread(ServerSocket s) throws IOException &#123;</span><br><span class="line">            this.serverSocket = s;</span><br><span class="line">        &#125;</span><br><span class="line">        // 任务主体方法</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    // 等待客户端连接</span><br><span class="line">                    Socket socket = this.serverSocket.accept();</span><br><span class="line">                    // 创建一个 HttpTask 实例，将 Socket 实例作为参数传递</span><br><span class="line">                    HttpTask eventTask = new HttpTask(socket);</span><br><span class="line">                    // 将 HttpTask 提交给 taskExecutor 执行</span><br><span class="line">                    taskExecutor.submit(eventTask);</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    try &#123;</span><br><span class="line">                        // 如果发生异常，等待 1 秒后继续尝试</span><br><span class="line">                        TimeUnit.SECONDS.sleep(1);</span><br><span class="line">                    &#125; catch (InterruptedException ie) &#123;</span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码是一个简单的 HTTP 服务器实现。以下是关于这个 HTTP 服务器的主要组件和功能的详细解释：</p>
<p>1、bootstrapExecutor：一个单线程的 ExecutorService，用于执行 HTTP 服务器的启动任务。</p>
<p>2、taskExecutor：一个线程池，用于处理来自客户端的 HTTP 请求。线程池的大小等于处理器可用核心数，队列大小为100，使用 DiscardPolicy 丢弃策略。</p>
<p>3、PORT：服务器侦听的端口号，默认为 8999。</p>
<p>4、startHttpServer() 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- a.创建一个线程池 taskExecutor 用于处理 HTTP 请求。</span><br><span class="line">- b.在一个循环中，尝试创建一个 ServerSocket 实例并绑定到指定端口。如果失败，则等待 10 秒后重试。</span><br><span class="line">- c.当成功创建 ServerSocket 实例后，将其作为参数提交给 bootstrapExecutor 执行 ServerThread </span><br><span class="line">任务。</span><br><span class="line">- d.关闭 bootstrapExecutor。</span><br></pre></td></tr></table></figure>
<p>5、ServerThread 类实现了 Runnable 接口，它是 HTTP 服务器的主要任务： </p>
<ul>
<li>a.serverSocket 成员变量：保存传递给构造函数的 ServerSocket 实例。 </li>
<li>b.run() 方法： </li>
</ul>
<ul>
<li><p>在一个无限循环中，调用 serverSocket.accept() 方法等待客户端的连接。 </p>
</li>
<li><p>当接受到一个新的客户端连接时，创建一个 HttpTask 实例，将 Socket 实例作为参数传递。 </p>
</li>
<li><p>将 HttpTask 提交给 taskExecutor 执行。</p>
</li>
</ul>
<p>这个 HTTP 服务器的主要逻辑是：使用一个线程来监听客户端连接，当有新的客户端连接时，创建一个 HttpTask 来处理客户端的 HTTP 请求，并将这个任务提交给线程池 taskExecutor 执行。这样可以实现多个客户端请求的并发处理。</p>
<p>到这里，一个基于 Socket 实现的 HTTP 服务器基本上就搭建完了，接下来就可以进行测试了</p>
<p><strong>4.测试 </strong></p>
<p>做这个服务器，主要是基于项目 quick-fix 产生的，这个项目主要是为了解决应用内部服务访问与数据订正，我们在这个项目的基础上进行测试。</p>
<p>一个完整的 post 请求如下</p>
<p><img src="\assets\note\image-20231012174944585.png" alt="image-20231012174944585"></p>
<p>接下来我们看下打印出返回头的情况</p>
<p><img src="\assets\note\image-20231012174958703.png" alt="image-20231012174958703"></p>
<p><strong>II. 其他 </strong></p>
<p><strong>0.项目源码 </strong></p>
<ul>
<li>quick-fix</li>
<li>相关代码:</li>
<li>com.git.hui.fix.core.endpoint.BasicHttpServer</li>
<li>com.git.hui.fix.core.endpoint.HttpMessageParser</li>
<li>com.git.hui.fix.core.endpoint.HttpTask</li>
</ul>
<h1 id="10-Java-NIO"><a href="#10-Java-NIO" class="headerlink" title="10 Java NIO"></a>10 Java NIO</h1><h2 id="10-1-NIO比IO强在哪？"><a href="#10-1-NIO比IO强在哪？" class="headerlink" title="10.1 NIO比IO强在哪？"></a>10.1 NIO比IO强在哪？</h2><p>我花了几天时间去了解NIO 的核心知识，期间看了《Java 编程思想》和《疯狂 Java 讲义》中的 NIO 模块。但是，看完之后还是很迷，不知道 NIO 是干嘛用的，网上的资料和书上的知识点没有很好地对应上。</p>
<p>我这里先给大家展示一副传统 IO 和 NIO 的对比图，感受一下。</p>
<p><img src="\assets\note\image-20231012201840907.png" alt="image-20231012201840907"></p>
<p>传统 IO 基于字节流或字符流（如 FileInputStream、BufferedReader 等）进行文件读写，以及使用 Socket 和 ServerSocket 进行网络传输。</p>
<p>NIO 使用通道（Channel）和缓冲区（Buffer）进行文件操作，以及使用 SocketChannel 和 ServerSocketChannel 进行网络传输。</p>
<p>传统 IO 采用阻塞式模型，对于每个连接，都需要创建一个独立的线程来处理读写操作。当一个线程在等待 I/O 操作时，无法执行其他任务。这会导致大量线程的创建和销毁，以及上下文切换，降低了系统性能。</p>
<p>NIO 使用非阻塞模型，允许线程在等待 I/O 时执行其他任务。这种模式通过使用选择器（Selector）来监控多个通道（Channel）上的 I/O 事件，实现了更高的性能和可伸缩性。</p>
<p><strong>01、NIO 和传统 IO 在操作文件时的差异 </strong></p>
<p>JDK 1.4 中， java.nio.<em>包引入新的 Java I/O 库，其目的是<strong>提高速度</strong>。实际上，“旧”的 I/O 包已经使用 NIO<em>*重新实现过，即使我们不显式的使用 NIO 编程，也能从中受益。</em></em></p>
<p>nio 翻译成 no-blocking io 或者 new io 都无所谓啦，都说得通~</p>
<p>在《Java 编程思想》读到“即使我们不显式的使用 NIO 编程，也能从中受益”的时候，我是挺在意的，所以：我们测试一下使用 NIO 复制文件和传统 IO 复制文件 的性能：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleFileTransferTest &#123;</span><br><span class="line">    // 使用传统的 I/O 方法传输文件</span><br><span class="line">    private long transferFile(File source, File des) throws IOException &#123;</span><br><span class="line">        long startTime = System.currentTimeMillis();</span><br><span class="line">        if (!des.exists())</span><br><span class="line">            des.createNewFile();</span><br><span class="line">        // 创建输入输出流</span><br><span class="line">        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(source));</span><br><span class="line">        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(des));</span><br><span class="line">        // 使用数组传输数据</span><br><span class="line">        byte[] bytes = new byte[1024 * 1024];</span><br><span class="line">        int len;</span><br><span class="line">        while ((len = bis.read(bytes)) != -1) &#123;</span><br><span class="line">            bos.write(bytes, 0, len);</span><br><span class="line">        &#125;</span><br><span class="line">        long endTime = System.currentTimeMillis();</span><br><span class="line">        return endTime - startTime;</span><br><span class="line">    &#125;</span><br><span class="line">    // 使用 NIO 方法传输文件</span><br><span class="line">    private long transferFileWithNIO(File source, File des) throws IOException &#123;</span><br><span class="line">        long startTime = System.currentTimeMillis();</span><br><span class="line">        if (!des.exists())</span><br><span class="line">            des.createNewFile();</span><br><span class="line">        // 创建随机存取文件对象</span><br><span class="line">        RandomAccessFile read = new RandomAccessFile(source, &quot;rw&quot;);</span><br><span class="line">        RandomAccessFile write = new RandomAccessFile(des, &quot;rw&quot;);</span><br><span class="line">        // 获取文件通道</span><br><span class="line">        FileChannel readChannel = read.getChannel();</span><br><span class="line">        FileChannel writeChannel = write.getChannel();</span><br><span class="line">        // 创建并使用 ByteBuffer 传输数据</span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(1024 * 1024);</span><br><span class="line">        while (readChannel.read(byteBuffer) &gt; 0) &#123;</span><br><span class="line">            byteBuffer.flip();</span><br><span class="line">            writeChannel.write(byteBuffer);</span><br><span class="line">            byteBuffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        // 关闭文件通道</span><br><span class="line">        writeChannel.close();</span><br><span class="line">        readChannel.close();</span><br><span class="line">        long endTime = System.currentTimeMillis();</span><br><span class="line">        return endTime - startTime;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        SimpleFileTransferTest simpleFileTransferTest = new SimpleFileTransferTest();</span><br><span class="line">        File sourse = new File(&quot;[电影天堂www.dygod.cn]猜火车-cd1.rmvb&quot;);</span><br><span class="line">        File des = new File(&quot;io.avi&quot;);</span><br><span class="line">        File nio = new File(&quot;nio.avi&quot;);</span><br><span class="line">        // 比较传统的 I/O 和 NIO 传输文件的时间</span><br><span class="line">        long time = simpleFileTransferTest.transferFile(sourse, des);</span><br><span class="line">        System.out.println(time + &quot;：普通字节流时间&quot;);</span><br><span class="line">        long timeNio = simpleFileTransferTest.transferFileWithNIO(sourse, nio);</span><br><span class="line">        System.out.println(timeNio + &quot;：NIO时间&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先解释一下这段代码，里面出现的 RandomAccessFile 我们之前讲过，FileChannel 是 Java NIO（New I/O）库中的一个类，它提供了对文件的高效 I/O 操作，支持随机访问文件，允许在文件的任意位置进行读写操作。</p>
<p>与 RandomAccessFile 不同，FileChannel 使用了缓冲区（ByteBuffer）进行数据传输。</p>
<p>好，在我给出实际的结论之前，你是否会有这样的结论：</p>
<ul>
<li>对于较小的文件，NIO 和普通 IO 之间的性能差异可能不会非常明显，因为文件本身较小，复制过程较快。</li>
<li>对于较大的文件，使用 NIO 的性能可能会明显优于普通 IO。因为 NIO 使用了更高效的缓冲区和通道机制，可以在内存中进行更快的数据传输。</li>
</ul>
<p>然而实际的结果，却会令你大跌眼镜：<br>        <img src="\assets\note\image-20231012202156264.png" alt="image-20231012202156264"></p>
<p>文件越大的情况下，竟然普通字节流（传统 IO）的速度更快(当然了，个人测试，或许不是很准)，那还要 NIO 做什么呢？况且 NIO 的学习成本也比传统 IO 要高一些。</p>
<p>那这意味着我们可以不使用/学习 NIO 了吗？</p>
<p>答案是否定的，IO 操作往往在两个场景下会用到：</p>
<ul>
<li>文件 IO</li>
<li>网络 IO</li>
</ul>
<p>而 NIO 的<strong>魅力主要体现在网络中！</strong></p>
<p>NIO（New I/O）的设计目标是解决传统 I/O（BIO，Blocking I/O）在处理大量并发连接时的性能瓶颈。传统 I/O 在网络通信中主要使用阻塞式 I/O，为每个连接分配一个线程。当连接数量增加时，系统性能将受到严重影响，线程资源成为关键瓶颈。而 NIO 提供了非阻塞 I/O 和 I/O 多路复用，可以在单个线程中处理多个并发连接，从而在网络传输中显著提高性能。</p>
<p>以下是 NIO 在网络传输中优于传统 I/O 的原因：</p>
<p>①、NIO 支持非阻塞 I/O，这意味着在执行 I/O 操作时，线程不会被阻塞。这使得在网络传输中可以有效地管理大量并发连接（数千甚至数百万）。而在操作文件时，这个优势没有那么明显，因为文件读写通常不涉及大量并发操作。</p>
<p>②、NIO 支持 I/O 多路复用，这意味着一个线程可以同时监视多个通道（如套接字），并在 I/O 事件（如可读、可写）准备好时处理它们。这大大提高了网络传输中的性能，因为单个线程可以高效地管理多个并发连接。操作文件时这个优势也无法提现出来。</p>
<p>③、NIO 提供了 ByteBuffer 类，可以高效地管理缓冲区。这在网络传输中很重要，因为数据通常是以字节流的形式传输。操作文件的时候，虽然也有缓冲区，但优势仍然不够明显。</p>
<p><strong>02、NIO 和传统 IO 在网络传输中的差异 </strong></p>
<p>来看服务器端代码的差别。</p>
<p>IO，用的套接字，代码比较简单，我就不加注释了，之前学过，应该都能看得懂，用 while 循环监听客户端 Socket：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class IOServer &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            ServerSocket serverSocket = new ServerSocket(8080);</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                Socket client = serverSocket.accept();</span><br><span class="line">                InputStream in = client.getInputStream();</span><br><span class="line">                OutputStream out = client.getOutputStream();</span><br><span class="line">                byte[] buffer = new byte[1024];</span><br><span class="line">                int bytesRead = in.read(buffer);</span><br><span class="line">                out.write(buffer, 0, bytesRead);</span><br><span class="line">                in.close();</span><br><span class="line">                out.close();</span><br><span class="line">                client.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NIO，这部分我加上注释，主要用到的是 ServerSocketChannel 和 Selector：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public class NIOServer &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 创建 ServerSocketChannel</span><br><span class="line">            ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">            // 绑定端口</span><br><span class="line">            serverSocketChannel.bind(new InetSocketAddress(8081));</span><br><span class="line">            // 设置为非阻塞模式</span><br><span class="line">            serverSocketChannel.configureBlocking(false);</span><br><span class="line">            // 创建 Selector</span><br><span class="line">            Selector selector = Selector.open();</span><br><span class="line">            // 将 ServerSocketChannel 注册到 Selector，关注 OP_ACCEPT 事件</span><br><span class="line">            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            // 无限循环，处理事件</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                // 阻塞直到有事件发生</span><br><span class="line">                selector.select();</span><br><span class="line">                // 获取发生事件的 SelectionKey</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">                while (iterator.hasNext()) &#123;</span><br><span class="line">                    SelectionKey key = iterator.next();</span><br><span class="line">                    // 处理完后，从 selectedKeys 集合中移除</span><br><span class="line">                    iterator.remove();</span><br><span class="line">                    // 判断事件类型</span><br><span class="line">                    if (key.isAcceptable()) &#123;</span><br><span class="line">                        // 有新的连接请求</span><br><span class="line">                        ServerSocketChannel server = (ServerSocketChannel) key.channel();</span><br><span class="line">                        // 接受连接</span><br><span class="line">                        SocketChannel client = server.accept();</span><br><span class="line">                        // 设置为非阻塞模式</span><br><span class="line">                        client.configureBlocking(false);</span><br><span class="line">                        // 将新的 SocketChannel 注册到 Selector，关注 OP_READ 事件</span><br><span class="line">                        client.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                    &#125; else if (key.isReadable()) &#123;</span><br><span class="line">                        // 有数据可读</span><br><span class="line">                        SocketChannel client = (SocketChannel) key.channel();</span><br><span class="line">                        // 创建 ByteBuffer 缓冲区</span><br><span class="line">                        ByteBuffer buffer = ByteBuffer.allocate(1024);</span><br><span class="line">                        // 从 SocketChannel 中读取数据并写入 ByteBuffer</span><br><span class="line">                        client.read(buffer);</span><br><span class="line">                        // 翻转 ByteBuffer，准备读取</span><br><span class="line">                        buffer.flip();</span><br><span class="line">                        // 将数据从 ByteBuffer 写回到 SocketChannel</span><br><span class="line">                        client.write(buffer);</span><br><span class="line">                        // 关闭连接</span><br><span class="line">                        client.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码创建了一个基于 Java NIO 的简单 TCP 服务器。它使用 ServerSocketChannel 和 Selector（后面会讲） 实现了非阻塞 I/O 和 I/O 多路复用。服务器循环监听事件，当有新的连接请求时，接受连接并将新的 SocketChannel 注册到 Selector，关注 OP_READ 事件。当有数据可读时，从 SocketChannel 中读取数据并写入 ByteBuffer，然后将数据从 ByteBuffer 写回到 SocketChannel。</p>
<p>这里简单说一下 Socket 和 ServerSocket，以及 ServerSocketChannel 和 SocketChannel。</p>
<p>Socket 和 ServerSocket 是传统的阻塞式 I/O 编程方式，用于建立和管理 TCP 连接。</p>
<ul>
<li>Socket：表示客户端套接字，负责与服务器端建立连接并进行数据的读写。</li>
<li>ServerSocket：表示服务器端套接字，负责监听客户端连接请求。当有新的连接请求时，ServerSocket 会创建一个新的 Socket 实例，用于与客户端进行通信。</li>
</ul>
<p>在传统阻塞式 I/O 编程中，每个连接都需要一个单独的线程进行处理，这导致了在高并发场景下的性能问题。在接下来的客户端测试用例中会看到。</p>
<p>为了解决传统阻塞式 I/O 的性能问题，Java NIO 引入了 ServerSocketChannel 和 SocketChannel。它们是非阻塞 I/O，可以在单个线程中处理多个连接。</p>
<ul>
<li>ServerSocketChannel：类似于 ServerSocket，表示服务器端套接字通道。它负责监听客户端连接请求，并可以设置为非阻塞模式，这意味着在等待客户端连接请求时不会阻塞线程。</li>
<li>SocketChannel：类似于 Socket，表示客户端套接字通道。它负责与服务器端建立连接并进行数据的读写。SocketChannel 也可以设置为非阻塞模式，在读写数据时不会阻塞线程。</li>
</ul>
<p>再来简单说一下 Selector，后面会再细讲。</p>
<p>Selector 是 Java NIO 中的一个关键组件，用于实现 I/O 多路复用。它允许在单个线程中同时监控多个 ServerSocketChannel 和 SocketChannel，并通过 SelectionKey 标识关注的事件。当某个事件发生时，Selector 会将对应的 SelectionKey 添加到已选择的键集合中。通过使用 Selector，可以在单个线程中同时处理多个连接，从而有效地提高 I/O 操作的性能，特别是在高并发场景下。</p>
<p>客户端测试用例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public class TestClient &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        int clientCount = 10000;</span><br><span class="line">        ExecutorService executorServiceIO = Executors.newFixedThreadPool(10);</span><br><span class="line">        ExecutorService executorServiceNIO = Executors.newFixedThreadPool(10);</span><br><span class="line">        // 使用传统 IO 的客户端</span><br><span class="line">        Runnable ioClient = () -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Socket socket = new Socket(&quot;localhost&quot;, 8080);</span><br><span class="line">                OutputStream out = socket.getOutputStream();</span><br><span class="line">                InputStream in = socket.getInputStream();</span><br><span class="line">                out.write(&quot;Hello, 沉默王二 IO!&quot;.getBytes());</span><br><span class="line">                byte[] buffer = new byte[1024];</span><br><span class="line">                in.read(buffer);</span><br><span class="line">                in.close();</span><br><span class="line">                out.close();</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        // 使用 NIO 的客户端</span><br><span class="line">        Runnable nioClient = () -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">                socketChannel.connect(new InetSocketAddress(&quot;localhost&quot;, 8081));</span><br><span class="line">                ByteBuffer buffer = ByteBuffer.wrap(&quot;Hello, 沉默王二 NIO!&quot;.getBytes());</span><br><span class="line">                socketChannel.write(buffer);</span><br><span class="line">                buffer.clear();</span><br><span class="line">                socketChannel.read(buffer);</span><br><span class="line">                socketChannel.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        // 分别测试 NIO 和传统 IO 的服务器性能</span><br><span class="line">        long startTime, endTime;</span><br><span class="line">        startTime = System.currentTimeMillis();</span><br><span class="line">        for (int i = 0; i &lt; clientCount; i++) &#123;</span><br><span class="line">            executorServiceIO.execute(ioClient);</span><br><span class="line">        &#125;</span><br><span class="line">        executorServiceIO.shutdown();</span><br><span class="line">        executorServiceIO.awaitTermination(1, TimeUnit.MINUTES);</span><br><span class="line">        endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;传统 IO 服务器处理 &quot; + clientCount + &quot; 个客户端耗时: &quot; + (endTime - startTime) + &quot;ms&quot;);</span><br><span class="line">        startTime = System.currentTimeMillis();</span><br><span class="line">        for (int i = 0; i &lt; clientCount; i++) &#123;</span><br><span class="line">            executorServiceNIO.execute(nioClient);</span><br><span class="line">        &#125;</span><br><span class="line">        executorServiceNIO.shutdown();</span><br><span class="line">        executorServiceNIO.awaitTermination(1, TimeUnit.MINUTES);</span><br><span class="line">        endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;NIO 服务器处理 &quot; + clientCount + &quot; 个客户端耗时: &quot; + (endTime - startTime) + &quot;ms&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个简单的性能测试中，我们使用固定线程池（10个线程）来模拟客户端并发请求。分别测试 NIO 和传统 IO 服务器处理 10000 个客户端请求所需的时间。来看一下结果。</p>
<p><img src="\assets\note\image-20231012202800164.png" alt="image-20231012202800164"></p>
<p>可以看得出，NIO 比 传统 IO 差不多快一倍的时间。当然了，这是放在我本地测试的，如果服务端放在生产环境下，这个结果会有所不同，但我在本地跑了几次，结果差不多是这样的结果。</p>
<p>这说明 NIO 在网络传输中的性能确实要优于传统 IO 的。   </p>
<p><strong>03、小结 </strong></p>
<p>本篇内容主要讲了 NIO（New IO）和传统 IO 之间的差异，包括 IO 模型、操作文件、网络传输等方面。</p>
<ul>
<li>传统 I/O 采用阻塞式模型，线程在 I/O 操作期间无法执行其他任务。NIO 使用非阻塞模型，允许线程在等待 I/O 时执行其他任务，通过选择器（Selector）监控多个通道（Channel）上的 I/O 事件，提高性能和可伸缩性。</li>
<li>传统 I/O 使用基于字节流或字符流的类（如 FileInputStream、BufferedReader 等）进行文件读写。NIO 使用通道（Channel）和缓冲区（Buffer）进行文件操作，NIO 在性能上的优势并不大。</li>
<li>传统 I/O 使用 Socket 和 ServerSocket 进行网络传输，存在阻塞问题。NIO 提供了 SocketChannel 和 ServerSocketChannel，支持非阻塞网络传输，提高了并发处理能力。</li>
</ul>
<h2 id="10-2-BIO、NIO-和-AIO-的区别"><a href="#10-2-BIO、NIO-和-AIO-的区别" class="headerlink" title="10.2 BIO、NIO 和 AIO 的区别"></a>10.2 BIO、NIO 和 AIO 的区别</h2><p>上篇，我们了解了 NIO 和传统 IO 的区别，那这篇我们来了解 BIO、NIO 和 AIO 的区别，新手也很容易混淆，我们换一个方式来讲，讲给女朋友听 。</p>
<p>周末午后，在家里面进行电话面试，我问了面试者几个关于 IO 的问题，其中包括什么是 BIO、NIO 和 AIO？三者有什么区别？具体如何使用等问题，但是面试者回答的并不是很满意。于是我在面试评价中写道：”对 Java 的 IO 提醒理解不够深入”。恰好被女朋友看到了。</p>
<p><img src="\assets\note\image-20231012203025941.png" alt="image-20231012203025941"></p>
<p><strong>Java IO 与 BIO、NIO </strong></p>
<p>IO，常写作 I/O，是 Input/Output 的简称，即输入/输出。通常指数据在内部存储器（内存）和外部存储器（硬盘、优盘等）或其他周边设备之间的输入和输出。</p>
<p>输入/输出是信息处理系统（例如计算机）与外部世界（可能是人类或另一信息处理系统）之间的通信。</p>
<p>输入是系统接收的信号或数据，输出则是从其发送的信号或数据。</p>
<p>在 Java 中，提供了一系列 API，可以供开发者来读写外部数据或文件。我们称这些 API 为 Java IO。</p>
<p>IO 是 Java 中比较重要，且比较难的知识点，主要是因为随着 Java 的发展，目前有三种 IO 共存。分别是 BIO、NIO 和 AIO。</p>
<p>BIO 全称 Block-IO 是一种同步且阻塞的通信模式。是一个比较传统的通信方式，模式简单，使用方便。但并发处理能力低，通信耗时，依赖网速。</p>
<p>Java NIO，全程 Non-Block IO ，是 Java SE 1.4 版以后，针对网络传输效能优化的新功能。是一种非阻塞同步的通信模式。</p>
<p>NIO 与原来的 I/O 有同样的作用和目的, 他们之间最重要的区别是数据打包和传输的方式。原来的 I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。</p>
<p>面向流的 I/O 系统一次一个字节地处理数据。一个输入流产生一个字节的数据，一个输出流消费一个字节的数据。</p>
<p>面向块的 I/O 系统以块的形式处理数据。每一个操作都在一步中产生或者消费一个数据块。按块处理数据比按(流式的)字节处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。</p>
<p>Java AIO，全称 Asynchronous IO，是异步非阻塞的 IO。是一种非阻塞异步的通信模式。</p>
<p>在 NIO 的基础上引入了新的异步通道的概念，并提供了异步文件通道和异步套接字通道的实现。</p>
<p><img src="\assets\note\image-20231012203409694.png" alt="image-20231012203409694"></p>
<p><strong>三种 IO 的区别 </strong></p>
<p>首先，我们站在宏观的角度，重新画一下重点：</p>
<ul>
<li>BIO （Blocking I/O）：同步阻塞 I/O 模式。</li>
<li>NIO （New I/O）：同步非阻塞模式。</li>
<li>AIO （Asynchronous I/O）：异步非阻塞 I/O 模型。</li>
</ul>
<p>同步阻塞模式：这种模式下，我们的工作模式是先来到厨房，开始烧水，并坐在水壶面前一直等着水烧开。</p>
<p>同步非阻塞模式：这种模式下，我们的工作模式是先来到厨房，开始烧水，但是我们不一直坐在水壶前面等，而是回到客厅看电视，然后每隔几分钟到厨房看一下水有没有烧开。</p>
<p>异步非阻塞 I/O 模型：这种模式下，我们的工作模式是先来到厨房，开始烧水，我们不一直坐在水壶前面等，也不隔一段时间去看一下，而是在客厅看电视，水壶上面有个开关，水烧开之后他会通知我。</p>
<p>阻塞 VS 非阻塞：人是否坐在水壶前面一直等。</p>
<p>同步 VS 异步：水壶是不是在水烧开之后主动通知人。</p>
<p><strong>适用场景 </strong></p>
<p>BIO 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4 以前的唯一选择，但程序直观简单易理解。</p>
<p>NIO 方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4 开始支持。</p>
<p>AIO 方式适用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用 OS 参与并发操作，编程比较复杂，JDK7 开始支持。</p>
<p><strong>使用方式 </strong></p>
<p>使用 BIO 实现文件的读取和写入。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class BioFileDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BioFileDemo demo = new BioFileDemo();</span><br><span class="line">        demo.writeFile();</span><br><span class="line">        demo.readFile();</span><br><span class="line">    &#125;</span><br><span class="line">    // 使用 BIO 写入文件</span><br><span class="line">    public void writeFile() &#123;</span><br><span class="line">        String filename = &quot;logs/itwanger/paicoding.txt&quot;;</span><br><span class="line">        try &#123;</span><br><span class="line">            FileWriter fileWriter = new FileWriter(filename);</span><br><span class="line">            BufferedWriter bufferedWriter = new BufferedWriter(fileWriter);</span><br><span class="line">            bufferedWriter.write(&quot;学编程就上技术派&quot;);</span><br><span class="line">            bufferedWriter.newLine();</span><br><span class="line">            System.out.println(&quot;写入完成&quot;);</span><br><span class="line">            bufferedWriter.close();</span><br><span class="line">            fileWriter.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 使用 BIO 读取文件</span><br><span class="line">    public void readFile() &#123;</span><br><span class="line">        String filename = &quot;logs/itwanger/paicoding.txt&quot;;</span><br><span class="line">        try &#123;</span><br><span class="line">            FileReader fileReader = new FileReader(filename);</span><br><span class="line">            BufferedReader bufferedReader = new BufferedReader(fileReader);</span><br><span class="line">            String line;</span><br><span class="line">            while ((line = bufferedReader.readLine()) != null) &#123;</span><br><span class="line">                System.out.println(&quot;读取的内容: &quot; + line);</span><br><span class="line">            &#125;</span><br><span class="line">            bufferedReader.close();</span><br><span class="line">            fileReader.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个示例展示了如何使用 Java 中的传统阻塞 I/O（BIO）对文件进行读写操作。在 writeFile() 方法中，我们首先创建一个 FileWriter 对象，并使用 BufferedWriter 进行缓冲写入。接着，使用 bufferedWriter.write() 方法将字符串写入文件，然后调用bufferedWriter.newLine() 方法添加换行符。最后，关闭 BufferedWriter 和 FileWriter。在 readFile() 方法中，我们创建一个 FileReader 对象，并使用 BufferedReader 进行缓冲读取。然后通过调用 bufferedReader.readLine() 方法循环读取文件内容，直到返回 null 表示读取完毕。最后，关闭 BufferedReader 和 FileReader。</p>
<p>接下来是 NIO 的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class NioFileDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        NioFileDemo demo = new NioFileDemo();</span><br><span class="line">        demo.writeFile();</span><br><span class="line">        demo.readFile();</span><br><span class="line">    &#125;</span><br><span class="line">    // 使用 NIO 写入文件</span><br><span class="line">    public void writeFile() &#123;</span><br><span class="line">        Path path = Paths.get(&quot;logs/itwanger/paicoding.txt&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            FileChannel fileChannel = FileChannel.open(path, </span><br><span class="line">EnumSet.of(StandardOpenOption.CREATE, StandardOpenOption.WRITE));</span><br><span class="line">            ByteBuffer buffer = StandardCharsets.UTF_8.encode(&quot;学编程就上技术派&quot;);</span><br><span class="line">            fileChannel.write(buffer);</span><br><span class="line">            System.out.println(&quot;写入完成&quot;);</span><br><span class="line">            fileChannel.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 使用 NIO 读取文件</span><br><span class="line">    public void readFile() &#123;</span><br><span class="line">        Path path = Paths.get(&quot;logs/itwanger/paicoding.txt&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            FileChannel fileChannel = FileChannel.open(path, StandardOpenOption.READ);</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(1024);</span><br><span class="line">            int bytesRead = fileChannel.read(buffer);</span><br><span class="line">            while (bytesRead != -1) &#123;</span><br><span class="line">                buffer.flip();</span><br><span class="line">                System.out.println(&quot;读取的内容: &quot; + StandardCharsets.UTF_8.decode(buffer));</span><br><span class="line">                buffer.clear();</span><br><span class="line">                bytesRead = fileChannel.read(buffer);</span><br><span class="line">            &#125;</span><br><span class="line">            fileChannel.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个示例演示了如何使用 NIO 的 FileChannel 对文件进行读写操作。在 writeFile() 方法中，我们首先打开文件通道并指定创建和写入选项。接着，将要写入的字符串转换为 ByteBuffer，然后使用 fileChannel.write() 方法将其写入文件。在 readFile() 方法中，我们打开文件通道并指定读取选项，然后创建一个 ByteBuffer 用于存储读取到的数据。使用 fileChannel.read() 方法循环读取文件内容，直到返回 -1 表示读取完毕。在循环中，我们翻转缓冲区，将其解码为字符串并打印，然后清空缓冲区以进行下一次读取。最后，关闭文件通道。</p>
<p>使用 AIO 实现文件的读取和写入     </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public class AioDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AioDemo demo = new AioDemo();</span><br><span class="line">        demo.writeFile();</span><br><span class="line">        demo.readFile();</span><br><span class="line">    &#125;</span><br><span class="line">    // 使用 AsynchronousFileChannel 写入文件</span><br><span class="line">    public void writeFile() &#123;</span><br><span class="line">        // 使用 Paths.get() 获取文件路径</span><br><span class="line">        Path path = Paths.get(&quot;logs/itwanger/paicoding.txt&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            // 用 AsynchronousFileChannel.open() 打开文件通道，指定写入和创建文件的选项。</span><br><span class="line">            AsynchronousFileChannel fileChannel = AsynchronousFileChannel.open(path, </span><br><span class="line">StandardOpenOption.WRITE, StandardOpenOption.CREATE);</span><br><span class="line">            // 将要写入的字符串（&quot;学编程就上技术派&quot;）转换为 ByteBuffer。</span><br><span class="line">            ByteBuffer buffer = StandardCharsets.UTF_8.encode(&quot;学编程就上技术派&quot;);</span><br><span class="line">            // 调用 fileChannel.write() 方法将 ByteBuffer 中的内容写入文件。这是一个异步操</span><br><span class="line">作，因此需要使用 Future 对象等待写入操作完成。</span><br><span class="line">            Future&lt;Integer&gt; result = fileChannel.write(buffer, 0);</span><br><span class="line">            // 等待写操作完成</span><br><span class="line">            result.get();</span><br><span class="line">            System.out.println(&quot;写入完成&quot;);</span><br><span class="line">            fileChannel.close();</span><br><span class="line">        &#125; catch (IOException | InterruptedException | java.util.concurrent.ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 使用 AsynchronousFileChannel 读取文件</span><br><span class="line">    public void readFile() &#123;</span><br><span class="line">        Path path = Paths.get(&quot;logs/itwanger/paicoding.txt&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            // 指定读取文件的选项。</span><br><span class="line">            AsynchronousFileChannel fileChannel = AsynchronousFileChannel.open(path, StandardOpenOption.READ);</span><br><span class="line">            // 创建一个 ByteBuffer，用于存储从文件中读取的数据。</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(1024);</span><br><span class="line">            // 调用 fileChannel.read() 方法从文件中异步读取数据。该方法接受一个 </span><br><span class="line">CompletionHandler 对象，用于处理异步操作完成后的回调。</span><br><span class="line">            fileChannel.read(buffer, 0, buffer, new CompletionHandler&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void completed(Integer result, ByteBuffer attachment) &#123;</span><br><span class="line">                    // 在 CompletionHandler 的 completed() 方法中，翻转 ByteBuffer</span><br><span class="line">（attachment.flip()），然后使用 Charset.forName(&quot;UTF-8&quot;).decode() 将其解码为字符串并打印。最后，清空缓冲区并关闭文件通道。</span><br><span class="line">                    attachment.flip();</span><br><span class="line">                    System.out.println(&quot;读取的内容: &quot; + </span><br><span class="line">StandardCharsets.UTF_8.decode(attachment));</span><br><span class="line">                    attachment.clear();</span><br><span class="line">                    try &#123;</span><br><span class="line">                        fileChannel.close();</span><br><span class="line">                    &#125; catch (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                @Override</span><br><span class="line">                public void failed(Throwable exc, ByteBuffer attachment) &#123;</span><br><span class="line">                    // 如果异步读取操作失败，CompletionHandler 的 failed() 方法将被调用，打印错误信息。</span><br><span class="line">                    System.out.println(&quot;读取失败&quot;);</span><br><span class="line">                    exc.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            // 等待异步操作完成</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125; catch (IOException | InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码展示了一个名为 AioDemo 的类，包含两个方法： writeFile() 和 readFile() 。这两个方法分别使用 AsynchronousFileChannel 对文件进行异步写入和读取操作。代码的具体含义我都加到注释当中了，注意查看。</p>
<p>滴滴滴，水开了。</p>
<p><img src="\assets\note\image-20231012204156678.png" alt="image-20231012204156678"></p>
<p><strong>小结 </strong></p>
<p>BIO（Blocking I/O）：采用阻塞式 I/O 模型，线程在执行 I/O 操作时被阻塞，无法处理其他任务，适用于连接数较少且稳定的场景。</p>
<p>NIO（New I/O 或 Non-blocking I/O）：使用非阻塞 I/O 模型，线程在等待 I/O 时可执行其他任务，通过 Selector 监控多个 Channel 上的事件，提高性能和可伸缩性，适用于高并发场景。</p>
<p>AIO（Asynchronous I/O）：采用异步 I/O 模型，线程发起 I/O 请求后立即返回，当 I/O 操作完成时通过回调函数通知线程，进一步提高了并发处理能力，适用于高吞吐量场景。</p>
<blockquote>
<p>参考链接：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/QQxrr5yP8X9YdFqIwXDoQQ">https://mp.weixin.qq.com/s/QQxrr5yP8X9YdFqIwXDoQQ</a></p>
</blockquote>
<h2 id="10-3-Buffer和Channel"><a href="#10-3-Buffer和Channel" class="headerlink" title="10.3 Buffer和Channel"></a>10.3 Buffer和Channel</h2><p>首先我们再来回顾一下 IO 和 NIO 的区别：</p>
<ul>
<li>可简单认为：<strong>IO 是面向流的处理，NIO 是面向块(缓冲区)的处理</strong></li>
<li>面向流的 I/O 系统<strong>一次一个字节地处理数据。</strong></li>
<li>一个面向块(缓冲区)的 I/O 系统<strong>以块的形式处理数据。</strong></li>
</ul>
<p>NIO 主要有<strong>两个核心部分组成：</strong></p>
<ul>
<li><strong>Buffer 缓冲区</strong></li>
<li><strong>Channel 通道</strong></li>
</ul>
<p>在 NIO 中，并不是以流的方式来处理数据的，而是以 buffer 缓冲区和 Channel 通道<strong>配合使用</strong>来处理数据的。</p>
<p>简单理解一下：</p>
<p>可以把 Channel 通道比作铁路，buffer 缓冲区比作成火车(运载着货物)</p>
<p>而我们的 NIO 就是通过 Channel 通道运输着存储数据的 Buffer 缓冲区的来实现数据的处理！</p>
<p>要时刻记住：Channel 不与数据打交道，它只负责运输数据。与数据打交道的是 Buffer 缓冲区</p>
<ul>
<li><strong>Channel—&gt;运输</strong></li>
<li><strong>Buffer—&gt;数据</strong></li>
</ul>
<p>相对于传统 IO 而言，<strong>流是单向的</strong>。对于 NIO 而言，有了 Channel 通道这个概念，我们的<strong>读写都是双向</strong>的(铁路上的火车能从广州去北京、自然就能从北京返还到广州)！</p>
<p><strong>Buffer 缓冲区 </strong></p>
<p>我们来看看 Buffer 缓冲区有什么值得我们注意的地方。</p>
<p>Buffer 是缓冲区的抽象类：</p>
<p><img src="\assets\note\image-20231012205023003.png" alt="image-20231012205023003"></p>
<p>其中 ByteBuffer 是用得最多的实现类(在通道中读写字节数据)。</p>
<p><img src="\assets\note\image-20231012205041246.png" alt="image-20231012205041246"></p>
<p>拿到一个缓冲区我们往往会做什么？很简单，就是读取缓冲区的数据/写数据到缓冲区中。所以，缓冲区的核心方法就是 put 和 get：</p>
<p><img src="\assets\note\image-20231012205105823.png" alt="image-20231012205105823"></p>
<p>Buffer 类维护了 4 个核心变量来提供<strong>关于其所包含的数组信息</strong>。它们是：</p>
<p>容量 Capacity <strong>缓冲区能够容纳的数据元素的最大数量</strong>。容量在缓冲区创建时被设定，并且永远不能被改变。(不能被改变的原因也很简单，底层是数组嘛)</p>
<p>上界 Limit <strong>缓冲区里的数据的总数</strong>，代表了当前缓冲区中一共有多少数据。</p>
<p>位置 Position <strong>下一个要被读或写的元素的位置</strong>。Position 会自动由相应的 get()和 put()函数更新。</p>
<p>标记 Mark 一个备忘位置。<strong>用于记录上一次读写的位置</strong>。</p>
<p>首先展示一下<strong>是如何创建缓冲区的，核心变量的值是怎么变化的。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个缓冲区</span><br><span class="line">ByteBuffer byteBuffer = ByteBuffer.allocate(1024);</span><br><span class="line">// 看一下初始时4个核心变量的值</span><br><span class="line">System.out.println(&quot;初始时--&gt;limit---&gt;&quot;+byteBuffer.limit());</span><br><span class="line">System.out.println(&quot;初始时--&gt;position---&gt;&quot;+byteBuffer.position());</span><br><span class="line">System.out.println(&quot;初始时--&gt;capacity---&gt;&quot;+byteBuffer.capacity());</span><br><span class="line">System.out.println(&quot;初始时--&gt;mark---&gt;&quot; + byteBuffer.mark());</span><br><span class="line">System.out.println(&quot;--------------------------------------&quot;);</span><br><span class="line">// 添加一些数据到缓冲区中</span><br><span class="line">String s = &quot;沉默王二&quot;;</span><br><span class="line">byteBuffer.put(s.getBytes());</span><br><span class="line">// 看一下初始时4个核心变量的值</span><br><span class="line">System.out.println(&quot;put完之后--&gt;limit---&gt;&quot;+byteBuffer.limit());</span><br><span class="line">System.out.println(&quot;put完之后--&gt;position---&gt;&quot;+byteBuffer.position());</span><br><span class="line">System.out.println(&quot;put完之后--&gt;capacity---&gt;&quot;+byteBuffer.capacity());</span><br><span class="line">System.out.println(&quot;put完之后--&gt;mark---&gt;&quot; + byteBuffer.mark());</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">初始时--&gt;limit---&gt;1024</span><br><span class="line">初始时--&gt;position---&gt;0</span><br><span class="line">初始时--&gt;capacity---&gt;1024</span><br><span class="line">初始时--&gt;mark---&gt;java.nio.HeapByteBuffer[pos=0 lim=1024 cap=1024]</span><br><span class="line">--------------------------------------</span><br><span class="line">put完之后--&gt;limit---&gt;1024</span><br><span class="line">put完之后--&gt;position---&gt;12</span><br><span class="line">put完之后--&gt;capacity---&gt;1024</span><br><span class="line">put完之后--&gt;mark---&gt;java.nio.HeapByteBuffer[pos=12 lim=1024 cap=1024]</span><br></pre></td></tr></table></figure>
<p>现在<strong>我想要从缓存区拿数据</strong>，怎么拿呀？？NIO 给了我们一个 flip()方法。这个方法可以<strong>改动 position 和 limit 的位置！</strong></p>
<p>在之前代码的基础上，我们 flip() 一下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// flip()方法</span><br><span class="line">byteBuffer.flip();</span><br><span class="line">System.out.println(&quot;flip()方法之后--&gt;limit---&gt;&quot;+byteBuffer.limit());</span><br><span class="line">System.out.println(&quot;flip()方法之后--&gt;position---&gt;&quot;+byteBuffer.position());</span><br><span class="line">System.out.println(&quot;flip()方法之后--&gt;capacity---&gt;&quot;+byteBuffer.capacity());</span><br><span class="line">System.out.println(&quot;flip()方法之后--&gt;mark---&gt;&quot; + byteBuffer.mark());</span><br></pre></td></tr></table></figure>
<p>再看看 4 个核心属性的值会发生什么变化：</p>
<p><img src="\assets\note\image-20231012210003858.png" alt="image-20231012210003858"></p>
<p>在调用 flip() 之后，limit 变为当前 position 的值（12），position 重置为 0。这意味着你可以从缓冲区的开始位置读取刚刚写入的数据，直到 limit 指定的位置。capacity 保持不变（1024）。</p>
<p>假设我们有一个初始容量为 1024 的 ByteBuffer。</p>
<p><strong>初始状态:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">position = 0</span><br><span class="line">limit = 1024</span><br><span class="line">capacity = 1024</span><br></pre></td></tr></table></figure>
<p><strong>添加数据 “沉默王二” 后:</strong></p>
<p>由于 “沉默王二” 为 UTF-8 编码，一个汉字占 3 个字节，共有 4 个汉字，所以占用 12 个字节。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">position = 12</span><br><span class="line">limit = 1024</span><br><span class="line">capacity = 1024</span><br></pre></td></tr></table></figure>
<p>调用flip()方法后:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">position = 0</span><br><span class="line">limit = 12</span><br><span class="line">capacity = 1024</span><br></pre></td></tr></table></figure>
<p>用一幅图来表示就是。</p>
<p><img src="\assets\note\image-20231012210206210.png" alt="image-20231012210206210"></p>
<p>当切换成读模式之后，我们就可以读取缓冲区的数据了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个limit()大小的字节数组(因为就只有limit这么多个数据可读)</span><br><span class="line">byte[] bytes = new byte[byteBuffer.limit()];</span><br><span class="line">// 将读取的数据装进我们的字节数组中</span><br><span class="line">byteBuffer.get(bytes);</span><br><span class="line">// 输出数据</span><br><span class="line">System.out.println(new String(bytes, 0, bytes.length));</span><br></pre></td></tr></table></figure>
<p>输出后的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">沉默王二</span><br></pre></td></tr></table></figure>
<p>随后输出一下核心变量的值看看：</p>
<p><img src="\assets\note\image-20231012210643892.png" alt="image-20231012210643892"></p>
<p><strong>读完如何还想写数据到缓冲区</strong>，那就使用 clear() 方法，这个方法会“清空”缓冲区，数据没有真正被清空，只是被遗忘掉了</p>
<p><img src="\assets\note\image-20231012210710648.png" alt="image-20231012210710648"></p>
<p><strong>Channel 通道 </strong></p>
<p>Channel 通道<strong>只负责传输数据、不直接操作数据</strong>。操作数据都是通过 Buffer 缓冲区来进行操作！通常，通道可以分为两大类：文件通道和套接字通道。</p>
<p>FileChannel：用于文件 I/O 的通道，支持文件的读、写和追加操作。FileChannel 允许在文件的任意位置进行数据传输，支持文件锁定以及内存映射文件等高级功能。FileChannel 无法设置为非阻塞模式，因此它只适用于阻塞式文件操作。</p>
<p>SocketChannel：用于 TCP 套接字 I/O 的通道。SocketChannel 支持非阻塞模式，可以与 Selector（下文会讲）一起使用，实现高效的网络通信。SocketChannel 允许连接到远程主机，进行数据传输。</p>
<p>与之匹配的有ServerSocketChannel：用于监听 TCP 套接字连接的通道。与 SocketChannel 类似，ServerSocketChannel 也支持非阻塞模式，并可以与 Selector 一起使用。ServerSocketChannel 负责监听新的连接请求，接收到连接请求后，可以创建一个新的 </p>
<p>DatagramChannel：用于 UDP 套接字 I/O 的通道。DatagramChannel 支持非阻塞模式，可以发送和接收数据报包，适用于无连接的、不可靠的网络通信。</p>
<p>这篇我们主要来讲 FileChannel，SocketChannel、ServerSocketChannel 和 DatagramChannel 会放到后面的章节中讲解。</p>
<p><strong>文件通道 FileChannel </strong></p>
<p>可以通过下面的方式打开一个通道。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileChannel.open(Paths.get(&quot;docs/配套教程.md&quot;), StandardOpenOption.WRITE);</span><br></pre></td></tr></table></figure>
<p>这里我们用到了 Paths，这个后面也会讲到。</p>
<p>①、使用<strong>FileChannel 配合 ByteBuffer 缓冲区</strong>实现文件复制的功能：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">try (FileChannel sourceChannel = </span><br><span class="line">FileChannel.open(Paths.get(&quot;logs/javabetter/itwanger.txt&quot;), </span><br><span class="line">StandardOpenOption.READ);</span><br><span class="line">    FileChannel destinationChannel = </span><br><span class="line">FileChannel.open(Paths.get(&quot;logs/javabetter/itwanger1.txt&quot;), </span><br><span class="line">StandardOpenOption.WRITE, StandardOpenOption.CREATE)) &#123;</span><br><span class="line">  ByteBuffer buffer = ByteBuffer.allocate(1024);</span><br><span class="line">  while (sourceChannel.read(buffer) != -1) &#123;</span><br><span class="line">      buffer.flip();</span><br><span class="line">      destinationChannel.write(buffer);</span><br><span class="line">      buffer.clear();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们创建一个容量为 1024 的 ByteBuffer 作为缓冲区。在循环中，我们从源文件的 FileChannel 读取数据到缓冲区。当 read() 方法返回 -1 时，表示已经到达文件末尾。</p>
<p>读取数据后，我们调用 flip() 方法，以便在缓冲区中准备好要写入的数据。然后，我们将缓冲区的内容写入目标文件的 FileChannel（ write() 方法）。在写入完成后，我们调用 clear() 方法重置缓冲区，以便在下一次迭代中重用它。</p>
<p>②、使用<strong>内存映射文件（MappedByteBuffer）</strong>的方式实现<strong>文件复制</strong>的功能(直接操作缓冲区)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">try (FileChannel sourceChannel = </span><br><span class="line">FileChannel.open(Paths.get(&quot;logs/javabetter/itwanger.txt&quot;), </span><br><span class="line">StandardOpenOption.READ);</span><br><span class="line">      FileChannel destinationChannel = </span><br><span class="line">FileChannel.open(Paths.get(&quot;logs/javabetter/itwanger2.txt&quot;), </span><br><span class="line">StandardOpenOption.WRITE, StandardOpenOption.CREATE, StandardOpenOption.READ)) &#123;</span><br><span class="line">    long fileSize = sourceChannel.size();</span><br><span class="line">    MappedByteBuffer sourceMappedBuffer = </span><br><span class="line">sourceChannel.map(FileChannel.MapMode.READ_ONLY, 0, fileSize);</span><br><span class="line">    MappedByteBuffer destinationMappedBuffer = </span><br><span class="line">destinationChannel.map(FileChannel.MapMode.READ_WRITE, 0, fileSize);</span><br><span class="line">    for (int i = 0; i &lt; fileSize; i++) &#123;</span><br><span class="line">        byte b = sourceMappedBuffer.get(i);</span><br><span class="line">        destinationMappedBuffer.put(i, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MappedByteBuffer 是 Java NIO 中的一个类，它继承自 java.nio.ByteBuffer 。MappedByteBuffer 用于表示一个内存映射文件，即将文件的一部分或全部映射到内存中，以便通过直接操作内存来实现对文件的读写。这种方式可以提高文件 I/O 的性能，因为操作系统可以直接在内存和磁盘之间传输数据，无需通过 Java 应用程序进行额外的数据拷贝。</p>
<p>通常与 FileChannel 一起使用，可以通过调用 FileChannel 的 map() 方法创建 MappedByteBuffer 对象。map() 方法接受三个参数：映射模式（FileChannel.MapMode）映射起始位置和映射的长度。</p>
<p>映射模式包括只读模式（READ_ONLY）、读写模式（READ_WRITE）和专用模式（PRIVATE）。</p>
<p>我们设置源文件的 MappedByteBuffer 为只读模式（READ_ONLY），目标文件的 MappedByteBuffer 为读写模式（READ_WRITE）。</p>
<p>在循环中，我们逐字节地从源文件的 MappedByteBuffer 读取数据并将其写入目标文件的 MappedByteBuffer。这样就实现了文件复制功能。利用内存映射文件（MappedByteBuffer）实现的文件复制，可能会比使用 ByteBuffer 的方法更快。</p>
<p>需要注意的是，使用 MappedByteBuffer 进行文件操作时，数据的修改可能不会立即写入磁盘。可以通过调用 MappedByteBuffer 的 force() 方法将数据立即写回磁盘。</p>
<p>③、通道之间通过 transfer()实现数据的传输(直接操作缓冲区)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">try (FileChannel sourceChannel = </span><br><span class="line">FileChannel.open(Paths.get(&quot;logs/javabetter/itwanger.txt&quot;), </span><br><span class="line">StandardOpenOption.READ);</span><br><span class="line">      FileChannel destinationChannel = </span><br><span class="line">FileChannel.open(Paths.get(&quot;logs/javabetter/itwanger3.txt&quot;), </span><br><span class="line">StandardOpenOption.WRITE, StandardOpenOption.CREATE, StandardOpenOption.READ)) &#123;</span><br><span class="line">    sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    throw new RuntimeException(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FileChannel 的 transferTo() 方法是一个高效的文件传输方法，它允许将文件的一部分或全部内容直接从源文件通道传输到目标通道（通常是另一个文件通道或网络通道）。这种传输方式可以避免将文件数据在用户空间和内核空间之间进行多次拷贝，提高了文件传输的性能。</p>
<p>transferTo() 方法接受以下三个参数：</p>
<ul>
<li>position：源文件中开始传输的位置。</li>
<li>count：要传输的字节数。</li>
<li>target：接收数据的目标通道。</li>
</ul>
<p>需要注意的是， transferTo() 方法可能无法一次传输所有请求的字节。在实际应用中，你可能需要使用循环来确保所有字节都被传输。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class FileChannelTransferToLoopExampleWithPaths &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Path sourcePath = Paths.get(&quot;logs/itwanger/paicoding.txt&quot;);</span><br><span class="line">        Path destinationPath = Paths.get(&quot;logs/itwanger/paicoding_copy.txt&quot;);</span><br><span class="line">        // 使用 try-with-resources 语句确保通道资源被正确关闭</span><br><span class="line">        try (FileChannel sourceChannel = FileChannel.open(sourcePath, </span><br><span class="line">StandardOpenOption.READ);</span><br><span class="line">             FileChannel destinationChannel = FileChannel.open(destinationPath, </span><br><span class="line">StandardOpenOption.CREATE, StandardOpenOption.WRITE)) &#123;</span><br><span class="line">            long position = 0;</span><br><span class="line">            long count = sourceChannel.size();</span><br><span class="line">            // 循环传输，直到所有字节都被传输</span><br><span class="line">            while (position &lt; count) &#123;</span><br><span class="line">                long transferred = sourceChannel.transferTo(position, count - </span><br><span class="line">position, destinationChannel);</span><br><span class="line">                position += transferred;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外， transferTo() 方法在底层使用了操作系统提供的零拷贝功能（如 Linux 的 sendfile() 系统调用），可以大幅提高文件传输性能。但是，不同操作系统和 JVM 实现可能会影响零拷贝的可用性和性能，因此实际性能可能因环境而异。</p>
<p>零拷贝（Zero-Copy）是一种优化数据传输性能的技术，它最大限度地减少了在数据传输过程中的 CPU 和内存开销。在传统的数据传输过程中，数据通常需要在用户空间和内核空间之间进行多次拷贝，这会导致额外的 CPU 和内存开销。零拷贝技术通过避免这些多余的拷贝操作，实现了更高效的数据传输。</p>
<p>在 Java 中，零拷贝技术主要应用于文件和网络 I/O。FileChannel 类的 transferTo() 和 transferFrom() 方法就利用了零拷贝技术，可以在文件和网络通道之间高效地传输数据。</p>
<p><strong>直接与非直接缓冲区 </strong></p>
<p>直接缓冲区和非直接缓冲区的差别主要在于它们在内存中的存储方式。这里给出了直接缓冲区和非直接缓冲区的简要概述和区别：</p>
<p>非直接缓冲区：</p>
<ul>
<li>分配在 JVM 堆内存中</li>
<li>受到垃圾回收的管理</li>
<li>在读写操作时，需要将数据从堆内存复制到操作系统的本地内存，再进行 I/O 操作</li>
<li>创建： ByteBuffer.allocate(int capacity)</li>
</ul>
<p>直接缓冲区：</p>
<ul>
<li>分配在操作系统的本地内存中</li>
<li>不受垃圾回收的管理</li>
<li>在读写操作时，直接在本地内存中进行，避免了数据复制，提高了性能</li>
<li>创建： ByteBuffer.allocateDirect(int capacity)</li>
<li>还有前面提到的 FileChannel.map() 方法，会返回一个类型为 MappedByteBuffer 的直接缓冲区。</li>
</ul>
<p>ByteBuffer.allocate和ByteBuffer.allocateDirect直接的差异。</p>
<p><img src="\assets\note\image-20231012212248398.png" alt="image-20231012212248398"></p>
<p>直接缓冲区和非直接缓冲区之间的差异。</p>
<p><img src="\assets\note\image-20231012212321462.png" alt="image-20231012212321462"></p>
<p>非直接缓冲区存储在JVM内部，数据需要从应用程序（Java）复制到非直接缓冲区，再复制到内核缓冲区，最后发送到设备（磁盘/网络）。而对于直接缓冲区，数据可以直接从应用程序（Java）复制到内核缓冲区，无需经过JVM的非直接缓冲区。</p>
<p><strong>异步文件通道 AsynchronousFileChannel </strong></p>
<p>AsynchronousFileChannel 是 Java 7 引入的一个异步文件通道类，提供了对文件的异步读、写、打开和关闭等操作。</p>
<p>可以通过 AsynchronousFileChannel.open() 方法打开一个异步文件通道，该方法接受一个 Path 对象和一组打开选项（如 StandardOpenOption.READ、StandardOpenOption.WRITE 等）作为参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Path file = Paths.get(&quot;example.txt&quot;);</span><br><span class="line">AsynchronousFileChannel fileChannel = AsynchronousFileChannel.open(file, </span><br><span class="line">StandardOpenOption.READ, StandardOpenOption.WRITE);</span><br></pre></td></tr></table></figure>
<p>AsynchronousFileChannel 提供了两种异步操作的方式：</p>
<p>①、Future 方式：使用 Future 对象来跟踪异步操作的完成情况。当我们调用一个异步操作（如 read() 或 write() ）时，它会立即返回一个 Future 对象。可以使用这个对象来检查操作是否完成，以及获取操作的结果。这种方式适用于不需要在操作完成时立即执行其他操作的场景。</p>
<p>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.allocate(1024);</span><br><span class="line">long position = 0;</span><br><span class="line">Future&lt;Integer&gt; result = fileChannel.read(buffer, position);</span><br><span class="line">while (!result.isDone()) &#123;</span><br><span class="line">    // 执行其他操作</span><br><span class="line">&#125;</span><br><span class="line">int bytesRead = result.get();</span><br><span class="line">System.out.println(&quot;Bytes read: &quot; + bytesRead);</span><br></pre></td></tr></table></figure>
<p>②、CompletionHandler 方式，使用一个实现了 CompletionHandler 接口的对象来处理异步操作的完成。我们需要提供一个 CompletionHandler 实现类，重写 completed() 和 failed() 方法，分别处理操作成功和操作失败的情况。当异步操作完成时，系统会自动调用相应的方法。这种方式适用于需要在操作完成时立即执行其他操作的场景。</p>
<p>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.allocate(1024);</span><br><span class="line">long position = 0;</span><br><span class="line">fileChannel.read(buffer, position, buffer, new CompletionHandler&lt;Integer, </span><br><span class="line">ByteBuffer&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void completed(Integer result, ByteBuffer attachment) &#123;</span><br><span class="line">        System.out.println(&quot;Bytes read: &quot; + result);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void failed(Throwable exc, ByteBuffer attachment) &#123;</span><br><span class="line">        System.err.println(&quot;Read failed&quot;);</span><br><span class="line">        exc.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>来看完整的示例，采用 Future 的形式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Path path = Paths.get(&quot;docs/配套教程.md&quot;);</span><br><span class="line">try (AsynchronousFileChannel fileChannel = AsynchronousFileChannel.open(path, </span><br><span class="line">StandardOpenOption.READ)) &#123;</span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(1024);</span><br><span class="line">    long position = 0;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        Future&lt;Integer&gt; result = fileChannel.read(buffer, position);</span><br><span class="line">        while (!result.isDone()) &#123;</span><br><span class="line">            // 在这里可以执行其他任务，例如处理其他 I/O 操作</span><br><span class="line">        &#125;</span><br><span class="line">        int bytesRead = result.get();</span><br><span class="line">        if (bytesRead &lt;= 0) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        position += bytesRead;</span><br><span class="line">        buffer.flip();</span><br><span class="line">        byte[] data = new byte[buffer.limit()];</span><br><span class="line">        buffer.get(data);</span><br><span class="line">        System.out.println(new String(data));</span><br><span class="line">        buffer.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们使用 AsynchronousFileChannel.read() 方法发起异步读取操作。这个方法会返回一个 Future<Integer> 对象，表示读取操作的结果。我们可以通过调用 isDone() 方法来检查异步操作是否完成。完成后，我们可以通过调用 get() 方法获取实际读取的字节数。</p>
<p>然后我们来看 CompletionHandler 接口的形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public static void readAllBytes(Path path) throws IOException, InterruptedException </span><br><span class="line">&#123;</span><br><span class="line">    AsynchronousFileChannel fileChannel = AsynchronousFileChannel.open(path, </span><br><span class="line">StandardOpenOption.READ);</span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(1024);</span><br><span class="line">    AtomicLong position = new AtomicLong(0);</span><br><span class="line">    CountDownLatch latch = new CountDownLatch(1);</span><br><span class="line">    fileChannel.read(buffer, position.get(), null, new CompletionHandler&lt;Integer, Object&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void completed(Integer bytesRead, Object attachment) &#123;</span><br><span class="line">            if (bytesRead &gt; 0) &#123;</span><br><span class="line">                position.addAndGet(bytesRead);</span><br><span class="line">                buffer.flip();</span><br><span class="line">                byte[] data = new byte[buffer.limit()];</span><br><span class="line">                buffer.get(data);</span><br><span class="line">                System.out.print(new String(data));</span><br><span class="line">                buffer.clear();</span><br><span class="line">                fileChannel.read(buffer, position.get(), attachment, this);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                latch.countDown();</span><br><span class="line">                try &#123;</span><br><span class="line">                    fileChannel.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public void failed(Throwable exc, Object attachment) &#123;</span><br><span class="line">            System.out.println(&quot;Error: &quot; + exc.getMessage());</span><br><span class="line">            latch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    latch.await();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1、在 readAllBytes 方法中，我们使用 AsynchronousFileChannel.open() 方法以读取模式打开异步文件通道。</p>
<p>2、创建一个大小为 1024 的 ByteBuffer 来存储从文件中读取的数据。</p>
<p>3、使用 AtomicLong 类型的 position 变量来记录当前读取的文件位置。初始值为 0。</p>
<p>4、创建一个 CountDownLatch 对象，用于在异步操作完成时通知主线程。初始值为 1。</p>
<p>5、使用 fileChannel.read() 方法启动异步读取操作。这个方法的参数包括：用于存储数据的缓冲区、当前读取位置、附加对象（在这个例子中不需要，所以传递 null）以及一个实现了 CompletionHandler 接口的对象，用于在读取操作完成时回调。</p>
<p>6、CompletionHandler 接口有两个方法： completed() 和 failed() 。在读取操作成功完成时调用 completed() 方法；如果读取操作失败，调用 failed() 方法。</p>
<p>7、在 completed() 方法中，我们首先检查 bytesRead（本次读取的字节数）是否大于 0。如果大于 0，说明还有数据需要读取。</p>
<ul>
<li>更新 position 变量，将其增加 bytesRead。</li>
<li>将缓冲区翻转（ flip() ），以便我们可以从中读取数据。</li>
<li>创建一个新的字节数组，其大小等于缓冲区的限制（ limit() ）。</li>
<li>从缓冲区中获取数据并将其存储在新创建的字节数组中。</li>
<li>将字节数组转换为字符串并输出。</li>
<li>清除缓冲区，以便我们可以继续读取更多数据。</li>
<li>再次调用 fileChannel.read() 方法，以继续从文件中读取数据。</li>
</ul>
<p>8、如果 bytesRead 等于或小于 0，说明我们已经读取完文件中的所有数据。此时，我们需要：调用 latch.countDown() 方法，以通知主线程异步操作已完成。关闭 fileChannel。</p>
<p>9、如果读取操作失败，我们将在 failed() 方法中输出错误信息并调用 latch.countDown() 方法通知主线程。</p>
<p>10、最后，我们调用 latch.await() 方法来等待异步操作完成。主线程将在此处阻塞，直到 latch 的计数变为 0。 </p>
<p><strong>小结 </strong></p>
<p>Java NIO 中的 Buffer 和 Channel 是 NIO 系统的核心组件。Buffer 负责存储数据，提供了对数据的读写操作。它有多种类型，如 ByteBuffer、CharBuffer、IntBuffer 等，以支持不同的数据类型。</p>
<p>Channel 代表了与 I/O 设备（如文件或套接字）之间的连接。它提供了从源设备到 Buffer 的数据读取能力和从 Buffer 到目标设备的数据写入能力。Channel 可以是可读、可写或同时可读写的，我们详细介绍了文件通道 FileChannel 和异步文件通道 AsynchronousFileChannel。</p>
<p>总之，NIO 使用 Buffer 和 Channel 这两个组件来进行高效的数据传输，以提高 I/O 操作的性能。</p>
<h2 id="10-4-Paths-和-Files"><a href="#10-4-Paths-和-Files" class="headerlink" title="10.4 Paths 和 Files"></a>10.4 Paths 和 Files</h2><p>Paths 和 Files 在 Java 7 的时候引入，作为对 java.io.File 类的补充和改进。</p>
<p><strong>Paths 类 </strong></p>
<p>Paths 类主要用于操作文件和目录路径。它提供了一些静态方法，用于创建 java.nio.file.Path实例，代表文件系统中的路径。</p>
<p>下面是 Paths 的一个示例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个Path实例，表示当前目录下的一个文件</span><br><span class="line">Path path = Paths.get(&quot;example.txt&quot;);</span><br><span class="line">// 创建一个绝对路径</span><br><span class="line">Path absolutePath = Paths.get(&quot;/home/user/example.txt&quot;);</span><br></pre></td></tr></table></figure>
<p>java.nio.file.Path 接口在 Java NIO.2 中代表一个文件系统中的路径。它提供了一系列方法来操作和查询路径。</p>
<p><img src="\assets\note\image-20231012213428186.png" alt="image-20231012213428186"></p>
<p>下面是 Paths 和 Path 一起使用的实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Path path = Paths.get(&quot;docs/配套教程.md&quot;);</span><br><span class="line">// 获取文件名</span><br><span class="line">System.out.println(&quot;File name: &quot; + path.getFileName());</span><br><span class="line">// 获取父目录</span><br><span class="line">System.out.println(&quot;Parent: &quot; + path.getParent());</span><br><span class="line">// 获取根目录</span><br><span class="line">System.out.println(&quot;Root: &quot; + path.getRoot());</span><br><span class="line">// 将路径与另一个路径结合</span><br><span class="line">Path newPath = path.resolve(&quot;config/app.properties&quot;);</span><br><span class="line">System.out.println(&quot;Resolved path: &quot; + newPath);</span><br><span class="line">// 简化路径</span><br><span class="line">Path normalizedPath = newPath.normalize();</span><br><span class="line">System.out.println(&quot;Normalized path: &quot; + normalizedPath);</span><br><span class="line">// 将相对路径转换为绝对路径</span><br><span class="line">Path absolutePath = path.toAbsolutePath();</span><br><span class="line">System.out.println(&quot;Absolute path: &quot; + absolutePath);</span><br><span class="line">// 计算两个路径之间的相对路径</span><br><span class="line">Path basePath = Paths.get(&quot;/docs/&quot;);</span><br><span class="line">Path targetPath = Paths.get(&quot;/docs/imgs/itwanger&quot;);</span><br><span class="line">Path relativePath = basePath.relativize(targetPath);</span><br><span class="line">System.out.println(&quot;Relative path: &quot; + relativePath);</span><br></pre></td></tr></table></figure>
<p><strong>Files 类 </strong></p>
<p>java.nio.file.Files类提供了大量静态方法，用于处理文件系统中的文件和目录。这些方法包括文件的创建、删除、复制、移动等操作，以及读取和设置文件属性。</p>
<p>下面展示一个 Files 和 Paths 一起使用的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个Path实例</span><br><span class="line">Path path = Paths.get(&quot;logs/javabetter/itwanger4.txt&quot;);</span><br><span class="line">// 创建一个新文件</span><br><span class="line">Files.createFile(path);</span><br><span class="line">// 检查文件是否存在</span><br><span class="line">boolean exists = Files.exists(path);</span><br><span class="line">System.out.println(&quot;File exists: &quot; + exists);</span><br><span class="line">// 删除文件</span><br><span class="line">Files.delete(path);</span><br></pre></td></tr></table></figure>
<p>以下是一些常用方法及其示例：</p>
<p>1、 exists(Path path, LinkOption… options) ：检查文件或目录是否存在。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Path path = Paths.get(&quot;file.txt&quot;);</span><br><span class="line">boolean exists = Files.exists(path);</span><br><span class="line">System.out.println(&quot;File exists: &quot; + exists);</span><br></pre></td></tr></table></figure>
<p>LinkOption 是一个枚举类，它定义了如何处理文件系统链接的选项。它位于 java.nio.file 包中。LinkOption 主要在与文件或目录的路径操作相关的方法中使用，以控制这些方法如何处理符号链接。符号链接是一种特殊类型的文件，它在 Unix 和类 Unix 系统（如 Linux 和 macOS）上很常见。在 Windows 上，类似的概念被称为快捷方式。</p>
<p>2、 createFile(Path path, FileAttribute&lt;?&gt;… attrs) ：创建一个新的空文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Path newPath = Paths.get(&quot;newFile.txt&quot;);</span><br><span class="line">Files.createFile(newPath);</span><br></pre></td></tr></table></figure>
<p>FileAttribute 是一个泛型接口，用于处理各种不同类型的属性。在使用 FileAttribute 时，你需要为其提供一个特定的实现。 java.nio.file.attribute 包中的 PosixFileAttributes 类提供了 POSIX（Portable Operating System Interface，定义了许多与文件系统相关的操作，包括文件和目录的创建、删除、读取和修改。）文件属性的实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Path path = Paths.get(&quot;fileWithPermissions.txt&quot;);</span><br><span class="line">Set&lt;PosixFilePermission&gt; permissions = PosixFilePermissions.fromString(&quot;rw-r-----&quot;);</span><br><span class="line">FileAttribute&lt;Set&lt;PosixFilePermission&gt;&gt; fileAttribute = </span><br><span class="line">PosixFilePermissions.asFileAttribute(permissions);</span><br><span class="line">Files.createFile(path, fileAttribute);</span><br></pre></td></tr></table></figure>
<p>PosixFileAttributes 接口提供了获取 POSIX 文件属性的方法，如文件所有者、文件所属的组以及文件的访问权限。以上示例会创建一个读写属性的文件。</p>
<p>3、 createDirectory(Path dir, FileAttribute&lt;?&gt;… attrs) ：创建一个新的目录。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Path newDir = Paths.get(&quot;newDirectory&quot;);</span><br><span class="line">Files.createDirectory(newDir);</span><br></pre></td></tr></table></figure>
<p>4、 delete(Path path) ：删除文件或目录。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Path pathToDelete = Paths.get(&quot;fileToDelete.txt&quot;);</span><br><span class="line">Files.delete(pathToDelete);</span><br></pre></td></tr></table></figure>
<p>5、 copy(Path source, Path target, CopyOption… options) ：复制文件或目录。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Path sourcePath = Paths.get(&quot;sourceFile.txt&quot;);</span><br><span class="line">Path targetPath = Paths.get(&quot;targetFile.txt&quot;);</span><br><span class="line">Files.copy(sourcePath, targetPath, StandardCopyOption.REPLACE_EXISTING);</span><br></pre></td></tr></table></figure>
<p>在 Java NIO 中，有两个实现了 CopyOption 接口的枚举类：StandardCopyOption 和 LinkOption。</p>
<p>StandardCopyOption 枚举类提供了以下两个选项：</p>
<ul>
<li>REPLACE_EXISTING：如果目标文件已经存在，该选项会使 Files.copy() 方法替换目标文件。如果不指定此选项， Files.copy() 方法在目标文件已存在时将抛出 FileAlreadyExistsException。</li>
<li>COPY_ATTRIBUTES：此选项表示在复制文件时，尽可能地复制文件的属性（如文件时间戳、权限等）。如果不指定此选项，那么目标文件将具有默认的属性。</li>
</ul>
<p>6、 move(Path source, Path target, CopyOption… options) ：移动或重命名文件或目录。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Path sourcePath = Paths.get(&quot;sourceFile.txt&quot;);</span><br><span class="line">Path targetPath = Paths.get(&quot;targetFile.txt&quot;);</span><br><span class="line">Files.move(sourcePath, targetPath, StandardCopyOption.REPLACE_EXISTING);</span><br></pre></td></tr></table></figure>
<p>7、 readAllLines(Path path, Charset cs) ：读取文件的所有行到一个字符串列表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ath path = Paths.get(&quot;file.txt&quot;);</span><br><span class="line">List&lt;String&gt; lines = Files.readAllLines(path, StandardCharsets.UTF_8);</span><br><span class="line">lines.forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>8、 write(Path path, Iterable&lt;? extends CharSequence&gt; lines, Charset cs, OpenOption… options) ：将字符串列表写入文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Path path = Paths.get(&quot;file.txt&quot;);</span><br><span class="line">List&lt;String&gt; lines = Arrays.asList(&quot;沉默王二 1&quot;, &quot;沉默王二 2&quot;, &quot;沉默王二 3&quot;);</span><br><span class="line">Files.write(path, lines, StandardCharsets.UTF_8);</span><br></pre></td></tr></table></figure>
<p>OpenOption 是 Java NIO 中一个用于配置文件操作的接口。它提供了在使用 Files.newByteChannel() 、Files.newInputStream() 、 Files.newOutputStream() 、 AsynchronousFileChannel.open() 和 FileChannel.open() 方法时定制行为的选项。</p>
<p>在 Java NIO 中，有两个实现了 OpenOption 接口的枚举类：StandardOpenOption 和 LinkOption。</p>
<p>StandardOpenOption 枚举类提供了以下几个选项：</p>
<ul>
<li>READ：以读取模式打开文件。</li>
<li>WRITE：以写入模式打开文件。</li>
<li>APPEND：以追加模式打开文件。</li>
<li>TRUNCATE_EXISTING：在打开文件时，截断文件的内容，使其长度为 0。仅适用于 WRITE 或 APPEND 模式。</li>
<li>CREATE：当文件不存在时创建文件。如果文件已存在，则打开文件。</li>
<li>CREATE_NEW：当文件不存在时创建文件。如果文件已存在，抛出 FileAlreadyExistsException。</li>
<li>DELETE_ON_CLOSE：在关闭通道时删除文件。</li>
<li>SPARSE：提示文件系统创建一个稀疏文件。</li>
<li>SYNC：要求每次更新文件的内容或元数据时都进行同步。</li>
<li>DSYNC：要求每次更新文件内容时都进行同步。</li>
</ul>
<p>8、 newBufferedReader(Path path, Charset cs) 和 newBufferedWriter(Path path, Charset cs, OpenOption… options) ：创建 BufferedReader 和 BufferedWriter 对象以读取和写入文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Path path = Paths.get(&quot;file.txt&quot;);</span><br><span class="line">// Read file</span><br><span class="line">try (BufferedReader reader = Files.newBufferedReader(path, StandardCharsets.UTF_8)) </span><br><span class="line">&#123;</span><br><span class="line">    String line;</span><br><span class="line">    while ((line = reader.readLine()) != null) &#123;</span><br><span class="line">        System.out.println(line);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// Write file</span><br><span class="line">Path outputPath = Paths.get(&quot;outputFile.txt&quot;);</span><br><span class="line">try (BufferedWriter writer = Files.newBufferedWriter(outputPath, </span><br><span class="line">StandardCharsets.UTF_8)) &#123;</span><br><span class="line">    writer.write(&quot;沉默王二&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Files.walkFileTree() 静态方法 </strong></p>
<p>这个方法可以递归地访问目录结构中的所有文件和目录，并允许您对这些文件和目录执行自定义操作。使用 walkFileTree 方法时，需要提供一个起始路径（起始目录）和一个实现了 FileVisitor 接口的对象。</p>
<p>FileVisitor 接口包含四个方法，它们在遍历过程中的不同阶段被调用：</p>
<ul>
<li>preVisitDirectory：在访问目录之前调用。</li>
<li>postVisitDirectory：在访问目录之后调用。</li>
<li>visitFile：在访问文件时调用。</li>
<li>visitFileFailed：在访问文件失败时调用。</li>
</ul>
<p>来看下面这个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class WalkFileTreeExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Path startingDir = Paths.get(&quot;docs&quot;);</span><br><span class="line">        MyFileVisitor fileVisitor = new MyFileVisitor();</span><br><span class="line">        try &#123;</span><br><span class="line">            Files.walkFileTree(startingDir, fileVisitor);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private static class MyFileVisitor extends SimpleFileVisitor&lt;Path&gt; &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException &#123;</span><br><span class="line">            System.out.println(&quot;准备访问目录: &quot; + dir);</span><br><span class="line">            return FileVisitResult.CONTINUE;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException &#123;</span><br><span class="line">            System.out.println(&quot;正在访问目录: &quot; + dir);</span><br><span class="line">            return FileVisitResult.CONTINUE;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException &#123;</span><br><span class="line">            System.out.println(&quot;访问文件: &quot; + file);</span><br><span class="line">            return FileVisitResult.CONTINUE;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException &#123;</span><br><span class="line">            System.err.println(&quot;访问文件失败: &quot; + file);</span><br><span class="line">            return FileVisitResult.CONTINUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">准备访问目录: docs</span><br><span class="line">访问文件: docs/安装环境.md</span><br><span class="line">准备访问目录: docs/imgs</span><br><span class="line">访问文件: docs/imgs/init_03.jpg</span><br><span class="line">准备访问目录: docs/imgs/itwanger</span><br><span class="line">访问文件: docs/imgs/itwanger/tongzhishu.jpeg</span><br><span class="line">访问文件: docs/imgs/itwanger/tongzhishu1.jpeg</span><br><span class="line">访问文件: docs/imgs/itwanger/tongzhishu1.pdf</span><br><span class="line">正在访问目录: docs/imgs/itwanger</span><br><span class="line">访问文件: docs/imgs/init_02.jpg</span><br><span class="line">访问文件: docs/imgs/init_00.jpg</span><br><span class="line">访问文件: docs/imgs/init_01.jpg</span><br><span class="line">访问文件: docs/imgs/init_04.jpg</span><br><span class="line">正在访问目录: docs/imgs</span><br><span class="line">访问文件: docs/服务器启动教程.md</span><br><span class="line">访问文件: docs/配套教程.md</span><br><span class="line">访问文件: docs/约定.md</span><br><span class="line">访问文件: docs/本地开发环境配置教程.md</span><br><span class="line">访问文件: docs/前端工程结构说明.md</span><br><span class="line">正在访问目录: docs</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们创建了一个名为 MyFileVisitor 的自定义 FileVisitor 类，它扩展了 SimpleFileVisitor 类。SimpleFileVisitor 是 FileVisitor 接口的一个实现，它提供了一些默认的行为。我们可以覆盖 SimpleFileVisitor 中的方法以实现自己的逻辑。在这个例子中，我们只是打印出了访问的文件和目录。然后，我们使用 Files.walkFileTree 方法遍历文件树。这个方法会遍历整个目录结构，并调用 MyFileVisitor 中的相应方法。</p>
<p>其中，FileVisitResult 枚举包含以下四个选项：</p>
<ul>
<li>CONTINUE ： 继续</li>
<li>TERMINATE ： 终止</li>
<li>SKIP_SIBLINGS ： 跳过兄弟节点，然后继续</li>
<li>SKIP_SUBTREE ： 跳过子树（不访问此目录的条目），然后继续，仅在 preVisitDirectory 方法返回时才有意义，除此以外和 CONTINUE 相同。</li>
</ul>
<p><strong>搜索文件 </strong></p>
<p>walkFileTree() 方法还可以用于搜索文件，下面这个例子扩展了 SimpleFileVisitor 来查找一个名为 itwanger.txt 的文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class FindFileWithWalkFileTree &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Path startingDir = Paths.get(&quot;logs&quot;);</span><br><span class="line">        String targetFileName = &quot;itwanger.txt&quot;;</span><br><span class="line">        FindFileVisitor findFileVisitor = new FindFileVisitor(targetFileName);</span><br><span class="line">        try &#123;</span><br><span class="line">            Files.walkFileTree(startingDir, findFileVisitor);</span><br><span class="line">            if (findFileVisitor.isFileFound()) &#123;</span><br><span class="line">                System.out.println(&quot;找到文件了: &quot; + findFileVisitor.getFoundFilePath());</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                System.out.println(&quot;ooh，文件没找到&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private static class FindFileVisitor extends SimpleFileVisitor&lt;Path&gt; &#123;</span><br><span class="line">        private String targetFileName;</span><br><span class="line">        private Path foundFilePath;</span><br><span class="line">        public FindFileVisitor(String targetFileName) &#123;</span><br><span class="line">            this.targetFileName = targetFileName;</span><br><span class="line">        &#125;</span><br><span class="line">        public boolean isFileFound() &#123;</span><br><span class="line">            return foundFilePath != null;</span><br><span class="line">        &#125;</span><br><span class="line">        public Path getFoundFilePath() &#123;</span><br><span class="line">            return foundFilePath;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException &#123;</span><br><span class="line">            String fileName = file.getFileName().toString();</span><br><span class="line">            if (fileName.equals(targetFileName)) &#123;</span><br><span class="line">                foundFilePath = file;</span><br><span class="line">                return FileVisitResult.TERMINATE;</span><br><span class="line">            &#125;</span><br><span class="line">            return FileVisitResult.CONTINUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在主方法中，我们使用 Files.walkFileTree 方法遍历文件树，并传递一个起始目录和 FindFileVisitor 实例。</p>
<p>遍历完成后，我们检查是否找到了目标文件，如果找到了，就打印出它的路径。</p>
<p>搜索结果如下所示：</p>
<p><img src="\assets\note\image-20231012214346676.png" alt="image-20231012214346676"></p>
<p><strong>小结 </strong></p>
<p>Paths 和 Files 是 Java NIO 中的两个核心类。Paths 提供了一系列静态方法，用于操作路径（Path 对象）。它可以将字符串或 URI 转换为 Path 对象，方便后续操作。Files 类提供了丰富的文件操作方法，如文件的创建、删除、移动、复制、读取和写入等。这些方法支持各种选项和属性，如覆盖、保留属性和符号链接处理。Files 还支持文件遍历（如 walkFileTree 方法），可以处理文件目录树。总之，Paths 和 Files 为文件和目录操作提供了简洁、高效的方法。</p>
<h2 id="10-5-NIO-实现简易版聊天室"><a href="#10-5-NIO-实现简易版聊天室" class="headerlink" title="10.5 NIO 实现简易版聊天室"></a>10.5 NIO 实现简易版聊天室</h2><p>在此之前，我们曾利用 Java 的套接字 Socket 和 ServerSocket 完成网络编程，但 Socket 和 ServerSocket 是基于 Java IO 的，在网络编程方面，性能会比较差。原因我们在之前也讲过。</p>
<p>那 Java NIO 的 SocketChannel 和 ServerSocketChannel 性能怎么样呢？</p>
<p><strong>SocketChannel 和 ServerSocketChannel </strong></p>
<p>在学习 NIO 的第一讲里，我们已经介绍过 SocketChannel 和 ServerSocketChannel了，这里再简单补充下。</p>
<p>ServerSocketChannel 用于创建服务器端套接字，而 SocketChannel 用于创建客户端套接字。它们都支持阻塞和非阻塞模式，通过设置其 blocking 属性来切换。阻塞模式下，读/写操作会一直阻塞直到完成，而非阻塞模式下，读/写操作会立即返回。</p>
<p>阻塞模式：</p>
<ul>
<li>优点：编程简单，适合低并发场景。</li>
<li>缺点：性能较差，不适合高并发场景。</li>
</ul>
<p>非阻塞模式：</p>
<ul>
<li>优点：性能更好，适合高并发场景。</li>
<li>缺点：编程相对复杂。</li>
</ul>
<p>我们来看一个简单的示例（阻塞模式下）：</p>
<p>先来看 Server 端的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class BlockingServer &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        // 创建服务器套接字</span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        // 绑定端口</span><br><span class="line">        serverSocketChannel.socket().bind(new InetSocketAddress(8080));</span><br><span class="line">        // 设置为阻塞模式（默认为阻塞模式）</span><br><span class="line">        serverSocketChannel.configureBlocking(true);</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            // 接收客户端连接</span><br><span class="line">            SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">            // 分配缓冲区</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(1024);</span><br><span class="line">            // 读取数据</span><br><span class="line">            int bytesRead = socketChannel.read(buffer);</span><br><span class="line">            while (bytesRead != -1) &#123;</span><br><span class="line">                buffer.flip();</span><br><span class="line">                System.out.println(StandardCharsets.UTF_8.decode(buffer));</span><br><span class="line">                buffer.clear();</span><br><span class="line">                bytesRead = socketChannel.read(buffer);</span><br><span class="line">            &#125;</span><br><span class="line">            // 关闭套接字</span><br><span class="line">            socketChannel.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单解释一下这段代码，也比较好理解。</p>
<p>首先创建服务器端套接字ServerSocketChannel，然后绑定 8080 端口，接着使用 while 循环监听客户端套接字。如果接收到客户端连接 SocketChannel，就从通道里读取数据到缓冲区 ByteBuffer，一直读到通道里没有数据，关闭当前通道。</p>
<p>其中 serverSocketChannel.configureBlocking(true) 用来设置通道为阻塞模式（可以缺省）。</p>
<p>再来看客户端的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class BlockingClient &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        // 创建客户端套接字</span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">        // 连接服务器</span><br><span class="line">        socketChannel.connect(new InetSocketAddress(&quot;localhost&quot;, 8080));</span><br><span class="line">        // 分配缓冲区</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(1024);</span><br><span class="line">        // 向服务器发送数据</span><br><span class="line">        buffer.put(&quot;沉默王二，这是来自客户端的消息。&quot;.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        buffer.flip();</span><br><span class="line">        socketChannel.write(buffer);</span><br><span class="line">        // 清空缓冲区</span><br><span class="line">        buffer.clear();</span><br><span class="line">        // 关闭套接字</span><br><span class="line">        socketChannel.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端代码就更简单了，建立通道 SocketChannel，连接服务器，然后在缓冲区里放一段数据，之后写入到通道中，关闭套接字。</p>
<p>先运行 BlockingServer，再运行 BlockingClient，可以在 Server 端的控制台收到以下信息。</p>
<p><img src="\assets\note\image-20231012214653033.png" alt="image-20231012214653033"></p>
<p>好，我们再来看非阻塞模式下的示例。</p>
<p>先来看 Server 端： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class NonBlockingServer &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        // 创建服务器套接字</span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        // 绑定端口</span><br><span class="line">        serverSocketChannel.socket().bind(new InetSocketAddress(8080));</span><br><span class="line">        // 设置为非阻塞模式</span><br><span class="line">        serverSocketChannel.configureBlocking(false);</span><br><span class="line">        // 创建选择器</span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        // 注册服务器套接字到选择器</span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            selector.select();</span><br><span class="line">            Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selectedKeys.iterator();</span><br><span class="line">            while (iterator.hasNext()) &#123;</span><br><span class="line">                SelectionKey key = iterator.next();</span><br><span class="line">                iterator.remove();</span><br><span class="line">                if (key.isAcceptable()) &#123;</span><br><span class="line">                    // 接收客户端连接</span><br><span class="line">                    SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">                    socketChannel.configureBlocking(false);</span><br><span class="line">                    socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                &#125;</span><br><span class="line">                if (key.isReadable()) &#123;</span><br><span class="line">                    // 读取数据</span><br><span class="line">                    SocketChannel socketChannel = (SocketChannel) key.channel();</span><br><span class="line">                    ByteBuffer buffer = ByteBuffer.allocate(1024);</span><br><span class="line">                    int bytesRead = socketChannel.read(buffer);</span><br><span class="line">                    if (bytesRead != -1) &#123;</span><br><span class="line">                        buffer.flip();</span><br><span class="line">                        System.out.print(StandardCharsets.UTF_8.decode(buffer));</span><br><span class="line">                        buffer.clear();</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        // 客户端已断开连接，取消选择键并关闭通道</span><br><span class="line">                        key.cancel();</span><br><span class="line">                        socketChannel.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与之前阻塞模式相同的，我们就不再赘述了，只说不同的。</p>
<p>①、首先，创建一个 ServerSocketChannel，并将其设置为非阻塞模式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">serverSocketChannel.configureBlocking(false);</span><br></pre></td></tr></table></figure>
<p>②、创建一个 Selector 实例，用于处理多个通道的事件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure>
<p>③、将 ServerSocketChannel 注册到 Selector 上，并设置感兴趣的事件为 OP_ACCEPT。这意味着当有新的客户端连接请求时，Selector 会通知我们。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></figure>
<p>看一下 OP_ACCEPT 的注释：<br>            <img src="\assets\note\image-20231012214842790.png" alt="image-20231012214842790"></p>
<p>④、循环处理 Selector 中的事件。首先调用 selector.select() 方法来等待感兴趣的事件发生。这个方法会阻塞，直到至少有一个感兴趣的事件发生。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while (true) &#123;</span><br><span class="line">    int readyChannels = selector.select();</span><br><span class="line">    if (readyChannels == 0) &#123;</span><br><span class="line">        continue;</span><br><span class="line">    &#125;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>⑤、当 selector.select() 返回时，我们可以通过 selector.selectedKeys() 获取所有已就绪的事件，并对其进行迭代处理。在处理事件时，根据 SelectionKey 的类型来执行相应的操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line">Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();</span><br><span class="line">while (keyIterator.hasNext()) &#123;</span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line">    // 处理事件</span><br><span class="line">    // ...</span><br><span class="line">    keyIterator.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>⑥、当 SelectionKey 的类型为 OP_ACCEPT 时，说明有新的客户端连接请求。此时，我们需要接受新的连接，并将新创建的 SocketChannel 设置为非阻塞模式。然后，将该 SocketChannel 注册到 Selector 上，并设置感兴趣的事件为 OP_READ。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (key.isAcceptable()) &#123;</span><br><span class="line">    ServerSocketChannel server = (ServerSocketChannel) key.channel();</span><br><span class="line">    SocketChannel client = server.accept();</span><br><span class="line">    client.configureBlocking(false);</span><br><span class="line">    client.register(selector, SelectionKey.OP_READ);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>⑦、当 SelectionKey 的类型为 OP_READ 时，说明有客户端发送了数据。我们需要从 SocketChannel 中读取数据，并进行相应的处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (key.isReadable()) &#123;</span><br><span class="line">    SocketChannel client = (SocketChannel) key.channel();</span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(1024);</span><br><span class="line">    int bytesRead = client.read(buffer);</span><br><span class="line">    // 对读取到的数据进行处理</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>⑧、（如果可以的话）当 SelectionKey 的类型为 OP_WRITE 时，说明可以向客户端发送数据。我们可以将要发送的数据写入 SocketChannel。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (key.isWritable()) &#123;</span><br><span class="line">    SocketChannel client = (SocketChannel) key.channel();</span><br><span class="line">    ByteBuffer buffer = ByteBuffer.wrap(&quot;你好，客户端&quot;.getBytes());</span><br><span class="line">   client.write(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过，本例中并没有这一步。如果需要的话，可以按照这样的方式向客户端写入数据。</p>
<p>⑨、在服务器停止运行时，需要关闭 Selector 和 ServerSocketChannel，释放资源。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">key.cancel();</span><br><span class="line">socketChannel.close();</span><br></pre></td></tr></table></figure>
<p>好，接下来，我们来看客户端的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class NonBlockingClient &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        // 创建客户端套接字</span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">        // 设置为非阻塞模式</span><br><span class="line">        socketChannel.configureBlocking(false);</span><br><span class="line">        // 连接服务器</span><br><span class="line">        socketChannel.connect(new InetSocketAddress(&quot;localhost&quot;, 8080));</span><br><span class="line">        while (!socketChannel.finishConnect()) &#123;</span><br><span class="line">            // 等待连接完成</span><br><span class="line">        &#125;</span><br><span class="line">        // 分配缓冲区</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(1024);</span><br><span class="line">        // 向服务器发送数据</span><br><span class="line">        String message = &quot;你好，沉默王二，这是来自客户端的消息。&quot;;</span><br><span class="line">        buffer.put(message.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        buffer.flip();</span><br><span class="line">        socketChannel.write(buffer);</span><br><span class="line">        // 清空缓冲区</span><br><span class="line">        buffer.clear();</span><br><span class="line">        // 关闭套接字</span><br><span class="line">        socketChannel.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端代码依然比较简单，我们直接略过，不再解释。然后运行 Server，再运行 Client。可以运行多次，结果如下：</p>
<p><img src="\assets\note\image-20231012215131916.png" alt="image-20231012215131916"></p>
<p><strong>Scatter 和 Gather </strong></p>
<p>Scatter 和 Gather 是 Java NIO 中两种高效的 I/O 操作，用于将数据分散到多个缓冲区或从多个缓冲区中收集数据。</p>
<p>Scatter（分散）：它将从 Channel 读取的数据分散（写入）到多个缓冲区。这种操作可以在读取数据时将其分散到不同的缓冲区，有助于处理结构化数据。例如，我们可以将消息头、消息体和消息尾分别写入不同的缓冲区。</p>
<p>Gather（聚集）：与 Scatter 相反，它将多个缓冲区中的数据聚集（读取）并写入到一个 Channel。这种操作允许我们在发送数据时从多个缓冲区中聚集数据。例如，我们可以将消息头、消息体和消息尾从不同的缓冲区中聚集到一起并写入到同一个 Channel。</p>
<p>来写一个完整的 demo，先看 Server。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个ServerSocketChannel</span><br><span class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">serverSocketChannel.socket().bind(new InetSocketAddress(9000));</span><br><span class="line">// 接受连接</span><br><span class="line">SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">// Scatter：分散读取数据到多个缓冲区</span><br><span class="line">ByteBuffer headerBuffer = ByteBuffer.allocate(128);</span><br><span class="line">ByteBuffer bodyBuffer = ByteBuffer.allocate(1024);</span><br><span class="line">ByteBuffer[] buffers = &#123;headerBuffer, bodyBuffer&#125;;</span><br><span class="line">long bytesRead = socketChannel.read(buffers);</span><br><span class="line">// 输出缓冲区数据</span><br><span class="line">headerBuffer.flip();</span><br><span class="line">while (headerBuffer.hasRemaining()) &#123;</span><br><span class="line">    System.out.print((char) headerBuffer.get());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">bodyBuffer.flip();</span><br><span class="line">while (bodyBuffer.hasRemaining()) &#123;</span><br><span class="line">    System.out.print((char) bodyBuffer.get());</span><br><span class="line">&#125;</span><br><span class="line">// Gather：聚集数据从多个缓冲区写入到Channel</span><br><span class="line">ByteBuffer headerResponse = ByteBuffer.wrap(&quot;Header Response&quot;.getBytes());</span><br><span class="line">ByteBuffer bodyResponse = ByteBuffer.wrap(&quot;Body Response&quot;.getBytes());</span><br><span class="line">ByteBuffer[] responseBuffers = &#123;headerResponse, bodyResponse&#125;;</span><br><span class="line">long bytesWritten = socketChannel.write(responseBuffers);</span><br><span class="line">// 关闭连接</span><br><span class="line">socketChannel.close();</span><br><span class="line">serverSocketChannel.close();</span><br></pre></td></tr></table></figure>
<p>再来看 Client：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个SocketChannel</span><br><span class="line">SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">socketChannel.connect(new InetSocketAddress(&quot;localhost&quot;, 9000));</span><br><span class="line">// 发送数据到服务器</span><br><span class="line">String header = &quot;Header Content&quot;;</span><br><span class="line">String body = &quot;Body Content&quot;;</span><br><span class="line">ByteBuffer headerBuffer = ByteBuffer.wrap(header.getBytes());</span><br><span class="line">ByteBuffer bodyBuffer = ByteBuffer.wrap(body.getBytes());</span><br><span class="line">ByteBuffer[] buffers = &#123;headerBuffer, bodyBuffer&#125;;</span><br><span class="line">socketChannel.write(buffers);</span><br><span class="line">// 从服务器接收数据</span><br><span class="line">ByteBuffer headerResponseBuffer = ByteBuffer.allocate(128);</span><br><span class="line">ByteBuffer bodyResponseBuffer = ByteBuffer.allocate(1024);</span><br><span class="line">ByteBuffer[] responseBuffers = &#123;headerResponseBuffer, bodyResponseBuffer&#125;;</span><br><span class="line">long bytesRead = socketChannel.read(responseBuffers);</span><br><span class="line">// 输出接收到的数据</span><br><span class="line">headerResponseBuffer.flip();</span><br><span class="line">while (headerResponseBuffer.hasRemaining()) &#123;</span><br><span class="line">    System.out.print((char) headerResponseBuffer.get());</span><br><span class="line">&#125;</span><br><span class="line">bodyResponseBuffer.flip();</span><br><span class="line">while (bodyResponseBuffer.hasRemaining()) &#123;</span><br><span class="line">    System.out.print((char) bodyResponseBuffer.get());</span><br><span class="line">&#125;</span><br><span class="line">// 关闭连接</span><br><span class="line">socketChannel.close();</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们使用了 Scattering 从 SocketChannel 分散读取数据到多个缓冲区，并使用 Gathering 将数据从多个缓冲区聚集写入到 SocketChannel。通过这种方式，我们可以方便地处理多个缓冲区中的数据。</p>
<p><strong>异步套接字通道 AsynchronousSocketChannel 和 AsynchronousServerSocketChannel</strong></p>
<p>AsynchronousSocketChannel 和 AsynchronousServerSocketChannel 是 Java 7 引入的异步 I/O 类，分别用于处理异步客户端 Socket 和服务器端 ServerSocket。异步 I/O 允许在 I/O 操作进行时执行其他任务，并在操作完成时接收通知，提高了并发处理能力。</p>
<p>来看一个简单的示例，先看服务器端。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class AsynchronousServer &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException, InterruptedException </span><br><span class="line">&#123;</span><br><span class="line">        AsynchronousServerSocketChannel server = AsynchronousServerSocketChannel.open();</span><br><span class="line">        server.bind(new InetSocketAddress(&quot;localhost&quot;, 5000));</span><br><span class="line">        System.out.println(&quot;服务器端启动&quot;);</span><br><span class="line">        server.accept(null, new CompletionHandler&lt;AsynchronousSocketChannel, Void&gt;() </span><br><span class="line">&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void completed(AsynchronousSocketChannel client, Void attachment) </span><br><span class="line">&#123;</span><br><span class="line">                // 接收下一个连接请求</span><br><span class="line">                server.accept(null, this);</span><br><span class="line">                ByteBuffer buffer = ByteBuffer.allocate(1024);</span><br><span class="line">                Future&lt;Integer&gt; readResult = client.read(buffer);</span><br><span class="line">                try &#123;</span><br><span class="line">                    readResult.get();</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    String message = new String(buffer.array(), 0, buffer.remaining());</span><br><span class="line">                    System.out.println(&quot;接收到的消息: &quot; + message);</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            @Override</span><br><span class="line">            public void failed(Throwable exc, Void attachment) &#123;</span><br><span class="line">                exc.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        // 为了让服务器继续运行，我们需要阻止 main 线程退出</span><br><span class="line">        Thread.currentThread().join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码结构和之前讲到的异步文件通道 AsynchronousFileChannel 比较相似，异步服务单套接字通道 AsynchronousServerSocketChannel 接收客户端连接，每当收到一个新的连接时，会调用 completed() 方法，然后读取客户端发送的数据并将其打印到控制台。</p>
<p>来简单分析一下吧。</p>
<p>①、创建了一个 AsynchronousServerSocketChannel 实例并将其打开。这个通道将用于监听客户端连接。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AsynchronousServerSocketChannel server = AsynchronousServerSocketChannel.open();</span><br></pre></td></tr></table></figure>
<p>②、调用 accept() 方法来接收客户端连接。这个方法需要一个 CompletionHandler 实例，当客户端连接成功时， completed() 方法会被调用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server.accept(null, new CompletionHandler&lt;AsynchronousSocketChannel, Void&gt;() &#123; ... </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>③、实现 CompletionHandler，I/O 操作成功时，会调用 completed() 方法；当 I/O 操作失败时，会调用 failed() 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new CompletionHandler&lt;AsynchronousSocketChannel, Void&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void completed(AsynchronousSocketChannel client, Void attachment) &#123; ... &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void failed(Throwable exc, Void attachment) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 completed 方法中，我们首先调用 server.accept() 来接收下一个连接请求。然后，我们创建一个缓冲区 ByteBuffer 并使用 client.read() 从客户端读取数据。在这个示例中，我们使用了一个 Future 对象来等待读取操作完成。当读取完成时，我们将缓冲区的内容打印到控制台。           </p>
<p>④、为了让服务器继续运行并接收客户端连接，我们需要阻止 main 线程退出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.currentThread().join();</span><br></pre></td></tr></table></figure>
<p>再来看客户端的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class AsynchronousClient &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            AsynchronousSocketChannel client = AsynchronousSocketChannel.open();</span><br><span class="line">            Future&lt;Void&gt; connectResult = client.connect(new </span><br><span class="line">InetSocketAddress(&quot;localhost&quot;, 5000));</span><br><span class="line">            connectResult.get(); // 等待连接完成</span><br><span class="line">            String message = &quot;沉默王二，在吗？&quot;;</span><br><span class="line">            ByteBuffer buffer = </span><br><span class="line">ByteBuffer.wrap(message.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">            Future&lt;Integer&gt; writeResult = client.write(buffer);</span><br><span class="line">            writeResult.get(); // 等待发送完成</span><br><span class="line">            System.out.println(&quot;消息发送完毕&quot;);</span><br><span class="line">            client.close();</span><br><span class="line">        &#125; catch (IOException | InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是简单的连接和写入数据，就不多做解释了。这里先运行一下 Server 端，然后再运行一下客户端，看一下结果。</p>
<p><img src="\assets\note\image-20231012215719411.png" alt="image-20231012215719411"></p>
<p><strong>简单的聊天室 </strong></p>
<p>我们来通过 SocketChannel 和 ServerSocketChannel 实现一个 0.1 版的聊天室，先说一下需求，比较简单，服务端启动监听客户端请求，当客户端向服务器端发送信息后，服务器端接收到后把客户端消息回显给客户端，比较呆瓜，但可以先来看一下。</p>
<p><img src="\assets\note\image-20231012215746839.png" alt="image-20231012215746839"></p>
<p>我们来看服务器端代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public class ChatServer &#123;</span><br><span class="line">    private Selector selector;</span><br><span class="line">    private ServerSocketChannel serverSocketChannel;</span><br><span class="line">    private static final int PORT = 8080;</span><br><span class="line">    public ChatServer() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">            serverSocketChannel.socket().bind(new InetSocketAddress(PORT));</span><br><span class="line">            serverSocketChannel.configureBlocking(false);</span><br><span class="line">            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            System.out.println(&quot;聊天室服务端启动了 &quot; + PORT);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void start() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                if (selector.select() &gt; 0) &#123;</span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">                    while (iterator.hasNext()) &#123;</span><br><span class="line">                        SelectionKey key = iterator.next();</span><br><span class="line">                        iterator.remove();</span><br><span class="line">                        handleKey(key);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private void handleKey(SelectionKey key) throws IOException &#123;</span><br><span class="line">        if (key.isAcceptable()) &#123;</span><br><span class="line">            SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">            socketChannel.configureBlocking(false);</span><br><span class="line">            socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">            System.out.println(&quot;客户端连接上了: &quot; + socketChannel.getRemoteAddress());</span><br><span class="line">        &#125; else if (key.isReadable()) &#123;</span><br><span class="line">            SocketChannel socketChannel = (SocketChannel) key.channel();</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(1024);</span><br><span class="line">            int read = socketChannel.read(buffer);</span><br><span class="line">            if (read &gt; 0) &#123;</span><br><span class="line">                buffer.flip();</span><br><span class="line">                String msg = new String(buffer.array(), 0, read);</span><br><span class="line">                System.out.println(&quot;客户端说: &quot; + msg);</span><br><span class="line">                socketChannel.write(ByteBuffer.wrap((&quot;服务端回复: &quot; + msg).getBytes()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new ChatServer().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释一下代码逻辑：</p>
<p>1、创建一个 ServerSocketChannel，并将其绑定到指定端口。</p>
<p>2、将 ServerSocketChannel 设置为非阻塞模式。</p>
<p>3、创建一个 Selector，并将 ServerSocketChannel 注册到它上面，监听 OP_ACCEPT 事件（等待客户端连接）。</p>
<p>4、无限循环，等待感兴趣的事件发生。</p>
<p>5、使用 Selector.select() 方法，等待已注册的通道中有事件发生。</p>
<p>6、获取到发生事件的通道的 SelectionKey。</p>
<p>7、判断 SelectionKey 的事件类型：</p>
<ul>
<li>a. 如果是 OP_ACCEPT 事件，说明有新的客户端连接进来。接受新的连接，并将新连接的 SocketChannel 注册到 Selector 上，监听 OP_READ 事件。</li>
<li>b. 如果是 OP_READ 事件，说明客户端发送了消息。读取客户端发送的消息，并将其返回给客户端。 处理完毕后，清除已处理的 SelectionKey。</li>
</ul>
<p>再来看一下客户端的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">public class ChatClient &#123;</span><br><span class="line">    private Selector selector;</span><br><span class="line">    private SocketChannel socketChannel;</span><br><span class="line">    private static final String HOST = &quot;localhost&quot;;</span><br><span class="line">    private static final int PORT = 8080;</span><br><span class="line">    public ChatClient() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            socketChannel = SocketChannel.open(new InetSocketAddress(HOST, PORT));</span><br><span class="line">            socketChannel.configureBlocking(false);</span><br><span class="line">            socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">            System.out.println(&quot;连接到聊天室了&quot;);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void start() &#123;</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                while (true) &#123;</span><br><span class="line">                    if (selector.select() &gt; 0) &#123;</span><br><span class="line">                        for (SelectionKey key : selector.selectedKeys()) &#123;</span><br><span class="line">                            selector.selectedKeys().remove(key);</span><br><span class="line">                            if (key.isReadable()) &#123;</span><br><span class="line">                                readMessage();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        try (BufferedReader reader = new BufferedReader(new InputStreamReader(System.in))) &#123;</span><br><span class="line">            String input;</span><br><span class="line">            while ((input = reader.readLine()) != null) &#123;</span><br><span class="line">                sendMessage(input);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private void sendMessage(String message) throws IOException &#123;</span><br><span class="line">        if (message != null &amp;&amp; !message.trim().isEmpty()) &#123;</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.wrap(message.getBytes());</span><br><span class="line">            socketChannel.write(buffer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private void readMessage() throws IOException &#123;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(1024);</span><br><span class="line">        int read = socketChannel.read(buffer);</span><br><span class="line">        if (read &gt; 0) &#123;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            String msg = new String(buffer.array(), 0, read);</span><br><span class="line">            System.out.println(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new ChatClient().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释一下代码逻辑：</p>
<p>1、创建一个 SocketChannel，并连接到指定的服务器地址和端口。</p>
<p>2、将 SocketChannel 设置为非阻塞模式。</p>
<p>3、创建一个 Selector，并将 SocketChannel 注册到它上面，监听 OP_READ 事件（等待接收服务器的消息）。</p>
<p>4、启动一个新线程用于读取用户在控制台输入的消息，并发送给服务器。</p>
<p>5、无限循环，等待感兴趣的事件发生。</p>
<p>6、使用 Selector.select() 方法，等待已注册的通道中有事件发生。</p>
<p>7、获取到发生事件的通道的 SelectionKey。</p>
<p>8、判断 SelectionKey 的事件类型：</p>
<ul>
<li>a. 如果是 OP_READ 事件，说明服务器发送了消息。读取服务器发送的消息，并在控制台显示。 处理完毕后，清除已处理的 SelectionKey。</li>
</ul>
<p>来看运行后的效果。</p>
<p><img src="\assets\note\image-20231012220110996.png" alt="image-20231012220110996"></p>
<p>好，接下来，我们来升级一下需求，也就是 0.2 版聊天室，要求服务器端也能从控制台敲入信息主动发送给客户端。</p>
<p><img src="\assets\note\image-20231012220139117.png" alt="image-20231012220139117"></p>
<p>来看服务器端代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">public class Chat2Server &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        // 创建一个 ServerSocketChannel</span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        serverSocketChannel.configureBlocking(false);</span><br><span class="line">        serverSocketChannel.bind(new InetSocketAddress(8080));</span><br><span class="line">        // 创建一个 Selector</span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        System.out.println(&quot;聊天室服务端启动了&quot;);</span><br><span class="line">        // 客户端连接</span><br><span class="line">        AtomicReference&lt;SocketChannel&gt; clientRef = new AtomicReference&lt;&gt;();</span><br><span class="line">        // 从控制台读取输入并发送给客户端</span><br><span class="line">        Thread sendMessageThread = new Thread(() -&gt; &#123;</span><br><span class="line">            try (BufferedReader reader = new BufferedReader(new InputStreamReader(System.in))) &#123;</span><br><span class="line">                while (true) &#123;</span><br><span class="line">                    System.out.println(&quot;输入服务器端消息: &quot;);</span><br><span class="line">                    String message = reader.readLine();</span><br><span class="line">                    SocketChannel client = clientRef.get();</span><br><span class="line">                    if (client != null &amp;&amp; client.isConnected()) &#123;</span><br><span class="line">                        ByteBuffer buffer = ByteBuffer.wrap((message + &quot;\n&quot;).getBytes());</span><br><span class="line">                        client.write(buffer);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        sendMessageThread.start();</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            int readyChannels = selector.select();</span><br><span class="line">            if (readyChannels == 0) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();</span><br><span class="line">            while (keyIterator.hasNext()) &#123;</span><br><span class="line">                SelectionKey key = keyIterator.next();</span><br><span class="line">                if (key.isAcceptable()) &#123;</span><br><span class="line">                    // 接受客户端连接</span><br><span class="line">                    SocketChannel client = serverSocketChannel.accept();</span><br><span class="line">                    System.out.println(&quot;客户端已连接&quot;);</span><br><span class="line">                    client.configureBlocking(false);</span><br><span class="line">                    client.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                    clientRef.set(client);</span><br><span class="line">                &#125; else if (key.isReadable()) &#123;</span><br><span class="line">                    // 读取客户端消息</span><br><span class="line">                    SocketChannel channel = (SocketChannel) key.channel();</span><br><span class="line">                    ByteBuffer buffer = ByteBuffer.allocate(1024);</span><br><span class="line">                    int bytesRead = channel.read(buffer);</span><br><span class="line">                    if (bytesRead &gt; 0) &#123;</span><br><span class="line">                        buffer.flip();</span><br><span class="line">                        byte[] bytes = new byte[buffer.remaining()];</span><br><span class="line">                        buffer.get(bytes);</span><br><span class="line">                        String message = new String(bytes).trim();</span><br><span class="line">                        System.out.println(&quot;客户端消息: &quot; + message);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                keyIterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来看客户端代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public class Chat2Client &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        // 创建一个 SocketChannel</span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">        socketChannel.configureBlocking(false);</span><br><span class="line">        socketChannel.connect(new InetSocketAddress(&quot;localhost&quot;, 8080));</span><br><span class="line">        // 创建一个 Selector</span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_CONNECT);</span><br><span class="line">        // 从控制台读取输入并发送给服务器端</span><br><span class="line">        Thread sendMessageThread = new Thread(() -&gt; &#123;</span><br><span class="line">            try (BufferedReader reader = new BufferedReader(new InputStreamReader(System.in))) &#123;</span><br><span class="line">                while (true) &#123;</span><br><span class="line">                    System.out.println(&quot;输入客户端消息: &quot;);</span><br><span class="line">                    String message = reader.readLine();</span><br><span class="line">                    if (socketChannel.isConnected()) &#123;</span><br><span class="line">                        ByteBuffer buffer = ByteBuffer.wrap((message + &quot;\n&quot;).getBytes());</span><br><span class="line">                        socketChannel.write(buffer);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        sendMessageThread.start();</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            int readyChannels = selector.select();</span><br><span class="line">            if (readyChannels == 0) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();</span><br><span class="line">            while (keyIterator.hasNext()) &#123;</span><br><span class="line">                SelectionKey key = keyIterator.next();</span><br><span class="line">                if (key.isConnectable()) &#123;</span><br><span class="line">                    // 连接到服务器</span><br><span class="line">                    socketChannel.finishConnect();</span><br><span class="line">                    socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                    System.out.println(&quot;已连接到服务器&quot;);</span><br><span class="line">                &#125; else if (key.isReadable()) &#123;</span><br><span class="line">                    // 读取服务器端消息</span><br><span class="line">                    ByteBuffer buffer = ByteBuffer.allocate(1024);</span><br><span class="line">                    int bytesRead = socketChannel.read(buffer);</span><br><span class="line">                    if (bytesRead &gt; 0) &#123;</span><br><span class="line">                        buffer.flip();</span><br><span class="line">                        byte[] bytes = new byte[buffer.remaining()];</span><br><span class="line">                        buffer.get(bytes);</span><br><span class="line">                        String message = new String(bytes).trim();</span><br><span class="line">                        System.out.println(&quot;服务器端消息: &quot; + message);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                keyIterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行 Server，再运行 Client，交互信息如下：</p>
<p><img src="\assets\note\image-20231012220341934.png" alt="image-20231012220341934"></p>
<p>我们使用了 Selector 和非阻塞 I/O，这使得服务器可以同时处理多个连接。所以我们在 Intellij IDEA 中可以再配置一个客户端，见下图（填上这四项内容）。</p>
<p><img src="\assets\note\image-20231012220410559.png" alt="image-20231012220410559"></p>
<p>然后启动，就可以完成一个 Server 和多个 Client 交互了。</p>
<p><img src="\assets\note\image-20231012220436009.png" alt="image-20231012220436009"></p>
<p>OK，关于聊天室，我们就先讲到这里。</p>
<p><strong>小结 </strong></p>
<p>前面我们了解到，Java NIO 在文件 IO 上的性能其实和传统 IO 差不多，甚至在处理大文件的时候还有些甘拜下风，但 NIO 的主要作用体现在网络 IO 上，像 Netty 框架底层其实就是 NIO，我们来做一下简单的总结吧。</p>
<p>SocketChannel（用于 TCP 连接）和 ServerSocketChannel（用于监听和接受新的 TCP 连接）可以用来替代传统的 Socket 和 ServerSocket 类，提供非阻塞模式。</p>
<p>NIO 支持阻塞和非阻塞模式。非阻塞模式允许程序在等待 I/O 时执行其他任务，从而提高并发性能。非阻塞模式的实现依赖于 Selector，它可以监控多个通道上的 I/O 事件。</p>
<p>NIO 支持将数据分散到多个 Buffer（Scatter）或从多个 Buffer 收集数据（Gather），提供了更高效的数据传输方式。</p>
<p>Java NIO.2 引入了 AsynchronousSocketChannel 和 AsynchronousServerSocketChannel，这些类提供了基于回调的异步 I/O 操作。异步套接字通道可以在完成 I/O 操作时自动触发回调函数，从而实现高效的异步处理。</p>
<p>最后，我们使用 NIO 实现了简单的聊天室功能。通过 ServerSocketChannel 和 SocketChannel 创建服务端和客户端，实现互相发送和接收消息。在处理多个客户端时，可以使用 Selector 来管理多个客户端连接，提高并发性能。</p>
<p>总之，Java NIO 网络编程实践提供了更高效、灵活且可扩展的 I/O 处理方式，对于大型应用程序和高并发场景具有显著优势。</p>
<h2 id="10-6-Java-IO模型"><a href="#10-6-Java-IO模型" class="headerlink" title="10.6 Java IO模型"></a>10.6 Java IO模型</h2><p>Java 的 IO 分为两大类，一类是传统的 IO（Blocking IO），一类是 NIO （New IO）。</p>
<p>传统的 IO 基于字节流和字符流，以阻塞式 IO 操作为主。常用的类有 FileInputStream、FileOutputStream、InputStreamReader、OutputStreamWriter 等。这些类在读写数据时，会导致执行线程阻塞，直到操作完成。</p>
<p>Java NIO 是 Java 1.4 版本引入的，基于通道（Channel）和缓冲区（Buffer）进行操作，采用非阻塞式 IO 操作，允许线程在等待 IO 时执行其他任务。常见的 NIO 类有 ByteBuffer、FileChannel、SocketChannel、ServerSocketChannel 等。</p>
<p><strong>阻塞 IO 和非阻塞 IO </strong></p>
<p>那什么是阻塞式 IO，什么是非阻塞 IO 呢？</p>
<p>阻塞 I/O（Blocking I/O）：在这种模型中，I/O 操作是阻塞的，即执行 I/O 操作时，线程会被阻塞，直到操作完成。在阻塞 I/O 模型中，每个连接都需要一个线程来处理。因此，对于大量并发连接的场景，阻塞 I/O 模型的性能较差。</p>
<p><img src="\assets\note\image-20231012220627604.png" alt="image-20231012220627604"></p>
<p>非阻塞 I/O（Non-blocking I/O）：在这种模型中，I/O 操作不会阻塞线程。当数据尚未准备好时，I/O 调用会立即返回。线程可以继续执行其他任务，然后在适当的时候再次尝试执行 I/O 操作。非阻塞 I/O 模型允许单个线程同时处理多个连接，但可能需要在应用程序级别进行复杂的调度和管理。</p>
<p><img src="\assets\note\image-20231012220703833.png" alt="image-20231012220703833"></p>
<p><strong>内核空间和用户空间 </strong></p>
<p>在上面的两幅图中，涉及到了两个概念：内核空间和用户空间。我们之前在介绍非直接缓冲区的时候，有这样一副图片。</p>
<p><img src="\assets\note\image-20231012220739570.png" alt="image-20231012220739570"></p>
<p>其中的非直接缓冲区（JVM）就是在用户空间中，内核缓冲区（OS）就是在内核空间上。</p>
<p>内核空间是操作系统内核的专用内存区域，用于存储内核代码、数据结构和运行内核级别的系统调用。内核空间具有较高的权限级别，能够直接访问硬件资源和底层系统服务。一般来说，内核空间是受到严格保护的，用户级别的程序不能直接访问内核空间，以确保操作系统的稳定性和安全性。</p>
<p>用户空间是为用户级别的应用程序和服务分配的内存区域。它包含了应用程序的代码、数据和运行时堆栈。用户空间与内核空间相对隔离，具有较低的权限级别，不能直接访问内核空间或硬件资源。应用程序需要通过系统调用与内核空间进行交互，请求操作系统提供的服务。</p>
<p>内核空间和用户空间的划分有助于操作系统实现内存保护和权限控制，确保系统运行的稳定性和安全性。当用户程序需要访问系统资源或执行特权操作时，它需要通过系统调用切换到内核空间，由内核代理执行相应的操作。这种设计可以防止恶意或错误的用户程序直接访问内核空间，从而破坏系统的稳定性和安全性。同时，这种划分也提高了操作系统的可扩展性，因为内核空间和用户空间可以独立地进行扩展和优化。</p>
<p><img src="\assets\note\image-20231012220823292.png" alt="image-20231012220823292"></p>
<p><strong>多路复用、信号驱动、异步 IO </strong></p>
<p>除了前面提到的阻塞 IO 和非阻塞 IO 模型，还有另外三种 IO 模型，分别是多路复用、信号驱动和异步 IO。</p>
<p><strong>多路复用 </strong></p>
<p>I/O 多路复用（I/O Multiplexing）模型使用操作系统提供的多路复用功能（如 select、poll、epoll 等），使得单个线程可以同时处理多个 I/O 事件。当某个连接上的数据准备好时，操作系统会通知应用程序。这样，应用程序可以在一个线程中处理多个并发连接，而不需要为每个连接创建一个线程。</p>
<ul>
<li>select 是 Unix 系统中最早的 I/O 多路复用技术。它允许一个线程同时监视多个文件描述符（如套接字），并等待某个文件描述符上的 I/O 事件（如可读、可写或异常）。select 的主要问题是性能受限，特别是在处理大量文件描述符时。这是因为它使用一个位掩码来表示文件描述符集，每次调用都需要传递这个掩码，并在内核和用户空间之间进行复制。</li>
<li>poll 是对 select 的改进。它使用一个文件描述符数组而不是位掩码来表示文件描述符集。这样可以避免 select 中的性能问题。然而，poll 仍然需要遍历整个文件描述符数组，以检查每个文件描述符的状态。因此，在处理大量文件描述符时，性能仍然受限。</li>
<li>epoll 是 Linux 中的一种高性能 I/O 多路复用技术。它通过在内核中维护一个事件表来避免遍历文件描述符数组的性能问题。当某个文件描述符上的 I/O 事件发生时，内核会将该事件添加到事件表中。应用程序可以使用 epoll_wait 函数来获取已准备好的 I/O 事件，而无需遍历整个文件描述符集。这种方法大大提高了在大量并发连接下的性能。</li>
</ul>
<p><img src="\assets\note\image-20231012220933110.png" alt="image-20231012220933110"></p>
<p>在 Java NIO 中，I/O 多路复用主要通过 Selector 类实现。Selector 能够监控多个 Channel（通道）上的 I/O 事件，如连接、读取和写入。这使得一个线程可以处理多个并发连接，提高了程序的性能和可伸缩性。</p>
<p>以下是 Java NIO 中 I/O 多路复用的应用：</p>
<p>①、首先，需要创建一个 Selector 对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure>
<p>②、然后，需要将 Channel 注册到 Selector。每个 Channel 必须配置为非阻塞模式，才能与 Selector 一起使用。在注册 Channel 时，还需要指定感兴趣的 I/O 事件，如 SelectionKey.OP_ACCEPT（接受连接）、SelectionKey.OP_READ（读取数据）等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel serverChannel = ServerSocketChannel.open();</span><br><span class="line">serverChannel.configureBlocking(false);</span><br><span class="line">serverChannel.bind(new InetSocketAddress(8080));</span><br><span class="line">// 注册感兴趣的事件</span><br><span class="line">serverChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></figure>
<p>③、接下来，使用 Selector 的 select() 方法等待 I/O 事件。 select() 方法会阻塞，直到至少有一个 Channel 上的事件发生。当有事件发生时，可以通过调用 selectedKeys() 方法获取已准备好进行 I/O 操作的 Channel 的 SelectionKey 集合。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">while (true) &#123;</span><br><span class="line">    int readyChannels = selector.select();</span><br><span class="line">    if (readyChannels == 0) continue;</span><br><span class="line">    Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line">    Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();</span><br><span class="line">    while (keyIterator.hasNext()) &#123;</span><br><span class="line">        SelectionKey key = keyIterator.next();</span><br><span class="line">        if (key.isAcceptable()) &#123;</span><br><span class="line">            // 处理接受连接事件</span><br><span class="line">        &#125; else if (key.isReadable()) &#123;</span><br><span class="line">            // 处理读取数据事件</span><br><span class="line">        &#125; else if (key.isWritable()) &#123;</span><br><span class="line">            // 处理写入数据事件</span><br><span class="line">        &#125;</span><br><span class="line">        keyIterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>④、最后，根据 SelectionKey 的状态，执行相应的 I/O 操作。例如，如果 SelectionKey 表示 Channel 已准备好接受新的连接，可以调用 ServerSocketChannel 的 accept() 方法。如果 SelectionKey 表示 Channel 已准备好读取数据，可以从 SocketChannel 中读取数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (key.isAcceptable()) &#123;</span><br><span class="line">    SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">    socketChannel.configureBlocking(false);</span><br><span class="line">    socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">    System.out.println(&quot;客户端连接上了: &quot; + socketChannel.getRemoteAddress());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>信号驱动 </strong></p>
<p>信号驱动 I/O（Signal-driven I/O）模型中，应用程序可以向操作系统注册一个信号处理函数，当某个 I/O 事件发生时，操作系统会发送一个信号通知应用程序。应用程序在收到信号后处理相应的 I/O 事件。这种模型与非阻塞 I/O 类似，也需要在应用程序级别进行事件管理和调度。</p>
<p><img src="\assets\note\image-20231012221214351.png" alt="image-20231012221214351"></p>
<p>多路复用和信号驱动的差别主要在事件通知机制和引用场景上。</p>
<p>多路复用模型允许一个线程同时管理多个 I/O 连接。这是通过使用特殊的系统调用（如 select、poll 和 epoll）实现的，它们能够监视多个文件描述符上的 I/O 事件。当某个 I/O 事件发生时，这些系统调用会返回，通知应用程序执行相应的 I/O 操作。I/O 多路复用模型适用于高并发、低延迟和高吞吐量的场景，因为它能够有效地减少线程数量和上下文切换开销。</p>
<p>信号驱动模型依赖于信号（如 SIGIO）来通知应用程序 I/O 事件的发生。在这个模型中，应用程序首先设置文件描述符为信号驱动模式，并为相应的信号注册处理函数。当 I/O 事件发生时，内核会发送一个信号给应用程序，触发信号处理函数的执行。然后，应用程序可以在信号处理函数中执行相应的 I/O 操作。I/O 信号驱动模型适用于低并发、低延迟和低吞吐量的场景，因为它需要为每个 I/O 事件创建一个信号和信号处理函数。</p>
<p>Linux 的内核将所有外部设备都看做一个文件来操作，对一个文件的读写操作会调用内核提供的系统命令(api)，返回一个 file descriptor（fd，文件描述符）。而对一个Socket的读写也会有响应的描述符，称为 socket fd（Socket文件描述符），描述符就是一个数字，指向内核中的一个结构体（文件路径，数据区等一些属性）。</p>
<p>在Linux下对文件的操作是利用文件描述符(file descriptor)来实现的。</p>
<p><strong>异步 IO </strong></p>
<p>异步 I/O（Asynchronous I/O）模型与同步 I/O 模型的主要区别在于，异步 I/O 操作会在后台运行，当操作完成时，操作系统会通知应用程序。应用程序不需要等待 I/O 操作的完成，可以继续执行其他任务。这种模型适用于处理大量并发连接，且可以简化应用程序的设计和开发。</p>
<ul>
<li>同步：在执行 I/O 操作时，应用程序需要等待操作的完成。同步操作会导致线程阻塞，直到操作完成。同步 I/O 包括阻塞 I/O、非阻塞 I/O 和 I/O 多路复用。</li>
<li>异步：在执行 I/O 操作时，应用程序不需要等待操作的完成。异步操作允许应用程序在 I/O 操作进行时继续执行其他任务。异步 I/O 模型包括信号驱动 I/O 和异步 I/O。</li>
</ul>
<p><img src="\assets\note\image-20231012221405632.png" alt="image-20231012221405632"></p>
<p>假设你现在是个大厨（炖个老母鸡汤，切点土豆丝/姜丝/葱丝）：</p>
<ul>
<li>同步/阻塞：你站在锅边，一直等到汤炖好，期间不能做其他事情，直到汤炖好才去处理其他任务。</li>
<li>同步/非阻塞：你不断地查看锅里的汤，看是否炖好。在检查的间隙，你可以处理其他任务，如切菜。但你需要不断地切换任务，确保汤炖好了就可以处理。</li>
<li>异步/信号驱动：你给锅安装一个传感器，当汤炖好时，传感器会发出信号提醒你。在此期间，你可以处理其他任务，而不用担心错过汤炖好的时机。</li>
<li>异步 I/O：你请了一个助手，让他负责炖汤。当汤炖好时，助手会通知你。你可以专心处理其他任务，而无需关心炖汤的过程。</li>
</ul>
<p><strong>小结 </strong></p>
<p>简单总结一下，IO 模型主要有五种：阻塞 I/O、非阻塞 I/O、多路复用、信号驱动和异步 I/O。</p>
<ul>
<li>阻塞 I/O：应用程序执行 I/O 操作时，会一直等待数据传输完成，期间无法执行其他任务。</li>
<li>非阻塞 I/O：应用程序执行 I/O 操作时，如果数据未准备好，立即返回错误状态，不等待数据传输完成，可执行其他任务。</li>
<li>多路复用：允许一个线程同时管理多个 I/O 连接，适用于高并发、低延迟和高吞吐量场景，减少线程数量和上下文切换开销。</li>
<li>信号驱动：依赖信号通知应用程序 I/O 事件，适用于低并发、低延迟和低吞吐量场景，需要为每个 I/O 事件创建信号和信号处理函数。</li>
<li>异步 I/O：应用程序发起 I/O 操作后，内核负责数据传输过程，完成后通知应用程序。应用程序无需等待数据传输，可执行其他任务。</li>
</ul>
<h1 id="11-Java-重要知识点"><a href="#11-Java-重要知识点" class="headerlink" title="11 Java 重要知识点"></a>11 Java 重要知识点</h1><h2 id="11-1-Java命名规范"><a href="#11-1-Java命名规范" class="headerlink" title="11.1 Java命名规范"></a>11.1 Java命名规范</h2><p>“二哥，Java 中的命名约定都有哪些呢？”三妹的脸上泛着甜甜的笑容，她开始对接下来要学习的内容充满期待了，这正是我感到欣慰的地方。</p>
<p>“对于我们中国人来说，名字也是有讲究的，比如说我叫沉默王二，你就叫沉默王三，哈哈。”我笑着对三妹说。</p>
<p>命名约定决定我们使用什么样的标识符来命名包、类、字段、方法等等，虽然这个规则不是强制的，可以遵守，也可以不遵守，但如果不遵守的话，就会带来很多不必要的麻烦。</p>
<p>起个好的名字，就好像穿一件得体的衣服，呈现给人的用户体验是完全不一样的。 </p>
<p>好的命名可以让你的代码更易读，包括你自己和你的小伙伴，看一眼，不用想太多，就能明白代码是干嘛的。</p>
<p>拿我这个笔名“沉默王二”来举例吧，读起来我就觉得朗朗上口，读者看到这个笔名就知道我是一个什么样的人——对不熟的人保持沉默，对熟的人妙语连珠，哈哈。</p>
<blockquote>
<p>当然了，如果你暂时记不住也没关系，后面再回头来记一下就好了。</p>
</blockquote>
<p><strong>01、包（package） </strong></p>
<p>包的命名应该遵守以下规则：</p>
<ul>
<li>应该全部是小写字母</li>
<li>点分隔符之间有且仅有一个自然语义的英语单词</li>
<li>包名统一使用单数形式，比如说 com.itwanger.util 不能是 com.itwanger.utils</li>
<li>在最新的 Java 编程规范中，要求开发人员在自己定义的包名前加上唯一的前缀。由于互联网上的域名是不会重复的，所以多数开发人员采用自己公司（或者个人博客）在互联网上的域名称作为包的唯一前缀。比如我文章中出现的代码示例的包名就是 package com.itwanger 。</li>
</ul>
<p><strong>02、类（class） </strong></p>
<p>类的命名应该遵守以下规则：</p>
<ul>
<li>必须以大写字母开头</li>
<li>最好是一个名词，比如说 System</li>
<li>类名使用 UpperCamelCase（驼峰式命名）风格</li>
<li>尽量不要省略成单词的首字母，但以下情形例外：DO/BO/DTO/VO/AO/PO/UID 等</li>
</ul>
<p><img src="\assets\note\image-20231012222200775.png" alt="image-20231012222200775"></p>
<p>另外，如果是抽象类的话，使用 Abstract 或 Base 开头；如果是异常类的话，使用 Exception 结尾；如果是测试类的话，使用 Test 结尾。</p>
<p><strong>03、接口（interface） </strong></p>
<p>接口的命名应该遵守以下规则：</p>
<ul>
<li>必须以大写字母开头</li>
<li>最好是一个形容词，比如说 Runnable</li>
<li>尽量不要省略成单词的首字母</li>
</ul>
<p>来看个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interface Printable &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>接口和实现类之间也有一些规则：</p>
<ul>
<li>实现类用 Impl 的后缀与接口区别，比如说 CacheServiceImpl 实现 CacheService 接口</li>
<li>或者，AbstractTranslator 实现 Translatable 接口</li>
</ul>
<p><strong>04、字段（field）和变量（variable） </strong></p>
<p>字段和变量的命名应该遵守以下规则：</p>
<ul>
<li>必须以小写字母开头</li>
<li>可以包含多个单词，第一个单词的首字母小写，其他的单词首字母大写，比如说 firstName</li>
<li>最好不要使用单个字符，比如说 int a ，除非是局部变量</li>
<li>类型与中括号紧挨相连来表示数组，比如说 int[] arrayDemo ，main 方法中字符串数组参数不应该写成 String args[]</li>
<li>POJO 类中的任何布尔类型的变量，都不要加 is 前缀，否则部分框架解析会引起序列化错误，我自己知道的有 fastjson</li>
<li>避免在子类和父类的成员变量之间、或者不同代码块的局部变量之间采用完全相同的命名，使可理解性降低。子类、父类成员变量名相同，即使是 public 类型的变量也能够通过编译，另外，局部变量在同一方法内的不同代码块中同名也是合法的，这些情况都要避免。</li>
</ul>
<p>反例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class ConfusingName &#123;</span><br><span class="line">    public int stock;</span><br><span class="line">    // 非 setter/getter 的参数名称，不允许与本类成员变量同名</span><br><span class="line">    public void get(String alibaba) &#123;</span><br><span class="line">        if (condition) &#123;</span><br><span class="line">            final int money = 666;</span><br><span class="line">// ...</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">// 在同一方法体中，不允许与其它代码块中的 money 命名相同 final int money = 15978;</span><br><span class="line">// ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Son extends ConfusingName &#123;</span><br><span class="line">// 不允许与父类的成员变量名称相同 public int stock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>05、常量（constant） </strong></p>
<p>常量的命名应该遵守以下规则：</p>
<ul>
<li>应该全部是大写字母</li>
<li>可以包含多个单词，单词之间使用“_”连接，比如说 MAX_PRIORITY ，力求语义表达完整清楚，不要嫌名字长</li>
<li>可以包含数字，但不能以数字开头</li>
</ul>
<p>来看个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static final int MIN_AGE = 18; </span><br></pre></td></tr></table></figure>
<p><strong>06、方法（method） </strong></p>
<p>方法的命名应该遵守以下规则：</p>
<ul>
<li>必须以小写字母开头</li>
<li>最好是一个动词，比如说 print()</li>
<li>可以包含多个单词，第一个单词的首字母小写，其他的单词首字母大写，比如说 actionPerformed()</li>
</ul>
<p>来看个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void writeBook()&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>Service/DAO 层的方法命名规约：</p>
<ul>
<li>获取单个对象的方法用 get 做前缀</li>
<li>获取多个对象的方法用 list 做前缀，复数结尾，如：listObjects</li>
<li>获取统计值的方法用 count 做前缀</li>
<li>插入的方法用 save/insert 做前缀</li>
<li>删除的方法用 remove/delete 做前缀</li>
<li>修改的方法用 update 做前缀</li>
</ul>
<p><strong>07、总结 </strong></p>
<p>除了以上这些规则以外，还有一些共同的规则需要遵守，比如说：</p>
<ul>
<li>代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。反例： _name / __name / $name / name<em> / name$ / name_</em></li>
<li>所有编程相关的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。反例：DaZhePromotion [打折] / getPingfenByName() [评分] / String fw[福娃] / int 某变量 = 3</li>
<li>代码和注释中都要避免使用任何语言的种族歧视性词语。反例： RIBENGUIZI / Asan / blackList / whiteList / slave</li>
<li>方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格。</li>
<li>杜绝完全不规范的缩写，避免望文不知义。反例：AbstractClass “缩写”成 AbsClass；condition “缩写”成 condi；Function 缩写”成 Fu，此类随意缩写严重降低了代码的可阅读性。</li>
<li>为了达到代码自解释的目标，任何自定义编程元素在命名时，使用尽量完整的单词组合来表达。</li>
<li>在常量与变量的命名时，表示类型的名词放在词尾，以提升辨识度。正例： startTime / workQueue / nameList / TERMINATED_THREAD_COUNT</li>
<li>如果模块、接口、类、方法使用了设计模式，在命名时需体现出具体模式。 将设计模式体现在名中，有利于阅读者快速理解架构设计理念。比如说： public class OrderFactory;public class LoginProxy;public class ResourceObserver;</li>
<li>枚举类名带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。枚举其实就是特殊的常量类，且构造方法被默认强制是私有。比如说：枚举名字为 ProcessStatusEnum 的成员名称：SUCCESS / UNKNOWN_REASON 。</li>
</ul>
<h2 id="11-2-中文乱码及字符编码全攻略"><a href="#11-2-中文乱码及字符编码全攻略" class="headerlink" title="11.2 中文乱码及字符编码全攻略"></a>11.2 中文乱码及字符编码全攻略</h2><p>就在昨天，我在二哥的编程星球里看到这样一张截图，有球友反馈说支付宝的理财页面出现了中文乱码，估计不少小伙伴和我一样，都惊呆了 ！阿里这种大厂还能出现这种低级错误？</p>
<p><img src="\assets\note\image-20231013093346340.png" alt="image-20231013093346340"></p>
<p>难道昨天的人力都投入到“通义千问”的突然发布上了？</p>
<p>那借这个机会，我就来和大家探讨一下，中文乱码是怎么出现的，以及如何快速解决乱码问题。</p>
<p><strong>什么是中文乱码 </strong></p>
<p>Q：什么是中文乱码？</p>
<p>GPT4：中文乱码是指在计算机系统或软件中，由于字符编码不一致或处理不当，导致中文字符无法正常显示，出现乱码现象。这种现象通常表现为中文字符被替换成其他不相关的字符、符号或乱码。</p>
<p>比如说，历史上著名的“锟斤拷”同学，就是中文乱码的绝佳代言人。</p>
<p><img src="\assets\note\image-20231013093438726.png" alt="image-20231013093438726"></p>
<p><strong>什么是字符编码 </strong></p>
<p>Q：那什么是字符编码呢？</p>
<p>GPT4：字符编码（Character Encoding）是一种规则或约定，它将字符（如字母、数字、标点符号等）映射到计算机中的二进制数据。简单来说，字符编码就是将人类可读的字符转换为计算机可以处理的二进制数据的过程。</p>
<p>对于计算机来说，只认 0 和 1，所有的信息最终都是一个二进制数。一个二进制数要么是 0，要么是 1。8 个二进制数放在一起是一个字节，就会组合出 256 种状态，也就是 2 的 8 次方（ 2^8 ），从 00000000 到 11111111。</p>
<p>为了让计算机能够识别和处理各种字符，需要使用字符编码来对字符进行编码和解码。常见的字符编码包括 ASCII、UTF-8、UTF-16、GBK、GB2312 等。</p>
<p><img src="\assets\note\image-20231013093522740.png" alt="image-20231013093522740"></p>
<p><strong>1）ASCII </strong></p>
<p>ASCII 码由电报码发展而来，第一版标准发布于 1963 年，最后一次更新则是在 1986 年，至今为止共定义了 128 个字符。其中 33 个字符无法显示在一般的设备上，需要用特殊的设备才能显示。</p>
<p>ASCII 码的局限在于只能显示 26 个基本拉丁字母、阿拉伯数字和英式标点符号，因此只能用于显示现代美国英语，对于其他一些语言则无能无力，比如在法语中，字母上方有注音符号，它就无法用 ASCII 码表示。</p>
<p><img src="\assets\note\image-20231013093559048.png" alt="image-20231013093559048"></p>
<p>PS：拉丁字母（也称为罗马字母）是多数欧洲语言采用的字母系统，是世界上最通行的字母文字系统，是罗马文明的成果之一。</p>
<p>虽然名称上叫作拉丁字母，但拉丁文中并没有用 J、U 和 W 这三个字母。</p>
<p>在我的印象中，可能说拉丁字母多少有些陌生，说英语字母可能就有直观的印象了。</p>
<p><img src="\assets\note\image-20231013093725582.png" alt="image-20231013093725582"></p>
<p>阿拉伯数字，我们都很熟悉了。</p>
<p><img src="\assets\note\image-20231013093755955.png" alt="image-20231013093755955"></p>
<p>但是，阿拉伯数字并非起源于阿拉伯，而是起源于古印度。学过历史的你应该有一些印象，阿拉伯分布于西亚和北非，以阿拉伯语为主要语言，以伊斯兰教为主要信仰。</p>
<p><img src="\assets\note\image-20231013093823964.png" alt="image-20231013093823964"></p>
<p>处在这样的地理位置，做起东亚和欧洲的一些生意就很有优势，于是阿拉伯数字就由阿拉伯人传到了欧洲，因此得名。</p>
<p>英式标点符号，也叫英文标点符号，和中文标点符号很相近。标点符号是辅助文字记录语言的符号，是书面语的组成部分，用来表示停顿、加强语气等。</p>
<p>英文标点符号在 16 世纪时，分为朗诵学派和句法学派，主要由古典时期的希腊文和拉丁文演变而来，在 17 世纪后进入稳定阶段。俄文的标点符号依据希腊文而来，到了 18 世纪后也采用了英文标点符号。</p>
<p>在很多人的印象中，古文是没有标点符号的，但管锡华博士研究指出，中国早在先秦时代就有标点符号了，后来融合了一些英文标点符号后，逐渐形成了现在的中文标点符号。</p>
<p><img src="\assets\note\image-20231013093921594.png" alt="image-20231013093921594"></p>
<p><strong>2）Unicode </strong></p>
<p>这个世界上，除了英语，还有法语、葡萄牙语、西班牙语、德语、俄语、阿拉伯语、韩语、日语等等等等。ASCII 码用来表示英语是绰绰有余的，但其他这些语言就没办法了。</p>
<p>像我的主人二哥的母语——中文，就博大精深，与其对应的汉字数量很多很多，东汉的《说文解字》收字 9353 个，清朝《康熙字典》收字 47035 个，当代的《汉语大字典》收字 60370 个。1994 年中华书局、中国友谊出版公司出版的《中华字海》收字 85568 个。</p>
<blockquote>
<p>常用字大概 2500 个，次常用字 1000 个。</p>
</blockquote>
<p>一个字节只能表示 256 种符号，所以如果拿 ASCII 码来表示汉字的话，是远远不够用的，那就必须要用更多的字节。简体中文常见的编码方式是 GB2312，使用两个字节表示一个汉字，理论上最多可以表示 256 x 256 = 65536 个符号。</p>
<p>要知道，世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。</p>
<ul>
<li>编码就是将原始数据（比如说文本、图像、视频、音频等）转换为二进制形式。</li>
<li>解码就是将二进制数据转换为原始数据，是一个反向的过程。</li>
</ul>
<p>如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会彻底消失。</p>
<p>这个艰巨的任务由谁来完成呢？Unicode，中文译作万国码、国际码、统一码、单一码，就像它的名字都表示的，这是一种所有符号的编码。</p>
<p>Unicode 至今仍在不断增修，每个新版本都会加入更多新的字符。目前最新的版本为 2020 年 3 月公布的 13.0，收录了 13 万个字符。</p>
<p><img src="\assets\note\image-20231013094151302.png" alt="image-20231013094151302"></p>
<p>Unicode 是一个很大的集合，现在的规模可以容纳 100 多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母 Ain ， U+0041 表示英语的大写字母 A ， U+4E25 表示汉字严 。</p>
<p>具体的符号对应表，可以查询：</p>
<blockquote>
<p>unicode.org：<a target="_blank" rel="noopener" href="http://www.unicode.org">http://www.unicode.org</a></p>
<p>汉字对应表：ttp://www.chi2ko.com/tool/CJK.htm</p>
</blockquote>
<p>曾有人这样说：</p>
<blockquote>
<p>Unicode 支持的字符上限是 65536 个，Unicode 字符必须占两个字节。</p>
</blockquote>
<p>但这是一种误解，记住，Unicode 只是一个用来映射字符和数字的标准。它对支持字符的数量没有限制，也不要求字符必须占两个、三个或者其它任意数量的字节，所以它可以无穷大。</p>
<p><strong>3）UTF-8 </strong></p>
<p>Unicode 虽然统一了全世界字符的编码，但没有规定如何存储。如果统一规定的话，每个符号就要用 3 个或 4 个字节表示，因为 2 个字节只能表示 65536 个，根本表示不全。</p>
<p>那怎么办呢？</p>
<p>UTF（Unicode Transformation Formats，Unicode 的编码方式）来了！最常见的就是 UTF-8 和 UTF-16。</p>
<p>在 UTF-8 中，0-127 号的字符用 1 个字节来表示，使用和 ASCII 相同的编码。只有 128 号及以上的字符才用 2 个、3 个或者 4 个字节来表示。</p>
<p>如果只有一个字节，那么最高的比特位为 0；如果有多个字节，那么第一个字节从最高位开始，连续有几个比特位的值为 1，就使用几个字节编码，剩下的字节均以 10 开头。</p>
<p>具体的表现形式为：</p>
<ul>
<li>0xxxxxxx：一个字节；</li>
<li>110xxxxx 10xxxxxx：两个字节编码形式（开始两个 1）；</li>
<li>1110xxxx 10xxxxxx 10xxxxxx：三字节编码形式（开始三个 1）；</li>
<li>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx：四字节编码形式（开始四个 1）。</li>
</ul>
<p>也就是说，UTF-8 是一种可变长度的编码方式——这是它的优势也是劣势。</p>
<p>怎么讲呢？优势就是它包罗万象，劣势就是浪费空间。举例来说吧，UTF-8 采用了 3 个字节（ 256*256*256=16777216 ）来编码常用的汉字，但常用的汉字没有这么多，这对于计算机来说，就是一种严重的资源浪费。</p>
<p><strong>4）GB2312 </strong></p>
<p>基于这样的考虑，中国国家标准总局于 1980 年发布了 GB2312 编码，即中华人民共和国国家标准简体中文字符集。GB2312 标准共收录 6763 个汉字（2 个字节就够用了），其中一级汉字 3755 个，二级汉字 3008 个；同时收录了包括拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母在内的 682 个字符。</p>
<p>GB2312 的出现，基本满足了汉字的计算机处理需求。对于人名、古汉语等方面出现的罕用字和繁体字，GB2312 不能处理，就有了 GBK（K 为“扩展”的汉语拼音（kuòzhǎn）第一个声母）。</p>
<p><strong>中文乱码是如何出现的？ </strong></p>
<p>Q：来一串出现中文乱码的 demo，中文为沉默王二</p>
<p>GPT4：下面是一个可能导致中文乱码的示例。首先使用 GBK 编码将中文字符串 “沉默王二” 转换为字节数组，然后使用 UTF-8 编码将字节数组转回字符串。这将导致字符串在解码时出现乱码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class EncodingDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String originalStr = &quot;沉默王二&quot;;</span><br><span class="line">        String encodedStr = &quot;&quot;;</span><br><span class="line">        try &#123;</span><br><span class="line">            byte[] bytes = originalStr.getBytes(&quot;GBK&quot;);</span><br><span class="line">            encodedStr = new String(bytes, &quot;UTF-8&quot;);</span><br><span class="line">        &#125; catch (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;转码前: &quot; + originalStr);</span><br><span class="line">        System.out.println(&quot;转码后: &quot; + encodedStr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序会输出什么呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">转码前: 沉默王二</span><br><span class="line">转码后: ��Ĭ����</span><br></pre></td></tr></table></figure>
<p>嘿嘿，乱码来了！在 Unicode 中，� 是一个特殊的符号，它用来表示无法显示，它的十六进制是 0xEF 0xBF 0xBD 。那么两个 �� 就是 0xEF 0xBF 0xBD 0xEF 0xBF 0xBD ，如果用 GBK 进行解码的话，就是大名鼎鼎的“锟斤拷”。</p>
<p>可以通过代码来验证一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 输出 efbfbdefbfbd</span><br><span class="line">char[] kuijinkao = HexUtil.encodeHex(&quot;��&quot;, StandardCharsets.UTF_8);</span><br><span class="line">System.out.println(kuijinkao);</span><br><span class="line">// 借助 hutool 转成二进制</span><br><span class="line">byte[] testBytes = HexUtil.decodeHex(kuijinkao);</span><br><span class="line">// 使用 GBK 解码</span><br><span class="line">String testResult = new String(testBytes, Charset.forName(&quot;GBK&quot;));</span><br><span class="line">// 输出锟斤拷</span><br><span class="line">System.out.println(testResult);</span><br></pre></td></tr></table></figure>
<p>来看一下输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">efbfbdefbfbd</span><br><span class="line">锟斤拷</span><br></pre></td></tr></table></figure>
<p>所以，以后再见到锟斤拷，第一时间想到 UTF-8 和 GBK 的转换问题准没错。</p>
<p><strong>如何解决中文乱码呢？ </strong></p>
<p>Q：如何解决中文乱码呢？</p>
<p>GPT4：解决中文乱码问题需要确保在编码和解码过程中使用相同的字符编码。这是一个修改过的示例，展示了如何避免中文乱码问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String originalStr = &quot;沉默王二&quot;;</span><br><span class="line">byte[] bytes = originalStr.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">String encodedStr = new String(bytes, StandardCharsets.UTF_8);</span><br><span class="line">System.out.println(&quot;正确转码前: &quot; + originalStr);</span><br><span class="line">System.out.println(&quot;正确转码后: &quot; + encodedStr);</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">正确转码前: 沉默王二</span><br><span class="line">正确转码后: 沉默王二</span><br></pre></td></tr></table></figure>
<p>除此之外，以下是一些避免乱码的实践：</p>
<ul>
<li>使用统一的字符编码，如 UTF-8。它包含了所有 Unicode 字符，并且广泛支持。确保在所有平台和系统上使用相同的编码。</li>
<li>在处理文本文件时，始终明确指定字符编码。例如，在 Java 中使用 InputStreamReader、OutputStreamWriter 时，指定编码参数。</li>
<li>在 HTML、XML 等文档中，指定字符编码。例如，在 HTML 页面中添加 <meta charset="UTF-8"> 。</li>
<li>对于数据库，确保使用正确的字符集。在创建数据库和表时，明确指定字符集，如 utf8mb4。</li>
</ul>
<p>当与第三方服务通信时，确保双方使用相同的字符编码。在处理 API 请求和响应时，检查字符编码是否匹配。</p>
<p>Q：针对支付宝这种生产环境事故，如何快速定位并解决问题呢？</p>
<p>GPT4：</p>
<p>1、收集信息：了解问题的具体表现，例如哪些页面或功能受到影响，问题的严重程度，以及用户反馈。这将有助于快速定位问题范围。</p>
<p>2、检查日志：查看服务器日志和应用程序日志，检查是否存在异常信息或错误。日志信息有助于识别问题发生的时间和具体原因。</p>
<p>3、复现问题：在测试环境中尝试复现问题，以便更深入地了解问题细节。如果无法复现问题，可能需要进一步收集生产环境的详细信息。</p>
<p>4、定位问题：根据收集到的信息，确定问题可能发生的代码或系统部分。检查相关代码，特别是涉及字符编码、数据传输、数据库操作的部分。</p>
<p>5、解决问题：修复问题代码，确保字符编码在整个系统中保持一致。进行单元测试和集成测试，验证问题是否已解决。</p>
<p>6、部署修复：将修复后的代码部署到生产环境。为了避免影响正常服务，可以考虑先在一个小规模的生产环境中进行验证，然后逐步扩大部署范围。</p>
<p>7、监控：在修复后持续关注系统运行状况，确保问题已得到解决。收集用户反馈，确认用户满意度。</p>
<p>8、总结经验：针对此次问题，总结经验教训，分析问题产生的根本原因，优化开发和测试流程，避免类似问题再次发生。</p>
<h2 id="11-3-深入剖析Java中的拆箱和装箱"><a href="#11-3-深入剖析Java中的拆箱和装箱" class="headerlink" title="11.3 深入剖析Java中的拆箱和装箱"></a>11.3 深入剖析Java中的拆箱和装箱</h2><p>“哥，听说 Java 的每个基本类型都对应了一个包装类型，比如说 int 的包装类型为 Integer，double 的包装类型为 Double，是这样吗？”从三妹这句话当中，能听得出来，她已经提前预习这块内容了。</p>
<p>“是的，三妹。基本类型和包装类型的区别主要有以下 4 点，我来带你学习一下。”我回答说。我们家的斜对面刚好是一所小学，所以时不时还能听到朗朗的读书声，让人心情非常愉快。</p>
<p>“三妹，你准备好了吗？我们开始吧。”</p>
<p>“第一，<strong>包装类型可以为 null，而基本类型不可以。</strong>别小看这一点区别，它使得包装类型可以应用于 POJO 中，而基本类型则不行。”</p>
<p>“POJO 是什么呢？”遇到不会的就问，三妹在这一点上还是非常兢兢业业的。</p>
<p>“POJO 的英文全称是 Plain Ordinary Java Object，翻译一下就是，简单无规则的 Java 对象，只有字段以及对应的 setter 和 getter 方法。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Writer &#123;</span><br><span class="line">    private Integer age;</span><br><span class="line">    private String name;</span><br><span class="line">    public Integer getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setAge(Integer age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和 POJO 类似的，还有数据传输对象 DTO（Data Transfer Object，泛指用于展示层与服务层之间的数据传输对象）、视图对象 VO（View Object，把某个页面的数据封装起来）、持久化对象 PO（Persistant Object，可以看成是与数据库中的表映射的 Java 对象）。<br>“那为什么 POJO 的字段必须要用包装类型呢？”三妹问。</p>
<p>“《阿里巴巴 Java 开发手册》上有详细的说明，你看。”我打开 PDF，并翻到了对应的内容，指着屏幕念道。</p>
<blockquote>
<p>数据库的查询结果可能是 null，如果使用基本类型的话，因为要自动拆箱，就会抛出 NullPointerException 的异常。</p>
</blockquote>
<p>“什么是自动拆箱呢？”</p>
<p>“自动拆箱指的是，将包装类型转为基本类型，比如说把 Integer 对象转换成 int 值；对应的，把基本类型转为包装类型，则称为自动装箱。”</p>
<p>“哦。”</p>
<p>“那接下来，我们来看第二点不同。<strong>包装类型可用于泛型，而基本类型不可以，</strong>否则就会出现编译错误。”一边说着，我一边在 Intellij IDEA 中噼里啪啦地敲了起来。</p>
<p>“三妹，你瞧，编译器提示错误了。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;int&gt; list = new ArrayList&lt;&gt;(); // 提示 Syntax error, insert &quot;Dimensions&quot; to </span><br><span class="line">complete ReferenceType</span><br><span class="line">List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>“为什么呢？”三妹及时地问道。</p>
<p>“因为泛型在编译时会进行类型擦除，最后只保留原始类型，而原始类型只能是 Object 类及其子类——基本类型是个例外。”</p>
<p>“那，接下来，我们来说第三点，<strong>基本类型比包装类型更高效。</strong>”我喝了一口茶继续说道。</p>
<p>“作为局部变量时，基本类型在栈中直接存储的具体数值，而包装类型则存储的是堆中的引用。”我一边说着，一边打开 draw.io 画起了图。</p>
<p><img src="\assets\note\image-20231013095531566.png" alt="image-20231013095531566"></p>
<p>很显然，相比较于基本类型而言，包装类型需要占用更多的内存空间，不仅要存储对象，还要存储引用。假如没有基本类型的话，对于数值这类经常使用到的数据来说，每次都要通过 new 一个包装类型就显得非常笨重。</p>
<p>“三妹，你想知道程序运行时，数据都存储在什么地方吗？”</p>
<p>“嗯嗯，哥，你说说呗。”</p>
<p>“通常来说，有 4 个地方可以用来存储数据。”</p>
<p>1）寄存器。这是最快的存储区，因为它位于 CPU 内部，用来暂时存放参与运算的数据和运算结果。</p>
<p>2）栈。位于 RAM（Random Access Memory，也叫主存，与 CPU 直接交换数据的内部存储器）中，速度仅次于寄存器。但是，在分配内存的时候，存放在栈中的数据大小与生存周期必须在编译时是确定的，缺乏灵活性。基本数据类型的值和对象的引用通常存储在这块域。</p>
<p>3）堆。也位于 RAM 区，可以动态分配内存大小，编译器不必知道要从堆里分配多少存储空间，生存周期也不必事先告诉编译器，Java 的垃圾收集器会自动收走不再使用的数据，因此可以得到更大的灵活性。但是，运行时动态分配内存和销毁对象都需要占用时间，所以效率比栈低一些。new 创建的对象都会存储在这块区域。</p>
<p>4）磁盘。如果数据完全存储在程序之外，就可以不受程序的限制，在程序没有运行时也可以存在。像文件、数据库，就是通过持久化的方式，让对象存放在磁盘上。当需要的时候，再反序列化成程序可以识别的对象。</p>
<p>“能明白吗？三妹？”</p>
<p>“这节讲完后，我再好好消化一下。”</p>
<p>“那好，我们来说第四点，<strong>两个包装类型的值可以相同，但却不相等。”</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer chenmo = new Integer(10);</span><br><span class="line">Integer wanger = new Integer(10);</span><br><span class="line">System.out.println(chenmo == wanger); // false</span><br><span class="line">System.out.println(chenmo.equals(wanger )); // true</span><br></pre></td></tr></table></figure>
<p>“两个包装类型在使用“\==”进行判断的时候，判断的是其指向的地址是否相等，由于是两个对象，所以地址是不同的。”</p>
<p>“而 chenmo.equals(wanger) 的输出结果为 true，是因为 equals() 方法内部比较的是两个 int 值是否相等。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private final int value;</span><br><span class="line">public int intValue() &#123;</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">    if (obj instanceof Integer) &#123;</span><br><span class="line">        return value == ((Integer)obj).intValue();</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然 chenmo 和 wanger 的值都是 10，但他们并不相等。换句话说就是：将“\==”操作符应用于包装类型比较的时候，其结果很可能会和预期的不符。</p>
<p>“三妹，瞧， ((Integer)obj).intValue() 这段代码就是用来自动拆箱的。下面，我们来详细地说一说自动装箱和自动拆箱。”</p>
<p>既然有基本类型和包装类型，肯定有些时候要在它们之间进行转换。把基本类型转换成包装类型的过程叫做装箱（boxing）。反之，把包装类型转换成基本类型的过程叫做拆箱（unboxing）。</p>
<p>在 Java 1.5 之前，开发人员要手动进行装拆箱，比如说：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer chenmo = new Integer(10); // 手动装箱</span><br><span class="line">int wanger = chenmo.intValue();  // 手动拆箱</span><br></pre></td></tr></table></figure>
<p>Java 1.5 为了减少开发人员的工作，提供了自动装箱与自动拆箱的功能。这下就方便了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer chenmo  = 10;  // 自动装箱</span><br><span class="line">int wanger = chenmo;     // 自动拆箱</span><br></pre></td></tr></table></figure>
<p>来看一下反编译后的代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer chenmo = Integer.valueOf(10);</span><br><span class="line">int wanger = chenmo.intValue();</span><br></pre></td></tr></table></figure>
<p>也就是说，自动装箱是通过 Integer.valueOf() 完成的；自动拆箱是通过 Integer.intValue() 完成的。</p>
<p>“嗯，三妹，给你出一道面试题吧。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/ 1）基本类型和包装类型</span><br><span class="line">int a = 100;</span><br><span class="line">Integer b = 100;</span><br><span class="line">System.out.println(a == b);</span><br><span class="line">// 2）两个包装类型</span><br><span class="line">Integer c = 100;</span><br><span class="line">Integer d = 100;</span><br><span class="line">System.out.println(c == d);</span><br><span class="line">// 3）</span><br><span class="line">c = 200;</span><br><span class="line">d = 200;</span><br><span class="line">System.out.println(c == d);</span><br></pre></td></tr></table></figure>
<p>“给你 3 分钟时间，你先思考下，等我回来，然后再来分析一下为什么。”</p>
<p>。。。。。。</p>
<p>“嗯，哥，你过来吧，我说一说我的想法。”</p>
<p>第一段代码，基本类型和包装类型进行 == 比较，这时候 b 会自动拆箱，直接和 a 比较值，所以结果为 true。</p>
<p>第二段代码，两个包装类型都被赋值为了 100，这时候会进行自动装箱，按照你之前说的，将“==”操作符应用于包装类型比较的时候，其结果很可能会和预期的不符，我想结果可能为 false。</p>
<p>第三段代码，两个包装类型重新被赋值为了 200，这时候仍然会进行自动装箱，我想结果仍然为 false。</p>
<p>“嗯嗯，三妹，你分析的很有逻辑，但第二段代码的结果为 true，是不是感到很奇怪？”</p>
<p>“为什么会这样呀？”三妹急切地问。</p>
<p>“你说的没错，自动装箱是通过 Integer.valueOf() 完成的，我们来看看这个方法的源码就明白为什么了。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static Integer valueOf(int i) &#123;</span><br><span class="line">    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        return IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    return new Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是不是看到了一个之前从来没见过的类——IntegerCache？</p>
<p>“难道说是 Integer 的缓存类？”三妹做出了自己的判断。</p>
<p>“是的，来看一下 IntegerCache 的源码吧。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private static class IntegerCache &#123;</span><br><span class="line">    static final int low = -128;</span><br><span class="line">    static final int high;</span><br><span class="line">    static final Integer cache[];</span><br><span class="line">    static &#123;</span><br><span class="line">        // high value may be configured by property</span><br><span class="line">        int h = 127;</span><br><span class="line">        int i = parseInt(integerCacheHighPropValue);</span><br><span class="line">        i = Math.max(i, 127);</span><br><span class="line">        h = Math.min(i, Integer.MAX_VALUE - (-low) -1);</span><br><span class="line">        high = h;</span><br><span class="line">        cache = new Integer[(high - low) + 1];</span><br><span class="line">        int j = low;</span><br><span class="line">        for(int k = 0; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = new Integer(j++);</span><br><span class="line">        // range [-128, 127] must be interned (JLS7 5.1.7)</span><br><span class="line">        assert IntegerCache.high &gt;= 127;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大致瞟一下这段代码你就全明白了。-128 到 127 之间的数会从 IntegerCache 中取，然后比较，所以第二段代码（100 在这个范围之内）的结果是 true，而第三段代码（200 不在这个范围之内，所以 new 出来了两个 Integer 对象）的结果是 false。</p>
<p>“三妹，看完上面的分析之后，我希望你记住一点：<strong>当需要进行自动装箱时，如果数字在 -128 至 127 之间时，会直接使用缓存中的对象，而不是重新创建一个对象。”</strong></p>
<p>“自动装拆箱是一个很好的功能，大大节省了我们开发人员的精力，但也会引发一些麻烦，比如下面这段代码，性能就很差。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">long t1 = System.currentTimeMillis();</span><br><span class="line">Long sum = 0L;</span><br><span class="line">for (int i = 0; i &lt; Integer.MAX_VALUE;i++) &#123;</span><br><span class="line">    sum += i;</span><br><span class="line">&#125;</span><br><span class="line">long t2 = System.currentTimeMillis();        </span><br><span class="line">System.out.println(t2-t1);</span><br></pre></td></tr></table></figure>
<p>“知道为什么吗？三妹。”</p>
<p>“难道是因为 sum 被声明成了包装类型 Long 而不是基本类型 long。”三妹若有所思。</p>
<p>“是滴，由于 sum 是个 Long 型，而 i 为 int 类型， sum += i 在执行的时候，会先把 i 强转为 long 型，然后再把 sum 拆箱为 long 型进行相加操作，之后再自动装箱为 Long 型赋值给 sum。”</p>
<p>“三妹，你可以试一下，把 sum 换成 long 型比较一下它们运行的时间。”</p>
<p>。。。。。。</p>
<p>“哇，sum 为 Long 型的时候，足足运行了 5825 毫秒；sum 为 long 型的时候，只需要 679 毫秒。”</p>
<h2 id="11-4-深入理解Java浅拷贝与深拷贝"><a href="#11-4-深入理解Java浅拷贝与深拷贝" class="headerlink" title="11.4 深入理解Java浅拷贝与深拷贝"></a>11.4 深入理解Java浅拷贝与深拷贝</h2><p>“哥，听说浅拷贝和深拷贝是 Java 面试中经常会被问到的一个问题，是这样吗？”</p>
<p>“还真的是，而且了解浅拷贝和深拷贝的原理，对 Java 是值传递还是引用传递也会有更深的理解。”我肯定地回答。</p>
<p>“不管是浅拷贝还是深拷贝，都可以通过调用 Object 类的 clone() 方法来完成。”我一边说，一边打开 Intellij IDEA，并找到了 clone() 方法的源码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected native Object clone() throws CloneNotSupportedException;</span><br></pre></td></tr></table></figure>
<p>需要注意的是， clone() 方法同时是一个本地（ native ）方法，它的具体实现会交给 HotSpot 虚拟机，那就意味着虚拟机在运行该方法的时候，会将其替换为更高效的 C/C++ 代码，进而调用操作系统去完成对象的克隆工作。</p>
<blockquote>
<p>Java 9 后，该方法会被标注 @HotSpotIntrinsicCandidate 注解，被该注解标注的方法，在 HotSpot 虚拟机中会有一套高效的实现。</p>
</blockquote>
<p>“哥，那你就先说浅拷贝吧！”</p>
<p>“好的呀。直接上实战代码。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Writer implements Cloneable&#123;</span><br><span class="line">    private int age;</span><br><span class="line">    private String name;</span><br><span class="line">    // getter/setter 和构造方法都已省略</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return super.toString().substring(26) + &quot;&#123;&quot; +</span><br><span class="line">                &quot;age=&quot; + age +</span><br><span class="line">                &quot;, name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Writer 类有两个字段，分别是 int 类型的 age，和 String 类型的 name。然后重写了 toString() 方法，方便打印对象的具体信息。</p>
<p>“为什么要实现 Cloneable 接口呢？”三妹开启了十万个为什么的模式。</p>
<p>Cloneable 接口是一个标记接口，它肚子里面是空的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public interface Cloneable &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只是，如果一个类没有实现 Cloneable 接口，即便它重写了 clone() 方法，依然是无法调用该方法进行对象克隆的，程序在执行 clone() 方法的时候会抛出 CloneNotSupportedException 异常。</p>
<p>标记接口的作用其实很简单，用来表示某个功能在执行的时候是合法的。</p>
<p>“哦，我悟了！”三妹看来是彻底明白了我说的内容。</p>
<p>“接着，来测试类。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class TestClone &#123;</span><br><span class="line">    public static void main(String[] args) throws CloneNotSupportedException &#123;</span><br><span class="line">        Writer writer1 = new Writer(18,&quot;二哥&quot;);</span><br><span class="line">        Writer writer2 = (Writer) writer1.clone();</span><br><span class="line">        System.out.println(&quot;浅拷贝后：&quot;);</span><br><span class="line">        System.out.println(&quot;writer1：&quot; + writer1);</span><br><span class="line">        System.out.println(&quot;writer2：&quot; + writer2);</span><br><span class="line">        writer2.setName(&quot;三妹&quot;);</span><br><span class="line">        System.out.println(&quot;调整了 writer2 的 name 后：&quot;);</span><br><span class="line">        System.out.println(&quot;writer1：&quot; + writer1);</span><br><span class="line">        System.out.println(&quot;writer2：&quot; + writer2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>通过 new 关键字声明了一个 Writer 对象（18 岁的二哥），将其赋值给 writer1。</li>
<li>通过调用 clone() 方法进行对象拷贝，并将其赋值给 writer2。</li>
<li>之后打印 writer1 和 writer2。</li>
<li>将 writer2 的 name 字段调整为“三妹”。</li>
<li>再次打印。</li>
</ul>
<p>来看一下输出结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">浅拷贝后：</span><br><span class="line">writer1：Writer@68837a77&#123;age=18, name=&#x27;二哥&#x27;&#125;</span><br><span class="line">writer2：Writer@b97c004&#123;age=18, name=&#x27;二哥&#x27;&#125;</span><br><span class="line">调整了 writer2 的 name 后：</span><br><span class="line">writer1：Writer@68837a77&#123;age=18, name=&#x27;二哥&#x27;&#125;</span><br><span class="line">writer2：Writer@b97c004&#123;age=18, name=&#x27;三妹&#x27;&#125;</span><br></pre></td></tr></table></figure>
<p>可以看得出，浅拷贝后，writer1 和 writer2 引用了不同的对象，但值是相同的，说明拷贝成功。之后，修改了 writer2 的 name 字段，直接上图就明白了。</p>
<p><img src="\assets\note\image-20231013101631263.png" alt="image-20231013101631263"></p>
<p>之前的例子中，Writer 类只有两个字段，没有引用类型字段。那么，我们再来看另外一个例子，为 Writer 类增加一个自定义的引用类型字段 Book，先来看 Book 的定义。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Book &#123;</span><br><span class="line">    private String bookName;</span><br><span class="line">    private int price;</span><br><span class="line">    // getter/setter 和构造方法都已省略</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return super.toString().substring(26) +</span><br><span class="line">                &quot; bookName=&#x27;&quot; + bookName + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, price=&quot; + price +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有两个字段，分别是 String 类型的 bookName 和 int 类型的 price。</p>
<p>然后来看 Writer 类的定义。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Writer implements Cloneable&#123;</span><br><span class="line">    private int age;</span><br><span class="line">    private String name;</span><br><span class="line">    private Book book;</span><br><span class="line">    // getter/setter 和构造方法都已省略</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return super.toString().substring(26) +</span><br><span class="line">                &quot; age=&quot; + age +</span><br><span class="line">                &quot;, name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, book=&quot; + book +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        return super.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比之前的例子多了一个自定义类型的字段 book， clone() 方法并没有任何改变。</p>
<p>再来看测试类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class TestClone &#123;</span><br><span class="line">    public static void main(String[] args) throws CloneNotSupportedException &#123;</span><br><span class="line">        Writer writer1 = new Writer(18,&quot;二哥&quot;);</span><br><span class="line">        Book book1 = new Book(&quot;编译原理&quot;,100);</span><br><span class="line">        writer1.setBook(book1);</span><br><span class="line">        Writer writer2 = (Writer) writer1.clone();</span><br><span class="line">        System.out.println(&quot;浅拷贝后：&quot;);</span><br><span class="line">        System.out.println(&quot;writer1：&quot; + writer1);</span><br><span class="line">        System.out.println(&quot;writer2：&quot; + writer2);</span><br><span class="line">        Book book2 = writer2.getBook();</span><br><span class="line">        book2.setBookName(&quot;永恒的图灵&quot;);</span><br><span class="line">        book2.setPrice(70);</span><br><span class="line">        System.out.println(&quot;writer2.book 变更后：&quot;);</span><br><span class="line">        System.out.println(&quot;writer1：&quot; + writer1);</span><br><span class="line">        System.out.println(&quot;writer2：&quot; + writer2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>通过 new 关键字声明了一个 Writer 对象（18 岁的二哥），将其赋值给 writer1。</li>
<li>通过 new 关键字声明了一个 Book 对象（100 块的编译原理），将其赋值给 book1。</li>
<li>将 writer1 的 book 字段设置为 book1。</li>
<li>通过调用 clone() 方法进行对象拷贝，并将其赋值给 writer2。</li>
<li>之后打印 writer1 和 writer2。</li>
<li>获取 writer2 的 book 字段，并将其赋值给 book2。</li>
<li>将 book2 的 bookName 字段调整为“永恒的图灵”，price 字段调整为 70。</li>
<li>再次打印。</li>
</ul>
<p>来看一下输出结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">浅拷贝后：</span><br><span class="line">writer1：Writer@68837a77 age=18, name=&#x27;二哥&#x27;, book=Book@32e6e9c3 bookName=&#x27;编译原理&#x27;, </span><br><span class="line">price=100&#125;&#125;</span><br><span class="line">writer2：Writer@6d00a15d age=18, name=&#x27;二哥&#x27;, book=Book@32e6e9c3 bookName=&#x27;编译原理&#x27;, </span><br><span class="line">price=100&#125;&#125;</span><br><span class="line">writer2.book 变更后：</span><br><span class="line">writer1：Writer@68837a77 age=18, name=&#x27;二哥&#x27;, book=Book@32e6e9c3 bookName=&#x27;永恒的图灵&#x27;, </span><br><span class="line">price=70&#125;&#125;</span><br><span class="line">writer2：Writer@36d4b5c age=18, name=&#x27;二哥&#x27;, book=Book@32e6e9c3 bookName=&#x27;永恒的图灵&#x27;, </span><br><span class="line">price=70&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>与之前例子不同的是，writer2.book 变更后，writer1.book 也发生了改变。这是因为字符串 String 是不可变对象，一个新的值必须在字符串常量池中开辟一段新的内存空间，而自定义对象的内存地址并没有发生改变，只是对应的字段值发生了改变，见下图。</p>
<p><img src="\assets\note\image-20231013101831462.png" alt="image-20231013101831462"></p>
<p>“哇，哥，果真一图胜千言，我明白了。”三妹似乎对我画的图很感兴趣呢，“那你继续说深拷贝吧！”</p>
<p>“嗯，三妹，你有没有注意到，浅拷贝克隆的对象中，引用类型的字段指向的是同一个，当改变任何一个对象，另外一个对象也会随之改变，除去字符串的特殊性外。”</p>
<p>“深拷贝和浅拷贝不同的，深拷贝中的引用类型字段也会克隆一份，当改变任何一个对象，另外一个对象不会随之改变。”</p>
<p>“明白了这一点后，我们再来看例子。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Book implements Cloneable&#123;</span><br><span class="line">    private String bookName;</span><br><span class="line">    private int price;</span><br><span class="line">    // getter/setter 和构造方法都已省略</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return super.toString().substring(26) +</span><br><span class="line">                &quot; bookName=&#x27;&quot; + bookName + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, price=&quot; + price +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        return super.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，此时的 Book 类和浅拷贝时不同，重写了 clone() 方法，并实现了 Cloneable 接口。为的就是深拷贝的时候也能够克隆该字段。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Writer implements Cloneable&#123;</span><br><span class="line">    private int age;</span><br><span class="line">    private String name;</span><br><span class="line">    private Book book;</span><br><span class="line">    // getter/setter 和构造方法都已省略</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return super.toString().substring(26) +</span><br><span class="line">                &quot; age=&quot; + age +</span><br><span class="line">                &quot;, name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, book=&quot; + book +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        Writer writer = (Writer) super.clone();</span><br><span class="line">        writer.setBook((Book) writer.getBook().clone());</span><br><span class="line">        return writer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，此时 Writer 类也与之前的不同， clone() 方法当中，不再只调用 Object 的 clone() 方法对 Writer 进行克隆了，还对 Book 也进行了克隆。</p>
<p>来看测试类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class TestClone &#123;</span><br><span class="line">    public static void main(String[] args) throws CloneNotSupportedException &#123;</span><br><span class="line">        Writer writer1 = new Writer(18,&quot;二哥&quot;);</span><br><span class="line">        Book book1 = new Book(&quot;编译原理&quot;,100);</span><br><span class="line">        writer1.setBook(book1);</span><br><span class="line">        Writer writer2 = (Writer) writer1.clone();</span><br><span class="line">        System.out.println(&quot;深拷贝后：&quot;);</span><br><span class="line">        System.out.println(&quot;writer1：&quot; + writer1);</span><br><span class="line">        System.out.println(&quot;writer2：&quot; + writer2);</span><br><span class="line">        Book book2 = writer2.getBook();</span><br><span class="line">        book2.setBookName(&quot;永恒的图灵&quot;);</span><br><span class="line">        book2.setPrice(70);</span><br><span class="line">        System.out.println(&quot;writer2.book 变更后：&quot;);</span><br><span class="line">        System.out.println(&quot;writer1：&quot; + writer1);</span><br><span class="line">        System.out.println(&quot;writer2：&quot; + writer2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个测试类和之前的浅拷贝的测试类就完全一样了，但运行结果是不同的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">深拷贝后：</span><br><span class="line">writer1：Writer@6be46e8f age=18, name=&#x27;二哥&#x27;, book=Book@5056dfcb bookName=&#x27;编译原理&#x27;, </span><br><span class="line">price=100&#125;&#125;</span><br><span class="line">writer2：Writer@6d00a15d age=18, name=&#x27;二哥&#x27;, book=Book@51efea79 bookName=&#x27;编译原理&#x27;, </span><br><span class="line">price=100&#125;&#125;</span><br><span class="line">writer2.book 变更后：</span><br><span class="line">writer1：Writer@6be46e8f age=18, name=&#x27;二哥&#x27;, book=Book@5056dfcb bookName=&#x27;编译原理&#x27;, </span><br><span class="line">price=100&#125;&#125;</span><br><span class="line">writer2：Writer@6d00a15d age=18, name=&#x27;二哥&#x27;, book=Book@51efea79 bookName=&#x27;永恒的图灵&#x27;, </span><br><span class="line">price=70&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>不只是 writer1 和 writer2 是不同的对象，它们中的 book 也是不同的对象。所以，改变了 writer2 中的 book 并不会影响到 writer1。</p>
<p><img src="\assets\note\image-20231013102059277.png" alt="image-20231013102059277"></p>
<p>不过，通过 clone() 方法实现的深拷贝比较笨重，因为要将所有的引用类型都重写 clone() 方法，当嵌套的对象比较多的时候，就废了！</p>
<p>“那有没有好的办法呢？”三妹急切的问。</p>
<p>“当然有了，利用序列化。”我胸有成竹的回答，“序列化是将对象写到流中便于传输，而反序列化则是将对象从流中读取出来。”</p>
<p>“写入流中的对象就是对原始对象的拷贝。需要注意的是，每个要序列化的类都要实现 Serializable 接口，该接口和 Cloneable 接口类似，都是标记型接口。”</p>
<p>来看例子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Book implements Serializable &#123;</span><br><span class="line">    private String bookName;</span><br><span class="line">    private int price;</span><br><span class="line">    // getter/setter 和构造方法都已省略</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return super.toString().substring(26) +</span><br><span class="line">                &quot; bookName=&#x27;&quot; + bookName + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, price=&quot; + price +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Book 需要实现 Serializable 接口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Writer implements Serializable &#123;</span><br><span class="line">    private int age;</span><br><span class="line">    private String name;</span><br><span class="line">    private Book book;</span><br><span class="line">    // getter/setter 和构造方法都已省略</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return super.toString().substring(26) +</span><br><span class="line">                &quot; age=&quot; + age +</span><br><span class="line">                &quot;, name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, book=&quot; + book +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    //深度拷贝</span><br><span class="line">    public Object deepClone() throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        // 序列化</span><br><span class="line">        ByteArrayOutputStream bos = new ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = new ObjectOutputStream(bos);</span><br><span class="line">        oos.writeObject(this);</span><br><span class="line">        // 反序列化</span><br><span class="line">        ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">        ObjectInputStream ois = new ObjectInputStream(bis);</span><br><span class="line">        return ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Writer 类也需要实现 Serializable 接口，并且在该类中，增加了一个 deepClone() 的方法，利用 OutputStream 进行序列化，InputStream 进行反序列化，这样就实现了深拷贝。</p>
<p>来看示例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class TestClone &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException, </span><br><span class="line">ClassNotFoundException &#123;</span><br><span class="line">        Writer writer1 = new Writer(18,&quot;二哥&quot;);</span><br><span class="line">        Book book1 = new Book(&quot;编译原理&quot;,100);</span><br><span class="line">        writer1.setBook(book1);</span><br><span class="line">        Writer writer2 = (Writer) writer1.deepClone();</span><br><span class="line">        System.out.println(&quot;深拷贝后：&quot;);</span><br><span class="line">        System.out.println(&quot;writer1：&quot; + writer1);</span><br><span class="line">        System.out.println(&quot;writer2：&quot; + writer2);</span><br><span class="line">        Book book2 = writer2.getBook();</span><br><span class="line">        book2.setBookName(&quot;永恒的图灵&quot;);</span><br><span class="line">        book2.setPrice(70);</span><br><span class="line">        System.out.println(&quot;writer2.book 变更后：&quot;);</span><br><span class="line">        System.out.println(&quot;writer1：&quot; + writer1);</span><br><span class="line">        System.out.println(&quot;writer2：&quot; + writer2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与之前测试类不同的是，调用了 deepClone() 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">深拷贝后：</span><br><span class="line">writer1：Writer@9629756 age=18, name=&#x27;二哥&#x27;, book=Book@735b5592 bookName=&#x27;编译原理&#x27;, </span><br><span class="line">price=100&#125;&#125;</span><br><span class="line">writer2：Writer@544fe44c age=18, name=&#x27;二哥&#x27;, book=Book@31610302 bookName=&#x27;编译原理&#x27;, </span><br><span class="line">price=100&#125;&#125;</span><br><span class="line">writer2.book 变更后：</span><br><span class="line">writer1：Writer@9629756 age=18, name=&#x27;二哥&#x27;, book=Book@735b5592 bookName=&#x27;编译原理&#x27;, </span><br><span class="line">price=100&#125;&#125;</span><br><span class="line">writer2：Writer@544fe44c age=18, name=&#x27;二哥&#x27;, book=Book@31610302 bookName=&#x27;永恒的图灵&#x27;, </span><br><span class="line">price=70&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果和之前用 clone() 方法实现的深拷贝类似。</p>
<p>“不过，三妹，需要注意，由于是序列化涉及到输入流和输出流的读写，在性能上要比 HotSpot 虚拟机实现的 clone() 方法差很多。”我语重心长地说。</p>
<p>“好的，二哥，你先去休息吧，让我来琢磨一会，总结一下浅拷贝和深拷贝之间的差异。”</p>
<p>“嗯嗯。”</p>
<h2 id="11-5-Java-hashCode方法解析"><a href="#11-5-Java-hashCode方法解析" class="headerlink" title="11.5 Java hashCode方法解析"></a>11.5 Java hashCode方法解析</h2><p>今天我们来谈谈 Java 中的 hashCode() 方法。众所周知，Java 是一门面向对象的编程语言，所有的类都会默认继承自 Object 类，而 Object 的中文意思就是“对象”。</p>
<p>Object 类中就包含了 hashCode() 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public native int hashCode();</span><br></pre></td></tr></table></figure>
<p>意味着所有的类都会有一个 hashCode() 方法，该方法会返回一个 int 类型的值。由于 hashCode() 方法是一个本地方法（ native 关键字修饰的方法，用 C/C++ 语言实现，由 Java 调用），意味着 Object 类中并没有给出具体的实现。</p>
<p>具体的实现可以参考 jdk/src/hotspot/share/runtime/synchronizer.cpp （源码可以到 GitHub 上 OpenJDK 的仓库中下载）。 get_next_hash() 方法会根据 hashCode 的取值来决定采用哪一种哈希值的生成策略。</p>
<p><img src="\assets\note\image-20231013102427849.png" alt="image-20231013102427849"></p>
<p>Java 9 之后， hashCode() 方法会被 @HotSpotIntrinsicCandidate 注解修饰，表明它在 HotSpot 虚拟机中有一套高效的实现，基于 CPU 指令。</p>
<p>那大家有没有想过这样一个问题：<strong>为什么 Object 类需要一个 hashCode()方法呢？</strong></p>
<p>在 Java 中， hashCode() 方法的主要作用就是为了配合哈希表使用的。</p>
<p>哈希表（Hash Table），也叫散列表，是一种可以通过关键码值（key-value）直接访问的数据结构，它最大的特点就是可以快速实现查找、插入和删除。其中用到的算法叫做哈希，就是把任意长度的输入，变换成固定长度的输出，该输出就是哈希值。像 MD5、SHA1 都用的是哈希算法。</p>
<p>像 Java 中的 HashSet、Hashtable（注意是小写的 t）、HashMap 都是基于哈希表的具体实现。其中的 HashMap 就是最典型的代表，不仅面试官经常问，工作中的使用频率也非常的高。</p>
<p>大家想一下，如果没有哈希表，但又需要这样一个数据结构，它里面存放的数据是不允许重复的，该怎么办呢？</p>
<p>要不使用 equals() 方法进行逐个比较？这种方案当然是可行的。但如果数据量特别特别大，采用 equals() 方法进行逐个对比的效率肯定很低很低，最好的解决方案就是哈希表。</p>
<p>拿 HashMap 来说吧。当我们要在它里面添加对象时，先调用这个对象的 hashCode() 方法，得到对应的哈希值，然后将哈希值和对象一起放到 HashMap 中。当我们要再添加一个新的对象时：</p>
<ul>
<li>获取对象的哈希值；</li>
<li>和之前已经存在的哈希值进行比较，如果不相等，直接存进去；</li>
<li>如果有相等的，再调用 equals() 方法进行对象之间的比较，如果相等，不存了；</li>
<li>如果不等，说明哈希冲突了，增加一个链表，存放新的对象；</li>
<li>如果链表的长度大于 8，转为红黑树来处理。</li>
</ul>
<p>就这么一套下来，调用 equals() 方法的频率就大大降低了。也就是说，只要哈希算法足够的高效，把发生哈希冲突的频率降到最低，哈希表的效率就特别的高。</p>
<p>来看一下 HashMap 的哈希算法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先调用对象的 hashCode() 方法，然后对该值进行右移运算，然后再进行异或运算。</p>
<p>通常来说，String 会用来作为 HashMap 的键进行哈希运算，因此我们再来看一下 String 的 hashCode() 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public int hashCode() &#123;</span><br><span class="line">    int h = hash;</span><br><span class="line">    if (h == 0 &amp;&amp; value.length &gt; 0) &#123;</span><br><span class="line">        char val[] = value;</span><br><span class="line">        for (int i = 0; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = 31 * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    return h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可想而知，经过这么一系列复杂的运算，再加上 JDK 作者这种大师级别的设计，哈希冲突的概率我相信已经降到了最低（我们在 HashMap 中深入探讨过）。</p>
<p>当然了，从理论上来说，对于两个不同对象，它们通过 hashCode() 方法计算后的值可能相同。因此，不能使用 hashCode() 方法来判断两个对象是否相等，必须得通过 equals() 方法。</p>
<p>也就是说：</p>
<ul>
<li>如果两个对象调用 equals() 方法得到的结果为 true，调用 hashCode() 方法得到的结果必定相等；</li>
<li>如果两个对象调用 hashCode() 方法得到的结果不相等，调用 equals() 方法得到的结果必定为 false；</li>
</ul>
<p>反之：</p>
<ul>
<li>如果两个对象调用 equals() 方法得到的结果为 false，调用 hashCode() 方法得到的结果不一定不相等；</li>
<li>如果两个对象调用 hashCode() 方法得到的结果相等，调用 equals() 方法得到的结果不一定为 true；</li>
</ul>
<p>来看下面这段代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Student s1 = new Student(18, &quot;张三&quot;);</span><br><span class="line">        Map&lt;Student, Integer&gt; scores = new HashMap&lt;&gt;();</span><br><span class="line">        scores.put(s1, 98);</span><br><span class="line">        System.out.println(scores.get(new Student(18, &quot;张三&quot;)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> class Student &#123;</span><br><span class="line">    private int age;</span><br><span class="line">    private String name;</span><br><span class="line">     public Student(int age, String name) &#123;</span><br><span class="line">         this.age = age;</span><br><span class="line">         this.name = name;</span><br><span class="line">     &#125;</span><br><span class="line">     @Override</span><br><span class="line">     public boolean equals(Object o) &#123;</span><br><span class="line">         Student student = (Student) o;</span><br><span class="line">         return age == student.age &amp;&amp;</span><br><span class="line">                 Objects.equals(name, student.name);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>我们重写了 Student 类的 equals() 方法，如果两个学生的年纪和姓名相同，我们就认为是同一个学生，虽然很离谱，但我们就是这么草率。</p>
<p>在 main() 方法中，18 岁的张三考试得了 98 分，很不错的成绩，我们把张三和成绩放到了 HashMap 中，然后准备输出张三的成绩：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">null</span><br></pre></td></tr></table></figure>
<p>很不巧，结果为 null，而不是预期当中的 98。这是为什么呢？</p>
<p>原因就在于重写 equals() 方法的时候没有重写 hashCode() 方法。默认情况下， hashCode() 方法是一个本地方法，会返回对象的存储地址，显然 put() 中的 s1 和 get() 中的 new Student(18, “张三”) 是两个对象，它们的存储地址肯定是不同的。</p>
<p>HashMap 的 get() 方法会调用 hash(key.hashCode()) 计算对象的哈希值，虽然两个不同的 hashCode() 结果经过 hash() 方法计算后有可能得到相同的结果，但这种概率微乎其微，所以就导致 scores.get(new Student(18, “张三”)) 无法得到预期的值 18。</p>
<p>怎么解决这个问题呢？很简单，重写 hashCode() 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"> public int hashCode() &#123;</span><br><span class="line">     return Objects.hash(age, name);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>Objects 类的 hash() 方法可以针对不同数量的参数生成新的 hashCode() 值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static int hashCode(Object a[]) &#123;</span><br><span class="line"> if (a == null)</span><br><span class="line">     return 0;</span><br><span class="line"> int result = 1;</span><br><span class="line"> for (Object element : a)</span><br><span class="line">     result = 31 * result + (element == null ? 0 : element.hashCode());</span><br><span class="line"> return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码似乎很简单，归纳出的数学公式如下所示（n 为字符串长度）。</p>
<p><img src="\assets\note\image-20231013102931782.png" alt="image-20231013102931782"></p>
<p>注意：31 是个奇质数，不大不小，一般质数都非常适合哈希计算，偶数相当于移位运算，容易溢出，造成数据信息丢失。</p>
<p>这就意味着年纪和姓名相同的情况下，会得到相同的哈希值。 scores.get(new Student(18, “张三”)) 就会返回 98 的预期值了。</p>
<p>《Java 编程思想》这本圣经中有一段话，对 hashCode() 方法进行了一段描述。</p>
<blockquote>
<p>设计 hashCode() 时最重要的因素就是：无论何时，对同一个对象调用 hashCode() 都应该生成同样的值。如果在将一个对象用 put() 方法添加进 HashMap 时产生一个 hashCode() 值，而用 get() 方法取出时却产生了另外一个 hashCode() 值，那么就无法重新取得该对象了。所以，如果你的 hashCode() 方法依赖于对象中易变的数据，用户就要当心了，因为此数据发生变化时，hashCode() 就会生成一个不同的哈希值，相当于产生了一个不同的键。</p>
</blockquote>
<p>也就是说，如果在重写 hashCode() 和 equals() 方法时，对象中某个字段容易发生改变，那么最好舍弃这些字段，以免产生不可预期的结果。</p>
<p>好。有了上面这些内容作为基础后，我们回头再来看看本地方法 hashCode() 的 C++ 源码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">static inline intptr_t get_next_hash(Thread* current, oop obj) &#123;</span><br><span class="line">  intptr_t value = 0;</span><br><span class="line">  if (hashCode == 0) &#123;</span><br><span class="line">    // 这种形式使用全局的 Park-Miller 随机数生成器。</span><br><span class="line">    // 在 MP 系统上，我们将对全局变量进行大量的读写访问，因此该机制会引发大量的一致性通信。</span><br><span class="line">    value = os::random();</span><br><span class="line">  &#125; else if (hashCode == 1) &#123;</span><br><span class="line">    // 这种变体在 STW（Stop The World）操作之间具有稳定（幂等）的特性。</span><br><span class="line">    // 在一些 1-0 同步方案中，这可能很有用。</span><br><span class="line">    intptr_t addr_bits = cast_from_oop&lt;intptr_t&gt;(obj) &gt;&gt; 3;</span><br><span class="line">    value = addr_bits ^ (addr_bits &gt;&gt; 5) ^ GVars.stw_random;</span><br><span class="line">  &#125; else if (hashCode == 2) &#123;</span><br><span class="line">    value = 1;            // 用于敏感性测试</span><br><span class="line">  &#125; else if (hashCode == 3) &#123;</span><br><span class="line">    value = ++GVars.hc_sequence;</span><br><span class="line">  &#125; else if (hashCode == 4) &#123;</span><br><span class="line">    value = cast_from_oop&lt;intptr_t&gt;(obj);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // Marsaglia 的异或移位方案，具有线程特定的状态</span><br><span class="line">    // 这可能是最好的整体实现 -- 我们可能会在未来的版本中将其设为默认实现。</span><br><span class="line">    unsigned t = current-&gt;_hashStateX;</span><br><span class="line">    t ^= (t &lt;&lt; 11);</span><br><span class="line">    current-&gt;_hashStateX = current-&gt;_hashStateY;</span><br><span class="line">    current-&gt;_hashStateY = current-&gt;_hashStateZ;</span><br><span class="line">    current-&gt;_hashStateZ = current-&gt;_hashStateW;</span><br><span class="line">    unsigned v = current-&gt;_hashStateW;</span><br><span class="line">    v = (v ^ (v &gt;&gt; 19)) ^ (t ^ (t &gt;&gt; 8));</span><br><span class="line">    current-&gt;_hashStateW = v;</span><br><span class="line">    value = v;</span><br><span class="line">  &#125;</span><br><span class="line">  value &amp;= markWord::hash_mask;</span><br><span class="line">  if (value == 0) value = 0xBAD;</span><br><span class="line">  assert(value != markWord::no_hash, &quot;invariant&quot;);</span><br><span class="line">  return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果没有 C++ 基础的话，不用细致去看每一行代码，我们只通过表面去了解一下 get_next_hash() 这个方法就行。其中的 hashCode 变量是 JVM 启动时的一个全局参数，可以通过它来切换哈希值的生成策略。</p>
<ul>
<li>hashCode==0 ，调用操作系统 OS 的 random() 方法返回随机数。</li>
<li>hashCode == 1 ，在 STW（stop-the-world）操作中，这种策略通常用于同步方案中。利用对象地址进行计算，使用不经常更新的随机数（ GVars.stw_random ）参与其中。</li>
<li>hashCode == 2 ，使用返回 1，用于某些情况下的测试。</li>
<li>hashCode == 3 ，从 0 开始计算哈希值，不是线程安全的，多个线程可能会得到相同的哈希值。</li>
<li>hashCode == 4 ，与创建对象的内存位置有关，原样输出。</li>
<li>hashCode == 5 ，默认值，支持多线程，使用了 Marsaglia 的 xor-shift 算法产生伪随机数。所谓的 xor-shift 算法，简单来说，看起来就是一个移位寄存器，每次移入的位由寄存器中若干位取异或生成。所谓的伪随机数，不是完全随机的，但是真随机生成比较困难，所以只要能通过一定的随机数统计检测，就可以当作真随机数来使用。</li>
</ul>
<p>这里简单总结下。</p>
<p>在 Java 中， hashCode()方法是定义在 java.lang.Object 类中的一个方法，该类是所有 Java 所有类的父类。因此，每个 Java 对象都可以调用 hashCode()方法。 hashCode()方法主要用于支持哈希表（如 java.util.HashMap），这些数据结构使用哈希算法能实现快速查找、插入和删除操作。</p>
<p>hashCode()方法的主要目的是返回一个整数，这个整数称为哈希码，它代表了对象在内存中的一种近似表示。哈希码用于将对象映射到哈希表中的一个特定的位置。两个相等的对象（根据 equals()方法比较）应该具有相同的哈希码。然而，具有相同哈希码的两个对象并不一定相等。</p>
<p>当你创建一个自定义类并覆盖 equals()方法时，通常也需要覆盖 hashCode()方法，以确保相等的对象具有相同的哈希码。这有助于提高哈希表在使用自定义类的对象作为键时的准确性。</p>
<h2 id="11-6-Java是值传递还是引用传递？"><a href="#11-6-Java是值传递还是引用传递？" class="headerlink" title="11.6 Java是值传递还是引用传递？"></a>11.6 Java是值传递还是引用传递？</h2><p>“哥，说说 Java 到底是值传递还是引用传递吧？”三妹一脸的困惑，看得出来她被这个问题折磨得不轻。</p>
<p>“说实在的，我在一开始学 Java 的时候也被这个问题折磨得够呛，总以为基本数据类型在传参的时候是值传递，而引用类型是引用传递。”我对三妹袒露了心声，为的就是让她不再那么焦虑，她哥当年也是这么过来的。</p>
<p>C 语言是很多编程语言的母胎，包括 Java，那么对于 C 语言来说，所有的方法参数都是“通过值”传递的，也就是说，传递给被调用方法的参数值存放在临时变量中，而不是存放在原来的变量中。这就意味着，被调用的方法不能修改调用方法中变量的值，而只能修改其私有变量的临时副本的值。</p>
<p>Java 继承了 C 语言这一特性，因此 Java 是按照值来传递的。</p>
<p>接下来，我们必须得搞清楚，到底什么是值传递（pass by value），什么是引用传递（pass by reference），否则，讨论 Java 到底是值传递还是引用传递就显得毫无意义。</p>
<p>当一个参数按照值的方式在两个方法之间传递时，调用者和被调用者其实是用的两个不同的变量——被调用者中的变量（原始值）是调用者中变量的一份拷贝，对它们当中的任何一个变量修改都不会影响到另外一个变量，据说 Fortran 语言是通过引用传递的。</p>
<p>“Fortran 语言？”三妹睁大了双眼，似乎听见了什么新的名词。</p>
<p>“是的，Fortran 语言，1957 年由 IBM 公司开发，是世界上第一个被正式采用并流传至今的高级编程语言。”当一个参数按照引用传递的方式在两个方法之间传递时，调用者和被调用者其实用的是同一个变量，当该变量被修改时，双方都是可见的。</p>
<p>“我们之所以容易搞不清楚 Java 到底是值传递还是引用传递，主要是因为 Java 中的两类数据类型的叫法容易引发误会，比如说 int 是基本类型，说它是值传递的，我们就很容易理解；但对于引用类型，比如说 String，说它也是值传递的时候，我们就容易弄不明白。”</p>
<p>我们来看看基本数据类型和引用数据类型之间的差别。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int age = 18;</span><br><span class="line">String name = &quot;二哥&quot;;</span><br></pre></td></tr></table></figure>
<p>age 是基本类型，值就保存在变量中，而 name 是引用类型，变量中保存的是对象的地址。一般称这种变量为对象的引用，引用存放在栈中，而对象存放在堆中。</p>
<p>这里说的栈和堆，是指内存中的一块区域，和数据结构中的栈和堆不一样。栈是由编译器自动分配释放的，所以适合存放编译期就确定生命周期的数据；而堆中存放的数据，编译器是不需要知道生命周期的，创建后的回收工作由垃圾收集器来完成。</p>
<p>“画幅图。”</p>
<p><img src="\assets\note\image-20231013103352432.png" alt="image-20231013103352432"></p>
<p>当用 = 赋值运算符改变 age 和 name 的值时。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">age = 16;</span><br><span class="line">name = &quot;三妹&quot;;</span><br></pre></td></tr></table></figure>
<p>对于基本类型 age，赋值运算符会直接改变变量的值，原来的值被覆盖。</p>
<p>对于引用类型 name，赋值运算符会改变对象引用中保存的地址，原来的地址被覆盖，但原来的对象不会被覆盖。</p>
<p><img src="\assets\note\image-20231013103456150.png" alt="image-20231013103456150"></p>
<p>“三妹，注意听，接下来，我们来说说基本数据类型的参数传递。”</p>
<p>Java 有 8 种基本数据类型，分别是 int、long、byte、short、float、double 、char 和 boolean，就拿 int 类型来举例吧。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class PrimitiveTypeDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int age = 18;</span><br><span class="line">        modify(age);</span><br><span class="line">        System.out.println(age);</span><br><span class="line">    &#125;</span><br><span class="line">    private static void modify(int age1) &#123;</span><br><span class="line">        age1 = 30;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1） main() 方法中的 age 为基本类型，所以它的值 18 直接存储在变量中。</p>
<p>2）调用 modify() 方法的时候，将会把 age 的值 18 复制给形参 age1。</p>
<p>3） modify() 方法中，对 age1  做出了修改。</p>
<p>4）回到 main() 方法中，age 的值仍然为 18，并没有发生改变。</p>
<p>如果我们想让 age 的值发生改变，就需要这样做。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class PrimitiveTypeDemo1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int age = 18;</span><br><span class="line">        age = modify(age);</span><br><span class="line">        System.out.println(age);</span><br><span class="line">    &#125;</span><br><span class="line">    private static int modify(int age1) &#123;</span><br><span class="line">        age1 = 30;</span><br><span class="line">        return age1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一，让 modify() 方法有返回值；</p>
<p>第二，使用赋值运算符重新对 age 进行赋值。</p>
<p>“好了，再来说说引用类型的参数传递。”</p>
<p>就以 String 为例吧。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class ReferenceTypeDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String name = &quot;二哥&quot;;</span><br><span class="line">        modify(name);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">    private static void modify(String name1) &#123;</span><br><span class="line">        name1 = &quot;三妹&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在调用 modify() 方法的时候，形参 name1 复制了 name 的地址，指向的是堆中“二哥”的位置。</p>
<p><img src="\assets\note\image-20231013103637589.png" alt="image-20231013103637589"></p>
<p>当 modify() 方法调用结束后，改变了形参 name1 的地址，但 main() 方法中 name 并没有发生改变。</p>
<p><img src="\assets\note\image-20231013103705165.png" alt="image-20231013103705165"></p>
<p>总结：</p>
<ul>
<li>Java 中的参数传递是按值传递的。</li>
<li>如果参数是基本类型，传递的是基本类型的字面量值的拷贝。</li>
<li>如果参数是引用类型，传递的是引用的对象在堆中地址的拷贝。</li>
</ul>
<p>“好了，三妹，今天的学习就到这吧。”</p>
<h2 id="11-7-Java为什么无法实现真正的泛型"><a href="#11-7-Java为什么无法实现真正的泛型" class="headerlink" title="11.7 Java为什么无法实现真正的泛型"></a>11.7 Java为什么无法实现真正的泛型</h2><p>“二哥，为啥 Java 不能实现真正的泛型啊？”三妹开门见山地问。</p>
<p>简单来回顾一下类型擦除，看下面这段代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Cmower &#123;</span><br><span class="line">    public static void method(ArrayList&lt;String&gt; list) &#123;</span><br><span class="line">        System.out.println(&quot;Arraylist&lt;String&gt; list&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void method(ArrayList&lt;Date&gt; list) &#123;</span><br><span class="line">        System.out.println(&quot;Arraylist&lt;Date&gt; list&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“三妹，你是不是认为 ArrayList<String> list 和 ArrayList<Date> list 是两种不同的类型，因为 String 和 Date 是不同的类。”我问。</p>
<p>“嗯。”三妹点点头。</p>
<p>但由于类型擦除的原因，以上代码是不会编译通过的——编译器会提示一个错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&#x27;method(ArrayList&lt;String&gt;)&#x27; clashes with &#x27;method(ArrayList&lt;Date&gt;)&#x27;; both methods </span><br><span class="line">have same erasure</span><br></pre></td></tr></table></figure>
<p>也就是说，两个 method() 方法经过类型擦除后的方法签名是完全相同的，Java 是不允许这样做的。</p>
<p>也就是说，按照我们的假设：如果 Java 能够实现真正意义上的泛型，两个 method() 方法是可以同时存在的，就好像方法重载一样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Cmower &#123;</span><br><span class="line">    public static void method(String list) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void method(Date list) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“为什么 Java 不能实现真正意义上的泛型呢？背后的原因是什么？快告诉我呀！”三妹着急了。</p>
<p>“保持耐心，好不好？”我安慰道。</p>
<p><strong>第一，兼容性</strong></p>
<p>Java 在 2004 年已经积累了较为丰富的生态，如果把现有的类修改为泛型类，需要让所有的用户重新修改源代码并且编译，这就会导致 Java 1.4 之前打下的江山可能会完全覆灭。</p>
<p>想象一下，你的代码原来运行的好好的，就因为 JDK 的升级，导致所有的源代码都无法编译通过并且无法运行，是不是会非常痛苦？</p>
<p>类型擦除就完美实现了兼容性，Java 1.5 之后的类可以使用泛型，而 Java 1.4 之前没有使用泛型的类也可以保留，并且不用做任何修改就能在新版本的 Java 虚拟机上运行。</p>
<p>老用户不受影响，新用户可以自由地选择使用泛型，可谓一举两得。</p>
<p><strong>第二，不是“实现不了”</strong>。Pizza，1996 年的实验语言，在 Java 的基础上扩展了泛型。</p>
<blockquote>
<p>Pizza 教程地址：<a target="_blank" rel="noopener" href="http://pizzacompiler.sourceforge.net/doc/tutorial.html">http://pizzacompiler.sourceforge.net/doc/tutorial.html</a></p>
</blockquote>
<p>“1996 年？”三妹表示很吃惊。</p>
<p>“嗯，你那会还没出生。”我说，“插一下 Java 的版本历史吧，你好有一个时间线上的观念。”</p>
<ul>
<li>1995年5月23日，Java语言诞生</li>
<li>1996年1月，JDK1.0 诞生</li>
<li>1997年2月18日，JDK1.1发布</li>
<li>1998年2月，JDK1.1被下载超过2,000,000次</li>
<li>2000年5月8日，JDK1.3发布</li>
<li>2000年5月29日，JDK1.4发布</li>
<li>2004年9月30日18:00 PM，J2SE1.5 发布</li>
</ul>
<p>也就是说，Pizza 在 JDK 1.0 的版本上就实现了“真正意义上的”泛型，我引过来两段例子，你一看就明白了。</p>
<p>首先是 StoreSomething，一个泛型类，标识符是大写字母 A 而不是我们熟悉的大写字母 T。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class StoreSomething&lt;A&gt; &#123;</span><br><span class="line">     A something;</span><br><span class="line">     StoreSomething(A something) &#123;</span><br><span class="line">         this.something = something;</span><br><span class="line">     &#125;</span><br><span class="line">     void set(A something) &#123;</span><br><span class="line">         this.something = something;</span><br><span class="line">     &#125;</span><br><span class="line">     A get() &#123;</span><br><span class="line">         return something;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 A 呢，可以是任何合法的 Java 类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StoreSomething&lt;String&gt; a = new StoreSomething(&quot;I&#x27;m a string!&quot;);</span><br><span class="line">StoreSomething&lt;int&gt; b = new StoreSomething(17+4);</span><br><span class="line">b.set(9);</span><br><span class="line">int i = b.get();</span><br><span class="line">String s = a.get();</span><br></pre></td></tr></table></figure>
<p>对吧？这就是我们想要的“真正意义上的泛型”，A 不仅仅可以是引用类型 String，还可以是基本数据类型。</p>
<p>要知道，Java 的泛型不允许是基本数据类型，只能是包装器类型。</p>
<p><img src="\assets\note\image-20231013104221817.png" alt="image-20231013104221817"></p>
<p>除此之外，Pizza 的泛型还可以直接使用 new 关键字进行声明，并且 Pizza 编译器会从构造方法的参数上推断出具体的对象类型，究竟是 String 还是 int。要知道，Java 的泛型因为类型擦除的原因，程序员是无法知道一个 ArrayList 究竟是 ArrayList<String> 还是 ArrayList<Integer> 的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; ints = new ArrayList&lt;Integer&gt;();</span><br><span class="line">ArrayList&lt;String&gt; strs = new ArrayList&lt;String&gt;();</span><br><span class="line">System.out.println(ints.getClass());</span><br><span class="line">System.out.println(strs.getClass());</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class java.util.ArrayList</span><br><span class="line">class java.util.ArrayList</span><br></pre></td></tr></table></figure>
<p>都是 ArrayList 而已。</p>
<p>“那 Pizza 这种“真正意义上的泛型”为什么没有被 Java 采纳呢？”三妹很关心这个问题。</p>
<p>事实上，Java 的核心开发组对 Pizza 的泛型设计非常感兴趣，并且与 Pizza 的设计者 Martin 和 Phil 取得了联系，新合作了一个项目 Generic Java，争取在 Java 中添加泛型支持，但不引入 Pizza 的其他功能，比如说函数式编程。</p>
<p>这里再补充一点维基百科上的资料，Martin Odersky 是一名德国计算机科学家，他和其他人一起设计了 Scala 编程语言，以及 Generic Java（还有之前的 Pizza），他实现的 Generic Java 编译器成为了 Java 编译器 javac 的基础。</p>
<p>站在马后炮的思维来看，Pizza 的泛型设计和函数式编程非常具有历史前瞻性。然而 Java 的核心开发组在当时似乎并不想把函数式编程引入到 Java 中。</p>
<p>以至于 Java 在 1.4 之前仍然是不支持泛型的。</p>
<p>“为什么 Java 1.5 的时候又突然支持泛型了呢？”三妹问。</p>
<p>“当然是到了不支持不行的时候了。”我说。</p>
<p>没有泛型之前，我们可以这样写代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList list = new ArrayList();</span><br><span class="line">list.add(&quot;沉默王二&quot;);</span><br><span class="line">list.add(new Date());</span><br></pre></td></tr></table></figure>
<p>不管是 String 类型，还是 Date 类型，都可以一股脑塞进 ArrayList 当中，这看起来似乎很方便，但取的时候就悲剧了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = list.get(1);</span><br></pre></td></tr></table></figure>
<p>这样取行吗？不行。还得加上强制转换。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = (String) list.get(1);</span><br></pre></td></tr></table></figure>
<p>但我们知道，这行代码在运行的时候必然会出错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.ClassCastException: java.util.Date cannot be </span><br><span class="line">cast to java.lang.String</span><br></pre></td></tr></table></figure>
<p>这就又回到“兼容性”的问题了。</p>
<p>Java 语言和其他编程语言不一样，有着沉重的历史包袱，1.5 之前已经有大量的程序部署在生产环境下了，这时候如果一刀切，原来没有使用泛型的代码直接扼杀了，后果不堪想象。</p>
<p>Java 一直以来都强调兼容性，我认为这也是 Java 之所以能被广泛使用的主要原因之一，开发者不必担心Java 版本升级的问题，一个在 JDK 1.4 上可以跑的代码，放在 JDK 1.5 上仍然可以跑。</p>
<p>这里必须得说明一点，J2SE1.5 的发布，是 Java 语言发展史上的重要里程碑，为了表示该版本的重要性，J2SE1.5 也正式更名为 Java SE 5.0，往后去就是 Java SE 6.0，Java SE 7.0。。。。</p>
<p>但 Java 并不支持高版本 JDK 编译生成的字节码文件在低版本的 JRE（Java 运行时环境）上跑。</p>
<p><img src="\assets\note\image-20231013104520606.png" alt="image-20231013104520606"></p>
<p>针对泛型，兼容性具体表现在什么地方呢？来看下面这段代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; ints = new ArrayList&lt;Integer&gt;();</span><br><span class="line">ArrayList&lt;String&gt; strs = new ArrayList&lt;String&gt;();</span><br><span class="line">ArrayList list;</span><br><span class="line">list = ints;</span><br><span class="line">list = strs;</span><br></pre></td></tr></table></figure>
<p>“兼容性表现在上面这段代码必须得能够编译运行。怎么办呢？”我扭头看了一下旁边的三妹，继续说。</p>
<p>“只能搞类型擦除了！”我妹肯定地回答。</p>
<p>“是滴。”</p>
<p>编译前进行泛型检测， ArrayList<Integer> 只能放 Integer， ArrayList<String> 只能放 String，取的时候就不用担心类型强转出错了。</p>
<p>但编译后的字节码文件里，是没有泛型的，放的都是 Object。</p>
<p>Java 神奇就神奇在这，表面上万物皆对象，但为了性能上的考量，又存在 int、double 这种原始类型，但原始类型又没办法和 Object 兼容，于是我们就只能写 ArrayList<Integer> 这样很占用内存空间的代码。</p>
<p>这恐怕也是 Java 泛型被吐槽的原因之一了。</p>
<p><img src="\assets\note\image-20231013104632447.png" alt="image-20231013104632447"></p>
<p>一个好消息是 Valhalla 项目正在努力解决这些因为泛型擦除带来的历史遗留问题。</p>
<p>Project Valhalla：正在进行当中的 OpenJDK 项目，计划给未来的 Java 添加改进的泛型支持。</p>
<blockquote>
<p>源码地址：<a target="_blank" rel="noopener" href="http://openjdk.java.net/projects/valhalla/">http://openjdk.java.net/projects/valhalla/</a></p>
</blockquote>
<p>让我们拭目以待吧！</p>
<p>“怎么样？三妹，这下全部都明白了吧！”我问。</p>
<p>“嗯嗯。二哥，你讲得可真棒 ”三妹夸奖得我有点小开心，嘿嘿。</p>
<h2 id="11-8-掌握-Java-反射"><a href="#11-8-掌握-Java-反射" class="headerlink" title="11.8 掌握 Java 反射"></a>11.8 掌握 Java 反射</h2><p>“二哥，什么是反射呀？”三妹开门见山地问。</p>
<p>“要想知道什么是反射，就需要先来了解什么是‘正射’。”我笑着对三妹说，“一般情况下，我们在使用某个类之前已经确定它到底是个什么类了，拿到手就直接可以使用 new 关键字来调用构造方法进行初始化，之后使用这个类的对象来进行操作。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Writer writer = new Writer();</span><br><span class="line">writer.setName(&quot;沉默王二&quot;);</span><br></pre></td></tr></table></figure>
<p>像上面这个例子，就可以理解为“正射”。而反射就意味着一开始我们不知道要初始化的类到底是什么，也就没法直接使用 new 关键字创建对象了。</p>
<p>我们只知道这个类的一些基本信息，就好像我们看电影的时候，为了抓住一个犯罪嫌疑人，警察就会问一些目击证人，根据这些证人提供的信息，找专家把犯罪嫌疑人的样貌给画出来——这个过程，就可以称之为反射。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(&quot;com.itwanger.s39.Writer&quot;);</span><br><span class="line">Method method = clazz.getMethod(&quot;setName&quot;, String.class);</span><br><span class="line">Constructor constructor = clazz.getConstructor();</span><br><span class="line">Object object = constructor.newInstance();</span><br><span class="line">method.invoke(object,&quot;沉默王二&quot;);</span><br></pre></td></tr></table></figure>
<p>像上面这个例子，就可以理解为“反射”。</p>
<p>“反射的写法比正射复杂得多啊！”三妹感慨地说。</p>
<p>“是的，反射的成本是要比正射的高得多。”我说，“反射的缺点主要有两个。”</p>
<ul>
<li><strong>破坏封装</strong>：由于反射允许访问私有字段和私有方法，所以可能会破坏封装而导致安全问题。</li>
<li><strong>性能开销</strong>：由于反射涉及到动态解析，因此无法执行 Java 虚拟机优化，再加上反射的写法的确要复杂得多，所以性能要比“正射”差很多，在一些性能敏感的程序中应该避免使用反射。</li>
</ul>
<p>“那反射有哪些好处呢？”三妹问。</p>
<p>反射的主要应用场景有：</p>
<ul>
<li><strong>开发通用框架</strong>：像 Spring，为了保持通用性，通过配置文件来加载不同的对象，调用不同的方法。</li>
<li><strong>动态代理</strong>：在面向切面编程中，需要拦截特定的方法，就会选择动态代理的方式，而动态代理的底层技术就是反射。</li>
<li><strong>注解</strong>：注解本身只是起到一个标记符的作用，它需要利用发射机制，根据标记符去执行特定的行为。</li>
</ul>
<p>“好了，来看一下完整的例子吧。”我对三妹说。</p>
<p>Writer 类，有两个字段，然后还有对应的 getter/setter。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Writer &#123;</span><br><span class="line">    private int age;</span><br><span class="line">    private String name;</span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class ReflectionDemo1 &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException, </span><br><span class="line">NoSuchMethodException, IllegalAccessException, InvocationTargetException, </span><br><span class="line">InstantiationException &#123;</span><br><span class="line">        Writer writer = new Writer();</span><br><span class="line">        writer.setName(&quot;沉默王二&quot;);</span><br><span class="line">        System.out.println(writer.getName());</span><br><span class="line">        Class clazz = Class.forName(&quot;com.itwanger.s39.Writer&quot;);</span><br><span class="line">        Constructor constructor = clazz.getConstructor();</span><br><span class="line">        Object object = constructor.newInstance();</span><br><span class="line">        Method setNameMethod = clazz.getMethod(&quot;setName&quot;, String.class);</span><br><span class="line">        setNameMethod.invoke(object, &quot;沉默王二&quot;);</span><br><span class="line">        Method getNameMethod = clazz.getMethod(&quot;getName&quot;);</span><br><span class="line">        System.out.println(getNameMethod.invoke(object));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看一下输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">沉默王二</span><br><span class="line">沉默王二</span><br></pre></td></tr></table></figure>
<p>只不过，反射的过程略显曲折了一些。</p>
<p>第一步，获取反射类的 Class 对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(&quot;com.itwanger.s39.Writer&quot;);</span><br></pre></td></tr></table></figure>
<p>第二步，通过  Class 对象获取构造方法 Constructor 对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Constructor constructor = clazz.getConstructor();</span><br></pre></td></tr></table></figure>
<p>第三步，通过 Constructor 对象初始化反射类对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object object = constructor.newInstance();</span><br></pre></td></tr></table></figure>
<p>第四步，获取要调用的方法的 Method 对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Method setNameMethod = clazz.getMethod(&quot;setName&quot;, String.class);</span><br><span class="line">Method getNameMethod = clazz.getMethod(&quot;getName&quot;);</span><br></pre></td></tr></table></figure>
<p>第五步，通过 invoke() 方法执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setNameMethod.invoke(object, &quot;沉默王二&quot;);</span><br><span class="line">getNameMethod.invoke(object)</span><br></pre></td></tr></table></figure>
<p>“三妹，你看，经过这五个步骤，基本上就掌握了反射的使用方法。”我说。</p>
<p>“好像反射也没什么复杂的啊！”三妹说。</p>
<p>我先对三妹点点头，然后说：“是的，掌握反射的基本使用方法确实不难，但要理解整个反射机制还是需要花一点时间去了解一下 Java 虚拟机的类加载机制的。”</p>
<p>要想使用反射，首先需要获得反射类的 Class 对象，每一个类，不管它最终生成了多少个对象，这些对象只会对应一个 Class 对象，这个 Class 对象是由 Java 虚拟机生成的，由它来获悉整个类的结构信息。</p>
<p>也就是说， java.lang.Class 是所有反射 API 的入口。</p>
<p>而方法的反射调用，最终是由 Method 对象的 invoke() 方法完成的，来看一下源码（JDK 8 环境下）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public Object invoke(Object obj, Object... args)</span><br><span class="line">        throws IllegalAccessException, IllegalArgumentException,</span><br><span class="line">        InvocationTargetException &#123;</span><br><span class="line">    // 如果方法不允许被覆盖，进行权限检查</span><br><span class="line">    if (!override) &#123;</span><br><span class="line">        if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</span><br><span class="line">            Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">            // 检查调用者是否具有访问权限</span><br><span class="line">            checkAccess(caller, clazz, obj, modifiers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取方法访问器（从 volatile 变量中读取）</span><br><span class="line">    MethodAccessor ma = methodAccessor;</span><br><span class="line">    if (ma == null) &#123;</span><br><span class="line">        // 如果访问器为空，尝试获取方法访问器</span><br><span class="line">        ma = acquireMethodAccessor();</span><br><span class="line">    &#125;</span><br><span class="line">    // 使用方法访问器调用方法，并返回结果</span><br><span class="line">    return ma.invoke(obj, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个嵌套的 if 语句是用来进行权限检查的。</p>
<p>invoke() 方法实际上是委派给 MethodAccessor 接口来完成的。</p>
<p><img src="\assets\note\image-20231013105150453.png" alt="image-20231013105150453"></p>
<p>MethodAccessor 接口有三个实现类，其中的 MethodAccessorImpl 是一个抽象类，另外两个具体的实现类继承了这个抽象类。</p>
<p><img src="\assets\note\image-20231013105208523.png" alt="image-20231013105208523"></p>
<ul>
<li>NativeMethodAccessorImpl：通过本地方法来实现反射调用；</li>
<li>DelegatingMethodAccessorImpl：通过委派模式来实现反射调用；</li>
</ul>
<p>通过 debug 的方式进入 invoke() 方法后，可以看到第一次反射调用会生成一个委派实现 DelegatingMethodAccessorImpl，它在生成的时候会传递一个本地实现 NativeMethodAccessorImpl。</p>
<p><img src="\assets\note\image-20231013105254107.png" alt="image-20231013105254107"></p>
<p>也就是说， invoke() 方法在执行的时候，会先调用 DelegatingMethodAccessorImpl，然后调用 NativeMethodAccessorImpl，最后再调用实际的方法。</p>
<p>“为什么不直接调用本地实现呢？”三妹问。</p>
<p>“之所以采用委派实现，是为了能够在本地实现和动态实现之间切换。动态实现是另外一种反射调用机制，它是通过生成字节码的形式来实现的。如果反射调用的次数比较多，动态实现的效率就会更高，因为本地实现需要经过 Java 到 C/C++ 再到 Java 之间的切换过程，而动态实现不需要；但如果反射调用的次数比较少，反而本地实现更快一些。”我说。</p>
<p>“那临界点是多少呢？”三妹问。</p>
<p>“默认是 15 次。”我说，“可以通过 -Dsun.reflect.inflationThreshold 参数类调整。”</p>
<p>来看下面这个例子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Method setAgeMethod = clazz.getMethod(&quot;setAge&quot;, int.class);</span><br><span class="line">for (int i = 0;i &lt; 20; i++) &#123;</span><br><span class="line">    setAgeMethod.invoke(object, 18);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 invoke() 方法处加断点进入 debug 模式，当 i = 15 的时候，也就是第 16 次执行的时候，会进入到 if 条件分支中，改变 DelegatingMethodAccessorImpl 的委派模式 delegate 为 (MethodAccessorImpl)(new MethodAccessorGenerator()).generateMethod() ，而之前的委派模式 delegate 为 NativeMethodAccessorImpl。</p>
<p><img src="\assets\note\image-20231013105403871.png" alt="image-20231013105403871"></p>
<p>“这下明白了吧？三妹。”我说，“接下来，我们再来熟悉一下反射当中常用的 API。”</p>
<p><strong>1）获取反射类的 Class 对象</strong></p>
<p>Class.forName() ，参数为反射类的完全限定名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class c1 = Class.forName(&quot;com.itwanger.s39.ReflectionDemo3&quot;);</span><br><span class="line">System.out.println(c1.getCanonicalName());</span><br><span class="line">Class c2 = Class.forName(&quot;[D&quot;);</span><br><span class="line">System.out.println(c2.getCanonicalName());</span><br><span class="line">Class c3 = Class.forName(&quot;[[Ljava.lang.String;&quot;);</span><br><span class="line">System.out.println(c3.getCanonicalName());</span><br></pre></td></tr></table></figure>
<p>来看一下输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">com.itwanger.s39.ReflectionDemo3</span><br><span class="line">double[]</span><br><span class="line">java.lang.String[][]</span><br></pre></td></tr></table></figure>
<p>类名 + .class ，只适合在编译前就知道操作的 Class。。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class c1 = ReflectionDemo3.class;</span><br><span class="line">System.out.println(c1.getCanonicalName());</span><br><span class="line">Class c2 = String.class;</span><br><span class="line">System.out.println(c2.getCanonicalName());</span><br><span class="line">Class c3 = int[][][].class;</span><br><span class="line">System.out.println(c3.getCanonicalName());</span><br></pre></td></tr></table></figure>
<p>来看一下输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">com.itwanger.s39.ReflectionDemo3</span><br><span class="line">java.lang.String</span><br><span class="line">int[][][]</span><br></pre></td></tr></table></figure>
<p><strong>2）创建反射类的对象</strong></p>
<p>通过反射来创建对象的方式有两种：</p>
<ul>
<li>用 Class 对象的 newInstance() 方法。</li>
<li>用 Constructor 对象的 newInstance() 方法。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class c1 = Writer.class;</span><br><span class="line">Writer writer = (Writer) c1.newInstance();</span><br><span class="line">Class c2 = Class.forName(&quot;com.itwanger.s39.Writer&quot;);</span><br><span class="line">Constructor constructor = c2.getConstructor();</span><br><span class="line">Object object = constructor.newInstance();</span><br></pre></td></tr></table></figure>
<p><strong>3）获取构造方法</strong></p>
<p>Class 对象提供了以下方法来获取构造方法 Constructor 对象：</p>
<ul>
<li>getConstructor() ：返回反射类的特定 public 构造方法，可以传递参数，参数为构造方法参数对应 Class 对象；缺省的时候返回默认构造方法。</li>
<li>getDeclaredConstructor() ：返回反射类的特定构造方法，不限定于 public 的。</li>
<li>getConstructors() ：返回类的所有 public 构造方法。</li>
<li>getDeclaredConstructors() ：返回类的所有构造方法，不限定于 public 的。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class c2 = Class.forName(&quot;com.itwanger.s39.Writer&quot;);</span><br><span class="line">Constructor constructor = c2.getConstructor();</span><br><span class="line">Constructor[] constructors1 = String.class.getDeclaredConstructors();</span><br><span class="line">for (Constructor c : constructors1) &#123;</span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4）获取字段</strong></p>
<p>大体上和获取构造方法类似，把关键字 Constructor 换成 Field 即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Method setNameMethod = clazz.getMethod(&quot;setName&quot;, String.class);</span><br><span class="line">Method getNameMethod = clazz.getMethod(&quot;getName&quot;);</span><br></pre></td></tr></table></figure>
<p><strong>5）获取方法</strong></p>
<p>大体上和获取构造方法类似，把关键字 Constructor 换成 Method 即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Method[] methods1 = System.class.getDeclaredMethods();</span><br><span class="line">Method[] methods2 = System.class.getMethods();</span><br></pre></td></tr></table></figure>
<p>“注意，三妹，如果你想反射访问私有字段和（构造）方法的话，需要使用 Constructor/Field/Method.setAccessible(true) 来绕开 Java 语言的访问限制。”我说。</p>
<p>“好的，二哥。还有资料可以参考吗？”三妹问。</p>
<p>“有的，有两篇文章写得非常不错，你在学习反射的时候可以作为参考。”我说。</p>
<p>第一篇：深入理解 Java 反射和动态代理</p>
<blockquote>
<p>链接：<a target="_blank" rel="noopener" href="https://dunwu.github.io/javacore/basics/java-reflection.html">https://dunwu.github.io/javacore/basics/java-reflection.html</a></p>
</blockquote>
<p>第二篇：大白话说Java反射：入门、使用、原理：</p>
<blockquote>
<p>链接：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/chanshuyi/p/head_first_of_reflection.html">https://www.cnblogs.com/chanshuyi/p/head_first_of_reflection.html</a></p>
</blockquote>
<p>这里简单总结下。</p>
<p>反射是 Java 中的一个强大特性，它允许在运行时检查和操作类、接口、字段和方法。反射是 Java 的核心组件，支持各种框架和库的实现，如 Spring、Hibernate 等。使用反射，可以在运行时动态地创建对象、调用方法和访问字段，而无需在编译时了解这些对象的具体实现。</p>
<p>反射的主要类位于 java.lang.reflect 包中，主要包括以下几个关键类：</p>
<ul>
<li>Class：代表一个类或接口，包含了类的结构信息（如名称、构造函数、方法、字段等）。通过 Class 对象，可以获取类的元数据并操作类的实例。</li>
<li>Constructor：代表类的构造方法，用于创建类的实例。</li>
<li>Method：代表类的方法，可以通过它调用类的实例方法。</li>
<li>Field：代表类的字段，可以获取或修改字段的值。</li>
<li>Modifier：包含方法、字段和类的访问修饰符（如 public、private 等）。</li>
</ul>
<p>使用反射时，需要注意以下几点：</p>
<ul>
<li>性能：反射操作通常比直接操作对象的方法和字段慢，因为涉及到额外的间接调用和动态解析。因此，在关注性能的场景中，慎用反射。</li>
<li>安全性：通过反射，可以访问和操作类的私有字段和方法，这可能导致安全问题。因此，使用反射时要确保代码的安全性。</li>
<li>维护性：反射使代码变得更加复杂，可能导致难以维护。在使用反射时要确保代码的可读性和可维护性。</li>
</ul>
<p>尽管反射存在上述问题，但在某些场景下（如框架开发、动态代理等），它仍然是非常有用的工具。</p>
<p>来一个完整的 demo 示例吧。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    public Person() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public Person(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    private void privateMethod() &#123;</span><br><span class="line">        System.out.println(&quot;私有方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ReflectionDemo &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException,</span><br><span class="line">            IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchFieldException &#123;</span><br><span class="line">        // 获取 Person 类的 Class 对象</span><br><span class="line">        Class&lt;?&gt; personClass = Class.forName(&quot;com.github.paicoding.forum.test.javabetter.importance.Person&quot;);</span><br><span class="line">        // 获取并打印类名</span><br><span class="line">        System.out.println(&quot;类名: &quot; + personClass.getName());</span><br><span class="line">        // 获取构造函数</span><br><span class="line">        Constructor&lt;?&gt; constructor = personClass.getConstructor(String.class, int.class);</span><br><span class="line">        // 使用构造函数创建 Person 对象实例</span><br><span class="line">        Object personInstance = constructor.newInstance(&quot;沉默王二&quot;, 30);</span><br><span class="line">        // 获取并调用 getName 方法</span><br><span class="line">        Method getNameMethod = personClass.getMethod(&quot;getName&quot;);</span><br><span class="line">        String name = (String) getNameMethod.invoke(personInstance);</span><br><span class="line">        System.out.println(&quot;名字: &quot; + name);</span><br><span class="line">        // 获取并调用 setAge 方法</span><br><span class="line">        Method setAgeMethod = personClass.getMethod(&quot;setAge&quot;, int.class);</span><br><span class="line">        setAgeMethod.invoke(personInstance, 35);</span><br><span class="line">        // 获取并访问 age 字段</span><br><span class="line">        Field ageField = personClass.getDeclaredField(&quot;age&quot;);</span><br><span class="line">        ageField.setAccessible(true);</span><br><span class="line">        int age = ageField.getInt(personInstance);</span><br><span class="line">        System.out.println(&quot;年纪: &quot; + age);</span><br><span class="line">        // 获取并调用私有方法</span><br><span class="line">        Method privateMethod = personClass.getDeclaredMethod(&quot;privateMethod&quot;);</span><br><span class="line">        privateMethod.setAccessible(true);</span><br><span class="line">        privateMethod.invoke(personInstance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们首先通过 Class.forName() 方法获取 Person 类的 Class 对象。接着，我们获取了 Person 类的构造方法、方法和字段，并使用这些反射对象来创建实例、调用方法和访问字段。注意，在访问私有方法和字段时，我们需要调用 setAccessible(true) 方法来允许访问。</p>
<p>“好了，三妹，关于反射，就先讲到这里吧。”</p>
<h1 id="12-Java并发编程"><a href="#12-Java并发编程" class="headerlink" title="12 Java并发编程"></a>12 Java并发编程</h1><p>众所周知，Java 并发是 Java 程序员必须懂但又很难懂的一块知识点。一般来说，很少有人敢说自己精通 Java 并发的，一是容易被面试官吊打，二是并发编程涉及到操作系统、内存、CPU 等计算机专业比较核心的内容，比较考验一个程序员的内功。</p>
<p>这里就顺带给你盘点一下 Java 并发到底该如何从入门到精通，请及时用鸡毛掸子把收藏夹里的灰清理一下。在阅读过程中，如果有所帮助，麻烦默默收藏和主动转发，算是对我码字的这份坚持的亿点点鼓励。</p>
<p><strong>一、为什么要学 Java 并发？ </strong></p>
<p>有句话不知道当讲不当讲，先讲了再说，就是“如果你只想 CURD，那么 Java 并发不学也罢！”但其实呢，大家都已经被教育的很有涵养了，工作中拧不拧螺丝不重要，重要的是面试一定要会造火箭，不然面试的机会都很难捞得到。</p>
<p>那作为 Java 体系中非常重要的一环，Java 并发自然是必须要掌握的，最起码也得会起个多线程吧？哈哈哈。高级点的，像平常开发中用到的 Tomcat 服务器、消息中间件、RPC 框架等等，它们的底层都涉及到了并发编程。</p>
<p>当然了，Java 并发涉及到东西实在是不少，包括操作系统的知识，Java 虚拟机的一些知识，Java 线程模型的知识，多线程相关的关键字，比如说 synchronized、volatile 等，还有锁的知识、JDK 提供的工具类等等，学起来还是非常容易令人头大的。</p>
<p>因此，我们需要一些高效的学习路线图，以及一些优质的学习资源，从而减少我们学习Java 并发编程所投入的时间和精力。</p>
<p><strong>二、Java 并发学习路线图 </strong></p>
<p>这是我最近整理的一张关于 Java 并发编程的思维导图，大的方向可以分为三个部分：线程基础、理论基础、工具类 JUC。</p>
<p><img src="\assets\note\image-20231013113116011.png" alt="image-20231013113116011"></p>
<p>线程基础部分包括：</p>
<ul>
<li>线程的创建方式</li>
<li>线程的状态切换</li>
<li>线程的基本操作</li>
<li>线程组和线程优先级</li>
</ul>
<p>理论基础包括：</p>
<ul>
<li>进程和线程的区别</li>
<li>多线程解决了什么问题，又带来了什么问题？</li>
<li>如何解决并发问题？包括 Java 内存模型，以及两个常见的关键字 volatile 和 synchronized</li>
</ul>
<p>工具类 JUC 包括：</p>
<ul>
<li>锁 Lock 系的 AQS、ReentrantLock、ReentrantReadWriteLock、Condition、LockSupport</li>
<li>并发容器系的 ConcurrentHashMap、ConcurrentLinkedQueue、CopyOnWriteArrayList、ThreadLocal、BlockingQueue</li>
<li>线程池系的 ThreadPoolExecutor、ScheduledThreadPoolExecutor</li>
<li>原子系的 AtomicInteger、AtomicIntegerArray、AtomicReference 等等</li>
<li>通信工具系的倒计时器 CountDownLatch、循环栅栏 CyclicBarrier、资源访问控制 Semaphore、数据交换 Exchanger、移相器Phaser</li>
<li>Fork/Join框架</li>
</ul>
<p>最后再来个经典的生产者消费者模式进行实践，整个 Java 并发体系就学得非常扎实了！</p>
<p><strong>三、硬核 Java 并发学习资料</strong></p>
<p><strong>1）Java进阶之路 </strong></p>
<p>学 Java，当然要找二哥的Java进阶之路，网址我贴下面了哈：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://tobebetterjavaer.com/home.html">https://tobebetterjavaer.com/home.html</a></p>
</blockquote>
<p>进去直接找 Java 核心里面的 Java 并发编程就对了。我按照前面的思维导图整理了 29 篇文章，全部都是硬核级别的，跟着学就对了。<br> 学Java，就认准二哥的Java进阶之路</p>
<p><img src="\assets\note\image-20231013115054038.png" alt="image-20231013115054038"></p>
<p><strong>2）视频 </strong> </p>
<p>懂的都懂，看视频到 B 站。黑马的《Java并发编程》评价还不错，300 多个小节，我觉得讲的比较好的有三部分：synchronized优化原理、AQS和线程池。</p>
<p><img src="\assets\note\image-20231013115239365.png" alt="image-20231013115239365"></p>
<blockquote>
<p>视频地址：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV16J411h7Rd">https://www.bilibili.com/video/BV16J411h7Rd</a></p>
</blockquote>
<p>还有尚硅谷宋红康老师讲的这个视频。</p>
<p><img src="\assets\note\image-20231013115301073.png" alt="image-20231013115301073"></p>
<blockquote>
<p>视频地址：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Kw411Z7dF/">https://www.bilibili.com/video/BV1Kw411Z7dF/</a></p>
</blockquote>
<p><strong>3）书籍 </strong></p>
<p>纸质书只推荐一本《Java 并发编程实战》，豆瓣评分 9.0。不过这本书确实有点老了，基本上是按照 Java 6 来讲解的，希望出版社能早点出 2.0 版。</p>
<p><img src="\assets\note\image-20231013115339024.png" alt="image-20231013115339024"></p>
<p>《Java 并发编程实战》这本书从总体上来看，分两条主线：</p>
<ul>
<li>介绍 Java 并发包的重要组件和原理</li>
<li>如何利用这些组件来保证线程安全</li>
</ul>
<p>到底该如何获得线程安全呢？背会并理解下面这段话：</p>
<blockquote>
<p>Writing thread-safe code is, at its core, about managing access to state, and in particular to shared, mutable state.</p>
</blockquote>
<p>如果发现不是很好懂，想从国内作者下手的话，可以尝试一下《Java并发编程的艺术》和《图解Java并发编程》这两本书，虽然豆瓣上评分一般，但对于构建 Java 并发的知识体系还是有很大帮助的。</p>
<p>之后，再去啃《Java 并发编程实战》就会发现没有以前那么费劲了，这本书之所以被誉为 Java 并发编程的圣经，确实可以看得出作者在并发编程方面有着丰富的经验。</p>
<p><strong>4）开源电子书 </strong></p>
<p>推荐 RedSpider社区的深入浅出 Java 多线程，比Java 并发编程实战更通俗易懂一些，因为里面穿插了很多精美的手绘图。</p>
<p><img src="\assets\note\image-20231013115454424.png" alt="image-20231013115454424"></p>
<blockquote>
<p>GitHub地址：<a target="_blank" rel="noopener" href="https://github.com/RedSpider1/concurrent">https://github.com/RedSpider1/concurrent</a></p>
</blockquote>
<p>再推荐一份 GitHub 上星标 3.6k+ 的 Java 并发知识点总结：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/CL0610/Java-concurrency">https://github.com/CL0610/Java-concurrency</a></p>
</blockquote>
<p>仓库里有一句话我非常喜欢，也分享给各位小伙伴：</p>
<p>努力的意义，就是，在以后的日子里，放眼望去全是自己喜欢的人和事！</p>
<p><strong>5）付费专栏 </strong></p>
<p>王宝令老师在极客时间上开了一门《Java 并发编程实战》的付费专栏，质量还是挺高的，喜欢的小伙伴可以去购买。</p>
<p><strong>四、优质八股文 </strong></p>
<p>这里给大家推荐两份 Java 并发编程方面的八股文，一份来自三分恶滴滴的面渣逆袭，一份来自小牛，先截图给大家看一下 Java 并发方面都有哪些高频的面试题。</p>
<p>为了方便大家的阅读和背诵，我已经将其整理到了二哥的小破站《Java进阶之路》上，面渣逆袭 Java 并发篇：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://tobebetterjavaer.com/sidebar/sanfene/javathread.html">https://tobebetterjavaer.com/sidebar/sanfene/javathread.html</a></p>
</blockquote>
<p>Java 并发编程八股文（背诵版）：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://tobebetterjavaer.com/baguwen/java-thread.html">https://tobebetterjavaer.com/baguwen/java-thread.html</a></p>
</blockquote>
<p>这两份八股文的质量都非常高，来看一下AQS了解多少小节下的内容，图文并茂，非常容易消化和吸收。’’</p>
<p>诚实点说，如果能把这两份八股文背会的话，简历上就真的敢写“精通”Java 并发了。</p>
<p><strong>五、Java 并发学习心得 </strong></p>
<p>Java 提供的并发组件，大致可以分为两类：</p>
<ul>
<li>从预防阶段下手，防止错误发生，比如说 synchronized 关键字</li>
<li>一旦发生错误能及时重试，比如说 CAS</li>
</ul>
<p>对于线程数量比较多的并发场景，采用预防的措施会比较合理，这样大部分线程就不会因为小概率时间的 CAS 重试浪费掉大量的 CPU 周期；在线程数量小的时候，CAS 的意义就比较大，因为预防措施带来的线程切换要比 CAS 等待的开销更大。</p>
<p>想要学好 Java 并发编程，就必须得对下图中提到的基础概念进行充分的理解。</p>
<p><img src="\assets\note\image-20231013120107723.png" alt="image-20231013120107723"></p>
<p>在我看来，并发编程主要是用来解决这两个痛点的：</p>
<ul>
<li>多个线程对同一变量造成的不一致问题；</li>
<li>为提高性能，计算机的很多执行单元都配备了缓存，那势必会影响并发编程的数据一致性。</li>
</ul>
<p>需要提醒一点的是，多线程并发虽然是用来解决性能问题的，但并不意味着所有情况下都需要开启多线程，有时候反而会适得其反，那如果不是特别要求，尽量不要过早开启多线程。</p>
<p>并发编程是 Java 体系当中相对难掌握的一块知识点，比较考验一名程序员的内功，其实并发编程最早的应用领域就是操作系统的实现。</p>
<p>如果你已经有一定的编程经验，建议先学一下《计算机组成原理》，对操作系统、内存、CPU 先进行一些大致的了解，然后再来学习 Java 并发编程，可能就会感觉舒服多了！</p>
<p>结合我多年的工作经验来看，并发编程可以抽象成三个核心问题：分工、同步和互斥。</p>
<p>1）分工</p>
<p>分工指的是如何高效地拆解任务并分配给线程，像并发编程领域的一些设计模式，比如说生产者与消费者就是用来进行分工的。</p>
<p>2）同步</p>
<p>同步指的是线程之间如何协作，一个线程执行完了一个任务，要通知另外一个线程开工。还拿生产者-消费者模型来说吧，当队列满的时候，生产者线程等待，当队列不满的时候，生产者线程需要被唤醒重新执行；当队列空的时候，消费者线程开始等待，不空的时候，消费者线程被重新唤醒。</p>
<p>3）互斥</p>
<p>互斥指的是保证同一时刻只有一个线程访问共享资源，是解决线程安全问题的杀手锏。</p>
<p>当多个线程同时访问一个共享变量的时候，很容易出现“线程安全”问题，因为结果可能是不确定的——导致出现这个问题的根源就是可见性、有序性和原子性——为了解决它们，Java 引入了内存模型的概念，可以在一定程度上缓解“线程安全”的问题，但要想完全解决“线程安全”问题，还得靠互斥。</p>
<p>互斥的核心技术就是锁，比如说 synchronized，还有各种 Lock。</p>
<p>锁可以解决线程安全的问题，但同时也就意味着程序的性能要受到影响。</p>
<p>因此，Java 提供了针对不同场景下的锁，比如说读写锁 ReadWriteLock，可以解决多线程同时读，但只有一个线程能写的问题；但 ReadWriteLock 也有自己的问题，就是如果有线程正在读，写线程需要等待度线程释放锁后才能获得写锁，也就是读的过程中不允许写，属于一种悲观的读锁。</p>
<p>为了进一步提升并发执行的效率，Java 8 引入了一个新的读写锁 StampedLock，与ReadWriteLock 相比，StampedLock的优势在于读的过程中也允许获取写锁后写入，但带来的问题就是可能读的数据不一致，需要一点额外的代码来判断读的过程中是否有写入，本质上是一种乐观的锁。</p>
<p>乐观锁的意思就是估计读的过程中大概率不会有写入，而悲观锁则是读的过程中拒绝有写入，两者的区别就在于性能上会有差异，乐观锁需要针对小概率事件进行多一步的检测，但性能也会有所提升；悲观锁更能保证“线程安全性”。</p>
<p>听我这么一说，是不是一下子就清晰多了！</p>
<h1 id="13-JVM（Java-虚拟机）"><a href="#13-JVM（Java-虚拟机）" class="headerlink" title="13 JVM（Java 虚拟机）"></a>13 JVM（Java 虚拟机）</h1><p>2020 年的时候，通读了一遍周志明老师的《深入理解 Java 虚拟机：JVM 高级特性与最佳实践》第三版，读完之后受益匪浅，这让我对 Java 虚拟机有了一个更完整的认识。毫无疑问，《深入理解 Java 虚拟机》是 JVM 书籍中最好的一本书了，国产技术书的天花板。</p>
<p><img src="\assets\note\image-20231013120627618.png" alt="image-20231013120627618"></p>
<p>在金三银四/金九银十的跳槽季中，很多小伙伴都会忍不住蠢蠢欲动，其中 JVM 更是面试中不可或缺的一部分，所以我花了几天的时间整理了一条 JVM 的学习路线，希望能帮助到大家。</p>
<p><strong>一、为什么要学习 JVM？ </strong></p>
<p>曾经我对 JVM 也是感到非常的头痛，完全搞不懂该怎么入门，只是听说《深入理解 Java 虚拟机》这本书很吊，但真读起来，却需要极大的耐心和定力，否则很快就会在读完第一章 JVM 的简史后放弃。</p>
<p>那首先，我们就要搞清楚，为什么要学习 JVM ？</p>
<p>第一，当然是面试要考，这一点毫无疑问，尤其是对于要参加校招的应届生来说，JVM 是绕不过去的，必须得学。</p>
<p>第二，如果你想成为公司不可或缺的顶梁柱，那 JVM 你得学，因为一般情况下，遇到的问题基本上 Google 下就能解决了，可一旦遇到 JVM 性能调优，就必须得有能查 OOM 的原因、能看懂字节码的老鸟出马了。</p>
<p>应用程序一旦上线，出问题是板上钉钉的事，除了数据库、网络、代码逻辑上的问题，剩下的就有内存溢出啊，频繁 GC 导致的性能瓶颈啊等棘手问题。</p>
<p>遇到这种问题，你就必须得能看懂 GC 日志，明白什么是老年代、永久代、元数据区等，这些都是 Java 虚拟机方面的知识。</p>
<p>明白了学习 JVM 的重要性，那我们就开搞吧！</p>
<p><strong>二、JVM 学习路线图 </strong></p>
<p>这是我最近整理的一张关于 JVM 的思维导图，大的方向可以分为三个部分：字节码与类的加载、内存与垃圾回收、性能监控和调优。</p>
<p><img src="\assets\note\image-20231013121027362.png" alt="image-20231013121027362"></p>
<p><img src="\assets\note\image-20231013121309134.png" alt="image-20231013121309134"></p>
<p>字节码与类的加载包括：</p>
<ul>
<li>类的加载机制（类的加载过程、类加载器、双亲委派模型）</li>
<li>字节码（类文件结构、字节码指令、字节码执行引擎、实战字节码）</li>
</ul>
<p>内存与垃圾回收包括：</p>
<ul>
<li>JVM 内存结构</li>
<li>垃圾回收算法</li>
<li>垃圾回收机制</li>
<li>垃圾收集器</li>
</ul>
<p>性能监控和调优包括：</p>
<ul>
<li>调优指标</li>
<li>调优对象</li>
<li>调优工具</li>
<li>JIT 优化</li>
</ul>
<p>有理论知识，有动手实战，基本上可以把 JVM 这块学的非常扎实了。</p>
<p><strong>四、学习 JVM 的一点小心得 </strong></p>
<p>和 C++ 相比，Java 的内存管理机制可以说是一大特色，Java 开发不再需要自己去写代码手动释放内存，甚至你想自己干，JVM 都不给你这个机会，虚拟机完全掌握了 Java 内存的控制权。</p>
<p>这看起来挺美好的，但并不意味着Java 开发就可以随意写代码，随意使用内存，从我多年的使用体验来看，内存溢出和内存泄露还是会时不时发生的，尤其是初学阶段，尤其在开启多线程的情况下。</p>
<p>一旦出现内存溢出或者内存泄露，排查问题还是挺困难的，所以知道逊尼基到底是怎么管理内存的就变得十分重要了。</p>
<p>JVM 的垃圾回收，其实就是收拾那些不再使用的 Java 对象，把他们曾经占用的内存重新释放出来。所以我们要搞清楚：</p>
<p>对象是如何创建的？对象是如何被访问的？到底哪些对象是废弃的？于是我们就需要搞清楚对象的生和死。</p>
<p>这些废弃了的对象到底放在哪？于是就需要了解JVM 的内存结构：方法区、堆、程序计数器、虚拟机栈和本地方法栈。</p>
<p>这些废弃了的对象会不会造成内存泄露（OOM，OutOfMemoryError）？于是我们就需要了解每个分区的 OOM。</p>
<p>这些废弃了对象什么时候被回收？于是我们就需要了解垃圾回收算法，比如说清除算法、复制算法、标记整理算法和分代收集算法。</p>
<p>知道了一个对象在内存中的生和死，我们还需要知道类是如何在内存中变成对象的？对象的方法是如何执行的？</p>
<p>于是我们开始学习 Java 虚拟机的执行过程，学习字节码文件（ .class 文件），学习类的加载机制，学习虚拟机栈的栈帧结构，学习方法的调用过程，学习字节码指令等等。</p>
<p>为了监控虚拟机和故障排查，我们需要学习常用的 JDK 命令行工具，掌握必要的线上问题排查方法；此外，还需要了解 JIT (Just In Time)并不是简单的将热点代码编译成机器码就收工的，它还会对代码的执行进行优化（方法内联和逃逸分析）。</p>
<p>JVM 相关的知识已经成为面试必考的科目了，但老实讲，JVM 相关的知识还真的不太好用在项目中，或者说不太好在项目中体现出来。</p>
<p>那这里给大家推荐一个实战项目，基于 Spring Boot 的在线 Java IDE，可以远程执行 Java 代码并将程序的运行结果反馈出来。涉及了 Java 类文件的结构、Java 类加载器和 Java 类的热替换等 JVM 相关的技术。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/TangBean/OnlineExecutor">https://github.com/TangBean/OnlineExecutor</a></p>
</blockquote>
<p>听我这么一说，是不是一下子就清晰多了！</p>
<p>Java 虚拟机虽然难学，但如果你能坚持学下去，内功自然而然就提升了一大截。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://whalerest.top">鲸落</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://whalerest.top/posts/bb381fef.html">https://whalerest.top/posts/bb381fef.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://whalerest.top" target="_blank">鲸落</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB/">常用工具类</a><a class="post-meta__tags" href="/tags/Java%E6%96%B0%E7%89%B9%E6%80%A7/">Java新特性</a><a class="post-meta__tags" href="/tags/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">Java网络编程</a><a class="post-meta__tags" href="/tags/Java-NIO/">Java NIO</a><a class="post-meta__tags" href="/tags/Java%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9/">Java重要知识点</a><a class="post-meta__tags" href="/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">Java并发编程</a><a class="post-meta__tags" href="/tags/JVM%EF%BC%88java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%89/">JVM（java虚拟机）</a></div><div class="post_share"><div class="social-share" data-image="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/assets/weplay.png" target="_blank"><img class="post-qr-code-img" src="/assets/weplay.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/assets/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/assets/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/c13307dc.html" title="java进阶之路（一）"><img class="cover" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">java进阶之路（一）</div></div></a></div><div class="next-post pull-right"><a href="/posts/c15068a.html" title="Java进阶之路（三）"><img class="cover" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java进阶之路（三）</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/assets/mmexport1694508539292.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">鲸落</div><div class="author-info__description">随波不逐流</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">281</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">243</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/htx-rest"><i class="fab fa-github"></i><span>前往小窝</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="/assets/wenxin.jpg" target="_blank" title="微信"><i class="iconfont icon-weixin" style="color: #24292e;"></i></a><a class="social-icon" href="/assets/weixingongzhonghao.jpg" target="_blank" title="微信公众号"><i class="iconfont icon-weixingongzhonghao" style="color: #24292e;"></i></a><a class="social-icon" href="https://res.abeim.cn/api/qq/?qq=1656855152" target="_blank" title="QQ"><i class="iconfont icon-QQ" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:1656855152@qq.com" target="_blank" title="QQ邮箱"><i class="iconfont icon-youxiang" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">微信关注公众号“二哈学习之路”，回复“面渣笔记”，领取面试八股文！！！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">7 常用工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-Scanner%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">7.1 Scanner工具类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-Arrays%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">7.2 Arrays工具类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-StringUtils%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">7.3 StringUtils工具类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-Objects%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">7.4 Objects工具类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5-Collections%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">7.5 Collections工具类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-6-Hutool%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%BA%93"><span class="toc-text">7.6 Hutool工具类库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-7-Guava%E5%B7%A5%E5%85%B7%E5%BA%93"><span class="toc-text">7.7 Guava工具库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-8-%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">7.8 其他常用工具类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-Java%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">8 Java新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-%E6%8E%8C%E6%8F%A1Stream%E6%B5%81"><span class="toc-text">8.1 掌握Stream流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-Optional%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97"><span class="toc-text">8.2 Optional最佳指南</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BALambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">8.3 深入浅出Lambda表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4-Java-14-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">8.4 Java 14 新特性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-Java-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-text">9 Java 网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-%E4%BA%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text">9.1 了解网络编程的基础知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E6%A0%B8%E5%BF%83%E5%A5%97%E6%8E%A5%E5%AD%97Socket"><span class="toc-text">9.2 网络编程的核心套接字Socket</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-%E7%94%A8Socket%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAHTTP%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-text">9.3 用Socket实现一个HTTP服务器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-Java-NIO"><span class="toc-text">10 Java NIO</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#10-1-NIO%E6%AF%94IO%E5%BC%BA%E5%9C%A8%E5%93%AA%EF%BC%9F"><span class="toc-text">10.1 NIO比IO强在哪？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-2-BIO%E3%80%81NIO-%E5%92%8C-AIO-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">10.2 BIO、NIO 和 AIO 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-3-Buffer%E5%92%8CChannel"><span class="toc-text">10.3 Buffer和Channel</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-4-Paths-%E5%92%8C-Files"><span class="toc-text">10.4 Paths 和 Files</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-5-NIO-%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E7%89%88%E8%81%8A%E5%A4%A9%E5%AE%A4"><span class="toc-text">10.5 NIO 实现简易版聊天室</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-6-Java-IO%E6%A8%A1%E5%9E%8B"><span class="toc-text">10.6 Java IO模型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-Java-%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-text">11 Java 重要知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-1-Java%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-text">11.1 Java命名规范</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-2-%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E5%8F%8A%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E5%85%A8%E6%94%BB%E7%95%A5"><span class="toc-text">11.2 中文乱码及字符编码全攻略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-3-%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Java%E4%B8%AD%E7%9A%84%E6%8B%86%E7%AE%B1%E5%92%8C%E8%A3%85%E7%AE%B1"><span class="toc-text">11.3 深入剖析Java中的拆箱和装箱</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-4-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-text">11.4 深入理解Java浅拷贝与深拷贝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-5-Java-hashCode%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90"><span class="toc-text">11.5 Java hashCode方法解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-6-Java%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%EF%BC%9F"><span class="toc-text">11.6 Java是值传递还是引用传递？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-7-Java%E4%B8%BA%E4%BB%80%E4%B9%88%E6%97%A0%E6%B3%95%E5%AE%9E%E7%8E%B0%E7%9C%9F%E6%AD%A3%E7%9A%84%E6%B3%9B%E5%9E%8B"><span class="toc-text">11.7 Java为什么无法实现真正的泛型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-8-%E6%8E%8C%E6%8F%A1-Java-%E5%8F%8D%E5%B0%84"><span class="toc-text">11.8 掌握 Java 反射</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="toc-text">12 Java并发编程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13-JVM%EF%BC%88Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%89"><span class="toc-text">13 JVM（Java 虚拟机）</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 By 鲸落</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">I wish you to become your own sun, no need to rely on who's light.</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async src="https://cdn1.tianli0.top/npm/vue@2.6.14/dist/vue.min.js"></script><script async src="https://cdn1.tianli0.top/npm/element-ui@2.15.6/lib/index.js"></script><script async src="https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script><script defer type="text/javascript" src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script defer src="https://cdn1.tianli0.top/gh/nextapps-de/winbox/dist/winbox.bundle.min.js"></script><script async src="//at.alicdn.com/t/c/font_4233300_xxm4hpxio1.js"></script><script async src="/js/fps.js"></script><script async src="https://cdn.wpon.cn/2022-sucai/Gold-ingot.js"></script><script defer data-pjax src="/js/cat.js"></script><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><canvas id="snow"></canvas><script defer src="/js/fomal.js"></script><script defer src="/js/cursor.js"></script><script defer src="/live2d-widget/autoload.js"></script><script async src="/js/title.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var qweather_key = 'b16a1fa0e63c46a4b8f28abfb06ae3fe';
  var gaud_map_key = 'e2b04289e870b005374ee030148d64fd&s=rsv3';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '113.34532,23.15624';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 190px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 160px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(http://p0.itc.cn/images03/20200525/332e1ea10c634cbfaf0dfc5b69d00a3c.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Java笔试编程真题/&quot;);" href="javascript:void(0);">Java笔试编程真题</a><span class="categoryBar-list-count">223</span><span class="categoryBar-list-descr">Docker</span></li><li class="categoryBar-list-item" style="background:url(http://p8.itc.cn/images03/20200525/377f4f7044fe49b0bb932f43ef4f4891.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Docker/&quot;);" href="javascript:void(0);">Docker</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr">Hexo魔改教程</span></li><li class="categoryBar-list-item" style="background:url(http://p8.itc.cn/images03/20200525/0ed549edde2c4d5eaecc2824e753ca74.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Hexo魔改教程/&quot;);" href="javascript:void(0);">Hexo魔改教程</a><span class="categoryBar-list-count">12</span><span class="categoryBar-list-descr">MySQL</span></li><li class="categoryBar-list-item" style="background:url(http://p6.itc.cn/images03/20200525/8dedcdf6ace44a50a1deb6a9743821fe.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/面试题/&quot;);" href="javascript:void(0);">面试题</a><span class="categoryBar-list-count">10</span><span class="categoryBar-list-descr">面试题</span></li><li class="categoryBar-list-item" style="background:url(http://p8.itc.cn/images03/20200525/5f6cecf10ea04dec9a5d42bf9c4c3739.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/面渣笔记/&quot;);" href="javascript:void(0);">面渣笔记</a><span class="categoryBar-list-count">15</span><span class="categoryBar-list-descr">Redis</span></li><li class="categoryBar-list-item" style="background:url(http://p0.itc.cn/images03/20200525/332e1ea10c634cbfaf0dfc5b69d00a3c.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/MySQL/&quot;);" href="javascript:void(0);">MySQL</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr">Java笔试编程真题</span></li><li class="categoryBar-list-item" style="background:url(http://p8.itc.cn/images03/20200525/377f4f7044fe49b0bb932f43ef4f4891.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/RabbitMQ/&quot;);" href="javascript:void(0);">RabbitMQ</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr">Java数据结构与算法</span></li><li class="categoryBar-list-item" style="background:url(http://p8.itc.cn/images03/20200525/0ed549edde2c4d5eaecc2824e753ca74.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Redis/&quot;);" href="javascript:void(0);">Redis</a><span class="categoryBar-list-count">5</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(http://p6.itc.cn/images03/20200525/8dedcdf6ace44a50a1deb6a9743821fe.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Kafka/&quot;);" href="javascript:void(0);">Kafka</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/leetcode/&quot;);" href="javascript:void(0);">leetcode</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/面试/&quot;);" href="javascript:void(0);">面试</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/设计模式/&quot;);" href="javascript:void(0);">设计模式</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Java数据结构与算法/&quot;);" href="javascript:void(0);">Java数据结构与算法</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v6.2.0" title=""><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.9.0" title=""><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="https://npm.elemecdn.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.js"></script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/f51f72fb.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-06</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/f51f72fb.html&quot;);" href="javascript:void(0);" alt="">美团2024届秋招笔试第二场编程真题（2023.8.19）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/f51f72fb.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/91acfbaf.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/91acfbaf.html&quot;);" href="javascript:void(0);" alt="">蚂蚁校招编程真题及其解析（2023.4.20）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/91acfbaf.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/b5cfa224.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/b5cfa224.html&quot;);" href="javascript:void(0);" alt="">蚂蚁校招编程真题及其解析（2023.5.18）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/b5cfa224.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/a366af84.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/a366af84.html&quot;);" href="javascript:void(0);" alt="">蚂蚁校招编程真题及其解析（2023.4.4）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/a366af84.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/ecb7a244.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/ecb7a244.html&quot;);" href="javascript:void(0);" alt="">蚂蚁校招编程真题及其解析（2023.3.21）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/ecb7a244.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/6eb0e61a.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/6eb0e61a.html&quot;);" href="javascript:void(0);" alt="">蚂蚁校招编程真题及其解析（2023.4.11）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/6eb0e61a.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/b1a216eb.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/b1a216eb.html&quot;);" href="javascript:void(0);" alt="">蚂蚁校招编程真题及其解析（2022.10.27）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/b1a216eb.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/7b50e04c.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/7b50e04c.html&quot;);" href="javascript:void(0);" alt="">美团校招笔试编程真题（2023.5.13）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/7b50e04c.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/9ed49519.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/9ed49519.html&quot;);" href="javascript:void(0);" alt="">网易有道校招笔试编程真题及其解析（2023.4.2）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/9ed49519.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/1b4308aa.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-17</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/1b4308aa.html&quot;);" href="javascript:void(0);" alt="">美团校招笔试编程真题（2023.4.8）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/1b4308aa.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/a449f40d.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-22</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/a449f40d.html&quot;);" href="javascript:void(0);" alt="">美的校招笔试编程真题（2023.4.19）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/a449f40d.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/b2891dfd.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-14</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/b2891dfd.html&quot;);" href="javascript:void(0);" alt="">美团校招笔试编程真题（2023.3.11）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/b2891dfd.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/f53a714c.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/f53a714c.html&quot;);" href="javascript:void(0);" alt="">美团校招笔试编程真题（2023.4.29）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/f53a714c.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/9a879128.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/9a879128.html&quot;);" href="javascript:void(0);" alt="">美团校招笔试编程真题（2023.4.23）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/9a879128.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/f84cb424.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-17</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/f84cb424.html&quot;);" href="javascript:void(0);" alt="">美团校招笔试编程真题（2023.4.15）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/f84cb424.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/cf815277.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-15</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/cf815277.html&quot;);" href="javascript:void(0);" alt="">美团校招笔试编程真题（2023.3.18）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/cf815277.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/843d6f38.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/843d6f38.html&quot;);" href="javascript:void(0);" alt="">美团校招笔试编程真题及其解析（2023.3.4）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/843d6f38.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/6482affa.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/6482affa.html&quot;);" href="javascript:void(0);" alt="">美团校招笔试编程真题及其解析（2023.3.25）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/6482affa.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/7a556a2f.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-14</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/7a556a2f.html&quot;);" href="javascript:void(0);" alt="">美团2024届秋招笔试编程真题（2023.9.9）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/7a556a2f.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/61f68248.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/61f68248.html&quot;);" href="javascript:void(0);" alt="">美团2024届秋招笔试第四场编程真题（2023.9.2）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/61f68248.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/5b7a3f2a.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-07</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/5b7a3f2a.html&quot;);" href="javascript:void(0);" alt="">美团2024届秋招笔试第三场编程真题（2023.8.26）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/5b7a3f2a.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/860131f4.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-04</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/860131f4.html&quot;);" href="javascript:void(0);" alt="">美团2024届秋招笔试第一场编程真题（2023.8.12）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/860131f4.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/815405c2.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/815405c2.html&quot;);" href="javascript:void(0);" alt="">科大讯飞校招笔试编程真题及其解析（2023.8.13）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/815405c2.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/f766fbc2.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/f766fbc2.html&quot;);" href="javascript:void(0);" alt="">科大讯飞校招笔试编程真题（2023.8.31）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/f766fbc2.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/6da30861.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/6da30861.html&quot;);" href="javascript:void(0);" alt="">科大讯飞校招笔试编程真题（2023.7.8）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/6da30861.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/f9fa8a74.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/f9fa8a74.html&quot;);" href="javascript:void(0);" alt="">科大讯飞校招笔试编程真题（2023.7.29）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/f9fa8a74.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2efb0d75.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2efb0d75.html&quot;);" href="javascript:void(0);" alt="">科大讯飞校招笔试编程真题（2023.7.22）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2efb0d75.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/10ab47eb.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/10ab47eb.html&quot;);" href="javascript:void(0);" alt="">科大讯飞校招笔试编程真题（2023.7.1）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/10ab47eb.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/7641fb6a.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/7641fb6a.html&quot;);" href="javascript:void(0);" alt="">科大讯飞校招笔试编程真题（2022.10.14）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/7641fb6a.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/52772af7.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/52772af7.html&quot;);" href="javascript:void(0);" alt="">科大讯飞校招笔试编程真题及其解析（2023.7.15）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/52772af7.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/ac4bafef.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-27</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/ac4bafef.html&quot;);" href="javascript:void(0);" alt="">微众银行校招笔试编程真题及其解析（2023.4.12）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/ac4bafef.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/19d99df0.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-19</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/19d99df0.html&quot;);" href="javascript:void(0);" alt="">操作系统OS面试题八股文</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/19d99df0.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/b264b8b5.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-26</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/b264b8b5.html&quot;);" href="javascript:void(0);" alt="">携程校招笔试编程真题及其解析（2023.9.21）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/b264b8b5.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/a135cfaa.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/a135cfaa.html&quot;);" href="javascript:void(0);" alt="">携程校招笔试编程真题及其解析（2023.9.7）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/a135cfaa.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/faa64596.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/faa64596.html&quot;);" href="javascript:void(0);" alt="">携程校招笔试编程真题及其解析（2023.5.25）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/faa64596.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/c442a03f.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-26</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/c442a03f.html&quot;);" href="javascript:void(0);" alt="">携程校招笔试编程真题及其解析（2023.5.4）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/c442a03f.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/aeeccc.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/aeeccc.html&quot;);" href="javascript:void(0);" alt="">携程校招笔试编程真题及其解析（2023.3.7）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/aeeccc.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/1b7134f2.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/1b7134f2.html&quot;);" href="javascript:void(0);" alt="">携程校招笔试编程真题及其解析（2023.4.15）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/1b7134f2.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/cc63a592.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/cc63a592.html&quot;);" href="javascript:void(0);" alt="">携程校招笔试编程真题及其解析（2023.3.16）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/cc63a592.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/d3a0cf14.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-26</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/d3a0cf14.html&quot;);" href="javascript:void(0);" alt="">携程校招笔试编程真题及其解析（2023.3.29）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/d3a0cf14.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2ec06a90.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-23</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2ec06a90.html&quot;);" href="javascript:void(0);" alt="">恒生电子校招笔试编程真题（2023.9.22）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2ec06a90.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/acdf6806.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-27</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/acdf6806.html&quot;);" href="javascript:void(0);" alt="">微众银行校招笔试编程真题及其解析（2023.9.3）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/acdf6806.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/7520a94a.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-27</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/7520a94a.html&quot;);" href="javascript:void(0);" alt="">微众银行校招笔试编程真题及其解析（2023.9.13）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/7520a94a.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/bad939ec.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-22</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/bad939ec.html&quot;);" href="javascript:void(0);" alt="">小红书校招笔试编程真题（2023.8.6）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/bad939ec.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/5357b25a.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-27</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/5357b25a.html&quot;);" href="javascript:void(0);" alt="">微众银行校招笔试编程真题及其解析（2023.4.23）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/5357b25a.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/70a5bb78.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-11</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/70a5bb78.html&quot;);" href="javascript:void(0);" alt="">广联达校招笔试编程真题及其解析（2023.10.11）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/70a5bb78.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/92b4cb69.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-22</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/92b4cb69.html&quot;);" href="javascript:void(0);" alt="">小红书校招笔试编程真题（2023.8.19）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/92b4cb69.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/90ffa75e.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/90ffa75e.html&quot;);" href="javascript:void(0);" alt="">字节跳动校招笔试编程真题及其解析（2023.8.20）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/90ffa75e.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/d289fe7.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/d289fe7.html&quot;);" href="javascript:void(0);" alt="">字节跳动校招笔试编程真题及其解析（2023.8.27）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/d289fe7.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/4ce12134.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-22</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/4ce12134.html&quot;);" href="javascript:void(0);" alt="">小红书校招笔试编程真题（2023.7.23）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/4ce12134.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/befb4d57.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-22</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/befb4d57.html&quot;);" href="javascript:void(0);" alt="">小红书校招笔试编程真题（2023.5.7）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/befb4d57.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/9578e9c1.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-22</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/9578e9c1.html&quot;);" href="javascript:void(0);" alt="">小红书校招笔试编程真题（2023.4.9）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/9578e9c1.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/7d093ba9.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-22</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/7d093ba9.html&quot;);" href="javascript:void(0);" alt="">小红书校招笔试编程真题（2023.4.23）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/7d093ba9.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/8f70f515.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-22</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/8f70f515.html&quot;);" href="javascript:void(0);" alt="">小红书校招笔试编程真题（2023.3.26）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/8f70f515.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/7dc0b3d9.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/7dc0b3d9.html&quot;);" href="javascript:void(0);" alt="">字节跳动校招笔试编程真题及其解析（2023.9.3）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/7dc0b3d9.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/ecffee83.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/ecffee83.html&quot;);" href="javascript:void(0);" alt="">字节跳动校招笔试编程真题及其解析（2023.9.17）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/ecffee83.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/1c8174c5.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/1c8174c5.html&quot;);" href="javascript:void(0);" alt="">字节跳动校招笔试编程真题及其解析（2023.5.12）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/1c8174c5.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/62a18d75.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/62a18d75.html&quot;);" href="javascript:void(0);" alt="">字节跳动校招笔试编程真题及其解析（2023.7.5）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/62a18d75.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/66b7b354.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/66b7b354.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.9.6）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/66b7b354.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/1d9a64f3.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/1d9a64f3.html&quot;);" href="javascript:void(0);" alt="">字节跳动校招笔试编程真题及其解析（2023.3.24）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/1d9a64f3.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/68b410aa.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/68b410aa.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2022.9.23）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/68b410aa.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/e104789c.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/e104789c.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.4.12）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/e104789c.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/c2bdd821.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/c2bdd821.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2022.9.21）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/c2bdd821.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/f0ad93be.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/f0ad93be.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.9.27）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/f0ad93be.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/7fcf04e9.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/7fcf04e9.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.9.23）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/7fcf04e9.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/d5c6cc62.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/d5c6cc62.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.9.21）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/d5c6cc62.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/6d7aab07.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/6d7aab07.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.9.20）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/6d7aab07.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/386f7e39.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/386f7e39.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.9.13）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/386f7e39.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/f66d8903.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/f66d8903.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.8.30）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/f66d8903.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/d9b80f5d.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/d9b80f5d.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.8.23）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/d9b80f5d.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/1175732f.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/1175732f.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.5.6）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/1175732f.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2f068fa6.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2f068fa6.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.5.31）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2f068fa6.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/25b85624.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/25b85624.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.5.24）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/25b85624.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/ed7abba3.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/ed7abba3.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.5.10）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/ed7abba3.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/70ad831a.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/70ad831a.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.5.17）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/70ad831a.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/29c6951b.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/29c6951b.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.4.26）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/29c6951b.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/3605ff9d.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/3605ff9d.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.4.19）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/3605ff9d.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/257ff08.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/257ff08.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.10.18）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/257ff08.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/6dea1f6c.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/6dea1f6c.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.10.12）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/6dea1f6c.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/7f5fb082.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/7f5fb082.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.10.11）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/7f5fb082.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/b477f365.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-10</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/b477f365.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2022.11.2）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/b477f365.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/82287452.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/82287452.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2022.10.12）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/82287452.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/e1169d40.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-10</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/e1169d40.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2022.8.30）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/e1169d40.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/247ce45c.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/247ce45c.html&quot;);" href="javascript:void(0);" alt="">华为od校招笔试编程真题及其解析（2023.5.3）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/247ce45c.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/541f7aa7.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/541f7aa7.html&quot;);" href="javascript:void(0);" alt="">华为od校招笔试编程真题及其解析（2023.5.11）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/541f7aa7.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/3821b0f8.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/3821b0f8.html&quot;);" href="javascript:void(0);" alt="">华为od校招笔试编程真题及其解析（2023.4.8）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/3821b0f8.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/c8c04449.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/c8c04449.html&quot;);" href="javascript:void(0);" alt="">华为od校招笔试编程真题及其解析（2023.4.28）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/c8c04449.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/8f7328f8.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/8f7328f8.html&quot;);" href="javascript:void(0);" alt="">华为od校招笔试编程真题及其解析（2023.3.10）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/8f7328f8.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/d746ca6.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/d746ca6.html&quot;);" href="javascript:void(0);" alt="">华为od校招笔试编程真题及其解析（2023.4.20）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/d746ca6.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/c5b68121.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/c5b68121.html&quot;);" href="javascript:void(0);" alt="">华为od校招笔试编程真题及其解析（2023.4.14）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/c5b68121.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/9df7a3e6.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/9df7a3e6.html&quot;);" href="javascript:void(0);" alt="">华为od校招笔试编程真题及其解析（2022.10.14）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/9df7a3e6.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/d123261.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/d123261.html&quot;);" href="javascript:void(0);" alt="">华为od校招笔试编程真题及其解析（2022.11.3）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/d123261.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/5799fe.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/5799fe.html&quot;);" href="javascript:void(0);" alt="">京东校招编程真题及其解析（2023.9.9）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/5799fe.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/d7561eff.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/d7561eff.html&quot;);" href="javascript:void(0);" alt="">京东校招编程真题及其解析（2023.9.2）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/d7561eff.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/1cfbbee5.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/1cfbbee5.html&quot;);" href="javascript:void(0);" alt="">京东校招编程真题及其解析（2023.9.28）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/1cfbbee5.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/cbfa39e4.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-26</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/cbfa39e4.html&quot;);" href="javascript:void(0);" alt="">京东校招编程真题及其解析（2023.9.23）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/cbfa39e4.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/5a53c262.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/5a53c262.html&quot;);" href="javascript:void(0);" alt="">京东校招编程真题及其解析（2023.8.26）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/5a53c262.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/bb84b306.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/bb84b306.html&quot;);" href="javascript:void(0);" alt="">京东校招编程真题及其解析（2023.9.16）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/bb84b306.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/4590a8e4.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/4590a8e4.html&quot;);" href="javascript:void(0);" alt="">京东校招编程真题及其解析（2023.8.19）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/4590a8e4.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/92912fe5.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/92912fe5.html&quot;);" href="javascript:void(0);" alt="">京东校招编程真题及其解析（2023.8.12）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/92912fe5.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/ebbbf9bc.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-26</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/ebbbf9bc.html&quot;);" href="javascript:void(0);" alt="">京东校招编程真题及其解析（2023.10.7）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/ebbbf9bc.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/475ed45.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/475ed45.html&quot;);" href="javascript:void(0);" alt="">京东校招编程真题及其解析（2023.4.8）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/475ed45.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/ec9632c2.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/ec9632c2.html&quot;);" href="javascript:void(0);" alt="">京东校招编程真题及其解析（2023.2.25）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/ec9632c2.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/c13307dc.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/c13307dc.html&quot;);" href="javascript:void(0);" alt="">java进阶之路（一）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/c13307dc.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/bb381fef.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/bb381fef.html&quot;);" href="javascript:void(0);" alt="">Java进阶之路（四）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/bb381fef.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/410ba5d8.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/410ba5d8.html&quot;);" href="javascript:void(0);" alt="">Java进阶之路（二）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/410ba5d8.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/c15068a.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/c15068a.html&quot;);" href="javascript:void(0);" alt="">Java进阶之路（三）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/c15068a.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/3cbc845.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/3cbc845.html&quot;);" href="javascript:void(0);" alt="">Java数据结构与算法</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/3cbc845.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/f9c52cbb.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-19</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/f9c52cbb.html&quot;);" href="javascript:void(0);" alt="">设计模式面试篇-参考回答</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/f9c52cbb.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/27f853cc.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/27f853cc.html&quot;);" href="javascript:void(0);" alt="">框架篇面试题-参考回答</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/27f853cc.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/eabb6106.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-12</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/eabb6106.html&quot;);" href="javascript:void(0);" alt="">消息中间件面试题-参考回答</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/eabb6106.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/6ba374e2.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/6ba374e2.html&quot;);" href="javascript:void(0);" alt="">微服务面试篇-参考回答</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/6ba374e2.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/dbf9d5c9.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/dbf9d5c9.html&quot;);" href="javascript:void(0);" alt="">常见技术场景</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/dbf9d5c9.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/af15ea36.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/af15ea36.html&quot;);" href="javascript:void(0);" alt="">多线程相关面试题</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/af15ea36.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/6bb2589.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-12</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/6bb2589.html&quot;);" href="javascript:void(0);" alt="">Rabbitmq消息中间件（二）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/6bb2589.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/258353ca.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/258353ca.html&quot;);" href="javascript:void(0);" alt="">kafka深入浅出，快速玩转分布式发布订阅消息系统</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/258353ca.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/6f83b1e4.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/6f83b1e4.html&quot;);" href="javascript:void(0);" alt="">Redis面试题-参考回答</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/6f83b1e4.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/d2ba1e3f.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/d2ba1e3f.html&quot;);" href="javascript:void(0);" alt="">Redis原理篇</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/d2ba1e3f.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/37cf2cfd.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/37cf2cfd.html&quot;);" href="javascript:void(0);" alt="">Redis集群</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/37cf2cfd.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/6bb2589.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-12</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/6bb2589.html&quot;);" href="javascript:void(0);" alt="">Rabbitmq消息中间件（一）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/6bb2589.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/18ab1f25.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/18ab1f25.html&quot;);" href="javascript:void(0);" alt="">MySQL面试篇-参考回答</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/18ab1f25.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/11f76754.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/11f76754.html&quot;);" href="javascript:void(0);" alt="">MySQL进阶篇</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/11f76754.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/592cf81.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/592cf81.html&quot;);" href="javascript:void(0);" alt="">MySQL运维篇</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/592cf81.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/337fcc87.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/337fcc87.html&quot;);" href="javascript:void(0);" alt="">MySQL基础篇</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/337fcc87.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/b481a8d6.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/b481a8d6.html&quot;);" href="javascript:void(0);" alt="">Java集合相关面试题</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/b481a8d6.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/c218eb30.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/c218eb30.html&quot;);" href="javascript:void(0);" alt="">JVM相关面试题</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/c218eb30.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/7eb663f5.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/7eb663f5.html&quot;);" href="javascript:void(0);" alt="">Docker安装OpenResty</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/7eb663f5.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/be6d66dc.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/be6d66dc.html&quot;);" href="javascript:void(0);" alt="">Docker安装Canal</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/be6d66dc.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/a6573b44.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/a6573b44.html&quot;);" href="javascript:void(0);" alt="">Centos7安装Docker</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/a6573b44.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/a6b15897.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/a6b15897.html&quot;);" href="javascript:void(0);" alt="">Redis实战篇</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/a6b15897.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/d3404069.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/d3404069.html&quot;);" href="javascript:void(0);" alt="">Redis高级篇</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/d3404069.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/4604f75b.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-01</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/4604f75b.html&quot;);" href="javascript:void(0);" alt="">Redis基础篇</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/4604f75b.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '1s');
    arr[i].setAttribute('data-wow-offset', '100');
    arr[i].setAttribute('data-wow-iteration', '2');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>