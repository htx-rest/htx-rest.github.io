<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>java实战演练35讲 | 鲸落</title><meta name="author" content="鲸落"><meta name="copyright" content="鲸落"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="微信关注“二哈学习之路”，回复“面渣笔记”，领取面试八股文。">
<meta property="og:type" content="article">
<meta property="og:title" content="java实战演练35讲">
<meta property="og:url" content="https://whalerest.top/posts/fe2abc65.html">
<meta property="og:site_name" content="鲸落">
<meta property="og:description" content="微信关注“二哈学习之路”，回复“面渣笔记”，领取面试八股文。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://whalerest.top/assets/silhouette_night_starry_sky_137292_300x168.jpg">
<meta property="article:published_time" content="2023-11-06T01:04:16.000Z">
<meta property="article:modified_time" content="2023-11-06T09:26:51.114Z">
<meta property="article:author" content="鲸落">
<meta property="article:tag" content="Java, MySQL, 算法, 深度学习, 视网膜血管分割, 道路线提取, 目标检测, 博客, Butterfly, Hexo, 鲸落, whalerest">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://whalerest.top/assets/silhouette_night_starry_sky_137292_300x168.jpg"><link rel="shortcut icon" href="/"><link rel="canonical" href="https://whalerest.top/posts/fe2abc65.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'java实战演练35讲',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-11-06 17:26:51'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_4233300_xxm4hpxio1.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/element-ui@2.15.6/packages/theme-chalk/lib/index.css"><script src="https://npm.elemecdn.com/echarts@4.9.0/dist/echarts.min.js"></script><style id="themeColor"></style><style id="rightSide"></style><style id="transPercent"></style><style id="blurNum"></style><style id="settingStyle"></style><span id="fps"></span><style id="defineBg"></style><style id="menu_shadow"></style><div id="myscoll"></div><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/assets/mmexport1694508539292.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">282</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">243</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-youhuawenzhang"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-guidang"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei"></i><span> 分类</span></a></li><li><a class="site-page child" href="javascript:randomPost();"><i class="fa-fw iconfont icon-wode-zuji-copy"></i><span> 随便逛逛</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-xiuxianyinpin"></i><span> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/life/music/"><i class="fa-fw iconfont icon-tool"></i><span> 八音盒</span></a></li><li><a class="site-page child" href="/life/movies/"><i class="fa-fw iconfont icon-dianying"></i><span> 影院</span></a></li><li><a class="site-page child" href="/life/games/"><i class="fa-fw iconfont icon-youxi"></i><span> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-baoxiang21"></i><span> 八宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/box/gallery/"><i class="fa-fw iconfont icon-hualang"></i><span> 画廊</span></a></li><li><a class="site-page child" href="/box/animation/"><i class="fa-fw iconfont icon-donghua"></i><span> 动画</span></a></li><li><a class="site-page child" href="/box/nav/"><i class="fa-fw iconfont icon-a-06-wangzhidaohang"></i><span> 网址导航</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-tubiaozhizuomoban1"></i><span> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/social/fcircle/"><i class="fa-fw iconfont icon-iconfontzhizuobiaozhunbduan36"></i><span> 朋友圈</span></a></li><li><a class="site-page child" href="/comments/"><i class="fa-fw iconfont icon-liuyanban"></i><span> 留言板</span></a></li><li><a class="site-page child" href="/social/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-a-06-wangzhidaohang"></i><span> 网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/site/census/"><i class="fa-fw iconfont icon-a-06-wangzhidaohang"></i><span> 网站统计</span></a></li><li><a class="site-page child" href="/site/echarts/"><i class="fa-fw iconfont icon-tongji"></i><span> 文章统计</span></a></li><li><a class="site-page child" href="/site/time/"><i class="fa-fw iconfont icon-shalou"></i><span> 旧时光</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-geren"></i><span> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/personal/bb/"><i class="fa-fw iconfont icon-icon_liuyan"></i><span> 唠叨</span></a></li><li><a class="site-page child" href="/personal/love/"><i class="fa-fw iconfont icon-valentine_-email-love-message-send"></i><span> 恋爱小屋</span></a></li><li><a class="site-page child" href="/personal/about/"><i class="fa-fw iconfont icon-icon-lark-logo-old"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/assets/silhouette_night_starry_sky_137292_300x168.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="鲸落"><span class="site-name">鲸落</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-youhuawenzhang"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-guidang"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei"></i><span> 分类</span></a></li><li><a class="site-page child" href="javascript:randomPost();"><i class="fa-fw iconfont icon-wode-zuji-copy"></i><span> 随便逛逛</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-xiuxianyinpin"></i><span> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/life/music/"><i class="fa-fw iconfont icon-tool"></i><span> 八音盒</span></a></li><li><a class="site-page child" href="/life/movies/"><i class="fa-fw iconfont icon-dianying"></i><span> 影院</span></a></li><li><a class="site-page child" href="/life/games/"><i class="fa-fw iconfont icon-youxi"></i><span> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-baoxiang21"></i><span> 八宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/box/gallery/"><i class="fa-fw iconfont icon-hualang"></i><span> 画廊</span></a></li><li><a class="site-page child" href="/box/animation/"><i class="fa-fw iconfont icon-donghua"></i><span> 动画</span></a></li><li><a class="site-page child" href="/box/nav/"><i class="fa-fw iconfont icon-a-06-wangzhidaohang"></i><span> 网址导航</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-tubiaozhizuomoban1"></i><span> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/social/fcircle/"><i class="fa-fw iconfont icon-iconfontzhizuobiaozhunbduan36"></i><span> 朋友圈</span></a></li><li><a class="site-page child" href="/comments/"><i class="fa-fw iconfont icon-liuyanban"></i><span> 留言板</span></a></li><li><a class="site-page child" href="/social/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-a-06-wangzhidaohang"></i><span> 网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/site/census/"><i class="fa-fw iconfont icon-a-06-wangzhidaohang"></i><span> 网站统计</span></a></li><li><a class="site-page child" href="/site/echarts/"><i class="fa-fw iconfont icon-tongji"></i><span> 文章统计</span></a></li><li><a class="site-page child" href="/site/time/"><i class="fa-fw iconfont icon-shalou"></i><span> 旧时光</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-geren"></i><span> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/personal/bb/"><i class="fa-fw iconfont icon-icon_liuyan"></i><span> 唠叨</span></a></li><li><a class="site-page child" href="/personal/love/"><i class="fa-fw iconfont icon-valentine_-email-love-message-send"></i><span> 恋爱小屋</span></a></li><li><a class="site-page child" href="/personal/about/"><i class="fa-fw iconfont icon-icon-lark-logo-old"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">java实战演练35讲</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-11-06T01:04:16.000Z" title="发表于 2023-11-06 09:04:16">2023-11-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-06T09:26:51.114Z" title="更新于 2023-11-06 17:26:51">2023-11-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E6%B8%A3%E7%AC%94%E8%AE%B0/">面渣笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>48分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="java实战演练35讲"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Java实战演练"><a href="#Java实战演练" class="headerlink" title="Java实战演练"></a>Java实战演练</h1><p>实战小技巧，可用于实际编码过程中的 code snippets 带你再日常得编码中写得更加顺畅</p>
<h1 id="实战1：字符串占位替换"><a href="#实战1：字符串占位替换" class="headerlink" title="实战1：字符串占位替换"></a>实战1：字符串占位替换</h1><p>字符串占位替换，相信没有小伙伴是陌生的，这东西可以说是伴随着我们所有的项目工程，编码过程；别不相信，如</p>
<ul>
<li>String.format</li>
<li>sql参数拼接的占位</li>
<li>log日志输出</li>
</ul>
<p>接下来我们看一下在我们的日常工作生涯中，经常涉及到的几种占位替换方式</p>
<h2 id="1-String-format"><a href="#1-String-format" class="headerlink" title="1.String.format"></a>1.String.format</h2><p>这种可以说是最原始最基础的方式了，基本上在最开始学习java这门语言的时候就会涉及到，语法也比较简单</p>
<p>举例如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String.format(&quot;hello %s&quot;, &quot;二哈学习之路&quot;);</span><br></pre></td></tr></table></figure>
<p>使用 %来表示占位，后面跟上不同的标识符，用于限定这个占位处的参数类型</p>
<p>这种使用姿势，由jdk原生提供支持，下表为不同的转换符对应的说明</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">转换符</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">参数实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">%s</td>
<td style="text-align:center">字符串替换</td>
<td style="text-align:center">“二哈学习之路”</td>
</tr>
<tr>
<td style="text-align:center">%c</td>
<td style="text-align:center">字符类型</td>
<td style="text-align:center">‘a’</td>
</tr>
<tr>
<td style="text-align:center">%b</td>
<td style="text-align:center">布尔类型</td>
<td style="text-align:center">true/false</td>
</tr>
<tr>
<td style="text-align:center">%d</td>
<td style="text-align:center">整数，十进制</td>
<td style="text-align:center">10</td>
</tr>
<tr>
<td style="text-align:center">%x</td>
<td style="text-align:center">整数，十六进制</td>
<td style="text-align:center">0x12</td>
</tr>
<tr>
<td style="text-align:center">%o</td>
<td style="text-align:center">整数，八进制</td>
<td style="text-align:center">012</td>
</tr>
<tr>
<td style="text-align:center">%f</td>
<td style="text-align:center">浮点</td>
<td style="text-align:center">0.12f</td>
</tr>
<tr>
<td style="text-align:center">%e</td>
<td style="text-align:center">指数</td>
<td style="text-align:center">2e2</td>
</tr>
<tr>
<td style="text-align:center">%g</td>
<td style="text-align:center">通用浮点型</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">%h</td>
<td style="text-align:center">散列</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">%%</td>
<td style="text-align:center">百分比</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">%n</td>
<td style="text-align:center">换行</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">%tx</td>
<td style="text-align:center">日期与时间类型（x代表不同的日期与时间转换符</td>
</tr>
</tbody>
</table>
</div>
<p>虽然上面表中列出了很多，但实际使用时， %s , %d , %f 这三个就足以应付绝大部分的场景了；</p>
<p>使用姿势和上面的实例参不多，第一个参数为字符串模板，后面的可变参数为待替换的值</p>
<p>下面是在实际使用过程中的注意事项</p>
<h3 id="1-1-类型不匹配"><a href="#1-1-类型不匹配" class="headerlink" title="1.1 类型不匹配"></a>1.1 类型不匹配</h3><p>上面的表中介绍了不同的转换符，要求的参数类型，如果没有对应上，会怎样</p>
<p><strong>%s ，传入非字符串类型</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Test </span><br><span class="line">public void testFormat() &#123; </span><br><span class="line">    System.out.println(String.format(&quot;hello %s&quot;, 120)); </span><br><span class="line">    System.out.println(String.format(&quot;hello %s&quot;, true)); </span><br><span class="line">    System.out.println(String.format(&quot;hello %s&quot;, new int[]&#123;1,2, 3&#125;)); </span><br><span class="line">    System.out.println(String.format(&quot;hello %s&quot;, Arrays.asList(1, 2, 3))); </span><br><span class="line">    System.out.println(String.format(&quot;hello %s&quot;, 0x12)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hello 120 </span><br><span class="line">hello true </span><br><span class="line">hello [I@3d82c5f3 </span><br><span class="line">hello [1, 2, 3] </span><br><span class="line">hello 18</span><br></pre></td></tr></table></figure>
<p>也就是说， %s的占位标记，传参如果不是String类型，那么实际替换的是 arg.toString() (所以数组输出的是地址，而list输出了内容)</p>
<p><strong>%d ，传入非整数</strong></p>
<p>与字符串的不一样的是，如果我们定义要求替换的参数类型为整数，那么传参不是整数，就会抛异常</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(String.format(&quot;hello %d&quot;, 1.0F)); </span><br><span class="line">System.out.println(String.format(&quot;hello %d&quot;, &quot;10&quot;));</span><br></pre></td></tr></table></figure>
<p>上面这两个，一个传入的参数为浮点，一个传入的是字符串，在实际替换的时候，可不会调用Integer.valufOf(String.valueOf(xxx))来强转，而是采用更直接的方式，抛异常</p>
<p>关键的提示信息如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.util.IllegalFormatConversionException: d != java.lang.Float </span><br><span class="line">java.util.IllegalFormatConversionException: d != java.lang.String</span><br></pre></td></tr></table></figure>
<p>因此在实际使用这种方式进行替换时，推荐选择 %s ，毕竟兼容性更好</p>
<h3 id="1-2-参数个数不匹配"><a href="#1-2-参数个数不匹配" class="headerlink" title="1.2 参数个数不匹配"></a>1.2 参数个数不匹配</h3><p>我们会注意到, String.format接收的参数是不定长的，那么就可能存在字符串模板中预留的占位与实际传入的参数个数不匹配的场景，那么出现这种场景时，会怎样</p>
<p><strong>参数缺少</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(String.format(&quot;hello %s %s&quot;, &quot;erha&quot;));</span><br></pre></td></tr></table></figure>
<p>上面的例子中，模板要求两个，实际只传入一个参数，会直接抛异常MissingFormatArgumentException</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.util.MissingFormatArgumentException: Format specifier &#x27;%s&#x27;</span><br></pre></td></tr></table></figure>
<p><strong>参数过多</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(String.format(&quot;hello %s&quot;, &quot;erha&quot;, &quot;blog&quot;));</span><br></pre></td></tr></table></figure>
<p>执行正常，多余的参数不会被替换</p>
<p>因此，我们在使用 String.format进行字符串替换时，请确保传参不要少于实际定义的参数个数；多了还好，少了就会抛异常</p>
<h2 id="2-MessageFormat"><a href="#2-MessageFormat" class="headerlink" title="2. MessageFormat"></a>2. MessageFormat</h2><p>上面介绍的String.format虽说简单好用，但我们用多之后，自然会遇到，一个参数，需要替换模板中多个占位的场景，针对这种场景，更友好的方式是 MessageFormat ，这个也是jdk原生提供的</p>
<p>我们来简单看一下它的使用姿势</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String ans = MessageFormat.format(&quot;hello &#123;0&#125;, wechart site &#123;0&#125;&#123;1&#125;&quot;, &quot;二哈学习之路&quot;, &quot;blog&quot;);</span><br></pre></td></tr></table></figure>
<p>使用 {数字}来表示占位，其中数字对应的是传参的下标，因此当一个参数需要复用时，使用MessageFormat就可以比较简单的实现了，上面就是一个实例，替换之后的字符串为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello 二哈学习之路, wechart site 二哈学习之路blog</span><br></pre></td></tr></table></figure>
<p>接下来说一下它使用时的注意事项</p>
<h3 id="2-1-成对出现"><a href="#2-1-成对出现" class="headerlink" title="2.1 {}成对出现"></a>2.1 {}成对出现</h3><p>如果字符串中，只出现一个 { ，而没有配套的 } ，会抛异常</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(MessageFormat.format(&quot;hello &#125;&quot;, 123)); </span><br><span class="line">System.out.println(MessageFormat.format(&quot;hello &#123; world&quot;,  456));</span><br></pre></td></tr></table></figure>
<p>注意上面两种case，上面一个是有 }而缺少 { ，这样是没有问题的；而下面那个则会抛异常</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IllegalArgumentException: Unmatched braces in the pattern.</span><br></pre></td></tr></table></figure>
<p>如果字符串中却是希望输出 { ，可以使用单引号来处理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(MessageFormat.format(&quot;hello &#x27;&#123;&#x27; world&quot;,  456));</span><br></pre></td></tr></table></figure>
<h3 id="2-2-单引号"><a href="#2-2-单引号" class="headerlink" title="2.2 单引号"></a>2.2 单引号</h3><p>上面提到需要转移时，可以用单引号进行处理，在字符串模板的定义中，如果有单引号，需要各位注意</p>
<p><strong>只有一个单引号，会导致后面所有占位都不生效</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(MessageFormat.format(&quot;hello &#123;0&#125;, I&#x27;m &#123;1&#125;&quot;, &quot;二哈学习之路&quot;, &quot;blog&quot;));</span><br></pre></td></tr></table></figure>
<p>上面这个输出结果可能和我们实际希望的不一致</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello 二哈学习之路, Im &#123;1&#125;</span><br></pre></td></tr></table></figure>
<p>要解决上面这个，就是使用两个单引号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(MessageFormat.format(&quot;hello &#123;0&#125;, I&#x27;&#x27;m &#123;1&#125;&quot;, &quot;二哈学习之路&quot;, &quot;blog&quot;));</span><br></pre></td></tr></table></figure>
<p>这样输出的就是我们预期的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello 二哈学习之路, I&#x27;m blog</span><br></pre></td></tr></table></figure>
<h3 id="2-3-序号省略"><a href="#2-3-序号省略" class="headerlink" title="2.3 序号省略"></a>2.3 序号省略</h3><p>上面的定义中，已经明确要求我们在 {}中指定参数的序号，如果模板中没有指定会怎样?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(messageFormat.format(&quot;hello &#123;&#125;, world&quot;, &quot;erha&quot;));</span><br></pre></td></tr></table></figure>
<p>直接抛异常</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalArgumentException: can&#x27;t parse argument number: </span><br></pre></td></tr></table></figure>
<h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h2><p>本文介绍的实战小技巧属于是jdk原生提供的两种实现字符串占位替换的方式，除了这两个之外，我们日常开发中还会遇到其他的占位替换方式</p>
<p>比如sql的 ?替换，mybatis中sql参数组装使用 ${paramName} ，或者logback日志输出中的 {}来表示占位，spring的@Value注解声明的配置注入方式 ${name:defaultValue} ，这些也都属于占位替换的范畴，那么它们又是怎么实现的呢？</p>
<h1 id="实战2：数组与list互转"><a href="#实战2：数组与list互转" class="headerlink" title="实战2：数组与list互转"></a>实战2：数组与list互转</h1><p>这个考题比较常见，也比较简单，难道就这也有什么可以说到的门路不成？</p>
<p>接下来本文好好的说一说它的几种实现姿势，总有一款你喜欢的</p>
<h2 id="1-数组转List"><a href="#1-数组转List" class="headerlink" title="1.数组转List"></a>1.数组转List</h2><h3 id="1-1-Array-asList"><a href="#1-1-Array-asList" class="headerlink" title="1.1. Array.asList"></a>1.1. Array.asList</h3><p>这个考题太简单了，直接使用 Array.asList不就完事了么，比如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Test </span><br><span class="line">public void ary2list() &#123; </span><br><span class="line">    String[] ary = new String[]&#123; &quot;1&quot;, &quot;a&quot;&#125;; </span><br><span class="line">    List&lt;String&gt; list = Arrays.asList((ary); </span><br><span class="line">    System.out.println(list); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数组转list，so easy!!!</p>
<p>真的就这么简单么？？？</p>
<p>且看下面这一段代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void ary2list() &#123; </span><br><span class="line">    String[] ary = new String[]&#123; &quot;1&quot;, &quot;a&quot;&#125;; </span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(ary); </span><br><span class="line">    System.out.println(list); </span><br><span class="line">    list.add(&quot;c&quot;); </span><br><span class="line">    System.out.println(list); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接抛出了异常 java.lang.UnsupportedOperationException</p>
<p>有兴趣的小伙伴可以看一下源码实现方式，通过 Arrays.asList创建的List，虽说也命名是ArrayList ，但是它的全路径为 java.util.Arrays.ArrayList ， 不支持 add , remove等操作（所以下次再有面试官问ArrayList的知识点时，就可以反问一句，老哥你指的是哪个ArrayList，逼格是不是立马拉起来）</p>
<p><strong>知识点</strong></p>
<ul>
<li>通过 Arrays.asList创建的列表，不允许新增，删除元素；但是可以更新列表中元素的值</li>
</ul>
<h3 id="1-2-new-ArrayList"><a href="#1-2-new-ArrayList" class="headerlink" title="1.2. new ArrayList"></a>1.2. new ArrayList</h3><p>上面的数组转list方式虽然是最简单的，但不一定是合适的，特别是当我们可能对转换后的list进行操作时，可能埋坑（而且这种坑还非常隐晦，代码层面上很难发现）</p>
<p>为了减少在代码里面下毒的可能性，不妨使用下面这种方式 new ArrayList&lt;&gt;(Arrays.asList(ary))</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] ary = new String[]&#123; &quot;1&quot;, &quot;a&quot;&#125;; </span><br><span class="line">List&lt;String&gt; out = new ArrayList&lt;&gt;(Arrays.asList(ary)); </span><br><span class="line">out.add(&quot;hello&quot;); </span><br><span class="line">System.out.println(out);</span><br></pre></td></tr></table></figure>
<p>通过上面这种方式创建的List，就是我们熟知的 ArrayList了</p>
<p><strong>避雷预警</strong></p>
<p>看到上面这个使用姿势，就很容易想到一个常见的踩雷点，比如我们的应用中，有一个全局共享的配置列表，张三需要拿id为奇数的配置，李四拿id为偶数的配置，然后他们都是这么做的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.removeIf(s -&gt; s.id % 2 == 0);</span><br></pre></td></tr></table></figure>
<p>然后跑了一次之后发现这个全局的列表清空了，这就是典型的没有做好资源隔离的case了，针对这种场景，要么是限制使用方，直接针对全局的资源进行修改，要么就是使用方拿到的是一个隔离的备份</p>
<p><strong>禁止修改：</strong></p>
<ul>
<li>使用不可变的容器，如前面提到的 java.util.Arrays.ArrayList ()</li>
<li>使用 Collections.unmodifiableList创建</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; unModifyList = Collections.unmodifiableList(out);</span><br></pre></td></tr></table></figure>
<p><strong>列表拷贝</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new ArrayList&lt;&gt;(Arrays.asList(ary));</span><br></pre></td></tr></table></figure>
<p>（上面这种属于深拷贝的实现，具体可以看一下jdk的源码实现）</p>
<h3 id="1-3-Collections-addAll"><a href="#1-3-Collections-addAll" class="headerlink" title="1.3. Collections.addAll"></a>1.3. Collections.addAll</h3><p>第三种方式借助jdk提供的容器工具类 Collections来实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Test </span><br><span class="line">public void ary2listV3() &#123; </span><br><span class="line">    String[] ary = new String[]&#123; &quot;1&quot;, &quot;a&quot;&#125;; </span><br><span class="line">    // 创建列表，并指定长度，避免可能产生的扩容 </span><br><span class="line">    List&lt;String&gt; out = new ArrayList&lt;&gt;(ary.length); </span><br><span class="line">    // 实现数组添加到列表中 </span><br><span class="line">    Collections.addAll(out, ary); </span><br><span class="line">    // 因为列表为我们定义的ArrayList，因此可以对它进行增删改 </span><br><span class="line">    out.add(&quot;hello&quot;); </span><br><span class="line">    System.out.println(out); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原则上是比较推荐这种方式来实现的，至于为啥？看下源码实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; boolean addAll(Collection&lt;? super T&gt; c, T... elements) &#123; </span><br><span class="line">    boolean result = false; </span><br><span class="line">    for (T element : elements) </span><br><span class="line">        result |= c.add(element); </span><br><span class="line">    return result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码的实现是不是非常眼熟，如果让我们自己来写，也差不多会写成这样吧，简单直观高效，完美</p>
<h2 id="2-列表转数组"><a href="#2-列表转数组" class="headerlink" title="2.列表转数组"></a>2.列表转数组</h2><p>不同于数组转列表的几种玩法，列表转数组就简单多了，直接调用 List.toArray</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;); </span><br><span class="line">// 返回的是Object[] 数组 </span><br><span class="line">Object[] cell = list.toArray(); </span><br><span class="line">// 如果需要指定数组类型，可以传一个指定各类型的空的数组 </span><br><span class="line">// 也可以传一个与目标列表长度相等的数组，这样会将列表中的元素拷贝到这个数组中 </span><br><span class="line">String[] strCell = list.toArray(new String[]&#123;&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="3-小结-1"><a href="#3-小结-1" class="headerlink" title="3.小结"></a>3.小结</h2><p>今天的博文主题是数组与列表的互转，虽说题目简单，但是实现方式也是多种，需要搞清楚它们之间的本质区别，一不小心就可能采坑，而最简单的地方掉坑里，往往是最难发现和爬出来的</p>
<p>核心知识点小结如下</p>
<p><strong>数组转list：</strong></p>
<ul>
<li>Arrays.asList(xxx) ：创建的是不可变列表，不能删除和新增元素</li>
<li>new ArrayList&lt;&gt;(Arrays.asList(xxx) : 相当于用列表创建列表，属于深拷贝的一种表现，获取到的列表支持新增、删除</li>
<li>推荐写法 Collections.addAll()</li>
</ul>
<p><strong>列表转数组</strong></p>
<ul>
<li>list.toArray : 如果需要指定数组类型，则传参指定</li>
</ul>
<h1 id="实战3：字符串与Collection的互转"><a href="#实战3：字符串与Collection的互转" class="headerlink" title="实战3：字符串与Collection的互转"></a>实战3：字符串与Collection的互转</h1><p>将字符串转换为List，这种业务场景可以说非常常见了，实现方式也比较简单</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;String&gt; str2list(String str, String split) &#123; </span><br><span class="line">    String[] cells = str.split(split); </span><br><span class="line">    return Arrays.asList(cells); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么除了上面这种实现方式之外，还有其他的么？</p>
<h2 id="1-字符串转列表"><a href="#1-字符串转列表" class="headerlink" title="1.字符串转列表"></a>1.字符串转列表</h2><p>上面的实现姿势相当于字符串先转数组，然后在通过数组转列表，所以可以沿用前一篇字数组转list的几种方式</p>
<h3 id="1-1-jdk支持方式"><a href="#1-1-jdk支持方式" class="headerlink" title="1.1. jdk支持方式"></a>1.1. jdk支持方式</h3><p>借助 Collections.addAll来实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;String&gt; str2list2(String str, String split) &#123; </span><br><span class="line">    List&lt;String&gt; list = new ArrayList&lt;&gt;(); </span><br><span class="line">    Collections.addAll(list, str.split(split)); </span><br><span class="line">    return list; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这种方式适用于输出String的列表，如果我希望转成int列表呢？可以采用下面的方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Integer&gt; str2intList(String str, String split) &#123; </span><br><span class="line">    return Stream.of(str.split(split)) </span><br><span class="line">            .map(String::trim) </span><br><span class="line">            .filter(s -&gt; !s.isEmpty()) </span><br><span class="line">            .map(Integer::valueOf).collect(Collectors.toList()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接将数组转换为流，然后基于jdk8的特性，来实现转换为int列表</p>
<h3 id="1-2-guava方式"><a href="#1-2-guava方式" class="headerlink" title="1.2. guava方式"></a>1.2. guava方式</h3><p>引入依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/com.google.guava/guava --&gt; </span><br><span class="line">&lt;dependency&gt; </span><br><span class="line">    &lt;groupId&gt;com.google.guava&lt;/groupId&gt; </span><br><span class="line">    &lt;artifactId&gt;guava&lt;/artifactId&gt; </span><br><span class="line">    &lt;version&gt;30.1-jre&lt;/version&gt; </span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>除了使用jdk原生的方式之外，借助guava也是非常常见的的case了，主要通过Splitter来实现，写法看起来非常秀</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;String&gt; str2list2(String str, String split) &#123; </span><br><span class="line">    return Splitter.on(split).splitToList(str); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单直接的一行代码搞定，如果我们希望是对输出的列表类型进行指定，也可以如下操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Integer&gt; str2intListV2(String str, String split) &#123; </span><br><span class="line">    return Splitter.on(split).splitToStream(str) </span><br><span class="line">            .map(String::trim).filter(s -&gt; !s.isEmpty()) </span><br><span class="line">            .map(Integer::valueOf).collect(Collectors.toList()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-apache-commons"><a href="#1-3-apache-commons" class="headerlink" title="1.3. apache-commons"></a>1.3. apache-commons</h3><p>引入依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt; </span><br><span class="line">    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; </span><br><span class="line">    &lt;artifactId&gt;commons-collections4&lt;/artifactId&gt; </span><br><span class="line">    &lt;version&gt;4.4&lt;/version&gt; </span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>上面流的方式就很赞了，但是注意它是有jdk版本限制的，虽说现在基本上都是1.8以上的环境进行开发，但也不排除有上古的代码，比如我现在手上的项目，spring还是3…</p>
<p>如果我们不能使用流的方式，那么有什么简单的方式来实现字符串转换为指定类型的列表么？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Integer&gt; str2intListV3(String str, String split) &#123; </span><br><span class="line">    List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); </span><br><span class="line">    CollectionUtils.collect(Arrays.asList(str.split(split)), new Transformer&lt;String, Integer&gt;() &#123; </span><br><span class="line">        @Override </span><br><span class="line">        public Integer transform(String s) &#123; </span><br><span class="line">            return Integer.valueOf(s); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;, result); </span><br><span class="line">    return result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个实现也没有多优雅，不过这里有个编程小技巧可以学习， new Transformer(){}的传参方式，这种实现方式有点像回调的写法，虽然他们有本质的区别，此外就是jdk8之后的函数方法，就充分的体现这种设计思路，比如上面的换成jdk8的写法，直接简化为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Integer&gt; str2intListV3(String str, String split) &#123; </span><br><span class="line">    List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); </span><br><span class="line">    CollectionUtils.collect(Arrays.asList(str.split(split)), Integer::valueOf, result); </span><br><span class="line">    return result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-列表转字符串"><a href="#2-列表转字符串" class="headerlink" title="2.列表转字符串"></a>2.列表转字符串</h2><h3 id="2-1-StringBuilder"><a href="#2-1-StringBuilder" class="headerlink" title="2.1. StringBuilder"></a>2.1. StringBuilder</h3><p>最容易想到的，直接使用StringBuilder来实现拼接</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public String list2str(List&lt;String&gt; list, String split) &#123; </span><br><span class="line">    StringBuilder builder = new StringBuilder(); </span><br><span class="line">    for (String str: list) &#123; </span><br><span class="line">        builder.append(str).append(split); </span><br><span class="line">    &#125; </span><br><span class="line">    return builder.substring(0, builder.length() - 1); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意两点：</p>
<ul>
<li>使用StringBuilder而不是StringBuffer (why?)</li>
<li>注意最后一个拼接符号不要</li>
</ul>
<h3 id="2-2-String-join"><a href="#2-2-String-join" class="headerlink" title="2.2. String.join"></a>2.2. String.join</h3><p>一个更简单的实现方式如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public String list2str2(List&lt;String&gt; list, String split) &#123; </span><br><span class="line"> return String.join(split, list); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然上面这个的缺点就是列表必须是字符串列表，如果换成int列表，则不行</p>
<h3 id="2-3-gauva"><a href="#2-3-gauva" class="headerlink" title="2.3. gauva"></a>2.3. gauva</h3><p>guava也提供了列表转String的方式，同样很简单，而且还没有列表类型的限制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; String list2str3(List&lt;T&gt; list, String split) &#123; </span><br><span class="line">    return Joiner.on(split).join(list); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-小结-2"><a href="#3-小结-2" class="headerlink" title="3.小结"></a>3.小结</h2><p>本文的考题也非常常见，列表与字符串的互转，这里介绍了多种实现方式，有jdk原生的case（如果没有什么限制，推荐使用它， String.split除外，原因后面再说），如果有更高级的定制场景，如非String类型类表，则可以考虑guava的Splitter/Joinner来实现</p>
<p>在上面的实现中，也提供了几种有意思的编程方式</p>
<ul>
<li>Stream: 流，jdk8之后非常常见了</li>
<li>函数方法，回调写法case</li>
</ul>
<h1 id="实战4：字符串拼接"><a href="#实战4：字符串拼接" class="headerlink" title="实战4：字符串拼接"></a>实战4：字符串拼接</h1><p>相信没有小伙伴没有写过这样的代码，比如说现在让我们来实现一个字符串拼接的场景，怎样的实现才算是优雅的呢？</p>
<p>以将int数组转为英文逗号分隔的字符串为例进行演示</p>
<h2 id="1-实现"><a href="#1-实现" class="headerlink" title="1.实现"></a>1.实现</h2><h3 id="1-1-普通写法"><a href="#1-1-普通写法" class="headerlink" title="1.1. 普通写法"></a>1.1. 普通写法</h3><p>直接使用StringBuilder来拼接</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public String join(List&lt;Integer&gt; list) &#123; </span><br><span class="line">    StringBuilder builder = new StringBuilder(); </span><br><span class="line">    for(Integer sub: list) &#123; </span><br><span class="line">        builder.append(sub).append(&quot;,&quot;);</span><br><span class="line">    &#125; </span><br><span class="line">    return builder.substring(0, builder.length() - 1); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这种写法相信比较常见，相对来说不太顺眼的地方就是最后的toString，需要将最后的一个英文逗号给干掉</p>
<p>当然也可以用下面这种事前判断方式，避免最终的字符串截取</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public String join2(List&lt;Integer&gt; list) &#123; </span><br><span class="line">    StringBuilder builder = new StringBuilder(); </span><br><span class="line">    boolean first = true; </span><br><span class="line">    for (Integer sub: list) &#123; </span><br><span class="line">        if (first) &#123; </span><br><span class="line">            first = false; </span><br><span class="line">        &#125; else &#123; </span><br><span class="line">            builder.append(&quot;,&quot;); </span><br><span class="line">        &#125; </span><br><span class="line">        builder.append(sub); </span><br><span class="line">    &#125; </span><br><span class="line">    return builder.toString(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-StringJoiner"><a href="#1-2-StringJoiner" class="headerlink" title="1.2. StringJoiner"></a>1.2. StringJoiner</h3><p>上面实现中，干掉最后的一个分隔符实在不是很优雅，那么有更好一点的用法么，接下来看一下使用 StringJoiner的方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public String join3(List&lt;Integer&gt; list) &#123; </span><br><span class="line">    StringJoiner joiner = new StringJoiner(&quot;,&quot;); </span><br><span class="line">    for (Integer s : list) &#123; </span><br><span class="line">        joiner.add(String.valueOf(s)); </span><br><span class="line">    &#125; </span><br><span class="line">    return joiner.toString(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>StringJoiner由jdk1.8提供，除了上面的基础玩法之外，结合jdk1.8带来的流操作方式，可以更简洁的实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return list.stream().map(String::valueOf).collect(Collectors.joining(&quot;,&quot;));</span><br></pre></td></tr></table></figure>
<p>怎么样，上面这个实现比起前面的代码是不是要简洁多了，一行代码完事</p>
<h3 id="1-3-guava-joiner"><a href="#1-3-guava-joiner" class="headerlink" title="1.3. guava joiner"></a>1.3. guava joiner</h3><p>如果使用的jdk还不是1.8版本，不能使用上面的StringJoiner，没关系，还有guava的Joiner也可以实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public String join5(List&lt;Integer&gt; list) &#123; </span><br><span class="line">    return Joiner.on(&quot;,&quot;).join(list); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<ul>
<li>接收的参数类型为: 数组/Iterable/Iterator/可变参数, 基本上可以覆盖我们日常的业务场景</li>
</ul>
<h2 id="2-小结"><a href="#2-小结" class="headerlink" title="2.小结"></a>2.小结</h2><p>本篇文章的主题是一个非常非常常见的字符串拼接，一般来讲，我们在做字符串拼接时，最麻烦的事情就是分隔符的处理，要么就是分隔符前置添加，每次循环都需要判断是否为开头；要么就是后置，最后取字符串时，干掉最后一个分隔符</p>
<p>本文提供了一个非常使用的方式 StringJoiner ，完全解决了上面的分隔符问题，它的使用有两种场景</p>
<ul>
<li>简单的容器转String：直接借助Stream的 Collectors.joining来实现</li>
<li>for循环 （这种场景一般是for循环内的逻辑不仅仅包括字符串拼接，还包括其他的业务逻辑）： 循环内直接执行 stringJoiner.add()添加</li>
</ul>
<p>对于jdk1.8及以上的版本，优先推荐使用上面说的StringJoiner来实现字符串拼接；至于jdk1.8之下，那么Guava就是一个不错的选择了，使用姿势也很很简单</p>
<h1 id="实战5：驼峰与下划线划转"><a href="#实战5：驼峰与下划线划转" class="headerlink" title="实战5：驼峰与下划线划转"></a>实战5：驼峰与下划线划转</h1><p>这个考题非常实用，特别是对于我们这些号称只需要CURD的后端开发来说，驼峰与下划线互转，这不是属于日常任务么；一般来讲db中的列名，要求是下划线格式（why? 阿里的数据库规范是这么定义的，就我感觉驼峰也没毛病），而java实体命名则是驼峰格式，所以它们之间的互转，就必然存在一个驼峰与下划线的互转</p>
<p>今天我们就来看一下，这两个的互转支持方式</p>
<h2 id="1-实现-1"><a href="#1-实现-1" class="headerlink" title="1.实现"></a>1.实现</h2><h3 id="1-1-Gauva"><a href="#1-1-Gauva" class="headerlink" title="1.1. Gauva"></a>1.1. Gauva</h3><p>一般来讲遇到这种普适性的问题，大部分都是有现成的工具类可以来直接使用的；在java生态中，说到好用的工具百宝箱，guava可以说是排列靠前的</p>
<p>接下来我们看一下如何使用Gauva来实现我们的目的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 驼峰转下划线 </span><br><span class="line">String ans = CaseFormat.LOWER_CAMEL.to(CaseFormat.LOWER_UNDERSCORE, &quot;helloWorld&quot;);</span><br><span class="line">System.out.println(ans); </span><br><span class="line">// 下划线转驼峰 </span><br><span class="line">String ans2 = CaseFormat.LOWER_UNDERSCORE.to(CaseFormat.LOWER_CAMEL, &quot;hello_world&quot;); </span><br><span class="line">System.out.println(ans2);</span><br></pre></td></tr></table></figure>
<p>在这里主要使用的是 CaseFormat来实现互转，guava的CaseFormat还提供了其他几种方式</p>
<p>上面这个虽然可以实现互转，但是如果我们有一个字符串为 helloWorld_Case</p>
<p>将其他转换输出结果如下:</p>
<ul>
<li>下划线： hello_world__case</li>
<li>驼峰： helloworldCase</li>
</ul>
<p>这种输出，和标准的驼峰/下划线不太一样了（当然原因是由于输入也不标准）</p>
<h3 id="1-2-Hutool"><a href="#1-2-Hutool" class="headerlink" title="1.2. Hutool"></a>1.2. Hutool</h3><p>除了上面的guava，hutool的使用也非常广，其中包含很多工具类，其 StrUtil也提供了下划线与驼峰的互转支持</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String ans = StrUtil.toCamelCase(&quot;hello_world&quot;); </span><br><span class="line">System.out.println(ans); </span><br><span class="line">String ans2 = StrUtil.toUnderlineCase(&quot;helloWorld&quot;); </span><br><span class="line">System.out.println(ans2);</span><br></pre></td></tr></table></figure>
<p>同样的我们再来看一下特殊的case</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(StrUtil.toCamelCase(&quot;helloWorld_Case&quot;)); </span><br><span class="line">System.out.println(StrUtil.toUnderlineCase(&quot;helloWorld_Case&quot;));</span><br></pre></td></tr></table></figure>
<p>输出结果如下</p>
<ul>
<li>驼峰： helloworldCase</li>
<li>下划线: hello_world_case</li>
</ul>
<p>相比较上面的guava的场景，下划线这个貌似还行</p>
<h3 id="1-3-自定义实现"><a href="#1-3-自定义实现" class="headerlink" title="1.3. 自定义实现"></a>1.3. 自定义实现</h3><p>接下来为了满足我们希望转换为标砖的驼峰/下划线输出方式的需求，我们自己来手撸一个</p>
<p><strong>下划线转驼峰:</strong></p>
<p>关键点就是找到下划线，然后去掉它，下一个字符转大写续上（如果下一个还是下划线，那继续找下一个）</p>
<p>根据上面这个思路来实现，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private static final char UNDER_LINE = &#x27;_&#x27;; </span><br><span class="line">/** </span><br><span class="line"> * 下划线转驼峰 </span><br><span class="line"> * </span><br><span class="line"> * @param name </span><br><span class="line"> * @return </span><br><span class="line"> */ </span><br><span class="line">public static String toCamelCase(String name) &#123; </span><br><span class="line">    if (null == name || name.length() == 0) &#123; </span><br><span class="line">        return null; </span><br><span class="line">    &#125; </span><br><span class="line">    int length = name.length(); </span><br><span class="line">    StringBuilder sb = new StringBuilder(length); </span><br><span class="line">    boolean underLineNextChar = false; </span><br><span class="line">    for (int i = 0; i &lt; length; ++i) &#123; </span><br><span class="line">        char c = name.charAt(i); </span><br><span class="line">        if (c == UNDER_LINE) &#123; </span><br><span class="line">            underLineNextChar = true; </span><br><span class="line">        &#125; else if (underLineNextChar) &#123; </span><br><span class="line">            sb.append(Character.toUpperCase(c)); </span><br><span class="line">            underLineNextChar = false; </span><br><span class="line">        &#125; else &#123; </span><br><span class="line">            sb.append(c); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    return sb.toString(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>驼峰转下划线</strong></p>
<ul>
<li>关键点：大写的，则前位补一个下划线，当前字符转小写（如果前面已经是一个下划线了，那前面不补，直接转小写即可）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static String toUnderCase(String name) &#123; </span><br><span class="line">    if (name == null) &#123; </span><br><span class="line">        return null; </span><br><span class="line">    &#125; </span><br><span class="line">    int len = name.length(); </span><br><span class="line">    StringBuilder res = new StringBuilder(len + 2); </span><br><span class="line">    char pre = 0; </span><br><span class="line">    for (int i = 0; i &lt; len; i++) &#123; </span><br><span class="line">        char ch = name.charAt(i); </span><br><span class="line">        if (Character.isUpperCase(ch)) &#123;</span><br><span class="line">            if (pre != UNDER_LINE) &#123; </span><br><span class="line">                res.append(UNDER_LINE); </span><br><span class="line">            &#125; </span><br><span class="line">            res.append(Character.toLowerCase(ch)); </span><br><span class="line">        &#125; else &#123; </span><br><span class="line">            res.append(ch); </span><br><span class="line">        &#125; </span><br><span class="line">        pre = ch; </span><br><span class="line">    &#125; </span><br><span class="line">    return res.toString(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次测试 helloWorld_Case ，输出如下</p>
<ul>
<li>驼峰： helloWorldCase</li>
<li>下划线: hello_world_case</li>
</ul>
<h1 id="实战6：枚举的特殊用法"><a href="#实战6：枚举的特殊用法" class="headerlink" title="实战6：枚举的特殊用法"></a>实战6：枚举的特殊用法</h1><p>难道我们日常使用的枚举还有什么特殊的玩法不成？没错，还真有，本文主要介绍枚举的两种不那么常见的使用姿势</p>
<p>利用枚举来实现单例模式</p>
<p>利用枚举来实现策略模式</p>
<h2 id="1-使用场景"><a href="#1-使用场景" class="headerlink" title="1.使用场景"></a>1.使用场景</h2><h3 id="1-1-单例模式"><a href="#1-1-单例模式" class="headerlink" title="1.1. 单例模式"></a>1.1. 单例模式</h3><p>单例模式可以说是每个java开发者必须掌握的一个设计模式了，通常我们说它的实现，有饱汉式和饿汉式，也有经常说的双重判断，今天我们介绍另外一种方式，借助枚举来实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public enum SingleEnum &#123; </span><br><span class="line">    INSTANCE; </span><br><span class="line">    public void print(String word) &#123; </span><br><span class="line">        System.out.println(word); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">@Test </span><br><span class="line">public void testSingle() &#123; </span><br><span class="line">    SingleEnum.INSTANCE.print(&quot;hello world&quot;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用枚举来实现单例模式非常非常简单，将类声明为枚举，内部只定义一个值即可</p>
<p>为什么可以这样做？</p>
<ul>
<li>枚举类不能 new ，因此保证单例</li>
<li>枚举类不能被继承</li>
<li>类不加载时，不会实例化</li>
</ul>
<p>使用枚举类创建的单例有一个好处，就是即使用反射，也无法打破它的单例性质，这是相比较于其他的实现方式的一个优点</p>
<p>那么，为啥在实际的项目中，不太常见这种写法？</p>
<ul>
<li>就我个人的一点认知（不保证准确）：这个与我们对枚举的认知有一定关系，在 《Effect in java》一书中，推荐我们使用这种方式来实现单例，但是在实际的项目开发中，我们更多的将枚举作为常量来使用，很少在枚举类中，添加复杂的业务逻辑</li>
</ul>
<h3 id="1-2-策略模式"><a href="#1-2-策略模式" class="headerlink" title="1.2. 策略模式"></a>1.2. 策略模式</h3><p>枚举除了很容易就实现上面的单例模式之外，还可以非常简单的实现策略模式</p>
<p>举一个简单的例子，我现在有一个接口，通过接受的参数，来决定最终的数据存在什么地方</p>
<p>如果按照正常的写法，可能就是很多的if/else</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void save(String type, Object data) &#123; </span><br><span class="line">    if (&quot;db&quot;.equals(type) &#123; </span><br><span class="line">        // 保存到db </span><br><span class="line">        saveInDb(data); </span><br><span class="line">    &#125; else if (&quot;file&quot;.equals(type))  </span><br><span class="line">        // 保存在文件 </span><br><span class="line">        saveInFile(data); </span><br><span class="line">    &#125; else if (&quot;oss&quot;.eqauls(type)) &#123; </span><br><span class="line">        // 保存在oss </span><br><span class="line">        saveInOss(type); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这种写法虽说简单直观，但是当type类型一多了之后，这个if/else的代码行数就会很多很多了，而且看起来也不美观</p>
<p>接下来我们介绍一种利用枚举，基于策略模式的思想来解决上面的if/else问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public enum SaveStrategyEnum &#123; </span><br><span class="line">    DB(&quot;db&quot;) &#123; </span><br><span class="line">        @Override </span><br><span class="line">        public void save(Object obj) &#123; </span><br><span class="line">            System.out.println(&quot;save in db:&quot; + obj); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;, </span><br><span class="line">    FILE(&quot;file&quot;) &#123; </span><br><span class="line">        @Override </span><br><span class="line">        public void save(Object obj) &#123; </span><br><span class="line">            System.out.println(&quot;save in file: &quot; + obj); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;, </span><br><span class="line">    OSS(&quot;oss&quot;) &#123; </span><br><span class="line">        @Override </span><br><span class="line">        public void save(Object obj) &#123; </span><br><span class="line">            System.out.println(&quot;save in oss: &quot; + obj); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;; </span><br><span class="line">    private String type; </span><br><span class="line">    SaveStrategyEnum(String type) &#123; </span><br><span class="line">        this.type = type; </span><br><span class="line">    &#125; </span><br><span class="line">    public abstract void save(Object obj); </span><br><span class="line">    public static SaveStrategyEnum typeOf(String type) &#123; </span><br><span class="line">        for (SaveStrategyEnum strategyEnum: values()) &#123; </span><br><span class="line">            if (strategyEnum.type.equalsIgnoreCase(type)) &#123; </span><br><span class="line">                return strategyEnum; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        return null; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">public void save(String type, Object data) &#123; </span><br><span class="line">    SaveStrategyEnum strategyEnum = SaveStrategyEnum.typeOf(type); </span><br><span class="line">    if (strategyEnum != null) &#123; </span><br><span class="line">        strategyEnum.save(data); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的实现，主要利用的是抽象类 + 枚举来完成不同的策略具体实现</p>
<p>这种实现方式，相比较与前面的单例模式，还是更常见一点，虽然整体看下来没有什么难度，但是仔细看一看，会发现几个知识点</p>
<ul>
<li>抽象方法的使用 （在模板设计模式中，更能体会抽象方法的使用妙处）</li>
<li>利用枚举原生提供的 values() ，来实现遍历，找到目标</li>
</ul>
<h2 id="2-小结-1"><a href="#2-小结-1" class="headerlink" title="2.小结"></a>2.小结</h2><p>枚举虽然说是jdk原生提供的一个基础数据类型，但是它的使用姿势除了我们熟知的常量之外，还可以有效的运用在设计模式中，让我们的代码实现更优雅</p>
<p>比如使用枚举来实现单例模式，就不用再面对让人烦躁的双重判断/内部类的方式了</p>
<p>使用枚举的策略模式，也可以有效解决我们类中大量的if/else</p>
<h1 id="实战7：排序比较要慎重"><a href="#实战7：排序比较要慎重" class="headerlink" title="实战7：排序比较要慎重"></a>实战7：排序比较要慎重</h1><p>今天介绍的又是一个非常非常基本的基本知识点，为啥要单独拎出来？还是因为这个东西虽然非常简单，但是很容易掉坑，我已经遇到几次不严谨的写法了</p>
<h2 id="1-排序"><a href="#1-排序" class="headerlink" title="1.排序"></a>1.排序</h2><h3 id="1-1-Comparator-与-Comparable"><a href="#1-1-Comparator-与-Comparable" class="headerlink" title="1.1. Comparator 与 Comparable"></a>1.1. Comparator 与 Comparable</h3><p>说到排序，这两个接口好像不太容易绕过去，我们简单介绍下它们的区别</p>
<ul>
<li>如果你有一个类，希望支持同类型的自定义比较策略，可以实现接口 Compareable</li>
<li>如果某个类，没有实现 Compareable接口，但是又希望对它进行比较，则可以自自定义一个Comparator ，来定义这个类的比较规则</li>
</ul>
<p>通过一个简单的实例进行演示说明</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public static class Demo implements Comparable&lt;Demo&gt; &#123; </span><br><span class="line">    int code; </span><br><span class="line">    int age; </span><br><span class="line">    public Demo(int code, int age) &#123; </span><br><span class="line">        this.code = code; </span><br><span class="line">        this.age = age; </span><br><span class="line">    &#125; </span><br><span class="line">    @Override </span><br><span class="line">    public int compareTo(Demo o) &#123; </span><br><span class="line">        if (code == o.code) &#123; </span><br><span class="line">            return 0; </span><br><span class="line">        &#125; else if (code &lt; o.code) &#123; </span><br><span class="line">            return -1; </span><br><span class="line">        &#125; else &#123; </span><br><span class="line">            return 1; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    @Override </span><br><span class="line">    public String toString() &#123; </span><br><span class="line">        return &quot;Demo&#123;&quot; + </span><br><span class="line">                &quot;code=&quot; + code + </span><br><span class="line">                &quot;, age=&quot; + age + </span><br><span class="line">                &#x27;&#125;&#x27;; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的实现中，重点关注 Demo类，实现了 Comparable接口，因此可以直接调用list.sort(null)来进行比较；</p>
<p>但是如果我们现在需求改变了，希望实现针对demo类的age字段，进行升序排列，那么就可以利用 Comparator来实现了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Test </span><br><span class="line">public void testDemoSort() &#123; </span><br><span class="line">    List&lt;Demo&gt; list = new ArrayList&lt;&gt;(); </span><br><span class="line">    list.add(new Demo(10, 30)); </span><br><span class="line">    list.add(new Demo(12, 10)); </span><br><span class="line">    list.add(new Demo(11, 20)); </span><br><span class="line">    // 默认根据 code 进行升序比较 </span><br><span class="line">    list.sort(null); </span><br><span class="line">    System.out.println(&quot;sort by code: &quot; + list); </span><br><span class="line">    list.sort(new Comparator&lt;Demo&gt;() &#123; </span><br><span class="line">        @Override </span><br><span class="line">        public int compare(Demo o1, Demo o2) &#123; </span><br><span class="line">            if (o1.age == o2.age) &#123; </span><br><span class="line">                return 0; </span><br><span class="line">            &#125; else if (o1.age &lt; o2.age) &#123; </span><br><span class="line">                return -1; </span><br><span class="line">            &#125; else &#123; </span><br><span class="line">                return 1; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;); </span><br><span class="line">    System.out.println(&quot;sort by age: &quot; + list); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sort by code: [Demo&#123;code=10, age=30&#125;, Demo&#123;code=11, age=20&#125;, Demo&#123;code=12, age=10&#125;] </span><br><span class="line">sort by age: [Demo&#123;code=12, age=10&#125;, Demo&#123;code=11, age=20&#125;, Demo&#123;code=10, age=30&#125;]</span><br></pre></td></tr></table></figure>
<h3 id="1-2-踩坑预告"><a href="#1-2-踩坑预告" class="headerlink" title="1.2. 踩坑预告"></a>1.2. 踩坑预告</h3><p>再上面的compare方法实现中，我们可以发现里面的实现有点不太美观，我们最终的目的是什么？</p>
<ul>
<li>如果左边的小于右边的，返回 -1</li>
<li>如果左边的大于右边的，返回 0</li>
<li>如果左边的等于右边的，返回 1</li>
</ul>
<p>基于此，经常可以看到的实现如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list.sort(new Comparator&lt;Demo&gt;() &#123; </span><br><span class="line">    @Override </span><br><span class="line">    public int compare(Demo o1, Demo o2) &#123; </span><br><span class="line">       return o1.age - o2.age; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面这个实现虽然简洁了，但是有一个致命的问题，可能溢出!!!</p>
<p>所以请注意，千万千万不要用上面这种写法</p>
<p>那么有没有更优雅的方式呢？</p>
<p>有，使用基础类的 compare方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list.sort(new Comparator&lt;Demo&gt;() &#123; </span><br><span class="line">    @Override </span><br><span class="line">    public int compare(Demo o1, Demo o2) &#123; </span><br><span class="line">       return Integer.compare(o1.age, o2.age); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面这一段代码，再jdk1.8中，可以简化为下面一句</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.sort(Comparator.comparingInt(o -&gt; o.age));</span><br></pre></td></tr></table></figure>
<p>再扩展一下，如果希望倒排呢？</p>
<ul>
<li>第一种实现方式，调换位置</li>
<li>Jdk1.8方式，使用负数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">list.sort(new Comparator&lt;Demo&gt;() &#123; </span><br><span class="line">    @Override </span><br><span class="line">    public int compare(Demo o1, Demo o2) &#123; </span><br><span class="line">       return Integer.compare(o2.age, o1.age); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;); </span><br><span class="line">list.sort(Comparator.comparingInt(o -&gt; -o.age));</span><br></pre></td></tr></table></figure>
<h2 id="2-小结-2"><a href="#2-小结-2" class="headerlink" title="2.小结"></a>2.小结</h2><p>今天主要介绍的知识点是排序，再我们日常使用中，如果一个类希望支持排序，最好的方式就是让它实现 Comparable接口，然后自定义排序方式</p>
<p>这样再容器中，如果需要排序，直接调用 list.sort(null) 或者 CollectionUtils.sort(list)</p>
<p>如果目标类没有实现排序接口，或者希望使用另外一种排序方式，则通过自定义的 Comparator来实现</p>
<p>最后关于 compare方法的实现，设计到两个类的比较，这种最终的落脚地，多半是基础类型的比较</p>
<ul>
<li>o1 与 o2 比较，返回负数，则最终的结果中o1再前面（即升序排列）</li>
<li>不要直接使用 o1-o2会溢出，推荐使用 Integer.compare(o1, o2);</li>
</ul>
<h1 id="实战8：容器的初始化大小指定"><a href="#实战8：容器的初始化大小指定" class="headerlink" title="实战8：容器的初始化大小指定"></a>实战8：容器的初始化大小指定</h1><p>容器可以说是我们日常开发中，除了基本对象之外，使用最多的类了，那么平时在使用的时候，是否有主意到良好编程习惯的大佬，在创建容器的时候，一般会设置size；那么他们为什么要这么干呢？是出于什么进行考量的呢？</p>
<p>今天我们将针对最常见的List/Map/Set三种容器类型的初始化值选择，进行说明</p>
<h2 id="1-容器初始化"><a href="#1-容器初始化" class="headerlink" title="1.容器初始化"></a>1.容器初始化</h2><h3 id="1-1-List"><a href="#1-1-List" class="headerlink" title="1.1. List"></a>1.1. List</h3><p>列表，在我们日常使用过程中，会接触到下面几个</p>
<p>ArrayList: 最常见的数组列表</p>
<p>LinkedList: 基于链表的列表</p>
<p>CopyOnWriteArrayList: 线程安全的数组列表</p>
<p>接下来逐一进行说明</p>
<h4 id="1-1-1-ArrayList"><a href="#1-1-1-ArrayList" class="headerlink" title="1.1.1 ArrayList"></a>1.1.1 ArrayList</h4><p>现在以ArrayList为例，进行源码分析，当我们不指定列表大小，直接创建时</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList() &#123; </span><br><span class="line">    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面是内部实现，其中 elementData就是列表中存数据的数组，初始化为默认数组</p>
<p>当我们第一次添加一个元素时，发现数组为默认值，会触发一次数组扩容，新的数组大小为10（详情看源码）</p>
<p>其次就是数组的库容机制，通过源码/网上分享知识点可以知道，这个扩容的实现如下</p>
<ul>
<li>当新添加的元素，数组放不下时，实现扩容</li>
<li>扩容后的大小 = 扩容前大小 + max(添加元素个数 , 1/2 * 扩容前大小 )</li>
</ul>
<p>基于上面的知识点，大致可以得出指定列表长度的好处</p>
<ul>
<li>节省空间（用多少申请多少，避免浪费）</li>
<li>减少扩容带来的拷贝（扩容一次就会带来一次数组拷贝，如果已知列表很大，结果还使用默认的10，这会产生很多可避免的扩容开销）</li>
</ul>
<h4 id="1-1-2-LinkedList"><a href="#1-1-2-LinkedList" class="headerlink" title="1.1.2 LinkedList"></a>1.1.2 LinkedList</h4><p>基于链表的列表，不同于上面的数组列表，它没有提供指定大小的构造方法，why?</p>
<p>因为链表本身的数据结构的特点，它就像糖葫芦一样，一个串一个，有数据，才有接上的可能，因此不需要指定大小</p>
<h4 id="1-1-3-CopyOnWriteArrayList"><a href="#1-1-3-CopyOnWriteArrayList" class="headerlink" title="1.1.3 CopyOnWriteArrayList"></a>1.1.3 CopyOnWriteArrayList</h4><p>这个又非常有意思，它同样不能指定大小，但是原因与前面不同，主要在于它保证线程安全的实现方式</p>
<ul>
<li>每次新增/修改(加锁，保证单线程访问)，都是在拷贝的数组操作；完成之后，用新的替换旧的</li>
</ul>
<p>所以说，每次变更，都会存在数组拷贝，因此就没有必要提前指定数组大小</p>
<p>那么它的初始化每次都使用默认的么?</p>
<p>并不是这样的，当我们已知这个列表中的值时，推荐使用下面这种方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; values= Arrays.asList(&quot;12&quot;, &quot;220&quot;, &quot;123&quot;); </span><br><span class="line">List&lt;String&gt; cList = new CopyOnWriteArrayList&lt;&gt;(values);</span><br></pre></td></tr></table></figure>
<p>将初始化值，放在一个普通的列表中，然后利用普通列表来初始化 CopyOnWriteArrayList</p>
<h3 id="1-2-Map"><a href="#1-2-Map" class="headerlink" title="1.2.Map"></a>1.2.Map</h3><p>常见的map容器使用，大多是下面几个</p>
<ul>
<li>HashMap</li>
<li>LinkedHashMap : 有序的hashmap</li>
<li>TreeMap : 有序的hashmap</li>
<li>ConcurrentHashMap : 线程安全的map</li>
</ul>
<h4 id="1-2-1-HashMap"><a href="#1-2-1-HashMap" class="headerlink" title="1.2.1 HashMap"></a>1.2.1 HashMap</h4><p>HashMap的底层数据结构是 数组 + 链表/红黑树 ，关于这个就不细说了</p>
<p>我们在初始化时，若不指定size，则数组的默认长度为8（请注意，Map的数组长度是2的倍数）</p>
<p>与ArrayList的扩容时机不一样的是，默认情况下，Map容量没满就会触发一次扩容</p>
<p>默认是数量达到 size * 0.75 (0.75为扩容因子，可以在创建时修改)，就会触发一次扩容</p>
<p>why?</p>
<ul>
<li>主要是为了减少hash冲突</li>
</ul>
<p>同样的为了减少冲突，在初始化时，我们需要指定一个合适大小</p>
<p>比如我们</p>
<ul>
<li>已知map的数量为2，这个时候Map的大小选择因该是4</li>
<li>map数量为6，这个时候Map的大小选择是16</li>
</ul>
<p>有时候让我们自己来计算这个值，就有些麻烦了，这个时候，可以直接使用Guava的工具类来完成这个目的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = Maps.newHashMapWithExpectedSize(6);</span><br></pre></td></tr></table></figure>
<h4 id="1-2-2-LinkedHashMap"><a href="#1-2-2-LinkedHashMap" class="headerlink" title="1.2.2 LinkedHashMap"></a>1.2.2 LinkedHashMap</h4><p>初始化方式同上，略</p>
<h4 id="1-2-3-ConcurrentHashMap"><a href="#1-2-3-ConcurrentHashMap" class="headerlink" title="1.2.3 ConcurrentHashMap"></a>1.2.3 ConcurrentHashMap</h4><p>初始化方式同上，略</p>
<h4 id="1-2-4-TreeMap"><a href="#1-2-4-TreeMap" class="headerlink" title="1.2.4 TreeMap"></a>1.2.4 TreeMap</h4><p>不同于上面几个的是treeMap，没有提供指定容器大小的构造方法</p>
<p>原因和前面说到的LinkedList有些类似，TreeMap的底层数据结构为Tree，所以新增数据是挂在树的一个节点下面，无需指定容量大小</p>
<h3 id="1-3-Set"><a href="#1-3-Set" class="headerlink" title="1.3. Set"></a>1.3. Set</h3><p>集合用的最多应该就是 HashSet了，底层结构模型复用，所以初始化大小指定与HashMap一致，也不需要多说</p>
<h2 id="2-小结-3"><a href="#2-小结-3" class="headerlink" title="2.小结"></a>2.小结</h2><p>今天这篇博文主要介绍的是三种常见的容器，在创建时，如何指定容量大小</p>
<p>首先明确一点，指定容量大小是为了</p>
<ul>
<li>减少扩容带来的额外开销</li>
<li>指定容量代销，可以减少无效的内存开销</li>
</ul>
<p>初始化值设置的关键点:</p>
<ul>
<li>ArrayList: 数据有多少个，初始化值就是多少</li>
<li>HashMap: 考虑到扩容因子，初始化大小 = (size / 0.75 + 1)</li>
</ul>
<h1 id="实战9：List-subList使用不当StackOverflowError"><a href="#实战9：List-subList使用不当StackOverflowError" class="headerlink" title="实战9：List.subList使用不当StackOverflowError"></a>实战9：List.subList使用不当StackOverflowError</h1><p>相信每个小伙伴都使用过 List.subList来获取子列表，日常使用可能没啥问题，但是，请注意，它的使用，很可能一不小心就可能导致oom</p>
<h2 id="1-实例说明"><a href="#1-实例说明" class="headerlink" title="1.实例说明"></a>1.实例说明</h2><h3 id="1-1-subList"><a href="#1-1-subList" class="headerlink" title="1.1. subList"></a>1.1. subList</h3><p>场景复现，如基于list实现一个小顶堆</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Integer&gt; minStack(List&lt;Integer&gt; list, int value, int stackSzie) &#123; </span><br><span class="line">    list.add(value); </span><br><span class="line">    if (list.size() &lt; stackSzie) &#123; </span><br><span class="line">        return list; </span><br><span class="line">    &#125; </span><br><span class="line">    list.sort(null); </span><br><span class="line">    return list.subList(0, stackSzie); </span><br><span class="line">&#125; </span><br><span class="line">@Test </span><br><span class="line">public void testFix() &#123; </span><br><span class="line">    List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); </span><br><span class="line">    for (int i = Integer.MAX_VALUE; i &gt; Integer.MIN_VALUE; i--) &#123; </span><br><span class="line">        list.add(i); </span><br><span class="line">        list = minStack(list, i, 5); </span><br><span class="line">        System.out.println(list); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个执行完毕之后，居然出现栈溢出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// .... </span><br><span class="line">[2147462802, 2147462803, 2147462804, 2147462805, 2147462806] </span><br><span class="line">[2147462801, 2147462802, 2147462803, 2147462804, 2147462805] </span><br><span class="line">java.lang.StackOverflowError </span><br><span class="line">    at java.util.ArrayList$SubList.add(ArrayList.java:1057) </span><br><span class="line">    at java.util.ArrayList$SubList.add(ArrayList.java:1057)</span><br></pre></td></tr></table></figure>
<p>从实现来看，感觉也没啥问题啊， 我们稍微改一下上面的返回</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Integer&gt; minStack(List&lt;Integer&gt; list, int value, int stackSzie) &#123; </span><br><span class="line">    list.add(value); </span><br><span class="line">    if (list.size() &lt; stackSzie) &#123; </span><br><span class="line">        return list; </span><br><span class="line">    &#125; </span><br><span class="line">    list.sort(null); </span><br><span class="line">    return new ArrayList&lt;&gt;(list.subList(0, stackSzie)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次执行，却没有异常；所以关键点就在与</p>
<ul>
<li>list.subList的使用上</li>
</ul>
<h3 id="1-2-StackOverflowError分析"><a href="#1-2-StackOverflowError分析" class="headerlink" title="1.2. StackOverflowError分析"></a>1.2. StackOverflowError分析</h3><p>接下来我们主要看一下 list.subList的实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;E&gt; subList(int fromIndex, int toIndex) &#123; </span><br><span class="line">    subListRangeCheck(fromIndex, toIndex, size); </span><br><span class="line">    return new SubList(this, 0, fromIndex, toIndex); </span><br><span class="line">&#125; </span><br><span class="line">private class SubList extends AbstractList&lt;E&gt; implements RandomAccess &#123; </span><br><span class="line">    private final AbstractList&lt;E&gt; parent; </span><br><span class="line">    private final int parentOffset; </span><br><span class="line">    private final int offset; </span><br><span class="line">    int size; </span><br><span class="line">    SubList(AbstractList&lt;E&gt; parent, </span><br><span class="line">            int offset, int fromIndex, int toIndex) &#123; </span><br><span class="line">        this.parent = parent; </span><br><span class="line">        this.parentOffset = fromIndex; </span><br><span class="line">        this.offset = offset + fromIndex; </span><br><span class="line">        this.size = toIndex - fromIndex; </span><br><span class="line">        this.modCount = ArrayList.this.modCount; </span><br><span class="line">    &#125; </span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面返回的子列表是ArrayList的一个内部类 SubList ，它拥有一个指向父列表的成员 parrent</p>
<p>也就是说，从源头的ArryList开始，后面每次调用 subList ，这个指代关系就深一层</p>
<p>然后它的add方法也很有意思</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void add(int index, E e) &#123; </span><br><span class="line">    rangeCheckForAdd(index); </span><br><span class="line">    checkForComodification(); </span><br><span class="line">    parent.add(parentOffset + index, e); </span><br><span class="line">    this.modCount = parent.modCount; </span><br><span class="line">    this.size++; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点看 parent.add(parentOffset + index, e); ，添加的数据实际上是加在最源头的ArrayList上的，也就是说，虽然你现在拿到的SubList，只有几个元素，但是它对应的数组，可能超乎你的想象</p>
<p>当然上面这个异常主要是以为调用栈溢出（一直往上找parent）</p>
<p>这里反应的另外一个重要问题则是内存泄漏，就不继续说了</p>
<p>如果需要解决上面这个问题，改造方法如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;E&gt; subList(int fromIndex, int toIndex) &#123; </span><br><span class="line">    subListRangeCheck(fromIndex, toIndex, size); </span><br><span class="line">    return new ArrayList&lt;&gt;(new SubList(this, 0, fromIndex, toIndex)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-小结-4"><a href="#2-小结-4" class="headerlink" title="2.小结"></a>2.小结</h2><p>jdk提供的原生方法虽然非常好用，但是在使用的时候，也需要多加注意，一不小心就可能掉进坑里；这也告诉我们多看源码是有必要的</p>
<p>最后一句关键知识点小结：</p>
<ul>
<li>ArrayList.subList 返回的是内部类，与原ArrayList公用一个数组，只是限定了这个数组的起始下标和结束下标而已</li>
<li>在使用 subList ，请注意是否会存在内存泄露和栈溢出的问题</li>
</ul>
<h1 id="实战10：不可变容器"><a href="#实战10：不可变容器" class="headerlink" title="实战10：不可变容器"></a>实战10：不可变容器</h1><p>不可变容器，看着好像在实际的业务中不怎么会用到，但实则不然，相信每个小伙伴都用过，或者看到过下面的代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Collections.emptyList(); </span><br><span class="line">Collections.emptyMap();</span><br></pre></td></tr></table></figure>
<p>今天我们来介绍一下如何使用不可变容器，以及使用时的注意事项</p>
<h2 id="1-不可变容器"><a href="#1-不可变容器" class="headerlink" title="1.不可变容器"></a>1.不可变容器</h2><h3 id="1-1-JDK不可变容器"><a href="#1-1-JDK不可变容器" class="headerlink" title="1.1. JDK不可变容器"></a>1.1. JDK不可变容器</h3><p>java原生提供了一些不可变容器，它们最大的特点就是不支持添加、删除、修改容器内的值</p>
<p>Collections.emptyXxx空容器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Collections.emptyMap(); </span><br><span class="line">Collections.emptyList(); </span><br><span class="line">Collections.emptySet();</span><br></pre></td></tr></table></figure>
<p>上面三个是最常用的几个了，通常当我们一个方法的返回结果定义为容器类型时，可能为了避免npe，在返回空容器时，会如此使用</p>
<p>除了上面这几个空的不可变容器之外，还有</p>
<ul>
<li>UnmodifiableList</li>
<li>UnmodifiableMap</li>
<li>UnmodifiableSet</li>
</ul>
<p>它们的使用姿势，通常是借助 Collections来实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Collections.unmodifiableList(Arrays.asList(1, 2, 3));</span><br></pre></td></tr></table></figure>
<p>如上面创建的List，就不支持set/remove等修改操作</p>
<p>使用不可变容容器，最大的好处就是基于它的不可修改特性，来实现公用，且不会被污染</p>
<ul>
<li>所以一个自然而然能想到的应用场景就是 全局共享的配置</li>
</ul>
<h3 id="1-2-Guava不可变容器"><a href="#1-2-Guava不可变容器" class="headerlink" title="1.2. Guava不可变容器"></a>1.2. Guava不可变容器</h3><p>上面是jdk提供的不可变容器，相比较与它们，在实际的项目中，使用Gauva的不可变容器的可能更多</p>
<ul>
<li>ImmutableXxx ；不可变容器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = ImmutableList.of(1, 2, 3); </span><br><span class="line">Set&lt;Integer&gt; set = ImmutableSet.of(1, 2, 3); </span><br><span class="line">Map&lt;String, Integer&gt; map = ImmutableMap.of(&quot;hello&quot;, 1, &quot;world&quot;, 2);</span><br></pre></td></tr></table></figure>
<p>上面是最常见的三个容器对应的不可变型</p>
<p>从使用角度来看，初始化非常方便（相比较与jdk版而言）</p>
<h2 id="2-注意事项"><a href="#2-注意事项" class="headerlink" title="2.注意事项"></a>2.注意事项</h2><p>不可变容器虽好，但是使用不当也是很坑的；就我个人的一个观点</p>
<ul>
<li>如果是应用内的接口方法，容器传参，返回容器时，尽量不要使用不可变容器；因为你没办法保证别人拿到你的返回容器之后，会对它进行什么操作</li>
<li>如果是对外提供返回结果，特别是null的场景，使用不可变的空容器优于返回null</li>
<li>不可变容器，用于全局公用资源，共享配置参数；多线程的数据传递时，属于比较合适的场景</li>
</ul>
<h1 id="实战11：Map转换Map的几种方式"><a href="#实战11：Map转换Map的几种方式" class="headerlink" title="实战11：Map转换Map的几种方式"></a>实战11：Map转换Map的几种方式</h1><p>在日常开发过程中，从一个Map转换为另外一个Map属于基本操作了，那么我们一般怎么去实现这种场景呢？有什么更简洁省事的方法么？</p>
<h2 id="1-Map互转"><a href="#1-Map互转" class="headerlink" title="1.Map互转"></a>1.Map互转</h2><h3 id="1-1-实例场景"><a href="#1-1-实例场景" class="headerlink" title="1.1 实例场景"></a>1.1 实例场景</h3><p>现在我们给一个简单的实例</p>
<p>希望将一个 Map<String, Integer> 转换成 Map<String, String> ，接下来看一下有哪些实现方式，以及各自的优缺点</p>
<p>首先提供一个创建Map的公共方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private static &lt;T&gt; Map&lt;String, T&gt; newMap(String key, T val, Object... kv) &#123; </span><br><span class="line">    Map&lt;String, T&gt; ans = new HashMap&lt;&gt;(8); </span><br><span class="line">    ans.put(key, val); </span><br><span class="line">    for (int i = 0, size = kv.length; i &lt; size; i += 2) &#123; </span><br><span class="line">        ans.put(String.valueOf(kv[i]), (T) kv[i + 1]); </span><br><span class="line">    &#125; </span><br><span class="line">    return ans; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-1-1-基本的for循环转换"><a href="#1-1-1-基本的for循环转换" class="headerlink" title="1.1.1 基本的for循环转换"></a>1.1.1 基本的for循环转换</h4><p>这种方式是最容易想到和实现的，直接for循环来转换即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Test </span><br><span class="line">public void forEachParse() &#123; </span><br><span class="line">    Map&lt;String, Integer&gt; map = newMap(&quot;k&quot;, 1, &quot;a&quot;, 2, &quot;b&quot;, 3); </span><br><span class="line">    Map&lt;String, String&gt; ans = new HashMap&lt;&gt;(map.size()); </span><br><span class="line">    for (Map.Entry&lt;String, Integer&gt; entry: map.entrySet()) &#123; </span><br><span class="line">        ans.put(entry.getKey(), String.valueOf(entry.getValue())); </span><br><span class="line">    &#125; </span><br><span class="line">    System.out.println(ans); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式的优点很明显，实现容易，业务直观；</p>
<p>缺点就是可复用性较差，代码量多（相比于下面的case）</p>
<h4 id="1-1-2-容器的流式使用"><a href="#1-1-2-容器的流式使用" class="headerlink" title="1.1.2 容器的流式使用"></a>1.1.2 容器的流式使用</h4><p>在jdk1.8提供了流式操作，同样也可以采用这种方式来实现转换</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Test </span><br><span class="line">public void stream() &#123; </span><br><span class="line">    Map&lt;String, Integer&gt; map = newMap(&quot;k&quot;, 1, &quot;a&quot;, 2, &quot;b&quot;, 3); </span><br><span class="line">    Map&lt;String, String&gt; ans = map.entrySet().stream().collect( </span><br><span class="line">            Collectors.toMap(Map.Entry::getKey, s -&gt; String.valueOf(s.getValue()), (a, </span><br><span class="line">b) -&gt; a)); </span><br><span class="line">    System.out.println(ans); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用stream的方式，优点就是链式，代码量少；缺点是相较于上面的阅读体验会差一些（当然这个取决于个人，有些小伙伴就更习惯看这种链式的代码）</p>
<h4 id="1-1-3-Guava的trasform方式"><a href="#1-1-3-Guava的trasform方式" class="headerlink" title="1.1.3 Guava的trasform方式"></a>1.1.3 Guava的trasform方式</h4><p>从代码层面来看，上面两个都不够直观，如果对guava熟悉的小伙伴对下面的代码可能就很熟悉了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Test </span><br><span class="line">public void transfer() &#123; </span><br><span class="line">    Map&lt;String, Integer&gt; map = newMap(&quot;k&quot;, 1, &quot;a&quot;, 2, &quot;b&quot;, 3); </span><br><span class="line">    Map&lt;String, String&gt; ans =  Maps.transformValues(map, String::valueOf); </span><br><span class="line">    System.out.println(ans); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心逻辑就一行 Maps.transformValues(map, String::valueOf) ，实现了我们的Map转换的诉求很明显，这种方式的优点就是间接、直观；当然缺点就是需要引入guava，并且熟悉guava</p>
<h3 id="1-2-最后一问，这篇文章目的是啥？"><a href="#1-2-最后一问，这篇文章目的是啥？" class="headerlink" title="1.2 最后一问，这篇文章目的是啥？"></a>1.2 最后一问，这篇文章目的是啥？</h3><p>既然我们的标题是实战小技巧，本文除了给大家介绍可以使用guava的 Maps.transformValues来实现map转换之外，更主要的一个目的是如果让我们自己来实现一个工具类，来支持这个场景，应该怎么做？</p>
<p>直接提供一个转换方法？</p>
<p><strong>第一步：一个泛型的转换接口</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public &lt;K, T, V&gt; Map&lt;K, V&gt; transform(Map&lt;K, T&gt; map) &#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义上面这个接口之后，自然而然想到的缺点就是差一个value的转换实现</p>
<p><strong>第二步：value转换的定义</strong></p>
<p>这里采用Function接口思想来定义转换类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public &lt;K, T, V&gt; Map&lt;K, V&gt; transform(Map&lt;K, T&gt; map, Function&lt;T, V&gt; func) &#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然到这里我们就需要注意jdk1.8以下是不支持函数编程的，那么我们可以怎么来实现呢？</p>
<p>这个时候再对照一下guava的实现，然后再手撸一个，知识点就到手了</p>
<h1 id="实战12：巧用函数方法实现二维数组遍历"><a href="#实战12：巧用函数方法实现二维数组遍历" class="headerlink" title="实战12：巧用函数方法实现二维数组遍历"></a>实战12：巧用函数方法实现二维数组遍历</h1><p>对于数组遍历，基本上每个开发者都写过，遍历本身没什么好说的，但是当我们在遍历的过程中，有一些复杂的业务逻辑时，将会发现代码的层级会逐渐加深</p>
<p>如一个简单的case，将一个二维数组中的偶数找出来，保存到一个列表中</p>
<p>二维数组遍历，每个元素判断下是否为偶数，很容易就可以写出来，如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void getEven() &#123; </span><br><span class="line">    int[][] cells = new int[][]&#123;&#123;1, 2, 3, 4&#125;, &#123;11, 12, 13, 14&#125;, &#123;21, 22, 23, 24&#125;&#125;; </span><br><span class="line">    List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); </span><br><span class="line">    for (int i = 0; i &lt; cells.length; i ++) &#123; </span><br><span class="line">        for (int j = 0; j &lt; cells[0].length; j++) &#123; </span><br><span class="line">            if ((cells[i][j] &amp; 1) == 0) &#123; </span><br><span class="line">                ans.add(cells[i][j]); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    System.out.println(ans); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个实现没啥问题，但是这个代码的深度很容易就有三层了；当上面这个if中如果再有其他的判定条件，那么这个代码层级很容易增加了；二维数组还好，如果是三维数组，一个遍历就是三层；再加点逻辑，四层、五层不也是分分钟的事情么</p>
<p>那么问题来了，代码层级变多之后会有什么问题呢？</p>
<blockquote>
<p>只要代码能跑，又能有什么问题呢？！</p>
</blockquote>
<p><strong>1.函数方法消减代码层级</strong></p>
<p>由于多维数组的遍历层级天然就很深，那么有办法进行消减么？</p>
<p>要解决这个问题，关键是要抓住重点，遍历的重点是什么？获取每个元素的坐标！那么我们可以怎么办？</p>
<blockquote>
<p>定义一个函数方法，输入的就是函数坐标，在这个函数体中执行我们的遍历逻辑即可</p>
</blockquote>
<p>基于上面这个思路，相信我们可以很容易写一个二维的数组遍历通用方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void scan(int maxX, int maxY, BiConsumer&lt;Integer, Integer&gt; consumer) &#123; </span><br><span class="line"> for (int i = 0; i &lt; maxX; i++) &#123; </span><br><span class="line">     for (int j = 0; j &lt; maxY; j++) &#123; </span><br><span class="line">         consumer.accept(i, j); </span><br><span class="line">     &#125; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要上面的实现，函数方法直接使用了JDK默认提供的BiConsumer，两个传参，都是int 数组下表；无返回值</p>
<p>那么上面这个怎么用呢？</p>
<p>同样是上面的例子，改一下之后，如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void getEven() &#123; </span><br><span class="line">    int[][] cells = new int[][]&#123;&#123;1, 2, 3, 4&#125;, &#123;11, 12, 13, 14&#125;, &#123;21, 22, 23, 24&#125;&#125;; </span><br><span class="line">    List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); </span><br><span class="line">    scan(cells.length, cells[0].length, (i, j) -&gt; &#123; </span><br><span class="line">        if ((cells[i][j] &amp; 1) == 0) &#123; </span><br><span class="line">            ans.add(cells[i][j]); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;); </span><br><span class="line">    System.out.println(ans); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相比于前面的，貌似也就少了一层而已，好像也没什么了不起的</p>
<p>但是，当数组变为三维、四维、无维时，这个改动的写法层级都不会变哦</p>
<p>**2.遍历中return支持</p>
<p>前面的实现对于正常的遍历没啥问题；但是当我们在遍历过程中，遇到某个条件直接返回，能支持么？</p>
<p>如一个遍历二维数组，我们希望判断其中是否有偶数，那么可以怎么整？</p>
<p>仔细琢磨一下我们的scan方法，希望可以支持return，主要的问题点就是这个函数方法执行之后，我该怎么知道是继续循环还是直接return呢?</p>
<p>很容易想到的就是执行逻辑中，添加一个额外的返回值，用于标记是否中断循环直接返回</p>
<p>基于此思路，我们可以实现一个简单的demo版本</p>
<p>定义一个函数方法，接受循环的下标 + 返回值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface </span><br><span class="line">public interface ScanProcess&lt;T&gt; &#123; </span><br><span class="line">    ImmutablePair&lt;Boolean, T&gt; accept(int i, int j); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>循环通用方法就可以相应的改成</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; T scanReturn(int x, int y, ScanProcess&lt;T&gt; func) &#123; </span><br><span class="line">    for (int i = 0; i &lt; x; i++) &#123; </span><br><span class="line">        for (int j = 0; j &lt; y; j++) &#123; </span><br><span class="line">            ImmutablePair&lt;Boolean, T&gt; ans = func.accept(i, j); </span><br><span class="line">            if (ans != null &amp;&amp; ans.left) &#123; </span><br><span class="line">                return ans.right; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    return null; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于上面这种思路，我们的实际使用姿势如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Test </span><br><span class="line">public void getEven() &#123; </span><br><span class="line">    int[][] cells = new int[][]&#123;&#123;1, 2, 3, 4&#125;, &#123;11, 12, 13, 14&#125;, &#123;21, 22, 23, 24&#125;&#125;; </span><br><span class="line">    List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); </span><br><span class="line">    scanReturn(cells.length, cells[0].length, (i, j) -&gt; &#123; </span><br><span class="line">        if ((cells[i][j] &amp; 1) == 0) &#123; </span><br><span class="line">            return ImmutablePair.of(true, i + &quot;_&quot; + j); </span><br><span class="line">        &#125; </span><br><span class="line">        return ImmutablePair.of(false, null); </span><br><span class="line">    &#125;); </span><br><span class="line">    System.out.println(ans); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个实现可满足我们的需求，唯一有个别扭的地方就是返回，总有点不太优雅；那么除了这种方式之外，还有其他的方式么？</p>
<p>既然考虑了返回值，那么再考虑一下传参呢？通过一个定义的参数来装在是否中断以及返回结果，是否可行呢？</p>
<p>基于这个思路，我们可以先定义一个参数包装类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static class Ans&lt;T&gt; &#123; </span><br><span class="line">    private T ans; </span><br><span class="line">    private boolean tag = false; </span><br><span class="line">    public Ans&lt;T&gt; setAns(T ans) &#123; </span><br><span class="line">        tag = true; </span><br><span class="line">        this.ans = ans; </span><br><span class="line">        return this; </span><br><span class="line">    &#125; </span><br><span class="line">    public T getAns() &#123; </span><br><span class="line">        return ans; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">public interface ScanFunc&lt;T&gt; &#123; </span><br><span class="line">    void accept(int i, int j, Ans&lt;T&gt; ans) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们希望通过Ans这个类来记录循环结果，其中tag=true，则表示不用继续循环了，直接返回ans结果吧</p>
<p>与之对应的方法改造及实例如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; T scanReturn(int x, int y, ScanFunc&lt;T&gt; func) &#123; </span><br><span class="line">    Ans&lt;T&gt; ans = new Ans&lt;&gt;(); </span><br><span class="line">    for (int i = 0; i &lt; x; i++) &#123; </span><br><span class="line">        for (int j = 0; j &lt; y; j++) &#123; </span><br><span class="line">            func.accept(i, j, ans); </span><br><span class="line">            if (ans.tag) &#123; </span><br><span class="line">                return ans.ans; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    return null; </span><br><span class="line">&#125; </span><br><span class="line">public void getEven() &#123; </span><br><span class="line">    int[][] cells = new int[][]&#123;&#123;1, 2, 3, 4&#125;, &#123;11, 12, 13, 14&#125;, &#123;21, 22, 23, 24&#125;&#125;; </span><br><span class="line">    String ans = scanReturn(cells.length, cells[0].length, (i, j, a) -&gt; &#123; </span><br><span class="line">        if ((cells[i][j] &amp; 1) == 0) &#123; </span><br><span class="line">            a.setAns(i + &quot;_&quot; + j); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;); </span><br><span class="line">    System.out.println(ans); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样看起来就比前面的要好一点了</p>
<p>实际跑一下，看下输出是否和我们预期的一致；</p>
<p><img src="\assets\project\image-20231106120904767.png" alt="image-20231106120904767"></p>
<h1 id="实战13：List转Map-List的几种姿势"><a href="#实战13：List转Map-List的几种姿势" class="headerlink" title="实战13：List转Map List的几种姿势"></a>实战13：List转Map List的几种姿势</h1><p>今天介绍一个实用的小知识点，如何将List转为 Map<Object, List<Object>&gt;</p>
<h2 id="1-转换方式"><a href="#1-转换方式" class="headerlink" title="1.转换方式"></a>1.转换方式</h2><h3 id="1-1-基本写法"><a href="#1-1-基本写法" class="headerlink" title="1.1. 基本写法"></a>1.1. 基本写法</h3><p>最开始介绍的当然是最常见、最直观的写法，当然也是任何限制的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 比如将下面的列表，按照字符串长度进行分组 </span><br><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;(); </span><br><span class="line">list.add(&quot;hello&quot;); </span><br><span class="line">list.add(&quot;word&quot;); </span><br><span class="line">list.add(&quot;come&quot;); </span><br><span class="line">list.add(&quot;on&quot;); </span><br><span class="line">Map&lt;Integer, List&lt;String&gt;&gt; ans = new HashMap&lt;&gt;(); </span><br><span class="line">for(String str: list) &#123; </span><br><span class="line">    List&lt;String&gt; sub = ans.get(str.length()); </span><br><span class="line">    if(sub == null) &#123; </span><br><span class="line">        sub = new ArrayList&lt;&gt;(); </span><br><span class="line">        ans.put(str.length(), sub); </span><br><span class="line">    &#125; </span><br><span class="line">    sub.add(str); </span><br><span class="line">&#125; </span><br><span class="line">System.out.println(ans);</span><br></pre></td></tr></table></figure>
<p>对于jdk8+，上面for循环中的内容可以利用 Map.computeIfAbsent来替换，具体写法如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (String str : list) &#123; </span><br><span class="line">    ans.computeIfAbsent(str.length(), k -&gt; new ArrayList&lt;&gt;()).add(str); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然既然已经是jdk1.8了，借助Stream的流处理，可以将上面的更一步进行简化，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, List&lt;String&gt;&gt; ans = </span><br><span class="line">list.stream().collect(Collectors.groupingBy(String::length));</span><br></pre></td></tr></table></figure>
<h3 id="1-2-通用方法"><a href="#1-2-通用方法" class="headerlink" title="1.2. 通用方法"></a>1.2. 通用方法</h3><p>上面是针对特定的列表，针对业务进行开发转换，那么我们接下来尝试构建一个通用的工具类</p>
<p>这里我们主要借助的知识点就是泛型，一个重要的点就是如何获取Map中的key</p>
<p>对于jdk &lt; 1.8的写法，通过接口来定义实现key的获取姿势</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;K, V&gt; Map&lt;K, List&lt;V&gt;&gt; toMapList(List&lt;V&gt; list, KeyFunc&lt;V, K&gt; keyFunc) &#123; </span><br><span class="line">    Map&lt;K, List&lt;V&gt;&gt; result = new HashMap&lt;&gt;(); </span><br><span class="line">    for (V item: list) &#123; </span><br><span class="line">        K key = keyFunc.getKey(item); </span><br><span class="line">        if (!result.containsKey(key)) &#123; </span><br><span class="line">            result.put(key, new ArrayList&lt;&gt;()); </span><br><span class="line">        &#125; </span><br><span class="line">        result.get(key).add(item); </span><br><span class="line">    &#125; </span><br><span class="line">    return result; </span><br><span class="line">&#125; </span><br><span class="line">public static interface KeyFunc&lt;T, K&gt; &#123; </span><br><span class="line">    K getKey(T t); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用demo如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123; </span><br><span class="line">    List&lt;String&gt; list = new ArrayList&lt;&gt;(); </span><br><span class="line">    list.add(&quot;hello&quot;); </span><br><span class="line">    list.add(&quot;word&quot;); </span><br><span class="line">    list.add(&quot;come&quot;); </span><br><span class="line">    list.add(&quot;on&quot;); </span><br><span class="line">    Map&lt;Integer, List&lt;String&gt;&gt; res = toMapList(list, new KeyFunc&lt;String, Integer&gt;() &#123; </span><br><span class="line">        @Override </span><br><span class="line">        public Integer getKey(String s) &#123; </span><br><span class="line">            return s.length(); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;); </span><br><span class="line">    System.out.println(res); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来再看一下jdk1.8之后的写法，结合stream + 函数方法来实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;K, V&gt; Map&lt;K, List&lt;V&gt;&gt; toMapList(List&lt;V&gt; list, Function&lt;V, K&gt; func) &#123; </span><br><span class="line">    return list.stream().collect(Collectors.groupingBy(func)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其对应的使用方式则如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123; </span><br><span class="line">    List&lt;String&gt; list = new ArrayList&lt;&gt;(); </span><br><span class="line">    list.add(&quot;hello&quot;); </span><br><span class="line">    list.add(&quot;word&quot;); </span><br><span class="line">    list.add(&quot;come&quot;); </span><br><span class="line">    list.add(&quot;on&quot;); </span><br><span class="line">    Map&lt;Integer, List&lt;String&gt;&gt; res = toMapList(list, (Function&lt;String, Integer&gt;) String::length); </span><br><span class="line">    System.out.println(res); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-工具类"><a href="#1-3-工具类" class="headerlink" title="1.3. 工具类"></a>1.3. 工具类</h3><p>上一节介绍了基于泛型 + jdk8 Stream + 函数方法来实现通用转换工具类的实现姿势，接下来我们小结一下，输出一个适用于1.8之后的工具类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line"> * List&lt;V&gt;转换为Map&lt;K, List&lt;V&gt;&gt; 特点在于Map中的value，是个列表，且列表中的元素就是从原列表</span><br><span class="line">中的元素</span><br><span class="line"> * </span><br><span class="line"> * @param list </span><br><span class="line"> * @param func 基于list#item生成Map.key的函数方法 </span><br><span class="line"> * @param &lt;K&gt; </span><br><span class="line"> * @param &lt;V&gt; </span><br><span class="line"> * @return </span><br><span class="line"> */ </span><br><span class="line">public static &lt;K, V&gt; Map&lt;K, List&lt;V&gt;&gt; toMapList(List&lt;V&gt; list, Function&lt;V, K&gt; func) &#123; </span><br><span class="line">    return list.stream().collect(Collectors.groupingBy(func)); </span><br><span class="line">&#125; </span><br><span class="line">/** </span><br><span class="line"> * List&lt;I&gt;转换为Map&lt;K, List&lt;V&gt;&gt; 特点在于Map中的value是个列表，且列表中的元素是由list.item</span><br><span class="line">转换而来</span><br><span class="line"> * </span><br><span class="line"> * @param list </span><br><span class="line"> * @param keyFunc 基于list#item生成的Map.key的函数方法 </span><br><span class="line"> * @param valFunc 基于list#item转换Map.value列表中元素的函数方法 </span><br><span class="line"> * @param &lt;K&gt; </span><br><span class="line"> * @param &lt;I&gt; </span><br><span class="line"> * @param &lt;V&gt; </span><br><span class="line"> * @return </span><br><span class="line"> */ </span><br><span class="line">public static &lt;K, I, V&gt; Map&lt;K, List&lt;V&gt;&gt; toMapList(List&lt;I&gt; list, Function&lt;I, K&gt; </span><br><span class="line">keyFunc, Function&lt;I, V&gt; valFunc) &#123; </span><br><span class="line">    return list.stream().collect(Collectors.groupingBy(keyFunc, </span><br><span class="line">Collectors.mapping(valFunc, Collectors.toList()))); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-4-guava-HashMultimap扩展知识点"><a href="#1-4-guava-HashMultimap扩展知识点" class="headerlink" title="1.4.guava HashMultimap扩展知识点"></a>1.4.guava HashMultimap扩展知识点</h3><p>最后再介绍一个扩展知识点，Gauva工具包中提供了一个 HashMultimap的工具类，他的使用姿势和我们平常的Map并无差别，但是需要在注意的是，它的value是个集合</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;(); </span><br><span class="line">list.add(&quot;hello&quot;); </span><br><span class="line">list.add(&quot;word&quot;); </span><br><span class="line">list.add(&quot;come&quot;); </span><br><span class="line">list.add(&quot;on&quot;); </span><br><span class="line">list.add(&quot;on&quot;); </span><br><span class="line">HashMultimap&lt;Integer, String&gt; map = HashMultimap.create(); </span><br><span class="line">for (String item: strList) &#123; </span><br><span class="line">    map.put(item.length(), item); </span><br><span class="line">&#125; </span><br><span class="line">System.out.println(map);</span><br></pre></td></tr></table></figure>
<p>实际输出如下，验证了value实际上是个集合（on只有一个，如果是我们上面的工具类，会输出两个）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;2=[on], 4=[word, come], 5=[hello]&#125;</span><br></pre></td></tr></table></figure>
<h1 id="实战14：分页遍历得两种实现策略"><a href="#实战14：分页遍历得两种实现策略" class="headerlink" title="实战14：分页遍历得两种实现策略"></a>实战14：分页遍历得两种实现策略</h1><p>在日常开发中，分页遍历迭代的场景可以说非常普遍了，比如扫表，每次捞100条数据，然后遍历这100条数据，依次执行某个业务逻辑；这100条执行完毕之后，再加载下一百条数据，直到扫描完毕</p>
<p>那么要实现上面这种分页迭代遍历的场景，我们可以怎么做呢</p>
<p>本文将介绍两种使用姿势</p>
<ul>
<li>常规的使用方法</li>
<li>借助Iterator的使用姿势</li>
</ul>
<h2 id="1-实现方式"><a href="#1-实现方式" class="headerlink" title="1.实现方式"></a>1.实现方式</h2><h3 id="1-1-数据查询模拟"><a href="#1-1-数据查询模拟" class="headerlink" title="1.1. 数据查询模拟"></a>1.1. 数据查询模拟</h3><p>首先mock一个分页获取数据的逻辑，直接随机生成数据，并且控制最多返回三页</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static int cnt = 0; </span><br><span class="line">private static List&lt;String&gt; randStr(int start, int size) &#123; </span><br><span class="line">    ++cnt; </span><br><span class="line">    if (cnt &gt; 3) &#123; </span><br><span class="line">        return Collections.emptyList(); </span><br><span class="line">    &#125; else if (cnt == 3) &#123; </span><br><span class="line">        cnt = 0; </span><br><span class="line">        size -= 2; </span><br><span class="line">    &#125; </span><br><span class="line">    System.out.println(&quot;======================= start to gen randList ====================&quot;); </span><br><span class="line">    List&lt;String&gt; ans = new ArrayList&lt;&gt;(size); </span><br><span class="line">    for (int i = 0; i &lt; size; i++) &#123; </span><br><span class="line">        ans.add((start + i) + &quot;_&quot; + UUID.randomUUID().toString()); </span><br><span class="line">    &#125; </span><br><span class="line">    return ans; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-基本实现方式"><a href="#1-2-基本实现方式" class="headerlink" title="1.2. 基本实现方式"></a>1.2. 基本实现方式</h3><p>针对这种场景，最常见也是最简单直观的实现方式</p>
<ul>
<li>while死循环</li>
<li>内部遍历</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private static void scanByNormal() &#123; </span><br><span class="line">    int start = 0; </span><br><span class="line">    int size = 5; </span><br><span class="line">    while (true) &#123; </span><br><span class="line">        List&lt;String&gt; list = randStr(start, size); </span><br><span class="line">        for (String str : list) &#123; </span><br><span class="line">            System.out.println(str); </span><br><span class="line">        &#125; </span><br><span class="line">        if (list.size() &lt; size) &#123; </span><br><span class="line">            break; </span><br><span class="line">        &#125; </span><br><span class="line">        start += list.size(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-迭代器实现方式"><a href="#1-3-迭代器实现方式" class="headerlink" title="1.3. 迭代器实现方式"></a>1.3. 迭代器实现方式</h3><p>接下来介绍一种更有意思的方式，借助迭代器的遍历特性来实现，首先自定义一个通用分页迭代器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public static abstract class MyIterator&lt;T&gt; implements Iterator&lt;T&gt; &#123; </span><br><span class="line">    private int start = 0; </span><br><span class="line">    private int size = 5; </span><br><span class="line">    private int currentIndex; </span><br><span class="line">    private boolean hasMore = true; </span><br><span class="line">    private List&lt;T&gt; list; </span><br><span class="line">    public MyIterator() &#123; </span><br><span class="line">    &#125; </span><br><span class="line">    @Override </span><br><span class="line">    public boolean hasNext() &#123; </span><br><span class="line">        if (list != null &amp;&amp; list.size() &gt; currentIndex) &#123; </span><br><span class="line">            return true; </span><br><span class="line">        &#125; </span><br><span class="line">        // 当前的数据已经加载完毕，尝试加载下一批 </span><br><span class="line">        if (!hasMore) &#123; </span><br><span class="line">            return false; </span><br><span class="line">        &#125; </span><br><span class="line">        list = load(start, size); </span><br><span class="line">        if (list == null || list.isEmpty()) &#123; </span><br><span class="line">            // 没有加载到数据，结束 </span><br><span class="line">            return false; </span><br><span class="line">        &#125; </span><br><span class="line">        if (list.size() &lt; size) &#123; </span><br><span class="line">            // 返回条数小于限制条数，表示还有更多的数据可以加载 </span><br><span class="line">            hasMore = false; </span><br><span class="line">        &#125; </span><br><span class="line">        currentIndex = 0; </span><br><span class="line">        start += list.size(); </span><br><span class="line">        return true; </span><br><span class="line">    &#125; </span><br><span class="line">    @Override </span><br><span class="line">    public T next() &#123; </span><br><span class="line">        return list.get(currentIndex++); </span><br><span class="line">    &#125; </span><br><span class="line">    public abstract List&lt;T&gt; load(int start, int size); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来借助上面的迭代器可以比较简单的实现我们的需求了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private static void scanByIterator() &#123; </span><br><span class="line">    MyIterator&lt;String&gt; iterator = new MyIterator&lt;String&gt;() &#123; </span><br><span class="line">        @Override </span><br><span class="line">        public List&lt;String&gt; load(int start, int size) &#123; </span><br><span class="line">            return randStr(start, size);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;; </span><br><span class="line">    while (iterator.hasNext()) &#123; </span><br><span class="line">        String str = iterator.next(); </span><br><span class="line">        System.out.println(str); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么问题来了，上面这种使用方式比前面的优势体现再哪儿呢？</p>
<ul>
<li>双层循环改为单层循环</li>
</ul>
<p>接下来接入重点了，在jdk1.8引入了函数方法 + lambda之后，又提供了一个更简洁的使用姿势</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public class IteratorTestForJdk18 &#123; </span><br><span class="line">    @FunctionalInterface </span><br><span class="line">    public interface LoadFunc&lt;T&gt; &#123; </span><br><span class="line">        List&lt;T&gt; load(int start, int size); </span><br><span class="line">    &#125; </span><br><span class="line">    public static class MyIterator&lt;T&gt; implements Iterator&lt;T&gt; &#123; </span><br><span class="line">        private int start = 0; </span><br><span class="line">        private int size = 5; </span><br><span class="line">        private int currentIndex; </span><br><span class="line">        private boolean hasMore = true; </span><br><span class="line">        private List&lt;T&gt; list; </span><br><span class="line">        private LoadFunc&lt;T&gt; loadFunc; </span><br><span class="line">        public MyIterator(LoadFunc&lt;T&gt; loadFunc) &#123; </span><br><span class="line">            this.loadFunc = loadFunc; </span><br><span class="line">        &#125; </span><br><span class="line">        @Override </span><br><span class="line">        public boolean hasNext() &#123; </span><br><span class="line">            if (list != null &amp;&amp; list.size() &gt; currentIndex) &#123; </span><br><span class="line">                return true; </span><br><span class="line">            &#125; </span><br><span class="line">            // 当前的数据已经加载完毕，尝试加载下一批 </span><br><span class="line">            if (!hasMore) &#123; </span><br><span class="line">                return false; </span><br><span class="line">            &#125; </span><br><span class="line">            list = loadFunc.load(start, size); </span><br><span class="line">            if (list == null || list.isEmpty()) &#123; </span><br><span class="line">                // 没有加载到数据，结束 </span><br><span class="line">                return false; </span><br><span class="line">            &#125; </span><br><span class="line">            if (list.size() &lt; size) &#123; </span><br><span class="line">                // 返回条数小于限制条数，表示还有更多的数据可以加载 </span><br><span class="line">                hasMore = false; </span><br><span class="line">            &#125; </span><br><span class="line">            currentIndex = 0; </span><br><span class="line">            start += list.size(); </span><br><span class="line">            return true; </span><br><span class="line">        &#125; </span><br><span class="line">        @Override </span><br><span class="line">        public T next() &#123; </span><br><span class="line">            return list.get(currentIndex++); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在jdk1.8及之后的使用姿势，一行代码即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private static void scanByIteratorInJdk8() &#123; </span><br><span class="line">    new MyIterator&lt;&gt;(IteratorTestForJdk18::randStr) </span><br><span class="line">        .forEachRemaining(System.out::println); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这次对比效果是不是非常显眼了，从此以后分页迭代遍历再也不用冗长的双重迭代了</p>
<h1 id="实战15：数组拷贝"><a href="#实战15：数组拷贝" class="headerlink" title="实战15：数组拷贝"></a>实战15：数组拷贝</h1><p>说实话，在实际的业务开发中，基本上很少很少很少…会遇到数组拷贝的场景，甚至是我们一般都不怎么用数组，List它不香嘛，为啥要用数组</p>
<p>现在问题来了，要实现数组拷贝，怎么整？</p>
<h2 id="1-实现方式-1"><a href="#1-实现方式-1" class="headerlink" title="1.实现方式"></a>1.实现方式</h2><h3 id="1-1-基础写法"><a href="#1-1-基础写法" class="headerlink" title="1.1. 基础写法"></a>1.1. 基础写法</h3><p>最简单直接的写法，那就是新建一个数组，一个一个拷贝进去，不就完事了么</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String[] data = new String[]&#123;&quot;1&quot;, &quot;2&quot;, &quot;3&quot;&#125;; </span><br><span class="line">String[] ans = new String[data.length]; </span><br><span class="line">for (int index = 0; index &lt; data.length; index ++) &#123; </span><br><span class="line">    ans[index] = data[index]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-借用容器中转"><a href="#1-2-借用容器中转" class="headerlink" title="1.2. 借用容器中转"></a>1.2. 借用容器中转</h3><p>数组用起来有点麻烦，还是用容器舒爽，借助List来实现数组的拷贝，也就几行代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] data = new String[]&#123;&quot;1&quot;, &quot;2&quot;, &quot;3&quot;&#125;; </span><br><span class="line">List&lt;String&gt; list = Arrays.asList(data);</span><br><span class="line">String[] out = new String[data.length]; </span><br><span class="line">list.toArray(out);</span><br></pre></td></tr></table></figure>
<h3 id="1-3-Array-copy"><a href="#1-3-Array-copy" class="headerlink" title="1.3. Array.copy"></a>1.3. Array.copy</h3><p>上面这个有点绕得远了， 直接使用Array.copy</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] data = new String[]&#123;&quot;1&quot;, &quot;2&quot;, &quot;3&quot;&#125;; </span><br><span class="line">String[] out = Arrays.copyOf(data, data.length);</span><br></pre></td></tr></table></figure>
<h3 id="1-4-System-arraycopy"><a href="#1-4-System-arraycopy" class="headerlink" title="1.4. System.arraycopy"></a>1.4. System.arraycopy</h3><p>除了上面的，还可以使用更基础的用法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] data = new String[]&#123;&quot;1&quot;, &quot;2&quot;, &quot;3&quot;&#125;; </span><br><span class="line">String[] out = new String[data.length]; </span><br><span class="line">System.arraycopy(data, 0, out, 0, data.length);</span><br></pre></td></tr></table></figure>
<p>如果有看过jdk源码的小伙伴，上面这个用法应该不会陌生，特别是在容器类，这种数组拷贝的方式比比可见</p>
<p>参数说明:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static native void arraycopy(Object src,  int  srcPos,</span><br><span class="line">        Object dest, int destPos, </span><br><span class="line">        int length);</span><br></pre></td></tr></table></figure>
<ul>
<li>src : 原数组</li>
<li>srcPos: 原数组用于拷贝的起始下标</li>
<li>dest: 拷贝后的数组</li>
<li>destPos: 目标数组的小标</li>
<li>length: 原数组中拷贝过去的数组长度</li>
</ul>
<p>从上面的描述也能看出来，这个方法不仅能实现数组拷贝，还可以实现数组内指定片段的拷贝</p>
<h1 id="实战16：判断类为基础类型or基础类型的包装类"><a href="#实战16：判断类为基础类型or基础类型的包装类" class="headerlink" title="实战16：判断类为基础类型or基础类型的包装类"></a>实战16：判断类为基础类型or基础类型的包装类</h1><p>判断一个类是否为基础类型属于常规操作了，一般我们遇到这种case，要怎么处理呢？</p>
<p>一个一个的if/else判断? 还是其他的操作姿势？</p>
<h2 id="1-基础类型判断"><a href="#1-基础类型判断" class="headerlink" title="1.基础类型判断"></a>1.基础类型判断</h2><p>基础类型可以借助class类的 isPrimitive方法来实现判定，使用姿势也简单</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.getClass().isPrimitive()</span><br></pre></td></tr></table></figure>
<p>如果返回true，那么这个对象就是基本类型</p>
<ul>
<li>boolean</li>
<li>char</li>
<li>byte</li>
<li>short</li>
<li>int</li>
<li>long</li>
<li>float</li>
<li>double</li>
<li>void</li>
</ul>
<p>但是请注意，对于封装类型，比如Long，访问isPrimitive返回的是false</p>
<h3 id="2-封装类型判断"><a href="#2-封装类型判断" class="headerlink" title="2.封装类型判断"></a>2.封装类型判断</h3><p>那么封装类型可以怎么判断呢？难道一个一个的判定不成？</p>
<p>首先我们注意到 Class#isPrimitive的方法签名，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line"> * @see     java.lang.Boolean#TYPE </span><br><span class="line"> * @see     java.lang.Character#TYPE </span><br><span class="line"> * @see     java.lang.Byte#TYPE </span><br><span class="line"> * @see     java.lang.Short#TYPE </span><br><span class="line"> * @see     java.lang.Integer#TYPE </span><br><span class="line"> * @see     java.lang.Long#TYPE </span><br><span class="line"> * @see     java.lang.Float#TYPE </span><br><span class="line"> * @see     java.lang.Double#TYPE </span><br><span class="line"> * @see     java.lang.Void#TYPE </span><br><span class="line"> * @since JDK1.1 </span><br><span class="line"> */ </span><br><span class="line">public native boolean isPrimitive();</span><br></pre></td></tr></table></figure>
<p>上面的注释中，提到了Boolean#Type之类的静态成员，也就是说包装类型，都有一个TYPE的静态成员</p>
<p>比如boolean的是这个</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&quot;unchecked&quot;) </span><br><span class="line">public static final Class&lt;Boolean&gt; TYPE = (Class&lt;Boolean&gt;) </span><br><span class="line">Class.getPrimitiveClass(&quot;boolean&quot;);</span><br></pre></td></tr></table></figure>
<p>所以我们可以通过这个TYPE来判定，当前对象是否为封装对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123; </span><br><span class="line">    return ((Class) clz.getField(&quot;TYPE&quot;).get(null)).isPrimitive(); </span><br><span class="line">&#125; catch (Exception e) &#123; </span><br><span class="line">    return false; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果Class对象没有TYPE字段，那么就不是封装类，直接抛异常，返回false；当然这种通过异常的方式来判定，并不优雅；但是写法上比我们一个一个的if/else进行对比，要好得多了</p>
<h1 id="实战17：Java对象内存地址输出"><a href="#实战17：Java对象内存地址输出" class="headerlink" title="实战17：Java对象内存地址输出"></a>实战17：Java对象内存地址输出</h1><p><strong>输出对象地址</strong></p>
<p>当一个对象没有重写 hascode方法时，它返回的内存地址，当覆盖之后，我们有什么办法获取对象的内存地址么?</p>
<ul>
<li>使用 System.identityHashCode() 输出内存地址</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123; </span><br><span class="line">    BaseDo base = new BaseDo(); </span><br><span class="line">    base.name = &quot;hello&quot;; </span><br><span class="line">    int addr = System.identityHashCode(base); </span><br><span class="line">    System.out.println(base.hashCode() + &quot;|&quot; + addr); </span><br><span class="line">&#125; </span><br><span class="line">public static class BaseDo &#123; </span><br><span class="line">    String name; </span><br><span class="line">    @Override </span><br><span class="line">    public int hashCode() &#123; </span><br><span class="line">        return super.hashCode(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">997608398|997608398</span><br></pre></td></tr></table></figure>
<p>这个有啥用？</p>
<ul>
<li>判断两个对象是否为同一个对象时，可以借用（我是在验证Mybatis的一级缓存的，判断返回的Entity是否确实是同一个的时候以此来判定的）</li>
</ul>
<h1 id="实战18：随机数生成怎么选"><a href="#实战18：随机数生成怎么选" class="headerlink" title="实战18：随机数生成怎么选"></a>实战18：随机数生成怎么选</h1><p>随机数生成，java中有一个专门的Random类来实现，除此之外，使用 Math.random的也比较多，接下来我们简单学习下，随机数的使用姿势</p>
<h2 id="1-随机数生成"><a href="#1-随机数生成" class="headerlink" title="1.随机数生成"></a>1.随机数生成</h2><h3 id="1-1-Math-random"><a href="#1-1-Math-random" class="headerlink" title="1.1. Math.random"></a>1.1. Math.random</h3><p>jdk提供的基础工具类Math中封装一些常用的基础方法，比如我们今天的主题，生成随机数，使用姿势如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double val = Math.random();</span><br></pre></td></tr></table></figure>
<p>使用起来比较简单，生成的是[0,1)之间的浮点数，但是不要以为它就真的只能生成0-1之间的随机数，举例如下</p>
<p>如果想利用它，生成一个 [120, 500] 这个区间的随机数，怎么整？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int ans = Double.valueOf(Math.ceil(Math.random() * 381 + 120)).intValue();</span><br></pre></td></tr></table></figure>
<p>为啥上面的可行？</p>
<p>将上面的代码翻译一下，取值区间如</p>
<p>Math.random() * 381 + 120 取值范围如下</p>
<ul>
<li>[0, 1) * 381 + 120</li>
<li>[0, 381) + 120</li>
<li>[120, 501)</li>
</ul>
<p>借助 Math.ceil只取浮点数中的整数部分，这样我们的取值范围就是 [120, 500]了，和我们的预期一致</p>
<p>最后简单来看下， Math.random()是怎么实现随机数的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static final class RandomNumberGeneratorHolder &#123; </span><br><span class="line">    static final Random randomNumberGenerator = new Random();</span><br><span class="line">&#125; </span><br><span class="line">public static double random() &#123; </span><br><span class="line">    return RandomNumberGeneratorHolder.randomNumberGenerator.nextDouble(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意上面的实现，原来底层依然使用的是 Random类来生成随机数，而且上面这种写法属于非常经典的单例模式写法（不同于我们常见的双重判定方式，这种属于内部类的玩法，后面再说为啥可以这么用）</p>
<h3 id="1-2-Random"><a href="#1-2-Random" class="headerlink" title="1.2. Random"></a>1.2. Random</h3><p>除了使用上面的Math.random来获取随机数之外，直接使用Random类也是很常见的case；接下来先简单看一下Random的使用姿势</p>
<p><strong>创建Random对象</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 以当前时间戳作为随机种子 </span><br><span class="line">Random random = new Random(); </span><br><span class="line">// 以固定的数字作为随机种子，好处是每次执行时生成的随机数是一致的，便于场景复现 </span><br><span class="line">Random random2 = new Random(10);</span><br></pre></td></tr></table></figure>
<p><strong>生成随机数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// [0, max) 之间的随机整数 </span><br><span class="line">random.nextInt(max); </span><br><span class="line">// 随机返回ture/false </span><br><span class="line">random.nextBoolean() </span><br><span class="line">// 随机长整数 </span><br><span class="line">random.nextLong() </span><br><span class="line">// 随机浮点数 </span><br><span class="line">random.nextFloat() </span><br><span class="line">random.nextDouble()</span><br></pre></td></tr></table></figure>
<p><strong>伪随机高斯分布双精度数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">random.nextGaussian()</span><br></pre></td></tr></table></figure>
<p>随机类的nextGaussian()方法返回下一个伪随机数，即与随机数生成器序列的平均值为0.0，标准差为1.0的高斯(正态)分布双精度值</p>
<p>这种使用场景可能用在更专业的场景，至少我接触过的业务开发中，没有用过这个</p>
<h3 id="1-3-Math-random-与-Random如何选"><a href="#1-3-Math-random-与-Random如何选" class="headerlink" title="1.3. Math.random 与 Random如何选"></a>1.3. Math.random 与 Random如何选</h3><p>上面两个都可以用来生成随机数，那么在实际使用的时候，怎么选择呢？</p>
<p>从前面的描述也可以知道，它们两没啥本质区别，底层都是用的Random类，在实际的运用过程中，如果我们希望可以场景复现，比如测试中奖概率的场景下，选择Random类，指定随机种子可能更友好；如果只是简单的随机数生成使用，那么选择 Math.random即可，至少使用起来一行代码即可</p>
<h1 id="实战19：数字格式化"><a href="#实战19：数字格式化" class="headerlink" title="实战19：数字格式化"></a>实战19：数字格式化</h1><p>数字的格式化场景，更多的是在日志输出、金额计算相关的领域中会用到，平常我们可能更多使用 String.format来格式化，但是请注意，数字格式化是有一个 DecimalFormat ，专门来针对数字进行格式化</p>
<p>今天我们的知识点就是DecimalFormat来实现数字格式化</p>
<h2 id="1-格式化"><a href="#1-格式化" class="headerlink" title="1.格式化"></a>1.格式化</h2><h3 id="1-1-DecimalFormat使用说明"><a href="#1-1-DecimalFormat使用说明" class="headerlink" title="1.1. DecimalFormat使用说明"></a>1.1. DecimalFormat使用说明</h3><p>对于DecimalFormat的使用比较简单，主要是借助两个占位 0与 # ，区别在于当格式化的占位数，多余实际数的时候，占位 0的场景下，会用前缀0来补齐；而 #则不需要补齐</p>
<p>上面这个可能不太好理解，举例说明如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">double num = 3.1415926; </span><br><span class="line">System.out.println(new DecimalFormat(&quot;000&quot;, num)); </span><br><span class="line">System.out.println(new DecimalFormat(&quot;###&quot;, num));</span><br></pre></td></tr></table></figure>
<p>上面两个都是只输出整数，但是输出结果不同，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">003 </span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p>简单来说，就是 0 ，主要用于定长的输出，对于不足的，前缀补0</p>
<p><strong>整数#小数</strong></p>
<p>除了上面的基本姿势之外，更常见的是设置整数、小数的位数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(new DecimalFormat(&quot;000.00&quot;, num)); </span><br><span class="line">System.out.println(new DecimalFormat(&quot;###.##&quot;, num));</span><br></pre></td></tr></table></figure>
<p>输出结果如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">003.14 </span><br><span class="line">3.14</span><br></pre></td></tr></table></figure>
<p><strong>百分比</strong></p>
<p>百分比的输出也属于常见的case，使用DecimalFormat就很简单</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(new DecimalFormat(&quot;000.00%&quot;, num)); </span><br><span class="line">System.out.println(new DecimalFormat(&quot;###.##%&quot;, num));</span><br></pre></td></tr></table></figure>
<p>输出如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">314.16% </span><br><span class="line">314.16%</span><br></pre></td></tr></table></figure>
<p><strong>科学计数</strong></p>
<p>非专业场景下，科学技术的可能性比较小</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(new DecimalFormat(&quot;000.00E0&quot;, num)); </span><br><span class="line">System.out.println(new DecimalFormat(&quot;###.##E0&quot;, num));</span><br></pre></td></tr></table></figure>
<p>输出结果如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">314.16E-2 </span><br><span class="line">3.1416E0</span><br></pre></td></tr></table></figure>
<p><strong>金钱样式输出</strong></p>
<p>金融相关的钱输出时，非常有意思的是每三位加一个逗号分隔，如果想实现这个效果，也可以很简单完成</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double num = 31415926 </span><br><span class="line">System.out.println(new DecimalFormat(&quot;,###&quot;, num));</span><br></pre></td></tr></table></figure>
<p>输出结果如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">31,415,926</span><br></pre></td></tr></table></figure>
<p><strong>嵌入模板输出</strong></p>
<p>格式化模板，除了基础的 000, ###之外，还可以直接放在一个字符串中，实现类似String.format的效果</p>
<p>比如显示余额</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double num = 31415926 </span><br><span class="line">System.out.println(new DecimalFormat(&quot;您的余额,###￥&quot;, num));</span><br></pre></td></tr></table></figure>
<p>输出结果如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">您的余额31,415,926￥</span><br></pre></td></tr></table></figure>
<h1 id="实战20：进制转换很简单"><a href="#实战20：进制转换很简单" class="headerlink" title="实战20：进制转换很简单"></a>实战20：进制转换很简单</h1><p>进制转换，属于基本技能了，在java中要实现进制转换很简单，可以非常简单的实现，接下来我们来看下它的使用姿势</p>
<h2 id="1-进制转换"><a href="#1-进制转换" class="headerlink" title="1.进制转换"></a>1.进制转换</h2><h3 id="1-1-toString实现进制转换"><a href="#1-1-toString实现进制转换" class="headerlink" title="1.1. toString实现进制转换"></a>1.1. toString实现进制转换</h3><p>Integer/Long#toString(int i, int radix) 可以将任一进制的整数，转换为其他任意进制的整数</p>
<ul>
<li>第一个参数：待转换的数字</li>
<li>第二个参数：转换后的进制位</li>
</ul>
<p><strong>十六进制转十进制</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer.toString(0x12, 10)</span><br></pre></td></tr></table></figure>
<p><strong>八进制转是十进制</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer.toString(012, 10)</span><br></pre></td></tr></table></figure>
<h3 id="1-2-十进制转二进制"><a href="#1-2-十进制转二进制" class="headerlink" title="1.2. 十进制转二进制"></a>1.2. 十进制转二进制</h3><p>除了使用上面的姿势之外，可以直接使用 toBinaryString来实现转二进制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer.toBinaryString(2) </span><br><span class="line">Long.toBinaryString(2)</span><br></pre></td></tr></table></figure>
<h3 id="1-3-十进制转八进制"><a href="#1-3-十进制转八进制" class="headerlink" title="1.3. 十进制转八进制"></a>1.3. 十进制转八进制</h3><p>Integer/Long#toOctalString : 转八进制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer.toOctalString(9)</span><br></pre></td></tr></table></figure>
<h3 id="1-4-十进制转十六进制"><a href="#1-4-十进制转十六进制" class="headerlink" title="1.4. 十进制转十六进制"></a>1.4. 十进制转十六进制</h3><p>Integer/Long#toHexString : 转十六进制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer.toHexString(10)</span><br></pre></td></tr></table></figure>
<h1 id="实战21：Properties配置文件"><a href="#实战21：Properties配置文件" class="headerlink" title="实战21：Properties配置文件"></a>实战21：Properties配置文件</h1><p>properties配置文件，相信各位小伙伴都不会太陌生，常用Spring的可能会经常看到它，虽说现在更推荐的是使用Yaml配置文件，但是properties配置文件的使用频率也不低</p>
<p>在jdk中有一个直接关连的类Properties，接下来我们来看一下它的用法</p>
<h2 id="1-Properties配置类"><a href="#1-Properties配置类" class="headerlink" title="1.Properties配置类"></a>1.Properties配置类</h2><h3 id="1-1-配置文件"><a href="#1-1-配置文件" class="headerlink" title="1.1. 配置文件"></a>1.1. 配置文件</h3><p>properties文件的格式比较简单</p>
<ul>
<li>key = value : 等号左边的为配置key，右边的为配置value（value值会去除前后的空格）</li>
<li>#：以 #来区分注释</li>
</ul>
<p>一个基础的配置文件如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 测试 </span><br><span class="line">key = value </span><br><span class="line">user.name = 二哈学习之路</span><br><span class="line">user.age = 18 </span><br><span class="line">user.skill = java,python,js,shell</span><br></pre></td></tr></table></figure></p>
<h3 id="1-2-配置文件加载"><a href="#1-2-配置文件加载" class="headerlink" title="1.2. 配置文件加载"></a>1.2. 配置文件加载</h3><p>对于Properties配置文件，我们可以非常简单的借助 Properties类，来实现配置的加载</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class PropertiesUtil &#123; </span><br><span class="line">    /** </span><br><span class="line">     * 从文件中读取配置 </span><br><span class="line">     * </span><br><span class="line">     * @param propertyFile </span><br><span class="line">     * @return </span><br><span class="line">     * @throws IOException </span><br><span class="line">     */ </span><br><span class="line">    public static Properties loadProperties(String propertyFile) throws IOException &#123; </span><br><span class="line">        Properties config = new Properties(); </span><br><span class="line">        </span><br><span class="line">config.load(PropertiesUtil.class.getClassLoader().getResourceAsStream(propertyFile)); </span><br><span class="line">        return config; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接使用 Properties#config就可以读取配置文件内容，并赋值到java对象</p>
<p><strong>重点注意：</strong></p>
<p>重点看一下Properties类的继承关系，它的父类是Hashtable, 也就是说它的本质是Map对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class Properties extends Hashtable&lt;Object,Object&gt; &#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-Properties对象使用"><a href="#1-3-Properties对象使用" class="headerlink" title="1.3. Properties对象使用"></a>1.3. Properties对象使用</h3><p>因为 Properties是继承自Hashtable，而Hashtable是线程安全的Map容器，因此Properties也是线程安全的，同样的，在多线程并发获取配置的时候，它的性能表现也就不咋地了，why?</p>
<p>首先看一下配置获取</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 获取配置属性 </span><br><span class="line">public String getProperty(String key) &#123; </span><br><span class="line">    Object oval = super.get(key); </span><br><span class="line">    String sval = (oval instanceof String) ? (String)oval : null; </span><br><span class="line">    return ((sval == null) &amp;&amp; (defaults != null)) ? defaults.getProperty(key) : sval; </span><br><span class="line">&#125; </span><br><span class="line">// 获取配置属性，如果不存在，则返回默认值 </span><br><span class="line">public String getProperty(String key, String defaultValue) &#123; </span><br><span class="line">    String val = getProperty(key); </span><br><span class="line">    return (val == null) ? defaultValue : val; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面两个方法的使用频率很高，从签名上也很容易知道使用姿势；接下来需要看一下的为啥说并发效率很低</p>
<p>关键点就在第一个方法的 super.get() ，它对应的源码正是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public synchronized V get(Object key) &#123; </span><br><span class="line">  // ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法签名上有 synchronized ，所以为啥说并发环境下的性能表现不会特别好也就知道原因了</p>
<p>除了获取配置之外，另外一个常用的就是更新配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public synchronized Object setProperty(String key, String value) &#123; </span><br><span class="line">    return put(key, value); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-小结-5"><a href="#2-小结-5" class="headerlink" title="2.小结"></a>2.小结</h2><p>本文介绍的知识点主要是properties配置文件的处理，使用同名的java类来操作；需要重点注意的是Properties类属于Hashtable的子类，同样属于容器的范畴</p>
<p>最后提一个扩展的问题，在SpringBoot的配置自动装载中，可以将配置内容自动装载到配置类中，简单来讲就是支持配置到java bean的映射，如果现在让我们来实现这个，可以怎么整？</p>
<h1 id="实战22：Properties配置文件自动装载JavaBean"><a href="#实战22：Properties配置文件自动装载JavaBean" class="headerlink" title="实战22：Properties配置文件自动装载JavaBean"></a>实战22：Properties配置文件自动装载JavaBean</h1><p>SpringBoot的配置自动装载，使用起来还是很舒爽的，可以非常简单的将properties配置文件的内容，填充到Java bean对象中，如果我们现在是一个脱离于Springboot框架的项目，想实现上面这个功能，可以怎么来做呢？</p>
<h2 id="1-配置封装"><a href="#1-配置封装" class="headerlink" title="1.配置封装"></a>1.配置封装</h2><h3 id="1-1-配置文件自动装载"><a href="#1-1-配置文件自动装载" class="headerlink" title="1.1. 配置文件自动装载"></a>1.1. 配置文件自动装载</h3><p>前面介绍了Properties文件的读取以及基本使用姿势，通过上篇博文已知Properties类的本质是一个Map，所以我们需要干的就是将Map容器的值，赋值到JavaBean的成员属性中</p>
<p>要实现这个功能，自然而然会想到的就是利用反射（考虑到我们赋值的通常为标准的java bean，使用内省是个更好的选择）</p>
<p>接下来我们需要实现的也比较清晰了，第一步获取成员属性，两种方式</p>
<ul>
<li><p>内省: BeanInfo bean = Introspector.getBeanInfo(clz); PropertyDescriptor[]</p>
<p>propertyDescriptors = bean.getPropertyDescriptors();</p>
</li>
<li><p>反射: Field[] fields = clz.getDeclaredFields();</p>
</li>
</ul>
<p>第二步遍历成员属性，进行赋值</p>
<ul>
<li>内省：借助前面获取的 PropertyDescriptor对象，拿到set方法，进行赋值<ul>
<li>descriptor.getWriteMethod().invoke(obj, value)</li>
</ul>
</li>
<li>反射：适应 Field.set来赋值<ul>
<li>field.set(obj, value);</li>
</ul>
</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>上面的两种赋值方式，都要求我们传入的value对象类型与定义类型一直，否则会抛类型转换异常</li>
</ul>
<p>为了避免复杂的类型转换与判定，我们这里介绍下apache的 commons-beanutils来实现属性拷贝</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/commons-beanutils/commons-beanutils --&gt; </span><br><span class="line">&lt;dependency&gt; </span><br><span class="line">    &lt;groupId&gt;commons-beanutils&lt;/groupId&gt; </span><br><span class="line">    &lt;artifactId&gt;commons-beanutils&lt;/artifactId&gt; </span><br><span class="line">    &lt;version&gt;1.9.4&lt;/version&gt; </span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>接下来核心的实现逻辑如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">private static boolean isPrimitive(Class clz) &#123; </span><br><span class="line">    if (clz.isPrimitive()) &#123; </span><br><span class="line">        return true; </span><br><span class="line">    &#125; </span><br><span class="line">    try &#123; </span><br><span class="line">        return ((Class) clz.getField(&quot;TYPE&quot;).get(null)).isPrimitive(); </span><br><span class="line">    &#125; catch (Exception e) &#123; </span><br><span class="line">        return false; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">public static &lt;T&gt; T toBean(Properties properties, Class&lt;T&gt; type, String prefix) throws </span><br><span class="line">IntrospectionException, IllegalAccessException, InstantiationException, </span><br><span class="line">InvocationTargetException &#123; </span><br><span class="line">    if (prefix == null) &#123; </span><br><span class="line">        prefix = &quot;&quot;; </span><br><span class="line">    &#125; else if (!prefix.isEmpty() &amp;&amp; !prefix.endsWith(&quot;.&quot;)) &#123; </span><br><span class="line">        prefix += &quot;.&quot;; </span><br><span class="line">    &#125; </span><br><span class="line">    type.getDeclaredFields(); </span><br><span class="line">    // 内省方式来初始化 </span><br><span class="line">    T obj = type.newInstance(); </span><br><span class="line">    BeanInfo bean = Introspector.getBeanInfo(type); </span><br><span class="line">    PropertyDescriptor[] propertyDescriptors = bean.getPropertyDescriptors(); </span><br><span class="line">    for (PropertyDescriptor descriptor : propertyDescriptors) &#123; </span><br><span class="line">        // 只支持基本数据类型的拷贝 </span><br><span class="line">        Class fieldType = descriptor.getPropertyType(); </span><br><span class="line">        if (fieldType == Class.class) &#123; </span><br><span class="line">            continue;</span><br><span class="line">        &#125; </span><br><span class="line">        if (isPrimitive(fieldType) || fieldType == String.class) &#123; </span><br><span class="line">            // 支持基本类型的转换，如果使用 PropertyUtils, 则不会实现基本类型 + String的</span><br><span class="line">自动转换</span><br><span class="line">            BeanUtils.setProperty(obj, descriptor.getName(), </span><br><span class="line">properties.getProperty(prefix + descriptor.getName())); </span><br><span class="line">        &#125; else &#123; </span><br><span class="line">            BeanUtils.setProperty(obj, descriptor.getName(), toBean(properties, </span><br><span class="line">fieldType, prefix + descriptor.getName())); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    return obj; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意上面的实现，首先通过内省的方式获取所有的成员，然后进行遍历，借助BeanUtils.setProperty来实现属性值设置</p>
<p>这里面有两个知识点</p>
<ul>
<li>BeanUtil 还是 PropertyUtil<ul>
<li>它们两都有个设置属性的方法，但是BeanUtil支持简单类型的自动转换；而后者不行，要求类型完全一致</li>
</ul>
</li>
<li>非简单类型<ul>
<li>对于非简单类型，上面采用了递归的调用方式来处理；请注意，这里并不完善，比如BigDecimal, Date, List, Map这些相对基础的类型，是不太适用的哦</li>
</ul>
</li>
</ul>
<h3 id="1-2-功能测试"><a href="#1-2-功能测试" class="headerlink" title="1.2. 功能测试"></a>1.2. 功能测试</h3><p>最后针对上面的实现功能，简单的测试一下，是否可行</p>
<p>配置文件 mail.properties</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mail.host=localhost </span><br><span class="line">mail.port=25 </span><br><span class="line">mail.smtp.auth=false </span><br><span class="line">mail.smtp.starttlsEnable=false </span><br><span class="line">mail.from=test@yhhblog.com </span><br><span class="line">mail.username=user </span><br><span class="line">mail.password=pwd</span><br></pre></td></tr></table></figure>
<p>两个Java Bean</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Data </span><br><span class="line">public static class MailProperties &#123; </span><br><span class="line">    private String host; </span><br><span class="line">    private Integer port; </span><br><span class="line">    private Smtp smtp; </span><br><span class="line">    private String from; </span><br><span class="line">    private String username; </span><br><span class="line">    private String password; </span><br><span class="line">&#125; </span><br><span class="line">@Data </span><br><span class="line">public static class Smtp &#123; </span><br><span class="line">    private String auth; </span><br><span class="line">    private String starttlsEnable; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转换测试类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static Properties loadProperties(String propertyFile) throws IOException &#123; </span><br><span class="line">    Properties config = new Properties(); </span><br><span class="line">    </span><br><span class="line">config.load(PropertiesUtil.class.getClassLoader().getResourceAsStream(propertyFile)); </span><br><span class="line">    return config; </span><br><span class="line">&#125; </span><br><span class="line">@Test </span><br><span class="line">public void testParse() throws Exception &#123; </span><br><span class="line">    Properties properties = loadProperties(&quot;mail.properties&quot;); </span><br><span class="line">    MailProperties mailProperties = toBean(properties, MailProperties.class, &quot;mail&quot;); </span><br><span class="line">    System.out.println(mailProperties); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PropertiesUtil.MailProperties(host=localhost, port=25, </span><br><span class="line">smtp=PropertiesUtil.Smtp(auth=false, starttlsEnable=false), from=test@yhhblog.com, </span><br><span class="line">username=user, password=pwd)</span><br></pre></td></tr></table></figure>
<h1 id="实战23：基于引入包选择具体实现类"><a href="#实战23：基于引入包选择具体实现类" class="headerlink" title="实战23：基于引入包选择具体实现类"></a>实战23：基于引入包选择具体实现类</h1><p>最近遇到一个需求场景，开源的工具包，新增了一个高级特性，会依赖json序列化工具，来做一些特殊操作；但是，这个辅助功能并不是必须的，也就是说对于使用这个工具包的业务方而言，正常使用完全不需要json相关的功能；如果我强引用某个json工具，一是对于不适用高级特性的用户而言没有必要；二则是我引入的json工具极有可能与使用者的不一致，会增加使用者的成本</p>
<p>因此我希望这个工具包对外提供时，并不会引入具体的json工具依赖；也就是说maven依赖中的<scope>设置为 provided ；具体的json序列化的实现，则取决于调用方自身引入了什么json工具包</p>
<p>那么可以怎么实现上面这个方式呢？</p>
<h2 id="1-实现方式-2"><a href="#1-实现方式-2" class="headerlink" title="1.实现方式"></a>1.实现方式</h2><h3 id="1-1-任务说明"><a href="#1-1-任务说明" class="headerlink" title="1.1. 任务说明"></a>1.1. 任务说明</h3><p>上面的简单的说了一下我们需要做的事情，接下来我们重点盘一下，我们到底是要干什么</p>
<p>核心诉求相对清晰</p>
<ol>
<li>不强引入某个json工具</li>
<li>若需要使用高级特性，则直接使用当前环境中已集成的json序列化工具；若没有提供，则抛异常，不支持</li>
</ol>
<p>对于上面这个场景，常年使用Spring的我们估计不会陌生，Spring集成了很多的第三方开源组件，根据具体的依赖来选择最终的实现，比如日志，可以是logback，也可以是log4j；比如redis操作，可以是jedis，也可以是lettuce</p>
<p>那么Spring是怎么实现的呢？</p>
<h3 id="1-2-具体实现"><a href="#1-2-具体实现" class="headerlink" title="1.2.具体实现"></a>1.2.具体实现</h3><p>在Spring中有个注解名为 ConditionalOnClass ，表示当某个类存在时，才会干某些事情（如初始化bean对象）</p>
<p>它是怎么是实现的呢？（感兴趣的小伙伴可以搜索一下，或者重点关注下 SpringBootCondition的实现）</p>
<p>这里且抛开Spring的实现姿势，我们采用传统的实现方式，直接判断是否有加载对应的类，来判断有没有引入相应的工具包</p>
<p>如需要判断是否引入了gson包，则判断ClassLoader是否有加载 com.google.gson.Gson类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static boolean exist(String name) &#123; </span><br><span class="line">    try &#123; </span><br><span class="line">        return JsonUtil.class.getClassLoader().loadClass(name) != null; </span><br><span class="line">    &#125; catch (Exception e) &#123; </span><br><span class="line">        return false; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这种实现方式就可以达到我们的效果了；接下来我们参考下Spring的ClassUtils实现，做一个简单的封装，以判断是否存在某个类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">// 这段代码来自Spring </span><br><span class="line">// Source code recreated from a .class file by IntelliJ IDEA </span><br><span class="line">// (powered by FernFlower decompiler) </span><br><span class="line">// </span><br><span class="line">import java.lang.reflectArray; </span><br><span class="line">import java.utilHashMap; </span><br><span class="line">import java.util.Map;</span><br><span class="line">/** </span><br><span class="line"> * @author Spring </span><br><span class="line"> */ </span><br><span class="line">public abstract class ClassUtils &#123; </span><br><span class="line">    private static final Map&lt;String, Class&lt;?&gt;&gt; primitiveTypeNameMap = new HashMap(32); </span><br><span class="line">    private static final Map&lt;String, Class&lt;?&gt;&gt; commonClassCache = new HashMap(64); </span><br><span class="line">    private ClassUtils() &#123; </span><br><span class="line">    &#125; </span><br><span class="line">    public static boolean isPresent(String className) &#123; </span><br><span class="line">        try &#123; </span><br><span class="line">            forName(className, getDefaultClassLoader()); </span><br><span class="line">            return true; </span><br><span class="line">        &#125; catch (IllegalAccessError var3) &#123; </span><br><span class="line">            throw new IllegalStateException(&quot;Readability mismatch in inheritance </span><br><span class="line">hierarchy of class [&quot; + className + &quot;]: &quot; + var3.getMessage(), var3); </span><br><span class="line">        &#125; catch (Throwable var4) &#123; </span><br><span class="line">            return false; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    public static boolean isPresent(String className, ClassLoader classLoader) &#123; </span><br><span class="line">        try &#123; </span><br><span class="line">            forName(className, classLoader); </span><br><span class="line">            return true; </span><br><span class="line">        &#125; catch (IllegalAccessError var3) &#123; </span><br><span class="line">            throw new IllegalStateException(&quot;Readability mismatch in inheritance </span><br><span class="line">hierarchy of class [&quot; + className + &quot;]: &quot; + var3.getMessage(), var3); </span><br><span class="line">        &#125; catch (Throwable var4) &#123; </span><br><span class="line">            return false; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    public static Class&lt;?&gt; forName(String name, ClassLoader classLoader) throws </span><br><span class="line">ClassNotFoundException, LinkageError &#123; </span><br><span class="line">        Class&lt;?&gt; clazz = resolvePrimitiveClassName(name); </span><br><span class="line">        if (clazz == null) &#123; </span><br><span class="line">            clazz = (Class) commonClassCache.get(name); </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        if (clazz != null) &#123; </span><br><span class="line">            return clazz; </span><br><span class="line">        &#125; else &#123; </span><br><span class="line">            Class elementClass; </span><br><span class="line">            String elementName; </span><br><span class="line">            if (name.endsWith(&quot;[]&quot;)) &#123; </span><br><span class="line">                elementName = name.substring(0, name.length() - &quot;[]&quot;.length()); </span><br><span class="line">                elementClass = forName(elementName, classLoader); </span><br><span class="line">                return Array.newInstance(elementClass, 0).getClass(); </span><br><span class="line">            &#125; else if (name.startsWith(&quot;[L&quot;) &amp;&amp; name.endsWith(&quot;;&quot;)) &#123; </span><br><span class="line">                elementName = name.substring(&quot;[L&quot;.length(), name.length() - 1); </span><br><span class="line">                elementClass = forName(elementName, classLoader); </span><br><span class="line">                return Array.newInstance(elementClass, 0).getClass(); </span><br><span class="line">            &#125; else if (name.startsWith(&quot;[&quot;)) &#123; </span><br><span class="line">                elementName = name.substring(&quot;[&quot;.length()); </span><br><span class="line">                elementClass = forName(elementName, classLoader); </span><br><span class="line">                return Array.newInstance(elementClass, 0).getClass(); </span><br><span class="line">            &#125; else &#123; </span><br><span class="line">                ClassLoader clToUse = classLoader; </span><br><span class="line">                if (classLoader == null) &#123; </span><br><span class="line">                    clToUse = getDefaultClassLoader(); </span><br><span class="line">                &#125; </span><br><span class="line">                try &#123; </span><br><span class="line">                    return Class.forName(name, false, clToUse); </span><br><span class="line">                &#125; catch (ClassNotFoundException var9) &#123; </span><br><span class="line">                    int lastDotIndex = name.lastIndexOf(46); </span><br><span class="line">                    if (lastDotIndex != -1) &#123; </span><br><span class="line">                        String innerClassName = name.substring(0, lastDotIndex) + &#x27;$&#x27; </span><br><span class="line">+ name.substring(lastDotIndex + 1); </span><br><span class="line">                        try &#123; </span><br><span class="line">                            return Class.forName(innerClassName, false, clToUse); </span><br><span class="line">                        &#125; catch (ClassNotFoundException var8) &#123; </span><br><span class="line">                        &#125; </span><br><span class="line">                    &#125;</span><br><span class="line">                    throw var9; </span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    public static Class&lt;?&gt; resolvePrimitiveClassName(String name) &#123; </span><br><span class="line">        Class&lt;?&gt; result = null; </span><br><span class="line">        if (name != null &amp;&amp; name.length() &lt;= 8) &#123; </span><br><span class="line">            result = (Class) primitiveTypeNameMap.get(name); </span><br><span class="line">        &#125; </span><br><span class="line">        return result; </span><br><span class="line">    &#125; </span><br><span class="line">    public static ClassLoader getDefaultClassLoader() &#123; </span><br><span class="line">        ClassLoader cl = null; </span><br><span class="line">        try &#123; </span><br><span class="line">            cl = Thread.currentThread().getContextClassLoader(); </span><br><span class="line">        &#125; catch (Throwable var3) &#123; </span><br><span class="line">        &#125; </span><br><span class="line">        if (cl == null) &#123; </span><br><span class="line">            cl = ClassUtils.class.getClassLoader(); </span><br><span class="line">            if (cl == null) &#123; </span><br><span class="line">                try &#123; </span><br><span class="line">                    cl = ClassLoader.getSystemClassLoader(); </span><br><span class="line">                &#125; catch (Throwable var2) &#123; </span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        return cl; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>工具类存在之后，我们实现一个简单的json工具类，根据已有的json包来选择具体的实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class JsonUtil &#123; </span><br><span class="line">    private static JsonApi jsonApi; </span><br><span class="line">    private static void initJsonApi() &#123; </span><br><span class="line">        if (jsonApi == null) &#123; </span><br><span class="line">            synchronized (JsonUtil.class) &#123; </span><br><span class="line">                if (jsonApi == null) &#123; </span><br><span class="line">                    if </span><br><span class="line">(ClassUtils.isPresent(&quot;com.fasterxml.jackson.databind.ObjectMapper&quot;, </span><br><span class="line">JsonUtil.class.getClassLoader())) &#123; </span><br><span class="line">                        jsonApi = new JacksonImpl(); </span><br><span class="line">                    &#125; else if (ClassUtils.isPresent(&quot;com.google.gson.Gson&quot;, </span><br><span class="line">JsonUtil.class.getClassLoader())) &#123; </span><br><span class="line">                        jsonApi = new GsonImpl(); </span><br><span class="line">                    &#125; else if (ClassUtils.isPresent(&quot;com.alibaba.fastjson.JSONObject&quot;, </span><br><span class="line">JsonUtil.class.getClassLoader())) &#123; </span><br><span class="line">                        jsonApi = new JacksonImpl(); </span><br><span class="line">                    &#125; else &#123; </span><br><span class="line">                        throw new UnsupportedOperationException(&quot;no json framework to </span><br><span class="line">deserialize string! please import jackson|gson|fastjson&quot;); </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    /** </span><br><span class="line">     * json转实体类，会根据当前已有的json框架来执行反序列化 </span><br><span class="line">     * </span><br><span class="line">     * @param str </span><br><span class="line">     * @param t </span><br><span class="line">     * @param &lt;T&gt; </span><br><span class="line">     * @return </span><br><span class="line">     */ </span><br><span class="line">    public static &lt;T&gt; T toObj(String str, Class&lt;T&gt; t) &#123; </span><br><span class="line">        initJsonApi(); </span><br><span class="line">        return jsonApi.toObj(str, t); </span><br><span class="line">    &#125; </span><br><span class="line">    public static &lt;T&gt; String toStr(T t) &#123; </span><br><span class="line">        initJsonApi(); </span><br><span class="line">        return jsonApi.toStr(t); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的实现中，根据已有的json序列化工具，选择具体的实现类，我们定义了一个JsonApi接口，然后分别gson,jackson,fastjson给出默认的实现类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public interface JsonApi &#123; </span><br><span class="line">    &lt;T&gt; T toObj(String str, Class&lt;T&gt; clz); </span><br><span class="line">    &lt;T&gt; String toStr(T t); </span><br><span class="line">&#125; </span><br><span class="line">public class FastjsonImpl implements JsonApi &#123; </span><br><span class="line">    public &lt;T&gt; T toObj(String str, Class&lt;T&gt; clz) &#123; </span><br><span class="line">        return JSONObject.parseObject(str, clz); </span><br><span class="line">    &#125; </span><br><span class="line">    public &lt;T&gt; String toStr(T t) &#123; </span><br><span class="line">        return JSONObject.toJSONString(t); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">public class GsonImpl implements JsonApi &#123; </span><br><span class="line">    private static final Gson gson = new Gson(); </span><br><span class="line">    public &lt;T&gt; T toObj(String str, Class&lt;T&gt; t) &#123; </span><br><span class="line">        return gson.fromJson(str, t); </span><br><span class="line">    &#125; </span><br><span class="line">    public &lt;T&gt; String toStr(T t) &#123; </span><br><span class="line">        return gson.toJson(t); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">public class JacksonImpl implements JsonApi&#123; </span><br><span class="line">    private static final ObjectMapper jsonMapper = new ObjectMapper(); </span><br><span class="line">    public &lt;T&gt; T toObj(String str, Class&lt;T&gt; clz) &#123; </span><br><span class="line">        try &#123; </span><br><span class="line">            return jsonMapper.readValue(str, clz); </span><br><span class="line">        &#125; catch (Exception e) &#123; </span><br><span class="line">            throw new UnsupportedOperationException(e); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    public &lt;T&gt; String toStr(T t) &#123; </span><br><span class="line">        try &#123; </span><br><span class="line">            return jsonMapper.writeValueAsString(t); </span><br><span class="line">        &#125; catch (Exception e) &#123; </span><br><span class="line">            throw new UnsupportedOperationException(e); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后的问题来了，如果调用方并没有使用上面三个序列化工具，而是使用其他的呢，可以支持么？</p>
<p>既然我们定义了一个JsonApi，那么是不是可以由用户自己来实现接口，然后自动选择它呢？</p>
<p>现在的问题就是如何找到用户自定义的接口实现了</p>
<h3 id="1-3-扩展机制"><a href="#1-3-扩展机制" class="headerlink" title="1.3. 扩展机制"></a>1.3. 扩展机制</h3><p>对于SPI机制比较熟悉的小伙伴可能非常清楚，可以通过在配置目录 META-INF/services/下新增接口文件，内容为实现类的全路径名称，然后通过 ServiceLoader.load(JsonApi.class) 的方式来获取所有实现类</p>
<p>除了SPI的实现方式之外，另外一个策略则是上面提到的Spring的实现原理，借助字节码来处理（详情原理后面专文说明）</p>
<p>当然也有更容易想到的策略，扫描包路径下的class文件，遍历判断是否为实现类(额外注意jar包内的实现类场景)</p>
<p>接下来以SPI的方式来介绍下扩展实现方式，首先初始化JsonApi的方式改一下，优先使用用户自定义实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private static void initJsonApi() &#123; </span><br><span class="line">    if (jsonApi == null) &#123; </span><br><span class="line">        synchronized (JsonUtil.class) &#123; </span><br><span class="line">            if (jsonApi == null) &#123; </span><br><span class="line">                ServiceLoader&lt;JsonApi&gt; loader = ServiceLoader.load(JsonApi.class);</span><br><span class="line">                for (JsonApi value : loader) &#123; </span><br><span class="line">                    jsonApi = value; </span><br><span class="line">                    return; </span><br><span class="line">                &#125; </span><br><span class="line">                if </span><br><span class="line">(ClassUtils.isPresent(&quot;com.fasterxml.jackson.databind.ObjectMapper&quot;, </span><br><span class="line">JsonUtil.class.getClassLoader())) &#123; </span><br><span class="line">                    jsonApi = new JacksonImpl(); </span><br><span class="line">                &#125; else if (ClassUtils.isPresent(&quot;com.google.gson.Gson&quot;, </span><br><span class="line">JsonUtil.class.getClassLoader())) &#123; </span><br><span class="line">                    jsonApi = new GsonImpl(); </span><br><span class="line">                &#125; else if (ClassUtils.isPresent(&quot;com.alibaba.fastjson.JSONObject&quot;, </span><br><span class="line">JsonUtil.class.getClassLoader())) &#123; </span><br><span class="line">                    jsonApi = new JacksonImpl(); </span><br><span class="line">                &#125; else&#123; </span><br><span class="line">                    throw new UnsupportedOperationException(&quot;no json framework to </span><br><span class="line">deserialize string! please import jackson|gson|fastjson&quot;); </span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于使用者而言，首先是实现接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package ; </span><br><span class="line">import JsonApi; </span><br><span class="line">public class DemoJsonImpl implements JsonApi &#123; </span><br><span class="line">    @Override </span><br><span class="line">    public &lt;T&gt; T toObj(String str, Class&lt;T&gt; clz) &#123; </span><br><span class="line">        // ... </span><br><span class="line">    &#125; </span><br><span class="line">    @Override </span><br><span class="line">    public &lt;T&gt; String toStr(T t) &#123; </span><br><span class="line">        // ... </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着就是实现定义, resources/META-INF/services/ 目录下，新建文件名为com.github.hui.quick.plugin.qrcode.util.json.JsonApi</p>
<p>内容如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.github.hui.quick.plugin.test.DemoJsonImpl</span><br></pre></td></tr></table></figure>
<p>然后完工~</p>
<h2 id="2-小结-6"><a href="#2-小结-6" class="headerlink" title="2.小结"></a>2.小结</h2><p>主要介绍一个小的知识点，如何根据应用已有的jar包来选择具体的实现类的方式；本文介绍的方案是通过ClassLoader来尝试加载对应的类，若能正常加载，则认为有；否则认为没有；这种实现方式虽然非常简单，但是请注意，它是有缺陷的，至于缺陷是啥…</p>
<p>除此之外，也可以考虑通过字节码的方式来判断是否有某个类，或者获取某个接口的实现；文中最后抛出了一个问题，如何获取接口的所有实现类</p>
<p>常见的方式有下面三类（具体介绍了SPI的实现姿势，其他的两种感兴趣的可以搜索一下）</p>
<ul>
<li>SPI定义方式</li>
<li>扫描包路径</li>
<li>字节码方式(如Spring，如Tomcat的 @HandlesTypes )</li>
</ul>
<h1 id="实战24：-基于JDK的LRU算法实现"><a href="#实战24：-基于JDK的LRU算法实现" class="headerlink" title="实战24： 基于JDK的LRU算法实现"></a>实战24： 基于JDK的LRU算法实现</h1><h2 id="1-LRU算法"><a href="#1-LRU算法" class="headerlink" title="1.LRU算法"></a>1.LRU算法</h2><p>缓存淘汰算法—LRU算法LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是”如果数据最近被访问过，那么将来被访问的几率也更高”</p>
<p>再Java中可以非常简单的实现LRU算法，主要利用的是LinkedHashMap容器</p>
<h3 id="1-1-LRU算法实现"><a href="#1-1-LRU算法实现" class="headerlink" title="1.1 LRU算法实现"></a>1.1 LRU算法实现</h3><p>LinkedHashMap底层就是用的HashMap加双链表实现的，而且本身已经实现了按照访问顺序的存储。此外，LinkedHashMap中本身就实现了一个方法removeEldestEntry用于判断是否需要移除最不常读取的数，方法默认是直接返回false，不会移除元素</p>
<p>因此我们只需要重写这个方法，可以实现当缓存满之后，就移除最不常用的数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class LruCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; &#123; </span><br><span class="line">    private int size; </span><br><span class="line">    public LruCache(int size) &#123; </span><br><span class="line">        super(size, 0.75f, true); </span><br><span class="line">        this.size = size; </span><br><span class="line">    &#125; </span><br><span class="line">    @Override </span><br><span class="line">    protected boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest) &#123; </span><br><span class="line">        // 当元素个数，超过指定的大小时，淘汰最老的数据 </span><br><span class="line">        return size() &gt; size; </span><br><span class="line">    &#125; </span><br><span class="line">    public static void main(String[] args) &#123; </span><br><span class="line">        LruCache&lt;String, Integer&gt; cache = new LruCache&lt;&gt;(4); </span><br><span class="line">        for (int i = 0; i &lt; 8; i++) &#123; </span><br><span class="line">            if (i == 6) &#123; </span><br><span class="line">                cache.get(&quot;二哈学习之路blog_2&quot;); </span><br><span class="line">            &#125; </span><br><span class="line">            cache.put(&quot;二哈学习之路blog_&quot; + i, i); </span><br><span class="line">            System.out.println(i + &quot;:&quot; + cache); </span><br><span class="line">        &#125; </span><br><span class="line">        System.out.println(cache.size); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意上面的访问，当i == 6 时，主动访问了一下 一灰灰blog_2 ，主要就是不希望淘汰掉它，再看下对应的输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0:&#123;二哈学习之路blog_0=0&#125; </span><br><span class="line">1:&#123;二哈学习之路blog_0=0, 二哈学习之路blog_1=1&#125; </span><br><span class="line">2:&#123;二哈学习之路blog_0=0, 二哈学习之路blog_1=1, 二哈学习之路blog_2=2&#125; </span><br><span class="line">3:&#123;二哈学习之路blog_0=0, 二哈学习之路blog_1=1, 二哈学习之路blog_2=2, 二哈学习之路blog_3=3&#125; </span><br><span class="line">4:&#123;二哈学习之路blog_1=1, 二哈学习之路blog_2=2, 二哈学习之路blog_3=3, 二哈学习之路blog_4=4&#125; </span><br><span class="line">5:&#123;二哈学习之路blog_2=2, 二哈学习之路blog_3=3, 二哈学习之路blog_4=4, 二哈学习之路blog_5=5&#125; </span><br><span class="line">6:&#123;二哈学习之路blog_4=4, 二哈学习之路blog_5=5, 二哈学习之路blog_2=2, 二哈学习之路blog_6=6&#125; </span><br><span class="line">7:&#123;二哈学习之路blog_5=5, 二哈学习之路blog_2=2, 二哈学习之路blog_6=6, 二哈学习之路blog_7=7&#125; </span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<p>实际输出与我们预期一致</p>
<h3 id="1-2-小结"><a href="#1-2-小结" class="headerlink" title="1.2 小结"></a>1.2 小结</h3><p>jdk中蕴含了大量的财富，就看我们能不能识别出来了；通常我非常推荐&lt;3年的小伙伴，有事没事多盘一下jdk的经典实现，比如各种容器的底层结构，并发类的设计思想等</p>
<h1 id="实战25：-数字型字面量中的下划线"><a href="#实战25：-数字型字面量中的下划线" class="headerlink" title="实战25： 数字型字面量中的下划线"></a>实战25： 数字型字面量中的下划线</h1><p>不知道有没有小伙伴看过下面这种写法，不用质疑，它没有语法错误；再很多开源的框架中可以看到类似的写法；这种再字面量中添加下划线的方式，是一种小却使用的编程小技巧，推荐给CURD开发者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">long price = 1_000_123L;</span><br></pre></td></tr></table></figure>
<h2 id="1-Java7新特性之数字中使用下划线"><a href="#1-Java7新特性之数字中使用下划线" class="headerlink" title="1.Java7新特性之数字中使用下划线"></a>1.Java7新特性之数字中使用下划线</h2><p>为了直观性而言，在大数之间，加上下划线用于肉眼区分，下面实例小结下用法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">float pi1 = 3_.1415F; // 无效的; 不能在小数点之前有下划线 </span><br><span class="line">float pi2 = 3._1415F; // 无效的; 不能在小数点之后有下划线 </span><br><span class="line">long socialSecurityNumber1 = 999_99_9999_L; //无效的，不能在L下标之前加下划线 </span><br><span class="line">int a1 = _52; // 这是一个下划线开头的标识符，不是个数字 </span><br><span class="line">int a2 = 5_2; // 有效 </span><br><span class="line">int a3 = 52_; // 无效的，不能以下划线结尾 </span><br><span class="line">int a4 = 5_______2; // 有效的 </span><br><span class="line">int a5 = 0_x52; // 无效，不能在0x之间有下划线 </span><br><span class="line">int a6 = 0x_52; // 无效的，不能在数字开头有下划线</span><br><span class="line">int a7 = 0x5_2; // 有效的 (16进制数字) </span><br><span class="line">int a8 = 0x52_; // 无效的，不能以下划线结尾</span><br><span class="line">int a9 = 0_52; // 有效的（8进制数） </span><br><span class="line">int a10 = 05_2; // 有效的（8进制数） </span><br><span class="line">int a11 = 052_; // 无效的，不能以下划线结尾</span><br><span class="line">long creditCardNumber = 6684_5678_9012_3456l; </span><br><span class="line">long socialSecurityNumber = 333_99_9999l; </span><br><span class="line">float pi = 3.14_15F; </span><br><span class="line">long hexBytes = 0xFF_EC_DE_5E; </span><br><span class="line">long hexWords = 0xCAFE_BABE; </span><br><span class="line">long maxLong = 0x7fff_ffff_ffff_ffffL; </span><br><span class="line">byte nybbles = 0b0010_0101; </span><br><span class="line">long bytes = 0b11010010_01101001_10010100_10010010;</span><br></pre></td></tr></table></figure>
<p>简单来说，就是在数中间，插上下划线，用于划分段落</p>
<h2 id="2-小结-7"><a href="#2-小结-7" class="headerlink" title="2.小结"></a>2.小结</h2><p>再字面量中添加下划线，主要用于分割大数，方便阅读，重点注意：</p>
<ul>
<li>不能在小数点正前后添加</li>
<li>不要在L/D/F等数据类型标识的正前方添加</li>
<li>不能作为数字开头，也不能作为结尾</li>
<li>不要往进制修饰符中间或后面添加</li>
</ul>
<h1 id="实战26：列表遍历删除使用实例"><a href="#实战26：列表遍历删除使用实例" class="headerlink" title="实战26：列表遍历删除使用实例"></a>实战26：列表遍历删除使用实例</h1><p>在实际的业务开发中，容器的遍历可以说是非常非常常见的场景了，遍历删除呢，用的机会也不<br>会少，但你真的会用么？</p>
<h2 id="1-List遍历删除"><a href="#1-List遍历删除" class="headerlink" title="1.List遍历删除"></a>1.List遍历删除</h2><p>对于列表，这里以ArrayList进行举例说明，下面给出几种经常会遇到的写法</p>
<p>首先初始化一个list数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;(); </span><br><span class="line">for (int i = 0; i &lt; 20; i++) &#123; </span><br><span class="line">    list.add(i + &quot;&gt;index&quot;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-1-foreach"><a href="#1-1-foreach" class="headerlink" title="1.1. foreach"></a>1.1. foreach</h3><p>这个属于我们最常见的foreach循环，在循环内部判断满足条件的直接删除</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (String id : list) &#123; </span><br><span class="line"> if (id.contains(&quot;2&quot;)) &#123; </span><br><span class="line">     list.remove(id); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这种写法导致的问题，很容易可以发现，因为上面代码跑完之后，堆栈就出来了</p>
<p><img src="\assets\project\image-20231106154854447.png" alt="image-20231106154854447"></p>
<p>很典型的并发修改错误，在foreach循环中不允许删除,新增</p>
<h3 id="1-2-普通for循环"><a href="#1-2-普通for循环" class="headerlink" title="1.2. 普通for循环"></a>1.2. 普通for循环</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (int index = 0; index &lt; list.size(); index++) &#123; </span><br><span class="line">    if (index % 5 == 0) &#123; </span><br><span class="line">        list.remove(index); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>
<p>上面这种写法呢？我们希望把列表中，第0，5，10，15位置的元素干掉，正常执行，倒是不会报错，然而输出的结果却和我们的预期不一致</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1&gt;index, 2&gt;index, 3&gt;index, 4&gt;index, 5&gt;index, 7&gt;index, 8&gt;index, 9&gt;index, 10&gt;index, </span><br><span class="line">11&gt;index, 13&gt;index, 14&gt;index, 15&gt;index, 16&gt;index, 17&gt;index, 19&gt;index]</span><br></pre></td></tr></table></figure>
<p>for循环中，另外一种写法可能更加常见，为了避免每次都访问 list.size() 方法，我可能提前用一个变量保存数组大小</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int size = list.size(); </span><br><span class="line">for (int index = 0; index &lt; size; index++) &#123; </span><br><span class="line">    if (index % 5 == 0) &#123; </span><br><span class="line">        list.remove(index); </span><br><span class="line">    &#125; else &#123; </span><br><span class="line">        System.out.print(list.get(index)); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个问题就很明显了，数组越界</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2&gt;index3&gt;index4&gt;index5&gt;index8&gt;index9&gt;index10&gt;index11&gt;index14&gt;index15&gt;index16&gt;index17&gt;i</span><br><span class="line">ndexException in thread &quot;main&quot; java.lang.IndexOutOfBoundsException: Index: 16, Size: </span><br><span class="line">16 </span><br><span class="line">  at java.util.ArrayList.rangeCheck(ArrayList.java:659) </span><br><span class="line">  at java.util.ArrayList.get(ArrayList.java:435)</span><br></pre></td></tr></table></figure>
<h3 id="1-3-迭代方式"><a href="#1-3-迭代方式" class="headerlink" title="1.3. 迭代方式"></a>1.3. 迭代方式</h3><p>下面这种可以说是标准的迭代删除的写法了，基本上大多都是这么玩</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; iterator = list.iterator(); </span><br><span class="line">while (iterator.hasNext()) &#123; </span><br><span class="line">    String tmp = iterator.next(); </span><br><span class="line">    if (tmp.contains(&quot;2&quot;)) &#123; </span><br><span class="line">        iterator.remove(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-4-jdk8-流方式"><a href="#1-4-jdk8-流方式" class="headerlink" title="1.4. jdk8+ 流方式"></a>1.4. jdk8+ 流方式</h3><p>jdk8+ 推荐下面这种写法，简洁明了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.removeIf(s -&gt; s.contains(&quot;3&quot;));</span><br></pre></td></tr></table></figure>
<h2 id="2-小结-8"><a href="#2-小结-8" class="headerlink" title="2.小结"></a>2.小结</h2><p>注意不要在for/foreach遍历过程中删除元素，如果有移除元素的需求，使用迭代器；或者使用jdk8的流式写法也行</p>
<h1 id="实战27：HashMap遍历删除使用实例"><a href="#实战27：HashMap遍历删除使用实例" class="headerlink" title="实战27：HashMap遍历删除使用实例"></a>实战27：HashMap遍历删除使用实例</h1><p>map的迭代删除，和我们常见的list，set不太一样，不能直接获取Iteraotr对象，提供的删除方法也是单个的，根据key进行删除，如果我们有个需求，将map中满足某些条件的元素删除掉，要怎么做呢？</p>
<h2 id="1-Map-迭代删除"><a href="#1-Map-迭代删除" class="headerlink" title="1.Map 迭代删除"></a>1.Map 迭代删除</h2><p>迭代删除，在不考虑并发安全的前提下，我们看下可以怎么支持</p>
<h3 id="1-1-非常不优雅版本"><a href="#1-1-非常不优雅版本" class="headerlink" title="1.1. 非常不优雅版本"></a>1.1. 非常不优雅版本</h3><p>我们知道map并不是继承自Collection接口的，HashMap 也没有提供迭代支持，既然没法直接迭代，那我就老老实的low b版好了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); </span><br><span class="line">map.put(&quot;a&quot;, 1); </span><br><span class="line">map.put(&quot;b&quot;, 2); </span><br><span class="line">map.put(&quot;c&quot;, 3); </span><br><span class="line">map.put(&quot;d&quot;, 4); </span><br><span class="line">List&lt;String&gt; removeKey = new ArrayList&lt;&gt;(); </span><br><span class="line">for (Map.Entry&lt;String, Integer&gt; e: map.entrySet()) &#123; </span><br><span class="line">  if (e.getValue() % 2== 0) &#123; </span><br><span class="line">      removeKey.add(e.getKey()); </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line">removeKey.forEach(map::remove);</span><br></pre></td></tr></table></figure>
<p>上面的实现怎么样？并没有什么毛病</p>
<p>(为啥不直接在遍历中删除？）</p>
<h3 id="1-2-正确姿势版"><a href="#1-2-正确姿势版" class="headerlink" title="1.2. 正确姿势版"></a>1.2. 正确姿势版</h3><p>虽然Map没有迭代，但是它的entrySet有啊，所以我们可以通过它来实现遍历删除</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); </span><br><span class="line">map.put(&quot;a&quot;, 1); </span><br><span class="line">map.put(&quot;b&quot;, 2); </span><br><span class="line">map.put(&quot;c&quot;, 3); </span><br><span class="line">map.put(&quot;d&quot;, 4); </span><br><span class="line">Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = map.entrySet().iterator(); </span><br><span class="line">Map.Entry&lt;String, Integer&gt; entry; </span><br><span class="line">while (iterator.hasNext()) &#123; </span><br><span class="line">    entry = iterator.next(); </span><br><span class="line">    if (entry.getValue() % 2 == 0) &#123; </span><br><span class="line">        iterator.remove(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">System.out.println(map);</span><br></pre></td></tr></table></figure>
<p>上面这个可能是我们经常使用的操作姿势了，利用迭代器来操作元素</p>
<h3 id="1-3-简洁版"><a href="#1-3-简洁版" class="headerlink" title="1.3. 简洁版"></a>1.3. 简洁版</h3><p>到jdk8之后，针对容器提供了很多简洁的操作方式，迭代删除这方面可以说更加简单了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); </span><br><span class="line">map.put(&quot;a&quot;, 1); </span><br><span class="line">map.put(&quot;b&quot;, 2); </span><br><span class="line">map.put(&quot;c&quot;, 3); </span><br><span class="line">map.put(&quot;d&quot;, 4); </span><br><span class="line">map.entrySet().removeIf(entry -&gt; entry.getValue() % 2 == 0);</span><br></pre></td></tr></table></figure>
<h2 id="2-小结-9"><a href="#2-小结-9" class="headerlink" title="2.小结"></a>2.小结</h2><p>和列表删除元素一样，不要在for/foreach迭代过程中删除数据，如有需要，迭代器才是正解；jdk8之后更推荐流式写法</p>
<h1 id="实战28：优雅的实现代码耗时统计"><a href="#实战28：优雅的实现代码耗时统计" class="headerlink" title="实战28：优雅的实现代码耗时统计"></a>实战28：优雅的实现代码耗时统计</h1><p>在我们的实际开发中，多多少少会遇到统计一段代码片段的耗时的情况，我们一般的写法如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">long start = System.currentTimeMillis(); </span><br><span class="line">try &#123; </span><br><span class="line">    // .... 具体的代码段 </span><br><span class="line">&#125; finally &#123; </span><br><span class="line">    System.out.println(&quot;cost: &quot; + (System.currentTimeMillis() - start)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的写法没有什么毛病，但是看起来就不太美观了，那么有没有什么更优雅的写法呢？</p>
<h2 id="1-代理方式"><a href="#1-代理方式" class="headerlink" title="1.代理方式"></a>1.代理方式</h2><p>了解Spring AOP的同学可能立马会想到一个解决方法，如果想要统计某个方法耗时，使用切面可以无侵入的实现，如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 定义切点，拦截所有满足条件的方法 </span><br><span class="line">@Pointcut(&quot;execution(public * com.git.hui.boot.aop.demo.*.*(*))&quot;) </span><br><span class="line">public void point() &#123; </span><br><span class="line">&#125; </span><br><span class="line">@Around(&quot;point()&quot;) </span><br><span class="line">public Object doAround(ProceedingJoinPoint joinPoint) throws Throwable &#123; </span><br><span class="line"> long start = System.currentTimeMillis(); </span><br><span class="line"> try&#123; </span><br><span class="line">     return joinPoint.proceed(); </span><br><span class="line"> &#125; finally &#123; </span><br><span class="line">     System.out.println(&quot;cost: &quot; + (System.currentTimeMillis() - start)); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring AOP的底层支持原理为代理模式，为目标对象提供增强功能；在Spring的生态体系下，使用aop的方式来统计方法耗时，可以说少侵入且实现简单，但是有以下几个问题</p>
<ul>
<li>统计粒度为方法级别</li>
<li>类内部方法调用无法生效</li>
</ul>
<h2 id="2-AutoCloseable"><a href="#2-AutoCloseable" class="headerlink" title="2.AutoCloseable"></a>2.AutoCloseable</h2><p>在JDK1.7引入了一个新的接口 AutoCloseable , 通常它的实现类配合 try{}使用，可在IO流的使用上，经常可以看到下面这种写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 读取文件内容并输出 </span><br><span class="line">try (Reader stream = new BufferedReader(new InputStreamReader(new </span><br><span class="line">FileInputStream(&quot;/tmp&quot;)))) &#123; </span><br><span class="line">    List&lt;String&gt; list = ((BufferedReader) </span><br><span class="line">stream).lines().collect(Collectors.toList()); </span><br><span class="line">    System.out.println(list); </span><br><span class="line">&#125; catch (IOException e) &#123; </span><br><span class="line">    e.printStackTrace(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意上面的写法中，最值得关注一点是，不需要再主动的写 stream.close了，主要原因就是在try(){}执行完毕之后，会调用方法 AutoCloseable#close方法；</p>
<p>基于此，我们就会有一个大单的想法，下一个 Cost类实现 AutoCloseable接口，创建时记录一个时间，close方法中记录一个时间，并输出时间差值；将需要统计耗时的逻辑放入 try(){}代码块</p>
<p>下面是一个具体的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public static class Cost implements AutoCloseable &#123; </span><br><span class="line">    private long start; </span><br><span class="line">    public Cost() &#123; </span><br><span class="line">        this.start = System.currentTimeMillis(); </span><br><span class="line">    &#125; </span><br><span class="line">    @Override </span><br><span class="line">    public void close() &#123; </span><br><span class="line">        System.out.println(&quot;cost: &quot; + (System.currentTimeMillis() - start)); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">public static void testPrint() &#123; </span><br><span class="line">    for (int i = 0; i &lt; 5; i++) &#123; </span><br><span class="line">        System.out.println(&quot;now &quot; + i); </span><br><span class="line">        try &#123; </span><br><span class="line">            Thread.sleep(10); </span><br><span class="line">        &#125; catch (InterruptedException e) &#123; </span><br><span class="line">            e.printStackTrace(); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">public static void main(String[] args) &#123; </span><br><span class="line">    try (Cost c = new Cost()) &#123; </span><br><span class="line">        testPrint(); </span><br><span class="line">    &#125; </span><br><span class="line">    System.out.println(&quot;------over-------&quot;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行后输出如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">now 0 </span><br><span class="line">now 1 </span><br><span class="line">now 2 </span><br><span class="line">now 3 </span><br><span class="line">now 4 </span><br><span class="line">cost: 55 </span><br><span class="line">------over-------</span><br></pre></td></tr></table></figure>
<p>如果代码块抛异常，也会正常输出耗时么？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static void testPrint() &#123; </span><br><span class="line">    for (int i = 0; i &lt; 5; i++) &#123; </span><br><span class="line">        System.out.println(&quot;now &quot; + i); </span><br><span class="line">        try &#123; </span><br><span class="line">            Thread.sleep(10); </span><br><span class="line">        &#125; catch (InterruptedException e) &#123; </span><br><span class="line">            e.printStackTrace(); </span><br><span class="line">        &#125; </span><br><span class="line">        if (i == 3) &#123; </span><br><span class="line">            throw new RuntimeException(&quot;some exception!&quot;); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次输出如下，并没有问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">now 0 </span><br><span class="line">now 1 </span><br><span class="line">now 2 </span><br><span class="line">now 3 </span><br><span class="line">cost: 46 </span><br><span class="line">Exception in thread &quot;main&quot; java.lang.RuntimeException: some exception! </span><br><span class="line">  at com.git.hui.boot.order.Application.testPrint(Application.java:43) </span><br><span class="line">  at com.git.hui.boot.order.Application.main(Application.java:50)</span><br></pre></td></tr></table></figure>
<h2 id="3-小结-3"><a href="#3-小结-3" class="headerlink" title="3.小结"></a>3.小结</h2><p>除了上面介绍的两种方式，还有一种在业务开发中不太常见，但是在中间件、偏基础服务的功能组件中可以看到，利用Java Agent探针技术来实现，比如阿里的arthas就是在JavaAgent的基础上做了各种上天的功能，后续介绍java探针技术时会专门介绍</p>
<p>下面小结一下三种统计耗时的方式</p>
<p><strong>基本写法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">long start = System.currentTimeMillis(); </span><br><span class="line">try &#123; </span><br><span class="line"> // .... 具体的代码段 </span><br><span class="line">&#125; finally &#123; </span><br><span class="line"> System.out.println(&quot;cost: &quot; + (System.currentTimeMillis() - start)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优点是简单，适用范围广泛；缺点是侵入性强，大量的重复代码</p>
<p><strong>Spring AOP</strong></p>
<p>在Spring生态下，可以借助AOP来拦截目标方法，统计耗时</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Around(&quot;...&quot;) </span><br><span class="line">public Object doAround(ProceedingJoinPoint joinPoint) throws Throwable &#123; </span><br><span class="line">    long start = System.currentTimeMillis(); </span><br><span class="line">    try&#123; </span><br><span class="line">        return joinPoint.proceed(); </span><br><span class="line">    &#125; finally &#123; </span><br><span class="line">        System.out.println(&quot;cost: &quot; + (System.currentTimeMillis() - start)); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优点：无侵入，适合统一管理（比如测试环境输出统计耗时，生产环境不输出）；缺点是适用范围小，且粒度为方法级别，并受限于AOP的使用范围</p>
<p><strong>AutoCloseable</strong></p>
<p>这种方式可以看做是第一种写法的进阶版</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 定义类 </span><br><span class="line">public static class Cost implements AutoCloseable &#123; </span><br><span class="line">    private long start; </span><br><span class="line">    public Cost() &#123; </span><br><span class="line">        this.start = System.currentTimeMillis(); </span><br><span class="line">    &#125; </span><br><span class="line">    @Override </span><br><span class="line">    public void close() &#123; </span><br><span class="line">        System.out.println(&quot;cost: &quot; + (System.currentTimeMillis() - start)); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">// 使用姿势 </span><br><span class="line">try (Cost c = new Cost()) &#123; </span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优点是：简单，适用范围广泛，且适合统一管理；缺点是依然有代码侵入</p>
<p><strong>说明</strong></p>
<p>上面第二种方法看着属于最优雅的方式，但是限制性强；如果有更灵活的需求，建议考虑第三种写法，在代码的简洁性和统一管理上都要优雅很多，相比较第一种可以减少大量冗余代码</p>
<h1 id="实战29：获取类路径的常见方式"><a href="#实战29：获取类路径的常见方式" class="headerlink" title="实战29：获取类路径的常见方式"></a>实战29：获取类路径的常见方式</h1><h2 id="1-资源路径查询"><a href="#1-资源路径查询" class="headerlink" title="1.资源路径查询"></a>1.资源路径查询</h2><p>在Java环境中，如何获取当前类的路径，如何获取项目根路径，可以说是比较常见的需求场景了，下面简单的记录一下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Test </span><br><span class="line">public void showURL() throws IOException &#123; </span><br><span class="line">    // 第一种：获取类加载的根路径 </span><br><span class="line">    File f = new File(this.getClass().getResource(&quot;/&quot;).getPath()); </span><br><span class="line">    System.out.println(f); </span><br><span class="line">    // 获取当前类的所在工程路径; 如果不加“/”  获取当前类的加载目录 </span><br><span class="line">    File f2 = new File(this.getClass().getResource(&quot;&quot;).getPath()); </span><br><span class="line">    System.out.println(f2); </span><br><span class="line">    // 第二种：获取项目路径 </span><br><span class="line">    File directory = new File(&quot;&quot;);// 参数为空 </span><br><span class="line">    String courseFile = directory.getCanonicalPath(); </span><br><span class="line">    System.out.println(courseFile); </span><br><span class="line">    // 第三种：根据系统资源获取 </span><br><span class="line">    URL xmlpath = this.getClass().getClassLoader().getResource(&quot;&quot;); </span><br><span class="line">    System.out.println(xmlpath); </span><br><span class="line">    // 第四种：系统变量 </span><br><span class="line">    System.out.println(System.getProperty(&quot;user.dir&quot;)); </span><br><span class="line">    // 第五种：获取所有的类路径 包括jar包的路径 </span><br><span class="line">    System.out.println(System.getProperty(&quot;java.class.path&quot;)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/Users/user/Project/hui/testApp/pair/target/test-classes </span><br><span class="line">/Users/user/Project/hui/testApp/pair/target/test-classes/net/finbtc/coin/test </span><br><span class="line">/Users/user/Project/hui/testApp/pair </span><br><span class="line">file:/Users/user/Project/hui/testApp/pair/target/test-classes/ </span><br><span class="line">/Users/user/Project/hui/testApp/pair </span><br><span class="line">/Applications/IntelliJ IDEA.app/Contents/lib/idea_rt.jar:... （太长省略）</span><br></pre></td></tr></table></figure>
<h2 id="2-小结-10"><a href="#2-小结-10" class="headerlink" title="2.小结"></a>2.小结</h2><ul>
<li>new File(this.getClass().getResource(“/“).getPath())<ul>
<li>获取类加载的根路径</li>
</ul>
</li>
<li>new File(this.getClass().getResource(“”).getPath())<ul>
<li>获取当前类的所在工程路径; 如果不加“/” 获取当前类的加载目录</li>
</ul>
</li>
<li>new File(“”).getCanonicalPath()<ul>
<li>获取项目路径</li>
</ul>
</li>
<li>this.getClass().getClassLoader().getResource(“”)</li>
<li>System.getProperty(“user.dir”)</li>
<li>System.getProperty(“java.class.path”)<ul>
<li>获取所有的类路径 包括jar包的路径</li>
</ul>
</li>
</ul>
<h1 id="实战30：JDK压缩与解压工具类"><a href="#实战30：JDK压缩与解压工具类" class="headerlink" title="实战30：JDK压缩与解压工具类"></a>实战30：JDK压缩与解压工具类</h1><p>在实际的应用场景中，特别是对外传输数据时，将原始数据压缩之后丢出去，可以说是非常常见的一个case了，平常倒是没有直接使用JDK原生的压缩工具类，使用Protosutff和Kryo的机会较多,正好在实际的工作场景中遇到了，现在简单的看下使用姿势</p>
<h2 id="1-压缩与解压工具类"><a href="#1-压缩与解压工具类" class="headerlink" title="1.压缩与解压工具类"></a>1.压缩与解压工具类</h2><h3 id="1-1-基本实现"><a href="#1-1-基本实现" class="headerlink" title="1.1. 基本实现"></a>1.1. 基本实现</h3><p>主要借助的就是Deflater, Inflater两个工具类，其使用姿势如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public static String uncompress(byte[] input) throws IOException &#123; </span><br><span class="line">    Inflater inflater = new Inflater(); </span><br><span class="line">    inflater.setInput(input); </span><br><span class="line">    ByteArrayOutputStream baos = new ByteArrayOutputStream(input.length); </span><br><span class="line">    try &#123; </span><br><span class="line">        byte[] buff = new byte[1024]; </span><br><span class="line">        while (!inflater.finished()) &#123; </span><br><span class="line">            int count = inflater.inflate(buff); </span><br><span class="line">            baos.write(buff, 0, count); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; catch (Exception e) &#123; </span><br><span class="line">        e.printStackTrace(); </span><br><span class="line">    &#125; finally &#123; </span><br><span class="line">        baos.close(); </span><br><span class="line">    &#125; </span><br><span class="line">    inflater.end(); </span><br><span class="line">    byte[] output = baos.toByteArray(); </span><br><span class="line">    return new String(output, &quot;UTF-8&quot;); </span><br><span class="line">&#125; </span><br><span class="line">public static byte[] compress(byte[] data) throws IOException &#123; </span><br><span class="line">    byte[] output; </span><br><span class="line">    Deflater compress = new Deflater(); </span><br><span class="line">    compress.reset(); </span><br><span class="line">    compress.setInput(data); </span><br><span class="line">    compress.finish(); </span><br><span class="line">    ByteArrayOutputStream bos = new ByteArrayOutputStream(data.length); </span><br><span class="line">    try &#123; </span><br><span class="line">        byte[] buf = new byte[1024]; </span><br><span class="line">        while (!compress.finished()) &#123; </span><br><span class="line">            int i = compress.deflate(buf); </span><br><span class="line">            bos.write(buf, 0, i); </span><br><span class="line">        &#125; </span><br><span class="line">        output = bos.toByteArray(); </span><br><span class="line">    &#125; catch (Exception e) &#123; </span><br><span class="line">        output = data; </span><br><span class="line">        e.printStackTrace(); </span><br><span class="line">    &#125; finally &#123; </span><br><span class="line">        bos.close(); </span><br><span class="line">    &#125; </span><br><span class="line">    compress.end(); </span><br><span class="line">    return output; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个简单的测试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws IOException &#123; </span><br><span class="line">    StringBuilder builder = new StringBuilder(); </span><br><span class="line">    for (int i = 0; i &lt; 200; i++) &#123; </span><br><span class="line">        builder.append(&#x27;a&#x27; + (new Random().nextInt() * 26)); </span><br><span class="line">    &#125; </span><br><span class="line">    String text = builder.toString(); </span><br><span class="line">    byte[] compres = compress(text.getBytes()); </span><br><span class="line">    System.out.println(compres.length + &quot; : &quot; + text.getBytes().length); </span><br><span class="line">    String res = uncompress(compres); </span><br><span class="line">    System.out.println(&quot;uncompress! \n&quot; + text + &quot;\n&quot; + res); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">1011 : 1974 </span><br><span class="line">uncompress!  </span><br><span class="line">1159641073884270587-148914555-876348695-140903655914152858511750740619-</span><br><span class="line">504526839109631208315104321891746743931-228808979-1303586499-19431155411964999751-</span><br><span class="line">1784318475-954798177-1812907183-831342707-3149322476028964551802022597-269963287-</span><br><span class="line">6384200011467670385844411707877038035412670417-1119826115558346219-</span><br><span class="line">959513147646693111435818855-32626587-</span><br><span class="line">18184494797054550038966016212145089137523302939171183465807867207-</span><br><span class="line">5294746515903446057333959811216956465-11772186456902770294071039871896527261-</span><br><span class="line">126190055310658640239029635411410052621945318513-1099749933-2044334159884087065-</span><br><span class="line">1705740759-1313321287-1408007761-</span><br><span class="line">12659778231544522691472523171153203782987609706919936632357801287155512488271333115291</span><br><span class="line">-1121944135941979389-179880545175884207196204559-</span><br><span class="line">2097788799145839653133892163716038492252042396151523357607329397509-</span><br><span class="line">2453452914618397691174247129-542507633-1893723573237001573-</span><br><span class="line">84175562119492726191070559557-875056377-1763237523-662399435-170798495-</span><br><span class="line">12405874171550890051-1938474621-701626601-1246867757-</span><br><span class="line">1138873077164155271023310391435811251050668025181338411-7641844471088518205-</span><br><span class="line">1570482881-1690731767-954924683-213656821149494003-544272515-</span><br><span class="line">9322840891981997411254437701-183054198720365002211448655569-</span><br><span class="line">54030518916444117051191350451-900732825-</span><br><span class="line">2072105047160877226512403288354302424851213478975-</span><br><span class="line">57604286986096457192173124564975571096304687-</span><br><span class="line">213425653510984804314132356831371957625714091709-327695077-182546427-</span><br><span class="line">372769058150182636433743131293942149315625331-1010625457741185365-81246881-565236593-</span><br><span class="line">1937214707-2090999425-1673181289-1110250756450022071917863643-</span><br><span class="line">127217577910228760391902441297-31318475-535669437-</span><br><span class="line">1151216791170962161121375401911260706331-1873591233-495048743-8876731551362670289-</span><br><span class="line">686442615-6752584831233249861-3467630691547253127-345092207-908370541-</span><br><span class="line">1788351797644350365-67770933-4703179231930520693138257968522450375-1171662023-</span><br><span class="line">5791753311816936409-1745781765-922801857281665531707439257928142703-</span><br><span class="line">367587763829971705455779401438501763-1398546079-606883161-924403277-1617582925-</span><br><span class="line">2005411841279115903 </span><br><span class="line">1159641073884270587-148914555-876348695-140903655914152858511750740619-</span><br><span class="line">504526839109631208315104321891746743931-228808979-1303586499-19431155411964999751-</span><br><span class="line">1784318475-954798177-1812907183-831342707-3149322476028964551802022597-269963287-</span><br><span class="line">6384200011467670385844411707877038035412670417-1119826115558346219-</span><br><span class="line">959513147646693111435818855-32626587-</span><br><span class="line">18184494797054550038966016212145089137523302939171183465807867207-</span><br><span class="line">5294746515903446057333959811216956465-11772186456902770294071039871896527261-</span><br><span class="line">126190055310658640239029635411410052621945318513-1099749933-2044334159884087065-</span><br><span class="line">1705740759-1313321287-1408007761-</span><br><span class="line">12659778231544522691472523171153203782987609706919936632357801287155512488271333115291</span><br><span class="line">-1121944135941979389-179880545175884207196204559-</span><br><span class="line">2097788799145839653133892163716038492252042396151523357607329397509-</span><br><span class="line">2453452914618397691174247129-542507633-1893723573237001573-</span><br><span class="line">84175562119492726191070559557-875056377-1763237523-662399435-170798495-</span><br><span class="line">12405874171550890051-1938474621-701626601-1246867757-</span><br><span class="line">1138873077164155271023310391435811251050668025181338411-7641844471088518205-</span><br><span class="line">1570482881-1690731767-954924683-213656821149494003-544272515-</span><br><span class="line">9322840891981997411254437701-183054198720365002211448655569-</span><br><span class="line">54030518916444117051191350451-900732825-</span><br><span class="line">2072105047160877226512403288354302424851213478975-</span><br><span class="line">57604286986096457192173124564975571096304687-</span><br><span class="line">213425653510984804314132356831371957625714091709-327695077-182546427-</span><br><span class="line">372769058150182636433743131293942149315625331-1010625457741185365-81246881-565236593-</span><br><span class="line">1937214707-2090999425-1673181289-1110250756450022071917863643-</span><br><span class="line">127217577910228760391902441297-31318475-535669437-</span><br><span class="line">1151216791170962161121375401911260706331-1873591233-495048743-8876731551362670289-</span><br><span class="line">686442615-6752584831233249861-3467630691547253127-345092207-908370541-</span><br><span class="line">1788351797644350365-67770933-4703179231930520693138257968522450375-1171662023-</span><br><span class="line">5791753311816936409-1745781765-922801857281665531707439257928142703-</span><br><span class="line">367587763829971705455779401438501763-1398546079-606883161-924403277-1617582925-</span><br><span class="line">2005411841279115903</span><br></pre></td></tr></table></figure>
<h3 id="1-2-注意事项"><a href="#1-2-注意事项" class="headerlink" title="1.2. 注意事项"></a>1.2. 注意事项</h3><p>上面这个运作的还挺好，但在接入使用时，总是提示 java.util.zip.DataFormatException:incorrect header check , 因为接受的是第三方传递过来的压缩数据，比较坑爹的是对方就写了个Deflater压缩，然后什么都没有了，那么这个是啥原因呢？</p>
<p>其实看下Deflater的构造方法，发现还可以传一个boolean值(nowrap), 官方说明是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line"></span><br><span class="line"> * Creates a new compressor using the specified compression level. </span><br><span class="line"> * If &#x27;nowrap&#x27; is true then the ZLIB header and checksum fields will </span><br><span class="line"> * not be used in order to support the compression format used in </span><br><span class="line"> * both GZIP and PKZIP. </span><br><span class="line"> * @param level the compression level (0-9) </span><br><span class="line"> * @param nowrap if true then use GZIP compatible compression </span><br><span class="line">   */ </span><br><span class="line">   public Deflater(int level, boolean nowrap) &#123; </span><br><span class="line">   this.level = level; </span><br><span class="line">   this.strategy = DEFAULT_STRATEGY; </span><br><span class="line">   this.zsRef = new ZStreamRef(init(level, DEFAULT_STRATEGY, nowrap)); </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>简单来说，就是压缩时，如果nowrap为true，那么解压时也要为true；否则对不上时，就会抛异常</p>
<p>接下来简单对比下两种不同传参的情况，首先更新下工具类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public static String uncompress(byte[] input, boolean nowrap) throws IOException &#123; </span><br><span class="line">    Inflater inflater = new Inflater(nowrap); </span><br><span class="line">    inflater.setInput(input); </span><br><span class="line">    ByteArrayOutputStream baos = new ByteArrayOutputStream(input.length); </span><br><span class="line">    try &#123; </span><br><span class="line">        byte[] buff = new byte[1024]; </span><br><span class="line">        while (!inflater.finished()) &#123; </span><br><span class="line">            int count = inflater.inflate(buff); </span><br><span class="line">            baos.write(buff, 0, count); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; catch (Exception e) &#123; </span><br><span class="line">        e.printStackTrace(); </span><br><span class="line">    &#125; finally &#123; </span><br><span class="line">        baos.close(); </span><br><span class="line">    &#125; </span><br><span class="line">    inflater.end(); </span><br><span class="line">    byte[] output = baos.toByteArray(); </span><br><span class="line">    return new String(output); </span><br><span class="line">&#125; </span><br><span class="line">public static byte[] compress(byte[] data, boolean nowrap) throws IOException &#123; </span><br><span class="line">    byte[] output; </span><br><span class="line">    Deflater compress = new Deflater(Deflater.DEFAULT_COMPRESSION, nowrap); </span><br><span class="line">    compress.reset(); </span><br><span class="line">    compress.setInput(data); </span><br><span class="line">    compress.finish(); </span><br><span class="line">    ByteArrayOutputStream bos = new ByteArrayOutputStream(data.length); </span><br><span class="line">    try &#123; </span><br><span class="line">        byte[] buf = new byte[1024]; </span><br><span class="line">        while (!compress.finished()) &#123; </span><br><span class="line">            int i = compress.deflate(buf); </span><br><span class="line">            bos.write(buf, 0, i); </span><br><span class="line">        &#125; </span><br><span class="line">        output = bos.toByteArray(); </span><br><span class="line">    &#125; catch (Exception e) &#123; </span><br><span class="line">        output = data; </span><br><span class="line">        e.printStackTrace(); </span><br><span class="line">    &#125; finally &#123; </span><br><span class="line">        bos.close(); </span><br><span class="line">    &#125; </span><br><span class="line">    compress.end(); </span><br><span class="line">    return output; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws IOException &#123; </span><br><span class="line">    StringBuilder builder = new StringBuilder(); </span><br><span class="line">    for (int i = 0; i &lt; 1000; i++) &#123; </span><br><span class="line">        builder.append(&#x27;a&#x27; + (new Random().nextInt() * 26)); </span><br><span class="line">    &#125; </span><br><span class="line">    String text = builder.toString(); </span><br><span class="line">    byte[] compres = compress(text.getBytes(), true); </span><br><span class="line">    System.out.println(compres.length + &quot; : &quot; + text.getBytes().length); </span><br><span class="line">    String res = uncompress(compres, true); </span><br><span class="line">    System.out.println(res.equals(text)); </span><br><span class="line">    byte[] compres2 = compress(text.getBytes(), false); </span><br><span class="line">    System.out.println(compres2.length + &quot; : &quot; + text.getBytes().length); </span><br><span class="line">    String res2 = uncompress(compres2, false); </span><br><span class="line">    System.out.println(res2.equals(text)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下，从大小来看，前者小那么一点点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">5086 : 9985 </span><br><span class="line">true </span><br><span class="line">5092 : 9985 </span><br><span class="line">true</span><br></pre></td></tr></table></figure>
<h2 id="2-小结-11"><a href="#2-小结-11" class="headerlink" title="2.小结"></a>2.小结</h2><p>一般来说，jdk自带的压缩与解压，除了方便之外，可能优势并不是那么的大，这里盗一张网上的对比表格</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">优点</th>
<th style="text-align:center">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">kryo</td>
<td style="text-align:center">速度快，序列化后体积小</td>
<td style="text-align:center">跨语言支持较复杂</td>
</tr>
<tr>
<td style="text-align:center">hessian</td>
<td style="text-align:center">默认支持跨语言</td>
<td style="text-align:center">较慢</td>
</tr>
<tr>
<td style="text-align:center">protostuff</td>
<td style="text-align:center">速度快，基于protobuf</td>
<td style="text-align:center">需静态编译</td>
</tr>
<tr>
<td style="text-align:center">Protostuff-Runtime</td>
<td style="text-align:center">无需静态编译，但序列化前需预先传入schema</td>
<td style="text-align:center">不支持无默认构造函数的类，反序列化时需用户自己初始化序列化后的对象，其只负责将该对象进行赋值</td>
</tr>
<tr>
<td style="text-align:center">jdk</td>
<td style="text-align:center">使用方便，可序列化所有类</td>
<td style="text-align:center">速度慢，占空间</td>
</tr>
</tbody>
</table>
</div>
<p>其次，在使用java的压缩与解压时，需要注意下，nowrap这个参数，需要保持一致，否则会报错</p>
<h1 id="实战31：深拷贝浅拷贝及对象拷贝的两种方式"><a href="#实战31：深拷贝浅拷贝及对象拷贝的两种方式" class="headerlink" title="实战31：深拷贝浅拷贝及对象拷贝的两种方式"></a>实战31：深拷贝浅拷贝及对象拷贝的两种方式</h1><h2 id="1-Java之Clone"><a href="#1-Java之Clone" class="headerlink" title="1.Java之Clone"></a>1.Java之Clone</h2><h3 id="1-1-背景"><a href="#1-1-背景" class="headerlink" title="1.1 背景"></a>1.1 背景</h3><p>对象拷贝，是一个非常基础的内容了，为什么会单独的把这个领出来讲解，主要是先前遇到了一个非常有意思的场景</p>
<p>有一个任务，需要解析类xml标记语言，然后生成document对象，之后将会有一系列针对document对象的操作</p>
<p>通过实际的测试，发现生成Document对象是比较耗时的一个操作，再加上这个任务场景中，需要解析的xml文档是固定的几个，那么一个可以优化的思路就是能不能缓存住创建后的Document对象，在实际使用的时候clone一份出来</p>
<h3 id="1-2-内容说明"><a href="#1-2-内容说明" class="headerlink" title="1.2 内容说明"></a>1.2 内容说明</h3><p>看到了上面的应用背景，自然而言的就会想到深拷贝了，本篇博文则主要内容如下</p>
<ul>
<li>介绍下两种拷贝方式的区别</li>
<li>深拷贝的辅助工具类</li>
<li>如何自定义实现对象拷贝</li>
</ul>
<h2 id="2-深拷贝和浅拷贝"><a href="#2-深拷贝和浅拷贝" class="headerlink" title="2.深拷贝和浅拷贝"></a>2.深拷贝和浅拷贝</h2><h3 id="2-1-定义说明"><a href="#2-1-定义说明" class="headerlink" title="2.1 定义说明"></a>2.1 定义说明</h3><p><strong>深拷贝</strong></p>
<p>相当于创建了一个新的对象，只是这个对象的所有内容，都和被拷贝的对象一模一样而已，即两者的修改是隔离的，相互之间没有影响</p>
<p><strong>浅拷贝</strong></p>
<p>也是创建了一个对象，但是这个对象的某些内容（比如A）依然是被拷贝对象的，即通过这两个对象中任意一个修改A，两个对象的A都会受到影响</p>
<p>看到上面两个简单的说明，那么问题来了</p>
<ul>
<li>浅拷贝中，是所有的内容公用呢？还是某些内容公用？</li>
<li>从隔离来将，都不希望出现浅拷贝这种方式了，太容易出错了，那么两种拷贝方式的应用场景是怎样的？</li>
</ul>
<h3 id="2-2-浅拷贝"><a href="#2-2-浅拷贝" class="headerlink" title="2.2 浅拷贝"></a>2.2 浅拷贝</h3><p>一般来说，浅拷贝方式需要实现 Cloneable接口，下面结合一个实例，来看下浅拷贝中哪些是独立的，哪些是公用的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">@Data </span><br><span class="line">public class ShallowClone implements Cloneable &#123; </span><br><span class="line">    private String name; </span><br><span class="line">    private int age; </span><br><span class="line">    private List&lt;String&gt; books; </span><br><span class="line">    public ShallowClone clone() &#123; </span><br><span class="line">        ShallowClone clone = null; </span><br><span class="line">        try &#123; </span><br><span class="line">            clone = (ShallowClone) super.clone(); </span><br><span class="line">        &#125; catch (CloneNotSupportedException e) &#123; </span><br><span class="line">            e.printStackTrace(); </span><br><span class="line">        &#125; </span><br><span class="line">        return clone;</span><br><span class="line">    &#125; </span><br><span class="line">    public static void main(String[] args) &#123; </span><br><span class="line">        ShallowClone shallowClone = new ShallowClone(); </span><br><span class="line">        shallowClone.setName(&quot;SourceName&quot;); </span><br><span class="line">        shallowClone.setAge(28); </span><br><span class="line">        List&lt;String&gt; list = new ArrayList&lt;&gt;(); </span><br><span class="line">        list.add(&quot;java&quot;); </span><br><span class="line">        list.add(&quot;c++&quot;); </span><br><span class="line">        shallowClone.setBooks(list); </span><br><span class="line">        ShallowClone cloneObj = shallowClone.clone(); </span><br><span class="line">        // 判断两个对象是否为同一个对象（即是否是新创建了一个实例） </span><br><span class="line">        System.out.println(shallowClone == cloneObj); </span><br><span class="line">        // 修改一个对象的内容是否会影响另一个对象 </span><br><span class="line">        shallowClone.setName(&quot;newName&quot;); </span><br><span class="line">        shallowClone.setAge(20); </span><br><span class="line">        shallowClone.getBooks().add(&quot;javascript&quot;); </span><br><span class="line">        System.out.println(&quot;source: &quot; + shallowClone.toString() + &quot;\nclone:&quot; + </span><br><span class="line">cloneObj.toString()); </span><br><span class="line">        shallowClone.setBooks(Arrays.asList(&quot;hello&quot;)); </span><br><span class="line">        System.out.println(&quot;source: &quot; + shallowClone.toString() + &quot;\nclone:&quot; + </span><br><span class="line">cloneObj.toString()); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">false </span><br><span class="line">source: ShallowClone(name=newName, age=20, books=[java, c++, javascript]) </span><br><span class="line">clone:ShallowClone(name=SourceName, age=28, books=[java, c++, javascript]) </span><br><span class="line">source: ShallowClone(name=newName, age=20, books=[hello]) </span><br><span class="line">clone:ShallowClone(name=SourceName, age=28, books=[java, c++, javascript])</span><br></pre></td></tr></table></figure>
<p>结果分析：</p>
<ul>
<li>拷贝后获取的是一个独立的对象，和原对象拥有不同的内存地址</li>
<li>基本元素类型，两者是隔离的（虽然上面只给出了int，String）<ul>
<li>基本元素类型包括:</li>
<li>int, Integer, long, Long, char, Charset, byte,Byte, boolean, Boolean, float,Float, double,Double, String</li>
</ul>
</li>
<li>非基本数据类型（如基本容器，其他对象等），只是拷贝了一份引用出去了，实际指向的依然是同一份</li>
</ul>
<p>其实，浅拷贝有个非常简单的理解方式：</p>
<p><strong>浅拷贝的整个过程就是，创建一个新的对象，然后新对象的每个值都是由原对象的值，通过 =进行赋值</strong></p>
<p>这个怎么理解呢？</p>
<p>上面的流程拆解就是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- Object clone = new Object(); </span><br><span class="line">- clone.a = source.a </span><br><span class="line">- clone.b = source.b </span><br><span class="line">- ...</span><br></pre></td></tr></table></figure>
<p>那么=赋值有什么特点呢？</p>
<p>基本数据类型是值赋值；非基本的就是引用赋值</p>
<h3 id="2-3-深拷贝"><a href="#2-3-深拷贝" class="headerlink" title="2.3 深拷贝"></a>2.3 深拷贝</h3><p>深拷贝，就是要创建一个全新的对象，新的对象内部所有的成员也都是全新的，只是初始化的值已经由被拷贝的对象确定了而已</p>
<p>那么上面的实例改成深拷贝应该是怎样的呢？</p>
<p>可以加上这么一个方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public ShallowClone deepClone() &#123; </span><br><span class="line">    ShallowClone clone = new ShallowClone(); </span><br><span class="line">    clone.name = this.name; </span><br><span class="line">    clone.age = this.age; </span><br><span class="line">    if (this.books != null) &#123; </span><br><span class="line">        clone.books = new ArrayList&lt;&gt;(this.books); </span><br><span class="line">    &#125; </span><br><span class="line">    return clone; </span><br><span class="line">&#125; </span><br><span class="line">// 简单改一下测试case </span><br><span class="line">public static void main(String[] args) &#123; </span><br><span class="line">    ShallowClone shallowClone = new ShallowClone(); </span><br><span class="line">    shallowClone.setName(&quot;SourceName&quot;); </span><br><span class="line">    shallowClone.setAge(new Integer(1280)); </span><br><span class="line">    List&lt;String&gt; list = new ArrayList&lt;&gt;(); </span><br><span class="line">    list.add(&quot;java&quot;); </span><br><span class="line">    list.add(&quot;c++&quot;); </span><br><span class="line">    shallowClone.setBooks(list); </span><br><span class="line">    ShallowClone cloneObj = shallowClone.deepClone(); </span><br><span class="line">    // 判断两个对象是否为同一个对象（即是否是新创建了一个实例） </span><br><span class="line">    System.out.println(shallowClone == cloneObj); </span><br><span class="line">    // 修改一个对象的内容是否会影响另一个对象 </span><br><span class="line">    shallowClone.setName(&quot;newName&quot;); </span><br><span class="line">    shallowClone.setAge(2000); </span><br><span class="line">    shallowClone.getBooks().add(&quot;javascript&quot;); </span><br><span class="line">    System.out.println(&quot;source: &quot; + shallowClone.toString() + &quot;\nclone:&quot; + </span><br><span class="line">cloneObj.toString()); </span><br><span class="line">    shallowClone.setBooks(Arrays.asList(&quot;hello&quot;)); </span><br><span class="line">    System.out.println(&quot;source: &quot; + shallowClone.toString() + &quot;\nclone:&quot; + </span><br><span class="line">cloneObj.toString()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">false </span><br><span class="line">source: ShallowClone(name=newName, age=2000, books=[java, c++, javascript]) </span><br><span class="line">clone:ShallowClone(name=SourceName, age=1280, books=[java, c++]) </span><br><span class="line">source: ShallowClone(name=newName, age=2000, books=[hello]) </span><br><span class="line">clone:ShallowClone(name=SourceName, age=1280, books=[java, c++])</span><br></pre></td></tr></table></figure>
<p>结果分析：</p>
<ul>
<li>深拷贝独立的对象</li>
<li>拷贝后对象的内容，与原对象的内容完全没关系，都是独立的</li>
</ul>
<p>简单来说，深拷贝是需要自己来实现的，对于基本类型可以直接赋值，而对于对象、容器、数组来讲，需要创建一个新的出来，然后重新赋值</p>
<h3 id="2-4-应用场景区分"><a href="#2-4-应用场景区分" class="headerlink" title="2.4 应用场景区分"></a>2.4 应用场景区分</h3><p>深拷贝的用途我们很容易可以想见，某个复杂对象创建比较消耗资源的时候，就可以缓存一个蓝本，后续的操作都是针对深clone后的对象，这样就不会出现混乱的情况了</p>
<p>那么浅拷贝呢？感觉留着是一个坑，一个人修改了这个对象的值，结果发现对另一个人造成了影响，真不是坑爹么？</p>
<p>假设又这么一个通知对象长下面这样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private String notifyUser; </span><br><span class="line">// xxx </span><br><span class="line">private List&lt;String&gt; notifyRules;</span><br></pre></td></tr></table></figure>
<p>我们现在随机挑选了一千个人，同时发送通知消息，所以需要创建一千个上面的对象，这些对象中呢，除了notifyUser不同，其他的都一样</p>
<p>在发送之前，突然发现要临时新增一条通知信息，如果是浅拷贝的话，只用在任意一个通知对象的notifyRules中添加一调消息，那么这一千个对象的通知消息都会变成最新的了；而如果你是用深拷贝，那么苦逼的得遍历这一千个对象，每个都加一条消息了</p>
<h2 id="3-对象拷贝工具"><a href="#3-对象拷贝工具" class="headerlink" title="3.对象拷贝工具"></a>3.对象拷贝工具</h2><p>上面说到，浅拷贝，需要实现Clonebale接口，深拷贝一般需要自己来实现，那么我现在拿到一个对象A，它自己没有提供深拷贝接口，我们除了主动一条一条的帮它实现之外，有什么辅助工具可用么？</p>
<p>对象拷贝区别与clone，它可以支持两个不同对象之间实现内容拷贝</p>
<p><strong>Apache的两个版本：（反射机制）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.apache.commons.beanutils.PropertyUtils.copyProperties(Object dest, Object orig) </span><br><span class="line">org.apache.commons.beanutils.BeanUtils#cloneBean</span><br></pre></td></tr></table></figure>
<p><strong>Spring版本：（反射机制）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.beans.BeanUtils.copyProperties(Object source, Object target, Class </span><br><span class="line">editable, String[] ignoreProperties)</span><br></pre></td></tr></table></figure>
<p><strong>cglib版本：（使用动态代理，效率高）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.sf.cglib.beans.BeanCopier.copy(Object paramObject1, Object paramObject2, Converter paramConverter)</span><br></pre></td></tr></table></figure>
<p>从上面的几个有名的工具类来看，提供了两种使用者姿势，一个是反射，一个是动态代理，下面分别来看两种思路</p>
<h3 id="3-1-借助反射实现对象拷贝"><a href="#3-1-借助反射实现对象拷贝" class="headerlink" title="3.1 借助反射实现对象拷贝"></a>3.1 借助反射实现对象拷贝</h3><p>通过反射的方式实现对象拷贝的思路还是比较清晰的，先通过反射获取对象的所有属性，然后修改可访问级别，然后赋值；再获取继承的父类的属性，同样利用反射进行赋值</p>
<p>上面的几个开源工具，内部实现封装得比较好，所以直接贴源码可能不太容易一眼就能看出反射方式的原理，所以简单的实现了一个, 仅提供思路</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public static void copy(Object source, Object dest) throws Exception &#123; </span><br><span class="line">    Class destClz = dest.getClass(); </span><br><span class="line">    // 获取目标的所有成员 </span><br><span class="line">    Field[] destFields = destClz.getDeclaredFields(); </span><br><span class="line">    Object value; </span><br><span class="line">    for (Field field : destFields) &#123; // 遍历所有的成员，并赋值 </span><br><span class="line">        // 获取value值 </span><br><span class="line">        value = getVal(field.getName(), source); </span><br><span class="line">        field.setAccessible(true); </span><br><span class="line">        field.set(dest, value); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">private static Object getVal(String name, Object obj) throws Exception &#123; </span><br><span class="line">    try &#123; </span><br><span class="line">        // 优先获取obj中同名的成员变量 </span><br><span class="line">        Field field = obj.getClass().getDeclaredField(name); </span><br><span class="line">        field.setAccessible(true); </span><br><span class="line">        return field.get(obj); </span><br><span class="line">    &#125; catch (NoSuchFieldException e) &#123; </span><br><span class="line">        // 表示没有同名的变量 </span><br><span class="line">    &#125; </span><br><span class="line">    // 获取对应的 getXxx() 或者 isXxx() 方法 </span><br><span class="line">    name = name.substring(0, 1).toUpperCase() + name.substring(1); </span><br><span class="line">    String methodName = &quot;get&quot; + name; </span><br><span class="line">    String methodName2 = &quot;is&quot; + name; </span><br><span class="line">    Method[] methods = obj.getClass().getMethods(); </span><br><span class="line">    for (Method method : methods) &#123; </span><br><span class="line">        // 只获取无参的方法 </span><br><span class="line">        if (method.getParameterCount() &gt; 0) &#123; </span><br><span class="line">            continue;</span><br><span class="line">        &#125; </span><br><span class="line">        if (method.getName().equals(methodName) </span><br><span class="line">                || method.getName().equals(methodName2)) &#123; </span><br><span class="line">            return method.invoke(obj); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    return null; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的实现步骤还是非常清晰的，首先是找同名的属性，然后利用反射获取对应的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Field field = obj.getClass().getDeclaredField(name); </span><br><span class="line">field.setAccessible(true); </span><br><span class="line">return field.get(obj);</span><br></pre></td></tr></table></figure>
<p>如果找不到，则找getXXX, isXXX来获取</p>
<h3 id="3-2-代理的方式实现对象拷贝"><a href="#3-2-代理的方式实现对象拷贝" class="headerlink" title="3.2 代理的方式实现对象拷贝"></a>3.2 代理的方式实现对象拷贝</h3><p>Cglib的BeanCopier就是通过代理的方式实现拷贝，性能优于反射的方式，特别是在大量的数据拷贝时，比较明显</p>
<p>代理，我们知道可以区分为静态代理和动态代理，简单来讲就是你要操作对象A，但是你不直接去操作A，而是找一个中转porxyA, 让它来帮你操作对象A</p>
<p>那么这种技术是如何使用在对象拷贝的呢？</p>
<p>我们知道，效率最高的对象拷贝方式就是Getter/Setter方法了，前面说的代理的含义指我们不直接操作，而是找个中间商来赚差价，那么方案就出来了</p>
<p>将原SourceA拷贝到目标DestB</p>
<ul>
<li>创建一个代理 copyProxy</li>
<li>在代理中，依次调用 SourceA的get方法获取属性值，然后调用DestB的set方法进行赋值</li>
</ul>
<p>实际上BeanCopier的思路大致如上，具体的方案当然就不太一样了, 简单看了一下实现逻辑，挺有意思的一块，先留个坑，后面单独开个博文补上</p>
<p><strong>说明</strong></p>
<p>从实现原理和通过简单的测试，发现BeanCopier是扫描原对象的getXXX方法，然后赋值给同名的setXXX 方法，也就是说，如果这个对象中某个属性没有get/set方法，那么就无法赋值成功了</p>
<h2 id="3-小结-4"><a href="#3-小结-4" class="headerlink" title="3.小结"></a>3.小结</h2><h3 id="3-1-深拷贝和浅拷贝"><a href="#3-1-深拷贝和浅拷贝" class="headerlink" title="3.1 深拷贝和浅拷贝"></a>3.1 深拷贝和浅拷贝</h3><p><strong>深拷贝</strong></p>
<blockquote>
<p>相当于创建了一个新的对象，只是这个对象的所有内容，都和被拷贝的对象一模一样而已，即两者的修改是隔离的，相互之间没有影响</p>
</blockquote>
<ul>
<li>完全独立</li>
</ul>
<p><strong>浅拷贝</strong></p>
<blockquote>
<p>也是创建了一个对象，但是这个对象的某些内容（比如A）依然是被拷贝对象的，即通过这两个对象中任意一个修改A，两个对象的A都会受到影响</p>
</blockquote>
<p>等同与新创建一个对象，然后使用=，将原对象的属性赋值给新对象的属性</p>
<p>需要实现Cloneable接口</p>
<h3 id="3-2-对象拷贝的两种方法"><a href="#3-2-对象拷贝的两种方法" class="headerlink" title="3.2 对象拷贝的两种方法"></a>3.2 对象拷贝的两种方法</h3><p><strong>通过反射方式实现对象拷贝</strong></p>
<p>主要原理就是通过反射获取所有的属性，然后反射更改属性的内容</p>
<p><strong>通过代理实现对象拷贝</strong></p>
<p>将原SourceA拷贝到目标DestB</p>
<p>创建一个代理 copyProxy 在代理中，依次调用 SourceA的get方法获取属性值，然后调用DestB的set方法进行赋值</p>
<h1 id="实战32：Java可以如何实现文件变动的监听"><a href="#实战32：Java可以如何实现文件变动的监听" class="headerlink" title="实战32：Java可以如何实现文件变动的监听"></a>实战32：Java可以如何实现文件变动的监听</h1><p>应用中使用logback作为日志输出组件的话，大部分会去配置 logback.xml 这个文件，而且生产环境下，直接去修改logback.xml文件中的日志级别，不用重启应用就可以生效</p>
<p>那么，这个功能是怎么实现的呢？</p>
<h2 id="1-问题描述及分析"><a href="#1-问题描述及分析" class="headerlink" title="1.问题描述及分析"></a>1.问题描述及分析</h2><p>针对上面的这个问题，首先抛出一个实际的case，在我的个人网站 * 神奇工具箱 - 小工具集合中，所有的小工具都是通过配置文件来动态新增和隐藏的，因为只有一台服务器，所以配置文件就简化的直接放在了服务器的某个目录下</p>
<p>现在的问题时，我需要在这个文件的内容发生变动时，应用可以感知这种变动，并重新加载文件内容，更新应用内部缓存</p>
<p>一个最容易想到的方法，就是轮询，判断文件是否发生修改，如果修改了，则重新加载，并刷新内存，所以主要需要关心的问题如下：</p>
<ul>
<li>如何轮询？</li>
<li>如何判断文件是否修改？</li>
<li>配置异常，会不会导致服务不可用？（即容错，这个与本次主题关联不大，但又比较重要…）</li>
</ul>
<h2 id="2-设计与实现"><a href="#2-设计与实现" class="headerlink" title="2.设计与实现"></a>2.设计与实现</h2><p>问题抽象出来之后，对应的解决方案就比较清晰了</p>
<ul>
<li>如何轮询 ？ —》 定时器 Timer, ScheduledExecutorService 都可以实现</li>
<li>如何判断文件修改？ —》根据 java.io.File#lastModified 获取文件的上次修改时间，比对即可</li>
</ul>
<p>那么一个很简单的实现就比较容易了:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class FileUpTest &#123; </span><br><span class="line">    private long lastTime; </span><br><span class="line">    @Test </span><br><span class="line">    public void testFileUpdate() &#123; </span><br><span class="line">        File file = new File(&quot;/tmp/alarmConfig&quot;); </span><br><span class="line">        // 首先文件的最近一次修改时间戳 </span><br><span class="line">        lastTime = file.lastModified(); </span><br><span class="line">        // 定时任务，每秒来判断一下文件是否发生变动，即判断lastModified是否改变 </span><br><span class="line">        ScheduledExecutorService scheduledExecutorService = </span><br><span class="line">Executors.newScheduledThreadPool(1); </span><br><span class="line">        scheduledExecutorService.scheduleAtFixedRate(new Runnable() &#123; </span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123; </span><br><span class="line">                if (file.lastModified() &gt; lastTime) &#123; </span><br><span class="line">                    System.out.println(&quot;file update! time : &quot; + file.lastModified()); </span><br><span class="line">                    lastTime = file.lastModified(); </span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;,0, 1, TimeUnit.SECONDS); </span><br><span class="line">        try &#123; </span><br><span class="line">            Thread.sleep(1000 * 60); </span><br><span class="line">        &#125; catch (InterruptedException e) &#123; </span><br><span class="line">            e.printStackTrace(); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个属于一个非常简单，非常基础的实现了，基本上也可以满足我们的需求，那么这个实现有什么问题呢？</p>
<p><strong>定时任务的执行中，如果出现了异常会怎样？</strong></p>
<p>对上面的代码稍作修改</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class FileUpTest &#123; </span><br><span class="line">    private long lastTime; </span><br><span class="line">    private void ttt() &#123; </span><br><span class="line">        throw new NullPointerException(); </span><br><span class="line">    &#125; </span><br><span class="line">    @Test </span><br><span class="line">    public void testFileUpdate() &#123; </span><br><span class="line">        File file = new File(&quot;/tmp/alarmConfig&quot;); </span><br><span class="line">        lastTime = file.lastModified(); </span><br><span class="line">        ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(1); </span><br><span class="line">        scheduledExecutorService.scheduleAtFixedRate(new Runnable() &#123; </span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123; </span><br><span class="line">                if (file.lastModified() &gt; lastTime) &#123; </span><br><span class="line">                    System.out.println(&quot;file update! time : &quot; + file.lastModified()); </span><br><span class="line">                    lastTime = file.lastModified(); </span><br><span class="line">                    ttt(); </span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;, 0, 1, TimeUnit.SECONDS); </span><br><span class="line">        try &#123; </span><br><span class="line">            Thread.sleep(1000 * 60 * 10); </span><br><span class="line">        &#125; catch (InterruptedException e) &#123; </span><br><span class="line">            e.printStackTrace(); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际测试，发现只有首次修改的时候，触发了上面的代码，但是再次修改则没有效果了，即当抛出异常之后，定时任务将不再继续执行了，这个问题的主要原因是因为ScheduledExecutorService 的原因了</p>
<p>直接查看ScheduledExecutorService的源码注释说明</p>
<blockquote>
<p>If any execution of the task encounters an exception, subsequent executions are suppressed.Otherwise, the task will only terminate via cancellation or termination of the executor. 即如果定时任务执行过程中遇到发生异常，则后面的任务将不再执行。</p>
</blockquote>
<p><strong>所以，使用这种姿势的时候，得确保自己的任务不会抛出异常，否则后面就没法玩了</strong></p>
<p>对应的解决方法也比较简单，整个catch一下就好</p>
<h2 id="3-进阶版"><a href="#3-进阶版" class="headerlink" title="3.进阶版"></a>3.进阶版</h2><p>前面是一个基础的实现版本了，当然在java圈，基本上很多常见的需求，都是可以找到对应的开源工具来使用的，当然这个也不例外，而且应该还是大家比较属性的apache系列</p>
<h3 id="3-1-apache版"><a href="#3-1-apache版" class="headerlink" title="3.1 apache版"></a>3.1 apache版</h3><p>首先maven依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt; </span><br><span class="line">    &lt;groupId&gt;commons-io&lt;/groupId&gt; </span><br><span class="line">    &lt;artifactId&gt;commons-io&lt;/artifactId&gt; </span><br><span class="line">    &lt;version&gt;2.6&lt;/version&gt; </span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>主要是借助这个工具中的 FileAlterationObserver , FileAlterationListener ,FileAlterationMonitor 三个类来实现相关的需求场景了，当然使用也算是很简单了，以至于都不太清楚可以再怎么去说明了，直接看下面从我的一个开源项目quick-alarm中拷贝出来的代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class PropertiesConfListenerHelper &#123; </span><br><span class="line">    public static boolean registerConfChangeListener(File file, Function&lt;File, </span><br><span class="line">Map&lt;String, AlarmConfig&gt;&gt; func) &#123; </span><br><span class="line">        try &#123; </span><br><span class="line">            // 轮询间隔 5 秒 </span><br><span class="line">            long interval = TimeUnit.SECONDS.toMillis(5); </span><br><span class="line">            // 因为监听是以目录为单位进行的，所以这里直接获取文件的根目录 </span><br><span class="line">            File dir = file.getParentFile(); </span><br><span class="line">            // 创建一个文件观察器用于过滤 </span><br><span class="line">            FileAlterationObserver observer = new FileAlterationObserver(dir, </span><br><span class="line">                    FileFilterUtils.and(FileFilterUtils.fileFileFilter(), </span><br><span class="line">                            FileFilterUtils.nameFileFilter(file.getName()))); </span><br><span class="line">            //设置文件变化监听器 </span><br><span class="line">            observer.addListener(new MyFileListener(func)); </span><br><span class="line">            FileAlterationMonitor monitor = new FileAlterationMonitor(interval, </span><br><span class="line">observer); </span><br><span class="line">            monitor.start(); </span><br><span class="line">            return true; </span><br><span class="line">        &#125; catch (Exception e) &#123; </span><br><span class="line">            log.error(&quot;register properties change listener error! e:&#123;&#125;&quot;, e); </span><br><span class="line">            return false; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    static final class MyFileListener extends FileAlterationListenerAdaptor &#123; </span><br><span class="line">        private Function&lt;File, Map&lt;String, AlarmConfig&gt;&gt; func; </span><br><span class="line">        public MyFileListener(Function&lt;File, Map&lt;String, AlarmConfig&gt;&gt; func) &#123; </span><br><span class="line">            this.func = func; </span><br><span class="line">        &#125; </span><br><span class="line">        @Override </span><br><span class="line">        public void onFileChange(File file) &#123; </span><br><span class="line">            Map&lt;String, AlarmConfig&gt; ans = func.apply(file); // 如果加载失败，打印一条日志</span><br><span class="line">            log.warn(&quot;PropertiesConfig changed! reload ans: &#123;&#125;&quot;, ans); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>针对上面的实现，简单说明几点：</p>
<ul>
<li>这个文件监听，是以目录为根源，然后可以设置过滤器，来实现对应文件变动的监听</li>
<li>如上面 registerConfChangeListener方法，传入的file是具体的配置文件，因此构建参数的时候，捞出了目录，捞出了文件名作为过滤</li>
<li>第二参数是jdk8语法，其中为具体的读取配置文件内容，并映射为对应的实体对象</li>
</ul>
<p>一个问题，如果 func方法执行时，也抛出了异常，会怎样？</p>
<p>实际测试表现结果和上面一样，抛出异常之后，依然跪，所以依然得注意，不要跑异常</p>
<p>那么简单来看一下上面的实现逻辑，直接扣出核心模块</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">    while(true) &#123; </span><br><span class="line">        if(this.running) &#123; </span><br><span class="line">            Iterator var1 = this.observers.iterator(); </span><br><span class="line">            while(var1.hasNext()) &#123; </span><br><span class="line">                FileAlterationObserver observer = (FileAlterationObserver)var1.next(); </span><br><span class="line">                observer.checkAndNotify();</span><br><span class="line">            &#125; </span><br><span class="line">            if(this.running) &#123; </span><br><span class="line">                try &#123; </span><br><span class="line">                    Thread.sleep(this.interval); </span><br><span class="line">                &#125; catch (InterruptedException var3) &#123; </span><br><span class="line">                    ;</span><br><span class="line">                &#125; </span><br><span class="line">                continue; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        return; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面基本上一目了然，整个的实现逻辑了，和我们的第一种定时任务的方法不太一样，这儿直接使用线程，死循环，内部采用sleep的方式来来暂停，因此出现异常时，相当于直接抛出去了，这个线程就跪了</p>
<h3 id="3-2-JDK版本"><a href="#3-2-JDK版本" class="headerlink" title="3.2 JDK版本"></a>3.2 JDK版本</h3><p>jdk1.7，提供了一个 WatchService ，也可以用来实现文件变动的监听，之前也没有接触过，看到说明，然后搜了一下使用相关，发现也挺简单的，同样给出一个简单的示例demo</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@Test </span><br><span class="line">public void testFileUpWather() throws IOException &#123; </span><br><span class="line">    // 说明，这里的监听也必须是目录 </span><br><span class="line">    Path path = Paths.get(&quot;/tmp&quot;); </span><br><span class="line">    WatchService watcher = FileSystems.getDefault().newWatchService(); </span><br><span class="line">    path.register(watcher, ENTRY_MODIFY); </span><br><span class="line">    new Thread(() -&gt; &#123; </span><br><span class="line">        try &#123; </span><br><span class="line">            while (true) &#123; </span><br><span class="line">                WatchKey key = watcher.take(); </span><br><span class="line">                for (WatchEvent&lt;?&gt; event : key.pollEvents()) &#123; </span><br><span class="line">                    if (event.kind() == OVERFLOW) &#123; </span><br><span class="line">                        //事件可能lost or discarded  </span><br><span class="line">                        continue; </span><br><span class="line">                    &#125;</span><br><span class="line">                    Path fileName = (Path) event.context(); </span><br><span class="line">                    System.out.println(&quot;文件更新: &quot; + fileName); </span><br><span class="line">                &#125; </span><br><span class="line">                if (!key.reset()) &#123; // 重设WatchKey </span><br><span class="line">                    break; </span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; catch (Exception e) &#123; </span><br><span class="line">            e.printStackTrace(); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;).start(); </span><br><span class="line">    try &#123; </span><br><span class="line">        Thread.sleep(1000 * 60 * 10); </span><br><span class="line">    &#125; catch (InterruptedException e) &#123; </span><br><span class="line">        e.printStackTrace(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>使用Java来实现配置文件变动的监听，主要涉及到的就是两个点</p>
<ul>
<li>如何轮询： 定时器（Timer, ScheduledExecutorService）, 线程死循环+sleep</li>
<li>文件修改： File#lastModified</li>
</ul>
<p>整体来说，这个实现还是比较简单的，无论是自定义实现，还是依赖 commos-io来做，都没太大的技术成本，但是需要注意的一点是：</p>
<ul>
<li>千万不要在定时任务 or 文件变动的回调方法中抛出异常！！！</li>
</ul>
<p>为了避免上面这个情况，一个可以做的实现是借助EventBus的异步消息通知来实现，当文件变动之后，发送一个消息即可，然后在具体的重新加载文件内容的方法上，添加一个 @Subscribe注解即可，这样既实现了解耦，也避免了异常导致的服务异常 （如果对这个实现有兴趣的可以评论说明）</p>
<h1 id="实战33：实用的Map初始化工具类"><a href="#实战33：实用的Map初始化工具类" class="headerlink" title="实战33：实用的Map初始化工具类"></a>实战33：实用的Map初始化工具类</h1><p>虽说java作为编译语言，但是它本身也提供了很多运行时能力，今天介绍一个非常基础的知识点，可变参数传递</p>
<p>在日常的开发过程中，创建Map对象还是比较常见的，现在我希望写一个工具类，可以非常简单创建并初始化Map对象</p>
<p>因此我们可以实现一个MapUtil工具类，来支持这个场景</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;K, V&gt; Map&lt;K, V&gt; newMap(K k, V v, Object... kv) &#123; </span><br><span class="line">        Map&lt;K, V&gt; ans = new HashMap&lt;&gt;(); </span><br><span class="line">        ans.put(k, v); </span><br><span class="line">        for (int i = 0; i &lt; kv.length; i += 2) &#123; </span><br><span class="line">            ans.put((K) kv[i], (V) kv[1]); </span><br><span class="line">        &#125; </span><br><span class="line">        return ans; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意一下上面的实现，kv这个参数就是我们要说的可变参数，在方法内部，kv可以看成是一个数组对象（而且是安全的对象，当不传递时，它的取值也不是null）</p>
<p>在使用可变参数时，下面是一些需要注意的点</p>
<p><strong>可变参数注意与数组参数的冲突</strong></p>
<p>注意下面的两个方法，不能同时出现，直接出现编译错误</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;K, V&gt; Map&lt;K, V&gt; newMap(K k, V v, Object... kv) </span><br><span class="line">public static &lt;K, V&gt; Map&lt;K, V&gt; newMap(K k, V v, Object[] kv)</span><br></pre></td></tr></table></figure>
<p><strong>重载的选择</strong></p>
<p>如果只有一个可变参数的方法， newMap(“key”, “value”)不会报错，会直接访问下面这个方法，kv参数为空数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;K, V&gt; Map&lt;K, V&gt; newMap(K k, V v, Object... kv)</span><br></pre></td></tr></table></figure>
<p>当出现重载时，即如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;K, V&gt; Map&lt;K, V&gt; newMap(K k, V v, Object... kv) </span><br><span class="line">public static &lt;K, V&gt; Map&lt;K, V&gt; newMap(K k, V v)</span><br></pre></td></tr></table></figure>
<p>上面两个方法的调用，如果传参只有两个时，会调用哪个？</p>
<ul>
<li>newMap(“key”, “value”) 调用的下面的方法</li>
<li>`newMap(“key”, “value”, “k”, “v”) 调用的上面的方法</li>
</ul>
<p><strong>可变参数传数组会怎样</strong></p>
<p>虽说我们在使用的时候，将可变参数当做数组来使用，但是传递时，若传数组，是否可行呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;K, V&gt; Map&lt;K, V&gt; newMap(K k, V v, Object... kv) &#123; </span><br><span class="line">    Map&lt;K, V&gt; ans = new HashMap&lt;&gt;(); </span><br><span class="line">    ans.put(k, v); </span><br><span class="line">    for (int i = 0; i &lt; kv.length; i += 2) &#123; </span><br><span class="line">        ans.put((K) kv[i], (V) kv[1]); </span><br><span class="line">    &#125; </span><br><span class="line">    return ans; </span><br><span class="line">&#125; </span><br><span class="line">@Test </span><br><span class="line">public void tt() &#123; </span><br><span class="line">    Map map = newMap(&quot;key&quot;, &quot;value&quot;, new Object[]&#123;&quot;1&quot;, &quot;2&quot;&#125;); </span><br><span class="line">    System.out.println(map); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际输出如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;1=2, key=value&#125;</span><br></pre></td></tr></table></figure>
<p>从实际测试来看，传数组并没有问题</p>
<h1 id="实战34：通用的根据路径获取文件资源的工具类"><a href="#实战34：通用的根据路径获取文件资源的工具类" class="headerlink" title="实战34：通用的根据路径获取文件资源的工具类"></a>实战34：通用的根据路径获取文件资源的工具类</h1><p>通常我们最多的场景是从本地资源中读取文件，这个时候我们经常需要注意的是相对路径、绝对路径问题；</p>
<p>除了从本地获取文件之外，从网络中获取文件资源（如图片）也属于相对常见的场景，接下来我们封装一个工具类，可以支持以上各种类型的数据读取</p>
<h2 id="1-工具实现类"><a href="#1-工具实现类" class="headerlink" title="1.工具实现类"></a>1.工具实现类</h2><p>首先定义一个公共方法如下，内部支持四种方式的数据获取</p>
<ul>
<li>相对路径</li>
<li>绝对路径</li>
<li>用户根目录</li>
<li>网络</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static InputStream getStreamByFileName(String fileName) throws IOException &#123; </span><br><span class="line">    if (fileName == null) &#123; </span><br><span class="line">        throw new IllegalArgumentException(&quot;fileName should not be null!&quot;); </span><br><span class="line">    &#125; </span><br><span class="line">    if (fileName.startsWith(&quot;http&quot;)) &#123; </span><br><span class="line">        // 网络地址 </span><br><span class="line">        return new URL(fileName).openConnection().getInputStream(); </span><br><span class="line">    &#125; else if (BasicFileUtil.isAbsFile(fileName)) &#123; </span><br><span class="line">        // 绝对路径 </span><br><span class="line">        Path path = Paths.get(fileName);</span><br><span class="line">        return Files.newInputStream(path); </span><br><span class="line">    &#125; else if (fileName.startsWith(&quot;~&quot;)) &#123; </span><br><span class="line">        // 用户目录下的绝对路径文件 </span><br><span class="line">        fileName = BasicFileUtil.parseHomeDir2AbsDir(fileName);</span><br><span class="line">        return Files.newInputStream(Paths.get(fileName)); </span><br><span class="line">    &#125; else &#123; // 相对路径 </span><br><span class="line">        return FileReadUtil.class.getClassLoader().getResourceAsStream(fileName); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意上面的实现，绝对路径与相对路径比较好理解，用户目录，这个处理又是怎样的呢？</p>
<p>关键点在于，用户目录转绝对路径</p>
<ul>
<li>借助 System.getProperties系统属性来处理</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line"> * 将用户目录下地址~/xxx 转换为绝对地址 </span><br><span class="line"> * </span><br><span class="line"> * @param path </span><br><span class="line"> * @return </span><br><span class="line"> */ </span><br><span class="line">public static String parseHomeDir2AbsDir(String path) &#123; </span><br><span class="line">    String homeDir = System.getProperties().getProperty(&quot;user.home&quot;); </span><br><span class="line">    return StringUtils.replace(path, &quot;~&quot;, homeDir); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来再看如何判断一个路径是否为绝对路径呢？</p>
<p>这里需要格外注意不同操作系统的差异性，比如win，区分C盘，D盘，但是mac/linux则不分这个，上面判断的核心逻辑如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public static boolean isAbsFile(String fileName) &#123; </span><br><span class="line">    if (OSUtil.isWinOS()) &#123; </span><br><span class="line">        // windows 操作系统时，绝对地址形如  c:\descktop </span><br><span class="line">        return fileName.contains(&quot;:&quot;) || fileName.startsWith(&quot;\\&quot;); </span><br><span class="line">    &#125; else &#123; </span><br><span class="line">        // mac or linux </span><br><span class="line">        return fileName.startsWith(&quot;/&quot;); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">/** </span><br><span class="line"> * 是否windows系统 </span><br><span class="line"> */ </span><br><span class="line">public static boolean isWinOS() &#123; </span><br><span class="line">    boolean isWinOS = false; </span><br><span class="line">    try &#123; </span><br><span class="line">        String osName = System.getProperty(&quot;os.name&quot;).toLowerCase(); </span><br><span class="line">        String sharpOsName = osName.replaceAll(&quot;windows&quot;, &quot;</span><br><span class="line">&#123;windows&#125;&quot;).replaceAll(&quot;^win([â-z])&quot;, &quot;&#123;windows&#125;$1&quot;) </span><br><span class="line">                .replaceAll(&quot;([â-z])win([â-z])&quot;, &quot;$1&#123;windows&#125;$2&quot;); </span><br><span class="line">        isWinOS = sharpOsName.contains(&quot;&#123;windows&#125;&quot;); </span><br><span class="line">    &#125; catch (Exception e) &#123; </span><br><span class="line">        e.printStackTrace(); </span><br><span class="line">    &#125; </span><br><span class="line">    return isWinOS; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了上面的三种本地资源获取之外，还有一个就是网络资源的读取，上面介绍的实现姿势主要是基于JDK原生的URL，在实际使用时，这个并不稳定，不能确定能获取到完整的数据，原则上不推荐使用；如果可以，使用http-client/okhttp都是不错的选择</p>
<p>最后给一个简单的测试</p>
<p>最后一个简单下载图片的case</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String img = &quot;https://c-</span><br><span class="line">ssl.duitang.com/uploads/item/201809/16/20180916175034_Gr2hk.thumb.1000_0.jpeg&quot;; </span><br><span class="line">BufferedImage pic = ImageIO.read(FileReadUtil.getStreamByFileName(img)); </span><br><span class="line">System.out.println(pic);</span><br></pre></td></tr></table></figure>
<p><img src="\assets\project\image-20231106165647888.png" alt="image-20231106165647888"></p>
<h1 id="实战35：调用本地程序的几种姿势"><a href="#实战35：调用本地程序的几种姿势" class="headerlink" title="实战35：调用本地程序的几种姿势"></a>实战35：调用本地程序的几种姿势</h1><p>作为一个后端同学，经常被安全的小伙伴盯上，找一找安全漏洞；除了常说的注入之外，还有比<br>较吓人的执行远程命令，唤醒本地应用程序等；然后有意思的问题就来了，写了这么多年的代<br>码，好像还真没有尝试过用java来唤醒本地应用程序的<br>比如说一个最简单的，打开本地的计算器，应该怎么搞？<br>接下来本文将介绍一下如何使用java打开本地应用，以及打开mac系统中特殊一点的处理方式<br>（直白来说就是不同操作系统，使用姿势不一样）</p>
<h2 id="1-Runtime使用方式"><a href="#1-Runtime使用方式" class="headerlink" title="1.Runtime使用方式"></a>1.Runtime使用方式</h2><p>主要是基于 Runtime.getRuntime().exec()来执行shell命令，来打开应用</p>
<ul>
<li>传参就是需要打开的应用名</li>
</ul>
<p>比如上面说到的打开计算器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// win系统 </span><br><span class="line">Runtime.getRuntime().exec(&quot;exec&quot;); </span><br><span class="line">// mac系统 </span><br><span class="line">Runtime.getRuntime().exec(&quot;open -n /Applications/Calculator.app&quot;)</span><br></pre></td></tr></table></figure>
<p>从上面的传参也可以看出两者的区别，为什么mac会整一个 open -n ， 这个其实可以理解为在终端执行命令，打开计算器</p>
<p><strong>注意事项</strong></p>
<p>对于mac系统而言，除了上面这种打开方式之外，还有下面这种姿势</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().exec(&quot;/Applications/Calculator.app/Contents/MacOS/Calculator&quot;)</span><br></pre></td></tr></table></figure>
<p>在exec中指定计算器的路径，有个很容易采的坑，直接写成下面这种</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().exec(&quot;/Applications/Calculator.app&quot;)</span><br></pre></td></tr></table></figure>
<p>上面这个直接执行之后会提示权限错误 ，其主要原因是mac系统的应用和win中的exe作为启动方式不太一样，对于mac而言，可以理解 xxx.app为一个目录，真正执行文件是内部的xxx/Contents/MacOS/xxx</p>
<h2 id="2-ProcessBuilder使用方式"><a href="#2-ProcessBuilder使用方式" class="headerlink" title="2.ProcessBuilder使用方式"></a>2.ProcessBuilder使用方式</h2><p>除了Runtime唤起之外，使用ProcessBuilder也属于非常常见的case</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// win </span><br><span class="line">new ProcessBuilder(&quot;exec&quot;).start() </span><br><span class="line">// mac 注意，使用下面这个，则传参不能是 open -n xxx </span><br><span class="line">new ProcessBuilder(&quot;/Applications/Calculator.app/Contents/MacOS/Calculator&quot;).start()</span><br></pre></td></tr></table></figure>
<p>使用上面这种姿势，特别需要注意的是内部传参不能是 open -n</p>
<h2 id="3-小结-5"><a href="#3-小结-5" class="headerlink" title="3.小结"></a>3.小结</h2><p>从上面介绍的方式来看，其实打开应用程序的思路主要就是利用java来执行脚本命令；内容比较简单，隐患却是比较大的；在自己的项目中，最好不要出现这种调用方式</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://whalerest.top">鲸落</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://whalerest.top/posts/fe2abc65.html">https://whalerest.top/posts/fe2abc65.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://whalerest.top" target="_blank">鲸落</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/assets/silhouette_night_starry_sky_137292_300x168.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/assets/weplay.png" target="_blank"><img class="post-qr-code-img" src="/assets/weplay.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/assets/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/assets/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/posts/ddb29ea7.html" title="计算机网络面试题八股文"><img class="cover" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">计算机网络面试题八股文</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/assets/mmexport1694508539292.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">鲸落</div><div class="author-info__description">随波不逐流</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">282</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">243</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/htx-rest"><i class="fab fa-github"></i><span>前往小窝</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="/assets/wenxin.jpg" target="_blank" title="微信"><i class="iconfont icon-weixin" style="color: #24292e;"></i></a><a class="social-icon" href="/assets/weixingongzhonghao.jpg" target="_blank" title="微信公众号"><i class="iconfont icon-weixingongzhonghao" style="color: #24292e;"></i></a><a class="social-icon" href="https://res.abeim.cn/api/qq/?qq=1656855152" target="_blank" title="QQ"><i class="iconfont icon-QQ" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:1656855152@qq.com" target="_blank" title="QQ邮箱"><i class="iconfont icon-youxiang" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">微信关注公众号“二哈学习之路”，回复“面渣笔记”，领取面试八股文！！！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%AE%9E%E6%88%98%E6%BC%94%E7%BB%83"><span class="toc-text">Java实战演练</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E6%88%981%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8D%A0%E4%BD%8D%E6%9B%BF%E6%8D%A2"><span class="toc-text">实战1：字符串占位替换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-String-format"><span class="toc-text">1.String.format</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E7%B1%BB%E5%9E%8B%E4%B8%8D%E5%8C%B9%E9%85%8D"><span class="toc-text">1.1 类型不匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%8F%82%E6%95%B0%E4%B8%AA%E6%95%B0%E4%B8%8D%E5%8C%B9%E9%85%8D"><span class="toc-text">1.2 参数个数不匹配</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-MessageFormat"><span class="toc-text">2. MessageFormat</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%88%90%E5%AF%B9%E5%87%BA%E7%8E%B0"><span class="toc-text">2.1 {}成对出现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%8D%95%E5%BC%95%E5%8F%B7"><span class="toc-text">2.2 单引号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%BA%8F%E5%8F%B7%E7%9C%81%E7%95%A5"><span class="toc-text">2.3 序号省略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%B0%8F%E7%BB%93"><span class="toc-text">3.小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E6%88%982%EF%BC%9A%E6%95%B0%E7%BB%84%E4%B8%8Elist%E4%BA%92%E8%BD%AC"><span class="toc-text">实战2：数组与list互转</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%95%B0%E7%BB%84%E8%BD%ACList"><span class="toc-text">1.数组转List</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-Array-asList"><span class="toc-text">1.1. Array.asList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-new-ArrayList"><span class="toc-text">1.2. new ArrayList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-Collections-addAll"><span class="toc-text">1.3. Collections.addAll</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%88%97%E8%A1%A8%E8%BD%AC%E6%95%B0%E7%BB%84"><span class="toc-text">2.列表转数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%B0%8F%E7%BB%93-1"><span class="toc-text">3.小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E6%88%983%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8ECollection%E7%9A%84%E4%BA%92%E8%BD%AC"><span class="toc-text">实战3：字符串与Collection的互转</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E5%88%97%E8%A1%A8"><span class="toc-text">1.字符串转列表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-jdk%E6%94%AF%E6%8C%81%E6%96%B9%E5%BC%8F"><span class="toc-text">1.1. jdk支持方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-guava%E6%96%B9%E5%BC%8F"><span class="toc-text">1.2. guava方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-apache-commons"><span class="toc-text">1.3. apache-commons</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%88%97%E8%A1%A8%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">2.列表转字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-StringBuilder"><span class="toc-text">2.1. StringBuilder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-String-join"><span class="toc-text">2.2. String.join</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-gauva"><span class="toc-text">2.3. gauva</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%B0%8F%E7%BB%93-2"><span class="toc-text">3.小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E6%88%984%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5"><span class="toc-text">实战4：字符串拼接</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%AE%9E%E7%8E%B0"><span class="toc-text">1.实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E6%99%AE%E9%80%9A%E5%86%99%E6%B3%95"><span class="toc-text">1.1. 普通写法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-StringJoiner"><span class="toc-text">1.2. StringJoiner</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-guava-joiner"><span class="toc-text">1.3. guava joiner</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%B0%8F%E7%BB%93"><span class="toc-text">2.小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E6%88%985%EF%BC%9A%E9%A9%BC%E5%B3%B0%E4%B8%8E%E4%B8%8B%E5%88%92%E7%BA%BF%E5%88%92%E8%BD%AC"><span class="toc-text">实战5：驼峰与下划线划转</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%AE%9E%E7%8E%B0-1"><span class="toc-text">1.实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-Gauva"><span class="toc-text">1.1. Gauva</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-Hutool"><span class="toc-text">1.2. Hutool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%9E%E7%8E%B0"><span class="toc-text">1.3. 自定义实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E6%88%986%EF%BC%9A%E6%9E%9A%E4%B8%BE%E7%9A%84%E7%89%B9%E6%AE%8A%E7%94%A8%E6%B3%95"><span class="toc-text">实战6：枚举的特殊用法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">1.使用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-text">1.1. 单例模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="toc-text">1.2. 策略模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%B0%8F%E7%BB%93-1"><span class="toc-text">2.小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E6%88%987%EF%BC%9A%E6%8E%92%E5%BA%8F%E6%AF%94%E8%BE%83%E8%A6%81%E6%85%8E%E9%87%8D"><span class="toc-text">实战7：排序比较要慎重</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%8E%92%E5%BA%8F"><span class="toc-text">1.排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-Comparator-%E4%B8%8E-Comparable"><span class="toc-text">1.1. Comparator 与 Comparable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E8%B8%A9%E5%9D%91%E9%A2%84%E5%91%8A"><span class="toc-text">1.2. 踩坑预告</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%B0%8F%E7%BB%93-2"><span class="toc-text">2.小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E6%88%988%EF%BC%9A%E5%AE%B9%E5%99%A8%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A4%A7%E5%B0%8F%E6%8C%87%E5%AE%9A"><span class="toc-text">实战8：容器的初始化大小指定</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">1.容器初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-List"><span class="toc-text">1.1. List</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-1-ArrayList"><span class="toc-text">1.1.1 ArrayList</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-2-LinkedList"><span class="toc-text">1.1.2 LinkedList</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-3-CopyOnWriteArrayList"><span class="toc-text">1.1.3 CopyOnWriteArrayList</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-Map"><span class="toc-text">1.2.Map</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-HashMap"><span class="toc-text">1.2.1 HashMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-LinkedHashMap"><span class="toc-text">1.2.2 LinkedHashMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-3-ConcurrentHashMap"><span class="toc-text">1.2.3 ConcurrentHashMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-4-TreeMap"><span class="toc-text">1.2.4 TreeMap</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-Set"><span class="toc-text">1.3. Set</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%B0%8F%E7%BB%93-3"><span class="toc-text">2.小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E6%88%989%EF%BC%9AList-subList%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BD%93StackOverflowError"><span class="toc-text">实战9：List.subList使用不当StackOverflowError</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%AE%9E%E4%BE%8B%E8%AF%B4%E6%98%8E"><span class="toc-text">1.实例说明</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-subList"><span class="toc-text">1.1. subList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-StackOverflowError%E5%88%86%E6%9E%90"><span class="toc-text">1.2. StackOverflowError分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%B0%8F%E7%BB%93-4"><span class="toc-text">2.小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E6%88%9810%EF%BC%9A%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AE%B9%E5%99%A8"><span class="toc-text">实战10：不可变容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AE%B9%E5%99%A8"><span class="toc-text">1.不可变容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-JDK%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AE%B9%E5%99%A8"><span class="toc-text">1.1. JDK不可变容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-Guava%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AE%B9%E5%99%A8"><span class="toc-text">1.2. Guava不可变容器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">2.注意事项</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E6%88%9811%EF%BC%9AMap%E8%BD%AC%E6%8D%A2Map%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">实战11：Map转换Map的几种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Map%E4%BA%92%E8%BD%AC"><span class="toc-text">1.Map互转</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%AE%9E%E4%BE%8B%E5%9C%BA%E6%99%AF"><span class="toc-text">1.1 实例场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-1-%E5%9F%BA%E6%9C%AC%E7%9A%84for%E5%BE%AA%E7%8E%AF%E8%BD%AC%E6%8D%A2"><span class="toc-text">1.1.1 基本的for循环转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-2-%E5%AE%B9%E5%99%A8%E7%9A%84%E6%B5%81%E5%BC%8F%E4%BD%BF%E7%94%A8"><span class="toc-text">1.1.2 容器的流式使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-3-Guava%E7%9A%84trasform%E6%96%B9%E5%BC%8F"><span class="toc-text">1.1.3 Guava的trasform方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E6%9C%80%E5%90%8E%E4%B8%80%E9%97%AE%EF%BC%8C%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E7%9B%AE%E7%9A%84%E6%98%AF%E5%95%A5%EF%BC%9F"><span class="toc-text">1.2 最后一问，这篇文章目的是啥？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E6%88%9812%EF%BC%9A%E5%B7%A7%E7%94%A8%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86"><span class="toc-text">实战12：巧用函数方法实现二维数组遍历</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E6%88%9813%EF%BC%9AList%E8%BD%ACMap-List%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A7%BF%E5%8A%BF"><span class="toc-text">实战13：List转Map List的几种姿势</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%BD%AC%E6%8D%A2%E6%96%B9%E5%BC%8F"><span class="toc-text">1.转换方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%9F%BA%E6%9C%AC%E5%86%99%E6%B3%95"><span class="toc-text">1.1. 基本写法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">1.2. 通用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">1.3. 工具类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-guava-HashMultimap%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-text">1.4.guava HashMultimap扩展知识点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E6%88%9814%EF%BC%9A%E5%88%86%E9%A1%B5%E9%81%8D%E5%8E%86%E5%BE%97%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0%E7%AD%96%E7%95%A5"><span class="toc-text">实战14：分页遍历得两种实现策略</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-text">1.实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E6%A8%A1%E6%8B%9F"><span class="toc-text">1.1. 数据查询模拟</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-text">1.2. 基本实现方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-text">1.3. 迭代器实现方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E6%88%9815%EF%BC%9A%E6%95%B0%E7%BB%84%E6%8B%B7%E8%B4%9D"><span class="toc-text">实战15：数组拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-1"><span class="toc-text">1.实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%9F%BA%E7%A1%80%E5%86%99%E6%B3%95"><span class="toc-text">1.1. 基础写法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%80%9F%E7%94%A8%E5%AE%B9%E5%99%A8%E4%B8%AD%E8%BD%AC"><span class="toc-text">1.2. 借用容器中转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-Array-copy"><span class="toc-text">1.3. Array.copy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-System-arraycopy"><span class="toc-text">1.4. System.arraycopy</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E6%88%9816%EF%BC%9A%E5%88%A4%E6%96%AD%E7%B1%BB%E4%B8%BA%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8Bor%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-text">实战16：判断类为基础类型or基础类型的包装类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD"><span class="toc-text">1.基础类型判断</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%B0%81%E8%A3%85%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD"><span class="toc-text">2.封装类型判断</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E6%88%9817%EF%BC%9AJava%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E8%BE%93%E5%87%BA"><span class="toc-text">实战17：Java对象内存地址输出</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E6%88%9818%EF%BC%9A%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E6%80%8E%E4%B9%88%E9%80%89"><span class="toc-text">实战18：随机数生成怎么选</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90"><span class="toc-text">1.随机数生成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-Math-random"><span class="toc-text">1.1. Math.random</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-Random"><span class="toc-text">1.2. Random</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-Math-random-%E4%B8%8E-Random%E5%A6%82%E4%BD%95%E9%80%89"><span class="toc-text">1.3. Math.random 与 Random如何选</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E6%88%9819%EF%BC%9A%E6%95%B0%E5%AD%97%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="toc-text">实战19：数字格式化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="toc-text">1.格式化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-DecimalFormat%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E"><span class="toc-text">1.1. DecimalFormat使用说明</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E6%88%9820%EF%BC%9A%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E5%BE%88%E7%AE%80%E5%8D%95"><span class="toc-text">实战20：进制转换很简单</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="toc-text">1.进制转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-toString%E5%AE%9E%E7%8E%B0%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="toc-text">1.1. toString实现进制转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E4%BA%8C%E8%BF%9B%E5%88%B6"><span class="toc-text">1.2. 十进制转二进制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E5%85%AB%E8%BF%9B%E5%88%B6"><span class="toc-text">1.3. 十进制转八进制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6"><span class="toc-text">1.4. 十进制转十六进制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E6%88%9821%EF%BC%9AProperties%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-text">实战21：Properties配置文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Properties%E9%85%8D%E7%BD%AE%E7%B1%BB"><span class="toc-text">1.Properties配置类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-text">1.1. 配置文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD"><span class="toc-text">1.2. 配置文件加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-Properties%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8"><span class="toc-text">1.3. Properties对象使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%B0%8F%E7%BB%93-5"><span class="toc-text">2.小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E6%88%9822%EF%BC%9AProperties%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%87%AA%E5%8A%A8%E8%A3%85%E8%BD%BDJavaBean"><span class="toc-text">实战22：Properties配置文件自动装载JavaBean</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%85%8D%E7%BD%AE%E5%B0%81%E8%A3%85"><span class="toc-text">1.配置封装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%87%AA%E5%8A%A8%E8%A3%85%E8%BD%BD"><span class="toc-text">1.1. 配置文件自动装载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95"><span class="toc-text">1.2. 功能测试</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E6%88%9823%EF%BC%9A%E5%9F%BA%E4%BA%8E%E5%BC%95%E5%85%A5%E5%8C%85%E9%80%89%E6%8B%A9%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-text">实战23：基于引入包选择具体实现类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-2"><span class="toc-text">1.实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%BB%BB%E5%8A%A1%E8%AF%B4%E6%98%8E"><span class="toc-text">1.1. 任务说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-text">1.2.具体实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6"><span class="toc-text">1.3. 扩展机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%B0%8F%E7%BB%93-6"><span class="toc-text">2.小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E6%88%9824%EF%BC%9A-%E5%9F%BA%E4%BA%8EJDK%E7%9A%84LRU%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-text">实战24： 基于JDK的LRU算法实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-LRU%E7%AE%97%E6%B3%95"><span class="toc-text">1.LRU算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-LRU%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-text">1.1 LRU算法实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%B0%8F%E7%BB%93"><span class="toc-text">1.2 小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E6%88%9825%EF%BC%9A-%E6%95%B0%E5%AD%97%E5%9E%8B%E5%AD%97%E9%9D%A2%E9%87%8F%E4%B8%AD%E7%9A%84%E4%B8%8B%E5%88%92%E7%BA%BF"><span class="toc-text">实战25： 数字型字面量中的下划线</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Java7%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%E6%95%B0%E5%AD%97%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%B8%8B%E5%88%92%E7%BA%BF"><span class="toc-text">1.Java7新特性之数字中使用下划线</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%B0%8F%E7%BB%93-7"><span class="toc-text">2.小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E6%88%9826%EF%BC%9A%E5%88%97%E8%A1%A8%E9%81%8D%E5%8E%86%E5%88%A0%E9%99%A4%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="toc-text">实战26：列表遍历删除使用实例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-List%E9%81%8D%E5%8E%86%E5%88%A0%E9%99%A4"><span class="toc-text">1.List遍历删除</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-foreach"><span class="toc-text">1.1. foreach</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E6%99%AE%E9%80%9Afor%E5%BE%AA%E7%8E%AF"><span class="toc-text">1.2. 普通for循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E8%BF%AD%E4%BB%A3%E6%96%B9%E5%BC%8F"><span class="toc-text">1.3. 迭代方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-jdk8-%E6%B5%81%E6%96%B9%E5%BC%8F"><span class="toc-text">1.4. jdk8+ 流方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%B0%8F%E7%BB%93-8"><span class="toc-text">2.小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E6%88%9827%EF%BC%9AHashMap%E9%81%8D%E5%8E%86%E5%88%A0%E9%99%A4%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="toc-text">实战27：HashMap遍历删除使用实例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Map-%E8%BF%AD%E4%BB%A3%E5%88%A0%E9%99%A4"><span class="toc-text">1.Map 迭代删除</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E9%9D%9E%E5%B8%B8%E4%B8%8D%E4%BC%98%E9%9B%85%E7%89%88%E6%9C%AC"><span class="toc-text">1.1. 非常不优雅版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF%E7%89%88"><span class="toc-text">1.2. 正确姿势版</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E7%AE%80%E6%B4%81%E7%89%88"><span class="toc-text">1.3. 简洁版</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%B0%8F%E7%BB%93-9"><span class="toc-text">2.小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E6%88%9828%EF%BC%9A%E4%BC%98%E9%9B%85%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E8%80%97%E6%97%B6%E7%BB%9F%E8%AE%A1"><span class="toc-text">实战28：优雅的实现代码耗时统计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BB%A3%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-text">1.代理方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-AutoCloseable"><span class="toc-text">2.AutoCloseable</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%B0%8F%E7%BB%93-3"><span class="toc-text">3.小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E6%88%9829%EF%BC%9A%E8%8E%B7%E5%8F%96%E7%B1%BB%E8%B7%AF%E5%BE%84%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E5%BC%8F"><span class="toc-text">实战29：获取类路径的常见方式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%B5%84%E6%BA%90%E8%B7%AF%E5%BE%84%E6%9F%A5%E8%AF%A2"><span class="toc-text">1.资源路径查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%B0%8F%E7%BB%93-10"><span class="toc-text">2.小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E6%88%9830%EF%BC%9AJDK%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8E%8B%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">实战30：JDK压缩与解压工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8E%8B%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">1.压缩与解压工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0"><span class="toc-text">1.1. 基本实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">1.2. 注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%B0%8F%E7%BB%93-11"><span class="toc-text">2.小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E6%88%9831%EF%BC%9A%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%8F%8A%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">实战31：深拷贝浅拷贝及对象拷贝的两种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Java%E4%B9%8BClone"><span class="toc-text">1.Java之Clone</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E8%83%8C%E6%99%AF"><span class="toc-text">1.1 背景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%86%85%E5%AE%B9%E8%AF%B4%E6%98%8E"><span class="toc-text">1.2 内容说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-text">2.深拷贝和浅拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%AE%9A%E4%B9%89%E8%AF%B4%E6%98%8E"><span class="toc-text">2.1 定义说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-text">2.2 浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-text">2.3 深拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E5%8C%BA%E5%88%86"><span class="toc-text">2.4 应用场景区分</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D%E5%B7%A5%E5%85%B7"><span class="toc-text">3.对象拷贝工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%80%9F%E5%8A%A9%E5%8F%8D%E5%B0%84%E5%AE%9E%E7%8E%B0%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D"><span class="toc-text">3.1 借助反射实现对象拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E4%BB%A3%E7%90%86%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D"><span class="toc-text">3.2 代理的方式实现对象拷贝</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%B0%8F%E7%BB%93-4"><span class="toc-text">3.小结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-text">3.1 深拷贝和浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-text">3.2 对象拷贝的两种方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E6%88%9832%EF%BC%9AJava%E5%8F%AF%E4%BB%A5%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E5%8F%98%E5%8A%A8%E7%9A%84%E7%9B%91%E5%90%AC"><span class="toc-text">实战32：Java可以如何实现文件变动的监听</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0%E5%8F%8A%E5%88%86%E6%9E%90"><span class="toc-text">1.问题描述及分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.设计与实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%BF%9B%E9%98%B6%E7%89%88"><span class="toc-text">3.进阶版</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-apache%E7%89%88"><span class="toc-text">3.1 apache版</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-JDK%E7%89%88%E6%9C%AC"><span class="toc-text">3.2 JDK版本</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%B0%8F%E7%BB%93"><span class="toc-text">4.小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E6%88%9833%EF%BC%9A%E5%AE%9E%E7%94%A8%E7%9A%84Map%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">实战33：实用的Map初始化工具类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E6%88%9834%EF%BC%9A%E9%80%9A%E7%94%A8%E7%9A%84%E6%A0%B9%E6%8D%AE%E8%B7%AF%E5%BE%84%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E8%B5%84%E6%BA%90%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">实战34：通用的根据路径获取文件资源的工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%B7%A5%E5%85%B7%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-text">1.工具实现类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E6%88%9835%EF%BC%9A%E8%B0%83%E7%94%A8%E6%9C%AC%E5%9C%B0%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E5%A7%BF%E5%8A%BF"><span class="toc-text">实战35：调用本地程序的几种姿势</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Runtime%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-text">1.Runtime使用方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-ProcessBuilder%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-text">2.ProcessBuilder使用方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%B0%8F%E7%BB%93-5"><span class="toc-text">3.小结</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 By 鲸落</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">I wish you to become your own sun, no need to rely on who's light.</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async src="https://cdn1.tianli0.top/npm/vue@2.6.14/dist/vue.min.js"></script><script async src="https://cdn1.tianli0.top/npm/element-ui@2.15.6/lib/index.js"></script><script async src="https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script><script defer type="text/javascript" src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script defer src="https://cdn1.tianli0.top/gh/nextapps-de/winbox/dist/winbox.bundle.min.js"></script><script async src="//at.alicdn.com/t/c/font_4233300_xxm4hpxio1.js"></script><script async src="/js/fps.js"></script><script async src="https://cdn.wpon.cn/2022-sucai/Gold-ingot.js"></script><script defer data-pjax src="/js/cat.js"></script><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><canvas id="snow"></canvas><script defer src="/js/fomal.js"></script><script defer src="/js/cursor.js"></script><script defer src="/live2d-widget/autoload.js"></script><script async src="/js/title.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 190px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 160px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(http://p0.itc.cn/images03/20200525/332e1ea10c634cbfaf0dfc5b69d00a3c.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Java笔试编程真题/&quot;);" href="javascript:void(0);">Java笔试编程真题</a><span class="categoryBar-list-count">223</span><span class="categoryBar-list-descr">Docker</span></li><li class="categoryBar-list-item" style="background:url(http://p8.itc.cn/images03/20200525/377f4f7044fe49b0bb932f43ef4f4891.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Docker/&quot;);" href="javascript:void(0);">Docker</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr">Hexo魔改教程</span></li><li class="categoryBar-list-item" style="background:url(http://p8.itc.cn/images03/20200525/0ed549edde2c4d5eaecc2824e753ca74.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Hexo魔改教程/&quot;);" href="javascript:void(0);">Hexo魔改教程</a><span class="categoryBar-list-count">12</span><span class="categoryBar-list-descr">MySQL</span></li><li class="categoryBar-list-item" style="background:url(http://p6.itc.cn/images03/20200525/8dedcdf6ace44a50a1deb6a9743821fe.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/面试题/&quot;);" href="javascript:void(0);">面试题</a><span class="categoryBar-list-count">10</span><span class="categoryBar-list-descr">面试题</span></li><li class="categoryBar-list-item" style="background:url(http://p8.itc.cn/images03/20200525/5f6cecf10ea04dec9a5d42bf9c4c3739.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/面渣笔记/&quot;);" href="javascript:void(0);">面渣笔记</a><span class="categoryBar-list-count">16</span><span class="categoryBar-list-descr">Redis</span></li><li class="categoryBar-list-item" style="background:url(http://p0.itc.cn/images03/20200525/332e1ea10c634cbfaf0dfc5b69d00a3c.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/MySQL/&quot;);" href="javascript:void(0);">MySQL</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr">Java笔试编程真题</span></li><li class="categoryBar-list-item" style="background:url(http://p8.itc.cn/images03/20200525/377f4f7044fe49b0bb932f43ef4f4891.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/RabbitMQ/&quot;);" href="javascript:void(0);">RabbitMQ</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr">Java数据结构与算法</span></li><li class="categoryBar-list-item" style="background:url(http://p8.itc.cn/images03/20200525/0ed549edde2c4d5eaecc2824e753ca74.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Redis/&quot;);" href="javascript:void(0);">Redis</a><span class="categoryBar-list-count">5</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(http://p6.itc.cn/images03/20200525/8dedcdf6ace44a50a1deb6a9743821fe.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Kafka/&quot;);" href="javascript:void(0);">Kafka</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/leetcode/&quot;);" href="javascript:void(0);">leetcode</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/面试/&quot;);" href="javascript:void(0);">面试</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/设计模式/&quot;);" href="javascript:void(0);">设计模式</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Java数据结构与算法/&quot;);" href="javascript:void(0);">Java数据结构与算法</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var qweather_key = 'b16a1fa0e63c46a4b8f28abfb06ae3fe';
  var gaud_map_key = 'e2b04289e870b005374ee030148d64fd&s=rsv3';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '113.34532,23.15624';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v6.2.0" title=""><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.9.0" title=""><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="https://npm.elemecdn.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.js"></script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/b5cfa224.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/b5cfa224.html&quot;);" href="javascript:void(0);" alt="">蚂蚁校招编程真题及其解析（2023.5.18）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/b5cfa224.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/a366af84.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/a366af84.html&quot;);" href="javascript:void(0);" alt="">蚂蚁校招编程真题及其解析（2023.4.4）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/a366af84.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/91acfbaf.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/91acfbaf.html&quot;);" href="javascript:void(0);" alt="">蚂蚁校招编程真题及其解析（2023.4.20）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/91acfbaf.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/6eb0e61a.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/6eb0e61a.html&quot;);" href="javascript:void(0);" alt="">蚂蚁校招编程真题及其解析（2023.4.11）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/6eb0e61a.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/ecb7a244.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/ecb7a244.html&quot;);" href="javascript:void(0);" alt="">蚂蚁校招编程真题及其解析（2023.3.21）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/ecb7a244.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/b1a216eb.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/b1a216eb.html&quot;);" href="javascript:void(0);" alt="">蚂蚁校招编程真题及其解析（2022.10.27）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/b1a216eb.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/a449f40d.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-22</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/a449f40d.html&quot;);" href="javascript:void(0);" alt="">美的校招笔试编程真题（2023.4.19）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/a449f40d.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/1b4308aa.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-17</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/1b4308aa.html&quot;);" href="javascript:void(0);" alt="">美团校招笔试编程真题（2023.4.8）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/1b4308aa.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/b2891dfd.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-14</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/b2891dfd.html&quot;);" href="javascript:void(0);" alt="">美团校招笔试编程真题（2023.3.11）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/b2891dfd.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/7b50e04c.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/7b50e04c.html&quot;);" href="javascript:void(0);" alt="">美团校招笔试编程真题（2023.5.13）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/7b50e04c.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/f53a714c.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/f53a714c.html&quot;);" href="javascript:void(0);" alt="">美团校招笔试编程真题（2023.4.29）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/f53a714c.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/9a879128.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/9a879128.html&quot;);" href="javascript:void(0);" alt="">美团校招笔试编程真题（2023.4.23）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/9a879128.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/f84cb424.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-17</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/f84cb424.html&quot;);" href="javascript:void(0);" alt="">美团校招笔试编程真题（2023.4.15）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/f84cb424.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/cf815277.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-15</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/cf815277.html&quot;);" href="javascript:void(0);" alt="">美团校招笔试编程真题（2023.3.18）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/cf815277.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/843d6f38.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/843d6f38.html&quot;);" href="javascript:void(0);" alt="">美团校招笔试编程真题及其解析（2023.3.4）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/843d6f38.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/6482affa.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/6482affa.html&quot;);" href="javascript:void(0);" alt="">美团校招笔试编程真题及其解析（2023.3.25）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/6482affa.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/7a556a2f.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-14</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/7a556a2f.html&quot;);" href="javascript:void(0);" alt="">美团2024届秋招笔试编程真题（2023.9.9）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/7a556a2f.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/61f68248.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/61f68248.html&quot;);" href="javascript:void(0);" alt="">美团2024届秋招笔试第四场编程真题（2023.9.2）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/61f68248.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/f51f72fb.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-06</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/f51f72fb.html&quot;);" href="javascript:void(0);" alt="">美团2024届秋招笔试第二场编程真题（2023.8.19）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/f51f72fb.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/5b7a3f2a.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-07</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/5b7a3f2a.html&quot;);" href="javascript:void(0);" alt="">美团2024届秋招笔试第三场编程真题（2023.8.26）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/5b7a3f2a.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/860131f4.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-04</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/860131f4.html&quot;);" href="javascript:void(0);" alt="">美团2024届秋招笔试第一场编程真题（2023.8.12）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/860131f4.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/9ed49519.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/9ed49519.html&quot;);" href="javascript:void(0);" alt="">网易有道校招笔试编程真题及其解析（2023.4.2）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/9ed49519.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/f766fbc2.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/f766fbc2.html&quot;);" href="javascript:void(0);" alt="">科大讯飞校招笔试编程真题（2023.8.31）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/f766fbc2.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/6da30861.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/6da30861.html&quot;);" href="javascript:void(0);" alt="">科大讯飞校招笔试编程真题（2023.7.8）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/6da30861.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/f9fa8a74.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/f9fa8a74.html&quot;);" href="javascript:void(0);" alt="">科大讯飞校招笔试编程真题（2023.7.29）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/f9fa8a74.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2efb0d75.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2efb0d75.html&quot;);" href="javascript:void(0);" alt="">科大讯飞校招笔试编程真题（2023.7.22）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2efb0d75.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/7641fb6a.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/7641fb6a.html&quot;);" href="javascript:void(0);" alt="">科大讯飞校招笔试编程真题（2022.10.14）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/7641fb6a.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/10ab47eb.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/10ab47eb.html&quot;);" href="javascript:void(0);" alt="">科大讯飞校招笔试编程真题（2023.7.1）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/10ab47eb.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/815405c2.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/815405c2.html&quot;);" href="javascript:void(0);" alt="">科大讯飞校招笔试编程真题及其解析（2023.8.13）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/815405c2.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/52772af7.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/52772af7.html&quot;);" href="javascript:void(0);" alt="">科大讯飞校招笔试编程真题及其解析（2023.7.15）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/52772af7.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/19d99df0.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-19</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/19d99df0.html&quot;);" href="javascript:void(0);" alt="">操作系统OS面试题八股文</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/19d99df0.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/a135cfaa.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/a135cfaa.html&quot;);" href="javascript:void(0);" alt="">携程校招笔试编程真题及其解析（2023.9.7）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/a135cfaa.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/b264b8b5.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-26</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/b264b8b5.html&quot;);" href="javascript:void(0);" alt="">携程校招笔试编程真题及其解析（2023.9.21）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/b264b8b5.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/c442a03f.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-26</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/c442a03f.html&quot;);" href="javascript:void(0);" alt="">携程校招笔试编程真题及其解析（2023.5.4）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/c442a03f.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/faa64596.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/faa64596.html&quot;);" href="javascript:void(0);" alt="">携程校招笔试编程真题及其解析（2023.5.25）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/faa64596.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/1b7134f2.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/1b7134f2.html&quot;);" href="javascript:void(0);" alt="">携程校招笔试编程真题及其解析（2023.4.15）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/1b7134f2.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/aeeccc.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/aeeccc.html&quot;);" href="javascript:void(0);" alt="">携程校招笔试编程真题及其解析（2023.3.7）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/aeeccc.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/d3a0cf14.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-26</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/d3a0cf14.html&quot;);" href="javascript:void(0);" alt="">携程校招笔试编程真题及其解析（2023.3.29）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/d3a0cf14.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/cc63a592.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/cc63a592.html&quot;);" href="javascript:void(0);" alt="">携程校招笔试编程真题及其解析（2023.3.16）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/cc63a592.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2ec06a90.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-23</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2ec06a90.html&quot;);" href="javascript:void(0);" alt="">恒生电子校招笔试编程真题（2023.9.22）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2ec06a90.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/acdf6806.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-27</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/acdf6806.html&quot;);" href="javascript:void(0);" alt="">微众银行校招笔试编程真题及其解析（2023.9.3）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/acdf6806.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/7520a94a.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-27</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/7520a94a.html&quot;);" href="javascript:void(0);" alt="">微众银行校招笔试编程真题及其解析（2023.9.13）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/7520a94a.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/5357b25a.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-27</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/5357b25a.html&quot;);" href="javascript:void(0);" alt="">微众银行校招笔试编程真题及其解析（2023.4.23）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/5357b25a.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/ac4bafef.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-27</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/ac4bafef.html&quot;);" href="javascript:void(0);" alt="">微众银行校招笔试编程真题及其解析（2023.4.12）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/ac4bafef.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/70a5bb78.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-11</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/70a5bb78.html&quot;);" href="javascript:void(0);" alt="">广联达校招笔试编程真题及其解析（2023.10.11）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/70a5bb78.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/bad939ec.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-22</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/bad939ec.html&quot;);" href="javascript:void(0);" alt="">小红书校招笔试编程真题（2023.8.6）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/bad939ec.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/92b4cb69.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-22</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/92b4cb69.html&quot;);" href="javascript:void(0);" alt="">小红书校招笔试编程真题（2023.8.19）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/92b4cb69.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/4ce12134.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-22</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/4ce12134.html&quot;);" href="javascript:void(0);" alt="">小红书校招笔试编程真题（2023.7.23）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/4ce12134.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/befb4d57.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-22</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/befb4d57.html&quot;);" href="javascript:void(0);" alt="">小红书校招笔试编程真题（2023.5.7）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/befb4d57.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/9578e9c1.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-22</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/9578e9c1.html&quot;);" href="javascript:void(0);" alt="">小红书校招笔试编程真题（2023.4.9）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/9578e9c1.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/7d093ba9.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-22</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/7d093ba9.html&quot;);" href="javascript:void(0);" alt="">小红书校招笔试编程真题（2023.4.23）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/7d093ba9.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/8f70f515.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-22</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/8f70f515.html&quot;);" href="javascript:void(0);" alt="">小红书校招笔试编程真题（2023.3.26）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/8f70f515.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/7dc0b3d9.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/7dc0b3d9.html&quot;);" href="javascript:void(0);" alt="">字节跳动校招笔试编程真题及其解析（2023.9.3）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/7dc0b3d9.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/ecffee83.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/ecffee83.html&quot;);" href="javascript:void(0);" alt="">字节跳动校招笔试编程真题及其解析（2023.9.17）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/ecffee83.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/90ffa75e.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/90ffa75e.html&quot;);" href="javascript:void(0);" alt="">字节跳动校招笔试编程真题及其解析（2023.8.20）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/90ffa75e.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/d289fe7.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/d289fe7.html&quot;);" href="javascript:void(0);" alt="">字节跳动校招笔试编程真题及其解析（2023.8.27）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/d289fe7.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/1c8174c5.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/1c8174c5.html&quot;);" href="javascript:void(0);" alt="">字节跳动校招笔试编程真题及其解析（2023.5.12）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/1c8174c5.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/62a18d75.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/62a18d75.html&quot;);" href="javascript:void(0);" alt="">字节跳动校招笔试编程真题及其解析（2023.7.5）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/62a18d75.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/1d9a64f3.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/1d9a64f3.html&quot;);" href="javascript:void(0);" alt="">字节跳动校招笔试编程真题及其解析（2023.3.24）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/1d9a64f3.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/66b7b354.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/66b7b354.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.9.6）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/66b7b354.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/f0ad93be.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/f0ad93be.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.9.27）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/f0ad93be.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/7fcf04e9.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/7fcf04e9.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.9.23）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/7fcf04e9.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/d5c6cc62.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/d5c6cc62.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.9.21）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/d5c6cc62.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/6d7aab07.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/6d7aab07.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.9.20）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/6d7aab07.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/f66d8903.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/f66d8903.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.8.30）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/f66d8903.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/386f7e39.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/386f7e39.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.9.13）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/386f7e39.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/d9b80f5d.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/d9b80f5d.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.8.23）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/d9b80f5d.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/1175732f.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/1175732f.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.5.6）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/1175732f.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2f068fa6.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2f068fa6.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.5.31）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2f068fa6.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/25b85624.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/25b85624.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.5.24）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/25b85624.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/70ad831a.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/70ad831a.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.5.17）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/70ad831a.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/ed7abba3.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/ed7abba3.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.5.10）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/ed7abba3.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/29c6951b.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/29c6951b.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.4.26）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/29c6951b.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/3605ff9d.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/3605ff9d.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.4.19）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/3605ff9d.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/e104789c.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/e104789c.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.4.12）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/e104789c.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/257ff08.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/257ff08.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.10.18）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/257ff08.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/6dea1f6c.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/6dea1f6c.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.10.12）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/6dea1f6c.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/7f5fb082.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/7f5fb082.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.10.11）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/7f5fb082.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/68b410aa.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/68b410aa.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2022.9.23）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/68b410aa.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/e1169d40.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-10</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/e1169d40.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2022.8.30）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/e1169d40.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/c2bdd821.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/c2bdd821.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2022.9.21）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/c2bdd821.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/b477f365.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-10</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/b477f365.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2022.11.2）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/b477f365.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/82287452.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/82287452.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2022.10.12）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/82287452.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/247ce45c.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/247ce45c.html&quot;);" href="javascript:void(0);" alt="">华为od校招笔试编程真题及其解析（2023.5.3）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/247ce45c.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/3821b0f8.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/3821b0f8.html&quot;);" href="javascript:void(0);" alt="">华为od校招笔试编程真题及其解析（2023.4.8）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/3821b0f8.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/541f7aa7.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/541f7aa7.html&quot;);" href="javascript:void(0);" alt="">华为od校招笔试编程真题及其解析（2023.5.11）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/541f7aa7.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/c8c04449.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/c8c04449.html&quot;);" href="javascript:void(0);" alt="">华为od校招笔试编程真题及其解析（2023.4.28）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/c8c04449.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/d746ca6.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/d746ca6.html&quot;);" href="javascript:void(0);" alt="">华为od校招笔试编程真题及其解析（2023.4.20）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/d746ca6.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/8f7328f8.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/8f7328f8.html&quot;);" href="javascript:void(0);" alt="">华为od校招笔试编程真题及其解析（2023.3.10）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/8f7328f8.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/c5b68121.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/c5b68121.html&quot;);" href="javascript:void(0);" alt="">华为od校招笔试编程真题及其解析（2023.4.14）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/c5b68121.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/d123261.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/d123261.html&quot;);" href="javascript:void(0);" alt="">华为od校招笔试编程真题及其解析（2022.11.3）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/d123261.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/9df7a3e6.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/9df7a3e6.html&quot;);" href="javascript:void(0);" alt="">华为od校招笔试编程真题及其解析（2022.10.14）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/9df7a3e6.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/5799fe.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/5799fe.html&quot;);" href="javascript:void(0);" alt="">京东校招编程真题及其解析（2023.9.9）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/5799fe.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/d7561eff.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/d7561eff.html&quot;);" href="javascript:void(0);" alt="">京东校招编程真题及其解析（2023.9.2）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/d7561eff.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/cbfa39e4.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-26</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/cbfa39e4.html&quot;);" href="javascript:void(0);" alt="">京东校招编程真题及其解析（2023.9.23）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/cbfa39e4.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/1cfbbee5.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/1cfbbee5.html&quot;);" href="javascript:void(0);" alt="">京东校招编程真题及其解析（2023.9.28）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/1cfbbee5.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/bb84b306.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/bb84b306.html&quot;);" href="javascript:void(0);" alt="">京东校招编程真题及其解析（2023.9.16）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/bb84b306.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/5a53c262.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/5a53c262.html&quot;);" href="javascript:void(0);" alt="">京东校招编程真题及其解析（2023.8.26）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/5a53c262.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/4590a8e4.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/4590a8e4.html&quot;);" href="javascript:void(0);" alt="">京东校招编程真题及其解析（2023.8.19）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/4590a8e4.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/92912fe5.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/92912fe5.html&quot;);" href="javascript:void(0);" alt="">京东校招编程真题及其解析（2023.8.12）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/92912fe5.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/475ed45.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/475ed45.html&quot;);" href="javascript:void(0);" alt="">京东校招编程真题及其解析（2023.4.8）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/475ed45.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/ec9632c2.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/ec9632c2.html&quot;);" href="javascript:void(0);" alt="">京东校招编程真题及其解析（2023.2.25）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/ec9632c2.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/ebbbf9bc.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-26</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/ebbbf9bc.html&quot;);" href="javascript:void(0);" alt="">京东校招编程真题及其解析（2023.10.7）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/ebbbf9bc.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/c13307dc.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/c13307dc.html&quot;);" href="javascript:void(0);" alt="">java进阶之路（一）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/c13307dc.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/bb381fef.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/bb381fef.html&quot;);" href="javascript:void(0);" alt="">Java进阶之路（四）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/bb381fef.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/410ba5d8.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/410ba5d8.html&quot;);" href="javascript:void(0);" alt="">Java进阶之路（二）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/410ba5d8.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/c15068a.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/c15068a.html&quot;);" href="javascript:void(0);" alt="">Java进阶之路（三）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/c15068a.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/3cbc845.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/3cbc845.html&quot;);" href="javascript:void(0);" alt="">Java数据结构与算法</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/3cbc845.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/f9c52cbb.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-19</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/f9c52cbb.html&quot;);" href="javascript:void(0);" alt="">设计模式面试篇-参考回答</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/f9c52cbb.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/eabb6106.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-12</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/eabb6106.html&quot;);" href="javascript:void(0);" alt="">消息中间件面试题-参考回答</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/eabb6106.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/27f853cc.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/27f853cc.html&quot;);" href="javascript:void(0);" alt="">框架篇面试题-参考回答</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/27f853cc.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/6ba374e2.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/6ba374e2.html&quot;);" href="javascript:void(0);" alt="">微服务面试篇-参考回答</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/6ba374e2.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/dbf9d5c9.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/dbf9d5c9.html&quot;);" href="javascript:void(0);" alt="">常见技术场景</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/dbf9d5c9.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/af15ea36.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/af15ea36.html&quot;);" href="javascript:void(0);" alt="">多线程相关面试题</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/af15ea36.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/258353ca.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/258353ca.html&quot;);" href="javascript:void(0);" alt="">kafka深入浅出，快速玩转分布式发布订阅消息系统</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/258353ca.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/6f83b1e4.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/6f83b1e4.html&quot;);" href="javascript:void(0);" alt="">Redis面试题-参考回答</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/6f83b1e4.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/37cf2cfd.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/37cf2cfd.html&quot;);" href="javascript:void(0);" alt="">Redis集群</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/37cf2cfd.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/d2ba1e3f.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/d2ba1e3f.html&quot;);" href="javascript:void(0);" alt="">Redis原理篇</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/d2ba1e3f.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/6bb2589.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-12</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/6bb2589.html&quot;);" href="javascript:void(0);" alt="">Rabbitmq消息中间件（二）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/6bb2589.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/6bb2589.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-12</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/6bb2589.html&quot;);" href="javascript:void(0);" alt="">Rabbitmq消息中间件（一）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/6bb2589.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/18ab1f25.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/18ab1f25.html&quot;);" href="javascript:void(0);" alt="">MySQL面试篇-参考回答</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/18ab1f25.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/11f76754.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/11f76754.html&quot;);" href="javascript:void(0);" alt="">MySQL进阶篇</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/11f76754.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/337fcc87.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/337fcc87.html&quot;);" href="javascript:void(0);" alt="">MySQL基础篇</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/337fcc87.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/592cf81.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/592cf81.html&quot;);" href="javascript:void(0);" alt="">MySQL运维篇</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/592cf81.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/b481a8d6.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/b481a8d6.html&quot;);" href="javascript:void(0);" alt="">Java集合相关面试题</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/b481a8d6.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/c218eb30.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/c218eb30.html&quot;);" href="javascript:void(0);" alt="">JVM相关面试题</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/c218eb30.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/7eb663f5.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/7eb663f5.html&quot;);" href="javascript:void(0);" alt="">Docker安装OpenResty</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/7eb663f5.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/be6d66dc.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/be6d66dc.html&quot;);" href="javascript:void(0);" alt="">Docker安装Canal</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/be6d66dc.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/a6573b44.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/a6573b44.html&quot;);" href="javascript:void(0);" alt="">Centos7安装Docker</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/a6573b44.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/d3404069.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/d3404069.html&quot;);" href="javascript:void(0);" alt="">Redis高级篇</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/d3404069.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/a6b15897.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/a6b15897.html&quot;);" href="javascript:void(0);" alt="">Redis实战篇</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/a6b15897.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/4604f75b.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-01</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/4604f75b.html&quot;);" href="javascript:void(0);" alt="">Redis基础篇</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/4604f75b.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '1s');
    arr[i].setAttribute('data-wow-offset', '100');
    arr[i].setAttribute('data-wow-iteration', '2');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --></body></html>