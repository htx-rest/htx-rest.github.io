<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java进阶之路（三） | 鲸落</title><meta name="author" content="鲸落"><meta name="copyright" content="鲸落"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="5 Java IO5.1 IO 分类“老王，Java IO 也太上头了吧？”新兵蛋子小二向头顶很凉快的老王抱怨道，“你瞧，我就按照传输方式对 IO 进行了一个简单的分类，就能搞出来这么多的玩意！”  好久没搞过 IO 了，老王看到这幅思维导图也是吃了一惊。想想也是，他当初学习 Java IO 的时候头也大，乌央乌央的一片，全是类，估计是所有 Java 包里面类最多的，一会是 Input 一会是 O">
<meta property="og:type" content="article">
<meta property="og:title" content="Java进阶之路（三）">
<meta property="og:url" content="https://htx-rest.github.io/posts/c15068a.html">
<meta property="og:site_name" content="鲸落">
<meta property="og:description" content="5 Java IO5.1 IO 分类“老王，Java IO 也太上头了吧？”新兵蛋子小二向头顶很凉快的老王抱怨道，“你瞧，我就按照传输方式对 IO 进行了一个简单的分类，就能搞出来这么多的玩意！”  好久没搞过 IO 了，老王看到这幅思维导图也是吃了一惊。想想也是，他当初学习 Java IO 的时候头也大，乌央乌央的一片，全是类，估计是所有 Java 包里面类最多的，一会是 Input 一会是 O">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img2.baidu.com/it/u=595920241,2439700946&fm=253&fmt=auto&app=120&f=JPEG?w=1422&h=800">
<meta property="article:published_time" content="2023-10-13T12:18:31.000Z">
<meta property="article:modified_time" content="2023-10-16T02:49:45.451Z">
<meta property="article:author" content="鲸落">
<meta property="article:tag" content="异常处理">
<meta property="article:tag" content="Java IO">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img2.baidu.com/it/u=595920241,2439700946&fm=253&fmt=auto&app=120&f=JPEG?w=1422&h=800"><link rel="shortcut icon" href="/"><link rel="canonical" href="https://htx-rest.github.io/posts/c15068a.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java进阶之路（三）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-10-16 10:49:45'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_4233300_xxm4hpxio1.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/element-ui@2.15.6/packages/theme-chalk/lib/index.css"><script src="https://npm.elemecdn.com/echarts@4.9.0/dist/echarts.min.js"></script><style id="themeColor"></style><style id="rightSide"></style><style id="transPercent"></style><style id="blurNum"></style><style id="settingStyle"></style><span id="fps"></span><style id="defineBg"></style><style id="menu_shadow"></style><div id="myscoll"></div><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://tuchuang.voooe.cn/images/2023/01/02/avatar.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">112</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">149</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-youhuawenzhang"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-guidang"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei"></i><span> 分类</span></a></li><li><a class="site-page child" href="javascript:randomPost();"><i class="fa-fw iconfont icon-wode-zuji-copy"></i><span> 随便逛逛</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-xiuxianyinpin"></i><span> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/life/music/"><i class="fa-fw iconfont icon-tool"></i><span> 八音盒</span></a></li><li><a class="site-page child" href="/life/movies/"><i class="fa-fw iconfont icon-dianying"></i><span> 影院</span></a></li><li><a class="site-page child" href="/life/games/"><i class="fa-fw iconfont icon-youxi"></i><span> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-baoxiang21"></i><span> 八宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/box/gallery/"><i class="fa-fw iconfont icon-hualang"></i><span> 画廊</span></a></li><li><a class="site-page child" href="/box/animation/"><i class="fa-fw iconfont icon-donghua"></i><span> 动画</span></a></li><li><a class="site-page child" href="/box/nav/"><i class="fa-fw iconfont icon-a-06-wangzhidaohang"></i><span> 网址导航</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-tubiaozhizuomoban1"></i><span> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/social/fcircle/"><i class="fa-fw iconfont icon-iconfontzhizuobiaozhunbduan36"></i><span> 朋友圈</span></a></li><li><a class="site-page child" href="/comments/"><i class="fa-fw iconfont icon-liuyanban"></i><span> 留言板</span></a></li><li><a class="site-page child" href="/social/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-a-06-wangzhidaohang"></i><span> 网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/site/census/"><i class="fa-fw iconfont icon-a-06-wangzhidaohang"></i><span> 网站统计</span></a></li><li><a class="site-page child" href="/site/echarts/"><i class="fa-fw iconfont icon-tongji"></i><span> 文章统计</span></a></li><li><a class="site-page child" href="/site/time/"><i class="fa-fw iconfont icon-shalou"></i><span> 旧时光</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-geren"></i><span> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/personal/bb/"><i class="fa-fw iconfont icon-icon_liuyan"></i><span> 唠叨</span></a></li><li><a class="site-page child" href="/personal/love/"><i class="fa-fw iconfont icon-valentine_-email-love-message-send"></i><span> 恋爱小屋</span></a></li><li><a class="site-page child" href="/personal/about/"><i class="fa-fw iconfont icon-icon-lark-logo-old"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800')"><nav id="nav"><span id="blog-info"><a href="/" title="鲸落"><span class="site-name">鲸落</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-youhuawenzhang"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-guidang"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei"></i><span> 分类</span></a></li><li><a class="site-page child" href="javascript:randomPost();"><i class="fa-fw iconfont icon-wode-zuji-copy"></i><span> 随便逛逛</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-xiuxianyinpin"></i><span> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/life/music/"><i class="fa-fw iconfont icon-tool"></i><span> 八音盒</span></a></li><li><a class="site-page child" href="/life/movies/"><i class="fa-fw iconfont icon-dianying"></i><span> 影院</span></a></li><li><a class="site-page child" href="/life/games/"><i class="fa-fw iconfont icon-youxi"></i><span> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-baoxiang21"></i><span> 八宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/box/gallery/"><i class="fa-fw iconfont icon-hualang"></i><span> 画廊</span></a></li><li><a class="site-page child" href="/box/animation/"><i class="fa-fw iconfont icon-donghua"></i><span> 动画</span></a></li><li><a class="site-page child" href="/box/nav/"><i class="fa-fw iconfont icon-a-06-wangzhidaohang"></i><span> 网址导航</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-tubiaozhizuomoban1"></i><span> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/social/fcircle/"><i class="fa-fw iconfont icon-iconfontzhizuobiaozhunbduan36"></i><span> 朋友圈</span></a></li><li><a class="site-page child" href="/comments/"><i class="fa-fw iconfont icon-liuyanban"></i><span> 留言板</span></a></li><li><a class="site-page child" href="/social/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-a-06-wangzhidaohang"></i><span> 网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/site/census/"><i class="fa-fw iconfont icon-a-06-wangzhidaohang"></i><span> 网站统计</span></a></li><li><a class="site-page child" href="/site/echarts/"><i class="fa-fw iconfont icon-tongji"></i><span> 文章统计</span></a></li><li><a class="site-page child" href="/site/time/"><i class="fa-fw iconfont icon-shalou"></i><span> 旧时光</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-geren"></i><span> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/personal/bb/"><i class="fa-fw iconfont icon-icon_liuyan"></i><span> 唠叨</span></a></li><li><a class="site-page child" href="/personal/love/"><i class="fa-fw iconfont icon-valentine_-email-love-message-send"></i><span> 恋爱小屋</span></a></li><li><a class="site-page child" href="/personal/about/"><i class="fa-fw iconfont icon-icon-lark-logo-old"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java进阶之路（三）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-10-13T12:18:31.000Z" title="发表于 2023-10-13 20:18:31">2023-10-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-10-16T02:49:45.451Z" title="更新于 2023-10-16 10:49:45">2023-10-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E6%B8%A3%E7%AC%94%E8%AE%B0/">面渣笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">50.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>182分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java进阶之路（三）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="5-Java-IO"><a href="#5-Java-IO" class="headerlink" title="5 Java IO"></a>5 Java IO</h1><h2 id="5-1-IO-分类"><a href="#5-1-IO-分类" class="headerlink" title="5.1 IO 分类"></a>5.1 IO 分类</h2><p>“老王，Java IO 也太上头了吧？”新兵蛋子小二向头顶很凉快的老王抱怨道，“你瞧，我就按照传输方式对 IO 进行了一个简单的分类，就能搞出来这么多的玩意！”</p>
<p><img src="\assets\note\image-20231010220517447.png" alt="image-20231010220517447"></p>
<p>好久没搞过 IO 了，老王看到这幅思维导图也是吃了一惊。想想也是，他当初学习 Java IO 的时候头也大，乌央乌央的一片，全是类，估计是所有 Java 包里面类最多的，一会是 Input 一会是 Output，一会是 Reader ，一会是 Writer，真不知道 Java 的设计者是怎么想的。</p>
<p>看着肺都快要气炸的小二，老王深深地吸了一口气，耐心地对小二说：“主要是 Java 的设计者考虑得比较多吧，所以 IO 给人一种很乱的感觉，我来给你梳理一下。”</p>
<p><strong>00、初识 Java IO </strong></p>
<p>IO，即in和out，也就是输入和输出，指应用程序和外部设备之间的数据传递，常见的外部设备包括文件、管道、网络连接。</p>
<p>Java 中是通过流处理IO 的，那么什么是流？</p>
<p>流（Stream），是一个抽象的概念，是指一连串的数据（字符或字节），是以先进先出的方式发送信息的通道。</p>
<p>当程序需要读取数据的时候，就会开启一个通向数据源的流，这个数据源可以是文件，内存，或是网络连接。类似的，当程序需要写入数据的时候，就会开启一个通向目的地的流。这时候你就可以想象数据好像在这其中“流”动一样。</p>
<p>一般来说关于流的特性有下面几点：</p>
<ul>
<li>先进先出：最先写入输出流的数据最先被输入流读取到。</li>
<li>顺序存取：可以一个接一个地往流中写入一串字节，读出时也将按写入顺序读取一串字节，不能随机访问中间的数据（RandomAccessFile除外）</li>
<li>只读或只写：每个流只能是输入流或输出流的一种，不能同时具备两个功能，输入流只能进行读操作，对输出流只能进行写操作。在一个数据传输通道中，如果既要写入数据，又要读取数据，则要分别提供两个流。</li>
</ul>
<p><strong>01、传输方式划分 </strong></p>
<p>就按照你的那副思维导图来说吧。</p>
<p>传输方式有两种，字节和字符，那首先得搞明白字节和字符有什么区别，对吧？</p>
<p>字节（byte）是计算机中用来表示存储容量的一个计量单位，通常情况下，一个字节有 8 位（bit）。</p>
<p>字符（char）可以是计算机中使用的字母、数字、和符号，比如说 A 1 $ 这些。</p>
<p>通常来说，一个字母或者一个字符占用一个字节，一个汉字占用两个字节。</p>
<p><img src="\assets\note\image-20231010220752842.png" alt="image-20231010220752842"></p>
<p>具体还要看字符编码，比如说在 UTF-8 编码下，一个英文字母（不分大小写）为一个字节，一个中文汉字为三个字节；在 Unicode 编码中，一个英文字母为一个字节，一个中文汉字为两个字节。</p>
<p>明白了字节与字符的区别，再来看字节流和字符流就会轻松多了。</p>
<p>字节流用来处理二进制文件，比如说图片啊、MP3 啊、视频啊。</p>
<p>字符流用来处理文本文件，文本文件可以看作是一种特殊的二进制文件，只不过经过了编码，便于人们阅读。</p>
<p>换句话说就是，字节流可以处理一切文件，而字符流只能处理文本。</p>
<p>虽然 IO 类很多，但核心的就是 4 个抽象类：InputStream、OutputStream、Reader、Writer。（抽象大法真好）</p>
<p>虽然 IO 类的方法也很多，但核心的也就 2 个：read 和 write。</p>
<p><strong>InputStream 类</strong></p>
<ul>
<li>int read() ：读取数据</li>
<li>int read(byte b[], int off, int len) ：从第 off 位置开始读，读取 len 长度的字节，然后放入数组 b 中</li>
<li>long skip(long n) ：跳过指定个数的字节</li>
<li>int available() ：返回可读的字节数</li>
<li>void close() ：关闭流，释放资源</li>
</ul>
<p><strong>OutputStream 类</strong></p>
<ul>
<li>void write(int b) ： 写入一个字节，虽然参数是一个 int 类型，但只有低 8 位才会写入，高 24 位会舍弃（这块后面再讲）</li>
<li>void write(byte b[], int off, int len) ： 将数组 b 中的从 off 位置开始，长度为 len 的字节写入</li>
<li>void flush() ： 强制刷新，将缓冲区的数据写入</li>
<li>void close() ：关闭流</li>
</ul>
<p><strong>Reader 类</strong></p>
<ul>
<li>int read() ：读取单个字符</li>
<li>int read(char cbuf[], int off, int len) ：从第 off 位置开始读，读取 len 长度的字符，然后放入数组 b 中</li>
<li>long skip(long n) ：跳过指定个数的字符</li>
<li>int ready() ：是否可以读了</li>
<li>void close() ：关闭流，释放资源</li>
</ul>
<p><strong>Writer 类</strong></p>
<ul>
<li>void write(int c) ： 写入一个字符</li>
<li>void write( char cbuf[], int off, int len) ： 将数组 cbuf 中的从 off 位置开始，长度为 len 的字符写入</li>
<li>void flush() ： 强制刷新，将缓冲区的数据写入</li>
<li>void close() ：关闭流</li>
</ul>
<p>理解了上面这些方法，基本上 IO 的灵魂也就全部掌握了。</p>
<p>字节流和字符流的区别：</p>
<ul>
<li>字节流一般用来处理图像、视频、音频、PPT、Word等类型的文件。字符流一般用于处理纯文本类型的文件，如TXT文件等，但不能处理图像视频等非文本文件。用一句话说就是：字节流可以处理一切文件，而字符流只能处理纯文本文件。</li>
<li>字节流本身没有缓冲区，缓冲字节流相对于字节流，效率提升非常高。而字符流本身就带有缓冲区，缓冲字符流相对于字符流效率提升就不是那么大了。</li>
</ul>
<p>以写文件为例，我们查看字符流的源码，发现确实有利用到缓冲区：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 声明一个 char 类型的数组，用于写入输出流</span><br><span class="line">private char[] writeBuffer;</span><br><span class="line">// 定义 writeBuffer 数组的大小，必须 &gt;= 1</span><br><span class="line">private static final int WRITE_BUFFER_SIZE = 1024;</span><br><span class="line">// 写入给定字符串中的一部分到输出流中</span><br><span class="line">public void write(String str, int off, int len) throws IOException &#123;</span><br><span class="line">    // 使用 synchronized 关键字同步代码块，确保线程安全</span><br><span class="line">    synchronized (lock) &#123;</span><br><span class="line">        char cbuf[];</span><br><span class="line">        // 如果 len &lt;= WRITE_BUFFER_SIZE，则使用 writeBuffer 数组进行写入</span><br><span class="line">        if (len &lt;= WRITE_BUFFER_SIZE) &#123;</span><br><span class="line">            // 如果 writeBuffer 为 null，则创建一个大小为 WRITE_BUFFER_SIZE 的新 char 数组</span><br><span class="line">            if (writeBuffer == null) &#123;</span><br><span class="line">                writeBuffer = new char[WRITE_BUFFER_SIZE];</span><br><span class="line">            &#125;</span><br><span class="line">            cbuf = writeBuffer;</span><br><span class="line">        &#125; else &#123;    // 如果 len &gt; WRITE_BUFFER_SIZE，则不永久分配非常大的缓冲区</span><br><span class="line">            // 创建一个大小为 len 的新 char 数组</span><br><span class="line">            cbuf = new char[len];</span><br><span class="line">        &#125;</span><br><span class="line">        // 将 str 中的一部分（从 off 开始，长度为 len）拷贝到 cbuf 数组中</span><br><span class="line">        str.getChars(off, (off + len), cbuf, 0);</span><br><span class="line">        // 将 cbuf 数组中的数据写入输出流中</span><br><span class="line">        write(cbuf, 0, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码是 Java IO 类库中的 OutputStreamWriter 类的 write 方法，可以看到缓冲区的大小是 1024 个 char。</p>
<p>我们再以文件的字符流和字节流来做一下对比，代码差别很小。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 字节流</span><br><span class="line">try (FileInputStream fis = new FileInputStream(&quot;input.txt&quot;);</span><br><span class="line">     FileOutputStream fos = new FileOutputStream(&quot;output.txt&quot;)) &#123;</span><br><span class="line">    byte[] buffer = new byte[1024];</span><br><span class="line">    int len;</span><br><span class="line">    while ((len = fis.read(buffer)) != -1) &#123;</span><br><span class="line">        fos.write(buffer, 0, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">// 字符流</span><br><span class="line">try (FileReader fr = new FileReader(&quot;input.txt&quot;);</span><br><span class="line">     FileWriter fw = new FileWriter(&quot;output.txt&quot;)) &#123;</span><br><span class="line">    char[] buffer = new char[1024];</span><br><span class="line">    int len;</span><br><span class="line">    while ((len = fr.read(buffer)) != -1) &#123;</span><br><span class="line">        fw.write(buffer, 0, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>02、操作对象划分 </strong></p>
<p>小二，你细想一下，IO IO，不就是输入输出（Input/Output）嘛：</p>
<ul>
<li>Input：将外部的数据读入内存，比如说把文件从硬盘读取到内存，从网络读取数据到内存等等</li>
<li>Output：将内存中的数据写入到外部，比如说把数据从内存写入到文件，把数据从内存输出到网络等等。</li>
</ul>
<p>所有的程序，在执行的时候，都是在内存上进行的，一旦关机，内存中的数据就没了，那如果想要持久化，就需要把内存中的数据输出到外部，比如说文件。</p>
<p>文件操作算是 IO 中最典型的操作了，也是最频繁的操作。那其实你可以换个角度来思考，比如说按照 IO 的操作对象来思考，IO 就可以分类为：文件、数组、管道、基本数据类型、缓冲、打印、对象序列化/反序列化，以及转换等。</p>
<p><img src="\assets\note\image-20231010221438501.png" alt="image-20231010221438501"></p>
<p><strong>1）文件 </strong></p>
<p>文件流也就是直接操作文件的流，可以细分为字节流（FileInputStream 和 FileOuputStream）和字符流（FileReader 和 FileWriter）。</p>
<p>FileInputStream 的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 声明一个 int 类型的变量 b，用于存储读取到的字节</span><br><span class="line">int b;</span><br><span class="line">// 创建一个 FileInputStream 对象，用于读取文件 fis.txt 中的数据</span><br><span class="line">FileInputStream fis1 = new FileInputStream(&quot;fis.txt&quot;);</span><br><span class="line">// 循环读取文件中的数据</span><br><span class="line">while ((b = fis1.read()) != -1) &#123;</span><br><span class="line">    // 将读取到的字节转换为对应的 ASCII 字符，并输出到控制台</span><br><span class="line">    System.out.println((char)b);</span><br><span class="line">&#125;</span><br><span class="line">// 关闭 FileInputStream 对象，释放资源</span><br><span class="line">fis1.close();</span><br></pre></td></tr></table></figure>
<p>FileOutputStream 的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 FileOutputStream 对象，用于写入数据到文件 fos.txt 中</span><br><span class="line">FileOutputStream fos = new FileOutputStream(&quot;fos.txt&quot;);</span><br><span class="line">// 向文件中写入数据，这里写入的是字符串 &quot;沉默王二&quot; 对应的字节数组</span><br><span class="line">fos.write(&quot;沉默王二&quot;.getBytes());</span><br><span class="line">// 关闭 FileOutputStream 对象，释放资源</span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure>
<p>FileReader 的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 声明一个 int 类型的变量 b，用于存储读取到的字符</span><br><span class="line">int b = 0;</span><br><span class="line">// 创建一个 FileReader 对象，用于读取文件 read.txt 中的数据</span><br><span class="line">FileReader fileReader = new FileReader(&quot;read.txt&quot;);</span><br><span class="line">// 循环读取文件中的数据</span><br><span class="line">while ((b = fileReader.read()) != -1) &#123;</span><br><span class="line">    // 将读取到的字符强制转换为 char 类型，并输出到控制台</span><br><span class="line">    System.out.println((char)b);</span><br><span class="line">&#125;</span><br><span class="line">// 关闭 FileReader 对象，释放资源</span><br><span class="line">fileReader.close();</span><br></pre></td></tr></table></figure>
<p>FileWriter 的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 FileWriter 对象，用于写入数据到文件 fw.txt 中</span><br><span class="line">FileWriter fileWriter = new FileWriter(&quot;fw.txt&quot;);</span><br><span class="line">// 将字符串 &quot;沉默王二&quot; 转换为字符数组</span><br><span class="line">char[] chars = &quot;沉默王二&quot;.toCharArray();</span><br><span class="line">// 向文件中写入数据，这里写入的是 chars 数组中的所有字符</span><br><span class="line">fileWriter.write(chars, 0, chars.length);</span><br><span class="line">// 关闭 FileWriter 对象，释放资源</span><br><span class="line">fileWriter.close();</span><br></pre></td></tr></table></figure>
<p>文件流还可以用于创建、删除、重命名文件等操作。FileOutputStream 和 FileWriter 构造函数的第二个参数可以指定是否追加数据到文件末尾。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 创建文件</span><br><span class="line">File file = new File(&quot;test.txt&quot;);</span><br><span class="line">if (file.createNewFile()) &#123;</span><br><span class="line">    System.out.println(&quot;文件创建成功&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    System.out.println(&quot;文件已存在&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// 删除文件</span><br><span class="line">if (file.delete()) &#123;</span><br><span class="line">    System.out.println(&quot;文件删除成功&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    System.out.println(&quot;文件删除失败&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// 重命名文件</span><br><span class="line">File oldFile = new File(&quot;old.txt&quot;);</span><br><span class="line">File newFile = new File(&quot;new.txt&quot;);</span><br><span class="line">if (oldFile.renameTo(newFile)) &#123;</span><br><span class="line">    System.out.println(&quot;文件重命名成功&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    System.out.println(&quot;文件重命名失败&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当掌握了文件的输入输出，其他的自然也就掌握了，都大差不差。</p>
<p><strong>2）数组（内存）</strong></p>
<p>通常来说，针对文件的读写操作，使用文件流配合缓冲流就够用了，但为了提升效率，频繁地读写文件并不是太好，那么就出现了数组流，有时候也称为内存流。</p>
<p>ByteArrayInputStream 的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 ByteArrayInputStream 对象，用于从字节数组中读取数据</span><br><span class="line">InputStream is = new BufferedInputStream(</span><br><span class="line">        new ByteArrayInputStream(</span><br><span class="line">                &quot;沉默王二&quot;.getBytes(StandardCharsets.UTF_8)));</span><br><span class="line">// 定义一个字节数组用于存储读取到的数据</span><br><span class="line">byte[] flush = new byte[1024];</span><br><span class="line">// 定义一个变量用于存储每次读取到的字节数</span><br><span class="line">int len = 0;</span><br><span class="line">// 循环读取字节数组中的数据，并输出到控制台</span><br><span class="line">while (-1 != (len = is.read(flush))) &#123;</span><br><span class="line">    // 将读取到的字节转换为对应的字符串，并输出到控制台</span><br><span class="line">    System.out.println(new String(flush, 0, len));</span><br><span class="line">&#125;</span><br><span class="line">// 关闭输入流，释放资源</span><br><span class="line">is.close();</span><br></pre></td></tr></table></figure>
<p>ByteArrayOutputStream 的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 ByteArrayOutputStream 对象，用于写入数据到内存缓冲区中</span><br><span class="line">ByteArrayOutputStream bos = new ByteArrayOutputStream();</span><br><span class="line">// 定义一个字节数组用于存储要写入内存缓冲区中的数据</span><br><span class="line">byte[] info = &quot;沉默王二&quot;.getBytes();</span><br><span class="line">// 向内存缓冲区中写入数据，这里写入的是 info 数组中的所有字节</span><br><span class="line">bos.write(info, 0, info.length);</span><br><span class="line">// 将内存缓冲区中的数据转换为字节数组</span><br><span class="line">byte[] dest = bos.toByteArray();</span><br><span class="line">// 关闭 ByteArrayOutputStream 对象，释放资源</span><br><span class="line">bos.close();</span><br></pre></td></tr></table></figure>
<p>数组流可以用于在内存中读写数据，比如将数据存储在字节数组中进行压缩、加密、序列化等操作。它的优点是不需要创建临时文件，可以提高程序的效率。但是，数组流也有缺点，它只能存储有限的数据量，如果存储的数据量过大，会导致内存溢出。</p>
<p><strong>3）管道 </strong></p>
<p>Java 中的管道和 Unix/Linux 中的管道不同，在 Unix/Linux 中，不同的进程之间可以通过管道来通信，但 Java 中，通信的双方必须在同一个进程中，也就是在同一个 JVM 中，管道为线程之间的通信提供了通信能力。</p>
<p>一个线程通过 PipedOutputStream 写入的数据可以被另外一个线程通过相关联的 PipedInputStream 读取出来。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 PipedOutputStream 对象和一个 PipedInputStream 对象</span><br><span class="line">final PipedOutputStream pipedOutputStream = new PipedOutputStream();</span><br><span class="line">final PipedInputStream pipedInputStream = new PipedInputStream(pipedOutputStream);</span><br><span class="line">// 创建一个线程，向 PipedOutputStream 中写入数据</span><br><span class="line">Thread thread1 = new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 将字符串 &quot;沉默王二&quot; 转换为字节数组，并写入到 PipedOutputStream 中</span><br><span class="line">            pipedOutputStream.write(&quot;沉默王二&quot;.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">            // 关闭 PipedOutputStream，释放资源</span><br><span class="line">            pipedOutputStream.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">// 创建一个线程，从 PipedInputStream 中读取数据并输出到控制台</span><br><span class="line">Thread thread2 = new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 定义一个字节数组用于存储读取到的数据</span><br><span class="line">            byte[] flush = new byte[1024];</span><br><span class="line">            // 定义一个变量用于存储每次读取到的字节数</span><br><span class="line">            int len = 0;</span><br><span class="line">            // 循环读取字节数组中的数据，并输出到控制台</span><br><span class="line">            while (-1 != (len = pipedInputStream.read(flush))) &#123;</span><br><span class="line">                // 将读取到的字节转换为对应的字符串，并输出到控制台</span><br><span class="line">                System.out.println(new String(flush, 0, len));</span><br><span class="line">            &#125;</span><br><span class="line">            // 关闭 PipedInputStream，释放资源</span><br><span class="line">            pipedInputStream.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">// 启动线程1和线程2</span><br><span class="line">thread1.start();</span><br><span class="line">thread2.start();</span><br></pre></td></tr></table></figure>
<p>使用管道流可以实现不同线程之间的数据传输，可以用于线程间的通信、数据的传递等。但是，管道流也有一些局限性，比如只能在同一个 JVM 中的线程之间使用，不能跨越不同的 JVM 进程。</p>
<p><strong>4）基本数据类型 </strong></p>
<p>基本数据类型输入输出流是一个字节流，该流不仅可以读写字节和字符，还可以读写基本数据类型。</p>
<p>DataInputStream 提供了一系列可以读基本数据类型的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 DataInputStream 对象，用于从文件中读取数据</span><br><span class="line">DataInputStream dis = new DataInputStream(new FileInputStream(&quot;das.txt&quot;));</span><br><span class="line">// 读取一个字节，将其转换为 byte 类型</span><br><span class="line">byte b = dis.readByte();</span><br><span class="line">// 读取两个字节，将其转换为 short 类型</span><br><span class="line">short s = dis.readShort();</span><br><span class="line">// 读取四个字节，将其转换为 int 类型</span><br><span class="line">int i = dis.readInt();</span><br><span class="line">// 读取八个字节，将其转换为 long 类型</span><br><span class="line">long l = dis.readLong();</span><br><span class="line">// 读取四个字节，将其转换为 float 类型</span><br><span class="line">float f = dis.readFloat();</span><br><span class="line">// 读取八个字节，将其转换为 double 类型</span><br><span class="line">double d = dis.readDouble();</span><br><span class="line">// 读取一个字节，将其转换为 boolean 类型</span><br><span class="line">boolean bb = dis.readBoolean();</span><br><span class="line">// 读取两个字节，将其转换为 char 类型</span><br><span class="line">char ch = dis.readChar();</span><br><span class="line">// 关闭 DataInputStream，释放资源</span><br><span class="line">dis.close();</span><br></pre></td></tr></table></figure>
<p>DataOutputStream 提供了一系列可以写基本数据类型的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 DataOutputStream 对象，用于将数据写入到文件中</span><br><span class="line">DataOutputStream das = new DataOutputStream(new FileOutputStream(&quot;das.txt&quot;));</span><br><span class="line">// 将一个 byte 类型的数据写入到文件中</span><br><span class="line">das.writeByte(10);</span><br><span class="line">// 将一个 short 类型的数据写入到文件中</span><br><span class="line">das.writeShort(100);</span><br><span class="line">// 将一个 int 类型的数据写入到文件中</span><br><span class="line">das.writeInt(1000);</span><br><span class="line">// 将一个 long 类型的数据写入到文件中</span><br><span class="line">das.writeLong(10000L);</span><br><span class="line">// 将一个 float 类型的数据写入到文件中</span><br><span class="line">das.writeFloat(12.34F);</span><br><span class="line">// 将一个 double 类型的数据写入到文件中</span><br><span class="line">das.writeDouble(12.56);</span><br><span class="line">// 将一个 boolean 类型的数据写入到文件中</span><br><span class="line">das.writeBoolean(true);</span><br><span class="line">// 将一个 char 类型的数据写入到文件中</span><br><span class="line">das.writeChar(&#x27;A&#x27;);</span><br><span class="line">// 关闭 DataOutputStream，释放资源</span><br><span class="line">das.close();</span><br></pre></td></tr></table></figure>
<p>除了 DataInputStream 和 DataOutputStream，Java IO 还提供了其他一些读写基本数据类型和字符串的流类，包括 ObjectInputStream 和 ObjectOutputStream（用于读写对象）。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    try (ObjectOutputStream oos = new ObjectOutputStream(new </span><br><span class="line">FileOutputStream(&quot;person.dat&quot;))) &#123;</span><br><span class="line">        Person p = new Person(&quot;张三&quot;, 20);</span><br><span class="line">        oos.writeObject(p);</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    try (ObjectInputStream ois = new ObjectInputStream(new </span><br><span class="line">FileInputStream(&quot;person.dat&quot;))) &#123;</span><br><span class="line">        Person p = (Person) ois.readObject();</span><br><span class="line">        System.out.println(p);</span><br><span class="line">    &#125; catch (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码创建了一个 Person 对象，将其写入文件中，然后从文件中读取该对象，并打印在控制台上。</p>
<p><strong>5）缓冲 </strong></p>
<p>CPU 很快，它比内存快 100 倍，比磁盘快百万倍。那也就意味着，程序和内存交互会很快，和硬盘交互相对就很慢，这样就会导致性能问题。</p>
<p>为了减少程序和硬盘的交互，提升程序的效率，就引入了缓冲流，也就是类名前缀带有 Buffer 的那些，比如说 BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter。</p>
<p><img src="\assets\note\image-20231010223429527.png" alt="image-20231010223429527"></p>
<p>缓冲流在内存中设置了一个缓冲区，只有缓冲区存储了足够多的带操作的数据后，才会和内存或者硬盘进行交互。简单来说，就是一次多读/写点，少读/写几次，这样程序的性能就会提高。</p>
<p>以下是一个使用 BufferedInputStream 读取文件的示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 BufferedInputStream 对象，用于从文件中读取数据</span><br><span class="line">BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;data.txt&quot;));</span><br><span class="line">// 创建一个字节数组，作为缓存区</span><br><span class="line">byte[] buffer = new byte[1024];</span><br><span class="line">// 读取文件中的数据，并将其存储到缓存区中</span><br><span class="line">int bytesRead;</span><br><span class="line">while ((bytesRead = bis.read(buffer)) != -1) &#123;</span><br><span class="line">    // 对缓存区中的数据进行处理</span><br><span class="line">    // 这里只是简单地将读取到的字节数组转换为字符串并打印出来</span><br><span class="line">    System.out.println(new String(buffer, 0, bytesRead));</span><br><span class="line">&#125;</span><br><span class="line">// 关闭 BufferedInputStream，释放资源</span><br><span class="line">bis.close();</span><br></pre></td></tr></table></figure>
<p>上述代码中，首先创建了一个 BufferedInputStream 对象，用于从文件中读取数据。然后创建了一个字节数组作为缓存区，每次读取数据时将数据存储到缓存区中。读取数据的过程是通过 while 循环实现的，每次读取数据后对缓存区中的数据进行处理。最后关闭BufferedInputStream，释放资源。</p>
<p>以下是一个使用 BufferedOutputStream 写入文件的示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 BufferedOutputStream 对象，用于将数据写入到文件中</span><br><span class="line">BufferedOutputStream bos = new BufferedOutputStream(new </span><br><span class="line">FileOutputStream(&quot;data.txt&quot;));</span><br><span class="line">// 创建一个字节数组，作为缓存区</span><br><span class="line">byte[] buffer = new byte[1024];</span><br><span class="line">// 将数据写入到文件中</span><br><span class="line">String data = &quot;沉默王二是个大傻子!&quot;;</span><br><span class="line">buffer = data.getBytes();</span><br><span class="line">bos.write(buffer);</span><br><span class="line">// 刷新缓存区，将缓存区中的数据写入到文件中</span><br><span class="line">bos.flush();</span><br><span class="line">// 关闭 BufferedOutputStream，释放资源</span><br><span class="line">bos.close();</span><br></pre></td></tr></table></figure>
<p>上述代码中，首先创建了一个 BufferedOutputStream 对象，用于将数据写入到文件中。然后创建了一个字节数组作为缓存区，将数据写入到缓存区中。写入数据的过程是通过 write() 方法实现的，将字节数组作为参数传递给 write() 方法即可。</p>
<p>最后，通过 flush() 方法将缓存区中的数据写入到文件中。在写入数据时，由于使用了 BufferedOutputStream，数据会先被写入到缓存区中，只有在缓存区被填满或者调用了 flush() 方法时才会将缓存区中的数据写入到文件中。</p>
<p>以下是一个使用 BufferedReader 读取文件的示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 BufferedReader 对象，用于从文件中读取数据</span><br><span class="line">BufferedReader br = new BufferedReader(new FileReader(&quot;data.txt&quot;));</span><br><span class="line">// 读取文件中的数据，并将其存储到字符串中</span><br><span class="line">String line;</span><br><span class="line">while ((line = br.readLine()) != null) &#123;</span><br><span class="line">    // 对读取到的数据进行处理</span><br><span class="line">    // 这里只是简单地将读取到的每一行字符串打印出来</span><br><span class="line">    System.out.println(line);</span><br><span class="line">&#125;</span><br><span class="line">// 关闭 BufferedReader，释放资源</span><br><span class="line">br.close();</span><br></pre></td></tr></table></figure>
<p>上述代码中，首先创建了一个 BufferedReader 对象，用于从文件中读取数据。然后使用 readLine() 方法读取文件中的数据，每次读取一行数据并将其存储到一个字符串中。读取数据的过程是通过 while 循环实现的。</p>
<p>以下是一个使用 BufferedWriter 写入文件的示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 BufferedWriter 对象，用于将数据写入到文件中</span><br><span class="line">BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;data.txt&quot;));</span><br><span class="line">// 将数据写入到文件中</span><br><span class="line">String data = &quot;沉默王二，真帅气&quot;;</span><br><span class="line">bw.write(data);</span><br><span class="line">// 刷新缓存区，将缓存区中的数据写入到文件中</span><br><span class="line">bw.flush();</span><br><span class="line">// 关闭 BufferedWriter，释放资源</span><br><span class="line">bw.close();</span><br></pre></td></tr></table></figure>
<p>上述代码中，首先创建了一个 BufferedWriter 对象，用于将数据写入到文件中。然后使用 write() 方法将数据写入到缓存区中，写入数据的过程和使用 FileWriter 类似。需要注意的是，使用 BufferedWriter 写入数据时，数据会先被写入到缓存区中，只有在缓存区被填满或者调用了 flush() 方法时才会将缓存区中的数据写入到文件中。</p>
<p>最后，通过 flush() 方法将缓存区中的数据写入到文件中，并通过 close() 方法关闭 BufferedWriter，释放资源。</p>
<p>使用缓冲流可以提高读写效率，减少了频繁的读写磁盘或网络的次数，从而提高了程序的性能。但是，在使用缓冲流时需要注意缓冲区的大小和清空缓冲区的时机，以避免数据丢失或不完整的问题。</p>
<p><strong>6）打印 </strong></p>
<p>Java 的打印流是一组用于打印输出数据的类，包括 PrintStream 和 PrintWriter 两个类。</p>
<p>恐怕 Java 程序员一生当中最常用的就是打印流了： System.out 其实返回的就是一个 PrintStream 对象，可以用来打印各式各样的对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;沉默王二是真的二！&quot;);</span><br></pre></td></tr></table></figure>
<p>PrintStream 最终输出的是字节数据，而 PrintWriter 则是扩展了 Writer 接口，所以它的 print()/println() 方法最终输出的是字符数据。使用上几乎和 PrintStream 一模一样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StringWriter buffer = new StringWriter();</span><br><span class="line">try (PrintWriter pw = new PrintWriter(buffer)) &#123;</span><br><span class="line">    pw.println(&quot;沉默王二&quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(buffer.toString());</span><br></pre></td></tr></table></figure>
<p><strong>7）对象序列化/反序列化</strong> </p>
<p>序列化本质上是将一个 Java 对象转成字节数组，然后可以将其保存到文件中，或者通过网络传输到远程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 ByteArrayOutputStream 对象 buffer，用于存储数据</span><br><span class="line">ByteArrayOutputStream buffer = new ByteArrayOutputStream();</span><br><span class="line">// 使用 try-with-resources 语句创建一个 ObjectOutputStream 对象 output，并将其与 buffer </span><br><span class="line">关联</span><br><span class="line">try (ObjectOutputStream output = new ObjectOutputStream(buffer)) &#123;</span><br><span class="line">    </span><br><span class="line">    // 使用 writeUTF() 方法将字符串 &quot;沉默王二&quot; 写入到缓冲区中</span><br><span class="line">    output.writeUTF(&quot;沉默王二&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// 使用 toByteArray() 方法将缓冲区中的数据转换成字节数组，并输出到控制台</span><br><span class="line">System.out.println(Arrays.toString(buffer.toByteArray()));</span><br></pre></td></tr></table></figure>
<p>与其对应的，有序列化，就有反序列化，也就是再将字节数组转成 Java 对象的过程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">try (ObjectInputStream input = new ObjectInputStream(new FileInputStream(</span><br><span class="line">        new File(&quot;Person.txt&quot;)))) &#123;</span><br><span class="line">    String s = input.readUTF();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码主要使用了 Java 的 ByteArrayOutputStream 和 ObjectOutputStream 类，将字符串 “沉默王二” 写入到一个字节数组缓冲区中，并将缓冲区中的数据转换成字节数组输出到控制台。</p>
<p>具体的执行过程如下：</p>
<ul>
<li>创建一个 ByteArrayOutputStream 对象 buffer，用于存储数据。</li>
<li>使用 try-with-resources 语句创建一个 ObjectOutputStream 对象 output，并将其与 buffer 关联。</li>
<li>使用 writeUTF() 方法将字符串 “沉默王二” 写入到缓冲区中。</li>
<li>当 try-with-resources 语句执行完毕时，会自动调用 output 的 close() 方法关闭输出流，释放资源。</li>
<li>使用 toByteArray() 方法将缓冲区中的数据转换成字节数组。</li>
<li>使用 Arrays.toString() 方法将字节数组转换成字符串，并输出到控制台。</li>
</ul>
<p><strong>8）转换 </strong></p>
<p>InputStreamReader 是从字节流到字符流的桥连接，它使用指定的字符集读取字节并将它们解码为字符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 InputStreamReader 对象 isr，使用 FileInputStream 对象读取文件 demo.txt 的内容并</span><br><span class="line">将其转换为字符流</span><br><span class="line">InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;demo.txt&quot;));</span><br><span class="line">// 创建一个字符数组 cha，用于存储读取的字符数据，其中 1024 表示数组的长度</span><br><span class="line">char[] cha = new char[1024];</span><br><span class="line">// 使用 read() 方法读取 isr 中的数据，并将读取的字符数据存储到 cha 数组中，返回值 len 表示读取的</span><br><span class="line">字符数</span><br><span class="line">int len = isr.read(cha);</span><br><span class="line">// 将 cha 数组中从下标 0 开始、长度为 len 的部分转换成字符串，并输出到控制台</span><br><span class="line">System.out.println(new String(cha, 0, len));</span><br><span class="line">// 关闭 InputStreamReader 对象 isr，释放资源</span><br><span class="line">isr.close();</span><br></pre></td></tr></table></figure>
<p>这段代码主要使用了 Java 的 InputStreamReader 和 FileInputStream 类，从文件 demo.txt 中读取数据并将其转换为字符流，然后将读取的字符数据存储到一个字符数组中，并输出转换成字符串后的结果到控制台。</p>
<p>OutputStreamWriter 将一个字符流的输出对象变为字节流的输出对象，是字符流通向字节流的桥梁。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 File 对象 f，表示文件 test.txt</span><br><span class="line">File f = new File(&quot;test.txt&quot;);</span><br><span class="line">// 创建一个 OutputStreamWriter 对象 out，使用 FileOutputStream 对象将数据写入到文件 f 中，并</span><br><span class="line">将字节流转换成字符流</span><br><span class="line">Writer out = new OutputStreamWriter(new FileOutputStream(f));</span><br><span class="line">// 使用 write() 方法将字符串 &quot;沉默王二!!&quot; 写入到文件 f 中</span><br><span class="line">out.write(&quot;沉默王二!!&quot;);</span><br><span class="line">// 关闭 Writer 对象 out，释放资源</span><br><span class="line">out.close();</span><br></pre></td></tr></table></figure>
<p>使用转换流可以方便地在字节流和字符流之间进行转换。在进行文本文件读写时，通常使用字符流进行操作，而在进行网络传输或与设备进行通信时，通常使用字节流进行操作。</p>
<p>另外，在使用转换流时需要注意字符编码的问题。如果不指定字符编码，则使用默认的字符编码，可能会出现乱码问题。因此，建议在使用转换流时，始终指定正确的字符编码，以避免出现乱码问题。</p>
<p>“小二啊，你看，经过我的梳理，是不是感觉 IO 也没多少东西！针对不同的场景、不同的业务，选择对应的 IO 流就可以了，用法上就是读和写。”老王一口气讲完这些，长长的舒了一口气。</p>
<p>此时此刻的小二，还沉浸在老王的滔滔不绝中。不仅感觉老王的肺活量是真的大，还感慨老王不愧是工作了十多年的“老油条”，一下子就把自己感觉头大的 IO 给梳理得很清晰了。</p>
<h2 id="5-2-文件流"><a href="#5-2-文件流" class="headerlink" title="5.2 文件流"></a>5.2 文件流</h2><p>在 IO 操作中，文件的操作相对来说是比较复杂的，但也是使用频率最高的部分，我们几乎所有的项目中几乎都躺着一个叫做 FileUtil 或者 FileUtils 的工具类。</p>
<p>java.io.File 类是专门对文件进行操作的类，注意只能对文件本身进行操作，不能对文件内容进行操作，想要操作内容，必须借助输入输出流。</p>
<p>File 类是文件和目录的抽象表示，主要用于文件和目录的创建、查找和删除等操作。</p>
<p>怎么理解上面两句话？其实很简单！</p>
<p>第一句是说 File 跟流无关，File 类不能对文件进行读和写，也就是输入和输出！</p>
<p>第二句是说 File 可以表示 D:\文件目录1与 D:\文件目录1\文件.txt ，前者是文件夹（Directory，或者叫目录）后者是文件(file)，File 类就是用来操作它俩的。</p>
<p><strong>File 构造方法 </strong></p>
<p>在 Java 中，一切皆是对象，File 类也不例外，不论是哪个对象都应该从该对象的构造说起，所以我们来分析分析 File类的构造方法。</p>
<p>比较常用的构造方法有三个：</p>
<p>1、 File(String pathname) ：通过给定的路径来创建新的 File 实例。</p>
<p>2、 File(String parent, String child) ：从父路径（字符串）和子路径创建新的 File 实例。</p>
<p>3、 File(File parent, String child) ：从父路径（File）和子路径名字符串创建新的 File 实例。</p>
<p>看文字描述不够生动、不够形象、不得劲？没事，通过举例马上就生动形象了，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 文件路径名</span><br><span class="line">String path = &quot;/Users/username/123.txt&quot;;</span><br><span class="line">File file1 = new File(path);</span><br><span class="line">// 文件路径名</span><br><span class="line">String path2 = &quot;/Users/username/1/2.txt&quot;;</span><br><span class="line">File file2 = new File(path2); -------------相当于/Users/username/1/2.txt</span><br><span class="line">// 通过父路径和子路径字符串</span><br><span class="line">String parent = &quot;/Users/username/aaa&quot;;</span><br><span class="line">String child = &quot;bbb.txt&quot;;</span><br><span class="line">File file3 = new File(parent, child); --------相当于/Users/username/aaa/bbb.txt</span><br><span class="line">// 通过父级File对象和子路径字符串</span><br><span class="line">File parentDir = new File(&quot;/Users/username/aaa&quot;);</span><br><span class="line">String child = &quot;bbb.txt&quot;;</span><br><span class="line">File file4 = new File(parentDir, child); --------相当于/Users/username/aaa/bbb.txt</span><br></pre></td></tr></table></figure>
<p>注意，macOS 路径使用正斜杠（ / ）作为路径分隔符，而 Windows 路径使用反斜杠（ \ ）作为路径分隔符。所以在遇到路径分隔符的时候，不要直接去写 /或者 \ 。</p>
<p>Java 中提供了一个跨平台的方法来获取路径分隔符，即使用 File.separator ，这个属性会根据操作系统自动返回正确的路径分隔符。</p>
<p>File 类的注意点：</p>
<ol>
<li>一个 File 对象代表硬盘中实际存在的一个文件或者目录。</li>
<li>File 类的构造方法不会检验这个文件或目录是否真实存在，因此无论该路径下是否存在文件或者目录，都不影响 File 对象的创建。</li>
</ol>
<p><strong>File 常用方法 </strong></p>
<p>File 的常用方法主要分为获取功能、获取绝对路径和相对路径、判断功能、创建删除功能的方法。</p>
<p><strong>1）获取功能的方法 </strong></p>
<p>1、 getAbsolutePath() ：返回此 File 的绝对路径。</p>
<p>2、 getPath() ：结果和 getAbsolutePath 一致。</p>
<p>3、 getName() ：返回文件名或目录名。</p>
<p>4、 length() ：返回文件长度，以字节为单位。</p>
<p>测试代码如下【注意测试以你自己的电脑文件夹为准】：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">File f = new File(&quot;/Users/username/aaa/bbb.java&quot;);</span><br><span class="line">System.out.println(&quot;文件绝对路径:&quot;+f.getAbsolutePath());</span><br><span class="line">System.out.println(&quot;文件构造路径:&quot;+f.getPath());</span><br><span class="line">System.out.println(&quot;文件名称:&quot;+f.getName());</span><br><span class="line">System.out.println(&quot;文件长度:&quot;+f.length()+&quot;字节&quot;);</span><br><span class="line">File f2 = new File(&quot;/Users/username/aaa&quot;);</span><br><span class="line">System.out.println(&quot;目录绝对路径:&quot;+f2.getAbsolutePath());</span><br><span class="line">System.out.println(&quot;目录构造路径:&quot;+f2.getPath());</span><br><span class="line">System.out.println(&quot;目录名称:&quot;+f2.getName());</span><br><span class="line">System.out.println(&quot;目录长度:&quot;+f2.length());</span><br></pre></td></tr></table></figure>
<p>注意： length() 表示文件的长度， File 对象表示目录的时候，返回值并无意义。</p>
<p><strong>2）绝对路径和相对路径 </strong></p>
<p>绝对路径是从文件系统的根目录开始的完整路径，它描述了一个文件或目录在文件系统中的确切位置。在 Windows 系统中，绝对路径通常以盘符（如 C:）开始，例如 “ C:\Program Files\Java\jdk1.8.0_291\bin\java.exe “。在 macOS 和 Linux 系统中，绝对路径通常以斜杠（ / ）开始，例如 “ /usr/local/bin/python3 “。</p>
<p>相对路径是相对于当前工作目录的路径，它描述了一个文件或目录与当前工作目录之间的位置关系。在 Java 中，相对路径通常是相对于当前 Java 程序所在的目录，例如 “ config/config.properties “。如果当前工作目录是 “ /Users/username/project “，那么相对路径 “ config/config.properties “ 就表示 “ /Users/username/project/config/config.properties “。</p>
<p>注意：</p>
<ul>
<li>在 Windows 操作系统中，文件系统默认是不区分大小写的，即在文件系统中，文件名和路径的大小写可以混合使用。例如，” C:\Users\username\Documents\example.txt “ 和 “ C:\Users\Username\Documents\Example.txt “ 表示的是同一个文件。但是，Windows 操作系统提供了一个区分大小写的选项，可以在格式化磁盘时选择启用，这样文件系统就会区分大小写。</li>
<li>在 macOS 和 Linux 等 Unix 系统中，文件系统默认是区分大小写的。例如，在 macOS 系统中，” /Users/username/Documents/example.txt “ 和 “ /Users/username/Documents/Example.txt “ 表示的是两个不同的文件。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 绝对路径示例</span><br><span class="line">File absoluteFile = new File(&quot;/Users/username/example/test.txt&quot;);</span><br><span class="line">System.out.println(&quot;绝对路径：&quot; + absoluteFile.getAbsolutePath());</span><br><span class="line">// 相对路径示例</span><br><span class="line">File relativeFile = new File(&quot;example/test.txt&quot;);</span><br><span class="line">System.out.println(&quot;相对路径：&quot; + relativeFile.getPath());</span><br></pre></td></tr></table></figure>
<p><strong>3）判断功能的方法 </strong></p>
<p>1、 exists() ：判断文件或目录是否存在。</p>
<p>2、 isDirectory() ：判断是否为目录。</p>
<p>3、 isFile() ：判断是否为文件。</p>
<p>方法演示，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">File file = new File(&quot;/Users/username/example&quot;);</span><br><span class="line">// 判断文件或目录是否存在</span><br><span class="line">if (file.exists()) &#123;</span><br><span class="line">    System.out.println(&quot;文件或目录存在&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    System.out.println(&quot;文件或目录不存在&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// 判断是否是目录</span><br><span class="line">if (file.isDirectory()) &#123;</span><br><span class="line">    System.out.println(&quot;是目录&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    System.out.println(&quot;不是目录&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// 判断是否是文件</span><br><span class="line">if (file.isFile()) &#123;</span><br><span class="line">    System.out.println(&quot;是文件&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    System.out.println(&quot;不是文件&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4）创建、删除功能的方法 </strong></p>
<ul>
<li>createNewFile() ：文件不存在，创建一个新的空文件并返回 true ，文件存在，不创建文件并返回false 。</li>
<li>delete() ：删除文件或目录。如果是目录，只有目录为空才能删除。</li>
<li>mkdir() ：只能创建一级目录，如果父目录不存在，则创建失败。返回 true 表示创建成功，返回 false 表示创建失败。</li>
<li>mkdirs() ：可以创建多级目录，如果父目录不存在，则会一并创建。返回 true 表示创建成功，返回 false 表示创建失败或目录已经存在。</li>
</ul>
<p>开发中一般用 mkdirs() ;</p>
<p>方法测试，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 创建文件</span><br><span class="line">File file = new File(&quot;/Users/username/example/test.txt&quot;);</span><br><span class="line">if (file.createNewFile()) &#123;</span><br><span class="line">    System.out.println(&quot;创建文件成功：&quot; + file.getAbsolutePath());</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    System.out.println(&quot;创建文件失败：&quot; + file.getAbsolutePath());</span><br><span class="line">&#125;</span><br><span class="line">// 删除文件</span><br><span class="line">if (file.delete()) &#123;</span><br><span class="line">    System.out.println(&quot;删除文件成功：&quot; + file.getAbsolutePath());</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    System.out.println(&quot;删除文件失败：&quot; + file.getAbsolutePath());</span><br><span class="line">&#125;</span><br><span class="line">// 创建多级目录</span><br><span class="line">File directory = new File(&quot;/Users/username/example/subdir1/subdir2&quot;);</span><br><span class="line">if (directory.mkdirs()) &#123;</span><br><span class="line">    System.out.println(&quot;创建目录成功：&quot; + directory.getAbsolutePath());</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    System.out.println(&quot;创建目录失败：&quot; + directory.getAbsolutePath());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>5）目录的遍历 </strong></p>
<ul>
<li>String[] list() ：返回一个 String 数组，表示该 File 目录中的所有子文件或目录。</li>
<li>File[] listFiles() ：返回一个 File 数组，表示该 File 目录中的所有的子文件或目录。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">File directory = new File(&quot;/Users/itwanger/Documents/Github/paicoding&quot;);</span><br><span class="line">// 列出目录下的文件名</span><br><span class="line">String[] files = directory.list();</span><br><span class="line">System.out.println(&quot;目录下的文件名：&quot;);</span><br><span class="line">for (String file : files) &#123;</span><br><span class="line">    System.out.println(file);</span><br><span class="line">&#125;</span><br><span class="line">// 列出目录下的文件和子目录</span><br><span class="line">File[] filesAndDirs = directory.listFiles();</span><br><span class="line">System.out.println(&quot;目录下的文件和子目录：&quot;);</span><br><span class="line">for (File fileOrDir : filesAndDirs) &#123;</span><br><span class="line">    if (fileOrDir.isFile()) &#123;</span><br><span class="line">        System.out.println(&quot;文件：&quot; + fileOrDir.getName());</span><br><span class="line">    &#125; else if (fileOrDir.isDirectory()) &#123;</span><br><span class="line">        System.out.println(&quot;目录：&quot; + fileOrDir.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>listFiles在获取指定目录下的文件或者子目录时必须满足下面两个条件：</p>
<ol>
<li>指定的目录必须存在</li>
<li>指定的必须是目录。否则容易引发 NullPointerException 异常</li>
</ol>
<p><strong>6）递归遍历 </strong></p>
<p>不说啥了，直接上代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    File directory = new File(&quot;/Users/itwanger/Documents/Github/paicoding&quot;);</span><br><span class="line">    // 递归遍历目录下的文件和子目录</span><br><span class="line">    traverseDirectory(directory);</span><br><span class="line">&#125;</span><br><span class="line">public static void traverseDirectory(File directory) &#123;</span><br><span class="line">    // 列出目录下的所有文件和子目录</span><br><span class="line">    File[] filesAndDirs = directory.listFiles();</span><br><span class="line">    // 遍历每个文件和子目录</span><br><span class="line">    for (File fileOrDir : filesAndDirs) &#123;</span><br><span class="line">        if (fileOrDir.isFile()) &#123;</span><br><span class="line">            // 如果是文件，输出文件名</span><br><span class="line">            System.out.println(&quot;文件：&quot; + fileOrDir.getName());</span><br><span class="line">        &#125; else if (fileOrDir.isDirectory()) &#123;</span><br><span class="line">            // 如果是目录，递归遍历子目录</span><br><span class="line">            System.out.println(&quot;目录：&quot; + fileOrDir.getName());</span><br><span class="line">            traverseDirectory(fileOrDir);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>RandomAccessFile </strong></p>
<p>RandomAccessFile 是 Java 中一个非常特殊的类，它既可以用来读取文件，也可以用来写入文件。与其他 IO 类（如 FileInputStream 和 FileOutputStream）不同，RandomAccessFile 允许您跳转到文件的任何位置，从那里开始读取或写入。这使得它特别适用于需要在文件中随机访问数据的场景，如数据库系统。</p>
<p>下面是一个使用 RandomAccessFile 的示例，包括写入和读取文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.RandomAccessFile;</span><br><span class="line">public class RandomAccessFileDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String filePath = &quot;logs/javabetter/itwanger.txt&quot;;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 使用 RandomAccessFile 写入文件</span><br><span class="line">            writeToFile(filePath, &quot;Hello, 沉默王二!&quot;);</span><br><span class="line">            // 使用 RandomAccessFile 读取文件</span><br><span class="line">            String content = readFromFile(filePath);</span><br><span class="line">            System.out.println(&quot;文件内容: &quot; + content);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private static void writeToFile(String filePath, String content) throws IOException &#123;</span><br><span class="line">        try (RandomAccessFile randomAccessFile = new RandomAccessFile(filePath, &quot;rw&quot;)) &#123;</span><br><span class="line">            // 将文件指针移动到文件末尾（在此处追加内容）</span><br><span class="line">            randomAccessFile.seek(randomAccessFile.length());</span><br><span class="line">            // 写入内容</span><br><span class="line">            randomAccessFile.writeUTF(content);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private static String readFromFile(String filePath) throws IOException &#123;</span><br><span class="line">        StringBuilder content = new StringBuilder();</span><br><span class="line">        try (RandomAccessFile randomAccessFile = new RandomAccessFile(filePath, &quot;r&quot;)) &#123;</span><br><span class="line">            // 将文件指针移动到文件开始处（从头开始读取）</span><br><span class="line">            randomAccessFile.seek(0);</span><br><span class="line">            content.append(randomAccessFile.readUTF());</span><br><span class="line">        &#125;</span><br><span class="line">        return content.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了避免中文乱码问题，我们使用 RandomAccessFile 的 writeUTF 和 readUTF 方法，它们将使用 UTF-8 编码处理字符串。大家可以运行一下这段代码，体验一下。</p>
<p><img src="\assets\note\image-20231010224921704.png" alt="image-20231010224921704"></p>
<p>接下来，会详细介绍一下 RandomAccessFile 的构造方法和常用的方法。</p>
<p><strong>构造方法 </strong></p>
<p>RandomAccessFile 主要有两个构造方法：</p>
<ul>
<li>RandomAccessFile(File file, String mode) ：使用给定的文件对象和访问模式创建一个新的 RandomAccessFile 实例。</li>
<li>RandomAccessFile(String name, String mode) ：使用给定的文件名和访问模式创建一个新的 RandomAccessFile 实例。</li>
</ul>
<p>访问模式 mode 的值可以是：</p>
<ul>
<li>“r”：以只读模式打开文件。调用结果对象的任何 write 方法都将导致 IOException。</li>
<li>“rw”：以读写模式打开文件。如果文件不存在，它将被创建。</li>
<li>“rws”：以读写模式打开文件，并要求对内容或元数据的每个更新都被立即写入到底层存储设备。这种模式是同步的，可以确保在系统崩溃时不会丢失数据。</li>
<li>“rwd”：与“rws”类似，以读写模式打开文件，但仅要求对文件内容的更新被立即写入。元数据可能会被延迟写入。</li>
</ul>
<p><strong>主要方法 </strong></p>
<ul>
<li>long getFilePointer() ：返回文件指针的当前位置。</li>
<li>long length() ：返回此文件的长度。</li>
<li>int read() ：从该文件中读取一个字节数据。</li>
<li>int read(byte[] b) ：从该文件中读取字节数据并将其存储到指定的字节数组中。</li>
<li>int read(byte[] b, int off, int len) ：从该文件中读取字节数据并将其存储到指定的字节数组中，从偏移量 off 开始，最多读取 len 个字节。</li>
<li>String readLine() ：从该文件中读取一行文本。</li>
<li>readUTF() ：从文件读取 UTF-8 编码的字符串。此方法首先读取两个字节的长度信息，然后根据这个长度读取字符串的 UTF-8 字节。最后，这些字节被转换为 Java 字符串。这意味着当你使用 readUTF 方法读取字符串时，需要确保文件中的字符串是使用 writeUTF 方法写入的，这样它们之间的长度信息和编码方式才能保持一致。</li>
<li>void seek(long pos) ：将文件指针设置到文件中的 pos 位置。</li>
<li>void write(byte[] b) ：将指定的字节数组的所有字节写入该文件。</li>
<li>void write(byte[] b, int off, int len) ：将指定字节数组的部分字节写入该文件，从偏移量 off 开始，写入 len 个字节。</li>
<li>void write(int b) ：将指定的字节写入该文件。</li>
<li>writeUTF(String str) ：将一个字符串以 UTF-8 编码写入文件。此方法首先写入两个字节的长度信息，表示字符串的 UTF-8 字节长度，然后写入 UTF-8 字节本身。因此，当你使用 writeUTF 写入字符串时，实际写入的字节数会比字符串的 UTF-8 字节长度多两个字节。这两个字节用于在读取字符串时确定正确的字符串长度。</li>
</ul>
<p>再来看一个示例，结合前面的讲解，就会彻底掌握 RandomAccessFile。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">File file = new File(&quot;logs/javabetter/itwanger.txt&quot;);</span><br><span class="line">try (RandomAccessFile raf = new RandomAccessFile(file, &quot;rw&quot;)) &#123;</span><br><span class="line">    // 写入文件</span><br><span class="line">    raf.writeUTF(&quot;Hello, 沉默王二!&quot;);</span><br><span class="line">    // 将文件指针移动到文件开头</span><br><span class="line">    raf.seek(0);</span><br><span class="line">    // 读取文件内容</span><br><span class="line">    String content = raf.readUTF();</span><br><span class="line">    System.out.println(&quot;内容: &quot; + content);</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们首先创建了一个名为 itwanger.txt 的文件对象。然后我们使用 RandomAccessFile 以读写模式打开这个文件。</p>
<p>接下来，我们使用 writeUTF 方法将字符串”Hello, 沉默王二!”写入文件。然后，我们使用 seek 方法将文件指针移动到文件开头，并使用 readUTF 方法读取文件内容。输出应该是”Hello, 沉默王二!”。</p>
<p>最后，我们使用try-with-resources语句确保 RandomAccessFile 在操作完成后被正确关闭。</p>
<p><strong>Apache FileUtils 类 </strong></p>
<p>FileUtils 类是 Apache Commons IO 库中的一个类，提供了一些更为方便的方法来操作文件或目录。</p>
<p><strong>1）复制文件或目录：</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">File srcFile = new File(&quot;path/to/src/file&quot;);</span><br><span class="line">File destFile = new File(&quot;path/to/dest/file&quot;);</span><br><span class="line">// 复制文件</span><br><span class="line">FileUtils.copyFile(srcFile, destFile);</span><br><span class="line">// 复制目录</span><br><span class="line">FileUtils.copyDirectory(srcFile, destFile);</span><br></pre></td></tr></table></figure>
<p><strong>2）删除文件或目录： </strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File file = new File(&quot;path/to/file&quot;);</span><br><span class="line">// 删除文件或目录</span><br><span class="line">FileUtils.delete(file);</span><br></pre></td></tr></table></figure>
<p>需要注意的是，如果要删除一个非空目录，需要先删除目录中的所有文件和子目录。</p>
<p><strong>3）移动文件或目录： </strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">File srcFile = new File(&quot;path/to/src/file&quot;);</span><br><span class="line">File destFile = new File(&quot;path/to/dest/file&quot;);</span><br><span class="line">// 移动文件或目录</span><br><span class="line">FileUtils.moveFile(srcFile, destFile);</span><br></pre></td></tr></table></figure>
<p><strong>4）查询文件或目录的信息： </strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">File file = new File(&quot;path/to/file&quot;);</span><br><span class="line">// 获取文件或目录的修改时间</span><br><span class="line">Date modifyTime = FileUtils.lastModified(file);</span><br><span class="line">// 获取文件或目录的大小</span><br><span class="line">long size = FileUtils.sizeOf(file);</span><br><span class="line">// 获取文件或目录的扩展名</span><br><span class="line">String extension = FileUtils.getExtension(file.getName());</span><br></pre></td></tr></table></figure>
<p><strong>Hutool FileUtil 类 </strong></p>
<p>FileUtil 类是 Hutool 工具包中的文件操作工具类，提供了一系列简单易用的文件操作方法，可以帮助 Java 开发者快速完成文件相关的操作任务。</p>
<p>FileUtil 类包含以下几类操作工具：</p>
<ul>
<li>文件操作：包括文件目录的新建、删除、复制、移动、改名等</li>
<li>文件判断：判断文件或目录是否非空，是否为目录，是否为文件等等。</li>
<li>绝对路径：针对 ClassPath 中的文件转换为绝对路径文件。</li>
<li>文件名：主文件名，扩展名的获取</li>
<li>读操作：包括 getReader、readXXX 操作</li>
<li>写操作：包括 getWriter、writeXXX 操作</li>
</ul>
<p>下面是 FileUtil 类中一些常用的方法：</p>
<p>1、copyFile：复制文件。该方法可以将指定的源文件复制到指定的目标文件中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File dest = FileUtil.file(&quot;FileUtilDemo2.java&quot;);</span><br></pre></td></tr></table></figure>
<p>2、move：移动文件或目录。该方法可以将指定的源文件或目录移动到指定的目标文件或目录中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileUtil.move(file, dest, true);</span><br></pre></td></tr></table></figure>
<p>3、del：删除文件或目录。该方法可以删除指定的文件或目录，如果指定的文件或目录不存在，则会抛出异常。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileUtil.del(file);</span><br></pre></td></tr></table></figure>
<p>4、rename：重命名文件或目录。该方法可以将指定的文件或目录重命名为指定的新名称。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileUtil.rename(file, &quot;FileUtilDemo3.java&quot;, true);</span><br></pre></td></tr></table></figure>
<p>5、readLines：从文件中读取每一行数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileUtil.readLines(file, &quot;UTF-8&quot;).forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>更多方法，可以去看一下 hutool 的源码，里面有非常多实用的方法，多看看，绝对能提升不少编程水平。</p>
<h2 id="5-3-字节流"><a href="#5-3-字节流" class="headerlink" title="5.3 字节流"></a>5.3 字节流</h2><p>我们必须得明确一点，一切文件（文本、视频、图片）的数据都是以二进制的形式存储的，传输时也是。所以，字节流可以传输任意类型的文件数据。</p>
<p><strong>字节输出流（OutputStream） </strong></p>
<p>java.io.OutputStream 是字节输出流的超类（父类），我们来看一下它定义的一些共性方法：</p>
<p>1、 close() ：关闭此输出流并释放与此流相关联的系统资源。</p>
<p>2、 flush() ：刷新此输出流并强制缓冲区的字节被写入到目的地。</p>
<p>3、 write(byte[] b) ：将 b.length 个字节从指定的字节数组写入此输出流。</p>
<p>4、 write(byte[] b, int off, int len) ：从指定的字节数组写入 len 字节到此输出流，从偏移量 off开始。 <strong>也就是说从off个字节数开始一直到len个字节结束</strong></p>
<p><strong>FileOutputStream类 </strong></p>
<p>OutputStream 有很多子类，我们从最简单的一个子类 FileOutputStream 开始。看名字就知道是文件输出流，用于将数据写入到文件。</p>
<p><strong>1）FileOutputStrea 的构造方法 </strong></p>
<p>1、使用文件名创建 FileOutputStream 对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String fileName = &quot;example.txt&quot;;</span><br><span class="line">FileOutputStream fos = new FileOutputStream(fileName);</span><br></pre></td></tr></table></figure>
<p>以上代码使用文件名 “example.txt” 创建一个 FileOutputStream 对象，将数据写入到该文件中。<strong>如果文件不存在，则创建一个新文件；如果文件已经存在，则覆盖原有文件。</strong></p>
<p>2、使用文件对象创建 FileOutputStream 对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File file = new File(&quot;example.txt&quot;);</span><br><span class="line">FileOutputStream fos = new FileOutputStream(file);</span><br></pre></td></tr></table></figure>
<p>FileOutputStream 的使用示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fos = null;</span><br><span class="line">try &#123;</span><br><span class="line">  fos = new FileOutputStream(&quot;example.txt&quot;);</span><br><span class="line">  fos.write(&quot;沉默王二&quot;.getBytes());</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">  if (fos != null) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      fos.close();</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码创建了一个 FileOutputStream 对象，将字符串 “沉默王二” 写入到 example.txt 文件中，并在最后关闭了输出流。</p>
<p><strong>2）FileOutputStream 写入字节数据 </strong></p>
<p>使用 FileOutputStream 写入字节数据主要通过 write 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">write(int b)</span><br><span class="line">write(byte[] b)</span><br><span class="line">write(byte[] b,int off,int len)  //从òff`索引开始，`len`个字节</span><br></pre></td></tr></table></figure>
<p>①、写入字节： write(int b) 方法，每次可以写入一个字节，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 使用文件名称创建流对象</span><br><span class="line">FileOutputStream fos = new FileOutputStream(&quot;fos.txt&quot;);     </span><br><span class="line">// 写出数据</span><br><span class="line">fos.write(97); // 第1个字节</span><br><span class="line">fos.write(98); // 第2个字节</span><br><span class="line">fos.write(99); // 第3个字节</span><br><span class="line">// 关闭资源</span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure>
<p>字符 a 的 ASCII 值为 97，字符 b 的ASCII 值为 98，字符 b 的ASCII 值为 99。也就是说，以上代码可以写成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 使用文件名称创建流对象</span><br><span class="line">FileOutputStream fos = new FileOutputStream(&quot;fos.txt&quot;);     </span><br><span class="line">// 写出数据</span><br><span class="line">fos.write(&#x27;a&#x27;); // 第1个字节</span><br><span class="line">fos.write(&#x27;b&#x27;); // 第2个字节</span><br><span class="line">fos.write(&#x27;c&#x27;); // 第3个字节</span><br><span class="line">// 关闭资源</span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure>
<p>当使用 write(int b) 方法写出一个字节时，参数 b 表示要写出的字节的整数值。由于一个字节只有8位，因此参数 b 的取值范围应该在 0 到 255 之间，超出这个范围的值将会被截断。例如，如果参数 b 的值为 -1，那么它会被截断为 255，如果参数 b 的值为 256，那么它会被截断为 0。</p>
<p>在将参数 b 写入输出流中时，write(int b) 方法只会将参数 b 的低8位写入，而忽略高24位。这是因为在 Java 中，整型类型（包括 byte、short、int、long）在内存中以二进制补码形式表示。当将一个整型值传递给 write(int b) 方法时，方法会将该值转换为 byte 类型，只保留二进制补码的低8位，而忽略高24位。</p>
<p>例如，如果要写出的整数为 0x12345678，它的二进制补码表示为 0001 0010 0011 0100 0101 0110 0111 1000。当使用 write(int b) 方法写出该整数时，只会将二进制补码的低8位 0111 1000 写出，而忽略高24位 0001 0010 0011 0100 0101 0110。这就是参数 b 的高24位被忽略的原因。</p>
<p>0111 1000 是一个8位的二进制数，它对应的十进制数是 120，对应的 ASCII 码字符是小写字母 “x”。在 ASCII 码表中，小写字母 “x” 的十进制 ASCII 码值为 120。因此，如果使用 write(int b) 方法写出一个字节值为 0x78（十进制为 120），那么写出的结果就是小写字母 “x”。</p>
<p>我们来验证一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fos = null;</span><br><span class="line">try &#123;</span><br><span class="line">    fos = new FileOutputStream(&quot;example.txt&quot;);</span><br><span class="line">    fos.write(120);</span><br><span class="line">    fos.write(&#x27;x&#x27;);</span><br><span class="line">    fos.write(0x12345678);</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    if (fos != null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            fos.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看一下结果：</p>
<p><img src="\assets\note\image-20231011100559469.png" alt="image-20231011100559469"></p>
<p>果然是 3 个 x。</p>
<p>②、写入字节数组： write(byte[] b) ，代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 使用文件名称创建流对象</span><br><span class="line">FileOutputStream fos = new FileOutputStream(&quot;fos.txt&quot;);     </span><br><span class="line">// 字符串转换为字节数组</span><br><span class="line">byte[] b = &quot;沉默王二有点帅&quot;.getBytes();</span><br><span class="line">// 写入字节数组数据</span><br><span class="line">fos.write(b);</span><br><span class="line">// 关闭资源</span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure>
<p>③、写入指定长度字节数组： write(byte[] b, int off, int len) ，代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 使用文件名称创建流对象</span><br><span class="line">FileOutputStream fos = new FileOutputStream(&quot;fos.txt&quot;);     </span><br><span class="line">// 字符串转换为字节数组</span><br><span class="line">byte[] b = &quot;abcde&quot;.getBytes();</span><br><span class="line">// 从索引2开始，2个字节。索引2是c，两个字节，也就是cd。</span><br><span class="line">fos.write(b,2,2);</span><br><span class="line">// 关闭资源</span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure>
<p><strong>3）FileOutputStream实现数据追加、换行 </strong></p>
<p>在上面的代码示例中，每次运行程序都会创建新的输出流对象，于是文件中的数据也会被清空。如果想保留目标文件中的数据，还能继续追加新数据，该怎么办呢？以及如何实现换行呢？</p>
<p>其实很简单。</p>
<p>我们来学习 FileOutputStream的另外两个构造方法，如下：</p>
<p>1、使用文件名和追加标志创建 FileOutputStream 对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String fileName = &quot;example.txt&quot;;</span><br><span class="line">boolean append = true;</span><br><span class="line">FileOutputStream fos = new FileOutputStream(fileName, append);</span><br></pre></td></tr></table></figure>
<p>以上代码使用文件名 “example.txt” 和追加标志创建一个 FileOutputStream 对象，将数据追加到该文件的末尾。如果文件不存在，则创建一个新文件；如果文件已经存在，则在文件末尾追加数据。</p>
<p>2、使用文件对象和追加标志创建 FileOutputStream 对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File file = new File(&quot;example.txt&quot;);</span><br><span class="line">boolean append = true;</span><br><span class="line">FileOutputStream fos = new FileOutputStream(file, append);</span><br></pre></td></tr></table></figure>
<p>以上代码使用文件对象和追加标志创建一个 FileOutputStream 对象，将数据追加到该文件的末尾。</p>
<p>这两个构造方法，第二个参数中都需要传入一个boolean类型的值， true 表示追加数据， false 表示不追加也就是清空原有数据。</p>
<p>实现数据追加代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 使用文件名称创建流对象</span><br><span class="line">FileOutputStream fos = new FileOutputStream(&quot;fos.txt&quot;,true);     </span><br><span class="line">// 字符串转换为字节数组</span><br><span class="line">byte[] b = &quot;abcde&quot;.getBytes();</span><br><span class="line">// 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。</span><br><span class="line">fos.write(b);</span><br><span class="line">// 关闭资源</span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure>
<p>多次运行代码，你会发现数据在不断地追加。</p>
<p>在 Windows 系统中，换行符号是 \r\n ，具体代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String filename = &quot;example.txt&quot;;</span><br><span class="line">FileOutputStream fos = new FileOutputStream(filename, true);  // 追加模式</span><br><span class="line">String content = &quot;沉默王二\r\n&quot;;  // 使用回车符和换行符的组合</span><br><span class="line">fos.write(content.getBytes());</span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure>
<p>在 macOS 系统中，换行符是 \n ，具体代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String filename = &quot;example.txt&quot;;</span><br><span class="line">FileOutputStream fos = new FileOutputStream(filename, true);  // 追加模式</span><br><span class="line">String content = &quot;沉默王二\n&quot;;  // 只使用换行符</span><br><span class="line">fos.write(content.getBytes());</span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure>
<p>这里再唠一唠回车符和换行符。</p>
<p>回车符（ \r ）和换行符（ \n ）是计算机中常见的控制字符，用于表示一行的结束或者换行的操作。它们在不同的操作系统和编程语言中的使用方式可能有所不同。</p>
<p>在 Windows 系统中，通常使用回车符和换行符的组合（ \r\n ）来表示一行的结束。在文本文件中，每行的末尾都会以一个回车符和一个换行符的组合结束。这是由于早期的打印机和终端设备需要回车符和换行符的组合来完成一行的结束和换行操作。在 Windows 中，文本编辑器和命令行终端等工具都支持使用回车符和换行符的组合来表示一行的结束。</p>
<p>而在 macOS 和 Linux 系统中，通常只使用换行符（ \n ）来表示一行的结束。在文本文件中，每行的末尾只有一个换行符。这是由于早期 Unix 系统中的终端设备只需要换行符来完成一行的结束和跨行操作。在 macOS 和 Linux 中，文本编辑器和终端等工具都支持使用换行符来表示一行的结束。</p>
<p>在编程语言中，通常也会使用回车符和换行符来进行字符串的操作。例如，在 Java 中，字符串中的回车符可以用 “ \r “ 来表示，换行符可以用 “ \n “ 来表示。在通过输入输出流进行文件读写时，也需要注意回车符和换行符的使用方式和操作系统的差异。</p>
<p><strong>字节输入流（InputStream） </strong></p>
<p>java.io.InputStream 是字节输入流的超类（父类），我们来看一下它的一些共性方法：</p>
<p>1、 close() ：关闭此输入流并释放与此流相关的系统资源。</p>
<p>2、 int read() ： 从输入流读取数据的下一个字节。</p>
<p>3、 read(byte[] b) ： 该方法返回的 int 值代表的是读取了多少个字节，读到几个返回几个，读取不到返回-1</p>
<p><strong>FileInputStream类 </strong></p>
<p>InputStream 有很多子类，我们从最简单的一个子类 FileInputStream 开始。看名字就知道是文件输入流，用于将数据从文件中读取数据。</p>
<p><strong>1）FileInputStream的构造方法 </strong></p>
<p>1、 FileInputStream(String name) ：创建一个 FileInputStream 对象，并打开指定名称的文件进行读取。文件名由 name 参数指定。如果文件不存在，将会抛出 FileNotFoundException 异常。</p>
<p>2、 FileInputStream(File file) ：创建一个 FileInputStream 对象，并打开指定的 File 对象表示的文件进行读取。</p>
<p>代码示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 FileInputStream 对象</span><br><span class="line">FileInputStream fis = new FileInputStream(&quot;test.txt&quot;);</span><br><span class="line">// 读取文件内容</span><br><span class="line">int data;</span><br><span class="line">while ((data = fis.read()) != -1) &#123;</span><br><span class="line">    System.out.print((char) data);</span><br><span class="line">&#125;</span><br><span class="line">// 关闭输入流</span><br><span class="line">fis.close();</span><br></pre></td></tr></table></figure>
<p><strong>2）FileInputStream读取字节数据 </strong></p>
<p>①、读取字节： read()方法会读取一个字节并返回其整数表示。如果已经到达文件的末尾，则返回 -1。如果在读取时发生错误，则会抛出 IOException 异常。</p>
<p>代码示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 FileInputStream 对象</span><br><span class="line">FileInputStream fis = new FileInputStream(&quot;test.txt&quot;);</span><br><span class="line">// 读取文件内容</span><br><span class="line">int data;</span><br><span class="line">while ((data = fis.read()) != -1) &#123;</span><br><span class="line">    System.out.print((char) data);</span><br><span class="line">&#125;</span><br><span class="line">// 关闭输入流</span><br><span class="line">fis.close();</span><br></pre></td></tr></table></figure>
<p>②、使用字节数组读取： read(byte[] b) 方法会从输入流中最多读取 b.length 个字节，并将它们存储到缓冲区数组 b 中。</p>
<p>代码示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 FileInputStream 对象</span><br><span class="line">FileInputStream fis = new FileInputStream(&quot;test.txt&quot;);</span><br><span class="line">// 读取文件内容到缓冲区</span><br><span class="line">byte[] buffer = new byte[1024];</span><br><span class="line">int count;</span><br><span class="line">while ((count = fis.read(buffer)) != -1) &#123;</span><br><span class="line">    System.out.println(new String(buffer, 0, count));</span><br><span class="line">&#125;</span><br><span class="line">// 关闭输入流</span><br><span class="line">fis.close();</span><br></pre></td></tr></table></figure>
<p><strong>3）字节流FileInputstream复制图片 </strong></p>
<p>原理很简单，就是把图片信息读入到字节输入流中，再通过字节输出流写入到文件中。</p>
<p>代码示例如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 FileInputStream 对象以读取原始图片文件</span><br><span class="line">FileInputStream fis = new FileInputStream(&quot;original.jpg&quot;);</span><br><span class="line">// 创建一个 FileOutputStream 对象以写入复制后的图片文件</span><br><span class="line">FileOutputStream fos = new FileOutputStream(&quot;copy.jpg&quot;);</span><br><span class="line">// 创建一个缓冲区数组以存储读取的数据</span><br><span class="line">byte[] buffer = new byte[1024];</span><br><span class="line">int count;</span><br><span class="line">// 读取原始图片文件并将数据写入复制后的图片文件</span><br><span class="line">while ((count = fis.read(buffer)) != -1) &#123;</span><br><span class="line">    fos.write(buffer, 0, count);</span><br><span class="line">&#125;</span><br><span class="line">// 关闭输入流和输出流</span><br><span class="line">fis.close();</span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure>
<p>上面的代码创建了一个 FileInputStream 对象以读取原始图片文件，并创建了一个 FileOutputStream 对象以写入复制后的图片文件。然后，使用 while 循环逐个读取原始图片文件中的字节，并将其写入复制后的图片文件中。最后，关闭输入流和输出流释放资源。</p>
<p><strong>小结 </strong></p>
<p>InputStream 是字节输入流的抽象类，它定义了读取字节数据的方法，如 read() 、 read(byte[] b) 、read(byte[] b, int off, int len) 等。OutputStream 是字节输出流的抽象类，它定义了写入字节数据的方法，如 write(int b) 、 write(byte[] b) 、 write(byte[] b, int off, int len) 等。这两个抽象类是字节流的基础。</p>
<p>FileInputStream 是从文件中读取字节数据的流，它继承自 InputStream。FileOutputStream 是将字节数据写入文件的流，它继承自 OutputStream。这两个类是字节流最常用的实现类之一。</p>
<h2 id="5-4-字符流"><a href="#5-4-字符流" class="headerlink" title="5.4 字符流"></a>5.4 字符流</h2><p>字符流 Reader 和 Writer 的故事要从它们的类关系图开始，来看图。</p>
<p><img src="\assets\note\image-20231011101237315.png" alt="image-20231011101237315"></p>
<p>字符流是一种用于读取和写入字符数据的输入输出流。与字节流不同，字符流以字符为单位读取和写入数据，而不是以字节为单位。常用来处理文本信息。</p>
<p>如果用字节流直接读取中文，可能会遇到乱码问题，见下例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//FileInputStream为操作文件的字符输入流</span><br><span class="line">FileInputStream inputStream = new FileInputStream(&quot;a.txt&quot;);//内容为“沉默王二是傻 X”</span><br><span class="line">int len;</span><br><span class="line">while ((len=inputStream.read())!=-1)&#123;</span><br><span class="line">    System.out.print((char)len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">运行结果：   æ²•é»•ç••äº•æ•¯å•» X</span><br></pre></td></tr></table></figure>
<p>看一下截图：</p>
<p><img src="\assets\note\image-20231011101330869.png" alt="image-20231011101330869"></p>
<p>之所以出现乱码是因为在字节流中，一个字符通常由多个字节组成，而不同的字符编码使用的字节数不同。如果我们使用了错误的字符编码，或者在读取和写入数据时没有正确处理字符编码的转换，就会导致读取出来的中文字符出现乱码。</p>
<p>例如，当我们使用默认的字符编码（见上例）读取一个包含中文字符的文本文件时，就会出现乱码。因为默认的字符编码通常是 ASCII 编码，它只能表示英文字符，而不能正确地解析中文字符。</p>
<p>那使用字节流该如何正确地读出中文呢？见下例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try (FileInputStream inputStream = new FileInputStream(&quot;a.txt&quot;)) &#123;</span><br><span class="line">    byte[] bytes = new byte[1024];</span><br><span class="line">    int len;</span><br><span class="line">    while ((len = inputStream.read(bytes)) != -1) &#123;</span><br><span class="line">        System.out.print(new String(bytes, 0, len));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么这种方式就可以呢？</p>
<p>因为我们拿 String 类进行了解码，查看 new String(byte bytes[], int offset, int length)的源码就可以发现，该构造方法有解码功能：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public String(byte bytes[], int offset, int length) &#123;</span><br><span class="line">    checkBounds(bytes, offset, length);</span><br><span class="line">    this.value = StringCoding.decode(bytes, offset, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续追看 StringCoding.decode() 方法调用的 defaultCharset() 方法，会发现默认编码是 UTF-8 ，代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static Charset defaultCharset() &#123;</span><br><span class="line">    if (defaultCharset == null) &#123;</span><br><span class="line">        synchronized (Charset.class) &#123;</span><br><span class="line">            if (cs != null)</span><br><span class="line">                defaultCharset = cs;</span><br><span class="line">            else</span><br><span class="line">                defaultCharset = forName(&quot;UTF-8&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return defaultCharset;</span><br><span class="line">&#125;</span><br><span class="line">static char[] decode(byte[] ba, int off, int len) &#123;</span><br><span class="line">    String csn = Charset.defaultCharset().name();</span><br><span class="line">    try &#123;</span><br><span class="line">        // use charset name decode() variant which provides caching.</span><br><span class="line">        return decode(csn, ba, off, len);</span><br><span class="line">    &#125; catch (UnsupportedEncodingException x) &#123;</span><br><span class="line">        warnUnsupportedCharset(csn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Java 中，常用的字符编码有 ASCII、ISO-8859-1、UTF-8、UTF-16 等。其中，ASCII 和 ISO-8859-1 只能表示部分字符，而 UTF-8 和 UTF-16 可以表示所有的 Unicode 字符，包括中文字符。</p>
<p>当我们使用 new String(byte bytes[], int offset, int length) 将字节流转换为字符串时，Java 会根据 UTF-8 的规则将每 3 个字节解码为一个中文字符，从而正确地解码出中文。</p>
<p>尽管字节流也有办法解决乱码问题，但不够直接，于是就有了字符流，专门用于处理文本文件（音频、图片、视频等为非文本文件）。</p>
<p>从另一角度来说：字符流 = 字节流 + 编码表</p>
<p><strong>01、字符输入流（Reader） </strong></p>
<p>java.io.Reader是字符输入流的超类（父类），它定义了字符输入流的一些共性方法：</p>
<p>1、 close() ：关闭此流并释放与此流相关的系统资源。</p>
<p>2、 read() ：从输入流读取一个字符。</p>
<p>3、 read(char[] cbuf) ：从输入流中读取一些字符，并将它们存储到字符数组 cbuf中</p>
<p>FileReader 是 Reader 的子类，用于从文件中读取字符数据。它的主要特点如下：</p>
<ul>
<li>可以通过构造方法指定要读取的文件路径。</li>
<li>每次可以读取一个或多个字符。</li>
<li>可以读取 Unicode 字符集中的字符，通过指定字符编码来实现字符集的转换。</li>
</ul>
<p><strong>1）FileReader构造方法 </strong></p>
<p>1、 FileReader(File file) ：创建一个新的 FileReader，参数为File对象。</p>
<p>2、 FileReader(String fileName) ：创建一个新的 FileReader，参数为文件名。</p>
<p>代码示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 使用File对象创建流对象</span><br><span class="line">File file = new File(&quot;a.txt&quot;);</span><br><span class="line">FileReader fr = new FileReader(file);</span><br><span class="line">// 使用文件名称创建流对象</span><br><span class="line">FileReader fr = new FileReader(&quot;b.txt&quot;);</span><br></pre></td></tr></table></figure>
<p><strong>2）FileReader读取字符数据 </strong></p>
<p>①、读取字符： read方法，每次可以读取一个字符，返回读取的字符（转为 int 类型），当读取到文件末尾时，返回 -1 。代码示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 使用文件名称创建流对象</span><br><span class="line">FileReader fr = new FileReader(&quot;abc.txt&quot;);</span><br><span class="line">// 定义变量，保存数据</span><br><span class="line">int b;</span><br><span class="line">// 循环读取</span><br><span class="line">while ((b = fr.read())!=-1) &#123;</span><br><span class="line">    System.out.println((char)b);</span><br><span class="line">&#125;</span><br><span class="line">// 关闭资源</span><br><span class="line">fr.close();</span><br></pre></td></tr></table></figure>
<p>②、读取指定长度的字符： read(char[] cbuf, int off, int len) ，并将其存储到字符数组中。其中，cbuf 表示存储读取结果的字符数组，off 表示存储结果的起始位置，len 表示要读取的字符数。代码示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">File textFile = new File(&quot;docs/约定.md&quot;);</span><br><span class="line">// 给一个 FileReader 的示例</span><br><span class="line">// try-with-resources FileReader</span><br><span class="line">try(FileReader reader = new FileReader(textFile);) &#123;</span><br><span class="line">    // read(char[] cbuf)</span><br><span class="line">    char[] buffer = new char[1024];</span><br><span class="line">    int len;</span><br><span class="line">    while ((len = reader.read(buffer, 0, buffer.length)) != -1) &#123;</span><br><span class="line">        System.out.print(new String(buffer, 0, len));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，使用 FileReader 从文件中读取字符数据，并将其存储到一个大小为 1024 的字符数组中。每次读取 len 个字符，然后使用 String 构造方法将其转换为字符串并输出。</p>
<p>FileReader 实现了 AutoCloseable 接口，因此可以使用 try-with-resources 语句自动关闭资源，避免了手动关闭资源的繁琐操作。</p>
<p><strong>02、字符输出流（Writer） </strong></p>
<p>java.io.Writer 是字符输出流类的超类（父类），可以将指定的字符信息写入到目的地，来看它定义的一些共性方法：</p>
<p>1、 write(int c) 写入单个字符。</p>
<p>2、 write(char[] cbuf) 写入字符数组。</p>
<p>3、 write(char[] cbuf, int off, int len) 写入字符数组的一部分，off为开始索引，len为字符个数。</p>
<p>4、 write(String str) 写入字符串。</p>
<p>5、 write(String str, int off, int len) 写入字符串的某一部分，off 指定要写入的子串在 str 中的起始位置，len 指定要写入的子串的长度。</p>
<p>6、 flush() 刷新该流的缓冲。</p>
<p>7、 close() 关闭此流，但要先刷新它。</p>
<p>java.io.FileWriter 类是 Writer 的子类，用来将字符写入到文件。</p>
<p><strong>1）FileWriter 构造方法 </strong></p>
<ul>
<li>FileWriter(File file) ： 创建一个新的 FileWriter，参数为要读取的File对象。</li>
<li>FileWriter(String fileName) ： 创建一个新的 FileWriter，参数为要读取的文件的名称。</li>
</ul>
<p>代码示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 第一种：使用File对象创建流对象</span><br><span class="line">File file = new File(&quot;a.txt&quot;);</span><br><span class="line">FileWriter fw = new FileWriter(file);</span><br><span class="line">// 第二种：使用文件名称创建流对象</span><br><span class="line">FileWriter fw = new FileWriter(&quot;b.txt&quot;);</span><br></pre></td></tr></table></figure>
<p><strong>2）FileWriter写入数据 </strong></p>
<p>①、写入字符： write(int b) 方法，每次可以写出一个字符，代码示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">FileWriter fw = null;</span><br><span class="line">try &#123;</span><br><span class="line">    fw = new FileWriter(&quot;output.txt&quot;);</span><br><span class="line">    fw.write(72); // 写入字符&#x27;H&#x27;的ASCII码</span><br><span class="line">    fw.write(101); // 写入字符&#x27;e&#x27;的ASCII码</span><br><span class="line">    fw.write(108); // 写入字符&#x27;l&#x27;的ASCII码</span><br><span class="line">    fw.write(108); // 写入字符&#x27;l&#x27;的ASCII码</span><br><span class="line">    fw.write(111); // 写入字符&#x27;o&#x27;的ASCII码</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        if (fw != null) &#123;</span><br><span class="line">            fw.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例代码中，首先创建一个 FileWriter 对象 fw，并指定要写入的文件路径 “output.txt”。然后使用 fw.write() 方法将字节写入文件中，这里分别写入字符’H’、’e’、’l’、’l’、’o’的 ASCII 码。最后在 finally 块中关闭 FileWriter 对象，释放资源。</p>
<p>需要注意的是，使用 write(int b) 方法写入的是一个字节，而不是一个字符。如果需要写入字符，可以使用 write(char cbuf[]) 或 write(String str) 方法。</p>
<p>②、写入字符数组： write(char[] cbuf) 方法，将指定字符数组写入输出流。代码示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">FileWriter fw = null;</span><br><span class="line">try &#123;</span><br><span class="line">    fw = new FileWriter(&quot;output.txt&quot;);</span><br><span class="line">    char[] chars = &#123;&#x27;H&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;&#125;;</span><br><span class="line">    fw.write(chars); // 将字符数组写入文件</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        if (fw != null) &#123;</span><br><span class="line">            fw.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>③、写入指定字符数组： write(char[] cbuf, int off, int len) 方法，将指定字符数组的一部分写入输出流。代码示例如下（重复的部分就不写了哈，参照上面的部分）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fw = new FileWriter(&quot;output.txt&quot;);</span><br><span class="line">    char[] chars = &#123;&#x27;H&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;,&#x27;, &#x27; &#x27;, &#x27;W&#x27;, &#x27;o&#x27;, &#x27;r&#x27;, &#x27;l&#x27;, &#x27;d&#x27;, </span><br><span class="line">&#x27;!&#x27;&#125;;</span><br><span class="line">fw.write(chars, 0, 5); // 将字符数组的前 5 个字符写入文件</span><br></pre></td></tr></table></figure>
<p>使用 fw.write() 方法将字符数组的前 5 个字符写入文件中。</p>
<p>④、写入字符串： write(String str) 方法，将指定字符串写入输出流。代码示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fw = new FileWriter(&quot;output.txt&quot;);</span><br><span class="line">String str = &quot;沉默王二&quot;;</span><br><span class="line">fw.write(str); // 将字符串写入文件</span><br></pre></td></tr></table></figure>
<p>⑤、写入指定字符串： write(String str, int off, int len) 方法，将指定字符串的一部分写入输出流。代码示例如下（try-with-resources形式）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;沉默王二真的帅啊！&quot;;</span><br><span class="line">try (FileWriter fw = new FileWriter(&quot;output.txt&quot;)) &#123;</span><br><span class="line">    fw.write(str, 0, 5); // 将字符串的前 5 个字符写入文件</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>【注意】如果不关闭资源，数据只是保存到缓冲区，并未保存到文件中。</p>
</blockquote>
<p><strong>3）关闭close和刷新flush </strong></p>
<p>因为 FileWriter 内置了缓冲区 ByteBuffer，所以如果不关闭输出流，就无法把字符写入到文件中。</p>
<p><img src="\assets\note\image-20231011102644327.png" alt="image-20231011102644327"></p>
<p>但是关闭了流对象，就无法继续写数据了。如果我们既想写入数据，又想继续使用流，就需要 flush 方法了。</p>
<p>flush ：刷新缓冲区，流对象可以继续使用。</p>
<p>close ：先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。</p>
<p>flush还是比较有趣的，来段代码体会体会：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//源   也就是输入流【读取流】 读取a.txt文件</span><br><span class="line">FileReader fr=new FileReader(&quot;abc.txt&quot;);  //必须要存在a.txt文件，否则报</span><br><span class="line">FileNotFoundException异常</span><br><span class="line">//目的地  也就是输出流</span><br><span class="line">FileWriter fw=new FileWriter(&quot;b.txt&quot;);  //系统会自动创建b.txt，因为它是输出流！</span><br><span class="line">int len;</span><br><span class="line">while((len=fr.read())!=-1)&#123;</span><br><span class="line">    fw.write(len);</span><br><span class="line">&#125;</span><br><span class="line">//注意这里是没有使用close关闭流，开发中不能这样做，但是为了更好的体会flush的作用</span><br></pre></td></tr></table></figure>
<p>运行效果是怎么样的呢？答案是b.txt文件中依旧是空的，并没有任何东西。</p>
<p><img src="\assets\note\image-20231011102734614.png" alt="image-20231011102734614"></p>
<p>原因我们前面已经说过了。编程就是这样，不去敲，永远学不会！！！所以一定要去敲，多敲啊！！！</p>
<p>在以上的代码中再添加下面三句代码，b.txt文件就能复制到源文件的数据了！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fr.close();</span><br><span class="line">fw.flush();</span><br><span class="line">fw.close();</span><br></pre></td></tr></table></figure>
<p>flush()这个方法是清空缓存的意思，用于清空缓冲区的数据流，进行流的操作时，数据先被读到内存中，然后再把数据写到文件中。</p>
<p>你可以使用下面的代码示例再体验一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 使用文件名称创建流对象</span><br><span class="line">FileWriter fw = new FileWriter(&quot;fw.txt&quot;);</span><br><span class="line">// 写出数据，通过flush</span><br><span class="line">fw.write(&#x27;刷&#x27;); // 写出第1个字符</span><br><span class="line">fw.flush();</span><br><span class="line">fw.write(&#x27;新&#x27;); // 继续写出第2个字符，写出成功</span><br><span class="line">fw.flush();</span><br><span class="line">// 写出数据，然后close</span><br><span class="line">fw.write(&#x27;关&#x27;); // 写出第1个字符</span><br><span class="line">fw.close();</span><br><span class="line">fw.write(&#x27;闭&#x27;); // 继续写出第2个字符,【报错】java.io.IOException: Stream closed</span><br><span class="line">fw.close();</span><br></pre></td></tr></table></figure>
<p>注意，即便是flush方法写出了数据，操作的最后还是要调用close方法，释放系统资源。当然你也可以用 try-with-resources 的方式。</p>
<p><strong>4）FileWriter的续写和换行 </strong></p>
<p>续写和换行：操作类似于FileOutputStream操作，直接上代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 使用文件名称创建流对象，可以续写数据</span><br><span class="line">FileWriter fw = new FileWriter(&quot;fw.txt&quot;,true);     </span><br><span class="line">// 写出字符串</span><br><span class="line">fw.write(&quot;沉默王二&quot;);</span><br><span class="line">// 写出换行</span><br><span class="line">fw.write(&quot;\r\n&quot;);</span><br><span class="line">// 写出字符串</span><br><span class="line">fw.write(&quot;是傻 X&quot;);</span><br><span class="line">// 关闭资源</span><br><span class="line">fw.close();</span><br></pre></td></tr></table></figure>
<p>输出结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输出结果:</span><br><span class="line">沉默王二</span><br><span class="line">是傻 X</span><br></pre></td></tr></table></figure>
<p><strong>5）文本文件复制 </strong></p>
<p>直接上代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import java.io.FileReader;</span><br><span class="line">import java.io.FileWriter;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">public class CopyFile &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        //创建输入流对象</span><br><span class="line">        FileReader fr=new FileReader(&quot;aa.txt&quot;);//文件不存在会抛出</span><br><span class="line">java.io.FileNotFoundException</span><br><span class="line">        //创建输出流对象</span><br><span class="line">        FileWriter fw=new FileWriter(&quot;copyaa.txt&quot;);</span><br><span class="line">        /*创建输出流做的工作：</span><br><span class="line">         *      1、调用系统资源创建了一个文件</span><br><span class="line">         *      2、创建输出流对象</span><br><span class="line">         *      3、把输出流对象指向文件        </span><br><span class="line">         * */</span><br><span class="line">        //文本文件复制，一次读一个字符</span><br><span class="line">        copyMethod1(fr, fw);</span><br><span class="line">        //文本文件复制，一次读一个字符数组</span><br><span class="line">        copyMethod2(fr, fw);</span><br><span class="line">        </span><br><span class="line">        fr.close();</span><br><span class="line">        fw.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void copyMethod1(FileReader fr, FileWriter fw) throws IOException </span><br><span class="line">&#123;</span><br><span class="line">        int ch;</span><br><span class="line">        while((ch=fr.read())!=-1) &#123;//读数据</span><br><span class="line">            fw.write(ch);//写数据</span><br><span class="line">        &#125;</span><br><span class="line">        fw.flush();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void copyMethod2(FileReader fr, FileWriter fw) throws IOException </span><br><span class="line">&#123;</span><br><span class="line">        char chs[]=new char[1024];</span><br><span class="line">        int len=0;</span><br><span class="line">        while((len=fr.read(chs))!=-1) &#123;//读数据</span><br><span class="line">            fw.write(chs,0,len);//写数据</span><br><span class="line">        &#125;</span><br><span class="line">        fw.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>03、IO异常的处理 </strong></p>
<p>我们在学习的过程中可能习惯把异常抛出，而实际开发中建议使用 try…catch…finally 代码块，处理异常部分，格式代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 声明变量</span><br><span class="line">FileWriter fw = null;</span><br><span class="line">try &#123;</span><br><span class="line">    //创建流对象</span><br><span class="line">    fw = new FileWriter(&quot;fw.txt&quot;);</span><br><span class="line">    // 写出数据</span><br><span class="line">    fw.write(&quot;二哥真的帅&quot;); //哥敢摸si</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        if (fw != null) &#123;</span><br><span class="line">            fw.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者直接使用 try-with-resources 的方式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try (FileWriter fw = new FileWriter(&quot;fw.txt&quot;)) &#123;</span><br><span class="line">    // 写出数据</span><br><span class="line">    fw.write(&quot;二哥真的帅&quot;); //哥敢摸si</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个代码中，try-with-resources 会在 try 块执行完毕后自动关闭 FileWriter 对象 fw，不需要手动关闭流。如果在 try 块中发生了异常，也会自动关闭流并抛出异常。因此，使用 try-with-resources 可以让代码更加简洁、安全和易读。</p>
<p><strong>04、小结 </strong></p>
<p>Writer 和 Reader 是 Java I/O 中用于字符输入输出的抽象类，它们提供了一系列方法用于读取和写入字符数据。它们的区别在于 Writer 用于将字符数据写入到输出流中，而 Reader 用于从输入流中读取字符数据。</p>
<p>Writer 和 Reader 的常用子类有 FileWriter、FileReader，可以将字符流写入和读取到文件中。</p>
<p>在使用 Writer 和 Reader 进行字符输入输出时，需要注意字符编码的问题。</p>
<h2 id="5-5-缓冲流"><a href="#5-5-缓冲流" class="headerlink" title="5.5 缓冲流"></a>5.5 缓冲流</h2><p>Java 的缓冲流是对字节流和字符流的一种封装，通过在内存中开辟缓冲区来提高 I/O 操作的效率。Java 通过 BufferedInputStream 和 BufferedOutputStream 来实现字节流的缓冲，通过 BufferedReader 和 BufferedWriter 来实现字符流的缓冲。</p>
<p>缓冲流的工作原理是将数据先写入缓冲区中，当缓冲区满时再一次性写入文件或输出流，或者当缓冲区为空时一次性从文件或输入流中读取一定量的数据。这样可以减少系统的 I/O 操作次数，提高系统的 I/O 效率，从而提高程序的运行效率。</p>
<p><strong>01、字节缓冲流 </strong></p>
<p>BufferedInputStream 和 BufferedOutputStream 属于字节缓冲流，强化了字节流 InputStream 和 OutputStream，关于字节流，我们前面已经详细地讲过了。</p>
<p><strong>1）构造方法 </strong></p>
<ul>
<li>BufferedInputStream(InputStream in) ：创建一个新的缓冲输入流，注意参数类型为InputStream。</li>
<li>BufferedOutputStream(OutputStream out) ： 创建一个新的缓冲输出流，注意参数类型为OutputStream。</li>
</ul>
<p>代码示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 创建字节缓冲输入流，先声明字节流</span><br><span class="line">FileInputStream fps = new FileInputStream(b.txt);</span><br><span class="line">BufferedInputStream bis = new BufferedInputStream(fps)</span><br><span class="line">// 创建字节缓冲输入流（一步到位）</span><br><span class="line">BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;b.txt&quot;));</span><br><span class="line">// 创建字节缓冲输出流（一步到位）</span><br><span class="line">BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;b.txt&quot;));</span><br></pre></td></tr></table></figure>
<p><strong>2）缓冲流的高效 </strong></p>
<p>我们通过复制一个 370M+ 的大文件，来测试缓冲流的效率。为了做对比，我们先用基本流来实现一下，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 记录开始时间</span><br><span class="line">long start = System.currentTimeMillis();</span><br><span class="line">// 创建流对象</span><br><span class="line">try (FileInputStream fis = new FileInputStream(&quot;py.mp4&quot;);//exe文件够大</span><br><span class="line">        FileOutputStream fos = new FileOutputStream(&quot;copyPy.mp4&quot;))&#123;</span><br><span class="line">    // 读写数据</span><br><span class="line">    int b;</span><br><span class="line">    while ((b = fis.read()) != -1) &#123;</span><br><span class="line">        fos.write(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 记录结束时间</span><br><span class="line">long end = System.currentTimeMillis();</span><br><span class="line">System.out.println(&quot;普通流复制时间:&quot;+(end - start)+&quot; 毫秒&quot;);</span><br></pre></td></tr></table></figure>
<p>不好意思，我本机比较菜，10 分钟还在复制中。切换到缓冲流试一下，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 记录开始时间</span><br><span class="line">long start = System.currentTimeMillis();</span><br><span class="line">// 创建流对象</span><br><span class="line">try (BufferedInputStream bis = new BufferedInputStream(new </span><br><span class="line">FileInputStream(&quot;py.mp4&quot;));</span><br><span class="line">        BufferedOutputStream bos = new BufferedOutputStream(new </span><br><span class="line">FileOutputStream(&quot;copyPy.mp4&quot;));)&#123;</span><br><span class="line">    // 读写数据</span><br><span class="line">    int b;</span><br><span class="line">    while ((b = bis.read()) != -1) &#123;</span><br><span class="line">        bos.write(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 记录结束时间</span><br><span class="line">long end = System.currentTimeMillis();</span><br><span class="line">System.out.println(&quot;缓冲流复制时间:&quot;+(end - start)+&quot; 毫秒&quot;);</span><br></pre></td></tr></table></figure>
<p>只需要 8016 毫秒，如何更快呢？</p>
<p>可以换数组的方式来读写，这个我们前面也有讲到，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 记录开始时间</span><br><span class="line">long start = System.currentTimeMillis();</span><br><span class="line">// 创建流对象</span><br><span class="line">try (BufferedInputStream bis = new BufferedInputStream(new </span><br><span class="line">FileInputStream(&quot;py.mp4&quot;));</span><br><span class="line">        BufferedOutputStream bos = new BufferedOutputStream(new </span><br><span class="line">FileOutputStream(&quot;copyPy.mp4&quot;));)&#123;</span><br><span class="line">    // 读写数据</span><br><span class="line">    int len;</span><br><span class="line">    byte[] bytes = new byte[8*1024];</span><br><span class="line">    while ((len = bis.read(bytes)) != -1) &#123;</span><br><span class="line">        bos.write(bytes, 0 , len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 记录结束时间</span><br><span class="line">long end = System.currentTimeMillis();</span><br><span class="line">System.out.println(&quot;缓冲流使用数组复制时间:&quot;+(end - start)+&quot; 毫秒&quot;);</span><br></pre></td></tr></table></figure>
<p>这下就更快了，只需要 521 毫秒。</p>
<p><strong>3）为什么字节缓冲流会这么快？ </strong></p>
<p>传统的 Java IO 是阻塞模式的，它的工作状态就是“读/写，等待，读/写，等待。。。。。。”</p>
<p>字节缓冲流解决的就是这个问题：<strong>一次多读点多写点，减少读写的频率，用空间换时间。</strong></p>
<ul>
<li>减少系统调用次数：在使用字节缓冲流时，数据不是立即写入磁盘或输出流，而是先写入缓冲区，当缓冲区满时再一次性写入磁盘或输出流。这样可以减少系统调用的次数，从而提高 I/O 操作的效率。</li>
<li>减少磁盘读写次数：在使用字节缓冲流时，当需要读取数据时，缓冲流会先从缓冲区中读取数据，如果缓冲区中没有足够的数据，则会一次性从磁盘或输入流中读取一定量的数据。同样地，当需要写入数据时，缓冲流会先将数据写入缓冲区，如果缓冲区满了，则会一次性将缓冲区中的数据写入磁盘或输出流。这样可以减少磁盘读写的次数，从而提高 I/O 操作的效率。</li>
<li>提高数据传输效率：在使用字节缓冲流时，由于数据是以块的形式进行传输，因此可以减少数据传输的次数，从而提高数据传输的效率。</li>
</ul>
<p>我们来看 BufferedInputStream 的 read 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public synchronized int read() throws IOException &#123;</span><br><span class="line">    if (pos &gt;= count) &#123;     // 如果当前位置已经到达缓冲区末尾</span><br><span class="line">        fill();             // 填充缓冲区</span><br><span class="line">        if (pos &gt;= count)   // 如果填充后仍然到达缓冲区末尾，说明已经读取完毕</span><br><span class="line">            return -1;      // 返回 -1 表示已经读取完毕</span><br><span class="line">    &#125;</span><br><span class="line">    return getBufIfOpen()[pos++] &amp; 0xff; // 返回当前位置的字节，并将位置加 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码主要有两部分：</p>
<ul>
<li>fill() ：该方法会将缓冲 buf 填满。</li>
<li>getBufIfOpen()[pos++] &amp; 0xff ：返回当前读取位置 pos 处的字节（ getBufIfOpen()返回的是 buffer 数组，是 byte 类型），并将其与 0xff 进行位与运算。这里的目的是将读取到的字节 b 当做无符号的字节处理，因为 Java 的 byte 类型是有符号的，而将 b 与 0xff 进行位与运算，就可以将其转换为无符号的字节，其范围为 0 到 255。</li>
</ul>
<blockquote>
<p>byte &amp; 0xFF 我们一会再细讲。</p>
</blockquote>
<p>再来看 FileInputStream 的 read 方法：</p>
<p><img src="\assets\note\image-20231011103948813.png" alt="image-20231011103948813"></p>
<p>在这段代码中， read0() 方法是一个本地方法，它的实现是由底层操作系统提供的，并不是 Java 语言实现的。在不同的操作系统上， read0() 方法的实现可能会有所不同，但是它们的功能都是相同的，都是用于读取一个字节。</p>
<p>再来看一下 BufferedOutputStream 的 write(byte b[], int off, int len) 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void write(byte b[], int off, int len) throws IOException &#123;</span><br><span class="line">    if (len &gt;= buf.length) &#123;    // 如果写入的字节数大于等于缓冲区长度</span><br><span class="line">        flushBuffer();          // 先刷新缓冲区</span><br><span class="line">        out.write(b, off, len); // 直接将数据写入输出流</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (len &gt; buf.length - count) &#123; // 如果写入的字节数大于空余空间</span><br><span class="line">        flushBuffer();              // 先刷新缓冲区</span><br><span class="line">    &#125;</span><br><span class="line">    System.arraycopy(b, off, buf, count, len); // 将数据拷贝到缓冲区中</span><br><span class="line">    count += len;                             // 更新计数器</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，该方法会检查写入的字节数是否大于等于缓冲区长度，如果是，则先将缓冲区中的数据刷新到磁盘中，然后直接将数据写入输出流。这样做是为了避免缓冲流级联时的问题，即缓冲区的大小不足以容纳写入的数据时，可能会引发级联刷新，导致效率降低。</p>
<blockquote>
<p>级联问题（Cascade Problem）是指在一组缓冲流（Buffered Stream）中，由于缓冲区的大小不足以容纳要写入的数据，导致数据被分割成多个部分，并分别写入到不同的缓冲区中，最终需要逐个刷新缓冲区，从而导致性能下降的问题。</p>
</blockquote>
<p>其次，如果写入的字节数小于缓冲区长度，则检查缓冲区中剩余的空间是否足够容纳要写入的字节数，如果不够，则先将缓冲区中的数据刷新到磁盘中。然后，使用 System.arraycopy() 方法将要写入的数据拷贝到缓冲区中，并更新计数器 count。</p>
<p>最后，如果写入的字节数小于缓冲区长度且缓冲区中还有剩余空间，则直接将要写入的数据拷贝到缓冲区中，并更新计数器 count。</p>
<p>也就是说，只有当 buf 写满了，才会 flush，将数据刷到磁盘，默认一次刷 8192 个字节。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public BufferedOutputStream(OutputStream out) &#123;</span><br><span class="line">    this(out, 8192);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 buf 没有写满，会继续写 buf。</p>
<p><img src="\assets\note\image-20231011104153679.png" alt="image-20231011104153679"></p>
<p>当把 BufferedOutputStream 和 BufferedInputStream 配合起来使用后，就减少了大量的读写次数，尤其是 byte[] bytes = new byte[8*1024] ，就相当于缓冲区的空间有 8 个 1024 字节，那读写效率就会大大提高。</p>
<p><strong>4） byte &amp; 0xFF</strong></p>
<p>byte 类型通常被用于存储二进制数据，例如读取和写入文件、网络传输等场景。在这些场景下，byte 类型的变量可以用来存储数据流中的每个字节，从而进行读取和写入操作。</p>
<p>byte 类型是有符号的，即其取值范围为 -128 到 127。如果我们希望得到的是一个无符号的 byte 值，就需要使用 byte &amp; 0xFF 来进行转换。</p>
<p>这是因为 0xFF 是一个无符号的整数，它的二进制表示为 11111111。当一个 byte 类型的值与 0xFF 进行位与运算时，会将 byte 类型的值转换为一个无符号的整数，其范围为 0 到 255。</p>
<p>0xff 是一个十六进制的数，相当于二进制的 11111111，&amp; 运算符的意思是：如果两个操作数的对应位为 1，则输出 1，否则为 0；由于 0xff 有 8 个 1，单个 byte 转成 int 其实就是将 byte 和 int 类型的 255 进行(&amp;)与运算。</p>
<p>例如，如果我们有一个 byte 类型的变量 b，其值为 -1，那么 b &amp; 0xFF 的结果就是 255。这样就可以将一个有符号的 byte 类型的值转换为一个无符号的整数。</p>
<p>&amp; 运算是一种二进制数据的计算方式, 两个操作位都为1，结果才为1，否则结果为0. 在上面的 getBufIfOpen()[pos++] &amp; 0xff 计算过程中, byte 有 8bit, OXFF 是16进制的255, 表示的是 int 类型, int 有 32bit.</p>
<p>如果 getBufIfOpen()[pos++] 为 -118, 那么其原码表示为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00000000 00000000 00000000 10001010</span><br></pre></td></tr></table></figure>
<p>反码为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11111111 11111111 11111111 11110101</span><br></pre></td></tr></table></figure>
<p>补码为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11111111 11111111 11111111 11110110</span><br></pre></td></tr></table></figure>
<p>0XFF 表示16进制的数据255, 原码, 反码, 补码都是一样的, 其二进制数据为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00000000 00000000 00000000 11111111</span><br></pre></td></tr></table></figure>
<p>0XFF 和 -118 进行&amp;运算后结果为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00000000 00000000 00000000 11110110</span><br></pre></td></tr></table></figure>
<p>还原为原码后为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00000000 00000000 00000000 10001010</span><br></pre></td></tr></table></figure>
<p>其表示的 int 值为 138，可见将 byte 类型的 -118 与 0XFF 进行与运算后值由 -118 变成了 int 类型的 138，其中低8位和byte的-118完全一致。</p>
<p>顺带聊一下 原码、反码和补码。</p>
<p>①、原码</p>
<p>原码就是符号位加上真值的绝对值，即用第一位表示符号，其余位表示值。比如如果是8位二进制:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[+1]原 = 0000 0001</span><br><span class="line">[-1]原 = 1000 0001</span><br></pre></td></tr></table></figure>
<p>第一位是符号位。因为第一位是符号位，所以8位二进制数的取值范围就是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1111 1111 , 0111 1111]</span><br></pre></td></tr></table></figure>
<p>即</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[-127 , 127]</span><br></pre></td></tr></table></figure>
<p>②、反码</p>
<p>反码的表示方法是：</p>
<ul>
<li>正数的反码是其本身</li>
<li>负数的反码是在其原码的基础上，符号位不变，其余各个位取反。</li>
</ul>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[+1] = [00000001]原 = [00000001]反</span><br><span class="line">[-1] = [10000001]原 = [11111110]反</span><br></pre></td></tr></table></figure>
<p>可见如果一个反码表示的是负数，人脑无法直观的看出来它的数值。通常要将其转换成原码再计算。</p>
<p>③、补码</p>
<p>补码的表示方法是：</p>
<ul>
<li>正数的补码就是其本身</li>
<li>负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后+1。(即在反码的基础上+1)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[+1] = [00000001]原 = [00000001]反 = [00000001]补</span><br><span class="line">[-1] = [10000001]原 = [11111110]反 = [11111111]补</span><br></pre></td></tr></table></figure>
<p>对于负数，补码表示方式也是人脑无法直观看出其数值的。通常也需要转换成原码在计算其数值。</p>
<p>从上面可以看到：</p>
<ul>
<li>对于正数：原码，反码，补码都是一样的</li>
<li>对于负数：原码，反码，补码都是不一样的</li>
</ul>
<p><strong>02、字符缓冲流 </strong></p>
<p>BufferedReader 类继承自 Reader 类，提供了一些便捷的方法，例如 readLine() 方法可以一次读取一行数据，而不是一个字符一个字符地读取。</p>
<p>BufferedWriter 类继承自 Writer 类，提供了一些便捷的方法，例如 newLine() 方法可以写入一个系统特定的行分隔符。</p>
<p><strong>1）构造方法 </strong></p>
<ul>
<li>BufferedReader(Reader in) ：创建一个新的缓冲输入流，注意参数类型为Reader。</li>
<li>BufferedWriter(Writer out) ： 创建一个新的缓冲输出流，注意参数类型为Writer。</li>
</ul>
<p>代码示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 创建字符缓冲输入流</span><br><span class="line">BufferedReader br = new BufferedReader(new FileReader(&quot;b.txt&quot;));</span><br><span class="line">// 创建字符缓冲输出流</span><br><span class="line">BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;b.txt&quot;));</span><br></pre></td></tr></table></figure>
<p><strong>2）字符缓冲流特有方法 </strong></p>
<p>字符缓冲流的基本方法与普通字符流调用方式一致，这里不再赘述，我们来看字符缓冲流特有的方法。</p>
<ul>
<li>BufferedReader： String readLine() : 读一行数据，读取到最后返回 null</li>
<li>BufferedWriter： newLine() : 换行，由系统定义换行符。</li>
</ul>
<p>来看 readLine()方法的代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 创建流对象</span><br><span class="line">BufferedReader br = new BufferedReader(new FileReader(&quot;a.txt&quot;));</span><br><span class="line">// 定义字符串,保存读取的一行文字</span><br><span class="line">String line  = null;</span><br><span class="line">// 循环读取,读取到最后返回null</span><br><span class="line">while ((line = br.readLine())!=null) &#123;</span><br><span class="line">    System.out.print(line);</span><br><span class="line">    System.out.println(&quot;------&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// 释放资源</span><br><span class="line">br.close();</span><br></pre></td></tr></table></figure>
<p>再来看 newLine() 方法的代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 创建流对象</span><br><span class="line">BfferedWriter bw = new BufferedWriter(new FileWriter(&quot;b.txt&quot;));</span><br><span class="line">// 写出数据</span><br><span class="line">bw.write(&quot;沉&quot;);</span><br><span class="line">// 写出换行</span><br><span class="line">bw.newLine();</span><br><span class="line">bw.write(&quot;默&quot;);</span><br><span class="line">bw.newLine();</span><br><span class="line">bw.write(&quot;王&quot;);</span><br><span class="line">bw.newLine();</span><br><span class="line">bw.write(&quot;二&quot;);</span><br><span class="line">bw.newLine();</span><br><span class="line">// 释放资源</span><br><span class="line">bw.close();</span><br></pre></td></tr></table></figure>
<p><strong>03、字符缓冲流练习</strong></p>
<p>来欣赏一下我写的这篇诗：</p>
<blockquote>
<p>6.岑夫子，丹丘生，将进酒，杯莫停。</p>
<p>1.君不见黄河之水天上来，奔流到海不复回。</p>
<p>8.钟鼓馔玉不足贵，但愿长醉不愿醒。</p>
<p>3.人生得意须尽欢，莫使金樽空对月。</p>
<p>5.烹羊宰牛且为乐，会须一饮三百杯。</p>
<p>2.君不见高堂明镜悲白发，朝如青丝暮成雪。</p>
<p>7.与君歌一曲，请君为我倾耳听。</p>
<p>4.天生我材必有用，千金散尽还复来。</p>
</blockquote>
<p>欣赏完了没？</p>
<p>估计你也看出来了，这是李白写的《将进酒》，不是我王二写的。</p>
<p>不过，顺序是乱的，还好，我都编了号。那如何才能按照正确的顺序来呢？</p>
<p>来看代码实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 创建map集合,保存文本数据,键为序号,值为文字</span><br><span class="line">HashMap&lt;String, String&gt; lineMap = new HashMap&lt;&gt;();</span><br><span class="line">// 创建流对象  源</span><br><span class="line">BufferedReader br = new BufferedReader(new FileReader(&quot;logs/test.log&quot;));</span><br><span class="line">//目标</span><br><span class="line">BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;logs/test1.txt&quot;));</span><br><span class="line">// 读取数据</span><br><span class="line">String line;</span><br><span class="line">while ((line = br.readLine())!=null) &#123;</span><br><span class="line">    // 解析文本</span><br><span class="line">    if (line.isEmpty()) &#123;</span><br><span class="line">        continue;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] split = line.split(Pattern.quote(&quot;.&quot;));</span><br><span class="line">    // 保存到集合</span><br><span class="line">    lineMap.put(split[0], split[1]);</span><br><span class="line">&#125;</span><br><span class="line">// 释放资源</span><br><span class="line">br.close();</span><br><span class="line">// 遍历map集合</span><br><span class="line">for (int i = 1; i &lt;= lineMap.size(); i++) &#123;</span><br><span class="line">    String key = String.valueOf(i);</span><br><span class="line">    // 获取map中文本</span><br><span class="line">    String value = lineMap.get(key);</span><br><span class="line">    // 写出拼接文本</span><br><span class="line">    bw.write(key+&quot;.&quot;+value);</span><br><span class="line">    // 写出换行</span><br><span class="line">    bw.newLine();</span><br><span class="line">&#125;</span><br><span class="line">// 释放资源</span><br><span class="line">bw.close();</span><br></pre></td></tr></table></figure>
<p>这里面用到的知识都是我们前面学过的，比如说 HashMap，字符串分割，包括刚刚学习的字符缓冲流。</p>
<p>来看输出结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.君不见黄河之水天上来，奔流到海不复回。</span><br><span class="line">2.君不见高堂明镜悲白发，朝如青丝暮成雪。</span><br><span class="line">3.人生得意须尽欢，莫使金樽空对月。</span><br><span class="line">4.天生我材必有用，千金散尽还复来。</span><br><span class="line">5.烹羊宰牛且为乐，会须一饮三百杯。</span><br><span class="line">6.岑夫子，丹丘生，将进酒，杯莫停。</span><br><span class="line">7.与君歌一曲，请君为我倾耳听。</span><br><span class="line">8.钟鼓馔玉不足贵，但愿长醉不愿醒。</span><br></pre></td></tr></table></figure>
<h2 id="5-6-转换流"><a href="#5-6-转换流" class="headerlink" title="5.6 转换流"></a>5.6 转换流</h2><p>转换流可以将一个字节流包装成字符流，或者将一个字符流包装成字节流。这种转换通常用于处理文本数据，如读取文本文件或将数据从网络传输到应用程序。</p>
<p>转换流主要有两种类型：InputStreamReader 和 OutputStreamWriter。</p>
<p>InputStreamReader 将一个字节输入流转换为一个字符输入流，而 OutputStreamWriter 将一个字节输出流转换为一个字符输出流。它们使用指定的字符集将字节流和字符流之间进行转换。常用的字符集包括 UTF-8、GBK、ISO-8859-1 等。</p>
<p><img src="\assets\note\image-20231011105242854.png" alt="image-20231011105242854"></p>
<p><strong>01、编码和解码 </strong></p>
<p>在计算机中，数据通常以二进制形式存储和传输。</p>
<ul>
<li>编码就是将原始数据（比如说文本、图像、视频、音频等）转换为二进制形式。</li>
<li>解码就是将二进制数据转换为原始数据，是一个反向的过程。</li>
</ul>
<p>常见的编码和解码方式有很多，举几个例子：</p>
<ul>
<li>ASCII 编码和解码：在计算机中，常常使用 ASCII 码来表示字符，如键盘上的字母、数字和符号等。例如，字母 A 对应的 ASCII 码是 65，字符 + 对应的 ASCII 码是 43。</li>
<li>Unicode 编码和解码：Unicode 是一种字符集，支持多种语言和字符集。在计算机中，Unicode 可以使用 UTF-8、UTF-16 等编码方式将字符转换为二进制数据进行存储和传输。</li>
<li>Base64 编码和解码：Base64 是一种将二进制数据转换为 ASCII 码的编码方式。它将 3 个字节的二进制数据转换为 4 个 ASCII 字符，以便在网络传输中使用。例如，将字符串 “Hello, world!” 进行 Base64 编码后，得到的结果是 “SGVsbG8sIHdvcmxkIQ==”。</li>
<li>图像编码和解码：在图像处理中，常常使用 JPEG、PNG、GIF 等编码方式将图像转换为二进制数据进行存储和传输。在解码时，可以将二进制数据转换为图像，以便显示或处理。</li>
<li>视频编码和解码：在视频处理中，常常使用 H.264、AVC、MPEG-4 等编码方式将视频转换为二进制数据进行存储和传输。在解码时，可以将二进制数据转换为视频，以便播放或处理。</li>
</ul>
<p>简单一点说就是：</p>
<ul>
<li>编码：字符(能看懂的)—&gt;字节(看不懂的)</li>
<li>解码：字节(看不懂的)—&gt;字符(能看懂的)</li>
</ul>
<p>我用代码来表示一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;沉默王二&quot;;</span><br><span class="line">String charsetName = &quot;UTF-8&quot;;</span><br><span class="line">// 编码</span><br><span class="line">byte[] bytes = str.getBytes(Charset.forName(charsetName));</span><br><span class="line">System.out.println(&quot;编码: &quot; + bytes);</span><br><span class="line">// 解码</span><br><span class="line">String decodedStr = new String(bytes, Charset.forName(charsetName));</span><br><span class="line">System.out.println(&quot;解码: &quot; + decodedStr);</span><br></pre></td></tr></table></figure>
<p>在这个示例中，首先定义了一个字符串变量 str 和一个字符集名称 charsetName。然后，使用 Charset.forName() 方法获取指定字符集的 Charset 对象。接着，使用字符串的 getBytes() 方法将字符串编码为指定字符集的字节数组。最后，使用 new String() 方法将字节数组解码为字符串。</p>
<p>需要注意的是，在编码和解码过程中，要保证使用相同的字符集，以便正确地转换数据。</p>
<p><strong>02、字符集 </strong></p>
<p>Charset：字符集，是一组字符的集合，每个字符都有一个唯一的编码值，也称为码点。</p>
<p>常见的字符集包括 ASCII、Unicode 和 GBK，而 Unicode 字符集包含了多种编码方式，比如说 UTF-8、UTF-16。</p>
<p><img src="\assets\note\image-20231011105519195.png" alt="image-20231011105519195"></p>
<p><strong>ASCII 字符集 </strong></p>
<p>ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）字符集是一种最早的字符集，包含 128 个字符，其中包括控制字符、数字、英文字母以及一些标点符号。ASCII 字符集中的每个字符都有一个唯一的 7 位二进制编码（由 0 和 1 组成），可以表示为十进制数或十六进制数。</p>
<p>ASCII 编码方式是一种固定长度的编码方式，每个字符都使用 7 位二进制编码来表示。ASCII 编码只能表示英文字母、数字和少量的符号，不能表示其他语言的文字和符号，因此在全球范围内的应用受到了很大的限制。</p>
<p><strong>Unicode 字符集 </strong></p>
<p>Unicode 包含了世界上几乎所有的字符，用于表示人类语言、符号和表情等各种信息。Unicode 字符集中的每个字符都有一个唯一的码点（code point），用于表示该字符在字符集中的位置，可以用十六进制数表示。</p>
<p>为了在计算机中存储和传输 Unicode 字符集中的字符，需要使用一种编码方式。UTF-8、UTF-16 和 UTF-32 都是 Unicode 字符集的编码方式，用于将 Unicode 字符集中的字符转换成字节序列，以便于存储和传输。</p>
<p>它们的差别在于使用的字节长度不同。</p>
<ul>
<li>UTF-8 是一种可变长度的编码方式，对于 ASCII 字符（码点范围为 0x00~0x7F ），使用一个字节表示，对于其他 Unicode 字符，使用两个、三个或四个字节表示。UTF-8 编码方式被广泛应用于互联网和计算机领域，因为它可以有效地压缩数据，适用于网络传输和存储。</li>
<li>UTF-16 是一种固定长度的编码方式，对于基本多语言平面（Basic Multilingual Plane，Unicode 字符集中的一个码位范围，包含了世界上大部分常用的字符，总共包含了超过 65,000 个码位）中的字符（码点范围为 0x0000~0xFFFF ），使用两个字节表示，对于其他 Unicode 字符，使用四个字节表示。</li>
<li>UTF-32 是一种固定长度的编码方式，对于所有 Unicode 字符，使用四个字节表示。</li>
</ul>
<p><strong>GBK 字符集 </strong></p>
<p>GBK 包含了 GB2312 字符集中的字符，同时还扩展了许多其他汉字字符和符号，共收录了 21,913 个字符。</p>
<p>GBK 采用双字节编码方式，每个汉字占用 2 个字节，其中高字节和低字节都使用了 8 位，因此 GBK 编码共有 2^16=65536 种可能的编码，其中大部分被用于表示汉字字符。</p>
<p>GBK 编码是一种变长的编码方式，对于 ASCII 字符（码位范围为 0x00 到 0x7F），使用一个字节表示，对于其他字符，使用两个字节表示。GBK 编码中的每个字节都可以采用 0x81 到 0xFE 之间的任意一个值，因此可以表示 2^15=32768 个字符。为了避免与 ASCII 码冲突，GBK 编码的第一个字节采用了 0x81 到 0xFE 之间除了 0x7F 的所有值，第二个字节采用了 0x40 到 0x7E 和 0x80 到 0xFE 之间的所有值，共 94 个值。</p>
<p>GB2312 的全名是《信息交换用汉字编码字符集基本集》，也被称为“国标码”。采用了双字节编码方式，每个汉字占用 2 个字节，其中高字节和低字节都使用了 8 位，因此 GB2312 编码共有 2^16=65536 种可能的编码，其中大部分被用于表示汉字字符。GB2312 编码中的每个字节都可以采用 0xA1 到 0xF7 之间的任意一个值，因此可以表示 126 个字符。</p>
<p>GB2312 是一个较为简单的字符集，只包含了常用的汉字和符号，因此对于一些较为罕见的汉字和生僻字，GB2312 不能满足需求，现在已经逐渐被 GBK、GB18030 等字符集所取代。</p>
<p>GB18030 是最新的中文码表。收录汉字 70244 个，采用多字节编码，每个字可以由 1 个、2 个或 4 个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。</p>
<p><strong>03、乱码 </strong></p>
<p>当使用不同的编码方式读取或者写入文件时，就会出现乱码问题，来看示例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">String s = &quot;沉默王二！&quot;;</span><br><span class="line">try &#123;</span><br><span class="line">    // 将字符串按GBK编码方式保存到文件中</span><br><span class="line">    OutputStreamWriter out = new OutputStreamWriter(</span><br><span class="line">            new FileOutputStream(&quot;logs/test_utf8.txt&quot;), &quot;GBK&quot;);</span><br><span class="line">    out.write(s);</span><br><span class="line">    out.close();</span><br><span class="line">    FileReader fileReader = new FileReader(&quot;logs/test_utf8.txt&quot;);</span><br><span class="line">    int read;</span><br><span class="line">    while ((read = fileReader.read()) != -1) &#123;</span><br><span class="line">        System.out.print((char)read);</span><br><span class="line">    &#125;</span><br><span class="line">    fileReader.close();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例代码中，首先定义了一个包含中文字符的字符串，然后将该字符串按 GBK 编码方式保存到文件中，接着将文件按默认编码方式（UTF-8）读取，并显示内容。此时就会出现乱码问题，显示为“��Ĭ������”。</p>
<p>这是因为文件中的 GBK 编码的字符在使用 UTF-8 编码方式解析时无法正确解析，从而导致出现乱码问题。</p>
<p>那如何才能解决乱码问题呢？</p>
<p>这就引出我们今天的主角了——转换流。</p>
<p><strong>04、InputStreamReader </strong></p>
<p>java.io.InputStreamReader 是 Reader 类的子类。它的作用是将字节流（InputStream）转换为字符流（Reader），同时支持指定的字符集编码方式，从而实现字符流与字节流之间的转换。</p>
<p><strong>1）构造方法 </strong></p>
<ul>
<li>InputStreamReader(InputStream in) : 创建一个使用默认字符集的字符流。</li>
<li>InputStreamReader(InputStream in, String charsetName) : 创建一个指定字符集的字符流。</li>
</ul>
<p>代码示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;in.txt&quot;));</span><br><span class="line">InputStreamReader isr2 = new InputStreamReader(new FileInputStream(&quot;in.txt&quot;) , &quot;GBK&quot;);</span><br></pre></td></tr></table></figure>
<p><strong>2）解决编码问题 </strong></p>
<p>下面是一个使用 InputStreamReader 解决乱码问题的示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">String s = &quot;沉默王二！&quot;;</span><br><span class="line">try &#123;</span><br><span class="line">    // 将字符串按GBK编码方式保存到文件中</span><br><span class="line">    OutputStreamWriter outUtf8 = new OutputStreamWriter(</span><br><span class="line">            new FileOutputStream(&quot;logs/test_utf8.txt&quot;), &quot;GBK&quot;);</span><br><span class="line">    outUtf8.write(s);</span><br><span class="line">    outUtf8.close();</span><br><span class="line">    // 将字节流转换为字符流，使用GBK编码方式</span><br><span class="line">    InputStreamReader isr = new InputStreamReader(new </span><br><span class="line">FileInputStream(&quot;logs/test_utf8.txt&quot;), &quot;GBK&quot;);</span><br><span class="line">    // 读取字符流</span><br><span class="line">    int c;</span><br><span class="line">    while ((c = isr.read()) != -1) &#123;</span><br><span class="line">        System.out.print((char) c);</span><br><span class="line">    &#125;</span><br><span class="line">    isr.close();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于使用了 InputStreamReader 对字节流进行了编码方式的转换，因此在读取字符流时就可以正确地解析出中文字符，避免了乱码问题。</p>
<p><strong>05、OutputStreamWriter </strong></p>
<p>java.io.OutputStreamWriter 是 Writer 的子类，字面看容易误以为是转为字符流，其实是将字符流转换为字节流，是字符流到字节流的桥梁。</p>
<ul>
<li>OutputStreamWriter(OutputStream in) : 创建一个使用默认字符集的字符流。</li>
<li>OutputStreamWriter(OutputStream in, String charsetName) ：创建一个指定字符集的字符流。</li>
</ul>
<p>代码示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OutputStreamWriter isr = new OutputStreamWriter(new FileOutputStream(&quot;a.txt&quot;));</span><br><span class="line">OutputStreamWriter isr2 = new OutputStreamWriter(new FileOutputStream(&quot;b.txt&quot;) , &quot;GBK&quot;);</span><br></pre></td></tr></table></figure>
<p>通常为了提高读写效率，我们会在转换流上再加一层缓冲流，来看代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    // 从文件读取字节流，使用UTF-8编码方式</span><br><span class="line">    FileInputStream fis = new FileInputStream(&quot;test.txt&quot;);</span><br><span class="line">    // 将字节流转换为字符流，使用UTF-8编码方式</span><br><span class="line">    InputStreamReader isr = new InputStreamReader(fis, &quot;UTF-8&quot;);</span><br><span class="line">    // 使用缓冲流包装字符流，提高读取效率</span><br><span class="line">    BufferedReader br = new BufferedReader(isr);</span><br><span class="line">    // 创建输出流，使用UTF-8编码方式</span><br><span class="line">    FileOutputStream fos = new FileOutputStream(&quot;output.txt&quot;);</span><br><span class="line">    // 将输出流包装为转换流，使用UTF-8编码方式</span><br><span class="line">    OutputStreamWriter osw = new OutputStreamWriter(fos, &quot;UTF-8&quot;);</span><br><span class="line">    // 使用缓冲流包装转换流，提高写入效率</span><br><span class="line">    BufferedWriter bw = new BufferedWriter(osw);</span><br><span class="line">    // 读取输入文件的每一行，写入到输出文件中</span><br><span class="line">    String line;</span><br><span class="line">    while ((line = br.readLine()) != null) &#123;</span><br><span class="line">        bw.write(line);</span><br><span class="line">        bw.newLine(); // 每行结束后写入一个换行符</span><br><span class="line">    &#125;</span><br><span class="line">    // 关闭流</span><br><span class="line">    br.close();</span><br><span class="line">    bw.close();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例代码中，首先使用 FileInputStream 从文件中读取字节流，使用 UTF-8 编码方式进行读取。然后，使用 InputStreamReader 将字节流转换为字符流，使用 UTF-8 编码方式进行转换。接着，使用 BufferedReader 包装字符流，提高读取效率。然后，创建 FileOutputStream 用于输出文件，使用 UTF-8 编码方式进行创建。接着，使用 OutputStreamWriter 将输出流转换为字符流，使用 UTF-8 编码方式进行转换。最后，使用 BufferedWriter 包装转换流，提高写入效率。</p>
<p><strong>06、小结 </strong></p>
<p>InputStreamReader 和 OutputStreamWriter 是将字节流转换为字符流或者将字符流转换为字节流。通常用于解决字节流和字符流之间的转换问题，可以将字节流以指定的字符集编码方式转换为字符流，或者将字符流以指定的字符集编码方式转换为字节流。</p>
<p>InputStreamReader 类的常用方法包括：</p>
<ul>
<li>read() ：从输入流中读取一个字符的数据。</li>
<li>read(char[] cbuf, int off, int len) ：从输入流中读取 len 个字符的数据到指定的字符数组 cbuf 中，从 off 位置开始存放。</li>
<li>ready() ：返回此流是否已准备好读取。</li>
<li>close() ：关闭输入流。</li>
</ul>
<p>OutputStreamWriter 类的常用方法包括：</p>
<ul>
<li>write(int c) ：向输出流中写入一个字符的数据。</li>
<li>write(char[] cbuf, int off, int len) ：向输出流中写入指定字符数组 cbuf 中的 len 个字符，从 off 位置开始。</li>
<li>flush() ：将缓冲区的数据写入输出流中。</li>
<li>close() ：关闭输出流。</li>
</ul>
<p>在使用转换流时，需要指定正确的字符集编码方式，否则可能会导致数据读取或写入出现乱码。</p>
<h2 id="5-7-打印流"><a href="#5-7-打印流" class="headerlink" title="5.7 打印流"></a>5.7 打印流</h2><p>在我的职业生涯中， System.out.println() 的使用频率恐怕不亚于 main 方法的使用频率。其中 System.out 返回的正是打印流 PrintStream 。</p>
<p>除此之外，还有它还有一个孪生兄弟，PrintWriter。PrintStream 是 OutputStream 的子类，PrintWriter 是 Writer 的子类，也就是说，一个字节流，一个是字符流。</p>
<p>打印流具有以下几个特点：</p>
<ul>
<li>可以自动进行数据类型转换：打印流可以将各种数据类型转换为字符串，并输出到指定的输出流中。</li>
<li>可以自动进行换行操作：打印流可以在输出字符串的末尾自动添加换行符，方便输出多个字符串时的格式控制。</li>
<li>可以输出到控制台或者文件中：打印流可以将数据输出到控制台或者文件中，方便调试和日志记录（尽管生产环境下更推荐使用 Logback、ELK 等）。</li>
</ul>
<p>PrintStream 类的常用方法包括：</p>
<ul>
<li>print() ：输出一个对象的字符串表示形式。</li>
<li>println() ：输出一个对象的字符串表示形式，并在末尾添加一个换行符。</li>
<li>printf() ：使用指定的格式字符串和参数输出格式化的字符串。</li>
</ul>
<p>来一个示例体验一下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PrintStream ps = System.out;</span><br><span class="line">ps.println(&quot;沉默王二&quot;);</span><br><span class="line">ps.print(&quot;沉 &quot;);</span><br><span class="line">ps.print(&quot;默 &quot;);</span><br><span class="line">ps.print(&quot;王 &quot;);</span><br><span class="line">ps.print(&quot;二 &quot;);</span><br><span class="line">ps.println();</span><br><span class="line">ps.printf(&quot;姓名：%s，年龄：%d，成绩：%f&quot;, &quot;沉默王二&quot;, 18, 99.9);</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们创建了一个 PrintStream 对象 ps，它输出到控制台。我们使用 ps 的 print 和 println 方法输出了一些字符串。</p>
<p>使用 printf 方法输出了一个格式化字符串，其中 %s、%d 和 %.2f 分别表示字符串、整数和浮点数的格式化输出。我们使用逗号分隔的参数列表指定了要输出的值。</p>
<p>来详细说说 printf 方法哈。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public PrintStream printf(String format, Object... args);</span><br></pre></td></tr></table></figure>
<p>其中，format 参数是格式化字符串，args 参数是要输出的参数列表。格式化字符串包含了普通字符和转换说明符。普通字符是指除了转换说明符之外的字符，它们在输出时直接输出。转换说明符是由百分号（%）和一个或多个字符组成的，用于指定输出的格式和数据类型。</p>
<p>下面是 Java 的常用转换说明符及对应的输出格式：</p>
<ul>
<li>%s ：输出一个字符串。</li>
<li>%d 或 %i ：输出一个十进制整数。</li>
<li>%x 或 %X ：输出一个十六进制整数， %x 输出小写字母， %X 输出大写字母。</li>
<li>%f 或 %F ：输出一个浮点数。</li>
<li>%e 或 %E ：输出一个科学计数法表示的浮点数， %e 输出小写字母 e， %E 输出大写字母 E。</li>
<li>%g 或 %G ：输出一个浮点数，自动选择 %f 或 %e/%E 格式输出。</li>
<li>%c ：输出一个字符。</li>
<li>%b ：输出一个布尔值。</li>
<li>%h ：输出一个哈希码（16进制）。</li>
<li>%n ：换行符。</li>
</ul>
<p>除了转换说明符之外，Java 的 printf 方法还支持一些修饰符，用于指定输出的宽度、精度、对齐方式等。</p>
<ul>
<li>宽度修饰符：用数字指定输出的最小宽度，如果输出的数据不足指定宽度，则在左侧或右侧填充空格或零。</li>
<li>精度修饰符：用点号（.）和数字指定浮点数或字符串的精度，对于浮点数，指定小数点后的位数，对于字符串，指定输出的字符数。</li>
<li>对齐修饰符：用减号（-）或零号（0）指定输出的对齐方式，减号表示左对齐，零号表示右对齐并填充零。</li>
</ul>
<p>下面是一些示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int num = 123;</span><br><span class="line">System.out.printf(&quot;%5d\n&quot;, num); // 输出 &quot;  123&quot;</span><br><span class="line">System.out.printf(&quot;%-5d\n&quot;, num); // 输出 &quot;123  &quot;</span><br><span class="line">System.out.printf(&quot;%05d\n&quot;, num); // 输出 &quot;00123&quot;</span><br><span class="line">double pi = Math.PI;</span><br><span class="line">System.out.printf(&quot;%10.2f\n&quot;, pi); // 输出 &quot;      3.14&quot;</span><br><span class="line">System.out.printf(&quot;%-10.4f\n&quot;, pi); // 输出 &quot;3.1416    &quot;</span><br><span class="line">String name = &quot;沉默王二&quot;;</span><br><span class="line">System.out.printf(&quot;%10s\n&quot;, name); // 输出 &quot;     沉默王二&quot;</span><br><span class="line">System.out.printf(&quot;%-10s\n&quot;, name); // 输出 &quot;沉默王二     &quot;</span><br></pre></td></tr></table></figure>
<p>具体来说，</p>
<ul>
<li>我们使用 %5d 来指定输出的整数占据 5 个字符的宽度，不足部分在左侧填充空格。</li>
<li>使用 %-5d 来指定输出的整数占据 5 个字符的宽度，不足部分在右侧填充空格。</li>
<li>使用 %05d 来指定输出的整数占据 5 个字符的宽度，不足部分在左侧填充 0。</li>
<li>使用 %10.2f 来指定输出的浮点数占据 10 个字符的宽度，保留 2 位小数，不足部分在左侧填充空格。</li>
<li>使用 %-10.4f 来指定输出的浮点数占据 10 个字符的宽度，保留 4 位小数，不足部分在右侧填充空格。</li>
<li>使用 %10s 来指定输出的字符串占据 10 个字符的宽度，不足部分在左侧填充空格。</li>
<li>使用 %-10s 来指定输出的字符串占据 10 个字符的宽度，不足部分在右侧填充空格。</li>
</ul>
<p>接下来，我们给出一个 PrintWriter 的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PrintWriter writer = new PrintWriter(new FileWriter(&quot;output.txt&quot;));</span><br><span class="line">writer.println(&quot;沉默王二&quot;);</span><br><span class="line">writer.printf(&quot;他的年纪为 %d.\n&quot;, 18);</span><br><span class="line">writer.close();</span><br></pre></td></tr></table></figure>
<p>首先，我们创建一个 PrintWriter 对象，它的构造函数接收一个 Writer 对象作为参数。在这里，我们使用 FileWriter 来创建一个输出文件流，并将其作为参数传递给 PrintWriter 的构造函数。然后，我们使用 PrintWriter 的 println 和 printf 方法来输出两行内容，其中 printf 方法可以接收格式化字符串。最后，我们调用 PrintWriter 的 close 方法来关闭输出流。</p>
<p>我们也可以不创建 FileWriter 对象，直接指定文件名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PrintWriter pw = new PrintWriter(&quot;output.txt&quot;);</span><br><span class="line">pw.println(&quot;沉默王二&quot;);</span><br><span class="line">pw.printf(&quot;他的年纪为 %d.\n&quot;, 18);</span><br><span class="line">pw.close();</span><br></pre></td></tr></table></figure>
<p>好，关于打印流我们就说这么多，比较简单。至于 printf 的一些规则，用到的时候可以再查使用说明或者看 API 文档就可以了，记不住没关系。</p>
<h2 id="5-8-序列流-序列化和反序列化"><a href="#5-8-序列流-序列化和反序列化" class="headerlink" title="5.8 序列流(序列化和反序列化)"></a>5.8 序列流(序列化和反序列化)</h2><p>Java 的序列流（ObjectInputStream 和 ObjectOutputStream）是一种可以将 Java 对象序列化和反序列化的流。</p>
<p>序列化是指将一个对象转换为一个字节序列（包含对象的数据 、对象的类型和对象中存储的属性等信息），以便在网络上传输或保存到文件中，或者在程序之间传递。在 Java 中，序列化通过实现 java.io.Serializable 接口来实现，只有实现了 Serializable 接口的对象才能被序列化。</p>
<p>反序列化是指将一个字节序列转换为一个对象，以便在程序中使用。</p>
<p><img src="\assets\note\image-20231011110758602.png" alt="image-20231011110758602"></p>
<p><strong>01、ObjectOutputStream </strong></p>
<p>java.io.ObjectOutputStream 继承自 OutputStream 类，因此可以将序列化后的字节序列写入到文件、网络等输出流中。</p>
<p>来看 ObjectOutputStream 的构造方法： </p>
<p>ObjectOutputStream(OutputStream out)</p>
<p>该构造方法接收一个 OutputStream 对象作为参数，用于将序列化后的字节序列输出到指定的输出流中。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fos = new FileOutputStream(&quot;file.txt&quot;);</span><br><span class="line">ObjectOutputStream oos = new ObjectOutputStream(fos);</span><br></pre></td></tr></table></figure>
<p>一个对象要想序列化，必须满足两个条件:</p>
<ul>
<li>该类必须实现 java.io.Serializable 接口，否则会抛出 NotSerializableException 。</li>
<li>该类的所有字段都必须是可序列化的。如果一个字段不需要序列化，则需要使用 transient 关键字进行修饰。</li>
</ul>
<p>使用示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Employee implements Serializable &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    public String address;</span><br><span class="line">    public transient int age; // transient瞬态修饰成员,不会被序列化</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，来聊聊 writeObject (Object obj) 方法，该方法是 ObjectOutputStream 类中用于将对象序列化成字节序列并输出到输出流中的方法，可以处理对象之间的引用关系、继承关系、静态字段和 transient 字段。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class ObjectOutputStreamDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person person = new Person(&quot;沉默王二&quot;, 20);</span><br><span class="line">        try &#123;</span><br><span class="line">            FileOutputStream fos = new FileOutputStream(&quot;logs/person.dat&quot;);</span><br><span class="line">            ObjectOutputStream oos = new ObjectOutputStream(fos);</span><br><span class="line">            oos.writeObject(person);</span><br><span class="line">            oos.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Person implements Serializable &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    public Person(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中，首先创建了一个 Person 对象，然后使用 FileOutputStream 和 ObjectOutputStream 将 Person 对象序列化并输出到 person.dat 文件中。在 Person 类中，实现了 Serializable 接口，表示该类可以进行对象序列化。</p>
<p><strong>02、ObjectInputStream </strong></p>
<p>ObjectInputStream 可以读取 ObjectOutputStream 写入的字节流，并将其反序列化为相应的对象（包含对象的数据 、对象的类型和对象中存储的属性等信息）。</p>
<p>说简单点就是，序列化之前是什么样子，反序列化后就是什么样子。</p>
<p>来看一下构造方法： ObjectInputStream(InputStream in) ： 创建一个指定 InputStream 的 ObjectInputStream。</p>
<p>其中，ObjectInputStream 的 readObject 方法用来读取指定文件中的对象，示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String filename = &quot;logs/person.dat&quot;; // 待反序列化的文件名</span><br><span class="line">try (FileInputStream fileIn = new FileInputStream(filename);</span><br><span class="line">     ObjectInputStream in = new ObjectInputStream(fileIn)) &#123;</span><br><span class="line">     // 从指定的文件输入流中读取对象并反序列化</span><br><span class="line">     Object obj = in.readObject();</span><br><span class="line">     // 将反序列化后的对象强制转换为指定类型</span><br><span class="line">     Person p = (Person) obj;</span><br><span class="line">     // 打印反序列化后的对象信息</span><br><span class="line">     System.out.println(&quot;Deserialized Object: &quot; + p);</span><br><span class="line">&#125; catch (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">     e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们首先指定了待反序列化的文件名（前面通过 ObjectOutputStream 序列化后的文件），然后创建了一个 FileInputStream 对象和一个 ObjectInputStream 对象。接着我们调用 ObjectInputStream 的 readObject 方法来读取指定文件中的对象，并将其强制转换为 Person 类型。最后我们打印了反序列化后的对象信息。</p>
<p><strong>03、Kryo </strong></p>
<p>实际开发中，很少使用 JDK 自带的序列化和反序列化，这是因为：</p>
<ul>
<li>可移植性差：Java 特有的，无法跨语言进行序列化和反序列化。</li>
<li>性能差：序列化后的字节体积大，增加了传输/保存成本。</li>
<li>安全问题：攻击者可以通过构造恶意数据来实现远程代码执行，从而对系统造成严重的安全威胁。相关阅读：Java 反序列化漏洞之殇 。</li>
</ul>
<p>Kryo 是一个优秀的 Java 序列化和反序列化库，具有高性能、高效率和易于使用和扩展等特点，有效地解决了 JDK 自带的序列化机制的痛点。</p>
<blockquote>
<p>GitHub 地址：<a target="_blank" rel="noopener" href="https://github.com/EsotericSoftware/kryo">https://github.com/EsotericSoftware/kryo</a></p>
</blockquote>
<p>使用示例：</p>
<p>第一步，在 pom.xml 中引入依赖。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 引入 Kryo 序列化工具 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;com.esotericsoftware&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;kryo&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;5.4.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>第二步，创建一个 Kryo 对象，并使用 register() 方法将对象进行注册。然后，使用 writeObject() 方法将 Java 对象序列化为二进制流，再使用 readObject() 方法将二进制流反序列化为 Java 对象。最后，输出反序列化后的 Java 对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public class KryoDemo &#123;</span><br><span class="line">    public static void main(String[] args) throws FileNotFoundException &#123;</span><br><span class="line">        Kryo kryo = new Kryo();</span><br><span class="line">        kryo.register(KryoParam.class);</span><br><span class="line">        KryoParam object = new KryoParam(&quot;沉默王二&quot;, 123);</span><br><span class="line">        Output output = new Output(new FileOutputStream(&quot;logs/kryo.bin&quot;));</span><br><span class="line">        kryo.writeObject(output, object);</span><br><span class="line">        output.close();</span><br><span class="line">        Input input = new Input(new FileInputStream(&quot;logs/kryo.bin&quot;));</span><br><span class="line">        KryoParam object2 = kryo.readObject(input, KryoParam.class);</span><br><span class="line">        System.out.println(object2);</span><br><span class="line">        input.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class KryoParam &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    public KryoParam() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public KryoParam(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;KryoParam&#123;&quot; +</span><br><span class="line">                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, age=&quot; + age +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>04、小结 </strong></p>
<p>本节我们介绍了 Java 的序列化机制，并推荐了一款高性能的 Java 类库 Kryo 来取代 JDK 自带的序列化机<br>制，已经在 Twitter、Groupon、Yahoo 以及多个著名开源项目（如 Hive、Storm）中广泛使用。以上，希望能帮助到大家。</p>
<h2 id="5-9-序列接口Serializable"><a href="#5-9-序列接口Serializable" class="headerlink" title="5.9 序列接口Serializable"></a>5.9 序列接口Serializable</h2><p>对于 Java 的序列化，我之前一直停留在最浅层次的认知上——把那个要序列化的类实现 Serializbale 接口就可以了嘛。</p>
<p>我似乎不愿意做更深入的研究，因为会用就行了嘛。</p>
<p>但随着时间的推移，见到 Serializbale 的次数越来越多，我便对它产生了浓厚的兴趣。是时候花点时间研究研究了。</p>
<p><strong>01、先来点理论 </strong></p>
<p>Java 序列化是 JDK 1.1 时引入的一组开创性的特性，用于将 Java 对象转换为字节数组，便于存储或传输。此后，仍然可以将字节数组转换回 Java 对象原有的状态。</p>
<p>序列化的思想是“冻结”对象状态，然后写到磁盘或者在网络中传输；反序列化的思想是“解冻”对象状态，重新获得可用的 Java 象。</p>
<p>序列化有一条规则，就是要序列化的对象必须实现 Serializbale 接口，否则就会报 NotSerializableException 异常。</p>
<p>好，来看看 Serializbale 接口的定义吧：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public interface Serializable &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没别的了！</p>
<p>明明就一个空的接口嘛，竟然能够保证实现了它的“类对象”被序列化和反序列化？</p>
<p><strong>02、再来点实战 </strong></p>
<p>在回答上述问题之前，我们先来创建一个类（只有两个字段，和对应的 getter/setter ），用于序列化和反序列化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Wanger &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来创建一个测试类，通过 ObjectOutputStream 将“18 岁的王二”写入到文件当中，实际上就是一种序列化的过程；再通过 ObjectInputStream 将“18 岁的王二”从文件中读出来，实际上就是一种反序列化的过程。（前面我们学习序列流的时候也讲过）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 初始化</span><br><span class="line">Wanger wanger = new Wanger();</span><br><span class="line">wanger.setName(&quot;王二&quot;);</span><br><span class="line">wanger.setAge(18);</span><br><span class="line">System.out.println(wanger);</span><br><span class="line">// 把对象写到文件中</span><br><span class="line">try (ObjectOutputStream oos = new ObjectOutputStream(new </span><br><span class="line">FileOutputStream(&quot;chenmo&quot;));)&#123;</span><br><span class="line">    oos.writeObject(wanger);</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">// 从文件中读出对象</span><br><span class="line">try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(new </span><br><span class="line">File(&quot;chenmo&quot;)));)&#123;</span><br><span class="line">    Wanger wanger1 = (Wanger) ois.readObject();</span><br><span class="line">    System.out.println(wanger1);</span><br><span class="line">&#125; catch (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过，由于 Wanger 没有实现 Serializbale 接口，所以在运行测试类的时候会抛出异常，堆栈信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.io.NotSerializableException: com.cmower.java_demo.xuliehua.Wanger</span><br><span class="line">    at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1184)</span><br><span class="line">    at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:348)</span><br><span class="line">    at com.cmower.java_demo.xuliehua.Test.main(Test.java:21)</span><br></pre></td></tr></table></figure>
<p>顺着堆栈信息，我们来看一下 ObjectOutputStream 的 writeObject0() 方法。其部分源码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 判断对象是否为字符串类型，如果是，则调用 writeString 方法进行序列化</span><br><span class="line">if (obj instanceof String) &#123;</span><br><span class="line">    writeString((String) obj, unshared);</span><br><span class="line">&#125;</span><br><span class="line">// 判断对象是否为数组类型，如果是，则调用 writeArray 方法进行序列化</span><br><span class="line">else if (cl.isArray()) &#123;</span><br><span class="line">    writeArray(obj, desc, unshared);</span><br><span class="line">&#125;</span><br><span class="line">// 判断对象是否为枚举类型，如果是，则调用 writeEnum 方法进行序列化</span><br><span class="line">else if (obj instanceof Enum) &#123;</span><br><span class="line">    writeEnum((Enum&lt;?&gt;) obj, desc, unshared);</span><br><span class="line">&#125;</span><br><span class="line">// 判断对象是否为可序列化类型，如果是，则调用 writeOrdinaryObject 方法进行序列化</span><br><span class="line">else if (obj instanceof Serializable) &#123;</span><br><span class="line">    writeOrdinaryObject(obj, desc, unshared);</span><br><span class="line">&#125;</span><br><span class="line">// 如果对象不能被序列化，则抛出 NotSerializableException 异常</span><br><span class="line">else &#123;</span><br><span class="line">if (extendedDebugInfo) &#123;</span><br><span class="line">    throw new NotSerializableException(</span><br><span class="line">        cl.getName() + &quot;\n&quot; + debugInfoStack.toString());</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    throw new NotSerializableException(cl.getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说， ObjectOutputStream 在序列化的时候，会判断被序列化的对象是哪一种类型，字符串？数组？枚举？还是 Serializable ，如果全都不是的话，抛出 NotSerializableException 。</p>
<p>假如 Wanger 实现了 Serializable 接口，就可以序列化和反序列化了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Wanger implements Serializable&#123;</span><br><span class="line">    private static final long serialVersionUID = -2095916884810199532L;</span><br><span class="line">    </span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体怎么序列化呢？</p>
<p>以 ObjectOutputStream 为例吧，它在序列化的时候会依次调用 writeObject() → writeObject0() → writeOrdinaryObject() → writeSerialData() → invokeWriteObject() → defaultWriteFields() 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private void defaultWriteFields(Object obj, ObjectStreamClass desc) throws </span><br><span class="line">IOException &#123;</span><br><span class="line">    // 获取对象的类，并检查是否可以进行默认的序列化</span><br><span class="line">    Class&lt;?&gt; cl = desc.forClass();</span><br><span class="line">    desc.checkDefaultSerialize();</span><br><span class="line">    // 获取对象的基本类型字段的数量，以及这些字段的值</span><br><span class="line">    int primDataSize = desc.getPrimDataSize();</span><br><span class="line">    desc.getPrimFieldValues(obj, primVals);</span><br><span class="line">    // 将基本类型字段的值写入输出流</span><br><span class="line">    bout.write(primVals, 0, primDataSize, false);</span><br><span class="line">    // 获取对象的非基本类型字段的值</span><br><span class="line">    ObjectStreamField[] fields = desc.getFields(false);</span><br><span class="line">    Object[] objVals = new Object[desc.getNumObjFields()];</span><br><span class="line">    int numPrimFields = fields.length - objVals.length;</span><br><span class="line">    desc.getObjFieldValues(obj, objVals);</span><br><span class="line">    // 循环写入对象的非基本类型字段的值</span><br><span class="line">    for (int i = 0; i &lt; objVals.length; i++) &#123;</span><br><span class="line">        // 调用 writeObject0 方法将对象的非基本类型字段序列化写入输出流</span><br><span class="line">        try &#123;</span><br><span class="line">            writeObject0(objVals[i], fields[numPrimFields + i].isUnshared());</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果在写入过程中出现异常，则将异常包装成 IOException 抛出</span><br><span class="line">        catch (IOException ex) &#123;</span><br><span class="line">            if (abortIOException == null) &#123;</span><br><span class="line">                abortIOException = ex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那怎么反序列化呢？</p>
<p>以 ObjectInputStream 为例，它在反序列化的时候会依次调用 readObject() → readObject0() → readOrdinaryObject() → readSerialData() → defaultReadFields() 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">private void defaultReadFields(Object obj, ObjectStreamClass desc) throws </span><br><span class="line">IOException &#123;</span><br><span class="line">    // 获取对象的类，并检查对象是否属于该类</span><br><span class="line">    Class&lt;?&gt; cl = desc.forClass();</span><br><span class="line">    if (cl != null &amp;&amp; obj != null &amp;&amp; !cl.isInstance(obj)) &#123;</span><br><span class="line">        throw new ClassCastException();</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取对象的基本类型字段的数量和值</span><br><span class="line">    int primDataSize = desc.getPrimDataSize();</span><br><span class="line">    if (primVals == null || primVals.length &lt; primDataSize) &#123;</span><br><span class="line">        primVals = new byte[primDataSize];</span><br><span class="line">    &#125;</span><br><span class="line">    // 从输入流中读取基本类型字段的值，并存储在 primVals 数组中</span><br><span class="line">    bin.readFully(primVals, 0, primDataSize, false);</span><br><span class="line">    if (obj != null) &#123;</span><br><span class="line">        // 将 primVals 数组中的基本类型字段的值设置到对象的相应字段中</span><br><span class="line">        desc.setPrimFieldValues(obj, primVals);</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取对象的非基本类型字段的数量和值</span><br><span class="line">    int objHandle = passHandle;</span><br><span class="line">    ObjectStreamField[] fields = desc.getFields(false);</span><br><span class="line">    Object[] objVals = new Object[desc.getNumObjFields()];</span><br><span class="line">    int numPrimFields = fields.length - objVals.length;</span><br><span class="line">    // 循环读取对象的非基本类型字段的值</span><br><span class="line">    for (int i = 0; i &lt; objVals.length; i++) &#123;</span><br><span class="line">        // 调用 readObject0 方法读取对象的非基本类型字段的值</span><br><span class="line">        ObjectStreamField f = fields[numPrimFields + i];</span><br><span class="line">        objVals[i] = readObject0(Object.class, f.isUnshared());</span><br><span class="line">        // 如果该字段是一个引用字段，则将其标记为依赖该对象</span><br><span class="line">        if (f.getField() != null) &#123;</span><br><span class="line">            handles.markDependency(objHandle, passHandle);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (obj != null) &#123;</span><br><span class="line">        // 将 objVals 数组中的非基本类型字段的值设置到对象的相应字段中</span><br><span class="line">        desc.setObjFieldValues(obj, objVals);</span><br><span class="line">    &#125;</span><br><span class="line">    passHandle = objHandle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我想看到这，你应该会恍然大悟的“哦”一声了。 Serializable 接口之所以定义为空，是因为它只起到了一个标识的作用，告诉程序实现了它的对象是可以被序列化的，但真正序列化和反序列化的操作并不需要它来完成。</p>
<p><strong>03、再来点注意事项 </strong></p>
<p>开门见山的说吧， static 和 transient 修饰的字段是不会被序列化的。</p>
<p>为什么呢？我们先来证明，再来解释原因。</p>
<p>首先，在 Wanger 类中增加两个字段。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Wanger implements Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = -2095916884810199532L;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    public static String pre = &quot;沉默&quot;;</span><br><span class="line">    transient String meizi = &quot;王三&quot;;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Wanger&#123;&quot; + &quot;name=&quot; + name + &quot;,age=&quot; + age + &quot;,pre=&quot; + pre + </span><br><span class="line">&quot;,meizi=&quot; + meizi + &quot;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其次，在测试类中打印序列化前和反序列化后的对象，并在序列化后和反序列化前改变 static 字段的值。</p>
<p>具体代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 初始化</span><br><span class="line">Wanger wanger = new Wanger();</span><br><span class="line">wanger.setName(&quot;王二&quot;);</span><br><span class="line">wanger.setAge(18);</span><br><span class="line">System.out.println(wanger);</span><br><span class="line">// 把对象写到文件中</span><br><span class="line">try (ObjectOutputStream oos = new ObjectOutputStream(new </span><br><span class="line">FileOutputStream(&quot;chenmo&quot;));)&#123;</span><br><span class="line">        oos.writeObject(wanger);</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    // 改变 static 字段的值</span><br><span class="line">Wanger.pre =&quot;不沉默&quot;;</span><br><span class="line">// 从文件中读出对象</span><br><span class="line">try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(new </span><br><span class="line">File(&quot;chenmo&quot;)));)&#123;</span><br><span class="line">    Wanger wanger1 = (Wanger) ois.readObject();</span><br><span class="line">    System.out.println(wanger1);</span><br><span class="line">&#125; catch (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Wanger&#123;name=王二,age=18,pre=沉默,meizi=王三&#125;</span><br><span class="line">Wanger&#123;name=王二,age=18,pre=不沉默,meizi=null&#125;</span><br></pre></td></tr></table></figure>
<p>从结果的对比当中，我们可以发现：</p>
<p>1）序列化前， pre 的值为“沉默”，序列化后， pre 的值修改为“不沉默”，反序列化后， pre 的值为“不沉默”，而不是序列化前的状态“沉默”。</p>
<p>为什么呢？因为序列化保存的是对象的状态，而 static 修饰的字段属于类的状态，因此可以证明序列化并不保存 static 修饰的字段。</p>
<p>2）序列化前， meizi 的值为“王三”，反序列化后， meizi 的值为 null ，而不是序列化前的状态“王三”。</p>
<p>为什么呢？ transient 的中文字义为“临时的”（论英语的重要性），它可以阻止字段被序列化到文件中，在被反序列化后， transient 字段的值被设为初始值，比如 int 型的初始值为 0，对象型的初始值为 null 。</p>
<p>如果想要深究源码的话，你可以在 ObjectStreamClass 中发现下面这样的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private static ObjectStreamField[] getDefaultSerialFields(Class&lt;?&gt; cl) &#123;</span><br><span class="line">    // 获取该类中声明的所有字段</span><br><span class="line">    Field[] clFields = cl.getDeclaredFields();</span><br><span class="line">    ArrayList&lt;ObjectStreamField&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">    int mask = Modifier.STATIC | Modifier.TRANSIENT;</span><br><span class="line">    // 遍历所有字段，将非 static 和 transient 的字段添加到 list 中</span><br><span class="line">    for (int i = 0; i &lt; clFields.length; i++) &#123;</span><br><span class="line">        Field field = clFields[i];</span><br><span class="line">        int mods = field.getModifiers();</span><br><span class="line">        if ((mods &amp; mask) == 0) &#123;</span><br><span class="line">            // 根据字段名、字段类型和字段是否可序列化创建一个 ObjectStreamField 对象</span><br><span class="line">            ObjectStreamField osf = new ObjectStreamField(field.getName(), </span><br><span class="line">field.getType(), !Serializable.class.isAssignableFrom(cl));</span><br><span class="line">            list.add(osf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int size = list.size();</span><br><span class="line">    // 如果 list 为空，则返回一个空的 ObjectStreamField 数组，否则将 list 转换为 </span><br><span class="line">ObjectStreamField 数组并返回</span><br><span class="line">    return (size == 0) ? NO_FIELDS :</span><br><span class="line">        list.toArray(new ObjectStreamField[size]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到 Modifier.STATIC | Modifier.TRANSIENT 了吧，这两个修饰符标记的字段就没有被放入到序列化的字段中，明白了吧？</p>
<p><strong>04、再来点干货 </strong></p>
<p>除了 Serializable 之外，Java 还提供了一个序列化接口 Externalizable （念起来有点拗口）。</p>
<p>两个接口有什么不一样的吗？试一试就知道了。</p>
<p>首先，把 Wanger 类实现的接口  Serializable 替换为 Externalizable 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Wanger implements Externalizable &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    public Wanger() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Wanger&#123;&quot; + &quot;name=&quot; + name + &quot;,age=&quot; + age + &quot;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void writeExternal(ObjectOutput out) throws IOException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void readExternal(ObjectInput in) throws IOException, </span><br><span class="line">ClassNotFoundException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现 Externalizable 接口的 Wanger 类和实现 Serializable 接口的 Wanger 类有一些不同：</p>
<p>1）新增了一个无参的构造方法。</p>
<p>使用 Externalizable 进行反序列化的时候，会调用被序列化类的无参构造方法去创建一个新的对象，然后再将被保存对象的字段值复制过去。否则的话，会抛出以下异常：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">java.io.InvalidClassException: com.cmower.java_demo.xuliehua1.Wanger; no valid </span><br><span class="line">constructor</span><br><span class="line">    at </span><br><span class="line">java.io.ObjectStreamClass$ExceptionInfo.newInvalidClassException(ObjectStreamClass.j</span><br><span class="line">ava:150)</span><br><span class="line">    at java.io.ObjectStreamClass.checkDeserialize(ObjectStreamClass.java:790)</span><br><span class="line">    at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:1782)</span><br><span class="line">    at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1353)</span><br><span class="line">    at java.io.ObjectInputStream.readObject(ObjectInputStream.java:373)</span><br><span class="line">    at com.cmower.java_demo.xuliehua1.Test.main(Test.java:27)</span><br></pre></td></tr></table></figure>
<p>2）新增了两个方法 writeExternal() 和 readExternal() ，实现 Externalizable 接口所必须的。</p>
<p>然后，我们再在测试类中打印序列化前和反序列化后的对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 初始化</span><br><span class="line">Wanger wanger = new Wanger();</span><br><span class="line">wanger.setName(&quot;王二&quot;);</span><br><span class="line">wanger.setAge(18);</span><br><span class="line">System.out.println(wanger);</span><br><span class="line">// 把对象写到文件中</span><br><span class="line">try (ObjectOutputStream oos = new ObjectOutputStream(new </span><br><span class="line">FileOutputStream(&quot;chenmo&quot;));) &#123;</span><br><span class="line">    oos.writeObject(wanger);</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">// 从文件中读出对象</span><br><span class="line">try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(new </span><br><span class="line">File(&quot;chenmo&quot;)));) &#123;</span><br><span class="line">    Wanger wanger1 = (Wanger) ois.readObject();</span><br><span class="line">    System.out.println(wanger1);</span><br><span class="line">&#125; catch (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">// Wanger&#123;name=王二,age=18&#125;</span><br><span class="line">// Wanger&#123;name=null,age=0&#125;</span><br></pre></td></tr></table></figure>
<p>从输出的结果看，反序列化后得到的对象字段都变成了默认值，也就是说，序列化之前的对象状态没有被“冻结”下来。</p>
<p>为什么呢？因为我们没有为 Wanger 类重写具体的 writeExternal() 和 readExternal() 方法。那该怎么重写呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void writeExternal(ObjectOutput out) throws IOException &#123;</span><br><span class="line">    out.writeObject(name);</span><br><span class="line">    out.writeInt(age);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException </span><br><span class="line">&#123;</span><br><span class="line">    name = (String) in.readObject();</span><br><span class="line">    age = in.readInt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1）调用 ObjectOutput 的 writeObject() 方法将字符串类型的 name 写入到输出流中；</p>
<p>2）调用 ObjectOutput 的 writeInt() 方法将整型的 age 写入到输出流中；</p>
<p>3）调用 ObjectInput 的 readObject() 方法将字符串类型的 name 读入到输入流中；</p>
<p>4）调用 ObjectInput 的 readInt() 方法将字符串类型的 age 读入到输入流中；</p>
<p>再运行一次测试了类，你会发现对象可以正常地序列化和反序列化了。</p>
<blockquote>
<p>序列化前：Wanger{name=王二,age=18} </p>
<p>序列化后：Wanger{name=王二,age=18}</p>
</blockquote>
<p>总结一下：</p>
<p>Externalizable 和 Serializable 都是用于实现 Java 对象的序列化和反序列化的接口，但是它们有以下区别：</p>
<p>①、Serializable 是 Java 标准库提供的接口，而 Externalizable 是 Serializable 的子接口；</p>
<p><img src="\assets\note\image-20231011112552567.png" alt="image-20231011112552567"></p>
<p>②、Serializable 接口不需要实现任何方法，只需要将需要序列化的类标记为 Serializable 即可，而 Externalizable 接口需要实现 writeExternal 和 readExternal 两个方法；</p>
<p>③、Externalizable 接口提供了更高的序列化控制能力，可以在序列化和反序列化过程中对对象进行自定义的处理，如对一些敏感信息进行加密和解密。</p>
<p><strong>05、再来点甜点 </strong></p>
<p>让我先问问你吧，你知道 private static final long serialVersionUID = -2095916884810199532L; 这段代码的作用吗？</p>
<p>嗯……</p>
<p>serialVersionUID 被称为序列化 ID，它是决定 Java 对象能否反序列化成功的重要因子。在反序列化时，Java 虚拟机会把字节流中的 serialVersionUID 与被序列化类中的 serialVersionUID 进行比较，如果相同则可以进行反序列化，否则就会抛出序列化版本不一致的异常。</p>
<p>当一个类实现了 Serializable 接口后，IDE 就会提醒该类最好产生一个序列化 ID，就像下面这样：</p>
<p><img src="\assets\note\image-20231011112646445.png" alt="image-20231011112646445"></p>
<p>1）添加一个默认版本的序列化 ID：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final long serialVersionUID = 1L。</span><br></pre></td></tr></table></figure>
<p>2）添加一个随机生成的不重复的序列化 ID。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final long serialVersionUID = -2095916884810199532L;</span><br></pre></td></tr></table></figure>
<p>3）添加 @SuppressWarnings 注解。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&quot;serial&quot;)</span><br></pre></td></tr></table></figure>
<p>怎么选择呢？</p>
<p>首先，我们采用第二种办法，在被序列化类中添加一个随机生成的序列化 ID。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Wanger implements Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = -2095916884810199532L;</span><br><span class="line">    </span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    // 其他代码忽略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，序列化一个 Wanger 对象到文件中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 初始化</span><br><span class="line">Wanger wanger = new Wanger();</span><br><span class="line">wanger.setName(&quot;王二&quot;);</span><br><span class="line">wanger.setAge(18);</span><br><span class="line">System.out.println(wanger);</span><br><span class="line">// 把对象写到文件中</span><br><span class="line">try (ObjectOutputStream oos = new ObjectOutputStream(new </span><br><span class="line">FileOutputStream(&quot;chenmo&quot;));) &#123;</span><br><span class="line">    oos.writeObject(wanger);</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候，我们悄悄地把 Wanger 类的序列化 ID 偷梁换柱一下，嘿嘿。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// private static final long serialVersionUID = -2095916884810199532L;</span><br><span class="line">private static final long serialVersionUID = -2095916884810199533L;</span><br></pre></td></tr></table></figure>
<p>好了，准备反序列化吧。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(new </span><br><span class="line">File(&quot;chenmo&quot;)));) &#123;</span><br><span class="line">    Wanger wanger = (Wanger) ois.readObject();</span><br><span class="line">    System.out.println(wanger);</span><br><span class="line">&#125; catch (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>哎呀，出错了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.io.InvalidClassException:  local class incompatible: stream classdesc </span><br><span class="line">serialVersionUID = -2095916884810199532,</span><br><span class="line">local class serialVersionUID = -2095916884810199533</span><br><span class="line">    at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1521)</span><br><span class="line">    at com.cmower.java_demo.xuliehua1.Test.main(Test.java:27)</span><br></pre></td></tr></table></figure>
<p>异常堆栈信息里面告诉我们，从持久化文件里面读取到的序列化 ID 和本地的序列化 ID 不一致，无法反序列化。</p>
<p>那假如我们采用第三种方法，为 Wanger 类添加个 @SuppressWarnings(“serial”) 注解呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&quot;serial&quot;)</span><br><span class="line">class Wanger implements Serializable &#123;</span><br><span class="line">// 省略其他代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，再来一次反序列化吧。可惜依然报错。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.io.InvalidClassException:  local class incompatible: stream classdesc </span><br><span class="line">serialVersionUID = -2095916884810199532, </span><br><span class="line">local class serialVersionUID = -3818877437117647968</span><br><span class="line">    at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1521)</span><br><span class="line">    at com.cmower.java_demo.xuliehua1.Test.main(Test.java:27)</span><br></pre></td></tr></table></figure>
<p>异常堆栈信息里面告诉我们，本地的序列化 ID 为 -3818877437117647968，和持久化文件里面读取到的序列化 ID 仍然不一致，无法反序列化。这说明什么呢？使用 @SuppressWarnings(“serial”) 注解时，该注解会为被序列化类自动生成一个随机的序列化 ID。</p>
<p>由此可以证明，Java 虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，还有一个非常重要的因素就是序列化 ID 是否一致。</p>
<p>也就是说，如果没有特殊需求，采用默认的序列化 ID（1L）就可以，这样可以确保代码一致时反序列化成功。</p>
<p><strong>06、再来点总结 </strong></p>
<p>写这篇文章之前，我真没想到：“空空其身”的 Serializable 竟然有这么多可以研究的内容！</p>
<p>写完这篇文章之后，我不由得想起理科状元曹林菁说说过的一句话：“在学习中再小的问题也不放过，每个知识点都要总结”——说得真真真真的对啊！</p>
<h2 id="5-10-transient关键字"><a href="#5-10-transient关键字" class="headerlink" title="5.10 transient关键字"></a>5.10 transient关键字</h2><p>害，小二最熟的是 Java，但很多 Java 基础知识都不知道，比如 transient 关键字以前就没用到过，所以不知道它的作用是什么，今天去招银面试的时候，面试官问到了这个：说说 Java 的 transient 关键字吧，结果小二直接懵逼了。</p>
<p>下面是他自己面试凉了以后回去做的总结，分享出来，大家一起涨下姿势~~~好了，废话不多说，下面开始：</p>
<p><strong>01、transient 的作用及使用方法 </strong></p>
<p>我们知道，一个对象只要实现了 Serilizable 接口，它就可以被序列化。</p>
<p>在实际开发过程中，我们常常会遇到这样的问题，一个类的有些字段需要序列化，有些字段不需要，比如说用户的一些敏感信息（如密码、银行卡号等），为了安全起见，不希望在网络操作中传输或者持久化到磁盘文件中，那这些字段就可以加上 transient 关键字。</p>
<p>需要注意的是，被 transient 关键字修饰的成员变量在反序列化时会被自动初始化为默认值，例如基本数据类型为 0，引用类型为 null。</p>
<p>来看示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">public class TransientTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        </span><br><span class="line">        User user = new User();</span><br><span class="line">        user.setUsername(&quot;沉默王二&quot;);</span><br><span class="line">        user.setPasswd(&quot;123456&quot;);</span><br><span class="line">        </span><br><span class="line">        System.out.println(&quot;read before Serializable: &quot;);</span><br><span class="line">        System.out.println(&quot;username: &quot; + user.getUsername());</span><br><span class="line">        System.err.println(&quot;password: &quot; + user.getPasswd());</span><br><span class="line">        </span><br><span class="line">        try &#123;</span><br><span class="line">            ObjectOutputStream os = new ObjectOutputStream(</span><br><span class="line">                    new FileOutputStream(&quot;user.txt&quot;));</span><br><span class="line">            os.writeObject(user); // 将User对象写进文件</span><br><span class="line">            os.flush();</span><br><span class="line">            os.close();</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            ObjectInputStream is = new ObjectInputStream(new FileInputStream(</span><br><span class="line">                    &quot;user.txt&quot;));</span><br><span class="line">            user = (User) is.readObject(); // 从流中读取User的数据</span><br><span class="line">            is.close();</span><br><span class="line">            </span><br><span class="line">            System.out.println(&quot;\nread after Serializable: &quot;);</span><br><span class="line">            System.out.println(&quot;username: &quot; + user.getUsername());</span><br><span class="line">            System.err.println(&quot;password: &quot; + user.getPasswd());</span><br><span class="line">            </span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class User implements Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = 8294180014912103005L;  </span><br><span class="line">    </span><br><span class="line">    private String username;</span><br><span class="line">    private transient String passwd;</span><br><span class="line">    </span><br><span class="line">    public String getUsername() &#123;</span><br><span class="line">        return username;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setUsername(String username) &#123;</span><br><span class="line">        this.username = username;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public String getPasswd() &#123;</span><br><span class="line">        return passwd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setPasswd(String passwd) &#123;</span><br><span class="line">        this.passwd = passwd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">read before Serializable:</span><br><span class="line">username: 沉默王二</span><br><span class="line">password: 123456 </span><br><span class="line">read after Serializable:</span><br><span class="line">username: 沉默王二</span><br><span class="line">password: null</span><br></pre></td></tr></table></figure>
<p>密码字段为 null，说明反序列化时根本没有从文件中获取到信息。</p>
<p><strong>02、transient 使用小结 </strong></p>
<p>1）一旦字段被 transient 修饰，成员变量将不再是对象持久化的一部分，该变量的值在序列化后无法访问。</p>
<p>2）transient 关键字只能修饰字段，而不能修饰方法和类。</p>
<p>3）被 transient 关键字修饰的字段不能被序列化，一个静态变量（static关键字修饰）不管是否被 transient 修饰，均不能被序列化，前面讲到过。</p>
<p>来看示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">public class TransientTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        </span><br><span class="line">        User user = new User();</span><br><span class="line">        user.setUsername(&quot;沉默王二&quot;);</span><br><span class="line">        user.setPasswd(&quot;123456&quot;);</span><br><span class="line">        </span><br><span class="line">        System.out.println(&quot;read before Serializable: &quot;);</span><br><span class="line">        System.out.println(&quot;username: &quot; + user.getUsername());</span><br><span class="line">        System.err.println(&quot;password: &quot; + user.getPasswd());</span><br><span class="line">        </span><br><span class="line">        try &#123;</span><br><span class="line">            ObjectOutputStream os = new ObjectOutputStream(</span><br><span class="line">                    new FileOutputStream(&quot;user.txt&quot;));</span><br><span class="line">            os.writeObject(user); // 将User对象写进文件</span><br><span class="line">            os.flush();</span><br><span class="line">            os.close();</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 在反序列化之前改变username的值</span><br><span class="line">            User.username = &quot;沉默王三&quot;;</span><br><span class="line">            </span><br><span class="line">            ObjectInputStream is = new ObjectInputStream(new FileInputStream(&quot;user.txt&quot;));</span><br><span class="line">            user = (User) is.readObject(); // 从流中读取User的数据</span><br><span class="line">            is.close();</span><br><span class="line">            </span><br><span class="line">            System.out.println(&quot;\nread after Serializable: &quot;);</span><br><span class="line">            System.out.println(&quot;username: &quot; + user.getUsername());</span><br><span class="line">            System.err.println(&quot;password: &quot; + user.getPasswd());</span><br><span class="line">            </span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class User implements Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = 8294180014912103005L;  </span><br><span class="line">    </span><br><span class="line">    public static String username;</span><br><span class="line">    private transient String passwd;</span><br><span class="line">    </span><br><span class="line">    public String getUsername() &#123;</span><br><span class="line">        return username;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setUsername(String username) &#123;</span><br><span class="line">        this.username = username;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public String getPasswd() &#123;</span><br><span class="line">        return passwd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setPasswd(String passwd) &#123;</span><br><span class="line">        this.passwd = passwd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">read before Serializable:</span><br><span class="line">username: 沉默王二</span><br><span class="line">password: 123456 </span><br><span class="line">read after Serializable:</span><br><span class="line">username: 沉默王三</span><br><span class="line">password: null</span><br></pre></td></tr></table></figure>
<p>序列化前，static 修饰的 username 为 沉默王二，然后我们在反序列化前将其修改为 沉默王三 了，如果说 static 修饰的字段能保持状态的话，反序列化后应该是 沉默王二，对吧？</p>
<p>但结果是 沉默王三，这就证明了我们之前的结论：<strong>static 修饰的字段不能被序列化。</strong></p>
<p><strong>03、transient 修饰的字段真的不能被序列化？ </strong></p>
<p>思考下面的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class ExternalizableTest implements Externalizable &#123;</span><br><span class="line">    private transient String content = &quot;是的，我将会被序列化，不管我是否被transient关键字修</span><br><span class="line">饰&quot;;</span><br><span class="line">    @Override</span><br><span class="line">    public void writeExternal(ObjectOutput out) throws IOException &#123;</span><br><span class="line">        out.writeObject(content);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void readExternal(ObjectInput in) throws IOException,</span><br><span class="line">            ClassNotFoundException &#123;</span><br><span class="line">        content = (String) in.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        </span><br><span class="line">        ExternalizableTest et = new ExternalizableTest();</span><br><span class="line">        ObjectOutput out = new ObjectOutputStream(new FileOutputStream(</span><br><span class="line">                new File(&quot;test&quot;)));</span><br><span class="line">        out.writeObject(et);</span><br><span class="line">        ObjectInput in = new ObjectInputStream(new FileInputStream(new File(</span><br><span class="line">                &quot;test&quot;)));</span><br><span class="line">        et = (ExternalizableTest) in.readObject();</span><br><span class="line">        System.out.println(et.content);</span><br><span class="line">        out.close();</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看下输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">是的，我将会被序列化，不管我是否被transient关键字修饰</span><br></pre></td></tr></table></figure>
<p>这是为什么呢？不是说 transient 关键字修饰的字段不能序列化吗？</p>
<p>我先说结论，这是因为我们使用了 Externalizable 接口而不是 Serializable接口，这个知识点我们前面其实也讲到过。</p>
<p>在 Java 中，对象的序列化可以通过实现两种接口来实现，如果实现的是 Serializable 接口，则所有的序列化将会自动进行，如果实现的是 Externalizable 接口，则需要在 writeExternal 方法中指定要序列化的字段，与 transient 关键字修饰无关。</p>
<p>因此例子输出的是变量 content 的内容，而不是 null。</p>
<p><strong>04、小结 </strong></p>
<p>transient 关键字用于修饰类的成员变量，在序列化对象时，被修饰的成员变量不会被序列化和保存到文件中。其作用是告诉 JVM 在序列化对象时不需要将该变量的值持久化，这样可以避免一些安全或者性能问题。但是，transient 修饰的成员变量在反序列化时会被初始化为其默认值（如 int 类型会被初始化为 0，引用类型会被初始化为 null），因此需要在程序中进行适当的处理。</p>
<p>transient 关键字和 static 关键字都可以用来修饰类的成员变量。其中，transient 关键字表示该成员变量不参与序列化和反序列化，而 static 关键字表示该成员变量是属于类的，不属于对象的，因此不需要序列化和反序列化。</p>
<p>在 Serializable 和 Externalizable 接口中，transient 关键字的表现也不同，在 Serializable 中表示该成员变量不参与序列化和反序列化，在 Externalizable 中不起作用，因为 Externalizable 接口需要实现 readExternal 和 writeExternal 方法，需要手动完成序列化和反序列化的过程。</p>
<h1 id="6-异常处理"><a href="#6-异常处理" class="headerlink" title="6 异常处理"></a>6 异常处理</h1><h2 id="6-1-Java异常处理全面解析"><a href="#6-1-Java异常处理全面解析" class="headerlink" title="6.1 Java异常处理全面解析"></a>6.1 Java异常处理全面解析</h2><p><strong>01、什么是异常 </strong></p>
<p>“二哥，今天就要学习异常了吗？”三妹问。</p>
<p>“是的。只有正确地处理好异常，才能保证程序的可靠性，所以异常的学习还是很有必要的。”我说。</p>
<p>“那到底什么是异常呢？”三妹问。</p>
<p>“异常是指中断程序正常执行的一个不确定的事件。当异常发生时，程序的正常执行流程就会被打断。一般情况下，程序都会有很多条语句，如果没有异常处理机制，前面的语句一旦出现了异常，后面的语句就没办法继续执行了。”</p>
<p>“有了异常处理机制后，程序在发生异常的时候就不会中断，我们可以对异常进行捕获，然后改变程序执行的流程。”</p>
<p>“除此之外，异常处理机制可以保证我们向用户提供友好的提示信息，而不是程序原生的异常信息——用户根本理解不了。”</p>
<p>“不过，站在开发者的角度，我们更希望看到原生的异常信息，因为这有助于我们更快地找到 bug 的根源，反而被过度包装的异常信息会干扰我们的视线。”</p>
<p>“Java 语言在一开始就提供了相对完善的异常处理机制，这种机制大大降低了编写可靠程序的门槛，这也是 Java 之所以能够流行的原因之一。”</p>
<p>“那导致程序抛出异常的原因有哪些呢？”三妹问。</p>
<p>比如说：</p>
<ul>
<li>程序在试图打开一个不存在的文件；</li>
<li>程序遇到了网络连接问题；</li>
<li>用户输入了糟糕的数据；</li>
<li>程序在处理算术问题时没有考虑除数为 0 的情况；</li>
</ul>
<p>等等等等。</p>
<p>挑个最简单的原因来说吧。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(10/0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码在运行的时候抛出的异常信息如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.ArithmeticException: / by zero</span><br><span class="line">    at com.itwanger.s41.Demo.main(Demo.java:8)</span><br></pre></td></tr></table></figure>
<p>“你看，三妹，这个原生的异常信息对用户来说，显然是不太容易理解的，但对于我们开发者来说，简直不要太直白了——很容易就能定位到异常发生的根源。”</p>
<p><strong>02、Exception和Error的区别 </strong></p>
<p>“哦，我知道了。下一个问题，我经常看到一些文章里提到 Exception 和 Error，二哥你能帮我解释一下它们之间的区别吗？”三妹问。</p>
<p>“这是一个好问题呀，三妹！”</p>
<p>从单词的释义上来看，error 为错误，exception 为异常，错误的等级明显比异常要高一些。</p>
<p>从程序的角度来看，也的确如此。</p>
<p>Error 的出现，意味着程序出现了严重的问题，而这些问题不应该再交给 Java 的异常处理机制来处理，程序应该直接崩溃掉，比如说 OutOfMemoryError，内存溢出了，这就意味着程序在运行时申请的内存大于系统能够提供的内存，导致出现的错误，这种错误的出现，对于程序来说是致命的。</p>
<p>Exception 的出现，意味着程序出现了一些在可控范围内的问题，我们应当采取措施进行挽救。</p>
<p>比如说之前提到的 ArithmeticException，很明显是因为除数出现了 0 的情况，我们可以选择捕获异常，然后提示用户不应该进行除 0 操作，当然了，更好的做法是直接对除数进行判断，如果是 0 就不进行除法运算，而是告诉用户换一个非 0 的数进行运算。</p>
<p><strong>03、checked和unchecked异常 </strong></p>
<p>“三妹，还能想到其他的问题吗？”</p>
<p>“嗯，不用想，二哥，我已经提前做好预习工作了。”三妹自信地说，“异常又可以分为 checked 和 unchecked，它们之间又有什么区别呢？”</p>
<p>“哇，三妹，果然又是一个好问题呢。”</p>
<p>checked 异常（检查型异常）在源代码里必须显式地捕获或者抛出，否则编译器会提示你进行相应的操作；而 unchecked 异常（非检查型异常）就是所谓的运行时异常，通常是可以通过编码进行规避的，并不需要显式地捕获或者抛出。</p>
<p>“我先画一幅思维导图给你感受一下。”</p>
<p><img src="\assets\note\image-20231011114343485.png" alt="image-20231011114343485"></p>
<p>首先，Exception 和 Error 都继承了 Throwable 类。换句话说，只有 Throwable 类（或者子类）的对象才能使用 throw 关键字抛出，或者作为 catch 的参数类型。</p>
<p>面试中经常问到的一个问题是，NoClassDefFoundError 和 ClassNotFoundException 有什么区别？</p>
<p>“三妹你知道吗？”</p>
<p>“不知道，二哥，你解释下呗。”</p>
<p>它们都是由于系统运行时找不到要加载的类导致的，但是触发的原因不一样。</p>
<ul>
<li>NoClassDefFoundError：程序在编译时可以找到所依赖的类，但是在运行时找不到指定的类文件，导致抛出该错误；原因可能是 jar 包缺失或者调用了初始化失败的类。</li>
<li>ClassNotFoundException：当动态加载 Class 对象的时候找不到对应的类时抛出该异常；原因可能是要加载的类不存在或者类名写错了。</li>
</ul>
<p>其次，像 IOException、ClassNotFoundException、SQLException 都属于 checked 异常；像 RuntimeException 以及子类 ArithmeticException、ClassCastException、ArrayIndexOutOfBoundsException、NullPointerException，都属于 unchecked 异常。</p>
<p>unchecked 异常可以不在程序中显示处理，就像之前提到的 ArithmeticException 就是的；但 checked 异常必须显式处理。</p>
<p>比如说下面这行代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clz = Class.forName(&quot;com.itwanger.s41.Demo1&quot;);</span><br></pre></td></tr></table></figure>
<p>如果没做处理，比如说在 Intellij IDEA 环境下，就会提示你这行代码可能会抛出 java.lang.ClassNotFoundException 。</p>
<p><img src="\assets\note\image-20231011114528608.png" alt="image-20231011114528608"></p>
<p>建议你要么使用 try-catch 进行捕获：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    Class clz = Class.forName(&quot;com.itwanger.s41.Demo1&quot;);</span><br><span class="line">&#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意打印异常堆栈信息的 printStackTrace() 方法，该方法会将异常的堆栈信息打印到标准的控制台下，如果是测试环境，这样的写法还 OK，如果是生产环境，这样的写法是不可取的，必须使用日志框架把异常的堆栈信息输出到日志系统中，否则可能没办法跟踪。</p>
<p>要么在方法签名上使用 throws 关键字抛出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Demo1 &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException &#123;</span><br><span class="line">        Class clz = Class.forName(&quot;com.itwanger.s41.Demo1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样做的好处是不需要对异常进行捕获处理，只需要交给 Java 虚拟机来处理即可；坏处就是没法针对这种情况做相应的处理。</p>
<p>“二哥，针对 checked 异常，我在知乎上看到一个帖子，说 Java 中的 checked 很没有必要，这种异常在编译期要么 try-catch，要么 throws，但又不一定会出现异常，你觉得这样的设计有意义吗？”三妹提出了一个很尖锐的问题。</p>
<p>“哇，这种问题问的好。”我不由得对三妹心生敬佩。</p>
<p>“的确，checked 异常在业界是有争论的，它假设我们捕获了异常，并且针对这种情况作了相应的处理，但有些时候，根本就没法处理。”我说，“就拿上面提到的 ClassNotFoundException 异常来说，我们假设对其进行了 try-catch，可真的出现了 ClassNotFoundException 异常后，我们也没多少的可操作性，再 Class.forName() 一次？”</p>
<p>另外，checked 异常也不兼容函数式编程，后面如果你写 Lambda/Stream 代码的时候，就会体验到这种苦涩。</p>
<p>当然了，checked 异常并不是一无是处，尤其是在遇到 IO 或者网络异常的时候，比如说进行 Socket 链接，我大致写了一段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Demo2 &#123;</span><br><span class="line">    private String mHost;</span><br><span class="line">    private int mPort;</span><br><span class="line">    private Socket mSocket;</span><br><span class="line">    private final Object mLock = new Object();</span><br><span class="line">    public void run() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    private void initSocket() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Socket socket = new Socket(mHost, mPort);</span><br><span class="line">                synchronized (mLock) &#123;</span><br><span class="line">                    mSocket = socket;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当发生 IOException 的时候，socket 就重新尝试连接，否则就 break 跳出循环。意味着如果 IOException 不是 checked 异常，这种写法就略显突兀，因为 IOException 没办法像 ArithmeticException 那样用一个 if 语句判断除数是否为 0 去规避。</p>
<p>或者说，强制性的 checked 异常可以让我们在编程的时候去思考，遇到这种异常的时候该怎么更优雅的去处理。显然，Socket 编程中，肯定是会遇到 IOException 的，假如 IOException 是非检查型异常，就意味着开发者也可以不考虑，直接跳过，交给 Java 虚拟机来处理，但我觉得这样做肯定更不合适。</p>
<p><strong>04、关于 throw 和 throws </strong></p>
<p>“二哥，你能告诉我 throw 和 throws 两个关键字的区别吗？”三妹问。</p>
<p>“throw 关键字，用于主动地抛出异常；正常情况下，当除数为 0 的时候，程序会主动抛出 ArithmeticException；但如果我们想要除数为 1 的时候也抛出 ArithmeticException，就可以使用 throw 关键字主动地抛出异常。”我说。</p>
<p>语法也非常简单，throw 关键字后跟上 new 关键字，以及异常的类型还有参数即可。</p>
<p>举个例子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ThrowDemo &#123;</span><br><span class="line">    static void checkEligibilty(int stuage)&#123;</span><br><span class="line">        if(stuage&lt;18) &#123;</span><br><span class="line">            throw new ArithmeticException(&quot;年纪未满 18 岁，禁止观影&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;请认真观影!!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String args[])&#123;</span><br><span class="line">        checkEligibilty(10);</span><br><span class="line">        System.out.println(&quot;愉快地周末..&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码在运行的时候就会抛出以下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.ArithmeticException: 年纪未满 18 岁，禁止观影</span><br><span class="line">    at com.itwanger.s43.ThrowDemo.checkEligibilty(ThrowDemo.java:9)</span><br><span class="line">    at com.itwanger.s43.ThrowDemo.main(ThrowDemo.java:16)</span><br></pre></td></tr></table></figure>
<p>“throws 关键字的作用就和 throw 完全不同。”我说，“前面的小节里已经讲了 checked exception 和 unchecked exception，也就是检查型异常和非检查型异常；对于检查型异常来说，如果你没有做处理，编译器就会提示你。”</p>
<p>Class.forName() 方法在执行的时候可能会遇到 java.lang.ClassNotFoundException 异常，一个检查型异常，如果没有做处理，IDEA 就会提示你，要么在方法签名上声明，要么放在 try-catch 中。</p>
<p><img src="\assets\note\image-20231011114921164.png" alt="image-20231011114921164"></p>
<p>“那什么情况下使用 throws 而不是 try-catch 呢？”三妹问。</p>
<p>“假设现在有这么一个方法 myMethod() ，可能会出现 ArithmeticException 异常，也可能会出现 NullPointerException。这种情况下，可以使用 try-catch 来处理。”我回答。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void myMethod() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 可能抛出异常 </span><br><span class="line">    &#125; catch (ArithmeticException e) &#123;</span><br><span class="line">        // 算术异常</span><br><span class="line">    &#125; catch (NullPointerException e) &#123;</span><br><span class="line">        // 空指针异常</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“但假设有好几个类似 myMethod() 的方法，如果为每个方法都加上 try-catch，就会显得非常繁琐。代码就会变得又臭又长，可读性就差了。”我继续说。</p>
<p>“一个解决办法就是，使用 throws 关键字，在方法签名上声明可能会抛出的异常，然后在调用该方法的地方使用 try-catch 进行理。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String args[])&#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        myMethod1();</span><br><span class="line">    &#125; catch (ArithmeticException e) &#123;</span><br><span class="line">        // 算术异常</span><br><span class="line">    &#125; catch (NullPointerException e) &#123;</span><br><span class="line">        // 空指针异常</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void myMethod1() throws ArithmeticException, NullPointerException&#123;</span><br><span class="line">    // 方法签名上声明异常</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“好了，我来总结下 throw 和 throws 的区别，三妹，你记一下。”</p>
<p> 1）throws 关键字用于声明异常，它的作用和 try-catch 相似；而 throw 关键字用于显式的抛出异常。</p>
<p>2）throws 关键字后面跟的是异常的名字；而 throw 关键字后面跟的是异常的对象。</p>
<p>示例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throws ArithmeticException;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throw new ArithmeticException(&quot;算术异常&quot;);</span><br></pre></td></tr></table></figure>
<p>3）throws 关键字出现在方法签名上，而 throw 关键字出现在方法体里。</p>
<p>4）throws 关键字在声明异常的时候可以跟多个，用逗号隔开；而 throw 关键字每次只能抛出一个异常。</p>
<p><strong>05、关于 try-catch-finally </strong></p>
<p>“二哥，之前你讲了异常处理机制，这一节讲什么呢？”三妹问。</p>
<p>“该讲 try-catch-finally 了。”我说，“try 关键字后面会跟一个大括号 {} ，我们把一些可能发生异常的代码放到大括号里； try 块后面一般会跟 catch 块，用来处理发生异常的情况；当然了，异常不一定会发生，为了保证发不发生异常都能执行一些代码，就会跟一个 finally 块。”</p>
<p>“具体该怎么用呀，二哥？”三妹问。</p>
<p>“别担心，三妹，我一一来说明下。”我说。</p>
<p>try 块的语法很简单：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">// 可能发生异常的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“注意啊，三妹，如果一些代码确定不会抛出异常，就尽量不要把它包裹在 try 块里，因为加了异常处理的代码执行起来要比没有加的花费更多的时间。”</p>
<p>catch 块的语法也很简单：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">// 可能发生异常的代码</span><br><span class="line">&#125;catch (exception(type) e(object))&#123;</span><br><span class="line">// 异常处理代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个 try 块后面可以跟多个 catch 块，用来捕获不同类型的异常并做相应的处理，当 try 块中的某一行代码发生异常时，之后的代码就不再执行，而是会跳转到异常对应的 catch 块中执行。</p>
<p>如果一个 try 块后面跟了多个与之关联的 catch 块，那么应该把特定的异常放在前面，通用型的异常放在后面，不然编译器会提示错误。举例来说。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static void test() &#123;</span><br><span class="line">    int num1, num2;</span><br><span class="line">    try &#123;</span><br><span class="line">        num1 = 0;</span><br><span class="line">        num2 = 62 / num1;</span><br><span class="line">        System.out.println(num2);</span><br><span class="line">        System.out.println(&quot;try 块的最后一句&quot;);</span><br><span class="line">    &#125; catch (ArithmeticException e) &#123;</span><br><span class="line">        // 算术运算发生时跳转到这里</span><br><span class="line">        System.out.println(&quot;除数不能为零&quot;);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        // 通用型的异常意味着可以捕获所有的异常，它应该放在最后面，</span><br><span class="line">        System.out.println(&quot;异常发生了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;try-catch 之外的代码.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“为什么 Exception 不能放到 ArithmeticException 前面呢？”三妹问。</p>
<p>“因为 ArithmeticException 是 Exception 的子类，它更具体，我们看到就这个异常就知道是发生了算术错误，而 Exception 比较泛，它隐藏了具体的异常信息，我们看到后并不确定到底是发生了哪一种类型的异常，对错误的排查很不利。”我说，“再者，如果把通用型的异常放在前面，就意味着其他的 catch 块永远也不会执行，所以编译器就直接提示错误了。”</p>
<p>“再给你举个例子，注意看，三妹。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static void test1 () &#123;</span><br><span class="line">    try&#123;</span><br><span class="line">        int arr[]=new int[7];</span><br><span class="line">        arr[4]=30/0;</span><br><span class="line">        System.out.println(&quot;try 块的最后&quot;);</span><br><span class="line">    &#125; catch(ArithmeticException e)&#123;</span><br><span class="line">        System.out.println(&quot;除数必须是 0&quot;);</span><br><span class="line">    &#125; catch(ArrayIndexOutOfBoundsException e)&#123;</span><br><span class="line">        System.out.println(&quot;数组越界了&quot;);</span><br><span class="line">    &#125; catch(Exception e)&#123;</span><br><span class="line">        System.out.println(&quot;一些其他的异常&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;try-catch 之外&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码在执行的时候，第一个 catch 块会执行，因为除数为零；我再来稍微改动下代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static void test1 () &#123;</span><br><span class="line">    try&#123;</span><br><span class="line">        int arr[]=new int[7];</span><br><span class="line">        arr[9]=30/1;</span><br><span class="line">        System.out.println(&quot;try 块的最后&quot;);</span><br><span class="line">    &#125; catch(ArithmeticException e)&#123;</span><br><span class="line">        System.out.println(&quot;除数必须是 0&quot;);</span><br><span class="line">    &#125; catch(ArrayIndexOutOfBoundsException e)&#123;</span><br><span class="line">        System.out.println(&quot;数组越界了&quot;);</span><br><span class="line">    &#125; catch(Exception e)&#123;</span><br><span class="line">        System.out.println(&quot;一些其他的异常&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;try-catch 之外&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“我知道，二哥，第二个 catch 块会执行，因为没有发生算术异常，但数组越界了。”三妹没等我把代码运行起来就说出了答案。</p>
<p>“三妹，你说得很对，我再来改一下代码。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static void test1 () &#123;</span><br><span class="line">    try&#123;</span><br><span class="line">        int arr[]=new int[7];</span><br><span class="line">        arr[9]=30/1;</span><br><span class="line">        System.out.println(&quot;try 块的最后&quot;);</span><br><span class="line">    &#125; catch(ArithmeticException | ArrayIndexOutOfBoundsException e)&#123;</span><br><span class="line">        System.out.println(&quot;除数必须是 0&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;try-catch 之外&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“当有多个 catch 的时候，也可以放在一起，用竖划线 | 隔开，就像上面这样。”我说。</p>
<p>“这样不错呀，看起来更简洁了。”三妹说。</p>
<p>finally 块的语法也不复杂。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    // 可能发生异常的代码</span><br><span class="line">&#125;catch &#123;</span><br><span class="line">   // 异常处理</span><br><span class="line">&#125;finally &#123;</span><br><span class="line">   // 必须执行的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在没有 try-with-resources 之前，finally 块常用来关闭一些连接资源，比如说 socket、数据库链接、IO 输入输出流等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OutputStream osf = new FileOutputStream( &quot;filename&quot; );</span><br><span class="line">OutputStream osb = new BufferedOutputStream(opf);</span><br><span class="line">ObjectOutput op = new ObjectOutputStream(osb);</span><br><span class="line">try&#123;</span><br><span class="line">    output.writeObject(writableObject);</span><br><span class="line">&#125; finally&#123;</span><br><span class="line">    op.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“三妹，注意，使用 finally 块的时候需要遵守这些规则。”</p>
<ul>
<li>finally 块前面必须有 try 块，不要把 finally 块单独拉出来使用。编译器也不允许这样做。</li>
<li>finally 块不是必选项，有 try 块的时候不一定要有 finally 块。</li>
<li>如果 finally 块中的代码可能会发生异常，也应该使用 try-catch 进行包裹。</li>
<li>即便是 try 块中执行了 return、break、continue 这些跳转语句，finally 块也会被执行。</li>
</ul>
<p>“真的吗，二哥？”三妹对最后一个规则充满了疑惑。</p>
<p>“来试一下就知道了。”我说。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static int test2 () &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        return 112;</span><br><span class="line">    &#125;</span><br><span class="line">    finally &#123;</span><br><span class="line">        System.out.println(&quot;即使 try 块有 return，finally 块也会执行&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看一下输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">即使 try 块有 return，finally 块也会执行</span><br></pre></td></tr></table></figure>
<p>“那，会不会有不执行 finally 的情况呀？”三妹很好奇。</p>
<p>“有的。”我斩钉截铁地回答。</p>
<ul>
<li>遇到了死循环。</li>
<li>执行了 System. exit() 这行代码。</li>
</ul>
<p>System.exit() 和 return 语句不同，前者是用来退出程序的，后者只是回到了上一级方法调用。</p>
<p>“三妹，来看一下源码的文档注释就全明白了！”</p>
<p><img src="\assets\note\image-20231011115617590.png" alt="image-20231011115617590"></p>
<p>至于参数 status 的值也很好理解，如果是异常退出，设置为非 0 即可，通常用 1 来表示；如果是想正常退出程序，用 0 表示即可。</p>
<p><strong>06、小结 </strong></p>
<p>Java 的异常处理是一种重要的机制，可以帮助我们处理程序执行期间发生的错误 或异常。</p>
<p>异常分为两类：Checked Exception 和 Unchecked Exception，其中 Checked Exception 需要在代码中显式地处理或声明抛出，而 Unchecked Exception 不需要在代码中显式地处理或声明抛出。异常处理通常使用 try-catch-finally 块来处理，也可以使用 throws 关键字将异常抛出给调用者处理。</p>
<p>下面是 Java 异常处理的一些总结：</p>
<ul>
<li>使用 try-catch 块捕获并处理异常，可以避免程序因异常而崩溃。</li>
<li>可以使用多个 catch 块来捕获不同类型的异常，并进行不同的处理。</li>
<li>可以使用 finally 块来执行一些必要的清理工作，无论是否发生异常都会执行。</li>
<li>可以使用 throw 关键字手动抛出异常，用于在程序中明确指定某些异常情况。</li>
<li>可以使用 throws 关键字将异常抛出给调用者处理，用于在方法签名中声明可能会出现的异常。</li>
<li>Checked Exception 通常是由于外部因素导致的问题，需要在代码中显式地处理或声明抛出。</li>
<li>Unchecked Exception 通常是由于程序内部逻辑或数据异常导致的，可以不处理或者在需要时进行处理。</li>
<li>在处理异常时，应该根据具体的异常类型进行处理，例如可以尝试重新打开文件、重新建立网络连接等操作。</li>
<li>异常处理应该根据具体的业务需求和设计原则进行，避免过度捕获和处理异常，从而降低程序的性能和可维护性。</li>
</ul>
<h2 id="6-2-try-with-resources"><a href="#6-2-try-with-resources" class="headerlink" title="6.2 try-with-resources"></a>6.2 try-with-resources</h2><p>“二哥，终于等到你讲 try-with-resources 了！”三妹夸张的表情让我有些吃惊。</p>
<p>“三妹，不要激动呀！开讲之前，我们还是要来回顾一下 try–catch-finally，好做个铺垫。”我说，“来看看这段代码吧。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class TrycatchfinallyDecoder &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BufferedReader br = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            String path = TrycatchfinallyDecoder.class.getResource(&quot;/牛逼.txt&quot;).getFile();</span><br><span class="line">            String decodePath = URLDecoder.decode(path,&quot;utf-8&quot;);</span><br><span class="line">            br = new BufferedReader(new FileReader(decodePath));</span><br><span class="line">            String str = null;</span><br><span class="line">            while ((str =br.readLine()) != null) &#123;</span><br><span class="line">                System.out.println(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (br != null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    br.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“我简单来解释下。”等三妹看完这段代码后，我继续说，“在 try 块中读取文件中的内容，并一行一行地打印到控制台。如果文件找不到或者出现 IO 读写错误，就在 catch 中捕获并打印错误的堆栈信息。最后，在 finally 中关闭缓冲字符读取器对象 BufferedReader，有效杜绝了资源未被关闭的情况下造成的严重性能后果。”</p>
<p>“在 Java 7 之前，try–catch-finally 的确是确保资源会被及时关闭的最佳方法，无论程序是否会抛出异常。”</p>
<p>三妹点了点头，表示同意。</p>
<p>“不过，这段代码还是有些臃肿，尤其是 finally 中的代码。”我说，“况且，try–catch-finally 至始至终存在一个严重的隐患：try 中的 br.readLine() 有可能会抛出 IOException ，finally 中的 br.close() 也有可能会抛出 IOException 。假如两处都不幸地抛出了 IOException，那程序的调试任务就变得复杂了起来，到底是哪一处出了错误，就需要花一番功夫，这是我们不愿意看到的结果。”</p>
<p>“我来给你演示下，三妹。”</p>
<p>“首先，我们来定义这样一个类 MyfinallyReadLineThrow，它有两个方法，分别是 readLine() 和 close() ，方法体都是主动抛出异常。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class MyfinallyReadLineThrow &#123;</span><br><span class="line">    public void close() throws Exception &#123;</span><br><span class="line">        throw new Exception(&quot;close&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void readLine() throws Exception &#123;</span><br><span class="line">        throw new Exception(&quot;readLine&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“然后在 main() 方法中使用 try-catch-finally 的方式调用 MyfinallyReadLineThrow 的 readLine() 和 close() 方法。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class TryfinallyCustomReadLineThrow &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        MyfinallyReadLineThrow myThrow = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            myThrow = new MyfinallyReadLineThrow();</span><br><span class="line">            myThrow.readLine();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            myThrow.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上述代码后，错误堆栈如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.Exception: close</span><br><span class="line">    at </span><br><span class="line">com.cmower.dzone.trycatchfinally.MyfinallyOutThrow.close(TryfinallyCustomOutThrow.ja</span><br><span class="line">va:17)</span><br><span class="line">    at </span><br><span class="line">com.cmower.dzone.trycatchfinally.TryfinallyCustomOutThrow.main(TryfinallyCustomOutTh</span><br><span class="line">row.java:10)</span><br></pre></td></tr></table></figure>
<p>“看出来问题了吗，三妹？”</p>
<p>“啊？ readLine() 方法的异常信息竟然被 close() 方法的堆栈信息吃了！”</p>
<p>“不错啊，三妹，火眼金睛，的确，这会让我们误以为要调查的目标是 close() 方法而不是 readLine() 方法——尽管它也是应该怀疑的对象。”</p>
<p>“但有了 try-with-resources 后，这些问题就迎刃而解了。前提条件只有一个，就是需要释放的资源（比如 BufferedReader）实现了 AutoCloseable 接口。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try (BufferedReader br = new BufferedReader(new FileReader(decodePath));) &#123;</span><br><span class="line">    String str = null;</span><br><span class="line">    while ((str =br.readLine()) != null) &#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“你瞧，三妹，finally 块消失了，取而代之的是把要释放的资源写在 try 后的 () 中。如果有多个资源（BufferedReader 和 PrintWriter）需要释放的话，可以直接在 () 中添加。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try (BufferedReader br = new BufferedReader(new FileReader(decodePath));</span><br><span class="line">     PrintWriter writer = new PrintWriter(new File(writePath))) &#123;</span><br><span class="line">    String str = null;</span><br><span class="line">    while ((str =br.readLine()) != null) &#123;</span><br><span class="line">        writer.print(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“如果想释放自定义资源的话，只要让它实现 AutoCloseable 接口，并提供 close() 方法即可。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class TrywithresourcesCustom &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try (MyResource resource = new MyResource();) &#123;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class MyResource implements AutoCloseable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void close() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;关闭自定义资源&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看一下代码运行后的输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">关闭自定义资源</span><br></pre></td></tr></table></figure>
<p>“好神奇呀！”三妹欣喜若狂，“在 try () 中只是 new 了一个 MyResource 的对象，其他什么也没干，close() 方法就执行了！”</p>
<p>“想知道为什么吗？三妹。”</p>
<p>“当然想啊。”</p>
<p>“来看看反编译后的字节码吧。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class MyResource implements AutoCloseable &#123;</span><br><span class="line">    MyResource() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public void close() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;关闭自定义资源&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class TrywithresourcesCustom &#123;</span><br><span class="line">    public TrywithresourcesCustom() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            MyResource resource = new MyResource();</span><br><span class="line">            resource.close();</span><br><span class="line">        &#125; catch (Exception var2) &#123;</span><br><span class="line">            var2.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“啊，原来如此。编译器主动为 try-with-resources 进行了变身，在 try 中调用了 close() 方法。”</p>
<p>“是这样的。接下来，我们在 MyResourceOut 类中再添加一个 out() 方法。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class MyResourceOut implements AutoCloseable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void close() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;关闭自定义资源&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void out() throws Exception&#123;</span><br><span class="line">        System.out.println(&quot;沉默王二，一枚有趣的程序员&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“这次，我们在 try 中调用一下 out() 方法。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class TrywithresourcesCustomOut &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try (MyResourceOut resource = new MyResourceOut();) &#123;</span><br><span class="line">            resource.out();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“再来看一下反编译的字节码。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class TrywithresourcesCustomOut &#123;</span><br><span class="line">    public TrywithresourcesCustomOut() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            MyResourceOut resource = new MyResourceOut();</span><br><span class="line">            try &#123;</span><br><span class="line">                resource.out();</span><br><span class="line">            &#125; catch (Throwable var5) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    resource.close();</span><br><span class="line">                &#125; catch (Throwable var4) &#123;</span><br><span class="line">                    var5.addSuppressed(var4);</span><br><span class="line">                &#125;</span><br><span class="line">                throw var5;</span><br><span class="line">            &#125;</span><br><span class="line">            resource.close();</span><br><span class="line">        &#125; catch (Exception var6) &#123;</span><br><span class="line">            var6.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“这次， catch 块主动调用了 resource.close() ，并且有一段很关键的代码 var5.addSuppressed(var4) 。”</p>
<p>“这是为了什么呢？”三妹问。</p>
<p>“当一个异常被抛出的时候，可能有其他异常因为该异常而被抑制住，从而无法正常抛出。这时可以通过 addSuppressed() 方法把这些被抑制的方法记录下来，然后被抑制的异常就会出现在抛出的异常的堆栈信息中，可以通过 getSuppressed() 方法来获取这些异常。这样做的好处是不会丢失任何异常，方便我们进行调试。”我说。</p>
<p>“有没有想到之前的那个例子——在 try-catch-finally 中， readLine() 方法的异常信息竟然被 close() 方法的堆栈信息吃了。现在有了 try-with-resources，再来看看和 readLine() 方法一致的 out() 方法会不会被 close() 吃掉吧。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class MyResourceOutThrow implements AutoCloseable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void close() throws Exception &#123;</span><br><span class="line">        throw  new Exception(&quot;close()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void out() throws Exception&#123;</span><br><span class="line">        throw new Exception(&quot;out()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“调用这 2 个方法。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class TrywithresourcesCustomOutThrow &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try (MyResourceOutThrow resource = new MyResourceOutThrow();) &#123;</span><br><span class="line">            resource.out();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“程序输出的结果如下所示。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Exception: out()</span><br><span class="line">    at </span><br><span class="line">com.cmower.dzone.trycatchfinally.MyResourceOutThrow.out(TrywithresourcesCustomOutThr</span><br><span class="line">ow.java:20)</span><br><span class="line">    at </span><br><span class="line">com.cmower.dzone.trycatchfinally.TrywithresourcesCustomOutThrow.main(Trywithresource</span><br><span class="line">sCustomOutThrow.java:6)</span><br><span class="line">    Suppressed: java.lang.Exception: close()</span><br><span class="line">        at </span><br><span class="line">com.cmower.dzone.trycatchfinally.MyResourceOutThrow.close(TrywithresourcesCustomOutT</span><br><span class="line">hrow.java:16)</span><br><span class="line">        at </span><br><span class="line">com.cmower.dzone.trycatchfinally.TrywithresourcesCustomOutThrow.main(Trywithresource</span><br><span class="line">sCustomOutThrow.java:5)</span><br></pre></td></tr></table></figure>
<p>“瞧，这次不会了， out() 的异常堆栈信息打印出来了，并且 close() 方法的堆栈信息上加了一个关键字 Suppressed ，一目了然。”</p>
<p>“三妹，怎么样？是不是感觉 try-with-resources 好用多了！我来简单总结下哈，在处理必须关闭的资源时，始终有限考虑使用 try-with-resources，而不是 try–catch-finally。前者产生的代码更加简洁、清晰，产生的异常信息也更靠谱。”</p>
<p>“靠谱！”三妹说。</p>
<h2 id="6-3-异常处理的20个最佳实践"><a href="#6-3-异常处理的20个最佳实践" class="headerlink" title="6.3 异常处理的20个最佳实践"></a>6.3 异常处理的20个最佳实践</h2><p>“三妹啊，今天我来给你传授 20 个异常处理的最佳实践经验，以免你以后在开发中采坑。”我面带着微笑对三妹说。</p>
<p>“好啊，二哥，我洗耳恭听。”三妹也微微一笑，欣然接受。</p>
<p>“好，那哥就不废话了。开整。”</p>
<p><strong>01、尽量不要捕获 RuntimeException </strong></p>
<p>阿里出品的 Java 开发手册上这样规定：</p>
<blockquote>
<p>尽量不要 catch RuntimeException，比如 NullPointerException、IndexOutOfBoundsException 等等，应该用预检查的方式来规避。</p>
</blockquote>
<p>正例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (obj != null) &#123;</span><br><span class="line">  //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123; </span><br><span class="line">  obj.method(); </span><br><span class="line">&#125; catch (NullPointerException e) &#123;</span><br><span class="line">  //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“哦，那如果有些异常预检查不出来呢？”三妹问。</p>
<p>“的确会存在这样的情况，比如说 NumberFormatException，虽然也属于 RuntimeException，但没办法预检查，所以还是应该用 catch 捕获处理。”我说。</p>
<p><strong>02、尽量使用 try-with-resource 来关闭资源 </strong></p>
<p>当需要关闭资源时，尽量不要使用 try-catch-finally，禁止在 try 块中直接关闭资源。</p>
<p>反例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void doNotCloseResourceInTry() &#123;</span><br><span class="line">    FileInputStream inputStream = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        File file = new File(&quot;./tmp.txt&quot;);</span><br><span class="line">        inputStream = new FileInputStream(file);</span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“为什么呢？”三妹问。</p>
<p>“原因也很简单，因为一旦 close() 之前发生了异常，那么资源就无法关闭。直接使用 try-with-resource 来处理是最佳方式。”我说。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void automaticallyCloseResource() &#123;</span><br><span class="line">    File file = new File(&quot;./tmp.txt&quot;);</span><br><span class="line">    try (FileInputStream inputStream = new FileInputStream(file);) &#123;</span><br><span class="line">    &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“除非资源没有实现 AutoCloseable 接口。”我补充道。</p>
<p>“那这种情况下怎么办呢？”三妹问。</p>
<p>“就在 finally 块关闭流。”我说。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void closeResourceInFinally() &#123;</span><br><span class="line">    FileInputStream inputStream = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        File file = new File(&quot;./tmp.txt&quot;);</span><br><span class="line">        inputStream = new FileInputStream(file);</span><br><span class="line">    &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (inputStream != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                log.error(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>03、不要捕获 Throwable </strong></p>
<p>Throwable 是 exception 和 error 的父类，如果在 catch 子句中捕获了 Throwable，很可能把超出程序处理能力之外的错误也捕获了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void doNotCatchThrowable() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        // 不要这样做</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“到底为什么啊？”三妹问。</p>
<p>“因为有些 error 是不需要程序来处理，程序可能也处理不了，比如说 OutOfMemoryError 或者 StackOverflowError，前者是因为 Java 虚拟机无法申请到足够的内存空间时出现的非正常的错误，后者是因为线程申请的栈深度超过了允许的最大深度出现的非正常错误，如果捕获了，就掩盖了程序应该被发现的严重错误。”我说。</p>
<p>“打个比方，一匹马只能拉一车厢的货物，拉两车厢可能就挂了，但一 catch，就发现不了问题了。”我补充道。</p>
<p><strong>04、不要省略异常信息的记录 </strong></p>
<p>很多时候，由于疏忽大意，我们很容易捕获了异常却没有记录异常信息，导致程序上线后真的出现了问题却没有记录可查。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void doNotIgnoreExceptions() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">    &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">        // 没有记录异常</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应该把错误信息记录下来。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void logAnException() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">    &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">        log.error(&quot;哦，错误竟然发生了: &quot; + e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>05、不要记录了异常又抛出了异常 </strong></p>
<p>这纯属画蛇添足，并且容易造成错误信息的混乱。</p>
<p>反例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">&#125; catch (NumberFormatException e) &#123;</span><br><span class="line">    log.error(e);</span><br><span class="line">    throw e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要抛出就抛出，不要记录，记录了又抛出，等于多此一举。</p>
<p>反例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void wrapException(String input) throws MyBusinessException &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">    &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">        throw new MyBusinessException(&quot;错误信息描述：&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种也是一样的道理，既然已经捕获了，就不要在方法签名上抛出了。</p>
<p><strong>06、不要在 finally 块中使用 return </strong></p>
<p>阿里出品的 Java 开发手册上这样规定：</p>
<blockquote>
<p>try 块中的 return 语句执行成功后，并不会马上返回，而是继续执行 finally 块中的语句，如果 finally 块中也存在 return 语句，那么 try 块中的 return 就将被覆盖。</p>
</blockquote>
<p>反例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private int x = 0;</span><br><span class="line">public int checkReturn() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        return ++x;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        return ++x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“哦，确实啊，try 块中 x 返回的值为 1，到了 finally 块中就返回 2 了。”三妹说。</p>
<p>“是这样的。”我点点头。</p>
<p><strong>07、抛出具体定义的检查性异常而不是 Exception </strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public void foo() throws Exception &#123; //错误方式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一定要避免出现上面的代码，它破坏了检查性（checked）异常的目的。声明的方法应该尽可能抛出具体的检查性异常。</p>
<p>例如，如果一个方法可能会抛出 SQLException 异常，应该显式地声明抛出 SQLException 而不是 Exception 类型的异常。这样可以让其他开发者更好地理解代码的意图和异常处理的方式，并且可以根据 SQLException 的定义和文档来确定异常的处理方式和策略。</p>
<p><strong>08、捕获具体的子类而不是捕获 Exception 类 </strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">   someMethod();</span><br><span class="line">&#125; catch (Exception e) &#123; //错误方式</span><br><span class="line">   LOGGER.error(&quot;method has failed&quot;, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在 catch 块中捕获 Exception 类型的异常，会将所有异常都捕获，从而可能会给程序带来不必要的麻烦。具体来说，如果捕获 Exception 类型的异常，可能会导致以下问题：</p>
<ul>
<li>难以识别和定位异常：如果捕获 Exception 类型的异常，可能会捕获到一些不应该被处理的异常，从而导致程序难以识别和定位异常。</li>
<li>难以调试和排错：如果捕获 Exception 类型的异常，可能会使得调试和排错变得更加困难，因为无法确定具体的异常类型和异常发生的原因。</li>
</ul>
<p>下面举一个例子来说明为什么应该尽可能地捕获具体的子类而不是 Exception 类型的异常。</p>
<p>假设我们有一个方法 readFromFile(String filePath) ，用于从指定文件中读取数据。在方法实现过程中，可能会出现两种异常：FileNotFoundException 和 IOException。</p>
<p>如果在方法中使用以下 catch 块来捕获异常：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    // 读取数据的代码</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    // 异常处理的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样做会捕获所有类型的异常，包括 Checked Exception 和 Unchecked Exception。这可能会导致以下问题：</p>
<ul>
<li>发生 RuntimeException 类型的异常时，也会被捕获，从而可能会掩盖实际的异常信息。</li>
<li>在调试和排错时，无法确定异常的具体类型和发生原因，从而增加了调试和排错的难度。</li>
<li>在程序运行时，可能会捕获一些不需要处理的异常（如 NullPointerException、IllegalArgumentException 等），从而降低程序的性能和稳定性。</li>
</ul>
<p>因此，为了更好地定位和处理异常，应该尽可能地捕获具体的子类，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    // 读取数据的代码</span><br><span class="line">&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">    // 处理文件未找到异常的代码</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    // 处理输入输出异常的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样做可以更准确地捕获异常，从而提高程序的健壮性和稳定性。</p>
<p><strong>09、自定义异常时不要丢失堆栈跟踪 </strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">catch (NoSuchMethodException e) &#123;</span><br><span class="line">   throw new MyServiceException(&quot;Some information: &quot; + e.getMessage());  //错误方式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这破坏了原始异常的堆栈跟踪，正确的做法是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">catch (NoSuchMethodException e) &#123;</span><br><span class="line">   throw new MyServiceException(&quot;Some information: &quot; , e);  //正确方式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如，下面是一个自定义异常类，它重写了 printStackTrace() 方法来打印堆栈跟踪信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class MyException extends Exception &#123;</span><br><span class="line">    public MyException(String message, Throwable cause) &#123;</span><br><span class="line">        super(message, cause);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void printStackTrace() &#123;</span><br><span class="line">        System.err.println(&quot;MyException:&quot;);</span><br><span class="line">        super.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样做可以保留堆栈跟踪信息，同时也可以提供自定义的异常信息。在抛出 MyException 异常时，可以得到完整的堆栈跟踪信息，从而更好地定位和解决异常。</p>
<p><strong>10、finally 块中不要抛出任何异常</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  someMethod();  //Throws exceptionOne</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">  cleanUp();    //如果finally还抛出异常，那么exceptionOne将永远丢失</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>finally 块用于定义一段代码，无论 try 块中是否出现异常，都会被执行。finally 块通常用于释放资源、关闭文件等必须执行的操作。</p>
<p>如果在 finally 块中抛出异常，可能会导致原始异常被掩盖。比如说上例中，一旦 cleanup 抛出异常，someMethod 中的异常将会被覆盖。</p>
<p><strong>11、不要在生产环境中使用 </strong> </p>
<p>在 Java 中， printStackTrace() 方法用于将异常的堆栈跟踪信息输出到标准错误流中。这个方法对于调试和排错非常有用。但在生产环境中，不应该使用 printStackTrace() 方法，因为它可能会导致以下问题：</p>
<ul>
<li>printStackTrace() 方法将异常的堆栈跟踪信息输出到标准错误流中，这可能会暴露敏感信息，如文件路径、用户名、密码等。</li>
<li>printStackTrace() 方法会将堆栈跟踪信息输出到标准错误流中，这可能会影响程序的性能和稳定性。在高并发的生产环境中，大量的异常堆栈跟踪信息可能会导致系统崩溃或出现意外的行为。</li>
<li>由于生产环境中往往是多线程、分布式的复杂系统， printStackTrace() 方法输出的堆栈跟踪信息可能并不完整或准确。</li>
</ul>
<p>在生产环境中，应该使用日志系统来记录异常信息，例如 log4j、slf4j、logback 等。日志系统可以将异常信息记录到文件或数据库中，而不会暴露敏感信息，也不会影响程序的性能和稳定性。同时，日志系统也提供了更多的功能，如级别控制、滚动日志、邮件通知等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例如，可以使用 logback 记录异常信息，如下所示：</span><br><span class="line">try &#123;</span><br><span class="line">    // some code</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    logger.error(&quot;An error occurred: &quot;, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>12、对于不打算处理的异常，直接使用 try-finally，不用 catch </strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  method1();  // 会调用 Method 2</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">  cleanUp();    //do cleanup here</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 method1 正在访问 Method 2，而 Method 2 抛出一些你不想在 Method 1 中处理的异常，但是仍然希望在发生异常时进行一些清理，可以直接在 finally 块中进行清理，不要使用 catch 块。</p>
<p><strong>13、记住早 throw 晚 catch 原则 </strong></p>
<p>“早 throw, 晚 catch” 是 Java 中的一种异常处理原则。这个原则指的是在代码中尽可能早地抛出异常，以便在异常发生时能够及时地处理异常。同时，在 catch 块中尽可能晚地捕获异常，以便在捕获异常时能够获得更多的上下文信息，从而更好地处理异常。</p>
<p>来举个 “早 throw” 例子，如果一个方法需要传递参数，并且该参数必须满足一定的条件，如果参数不符合条件，则应该立即抛出异常，而不是在方法中进行其他操作。这可以确保异常在发生时能够及时被处理，避免更严重的问题。</p>
<p>再来举个“晚 catch”的例子，如果一个方法调用了其他方法，可能会抛出异常，如果在方法内部立即捕获异常，则可能会导致对异常的处理不充分。</p>
<p>来看这段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class ExceptionDemo1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        String str = sc.nextLine();</span><br><span class="line">        try &#123;</span><br><span class="line">            int num = parseInt(str);</span><br><span class="line">            System.out.println(&quot;转换结果：&quot; + num);</span><br><span class="line">        &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">            System.out.println(&quot;转换失败：&quot; + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static int parseInt(String str) &#123;</span><br><span class="line">        if (str == null || &quot;&quot;.equals(str)) &#123;</span><br><span class="line">            throw new NullPointerException(&quot;字符串为空&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (!str.matches(&quot;\\d+&quot;)) &#123;</span><br><span class="line">            throw new NumberFormatException(&quot;字符串不是数字&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return Integer.parseInt(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个示例中，定义了一个 parseInt() 方法，用于将字符串转换为整数。在该方法中，首先检测字符串是否为空，如果为空，则立即抛出 NullPointerException 异常。然后，检测字符串是否为数字，如果不是数字，则抛出 NumberFormatException 异常。最后，使用 Integer.parseInt() 方法将字符串转换为整数，并返回。</p>
<p>在示例的 main() 方法中，调用 parseInt() 方法，并使用 try-catch 块捕获可能抛出的 NumberFormatException 异常。如果转换成功，则输出转换结果，否则输出转换失败信息。</p>
<p>这个示例使用了 “早 throw, 晚 catch” 的原则，在 parseInt() 方法中尽可能早地抛出异常，在 main() 方法中尽可能晚地捕获异常，以便在捕获异常时能够获得更多的上下文信息，从而更好地处理异常。</p>
<p>运行该示例，输入一个数字字符串，可以看到输出转换结果。如果输入一个非数字字符串，则输出转换失败信息。</p>
<p><strong>14、只抛出和方法相关的异常 </strong></p>
<p>相关性对于保持代码的整洁非常重要。一种尝试读取文件的方法，如果抛出 NullPointerException，那么它不会给用户提供有价值的信息。相反，如果这种异常被包裹在自定义异常中，则会更好。</p>
<p>NoSuchFileFoundException 则对该方法的用户更有用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            int result = divide(10, 0);</span><br><span class="line">            System.out.println(&quot;The result is: &quot; + result);</span><br><span class="line">        &#125; catch (ArithmeticException e) &#123;</span><br><span class="line">            System.err.println(&quot;Error: &quot; + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static int divide(int a, int b) throws ArithmeticException &#123;</span><br><span class="line">        if (b == 0) &#123;</span><br><span class="line">            throw new ArithmeticException(&quot;Division by zero&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return a / b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在该示例中，只抛出了和方法相关的异常 ArithmeticException，这可以使代码更加清晰和易于维护。</p>
<p><strong>15、切勿在代码中使用异常来进行流程控制 </strong></p>
<p>在代码中使用异常来进行流程控制会导致代码的可读性、可维护性和性能出现问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String input = &quot;1,2,3,a,5&quot;;</span><br><span class="line">        String[] values = input.split(&quot;,&quot;);</span><br><span class="line">        for (String value : values) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                int num = Integer.parseInt(value);</span><br><span class="line">                System.out.println(num);</span><br><span class="line">            &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">                System.err.println(value + &quot; is not a valid number&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然这个示例可以正确地处理输入字符串中的非数字字符，但是它使用异常进行流程控制，这就导致代码变得混乱、难以理解。应该使用其他合适的控制结构（如 if、switch、循环等）来管理程序的流程。</p>
<p><strong>16、尽早验证用户输入以在请求处理的早期捕获异常 </strong></p>
<p>例如：在用户注册的业务中，如果按照这样来做：</p>
<ol>
<li>验证用户</li>
<li>插入用户</li>
<li>验证地址</li>
<li>插入地址</li>
<li>如果出问题回滚一切</li>
</ol>
<p>这是不正确的做法，它会使数据库在各种情况下处于不一致的状态，应该首先验证所有内容，然后再进行数据库更新。正确的做法是：</p>
<ol>
<li>验证用户</li>
<li>验证地址</li>
<li>插入用户</li>
<li>插入地址</li>
<li>如果问题回滚一切</li>
</ol>
<p>举个例子，我们用 JDBC 的方式往数据库插入数据，那么最好是先 validate 再 insert，而不是 validateUserInput、insertUserData、</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Connection conn = null;</span><br><span class="line">try &#123;</span><br><span class="line">    // Connect to the database</span><br><span class="line">    conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/mydatabase&quot;, &quot;username&quot;, &quot;password&quot;);</span><br><span class="line">    // Start a transaction</span><br><span class="line">    conn.setAutoCommit(false);</span><br><span class="line">    // Validate user input</span><br><span class="line">    validateUserInput();</span><br><span class="line">    // Insert user data</span><br><span class="line">    insertUserData(conn);</span><br><span class="line">    // Validate address input</span><br><span class="line">    validateAddressInput();</span><br><span class="line">    // Insert address data</span><br><span class="line">    insertAddressData(conn);</span><br><span class="line">    // Commit the transaction if everything is successful</span><br><span class="line">    conn.commit();</span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">    // Rollback the transaction if there is an error</span><br><span class="line">    if (conn != null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            conn.rollback();</span><br><span class="line">        &#125; catch (SQLException ex) &#123;</span><br><span class="line">            System.err.println(&quot;Error: &quot; + ex.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.err.println(&quot;Error: &quot; + e.getMessage());</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    // Close the database connection</span><br><span class="line">    if (conn != null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            conn.close();</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            System.err.println(&quot;Error: &quot; + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>17、一个异常只能包含在一个日志中 </strong></p>
<p>不要这样做：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">log.debug(&quot;Using cache sector A&quot;);</span><br><span class="line">log.debug(&quot;Using retry sector B&quot;);</span><br></pre></td></tr></table></figure>
<p>在单线程环境中，这样看起来没什么问题，但如果在多线程环境中，这两行紧挨着的代码中间可能会输出很多其他的内容，导致问题查起来会很难受。应该这样做：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOGGER.debug(&quot;Using cache sector A, using retry sector B&quot;);</span><br></pre></td></tr></table></figure>
<p><strong>18、将所有相关信息尽可能地传递给异常 </strong></p>
<p>有用的异常消息和堆栈跟踪非常重要，如果你的日志不能定位异常位置，那要日志有什么用呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Log exception message and stack trace</span><br><span class="line">LOGGER.debug(&quot;Error reading file&quot;, e);</span><br></pre></td></tr></table></figure>
<p>应该尽量把 String message, Throwable cause 异常信息和堆栈都输出。</p>
<p><strong>19、终止掉被中断线程 </strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">while (true) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    Thread.sleep(100000);</span><br><span class="line">  &#125; catch (InterruptedException e) &#123;&#125; //别这样做</span><br><span class="line">  doSomethingCool();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>InterruptedException 提示应该停止程序正在做的事情，比如事务超时或线程池被关闭等。</p>
<p>应该尽最大努力完成正在做的事情，并完成当前执行的线程，而不是忽略 InterruptedException。修改后的程序如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">while (true) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    Thread.sleep(100000);</span><br><span class="line">  &#125; catch (InterruptedException e) &#123;</span><br><span class="line">    break;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">doSomethingCool();</span><br></pre></td></tr></table></figure>
<p><strong>20、对于重复的 try-catch，使用模板方法 </strong></p>
<p>类似的 catch 块是无用的，只会增加代码的重复性，针对这样的问题可以使用模板方法。</p>
<p>例如，在尝试关闭数据库连接时的异常处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class DBUtil&#123;</span><br><span class="line">    public static void closeConnection(Connection conn)&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            conn.close();</span><br><span class="line">        &#125; catch(Exception ex)&#123;</span><br><span class="line">            //Log Exception - Cannot close connection</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这类的方法将在应用程序很多地方使用。不要把这块代码放的到处都是，而是定义上面的方法，然后像下面这样使用它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void dataAccessCode() &#123;</span><br><span class="line">    Connection conn = null;</span><br><span class="line">    try&#123;</span><br><span class="line">        conn = getConnection();</span><br><span class="line">        ....</span><br><span class="line">    &#125; finally&#123;</span><br><span class="line">        DBUtil.closeConnection(conn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“好了，三妹，关于异常处理实践就先讲这 20 条吧，实际开发中你还会碰到其他的一些坑，自己踩一踩可能印象更深刻一些。”我说。</p>
<p>“那万一到时候我工作后被领导骂了怎么办？”三妹委屈地说。</p>
<p>“新人嘛，总要写几个 bug 才能对得起新人这个称号嘛。”我轻描淡写地说。</p>
<p>“好吧。”三妹无奈地叹了口气。</p>
<h2 id="6-4-空指针的传说"><a href="#6-4-空指针的传说" class="headerlink" title="6.4 空指针的传说"></a>6.4 空指针的传说</h2><p>空指针，号称天下最强刺客。</p>
<p>他原本不叫这个名字，空指针原本复姓异常，空指针只不过是他的武器，但他杀戮过多，渐渐地人们只记住了空指针这三个字。</p>
<p>天下武功，唯快不破，空指针的针，以快和诡异著称，稍有不慎，便是伤亡。</p>
<p>… …</p>
<p>我叫王二，我来到这个奇怪的世界已经一年了，我等了一年，穿越附赠的老爷爷、戒指、系统什么的我到现在都没发现。</p>
<p>而且这个世界看起来也太奇怪了，这里好像叫什么 Java 大陆，我只知道这个世界的最强者叫做 Object，听说是什么道祖级的存在，我也不知道是什么意思，毕竟我现在好像还是个菜鸡，别的主角一年都应该要飞升仙界了吧，我还连个小火球都放不出来。</p>
<p>哦，对了，上面的那段话是我在茶馆喝茶的时候听说书的先生说的，总觉得空指针这个名字怪怪的，好像在什么地方听说过。</p>
<p>我的头痛的毛病又犯了，我已经记不起来我为什么来到这里了，我只记得我的名字叫王二，其他的，我只感觉这个奇怪的世界有一种熟悉，但是我什么都记不起来了。</p>
<p>算了，得过且过吧。</p>
<p>我准备去找空指针了，虽然听说他很可怕，但是好像听说他不是嗜杀之人，应该不会滥杀无辜吧，目前为止，我也只对这三个字有熟悉的感觉了，我一定要找到他，找回我的记忆！</p>
<p>我打听了很久，原来空指针是异常组织的三代嫡传，异常组织是这个世界上最恐怖的杀手组织，空指针就是异常现在最出色的刺客。</p>
<p>听说空指针出生的时候，脖子上就挂着一根针，整个 Java 大陆雪下一月不停，Linux 森林多块陆地直接沉陷，于是他的父亲 RuntimeException 就给他起了空指针这个名字。</p>
<p>空指针出生的天生异象也引起了异常组织高层的注意，听说他的祖父 Exception，还有整个异常组织的领军人物 Throwable 都亲自接见了空指针，并且认为空指针天赋异禀，未来可期。</p>
<p>要知道，Throwable 可是 Object 亲自任命的异常组织头领。作为 Object 最值得信任的亲信，跟随 Object 万年以来，所有的脏活累活都依靠 Thrwoable 创立的异常组织来处理，真可谓一人之下，万人之上。</p>
<p>Throwable 只有两个亲子，就是 Error 和 Exception，传说中 Error 心狠手辣，手下无一活口，见过 Error 的人还能活下来的寥寥无几。</p>
<p>整个大陆只有他们恐怖的传说，谁也不知道他们什么时候出现，但是一旦他们出现，基本宣告着你已经是个死人了。</p>
<p>而我听说过最恐怖的就是 OutOfMemoryError  和  StackOverflowError  这两位刺客，因为大陆上永远有一座风云榜悬挂在帝都门口，而这两位，一直位居杀手榜榜首位置，空指针也只只能屈居第三而已。当然，大陆不少人都认为空指针会后来居上。</p>
<p>我的消息只是打听到这么多，接下来的日子，我走过无数的城市、荒野，我穿过沙漠、丛林，这一天，终于，我来到了大陆的帝都—堆。</p>
<p>这个名字听起来也有点耳熟，不管他，先进城再说。</p>
<p>进城后我发现这里非常诡异，整座城市好像都非常年轻，好像连一个成年人都没有！街道上熙熙攘攘竟然都是年轻人。</p>
<p>带着疑惑，我走进了一家叫做同福客栈的酒楼。</p>
<p>”客官，打尖还是住店啊？“一个小二模样的小孩带着一丝谄媚的对我说。</p>
<p>”住店，带我去最好的房间，这些钱先押你这里，不够再跟我要。“一路走来，对于这些地方的行情我也算轻车熟路了。</p>
<p>”小朋友，这里是怎么回事？你们这里没有大人吗？“我一边走一边问这个只有我一半身高的小孩，根据我目测，他身高不超过1米，应该还只有七八岁的样子，难道这里的商人如此黑心，竟然雇佣童工，不过这也不貌似不对，因为周围的客人好像也都是这般年纪，他们竟然还有在抽烟喝酒的！</p>
<p>”客官可真幽默，不过我看客官应该是刚来帝都，不瞒您说，整个帝都就基本没有超过15岁的人，超过15的据说都在叫做老年区的养老去了！就拿我来说吧，我今年可不小了，我都8岁了，像我这般年纪的已经半截腿迈进棺材咯。哎，这身子也是一年不如一年了。“</p>
<p>看着这个小二一脸认真的样子，我越发觉得这座城市诡异起来了！8岁，什么鬼？8岁不是应该在家里看喜羊羊吗？！还半截腿迈进棺材！</p>
<p>”可是你看我比你高这么多，你不觉得奇怪吗？“我奇怪的问他。</p>
<p>”有什么好奇怪的，要不是我小时候喝多了三鹿，没准我也长这么高了！“小二有点生气的对我说。</p>
<p>行吧，再说两句把他激怒了，跳起来打我膝盖就大事不妙了。</p>
<p>接下来的几天，经过我的打探，原来我在的地方是叫做年轻区，整个帝都就只有这两个区域，年轻区的人年龄确实没有超过15岁的，有些人刚出生没几天就死了，对此，生活在这里的人也见怪不怪了。对于他们来说，寄希望能活到超过15岁进入老年区养老就是他们的梦想。</p>
<p>我在怀疑是不是异常组织在这里暗杀，可是发现结果并不是，这里的人貌似已经习惯了，生活对他们来说就是随便活活就好了，每次的死亡对于他们来说毫无征兆，可能刚踢着球呢，就突然挂了，有的上着厕所突然就死了，临死前连个屁股都没擦，不说了，有点恶心。</p>
<p>就在我等的不耐烦想打算去老年区看看的时候，一个穿着黑衣的人找到了我。</p>
<p>”你是谁？“我警惕的问他。</p>
<p>”本座IOException。“黑衣人神情冰冷的看着我说。</p>
<p>”你找我什么事？“</p>
<p>”这些你不用知道，跟我走一趟吧！“</p>
<p>我刚想说话拒绝，开什么玩笑，跟你们异常组打交道的人非死即残，谁要跟你去。</p>
<p>但是由不得我拒绝，我只感觉一阵天旋地转，我感觉我在天上飞，然后我就失去了意识。当我醒来的时候，我发现我躺在一张巨大的床上，桌子上点着一支檀香，整个房间只有一张桌子、一把椅子和我躺的地方。</p>
<p>房间很小，应该只有10几个平方，但是我竟然又有一种熟悉的感觉，这种感觉萦绕在我心头挥散不去。</p>
<p>没等我再想更多，房门打开了。</p>
<p>”是你，你把我带来干什么？“</p>
<p>”走吧，有人要见你。“</p>
<p>还是不容我抗拒，如果我的战斗力是5的话，我想，IO他该有好几万了吧。</p>
<p>又是这该死的眩晕感，不过这次没有几秒钟，我就发现我在一个花园里，花园中间一个身穿黄袍的中年人正在慢悠悠的喝茶。在他身上我感受不到任何强大的气息，甚至不如IOException给我的压迫感强烈。这是谁？</p>
<p>不等我思绪飘飞，IOException弯腰躬身说道：”陛下，人带过来了。“</p>
<p>”嗯，你退下吧。“中年人转过身来，脸上丝毫看不出情绪的说道。</p>
<p>我大概猜到了这是哪里了，于是也放下心来，在这里，或许能找到我的答案。</p>
<p>反正他要对我怎么样，我也没有办法反抗，我径直坐到他的对面，看着他说：”您就是Object陛下吧，不知找我所谓何事？“</p>
<p>中年人也不在意，没有正面回答我的问题，反而略带一丝调侃的说道：”不用咬文嚼字，说点正常人的话吧。</p>
<p>… …</p>
<p>这不按套路出牌啊，我这不是来久了，模仿你们古代人说话嘛，怎么还埋怨起我来了？！</p>
<p>”那我就直说了，我想知道空指针在哪里。“</p>
<p>”空指针就在皇宫轮值，你找他干嘛？“</p>
<p>”我暂时不能说“</p>
<p>”呵呵，你就不好奇我为什么知道你，为什么又把你带过来？“</p>
<p>”好奇，可是我就是不想问。“</p>
<p>Object喝了口茶，不紧不慢的回道：”年轻人有性格是好事，可是过刚易折的道理你应该明白。“</p>
<p>”我不明白，我在这里反正也没看见什么老人，当然，除了你。“我理所当然的认为这肯定是Object搞得鬼，整个帝都都是小朋友，要是没有猫腻，骗鬼呢！</p>
<p>Object听到这话，皱了皱眉，他沉默了一会儿，缓缓站起身子走到一颗柳树下，背着手说道：“你不知道这一切是为什么吗？”</p>
<p>废话，我当然不知道了，我知道还能问你吗？！</p>
<p>又是沉默… …这个气氛让我感觉很不舒服。就在我受不了想说话的时候，Object突然说了一句：“带他去见空指针吧。”</p>
<p>“是，陛下！”突然，一个身穿红袍的枯瘦老者出现在我背后，把我吓了一跳。</p>
<p>我也不想再多生事端，直觉告诉我这里不是久留之地，虽然有点莫名其妙，我还是跟着红袍老者来走了。</p>
<p>… …</p>
<p>“陛下，是他吗？”一个光头大汉的身影在半空若影若现的说道。</p>
<p>“还不能确定… 不过，留给我们的时间不多了，下一次的轮回就快来了。”</p>
<p>“轮回，又是轮回。我们还有希望吗？”大汉呢喃着，不知道是对自己说还是对中年人说。</p>
<p>中年人依然背着手，抬头望着漫天的柳絮说道：“这一世，该是个了断了。”</p>
<p>… …</p>
<p>没多久，他把我带到一个房间门口，也是面无表情的说道：“进去吧，空指针就在里面。”</p>
<p>我挺住脚步，转过身问他：“你是谁？我们是不是见过？”</p>
<p>红袍老者怪异一笑：“也许吧，老夫 IndexOutOfBoundsException ，空指针便是我好友。”</p>
<p>这个名字可真长，我听说过他，据传闻他的实力也非常之强，可能不下于空指针，都是以诡异的出手角度著称，不过相比于空指针的大名，他好像更低调，难怪在皇宫当个老太监一般。</p>
<p>我也不在多想，点点头，走进了房间。刚进房间，我就看见一个一身白衣的身影背对着我，笔直的身影好像要冲破天际，身上的气势强大无比，至少在我见过的所有人里足以排进前三了。空指针，果然名不虚传！</p>
<p>我走到房间中央，环目四望才发现这好像是一座祠堂的样子，就在我还在打量四周之际，一道清冷的声音传到我的耳边：</p>
<p>“你身上的气息让我非常讨厌！”</p>
<p>他转过身来，我发现我根本看不清空指针长什么样子，他的脸好像打上了马赛克。听到他的话，我心里的疑惑更多了，我只是觉得他的气息让我感到非常熟悉，他的话让我有点莫名其妙。于是我试探道：</p>
<p>“你知道我是谁？”</p>
<p>听到我的话，他一步步走进我，在我身边闻了闻，这让我什么一紧，虽然我想搞清楚我身上的问题，但是我不是出卖肉体的人，我退后一步说：</p>
<p>“你想干嘛？”</p>
<p>空指针皱紧了眉头，仿佛自言自语道：“不对，不对，这是… 规则的气息？可是他明明身上没有任何能量波动。”</p>
<p>我见他好像魔怔了，仿佛在思考什么，于是迈步走到他刚才站立的地方看着前面，原来，这是他们的族谱！</p>
<p>这里是异常的祠堂！</p>
<p><img src="\assets\note\image-20231011144045101.png" alt="image-20231011144045101"></p>
<p>看完这张族谱，我恍然大悟，好像明白了什么。突然，我的脑袋里出现了一个冰冷的机器声音：“获取异常族谱，历练完成度+100。”</p>
<p>我Kao，系统，这是系统啊，我不禁内牛满面，啥任务系统啊，一点提示都没有，我赶紧喊道：</p>
<p>“系统，系统，还在吗？在线等，挺着急的。”可是没有任何回复！这啥破系统！就在我想破口大骂的时候，空指针看到我和个二傻子似的大呼小叫，突然一脸不可思议的对着我说：</p>
<p>“你明悟了规则？”</p>
<p>我愣了愣，嗯？难道我不是战5渣了？规则之力？好像是很高端的样子啊？</p>
<p>“撒豆成兵！”</p>
<p>“呼风！”</p>
<p>”唤雨！“<br>”临兵斗者皆阵列在前！“</p>
<p>一点反应都没有。。。啥玩意儿？还规则之力？九字真言都没用啊？</p>
<p>空指针好像都蒙了，他敲了敲太阳穴，无语的看着我说：</p>
<p>”你不是来找我的吗？说完你的问题，然后给我滚！“</p>
<p>对啊，这系统把我整的我都忘记我来干嘛的了，我赶紧说：</p>
<p>”你认识我对不对，你是不是觉得我有一种熟悉的感觉？我想知道我的来历！“</p>
<p>空指针又愣了愣，他看着我，沉默了一会儿，回道：“不知道！”</p>
<p>我有点奇怪，看他一脸便秘的表情应该是见过我的，他一定在撒谎，既然如此…</p>
<p>“那你告诉我你们有什么办法能在你们异常的攻击下防身吧？”</p>
<p>空指针大怒，刚想起身说话，空中突然传来一道声音：答应他的要求！</p>
<p>他冷哼一声，丢给我一本书，上面写着catch一个字，还有一块写着catch的令牌，冰冷的说到：“你想知道的都在这里了。”说完，拂袖而去。</p>
<p>我看着桌子上的这本书，想了想还是翻阅起来。</p>
<p>原来 Exception  和它的儿子们，除了 RuntimeException  一支，都叫作 Checked Exception ，我还能用catch令牌来对抗他们的攻击！包括空指针，以后我就不怕他们了！</p>
<p>可是，他为什么要给我，看他刚才的样子都想打我了，又突然给了我这些？还有他一直在说的规则之力又是什么？这座城市为什么又这么诡异？</p>
<h2 id="6-5-try-catch会影响性能吗？"><a href="#6-5-try-catch会影响性能吗？" class="headerlink" title="6.5 try-catch会影响性能吗？"></a>6.5 try-catch会影响性能吗？</h2><p>“二哥，你看着这鬼代码，竟然在 for 循环里面搞了个 try-catch ，不知道 try-catch有性能损耗吗？” 老王煞有其事地指着屏幕里的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; 5000; i++) &#123;</span><br><span class="line">     try &#123;</span><br><span class="line">         dosth</span><br><span class="line">     &#125; catch (Exception e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>我探过头去看了眼代码，“那 老王你觉得该怎么改？”</p>
<p>“当然是把 try-catch 提到外面啊！” 老王脑子都不转一下，脱口而出。</p>
<p>“你是不是傻？且不说性能，这代码的目的明显是让循环内部单次调用出错不影响循环的运行，你移到外面，业务逻辑不就变了吗！”<br>老王挠了挠他的地中海，“好像也是啊！”</p>
<p>“回过头来，catch 整个 for 循环和在循环内部 catch，在不出错的情况下，其实性能差不多。” 我喝一口咖啡不经意地提到，准备在 老王前面秀一下。</p>
<p>“啥意思？” 老王有点懵地看着我，“ try-catch是有性能损耗的，我可是看过网上资料的！”</p>
<p>果然， 老王上钩了，我二话不说直接打开 idea，一顿操作敲了以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class TryCatchTest &#123;</span><br><span class="line">    // 用 @Benchmark 注解标记一个方法作为基准测试方法</span><br><span class="line">    @Benchmark</span><br><span class="line">    public void tryfor(Blackhole blackhole) &#123;</span><br><span class="line">        // 使用 try-catch 语句包装一个 for 循环</span><br><span class="line">        try &#123;</span><br><span class="line">            for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">                // 在循环中调用 Blackhole.consume() 方法</span><br><span class="line">                blackhole.consume(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            // 捕获异常并打印堆栈跟踪信息</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 用 @Benchmark 注解标记另一个方法作为基准测试方法</span><br><span class="line">    @Benchmark</span><br><span class="line">    public void fortry(Blackhole blackhole) &#123;</span><br><span class="line">        // 使用 for 循环包装一个 try-catch 语句</span><br><span class="line">        for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                // 在 try 块中调用 Blackhole.consume() 方法</span><br><span class="line">                blackhole.consume(i);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                // 捕获异常并打印堆栈跟踪信息</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，请允许我补充一些概念，以便大家能更好的理解这段代码。</p>
<blockquote>
<p>第一个： @Benchmark 是一个来自于 JMH（Java Microbenchmark Harness）库的注解，用来标记一个方法作为基准测试方法。JMH 是一个专门用于编写 Java 微基准测试的工具包，包含了一些用于测试 Java 代码性能和微调 JVM 的工具和库。使用 @Benchmark 注解标记的方法将被 JMH 自动识别为基准测试方法，并在运行时进行基准测试。在基准测试期间，JMH 会运行被标记的方法多次，并测量方法的执行时间、吞吐量、延迟等指标，并生成统计结果。</p>
<p>第二个：在 JMH 进行基准测试时，为了避免 JIT 编译器优化掉测试代码中的某些操作，我们需要在测试代码中使用一些占位符，以便让编译器认为这些操作是有意义的，不应该被优化掉。Blackhole.consume() 方法就是这样的一个占位符。它用来占用一些 CPU 时间和内存空间，以确保测试结果的准确性和可靠性。</p>
</blockquote>
<p>“BB 不如 show code，看到没， 老王，我把 try-catch 从 for 循环里面提出来跟在for循环里面做个对比跑一下，你猜猜两个差多少？”</p>
<p>“切，肯定 tryfor 性能好，想都不用想，不是的话我倒立洗头！” 老王信誓旦旦道。</p>
<p>我懒得跟他BB，直接开始了 benchmark，跑的结果如下：<br>     <img src="\assets\note\image-20231011144451106.png" alt="image-20231011144451106"></p>
<p>可以看到，两者的性能（数字越大越好）其实差不多：551063.024 VS 551525.861。</p>
<p>在这里，简单普及一下 JMH 的使用指南。</p>
<blockquote>
<p>第一步，在 pom.xml 文件中加入依赖。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 引入 JMH 工具包 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.openjdk.jmh&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jmh-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.35&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.openjdk.jmh&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jmh-generator-annprocess&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.35&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第二步，Intellij IDEA 中安装 JMH 插件。</p>
</blockquote>
<p><img src="\assets\note\image-20231011144544374.png" alt="image-20231011144544374"></p>
<blockquote>
<p>第三步，在代码编辑器中点击这个带有时间和运行的图标。然后静静等待结果就可以了，我本机（32G 内存 Intel i7 跑了 16 分钟，贼慢，因为 JMH 比较喜欢追求公平公正 ）</p>
</blockquote>
<p><img src="\assets\note\image-20231011144619049.png" alt="image-20231011144619049"></p>
<p>老王一看傻了：“说好的性能影响呢？怎么没了？”</p>
<p>我直接一个javap，让 老王看看，其实两个实现在字节码层面没啥区别：</p>
<blockquote>
<p>tryfor 的字节码</p>
</blockquote>
<p>异常表记录的是 0 - 20 行，如果这些行里面的代码出现问题，直接跳到 23 行处理。</p>
<p><img src="\assets\note\image-20231011144653816.png" alt="image-20231011144653816"></p>
<blockquote>
<p>fortry 的字节码</p>
</blockquote>
<p>差别也就是异常表的范围小点，包的是 9-14 行，其它跟 tryfor 都差不多。</p>
<p><img src="\assets\note\image-20231011144720356.png" alt="image-20231011144720356"></p>
<p>所以从字节码层面来看，没抛错两者的执行效率其实没啥差别。</p>
<p>“那为什么网上流传着 try-catch会有性能问题的说法啊？” 老王觉得非常奇怪。</p>
<p>这个说法确实有，在《Effective Java》这本书里就提到了 try-catch 性能问题：</p>
<p><img src="\assets\note\image-20231011144813673.png" alt="image-20231011144813673"></p>
<p>正所谓听话不能听一半，以前读书时候最怕的就是一知半解，因为完全理解选择题能选对，完全不懂蒙可能蒙对，一知半解必定选到错误的选项！</p>
<p>《Effective Java》书中说的其实是不要用 try-catch 来代替正常的代码，书中的举例了正常的 for 循环肯定这样实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for ( Mountain m : range )</span><br><span class="line">    m.climb();</span><br></pre></td></tr></table></figure>
<p>但有个卧龙偏偏不这样实现，要通过   try-catch 拐着弯来实现循环：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* Horrible abuse of exceptions. Don&#x27;t ever do this! */</span><br><span class="line">try &#123;</span><br><span class="line">    int i = 0;</span><br><span class="line">    while ( true )</span><br><span class="line">        range[i++].climb();</span><br><span class="line">&#125; catch ( ArrayIndexOutOfBoundsException e ) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这操作我只能说有点逆天，这两个实现的对比就有性能损耗了。</p>
<p>我们直接再跑下有 try-catch 的代码和没 try-catch的 for 循环区别，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class TryCatchTest1 &#123;</span><br><span class="line">    @Benchmark</span><br><span class="line">    public void fornotry(Blackhole blackhole) &#123;</span><br><span class="line">        for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">            blackhole.consume(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Benchmark</span><br><span class="line">    public void tryfor(Blackhole blackhole) &#123;</span><br><span class="line">        for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                blackhole.consume(i);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="\assets\note\image-20231011144930607.png" alt="image-20231011144930607"></p>
<p>+-差不多，直接看前面的分数对比，没有 ry-catch 的性能确实好些，这也和书中说的 try-catch 会影响 JVM 一些特定的优化说法吻合，但是具体没有说影响哪些优化，我猜测可能是指令重排之类的。</p>
<p>好了，我再总结下有关 try-catch 性能问题说法：</p>
<ol>
<li>try-catch 相比较没 try-catch ，确实有一定的性能影响，但是旨在不推荐我们用 try-catch 来代替正常能不用 try-catch 的实现，而不是不让用 try-catch 。</li>
<li>for循环内用   try-catch 和用 try-catch 包裹整个 for 循环性能差不多，但是其实两者本质上是业务处理方式的不同，跟性能扯不上关系，关键看你的业务流程处理。</li>
<li>虽然知道 try-catch会有性能影响，但是业务上不需要避讳其使用，业务实现优先（只要不是书中举例的那种逆天代码就行），非特殊情况下性能都是其次，有意识地避免大范围的 try-catch ，只 catch 需要的部分即可（没把握全 catch 也行，代码安全执行第一）。</li>
</ol>
<p>“好了， 老王你懂了没？”</p>
<p>“行啊二哥，BB是一套一套的，走请你喝燕麦拿铁！”  老王一把拉起我，我直接一个挣脱，“少来，我刚喝过咖啡，你那个倒立洗头，赶紧的！”我立马意识到 老王想岔开话题。</p>
<p>“洗洗洗，我们先喝个咖啡，晚上回去给你洗！”</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://htx-rest.github.io">鲸落</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://htx-rest.github.io/posts/c15068a.html">https://htx-rest.github.io/posts/c15068a.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://htx-rest.github.io" target="_blank">鲸落</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/">异常处理</a><a class="post-meta__tags" href="/tags/Java-IO/">Java IO</a></div><div class="post_share"><div class="social-share" data-image="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/assets/weplay.png" target="_blank"><img class="post-qr-code-img" src="/assets/weplay.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/assets/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/assets/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/bb381fef.html" title="Java进阶之路（四）"><img class="cover" src="https://source.fomal.cc/img/default_cover_14.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java进阶之路（四）</div></div></a></div><div class="next-post pull-right"><a href="/posts/410ba5d8.html" title="Java进阶之路（二）"><img class="cover" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java进阶之路（二）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/d29183.html" title="Java基础面试高频题"><img class="cover" src="https://img2.baidu.com/it/u=595920241,2439700946&fm=253&fmt=auto&app=120&f=JPEG?w=1422&h=800" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2023-10-14</div><div class="title">Java基础面试高频题</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://tuchuang.voooe.cn/images/2023/01/02/avatar.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">鲸落</div><div class="author-info__description">随波不逐流</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">112</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">149</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/htx-rest"><i class="fab fa-github"></i><span>前往小窝</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="/assets/wenxin.jpg" target="_blank" title="微信"><i class="iconfont icon-weixin" style="color: #24292e;"></i></a><a class="social-icon" href="/assets/weixingongzhonghao.jpg" target="_blank" title="微信公众号"><i class="iconfont icon-weixingongzhonghao" style="color: #24292e;"></i></a><a class="social-icon" href="https://res.abeim.cn/api/qq/?qq=1656855152" target="_blank" title="QQ"><i class="iconfont icon-QQ" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:1656855152@qq.com" target="_blank" title="QQ邮箱"><i class="iconfont icon-youxiang" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">摸鱼中！！！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#5-Java-IO"><span class="toc-text">5 Java IO</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-IO-%E5%88%86%E7%B1%BB"><span class="toc-text">5.1 IO 分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E6%96%87%E4%BB%B6%E6%B5%81"><span class="toc-text">5.2 文件流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E5%AD%97%E8%8A%82%E6%B5%81"><span class="toc-text">5.3 字节流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="toc-text">5.4 字符流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-text">5.5 缓冲流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6-%E8%BD%AC%E6%8D%A2%E6%B5%81"><span class="toc-text">5.6 转换流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-7-%E6%89%93%E5%8D%B0%E6%B5%81"><span class="toc-text">5.7 打印流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-8-%E5%BA%8F%E5%88%97%E6%B5%81-%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">5.8 序列流(序列化和反序列化)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-9-%E5%BA%8F%E5%88%97%E6%8E%A5%E5%8F%A3Serializable"><span class="toc-text">5.9 序列接口Serializable</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-10-transient%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">5.10 transient关键字</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-text">6 异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90"><span class="toc-text">6.1 Java异常处理全面解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-try-with-resources"><span class="toc-text">6.2 try-with-resources</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%8420%E4%B8%AA%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-text">6.3 异常处理的20个最佳实践</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-%E7%A9%BA%E6%8C%87%E9%92%88%E7%9A%84%E4%BC%A0%E8%AF%B4"><span class="toc-text">6.4 空指针的传说</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5-try-catch%E4%BC%9A%E5%BD%B1%E5%93%8D%E6%80%A7%E8%83%BD%E5%90%97%EF%BC%9F"><span class="toc-text">6.5 try-catch会影响性能吗？</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 By 鲸落</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">I wish you to become your own sun, no need to rely on who's light.</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async src="https://cdn1.tianli0.top/npm/vue@2.6.14/dist/vue.min.js"></script><script async src="https://cdn1.tianli0.top/npm/element-ui@2.15.6/lib/index.js"></script><script async src="https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script><script defer type="text/javascript" src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script defer src="https://cdn1.tianli0.top/gh/nextapps-de/winbox/dist/winbox.bundle.min.js"></script><script async src="//at.alicdn.com/t/c/font_4233300_xxm4hpxio1.js"></script><script async src="/js/fps.js"></script><script async src="https://cdn.wpon.cn/2022-sucai/Gold-ingot.js"></script><script defer data-pjax src="/js/cat.js"></script><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><canvas id="snow"></canvas><script defer src="/js/fomal.js"></script><script defer src="/js/cursor.js"></script><script defer src="/live2d-widget/autoload.js"></script><script async src="/js/title.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 190px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 160px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(http://p0.itc.cn/images03/20200525/332e1ea10c634cbfaf0dfc5b69d00a3c.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Docker/&quot;);" href="javascript:void(0);">Docker</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr">Docker</span></li><li class="categoryBar-list-item" style="background:url(http://p8.itc.cn/images03/20200525/377f4f7044fe49b0bb932f43ef4f4891.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Hexo魔改教程/&quot;);" href="javascript:void(0);">Hexo魔改教程</a><span class="categoryBar-list-count">12</span><span class="categoryBar-list-descr">Hexo魔改教程</span></li><li class="categoryBar-list-item" style="background:url(http://p8.itc.cn/images03/20200525/0ed549edde2c4d5eaecc2824e753ca74.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/面试题/&quot;);" href="javascript:void(0);">面试题</a><span class="categoryBar-list-count">10</span><span class="categoryBar-list-descr">MySQL</span></li><li class="categoryBar-list-item" style="background:url(http://p6.itc.cn/images03/20200525/8dedcdf6ace44a50a1deb6a9743821fe.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/面渣笔记/&quot;);" href="javascript:void(0);">面渣笔记</a><span class="categoryBar-list-count">5</span><span class="categoryBar-list-descr">面试题</span></li><li class="categoryBar-list-item" style="background:url(http://p8.itc.cn/images03/20200525/5f6cecf10ea04dec9a5d42bf9c4c3739.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/MySQL/&quot;);" href="javascript:void(0);">MySQL</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr">Redis</span></li><li class="categoryBar-list-item" style="background:url(http://p0.itc.cn/images03/20200525/332e1ea10c634cbfaf0dfc5b69d00a3c.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/RabbitMQ/&quot;);" href="javascript:void(0);">RabbitMQ</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr">Java笔试编程真题</span></li><li class="categoryBar-list-item" style="background:url(http://p8.itc.cn/images03/20200525/377f4f7044fe49b0bb932f43ef4f4891.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Redis/&quot;);" href="javascript:void(0);">Redis</a><span class="categoryBar-list-count">5</span><span class="categoryBar-list-descr">Java数据结构与算法</span></li><li class="categoryBar-list-item" style="background:url(http://p8.itc.cn/images03/20200525/0ed549edde2c4d5eaecc2824e753ca74.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Kafka/&quot;);" href="javascript:void(0);">Kafka</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(http://p6.itc.cn/images03/20200525/8dedcdf6ace44a50a1deb6a9743821fe.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Java笔试编程真题/&quot;);" href="javascript:void(0);">Java笔试编程真题</a><span class="categoryBar-list-count">67</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/面试/&quot;);" href="javascript:void(0);">面试</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/设计模式/&quot;);" href="javascript:void(0);">设计模式</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Java数据结构与算法/&quot;);" href="javascript:void(0);">Java数据结构与算法</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var qweather_key = 'b16a1fa0e63c46a4b8f28abfb06ae3fe';
  var gaud_map_key = 'e2b04289e870b005374ee030148d64fd&s=rsv3';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '113.34532,23.15624';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v6.2.0" title=""><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.9.0" title=""><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="https://npm.elemecdn.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.js"></script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/b2891dfd.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-14</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/b2891dfd.html&quot;);" href="javascript:void(0);" alt="">美团校招笔试编程真题（2023.3.11）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/b2891dfd.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/a449f40d.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-22</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/a449f40d.html&quot;);" href="javascript:void(0);" alt="">美的校招笔试编程真题（2023.4.19）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/a449f40d.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/1b4308aa.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-17</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/1b4308aa.html&quot;);" href="javascript:void(0);" alt="">美团校招笔试编程真题（2023.4.8）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/1b4308aa.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/7b50e04c.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/7b50e04c.html&quot;);" href="javascript:void(0);" alt="">美团校招笔试编程真题（2023.5.13）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/7b50e04c.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/f53a714c.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/f53a714c.html&quot;);" href="javascript:void(0);" alt="">美团校招笔试编程真题（2023.4.29）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/f53a714c.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/9a879128.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/9a879128.html&quot;);" href="javascript:void(0);" alt="">美团校招笔试编程真题（2023.4.23）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/9a879128.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/f84cb424.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-17</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/f84cb424.html&quot;);" href="javascript:void(0);" alt="">美团校招笔试编程真题（2023.4.15）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/f84cb424.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/cf815277.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-15</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/cf815277.html&quot;);" href="javascript:void(0);" alt="">美团校招笔试编程真题（2023.3.18）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/cf815277.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/6482affa.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/6482affa.html&quot;);" href="javascript:void(0);" alt="">美团校招笔试编程真题及其解析（2023.3.25）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/6482affa.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/7a556a2f.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-14</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/7a556a2f.html&quot;);" href="javascript:void(0);" alt="">美团2024届秋招笔试编程真题（2023.9.9）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/7a556a2f.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/843d6f38.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/843d6f38.html&quot;);" href="javascript:void(0);" alt="">美团校招笔试编程真题及其解析（2023.3.4）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/843d6f38.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/61f68248.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/61f68248.html&quot;);" href="javascript:void(0);" alt="">美团2024届秋招笔试第四场编程真题（2023.9.2）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/61f68248.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/5b7a3f2a.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-07</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/5b7a3f2a.html&quot;);" href="javascript:void(0);" alt="">美团2024届秋招笔试第三场编程真题（2023.8.26）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/5b7a3f2a.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/f51f72fb.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-06</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/f51f72fb.html&quot;);" href="javascript:void(0);" alt="">美团2024届秋招笔试第二场编程真题（2023.8.19）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/f51f72fb.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/860131f4.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-04</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/860131f4.html&quot;);" href="javascript:void(0);" alt="">美团2024届秋招笔试第一场编程真题（2023.8.12）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/860131f4.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/9ed49519.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/9ed49519.html&quot;);" href="javascript:void(0);" alt="">网易有道校招笔试编程真题及其解析（2023.4.2）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/9ed49519.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/6da30861.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/6da30861.html&quot;);" href="javascript:void(0);" alt="">科大讯飞校招笔试编程真题（2023.7.8）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/6da30861.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/f766fbc2.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/f766fbc2.html&quot;);" href="javascript:void(0);" alt="">科大讯飞校招笔试编程真题（2023.8.31）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/f766fbc2.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/f9fa8a74.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/f9fa8a74.html&quot;);" href="javascript:void(0);" alt="">科大讯飞校招笔试编程真题（2023.7.29）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/f9fa8a74.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/10ab47eb.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/10ab47eb.html&quot;);" href="javascript:void(0);" alt="">科大讯飞校招笔试编程真题（2023.7.1）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/10ab47eb.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2efb0d75.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2efb0d75.html&quot;);" href="javascript:void(0);" alt="">科大讯飞校招笔试编程真题（2023.7.22）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2efb0d75.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/7641fb6a.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/7641fb6a.html&quot;);" href="javascript:void(0);" alt="">科大讯飞校招笔试编程真题（2022.10.14）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/7641fb6a.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/815405c2.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/815405c2.html&quot;);" href="javascript:void(0);" alt="">科大讯飞校招笔试编程真题及其解析（2023.8.13）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/815405c2.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/52772af7.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/52772af7.html&quot;);" href="javascript:void(0);" alt="">科大讯飞校招笔试编程真题及其解析（2023.7.15）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/52772af7.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/a135cfaa.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/a135cfaa.html&quot;);" href="javascript:void(0);" alt="">携程校招笔试编程真题及其解析（2023.9.7）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/a135cfaa.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/b264b8b5.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-26</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/b264b8b5.html&quot;);" href="javascript:void(0);" alt="">携程校招笔试编程真题及其解析（2023.9.21）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/b264b8b5.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/c442a03f.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-26</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/c442a03f.html&quot;);" href="javascript:void(0);" alt="">携程校招笔试编程真题及其解析（2023.5.4）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/c442a03f.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/aeeccc.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/aeeccc.html&quot;);" href="javascript:void(0);" alt="">携程校招笔试编程真题及其解析（2023.3.7）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/aeeccc.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/faa64596.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/faa64596.html&quot;);" href="javascript:void(0);" alt="">携程校招笔试编程真题及其解析（2023.5.25）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/faa64596.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/1b7134f2.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/1b7134f2.html&quot;);" href="javascript:void(0);" alt="">携程校招笔试编程真题及其解析（2023.4.15）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/1b7134f2.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/cc63a592.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/cc63a592.html&quot;);" href="javascript:void(0);" alt="">携程校招笔试编程真题及其解析（2023.3.16）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/cc63a592.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/d3a0cf14.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-26</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/d3a0cf14.html&quot;);" href="javascript:void(0);" alt="">携程校招笔试编程真题及其解析（2023.3.29）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/d3a0cf14.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2ec06a90.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-23</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2ec06a90.html&quot;);" href="javascript:void(0);" alt="">恒生电子校招笔试编程真题（2023.9.22）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2ec06a90.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/7520a94a.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-27</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/7520a94a.html&quot;);" href="javascript:void(0);" alt="">微众银行校招笔试编程真题及其解析（2023.9.13）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/7520a94a.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/acdf6806.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-27</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/acdf6806.html&quot;);" href="javascript:void(0);" alt="">微众银行校招笔试编程真题及其解析（2023.9.3）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/acdf6806.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/5357b25a.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-27</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/5357b25a.html&quot;);" href="javascript:void(0);" alt="">微众银行校招笔试编程真题及其解析（2023.4.23）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/5357b25a.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/70a5bb78.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-11</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/70a5bb78.html&quot;);" href="javascript:void(0);" alt="">广联达校招笔试编程真题及其解析（2023.10.11）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/70a5bb78.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/ac4bafef.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-27</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/ac4bafef.html&quot;);" href="javascript:void(0);" alt="">微众银行校招笔试编程真题及其解析（2023.4.12）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/ac4bafef.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/bad939ec.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-22</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/bad939ec.html&quot;);" href="javascript:void(0);" alt="">小红书校招笔试编程真题（2023.8.6）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/bad939ec.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/92b4cb69.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-22</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/92b4cb69.html&quot;);" href="javascript:void(0);" alt="">小红书校招笔试编程真题（2023.8.19）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/92b4cb69.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/4ce12134.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-22</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/4ce12134.html&quot;);" href="javascript:void(0);" alt="">小红书校招笔试编程真题（2023.7.23）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/4ce12134.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/befb4d57.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-22</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/befb4d57.html&quot;);" href="javascript:void(0);" alt="">小红书校招笔试编程真题（2023.5.7）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/befb4d57.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/9578e9c1.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-22</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/9578e9c1.html&quot;);" href="javascript:void(0);" alt="">小红书校招笔试编程真题（2023.4.9）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/9578e9c1.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/7d093ba9.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-22</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/7d093ba9.html&quot;);" href="javascript:void(0);" alt="">小红书校招笔试编程真题（2023.4.23）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/7d093ba9.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/8f70f515.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-22</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/8f70f515.html&quot;);" href="javascript:void(0);" alt="">小红书校招笔试编程真题（2023.3.26）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/8f70f515.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/c13307dc.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/c13307dc.html&quot;);" href="javascript:void(0);" alt="">java进阶之路（一）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/c13307dc.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/f0ad93be.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/f0ad93be.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.9.27）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/f0ad93be.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/386f7e39.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/386f7e39.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.9.13）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/386f7e39.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/7fcf04e9.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/7fcf04e9.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.9.23）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/7fcf04e9.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/6d7aab07.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/6d7aab07.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.9.20）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/6d7aab07.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/f66d8903.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/f66d8903.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.8.30）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/f66d8903.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/1175732f.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/1175732f.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.5.6）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/1175732f.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/d9b80f5d.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/d9b80f5d.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.8.23）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/d9b80f5d.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2f068fa6.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2f068fa6.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.5.31）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2f068fa6.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/25b85624.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/25b85624.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.5.24）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/25b85624.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/ed7abba3.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/ed7abba3.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.5.10）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/ed7abba3.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/70ad831a.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/70ad831a.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.5.17）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/70ad831a.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/29c6951b.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/29c6951b.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.4.26）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/29c6951b.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/3605ff9d.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/3605ff9d.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.4.19）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/3605ff9d.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/6dea1f6c.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/6dea1f6c.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.10.12）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/6dea1f6c.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/e104789c.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/e104789c.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.4.12）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/e104789c.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/7f5fb082.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/7f5fb082.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.10.11）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/7f5fb082.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/68b410aa.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/68b410aa.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2022.9.23）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/68b410aa.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/c2bdd821.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/c2bdd821.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2022.9.21）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/c2bdd821.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/e1169d40.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-10</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/e1169d40.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2022.8.30）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/e1169d40.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/b477f365.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-10</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/b477f365.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2022.11.2）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/b477f365.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/82287452.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/82287452.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2022.10.12）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/82287452.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/bb381fef.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/bb381fef.html&quot;);" href="javascript:void(0);" alt="">Java进阶之路（四）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/bb381fef.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/410ba5d8.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/410ba5d8.html&quot;);" href="javascript:void(0);" alt="">Java进阶之路（二）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/410ba5d8.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/c15068a.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/c15068a.html&quot;);" href="javascript:void(0);" alt="">Java进阶之路（三）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/c15068a.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/3cbc845.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/3cbc845.html&quot;);" href="javascript:void(0);" alt="">Java数据结构与算法</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/3cbc845.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/f9c52cbb.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-19</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/f9c52cbb.html&quot;);" href="javascript:void(0);" alt="">设计模式面试篇-参考回答</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/f9c52cbb.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/eabb6106.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-12</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/eabb6106.html&quot;);" href="javascript:void(0);" alt="">消息中间件面试题-参考回答</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/eabb6106.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/27f853cc.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/27f853cc.html&quot;);" href="javascript:void(0);" alt="">框架篇面试题-参考回答</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/27f853cc.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/6ba374e2.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/6ba374e2.html&quot;);" href="javascript:void(0);" alt="">微服务面试篇-参考回答</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/6ba374e2.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/dbf9d5c9.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/dbf9d5c9.html&quot;);" href="javascript:void(0);" alt="">常见技术场景</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/dbf9d5c9.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/af15ea36.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/af15ea36.html&quot;);" href="javascript:void(0);" alt="">多线程相关面试题</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/af15ea36.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/258353ca.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/258353ca.html&quot;);" href="javascript:void(0);" alt="">kafka深入浅出，快速玩转分布式发布订阅消息系统</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/258353ca.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/6f83b1e4.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/6f83b1e4.html&quot;);" href="javascript:void(0);" alt="">Redis面试题-参考回答</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/6f83b1e4.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/37cf2cfd.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/37cf2cfd.html&quot;);" href="javascript:void(0);" alt="">Redis集群</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/37cf2cfd.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/d2ba1e3f.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/d2ba1e3f.html&quot;);" href="javascript:void(0);" alt="">Redis原理篇</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/d2ba1e3f.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/6bb2589.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-12</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/6bb2589.html&quot;);" href="javascript:void(0);" alt="">Rabbitmq消息中间件（二）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/6bb2589.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/18ab1f25.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/18ab1f25.html&quot;);" href="javascript:void(0);" alt="">MySQL面试篇-参考回答</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/18ab1f25.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/6bb2589.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-12</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/6bb2589.html&quot;);" href="javascript:void(0);" alt="">Rabbitmq消息中间件（一）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/6bb2589.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/11f76754.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/11f76754.html&quot;);" href="javascript:void(0);" alt="">MySQL进阶篇</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/11f76754.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/592cf81.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/592cf81.html&quot;);" href="javascript:void(0);" alt="">MySQL运维篇</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/592cf81.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/337fcc87.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/337fcc87.html&quot;);" href="javascript:void(0);" alt="">MySQL基础篇</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/337fcc87.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/b481a8d6.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/b481a8d6.html&quot;);" href="javascript:void(0);" alt="">Java集合相关面试题</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/b481a8d6.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/c218eb30.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/c218eb30.html&quot;);" href="javascript:void(0);" alt="">JVM相关面试题</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/c218eb30.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/7eb663f5.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/7eb663f5.html&quot;);" href="javascript:void(0);" alt="">Docker安装OpenResty</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/7eb663f5.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/be6d66dc.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/be6d66dc.html&quot;);" href="javascript:void(0);" alt="">Docker安装Canal</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/be6d66dc.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/a6573b44.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/a6573b44.html&quot;);" href="javascript:void(0);" alt="">Centos7安装Docker</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/a6573b44.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/d3404069.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/d3404069.html&quot;);" href="javascript:void(0);" alt="">Redis高级篇</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/d3404069.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/a6b15897.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/a6b15897.html&quot;);" href="javascript:void(0);" alt="">Redis实战篇</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/a6b15897.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/4604f75b.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-01</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/4604f75b.html&quot;);" href="javascript:void(0);" alt="">Redis基础篇</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/4604f75b.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '1s');
    arr[i].setAttribute('data-wow-offset', '100');
    arr[i].setAttribute('data-wow-iteration', '2');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --></body></html>