<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java进阶之路 | 鲸落</title><meta name="author" content="鲸落"><meta name="copyright" content="鲸落"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1 Java语法基础1.1 Java关键字和保留字1、abstract： 用于声明抽象类，以及抽象方法。 1234567891011abstract class Animal &amp;#123;    abstract void makeSound();    public void sleep() &amp;#123;        System.out.println(&quot;The animal is">
<meta property="og:type" content="article">
<meta property="og:title" content="Java进阶之路">
<meta property="og:url" content="https://htx-rest.github.io/posts/7ec90956.html">
<meta property="og:site_name" content="鲸落">
<meta property="og:description" content="1 Java语法基础1.1 Java关键字和保留字1、abstract： 用于声明抽象类，以及抽象方法。 1234567891011abstract class Animal &amp;#123;    abstract void makeSound();    public void sleep() &amp;#123;        System.out.println(&quot;The animal is">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg">
<meta property="article:published_time" content="2023-09-25T02:08:49.000Z">
<meta property="article:modified_time" content="2023-10-09T03:18:31.912Z">
<meta property="article:author" content="鲸落">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="面试">
<meta property="article:tag" content="基础知识">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg"><link rel="shortcut icon" href="/"><link rel="canonical" href="https://htx-rest.github.io/posts/7ec90956.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java进阶之路',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-10-09 11:18:31'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_4233300_xxm4hpxio1.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/element-ui@2.15.6/packages/theme-chalk/lib/index.css"><script src="https://npm.elemecdn.com/echarts@4.9.0/dist/echarts.min.js"></script><style id="themeColor"></style><style id="rightSide"></style><style id="transPercent"></style><style id="blurNum"></style><style id="settingStyle"></style><span id="fps"></span><style id="defineBg"></style><style id="menu_shadow"></style><div id="myscoll"></div><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://tuchuang.voooe.cn/images/2023/01/02/avatar.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">85</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">123</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-youhuawenzhang"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-guidang"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei"></i><span> 分类</span></a></li><li><a class="site-page child" href="javascript:randomPost();"><i class="fa-fw iconfont icon-wode-zuji-copy"></i><span> 随便逛逛</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-xiuxianyinpin"></i><span> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/life/music/"><i class="fa-fw iconfont icon-tool"></i><span> 八音盒</span></a></li><li><a class="site-page child" href="/life/movies/"><i class="fa-fw iconfont icon-dianying"></i><span> 影院</span></a></li><li><a class="site-page child" href="/life/games/"><i class="fa-fw iconfont icon-youxi"></i><span> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-baoxiang21"></i><span> 八宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/box/gallery/"><i class="fa-fw iconfont icon-hualang"></i><span> 画廊</span></a></li><li><a class="site-page child" href="/box/animation/"><i class="fa-fw iconfont icon-donghua"></i><span> 动画</span></a></li><li><a class="site-page child" href="/box/nav/"><i class="fa-fw iconfont icon-a-06-wangzhidaohang"></i><span> 网址导航</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-tubiaozhizuomoban1"></i><span> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/social/fcircle/"><i class="fa-fw iconfont icon-iconfontzhizuobiaozhunbduan36"></i><span> 朋友圈</span></a></li><li><a class="site-page child" href="/comments/"><i class="fa-fw iconfont icon-liuyanban"></i><span> 留言板</span></a></li><li><a class="site-page child" href="/social/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-a-06-wangzhidaohang"></i><span> 网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/site/census/"><i class="fa-fw iconfont icon-a-06-wangzhidaohang"></i><span> 网站统计</span></a></li><li><a class="site-page child" href="/site/echarts/"><i class="fa-fw iconfont icon-tongji"></i><span> 文章统计</span></a></li><li><a class="site-page child" href="/site/time/"><i class="fa-fw iconfont icon-shalou"></i><span> 旧时光</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-geren"></i><span> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/personal/bb/"><i class="fa-fw iconfont icon-icon_liuyan"></i><span> 唠叨</span></a></li><li><a class="site-page child" href="/personal/love/"><i class="fa-fw iconfont icon-valentine_-email-love-message-send"></i><span> 恋爱小屋</span></a></li><li><a class="site-page child" href="/personal/about/"><i class="fa-fw iconfont icon-icon-lark-logo-old"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="鲸落"><span class="site-name">鲸落</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-youhuawenzhang"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-guidang"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei"></i><span> 分类</span></a></li><li><a class="site-page child" href="javascript:randomPost();"><i class="fa-fw iconfont icon-wode-zuji-copy"></i><span> 随便逛逛</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-xiuxianyinpin"></i><span> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/life/music/"><i class="fa-fw iconfont icon-tool"></i><span> 八音盒</span></a></li><li><a class="site-page child" href="/life/movies/"><i class="fa-fw iconfont icon-dianying"></i><span> 影院</span></a></li><li><a class="site-page child" href="/life/games/"><i class="fa-fw iconfont icon-youxi"></i><span> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-baoxiang21"></i><span> 八宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/box/gallery/"><i class="fa-fw iconfont icon-hualang"></i><span> 画廊</span></a></li><li><a class="site-page child" href="/box/animation/"><i class="fa-fw iconfont icon-donghua"></i><span> 动画</span></a></li><li><a class="site-page child" href="/box/nav/"><i class="fa-fw iconfont icon-a-06-wangzhidaohang"></i><span> 网址导航</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-tubiaozhizuomoban1"></i><span> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/social/fcircle/"><i class="fa-fw iconfont icon-iconfontzhizuobiaozhunbduan36"></i><span> 朋友圈</span></a></li><li><a class="site-page child" href="/comments/"><i class="fa-fw iconfont icon-liuyanban"></i><span> 留言板</span></a></li><li><a class="site-page child" href="/social/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-a-06-wangzhidaohang"></i><span> 网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/site/census/"><i class="fa-fw iconfont icon-a-06-wangzhidaohang"></i><span> 网站统计</span></a></li><li><a class="site-page child" href="/site/echarts/"><i class="fa-fw iconfont icon-tongji"></i><span> 文章统计</span></a></li><li><a class="site-page child" href="/site/time/"><i class="fa-fw iconfont icon-shalou"></i><span> 旧时光</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-geren"></i><span> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/personal/bb/"><i class="fa-fw iconfont icon-icon_liuyan"></i><span> 唠叨</span></a></li><li><a class="site-page child" href="/personal/love/"><i class="fa-fw iconfont icon-valentine_-email-love-message-send"></i><span> 恋爱小屋</span></a></li><li><a class="site-page child" href="/personal/about/"><i class="fa-fw iconfont icon-icon-lark-logo-old"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java进阶之路</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-09-25T02:08:49.000Z" title="发表于 2023-09-25 10:08:49">2023-09-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-10-09T03:18:31.912Z" title="更新于 2023-10-09 11:18:31">2023-10-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E6%B8%A3%E7%AC%94%E8%AE%B0/">面渣笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">97k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>345分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java进阶之路"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="1-Java语法基础"><a href="#1-Java语法基础" class="headerlink" title="1 Java语法基础"></a>1 Java语法基础</h1><h2 id="1-1-Java关键字和保留字"><a href="#1-1-Java关键字和保留字" class="headerlink" title="1.1 Java关键字和保留字"></a>1.1 Java关键字和保留字</h2><p>1、<strong>abstract</strong>： 用于声明抽象类，以及抽象方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">abstract class Animal &#123;</span><br><span class="line">    abstract void makeSound();</span><br><span class="line">    public void sleep() &#123;</span><br><span class="line">        System.out.println(&quot;The animal is sleeping.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">    void makeSound() &#123;</span><br><span class="line">        System.out.println(&quot;The dog barks.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们创建了一个名为 Animal 的抽象类，其中包含一个抽象方法 makeSound() 和一个具体方法 sleep() 。</p>
<p>2、<strong>boolean</strong>： Java 中的一种基本数据类型，表示布尔值，即真（true）或假（false）。boolean 数据类型常用于判断条件、循环控制和逻辑运算等场景。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">boolean isStudent = true;</span><br><span class="line">if (isStudent) &#123;</span><br><span class="line">    System.out.println(&quot;This person is a student.&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    System.out.println(&quot;This person is not a student.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们定义了一个 boolean 变量：isStudent。通过 if 语句，我们可以根据这些变量的值进行不同的操作。</p>
<p>3、<strong>break</strong>： 用于跳出循环结构（如 for、while 和 do-while 循环）或 switch 语句。当遇到 break 语句时，程序将立即跳出当前循环或 switch 语句，继续执行紧跟在循环或 switch 语句后面的代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    if (i == 5) &#123;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;i: &quot; + i);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;Loop ended.&quot;);</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们使用 for 循环遍历 0 到 9 的整数。当 i 等于 5 时，我们使用 break 语句跳出循环。</p>
<p>4、<strong>byte</strong>： 用于表示一个 8 位（1 字节）有符号整数。它的值范围是 -128（-2^7）到 127（2^7 - 1）。由于 byte 类型占用的空间较小，它通常用于处理大量的数据，如文件读写、网络传输等场景，以节省内存空间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">byte minByte = -128;</span><br><span class="line">byte maxByte = 127;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们声明了三个 byte 类型的变量：minByte、maxByte，并分别赋予了不同的值。</p>
<p>5、<strong>case</strong>： 通常与 switch 语句一起使用。switch 语句允许根据某个变量的值来选择执行不同的代码块。在 switch 语句中，case 用于标识每个可能的值和对应的代码块。例子我们直接放到 switch 中一起讲。</p>
<p>6、<strong>catch</strong>： 用于捕获 try 语句中的异常。在 try 块中可能会抛出异常，而在 catch 块中可以捕获这些异常并进行处理。catch 块可以有多个，每个 catch 块可以捕获特定类型的异常。在 catch 块中，可以根据需要进行异常处理，例如输出错误信息、进行日志记录、恢复程序状态等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    int num = Integer.parseInt(&quot;abc&quot;);</span><br><span class="line">&#125; catch (NumberFormatException e) &#123;</span><br><span class="line">    System.out.println(&quot;Invalid number format&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个程序使用 try-catch 语句捕获 NumberFormatException 异常。在 try 块中，尝试将字符串 “abc” 转换为整数类型，由于这个字符串不是有效的数字格式，将会抛出 NumberFormatException 异常。在 catch 块中，捕获到了这个异常，并输出一条错误信息。</p>
<p>7、<strong>char</strong>： 用于声明一个字符类型的变量。char 类型的变量可以存储任意的 Unicode 字符，可以使用单引号将字符括起来来表示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char c = &#x27;A&#x27;;</span><br></pre></td></tr></table></figure>
<p>这个程序创建了一个 char 类型的变量 c，并将其赋值为大写字母 A。</p>
<p>8、<strong>class</strong>： 用于声明一个类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    public Person(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    public void sayHello() &#123;</span><br><span class="line">        System.out.println(&quot;Hello, my name is &quot; + name + &quot; and I am &quot; + age + &quot; </span><br><span class="line">years old.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>9、<strong>continue</strong>： 用于继续下一个循环，可以在指定条件下跳过其余代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 1; i &lt;= 10; i++) &#123;</span><br><span class="line">    if (i % 2 == 0) &#123;</span><br><span class="line">        continue;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>10、<strong>default</strong>： 用于指定 switch 语句中除去 case 条件之外的默认代码块。这个我们放到 switch 里一起演示。</p>
<p>11、<strong>do</strong>： 通常和 while 关键字配合使用，do 后紧跟循环体。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i = 1;</span><br><span class="line">do &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    i++;</span><br><span class="line">&#125; while (i &lt;= 10);</span><br></pre></td></tr></table></figure>
<p>do-while 循环与 while 循环类似，不同之处在于 do-while 循环会先执行循环体中的代码，然后再检查循环<br>条件。因此，do-while 循环至少会执行一次循环体中的代码。</p>
<p>12、<strong>double</strong>： 用于声明一个双精度浮点类型的变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">double a = 3.14;</span><br><span class="line">double b = 2.0;</span><br><span class="line">double c = a + b;</span><br></pre></td></tr></table></figure>
<p>13、<strong>else</strong>： 用于指示 if 语句中的备用分支。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int score = 75;</span><br><span class="line">if (score &gt;= 60) &#123;</span><br><span class="line">    System.out.println(&quot;及格了&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    System.out.println(&quot;挂科了&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>14、<strong>enum</strong>： 用于定义一组固定的常量（枚举）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public enum PlayerType &#123;</span><br><span class="line">    TENNIS,</span><br><span class="line">    FOOTBALL,</span><br><span class="line">    BASKETBALL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>15、<strong>extends</strong>： 用于指示一个类是从另一个类或接口继承的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        System.out.println(&quot;动物正在吃东西&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">    public void bark() &#123;</span><br><span class="line">        System.out.println(&quot;狗在汪汪叫&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ExtendsDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Dog dog = new Dog();</span><br><span class="line">        dog.eat();</span><br><span class="line">        dog.bark();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Animal 类中有一个 eat() 方法，输出字符串 “动物正在吃东西”。Dog 类继承自 Animal 类，并定义了一个 bark() 方法，输出字符串 “狗在汪汪叫”。</p>
<p>16、<strong>final</strong>： <strong>用于表示某个变量、方法或类是最终的，不能被修改或继承。</strong></p>
<ol>
<li><p>final 变量：表示一个常量，一旦被赋值，其值就不能再被修改。这在声明不可变的值时非常有用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final double PI = 3.14159265359;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>final 方法表示一个不能被子类重写的方法。这在设计类时，确保某个方法的实现不会被子类修改时非常有用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    final void makeSound() &#123;</span><br><span class="line">        System.out.println(&quot;动物发出声音.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">    // 错误: 无法覆盖来自 Animal 的 final 方法</span><br><span class="line">    // void makeSound() &#123;</span><br><span class="line">    //     System.out.println(&quot;狗吠叫.&quot;);</span><br><span class="line">    // &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Dog dog = new Dog();</span><br><span class="line">        dog.makeSound();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>final 类表示一个不能被继承的类。这在设计类时，确保其不会被其他类继承时非常有用。<strong>String 类就是<br>final 的</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">final class Animal &#123;</span><br><span class="line">    void makeSound() &#123;</span><br><span class="line">        System.out.println(&quot;动物发出声音.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 错误: 类型 Dog 无法继承 final 类 Animal</span><br><span class="line">// class Dog extends Animal &#123;</span><br><span class="line">//     void makeSound() &#123;</span><br><span class="line">//         System.out.println(&quot;狗吠叫.&quot;);</span><br><span class="line">//     &#125;</span><br><span class="line">// &#125;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Animal animal = new Animal();</span><br><span class="line">        animal.makeSound();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>17、<strong>finally</strong>： 和 try-catch 配合使用，表示无论是否处理异常，总是执行 finally 块中的代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    int x = 10 / 0;  // 抛出异常</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    System.out.println(&quot;发生了异常：&quot; + e.getMessage());</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    System.out.println(&quot;finally 块被执行&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>18、<strong>float</strong>： 表示单精度浮点数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float f1 = 3.14f;   // 注意要在数字后面加上 f 表示这是一个 float 类型</span><br><span class="line">float f2 = 1.23e-4f;   // 科学计数法表示小数</span><br></pre></td></tr></table></figure>
<p>在 Java 中，浮点数默认是 double 类型，如果要使用 float 类型的数据，需要在数字后面加上一个 f 或者 F，表示这是一个 float 类型的字面量。另外，也可以使用科学计数法表示浮点数，例如 1.23e-4 表示 0.000123。</p>
<p>19、<strong>for</strong>： 用于声明一个 for 循环，如果循环次数是固定的，建议使用 for 循环。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int[] arr = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">    System.out.println(&quot;arr[&quot; + i + &quot;] = &quot; + arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>20、<strong>if</strong>： 用于指定条件，如果条件为真，则执行对应代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int n = -3;</span><br><span class="line">if (n &gt; 0) &#123;</span><br><span class="line">    System.out.println(n + &quot; 是正数&quot;);</span><br><span class="line">&#125; else if (n &lt; 0) &#123;</span><br><span class="line">    System.out.println(n + &quot; 是负数&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    System.out.println(n + &quot; 是零&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>21、<strong>implements</strong>： 用于实现接口。</p>
<p>下面是一个实现了 Runnable 接口的类的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class MyThread implements Runnable &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        // 线程执行的代码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>22、<strong>import</strong>： 用于导入对应的类或者接口。例如，如果要使用 Java 标准库中的 ArrayList 类，可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br></pre></td></tr></table></figure>
<p>23、<strong>instanceof</strong>： <strong>用于判断对象是否属于某个类型（class）。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">例如，假设有一个 Person 类和一个 Student 类，Student 类继承自 Person 类，可以使用 instanceof </span><br><span class="line">运算符来判断一个对象是否为 Person 类或其子类的实例：</span><br><span class="line">Person p = new Student();</span><br><span class="line">if (p instanceof Person) &#123;</span><br><span class="line">    System.out.println(&quot;p is an instance of Person&quot;);</span><br><span class="line">&#125;</span><br><span class="line">if (p instanceof Student) &#123;</span><br><span class="line">    System.out.println(&quot;p is an instance of Student&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>24、<strong>int</strong>： 用于表示整数值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int x;           // 声明一个 int 类型的变量 x</span><br><span class="line">x = 10;          // 将整数值 10 赋给变量 x</span><br><span class="line">int y = 20;     // 声明并初始化一个 int 类型的变量 y，赋值为整数值 20</span><br></pre></td></tr></table></figure>
<p>25、<strong>interface</strong>： 用于声明接口。会定义一组方法的签名（即方法名、参数列表和返回值类型），但没有方法体。其他类可以实现接口，并提供方法的具体实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface MyInterface &#123;</span><br><span class="line">    void method1();</span><br><span class="line">    int method2(String param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>26、<strong>long</strong>： 用于表示长整数值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">long x;           // 声明一个 long 类型的变量 x</span><br><span class="line">x = 10000000000L; // 将长整数值 10000000000 赋给变量 x，需要在数字后面加上 L 或 l 表示这是一个 long 类型的值</span><br><span class="line">long y = 20000000000L; // 声明并初始化一个 long 类型的变量 y，赋值为长整数值 20000000000</span><br></pre></td></tr></table></figure>
<p>27、<strong>native</strong>： <strong>用于声明一个本地方法</strong>，本地方法是指在 Java 代码中声明但在本地代码（通常是 C 或 C++ 代<br>码）中实现的方法，它通常用于与操作系统或其他本地库进行交互。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public native void nativeMethod();</span><br></pre></td></tr></table></figure>
<p>28、<strong>new</strong>： 用于创建一个新的对象。</p>
<p>以下是使用 new 关键字创建对象实例的基本语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassName obj = new ClassName();</span><br></pre></td></tr></table></figure>
<p>以下是使用 new 关键字创建数组实例的基本语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[] arr = new int[10];</span><br></pre></td></tr></table></figure>
<p>29、<strong>null</strong>： 如果一个变量是空的（什么引用也没有指向），就可以将它赋值为 null，和空指针异常息息相关。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = null; // 声明一个字符串引用，初始化为 null</span><br><span class="line">MyClass obj = null; // 声明一个 MyClass 类型的引用，初始化为 null</span><br></pre></td></tr></table></figure>
<p>30、<strong>package</strong>： 用于声明类所在的包。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.example.mypackage;</span><br></pre></td></tr></table></figure>
<p>31、<strong>private</strong>： 一个访问权限修饰符，<strong>表示方法或变量只对当前类可见。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line">    private int x; // 私有属性 x，只能在当前类的内部访问</span><br><span class="line">    private void foo() &#123;</span><br><span class="line">        // 私有方法 foo，只能在当前类的内部调用</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，MyClass 类有一个私有属性 x 和一个私有方法 foo() 。这些成员只能在 MyClass 类的内部访问和调用，对其他类不可见。</p>
<p>32、<strong>protected</strong>： 一个访问权限修饰符，<strong>表示方法或变量对同一包内的类和所有子类可见。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.example.mypackage;</span><br><span class="line">public class MyBaseClass &#123;</span><br><span class="line">    protected int x; // 受保护的属性 x，可以被子类和同一包中的其他类访问</span><br><span class="line">    protected void foo() &#123;</span><br><span class="line">        // 受保护的方法 foo，可以被子类和同一包中的其他类调用</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">package com.example.mypackage;</span><br><span class="line">public class MySubClass extends MyBaseClass &#123;</span><br><span class="line">    public void bar() &#123;</span><br><span class="line">        x = 10; // 可以访问 MyBaseClass 中的受保护属性 x</span><br><span class="line">        foo(); // 可以调用 MyBaseClass 中的受保护方法 foo</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，MyBaseClass 类有一个受保护的属性 x 和一个受保护的方法 foo() 。这些成员可以被子类和同一包中的其他类访问和调用。MySubClass 类继承自 MyBaseClass 类，并可以访问和修改 MyBaseClass 中的受保护成员。</p>
<p>33、<strong>public</strong>： 一个访问权限修饰符，除了可以声明方法和变量（所有类可见），还可以声明类。 main() 方法必须声明为 public。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line">    public int x; // 公有属性 x，可以被任何类访问</span><br><span class="line">    public void foo() &#123;</span><br><span class="line">        // 公有方法 foo，可以被任何类调用</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，MyClass 类有一个公有属性 x 和一个公有方法 foo() 。这些成员可以被任何类访问和调用，无论这些类是否在同一个包中。</p>
<p>35、<strong>return</strong>： 用于从方法中返回一个值或终止方法的执行。return 语句可以将方法的计算结果返回给调用者，或者在方法执行到某个特定条件时提前结束方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public int add(int a, int b) &#123;</span><br><span class="line">    int sum = a + b;</span><br><span class="line">    return sum; // 返回 sum 的值，并结束方法的执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外，return 语句还可以用于提前结束方法的执行。例如，假设我们要编写一个方法，用于判断一个整数是否为偶数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static boolean isEven(int number) &#123;</span><br><span class="line">    if (number % 2 == 0) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们定义了一个名为 isEven 的方法，该方法接收一个整数参数 number。如果 number 是偶数，我们使用 return 语句提前返回 true。否则，方法执行将继续，最后返回 false。</p>
<p>36、<strong>short</strong>： 用于表示短整数，占用 2 个字节（16 位）的内存空间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">short x = 10; // 声明一个 short 类型的变量 x，赋值为 10</span><br><span class="line">short y = 20; // 声明一个 short 类型的变量 y，赋值为 20</span><br></pre></td></tr></table></figure>
<p>37、<strong>static</strong>： 表示该变量或方法是<strong>静态变量或静态方法。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line">    public static int x; // 静态变量 x，属于类的成员</span><br><span class="line">    public static void foo() &#123;</span><br><span class="line">        // 静态方法 foo，属于类的成员</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，MyClass 类有一个静态变量 x 和一个静态方法 foo() 。这些成员属于类的成员，可以通过类名直接访问，不需要创建对象。</p>
<p>38、<strong>strictfp（strict floating-point）</strong>： 并不常见，通常用于修饰一个方法，用于限制浮点数计算的精度和舍入行为。当你在类、接口或方法上使用 strictfp 时，该范围内的所有浮点数计算将遵循 IEEE 754 标准的规定，以确保跨平台的浮点数计算的一致性。</p>
<p>不同的硬件平台和 JVM 实现可能对浮点数计算的精度和舍入行为有差异，这可能导致在不同环境中运行相同的浮点数计算代码产生不同的结果。使用 strictfp 关键字可以确保在所有平台上获得相同的浮点数计算结果，避免计算结果的不一致问题。</p>
<p>但请注意，使用 strictfp 可能会对性能产生影响，因为可能需要更多的计算和转换来确保遵循 IEEE 754 标准。因此，在使用 strictfp 时，需要权衡精度和一致性与性能之间的关系。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public strictfp class MyClass &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        double a = 0.1;</span><br><span class="line">        double b = 0.2;</span><br><span class="line">        double result = a + b;</span><br><span class="line">        System.out.println(&quot;Result: &quot; + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Result: 0.30000000000000004</span><br></pre></td></tr></table></figure>
<p>在这个示例中，MyClass 类被声明为 strictfp，因此类中的所有浮点数计算都将遵循 IEEE 754 标准。</p>
<p>在大多数现代操作系统上，使用 strictfp 可能不会产生显著差异，因为大家都遵循 IEEE 754 标准，除非是一些较旧的硬件平台。</p>
<p>IEEE 754 标准（IEEE Standard for Floating-Point Arithmetic）是一个定义浮点数表示和运算的国际标准。由国际电气和电子工程师协会（IEEE）制定，首次发布于1985年。</p>
<p>IEEE 754 标准主要规定了以下几个方面：</p>
<p>浮点数表示：标准定义了两种浮点数格式，单精度（32位）和双精度（64位）。这两种格式分别由符号位、指数位和尾数位组成，用于表示浮点数的大小和精度。</p>
<p>四舍五入和舍入模式：标准定义了多种舍入模式，例如向最接近的数舍入（Round to Nearest, Ties to Even）、向零舍入（Round toward Zero）、向正无穷舍入（Round toward +∞）和向负无穷舍入（Round toward -∞）等。这些模式指导了浮点数计算过程中如何处理精度损失和舍入误差。</p>
<p>特殊值：标准定义了一些特殊的浮点数值，如正无穷（+∞）、负无穷（-∞）和非数值（NaN）。这些特殊值用于表示浮点数计算中可能出现的溢出、下溢和未定义结果等情况。</p>
<p>浮点数运算：标准规定了浮点数的基本运算（加、减、乘、除）和比较运算（等于、不等于、大于、小于、大于等于、小于等于）的行为和结果。这些运算需要遵循标准中规定的表示、舍入和特殊值处理规则。</p>
<p>来看示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Ieee754Demo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        float a = 0.1f;</span><br><span class="line">        float b = 0.2f;</span><br><span class="line">        float c = a + b;</span><br><span class="line">        System.out.println(&quot;a = &quot; + a);</span><br><span class="line">        System.out.println(&quot;b = &quot; + b);</span><br><span class="line">        System.out.println(&quot;c = a + b = &quot; + c);</span><br><span class="line">        double x = 1.0 / 0.0;</span><br><span class="line">        double y = -1.0 / 0.0;</span><br><span class="line">        double z = 0.0 / 0.0;</span><br><span class="line">        System.out.println(&quot;x = 1.0 / 0.0 = &quot; + x);</span><br><span class="line">        System.out.println(&quot;y = -1.0 / 0.0 = &quot; + y);</span><br><span class="line">        System.out.println(&quot;z = 0.0 / 0.0 = &quot; + z);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<p><img src="\assets\note\image-20230925103754023.png" alt="image-20230925103754023"></p>
<p>我们可以看到 IEEE 754 标准中的浮点数表示和运算：</p>
<ul>
<li>单精度浮点数的加法：变量 a 和 b 分别存储了 0.1 和 0.2，它们的和 c 等于 0.3。由于浮点数表示的精度限制，c 的实际值可能与理论值略有误差。</li>
<li>特殊值：变量 x、y 和 z 分别存储了正无穷（+∞）、负无穷（-∞）和非数值（NaN）。这些特殊值是由除法运算产生的，当被除数为 0 或结果无法表示时，会返回相应的特殊值。</li>
</ul>
<p>39、<strong>super</strong>： 可用于<strong>调用父类的方法或者字段。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    protected String name;</span><br><span class="line">    public Animal(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        System.out.println(name + &quot; is eating.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Dog extends Animal &#123;</span><br><span class="line">    public Dog(String name) &#123;</span><br><span class="line">        super(name); // 调用父类的构造方法</span><br><span class="line">    &#125;</span><br><span class="line">    public void bark() &#123;</span><br><span class="line">        System.out.println(name + &quot; is barking.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        super.eat(); // 调用父类的方法</span><br><span class="line">        System.out.println(name + &quot; is eating bones.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>40、<strong>switch</strong>： 用于根据某个变量的值选择执行不同的代码块。switch 语句通常与 case 和 default 一起使用。每个 case 子句表示一个可能的值和对应的代码块，而 default 子句用于处理不在 case 子句中的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int dayOfWeek = 3;</span><br><span class="line">        switch (dayOfWeek) &#123;</span><br><span class="line">            case 1:</span><br><span class="line">                System.out.println(&quot;Monday&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case 2:</span><br><span class="line">                System.out.println(&quot;Tuesday&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case 3:</span><br><span class="line">                System.out.println(&quot;Wednesday&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case 4:</span><br><span class="line">                System.out.println(&quot;Thursday&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case 5:</span><br><span class="line">                System.out.println(&quot;Friday&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case 6:</span><br><span class="line">                System.out.println(&quot;Saturday&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case 7:</span><br><span class="line">                System.out.println(&quot;Sunday&quot;);</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                System.out.println(&quot;Invalid day&quot;);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们定义了一个名为 dayOfWeek 的整数变量，并赋予了一个值。然后，我们使用 switch 语句根据 dayOfWeek 的值来输出对应的星期几。每个 case 子句表示 dayOfWeek 可能的值，后面紧跟着要执行的代码。使用 break 语句跳出 switch 语句，避免执行其他 case 子句的代码。如果 dayOfWeek 的值不在 case 子句中，default 子句将被执行。</p>
<p>41、<strong>synchronized</strong>： <strong>用于指定多线程代码中的同步方法、变量或者代码块。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line">    private int count;</span><br><span class="line">    public synchronized void increment() &#123;</span><br><span class="line">        count++; // 同步方法</span><br><span class="line">    &#125;</span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">        synchronized(this) &#123; // 同步代码块</span><br><span class="line">            // 执行一些需要同步的操作</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>42、<strong>this</strong>： <strong>可用于在方法或构造方法中引用当前对象。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line">    private int num;</span><br><span class="line">    public MyClass(int num) &#123;</span><br><span class="line">        this.num = num; // 使用 this 关键字引用当前对象的成员变量</span><br><span class="line">    &#125;</span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">        System.out.println(&quot;Doing something with &quot; + this.num); // 使用 this 关键字引</span><br><span class="line">用当前对象的成员变量</span><br><span class="line">    &#125;</span><br><span class="line">    public MyClass getThis() &#123;</span><br><span class="line">        return this; // 返回当前对象本身</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，MyClass 类有一个私有成员变量 num，并定义了一个构造方法、一个方法和一个返回当前对象的方法。在构造方法中，使用 this 关键字引用当前对象的成员变量，并将传入的参数赋值给该成员变量。在方法 doSomething() 中，使用 this 关键字引用当前对象的成员变量，并输出该成员变量的值。在方法 getThis() 中，直接返回当前对象本身。</p>
<p>43、<strong>throw</strong>： 主动抛出异常。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line">    public void doSomething(int num) throws Exception &#123;</span><br><span class="line">        if (num &lt; 0) &#123;</span><br><span class="line">            throw new Exception(&quot;num must be greater than zero&quot;); // 手动抛出异常</span><br><span class="line">        &#125;</span><br><span class="line">        // 执行一些操作</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>44、<strong>throws</strong>： 用于声明异常。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line">    public void doSomething(int num) throws Exception &#123;</span><br><span class="line">        if (num &lt; 0) &#123;</span><br><span class="line">            throw new Exception(&quot;num must be greater than zero&quot;); // 手动抛出异常</span><br><span class="line">        &#125;</span><br><span class="line">        // 执行一些操作</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>45、<strong>transient</strong>：  <strong>修饰的字段不会被序列化。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass implements Serializable &#123;</span><br><span class="line">    private int id;</span><br><span class="line">    private String name;</span><br><span class="line">    private transient String password;</span><br><span class="line">    public MyClass(int id, String name, String password) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.password = password;</span><br><span class="line">    &#125;</span><br><span class="line">    // 省略 getter 和 setter 方法</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;MyClass&#123;&quot; +</span><br><span class="line">                &quot;id=&quot; + id +</span><br><span class="line">                &quot;, name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, password=&#x27;&quot; + password + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，MyClass 类实现了 Serializable 接口，表示该类的对象可以被序列化。该类有三个成员变量，分别是 id、name 和 password。其中，password 成员变量被标记为 transient，表示在序列化过程中忽略这个成员变量。</p>
<p>45、<strong>try</strong>： 用于包裹要捕获异常的代码块。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    // 可能抛出异常的代码</span><br><span class="line">    int result = 1 / 0;</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    // 异常处理代码</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>46、<strong>void</strong>： 用于指定方法没有返回值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void doSomething() &#123;</span><br><span class="line">    // 方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>47、<strong>volatile</strong>： 保证不同线程对它修饰的变量进行操作时的<strong>可见性</strong>，即一个线程修改了某个变量的值，新值对其他线程来说是立即可见的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class MyThread extends Thread &#123;</span><br><span class="line">    private volatile boolean running = true;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (running) &#123;</span><br><span class="line">            // 线程执行的代码</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void stopThread() &#123;</span><br><span class="line">        running = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，MyThread 类继承了 Thread 类，重写了 run() 方法。MyThread 类有一个成员变量 running，被标记为 volatile，表示这个变量是共享的，可能会被多个线程同时访问。在 run() 方法中，使用 while 循环检查 running 变量的值，如果 running 为 true，就继续执行循环体中的代码。在另一个方法 stopThread() 中，将 running 变量的值设置为 false，表示需要停止线程。</p>
<p>48、<strong>while</strong>： 如果循环次数不固定，建议使用 while 循环。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i = 0;</span><br><span class="line">while (i &lt; 10) &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“除了这些关键字，Java 中还有两个非常特殊的保留字（goto 和 const），它们不能在程序中使用。”“goto 在 C语言中叫做‘无限跳转’语句，在 Java 中，不再使用 goto 语句，因为无限跳转会破坏程序结构。”Java 中确实可以使用标签（label）与 break 和 continue 语句结合来实现类似 goto 的跳转功能。以下是一个简单的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class LabelDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        outerLoop:</span><br><span class="line">        for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; 3; j++) &#123;</span><br><span class="line">                if (i == 1 &amp;&amp; j == 1) &#123;</span><br><span class="line">                    System.out.println(&quot;跳过 outerLoop 中的当前迭代&quot;);</span><br><span class="line">                    continue outerLoop;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;i: &quot; + i + &quot;, j: &quot; + j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;结束&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们使用了两层嵌套循环。外层循环有一个名为 outerLoop 的标签。当 i 等于 1 且 j 等于 1 时，我们使用 continue outerLoop 语句跳过外层循环中的当前迭代。这与 goto 的行为类似。</p>
<p>来看输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">i: 0, j: 0</span><br><span class="line">i: 0, j: 1</span><br><span class="line">i: 0, j: 2</span><br><span class="line">i: 1, j: 0</span><br><span class="line">跳过 outerLoop 中的当前迭代</span><br><span class="line">i: 2, j: 0</span><br><span class="line">i: 2, j: 1</span><br><span class="line">i: 2, j: 2</span><br><span class="line">结束</span><br></pre></td></tr></table></figure>
<p>尽管可以使用标签实现类似 goto 的跳转功能，但这种用法在 Java 中仍然较少见，因为过度使用可能导致代码难以理解和维护。通常建议尽可能使用其他控制结构（如 if、for 和 while 语句）来组织代码。</p>
<p>以下是一个使用 if 和 for 语句替代标签跳转的示例。在这个示例中，我们使用了一个布尔变量 skipIteration 来决定是否跳过外层循环的当前迭代：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class IfForDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">            boolean skipIteration = false;</span><br><span class="line">            for (int j = 0; j &lt; 3; j++) &#123;</span><br><span class="line">                if (i == 1 &amp;&amp; j == 1) &#123;</span><br><span class="line">                    System.out.println(&quot;跳过外层循环中的当前迭代&quot;);</span><br><span class="line">                    skipIteration = true;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;i: &quot; + i + &quot;, j: &quot; + j);</span><br><span class="line">            &#125;</span><br><span class="line">            if (skipIteration) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，当 i 等于 1 且 j 等于 1 时，我们将 skipIteration 设置为 true，然后使用 break 语句跳出内层<br>循环。在外层循环中，我们检查 skipIteration 变量的值，如果为 true，则跳过外层循环的当前迭代。</p>
<p>这个示例的输出结果与之前的示例相同：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">i: 0, j: 0</span><br><span class="line">i: 0, j: 1</span><br><span class="line">i: 0, j: 2</span><br><span class="line">i: 1, j: 0</span><br><span class="line">跳过外层循环中的当前迭代</span><br><span class="line">i: 2, j: 0</span><br><span class="line">i: 2, j: 1</span><br><span class="line">i: 2, j: 2</span><br></pre></td></tr></table></figure>
<p>“const 在 C语言中是声明常量的关键字，在 Java 中可以使用 public static final 三个关键字的组合来达到常量的效果。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Circle &#123;</span><br><span class="line">    public static final double PI = 3.14159;</span><br><span class="line">    public static double calculateArea(double radius) &#123;</span><br><span class="line">        return PI * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们使用 public static final 关键字组合定义了一个名为 PI 的常量。因为它是 public 的，所以其他类可以访问这个常量。因为它是 static 的，所以它与类关联，而不是类的实例。因为它是 final 的，所以它的值不能被更改。</p>
<h2 id="1-2-Java注释"><a href="#1-2-Java注释" class="headerlink" title="1.2 Java注释"></a>1.2 Java注释</h2><p><img src="\assets\note\image-20230925105319358.png" alt="image-20230925105319358"></p>
<p><strong>01、单行注释 </strong></p>
<p>单行注释通常用于解释方法内某单行代码的作用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void method() &#123;</span><br><span class="line">    int age = 18; // age 用于表示年龄</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但如果写在行尾的话，其实是不符合阿里巴巴的开发规约的。</p>
<p><img src="\assets\note\image-20230925105443224.png" alt="image-20230925105443224"></p>
<p>正确的单行注释如上图中所说，在被注释语句上方另起一行，使用 // 注释。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void method() &#123;</span><br><span class="line">    // age 用于表示年龄</span><br><span class="line">    int age = 18;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>02、多行注释 </strong></p>
<p>多行注释使用的频率其实并不高，通常用于解释一段代码的作用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">age 用于表示年纪</span><br><span class="line">name 用于表示姓名</span><br><span class="line">*/</span><br><span class="line">int age = 18;</span><br><span class="line">String name = &quot;沉默&quot;;</span><br></pre></td></tr></table></figure>
<p>以 /<em> 开始，以 </em>/ 结束，但不如用多个 // 来得痛快，因为 * 和 / 不在一起，敲起来麻烦。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// age 用于表示年纪</span><br><span class="line">// name 用于表示姓名</span><br><span class="line">int age = 18;</span><br><span class="line">String name = &quot;沉默&quot;;</span><br></pre></td></tr></table></figure>
<p><strong>03、文档注释 </strong></p>
<p>文档注释可用在三个地方，类、字段和方法，用来解释它们是干嘛的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 微信搜索「二哈进阶之路」</span><br><span class="line"> */</span><br><span class="line">public class Demo &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 姓名</span><br><span class="line">     */</span><br><span class="line">    private int age;</span><br><span class="line">    /**</span><br><span class="line">     * main 方法作为程序的入口</span><br><span class="line">     *</span><br><span class="line">     * @param args 参数</span><br><span class="line">     */</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS：在 Intellij IDEA 中，按下 /<em>* 后敲下回车键就可以自动添加文档注释的格式， </em>/ 是自动补全的。</p>
<p>接下来，我们来看看如何通过 javadoc 命令生成代码文档。</p>
<p>第一步，在该类文件上右键，找到「Open in Terminal」 可以打开命令行窗口。</p>
<p><img src="\assets\note\image-20230925105809280.png" alt="image-20230925105809280"></p>
<p>第二步，执行 javadoc 命令 javadoc Demo.java -encoding utf-8 。 -encoding utf-8 可以保证中文不发生乱码。</p>
<p><img src="\assets\note\image-20230925105924721.png" alt="image-20230925105924721"></p>
<p>第三步，执行 ls -l 命令就可以看到生成代码文档时产生的文件，主要是一些可以组成网页的 html、js 和 css 文件。</p>
<p><img src="\assets\note\image-20230925110002342.png" alt="image-20230925110002342"></p>
<p>第四步，执行 open index.html 命令可以通过默认的浏览器打开文档注释。</p>
<p><img src="\assets\note\image-20230925110036341.png" alt="image-20230925110036341"></p>
<p>点击「Demo」，可以查看到该类更具体的注释文档。</p>
<p><img src="\assets\note\image-20230925110131874.png" alt="image-20230925110131874"></p>
<p><strong>04、文档注释的注意事项 </strong></p>
<p>1） javadoc 命令只能为 public 和 protected 修饰的字段、方法和类生成文档。</p>
<p>default 和 private 修饰的字段和方法的注释将会被忽略掉。因为我们本来就不希望这些字段和方法暴露给调用者。</p>
<p>如果类不是 public 的话，javadoc 会执行失败。</p>
<p><img src="\assets\note\image-20230925110225972.png" alt="image-20230925110225972"></p>
<p>2）文档注释中可以嵌入一些 HTML 标记，比如说段落标记 <p> ，超链接标记 <a></a> 等等，但不要使用标题标记，比如说 <h1> ，因为 javadoc 会插入自己的标题，容易发生冲突。</p>
<p>3）文档注释中可以插入一些 @ 注解，比如说 @see 引用其他类， @version 版本号， @param 参数标识符， @author 作者标识符， @deprecated 已废弃标识符，等等。</p>
<p><strong>05、注释规约 </strong></p>
<p>1）类、字段、方法必须使用文档注释，不能使用单行注释和多行注释。因为注释文档在 IDE 编辑窗口中可以悬浮提示，提高编码效率。</p>
<p>比如说，在使用 String 类的时候，鼠标悬停在 String 上时可以得到以下提示。</p>
<p><img src="\assets\note\image-20230925110330201.png" alt="image-20230925110330201"></p>
<p>2）所有的抽象方法(包括接口中的方法)必须要用 Javadoc 注释、除了返回值、参数、 异常说明外，还必须指出该方法做什么事情，实现什么功能。</p>
<p>3）所有的类都必须添加创建者和创建日期。</p>
<p>Intellij IDEA 中可以在「File and Code Templates」中设置。</p>
<p><img src="\assets\note\image-20230925110443800.png" alt="image-20230925110443800"></p>
<p>语法如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 微信搜索「二哈进阶之路」</span><br><span class="line">* @author 二哈</span><br><span class="line">* @date $&#123;DATE&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p>设置好后，在新建一个类的时候就可以自动生成了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 微信搜索「二哈进阶之路」</span><br><span class="line"> *</span><br><span class="line"> * @author 二哈</span><br><span class="line"> * @date 2020/11/16</span><br><span class="line"> */</span><br><span class="line">public class Test &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4）所有的枚举类型字段必须要有注释，说明每个数据项的用途。</p>
<p>5）代码修改的同时，注释也要进行相应的修改。</p>
<p>“记住一点，注释是程序固有的一部分。”</p>
<ul>
<li>第一、注释要能够准确反映设计思想和代码逻辑;</li>
<li>第二、注释要能够描述业务含 义，使别的程序员能够迅速了解到代码背后的信息。</li>
</ul>
<p>完全没有注释的大段代码对于阅读者形同 天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路;注释也是给继任者看 的，使其能够快速接替自己的工作。</p>
<h2 id="1-3-Java数据类型"><a href="#1-3-Java数据类型" class="headerlink" title="1.3 Java数据类型"></a>1.3 Java数据类型</h2><p>Java 中的数据类型可分为 2 种：</p>
<p><strong>1）基本数据类型。</strong></p>
<p>基本数据类型是 Java 语言操作数据的基础，包括 boolean、char、byte、short、int、long、float 和 double，共 8 种。</p>
<p><strong>2）引用数据类型。</strong></p>
<p>除了基本数据类型以外的类型，都是所谓的引用类型。常见的有数组（对，没错，数组是引用类型，后面我们会讲）、class（也就是类），以及接口（指向的是实现接口的类的对象）。来个思维导图，感受下。</p>
<p><img src="\assets\note\image-20230925110840637.png" alt="image-20230925110840637"></p>
<p>变量可以分为局部变量、成员变量、静态变量。</p>
<p>当变量是局部变量的时候，必须得先初始化，否则编译器不允许你使用它。拿 int 来举例吧，看下图。</p>
<p><img src="\assets\note\image-20230925110931400.png" alt="image-20230925110931400"></p>
<p>当变量是成员变量或者静态变量时，可以不进行初始化，它们会有一个默认值，仍然以 int 为例，来看代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author 微信搜「二哈进阶之路」</span><br><span class="line"> */</span><br><span class="line">public class LocalVar &#123;</span><br><span class="line">    private int a;</span><br><span class="line">    static int b;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        LocalVar lv = new LocalVar();</span><br><span class="line">        System.out.println(lv.a);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>瞧见没，int 作为成员变量时或者静态变量时的默认值是 0。那不同的基本数据类型，是有不同的默认值和大小的，来个表格感受下。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">数据类型</th>
<th style="text-align:center">默认值</th>
<th style="text-align:center">大小</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">boolean</td>
<td style="text-align:center">false</td>
<td style="text-align:center">1 比特</td>
</tr>
<tr>
<td style="text-align:center">char</td>
<td style="text-align:center">‘\u0000’</td>
<td style="text-align:center">2 字节</td>
</tr>
<tr>
<td style="text-align:center">byte</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1 字节</td>
</tr>
<tr>
<td style="text-align:center">short</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2 字节</td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">0</td>
<td style="text-align:center">4 字节</td>
</tr>
<tr>
<td style="text-align:center">long</td>
<td style="text-align:center">0L</td>
<td style="text-align:center">8 字节</td>
</tr>
<tr>
<td style="text-align:center">float</td>
<td style="text-align:center">0.0f</td>
<td style="text-align:center">4 字节</td>
</tr>
<tr>
<td style="text-align:center">double</td>
<td style="text-align:center">0.0</td>
<td style="text-align:center">8 字节</td>
</tr>
</tbody>
</table>
</div>
<p><strong>01、比特和字节 </strong></p>
<p>比特币（Bitcoin）听说过吧？字节跳动（Byte Dance）听说过吧？这些名字当然不是乱起的，确实和比特、字节有关系。</p>
<p><strong>1）bit（比特） </strong></p>
<p>比特作为信息技术的最基本存储单位，非常小，但大名鼎鼎的比特币就是以此命名的，它的简写为小写字母“b”。</p>
<p>大家都知道，计算机是以二进制存储数据的，二进制的一位，就是 1 比特，也就是说，比特要么为 0 要么为 1。</p>
<p><strong>2）Byte（字节） </strong></p>
<p>通常来说，一个英文字符是一个字节，一个中文字符是两个字节。字节与比特的换算关系是：1 字节 = 8 比特。</p>
<p>在往上的单位就是 KB，并不是 1000 字节，因为计算机只认识二进制，因此是 2 的 10 次方，也就是 1024<br>个字节。（终于知道 1024 和程序员的关系了吧？狗头保命）</p>
<p><img src="\assets\note\image-20230925111850396.png" alt="image-20230925111850396"></p>
<p><strong>02、基本数据类型 </strong></p>
<p>接下来，我们再来详细地了解一下 8 种基本数据类型。</p>
<p><strong>1）布尔 </strong></p>
<p>布尔（boolean）仅用于存储两个值：true 和 false，也就是真和假，通常用于条件的判断。代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">boolean hasMoney = true;</span><br><span class="line">boolean hasGirlFriend = false;</span><br></pre></td></tr></table></figure>
<p><strong>2）byte </strong></p>
<p>一个字节可以表示 2^8 = 256 个不同的值。由于 byte 是有符号的，它的值可以是负数或正数，其取值范围是 -128 到 127（包括 -128 和 127）。</p>
<p>在网络传输、大文件读写时，为了节省空间，常用字节来作为数据的传输方式。代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">byte b; // 声明一个 byte 类型变量</span><br><span class="line">b = 10; // 将值 10 赋给变量 b</span><br><span class="line">byte c = -100; // 声明并初始化一个 byte 类型变量 c，赋值为 -100</span><br></pre></td></tr></table></figure>
<p><strong>3）short </strong></p>
<p>short 的取值范围在 -32,768 和 32,767 之间，包含 32,767。代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">short s; // 声明一个 short 类型变量</span><br><span class="line">s = 1000; // 将值 1000 赋给变量 s</span><br><span class="line">short t = -2000; // 声明并初始化一个 short 类型变量 t，赋值为 -2000</span><br></pre></td></tr></table></figure>
<p>实际开发中，short 比较少用，整型用 int 就 OK。</p>
<p><strong>4）int </strong></p>
<p>int 的取值范围在 -2,147,483,648（-2 ^ 31）和 2,147,483,647（2 ^ 31 -1）（含）之间。如果没有特殊需求，整型数据就用 int。代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int i; // 声明一个 int 类型变量</span><br><span class="line">i = 1000000; // 将值 1000000 赋给变量 i</span><br><span class="line">int j = -2000000; // 声明并初始化一个 int 类型变量 j，赋值为 -2000000</span><br></pre></td></tr></table></figure>
<p><strong>5）long </strong></p>
<p>long 的取值范围在 -9,223,372,036,854,775,808(-2^63) 和 9,223,372,036,854,775,807(2^63 -1)（含）之间。如果 int 存储不下，就用 long。代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">long l; // 声明一个 long 类型变量</span><br><span class="line">l = 100000000000L; // 将值 100000000000L 赋给变量 l（注意要加上 L 后缀）</span><br><span class="line">long m = -20000000000L; // 声明并初始化一个 long 类型变量 m，赋值为 -20000000000L</span><br></pre></td></tr></table></figure>
<p>为了和 int 作区分，long 型变量在声明的时候，末尾要带上大写的“L”。不用小写的“l”，是因为小写的“l”容易和数字“1”混淆。</p>
<p><strong>6）float </strong></p>
<p>float 是单精度的浮点数（单精度浮点数的有效数字大约为 6 到 7 位），32 位（4 字节），遵循 IEEE 754（二进制浮点数算术标准），取值范围为 1.4E-45 到 3.4E+38。float 不适合用于精确的数值，比如说金额。</p>
<p>代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">float f; // 声明一个 float 类型变量</span><br><span class="line">f = 3.14159f; // 将值 3.14159f 赋给变量 f（注意要加上 f 后缀）</span><br><span class="line">float g = -2.71828f; // 声明并初始化一个 float 类型变量 g，赋值为 -2.71828f</span><br></pre></td></tr></table></figure>
<p>为了和 double 作区分，float 型变量在声明的时候，末尾要带上小写的“f”。不需要使用大写的“F”，是因为小写的“f”很容易辨别。</p>
<p><strong>7）double </strong></p>
<p>double 是双精度浮点数（双精度浮点数的有效数字大约为 15 到 17 位），占 64 位（8 字节），也遵循 IEEE 754 标准，取值范围大约 ±4.9E-324 到 ±1.7976931348623157E308。double 同样不适合用于精确的数值，比如说金额。</p>
<p>代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double myDouble = 3.141592653589793;</span><br></pre></td></tr></table></figure>
<p>在进行金融计算或需要精确小数计算的场景中，可以使用 BigDecimal 类来避免浮点数舍入误差。</p>
<p>BigDecimal 可以表示一个任意大小且精度完全准确的浮点数。</p>
<blockquote>
<p>在实际开发中，如果不是特别大的金额（精确到 0.01 元，也就是一分钱），一般建议乘以 100 转成整型进行处理。</p>
</blockquote>
<p><strong>8）char </strong></p>
<p>char 用于表示 Unicode 字符，占 16 位（2 字节）的存储空间，取值范围为 0 到 65,535。</p>
<p>代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char letterA = &#x27;A&#x27;; // 用英文的单引号包裹住。</span><br></pre></td></tr></table></figure>
<p>注意，字符字面量应该用单引号（’’）包围，而不是双引号（””），因为<strong>双引号表示字符串字面量。</strong></p>
<p><strong>03、单精度和双精度 </strong></p>
<p>单精度（single-precision）和双精度（double-precision）是指两种不同精度的浮点数表示方法。单精度是这样的格式，1 位符号，8 位指数，23 位小数。</p>
<p><img src="\assets\note\image-20230925112500528.png" alt="image-20230925112500528"></p>
<p>单精度浮点数通常占用 32 位（4 字节）存储空间。数值范围大约是 ±1.4E-45 到 ±3.4028235E38，精度大约为 6 到 9 位有效数字。</p>
<p>双精度是这样的格式，1 位符号，11 位指数，52 为小数。</p>
<p><img src="\assets\note\image-20230925112546756.png" alt="image-20230925112546756"></p>
<p>双精度浮点数通常占用 64 位（8 字节）存储空间，数值范围大约是 ±4.9E-324 到 ±1.7976931348623157E308，精度大约为 15 到 17 位有效数字。</p>
<p>计算精度取决于小数位（尾数）。小数位越多，则能表示的数越大，那么计算精度则越高。</p>
<p>一个数由若干位数字组成，其中影响测量精度的数字称作有效数字，也称有效数位。有效数字指科学计算中用以表示一个浮点数精度的那些数字。一般地，指一个用小数形式表示的浮点数中，从第一个非零的数字算起的所有数字。如 1.24 和 0.00124 的有效数字都有 3 位。</p>
<p>以下是确定有效数字的一些基本规则：</p>
<ul>
<li>非零数字总是有效的。</li>
<li>位于两个非零数字之间的零是有效的。</li>
<li>对于小数，从左侧开始的第一个非零数字之前的零是无效的。</li>
<li>对于整数，从右侧开始的第一个非零数字之后的零是无效的。</li>
</ul>
<p>下面是一些示例，说明如何确定有效数字：</p>
<ul>
<li>1234：4 个有效数字（所有数字都是非零数字）</li>
<li>1002：4 个有效数字（零位于两个非零数字之间）</li>
<li>0.00234：3 个有效数字（从左侧开始的前两个零是无效的）</li>
<li>1200：2 个有效数字（从右侧开始的两个零是无效的）</li>
</ul>
<p><strong>04、int 和 char 类型互转 </strong></p>
<p>int 和 char 之间比较特殊，可以互转，也会在以后的学习当中经常遇到。</p>
<p>1）可以通过强制类型转换将整型 int 转换为字符 char。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int value_int = 65;</span><br><span class="line">char value_char  = (char) value_int;</span><br><span class="line">System.out.println(value_char);</span><br></pre></td></tr></table></figure>
<p>输出 A (其 ASCII 值可以通过整数 65 来表示)。</p>
<p>2）可以使用 Character.forDigit() 方法将整型 int 转换为字符 char，参数 radix 为基数，十进制为 10，十六进制为 16。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int radix = 10;</span><br><span class="line">int value_int = 6;</span><br><span class="line">char value_char = Character.forDigit(value_int , radix);</span><br><span class="line">System.out.println(value_char );</span><br></pre></td></tr></table></figure>
<p>Character 为 char 的包装器类型。我们随后会讲。</p>
<p>3）可以使用 int 的包装器类型 Integer 的 toString() 方法+String 的 charAt() 方法转成 char。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int value_int = 1;</span><br><span class="line">char value_char = Integer.toString(value_int).charAt(0);</span><br><span class="line">System.out.println(value_char );</span><br></pre></td></tr></table></figure>
<p>4）char 转 int</p>
<p>当然了，如果只是简单的 char 转 int，直接赋值就可以了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure>
<p>因为发生了自动类型转换，后面会细讲。</p>
<p><strong>05、包装器类型 </strong></p>
<p>包装器类型（Wrapper Types）是 Java 中的一种特殊类型，用于将基本数据类型（如 int、float、char 等）转换为对应的对象类型。</p>
<ul>
<li>Java 提供了以下包装器类型，与基本数据类型一一对应：</li>
<li>Byte（对应 byte）</li>
<li>Short（对应 short）</li>
<li>Integer（对应 int）</li>
<li>Long（对应 long）</li>
<li>Float（对应 float）</li>
<li>Double（对应 double）</li>
<li>Character（对应 char）</li>
<li>Boolean（对应 boolean）</li>
</ul>
<p>包装器类型允许我们使用基本数据类型提供的各种实用方法，并兼容需要对象类型的场景。例如，我们可以使用 Integer 类的 parseInt 方法将字符串转换为整数，或使用 Character 类的 isDigit 方法检查字符是否为数字，还有前面提到的 Character.forDigit() 方法。</p>
<p>下面是一个简单的示例，演示了如何使用包装器类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 使用 Integer 包装器类型</span><br><span class="line">Integer integerValue = new Integer(42);</span><br><span class="line">System.out.println(&quot;整数值: &quot; + integerValue);</span><br><span class="line">// 将字符串转换为整数</span><br><span class="line">String numberString = &quot;123&quot;;</span><br><span class="line">int parsedNumber = Integer.parseInt(numberString);</span><br><span class="line">System.out.println(&quot;整数值: &quot; + parsedNumber);</span><br><span class="line">// 使用 Character 包装器类型</span><br><span class="line">Character charValue = new Character(&#x27;A&#x27;);</span><br><span class="line">System.out.println(&quot;字符: &quot; + charValue);</span><br><span class="line">// 检查字符是否为数字</span><br><span class="line">char testChar = &#x27;9&#x27;;</span><br><span class="line">if (Character.isDigit(testChar)) &#123;</span><br><span class="line">System.out.println(&quot;字符是个数字.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的示例中，我们创建了一个 Integer 类型的对象 integerValue 并为其赋值 42。然后，我们将其值打印到控制台。</p>
<p>我们有一个包含数字的字符串 numberString。我们使用 Integer.parseInt() 方法将其转换为整数 parsedNumber。然后，我们将转换后的值打印到控制台。</p>
<p>我们有一个字符变量 testChar，并为其赋值字符 ‘9’。我们使用 Character.isDigit() 方法检查 testChar 是否为数字字符。如果是数字字符，我们将输出一条消息到控制台。</p>
<p>从 Java 5 开始，自动装箱（Autoboxing）和自动拆箱（Unboxing）机制允许我们在基本数据类型和包装器类型之间自动转换，无需显式地调用构造方法或转换方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer integerValue = 42; // 自动装箱，等同于 new Integer(42)</span><br><span class="line">int primitiveValue = integerValue; // 自动拆箱，等同于 integerValue.intValue()</span><br></pre></td></tr></table></figure>
<p><strong>06、引用数据类型 </strong></p>
<p>基本数据类型在作为成员变量和静态变量的时候有默认值，引用数据类型也有的（学完数组&amp;字符串，以及面向对象编程后会更加清楚，这里先简单过一下）。</p>
<p>String 是最典型的引用数据类型，所以我们就拿 String 类举例，看下面这段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author 微信搜「二哈进阶之路」</span><br><span class="line"> */</span><br><span class="line">public class LocalRef &#123;</span><br><span class="line">    private String a;</span><br><span class="line">    static String b;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        LocalRef lv = new LocalRef();</span><br><span class="line">        System.out.println(lv.a);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">null</span><br><span class="line">null</span><br></pre></td></tr></table></figure>
<p>null 在 Java 中是一个很神奇的存在，在你以后的程序生涯中，见它的次数不会少，尤其是伴随着令人烦恼的“空指针异常”，也就是所谓的 NullPointerException 。</p>
<p>也就是说，引用数据类型的默认值为 null，包括数组和接口。</p>
<p>那你是不是很好奇，为什么数组和接口也是引用数据类型啊？</p>
<p>先来看数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int [] arrays = &#123;1,2,3&#125;;</span><br><span class="line">System.out.println(arrays);</span><br></pre></td></tr></table></figure>
<p>arrays 是一个 int 类型的数组，对吧？打印结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[I@2d209079</span><br></pre></td></tr></table></figure>
<p>[I 表示数组是 int 类型的，@ 后面是十六进制的 hashCode——这样的打印结果太“人性化”了，一般人表示看不懂！为什么会这样显示呢？查看一下 java.lang.Object 类的 toString() 方法就明白了。</p>
<p><img src="\assets\note\image-20230925114234571.png" alt="image-20230925114234571"></p>
<p>数组虽然没有显式定义成一个类，但它的确是一个对象，继承了祖先类 Object 的所有方法。那为什么数组不单独定义一个类来表示呢？就像字符串 String 类那样呢？</p>
<p>一个合理的解释是 Java 将其隐藏了。假如真的存在一个 Array.java，我们也可以假想它真实的样子，它必须要定义一个容器来存放数组的元素，就像 String 类那样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final class String</span><br><span class="line">    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    /** The value is used for character storage. */</span><br><span class="line">    private final char value[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数组内部定义数组？没必要的！</p>
<p>再来看接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>
<p>List 是一个非常典型的接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public interface List&lt;E&gt; extends Collection&lt;E&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>而 ArrayList 是 List 接口的一个实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class="line">        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>对于接口类型的引用变量来说，你没法直接 new 一个：</p>
<p><img src="\assets\note\image-20230925114445179.png" alt="image-20230925114445179"></p>
<p>只能 new 一个实现它的类的对象——那自然接口也是引用数据类型了。</p>
<p>来看一下基本数据类型和引用数据类型之间最大的差别。</p>
<p>基本数据类型：</p>
<ul>
<li>变量名指向具体的数值。</li>
<li>基本数据类型存储在栈上。</li>
</ul>
<p>引用数据类型：</p>
<ul>
<li>变量名指向的是存储对象的内存地址，在栈上。</li>
<li>内存地址指向的对象存储在堆上。</li>
</ul>
<p><strong>07、堆和栈 </strong></p>
<p>堆是堆（heap），栈是栈（stack），如果看到“堆栈”的话，请不要怀疑自己，那是翻译的错，堆栈也是栈，反正我很不喜欢“堆栈”这种叫法，容易让新人掉坑里。</p>
<p>堆是在程序运行时在内存中申请的空间（可理解为动态的过程）；切记，不是在编译时；因此，Java 中的对象就放在这里，这样做的好处就是：</p>
<blockquote>
<p>当需要一个对象时，只需要通过 new 关键字写一行代码即可，当执行这行代码时，会自动在内存的“堆”区分配空间——这样就很灵活。</p>
</blockquote>
<p>栈，能够和处理器（CPU，也就是脑子）直接关联，因此访问速度更快。既然访问速度快，要好好利用啊！Java 就把对象的引用放在栈里。为什么呢？因为引用的使用频率高吗？</p>
<p>不是的，因为 Java 在编译程序时，必须明确的知道存储在栈里的东西的生命周期，否则就没法释放旧的内存来开辟新的内存空间存放引用——空间就那么大，前浪要把后浪拍死在沙滩上啊。</p>
<p>这么说就理解了吧？</p>
<p>用图来表示一下，左侧是栈，右侧是堆。</p>
<p><img src="\assets\note\image-20230925114753308.png" alt="image-20230925114753308"></p>
<p>这里再补充一些额外的知识点，能看懂就继续吸收，看不懂可以先去学下一节，以后再来补，没关系的。学习就是这样，可以跳过，可以温故。</p>
<p>举个例子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String a = new String(&quot;沉默&quot;)</span><br></pre></td></tr></table></figure>
<p>这段代码会先在堆里创建一个 沉默的字符串对象，然后再把对象的引用 a 放到栈里面。这里面还会涉及到字符串常量池，后面会讲。</p>
<p>那么对于这样一段代码，有基本数据类型的变量，有引用类型的变量，堆和栈都是如何存储他们的呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void test()</span><br><span class="line">&#123;</span><br><span class="line">    int i = 4;</span><br><span class="line">    int y = 2;</span><br><span class="line">    Object o1 = new Object();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我来画个图表示下。</p>
<p><img src="\assets\note\image-20230925114943142.png" alt="image-20230925114943142"></p>
<p><strong>08、小结 </strong></p>
<p>本文详细探讨了 Java 数据类型，包括比特与字节、基本数据类型、单精度与双精度、int 与 char 互转、包装器类型、引用数据类型以及堆与栈的内存模型。通过阅读本文，你将全面了解 Java 数据类型的概念与使用方法，为 Java 编程打下坚实基础。</p>
<h2 id="1-4-Java数据类型转换"><a href="#1-4-Java数据类型转换" class="headerlink" title="1.4 Java数据类型转换"></a>1.4 Java数据类型转换</h2><p>数据类型转换的目的是确保在表达式求值时，不同类型的数据能够相互兼容。</p>
<p><strong>01、自动类型转换 </strong></p>
<p>自动类型转换（自动类型提升）是 Java 编译器在不需要显式转换的情况下，将一种基本数据类型自动转换为另一种基本数据类型的过程。这种转换通常发生在表达式求值期间，当不同类型的数据需要相互兼容时。自动类型转换遵循以下规则：</p>
<ul>
<li>如果任何操作数是 double 类型，其他操作数将被转换为 double 类型。</li>
<li>否则，如果任何操作数是 float 类型，其他操作数将被转换为 float 类型。</li>
<li>否则，如果任何操作数是 long 类型，其他操作数将被转换为 long 类型。</li>
<li>否则，所有操作数将被转换为 int 类型。</li>
</ul>
<p>需要注意的是，自动类型转换只发生在兼容类型之间。例如，从较小的数据类型（如 int）到较大的数据类型（如 long 或 double）的转换是安全的，因为较大的数据类型可以容纳较小数据类型的所有可能值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">byte -&gt; short -&gt; int -&gt; long -&gt; float -&gt; double</span><br><span class="line">char -&gt; int -&gt; long -&gt; float -&gt; double</span><br></pre></td></tr></table></figure>
<p>下面是一个简单的示例，演示了自动类型转换：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int intValue = 5;</span><br><span class="line">double doubleValue = 2.5;</span><br><span class="line">// 自动类型转换：intValue 被转换为 double 类型</span><br><span class="line">double result = intValue * doubleValue;</span><br><span class="line">System.out.println(&quot;结果: &quot; + result); // 输出：结果: 12.5</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们有一个 int 类型的变量 intValue 和一个 double 类型的变量 doubleValue。当我们将它们相乘时，根据自动类型转换的规则，intValue 将被转换为 double 类型，以便将两个 double 类型的操作数相乘。最终结果将是一个 double 类型的值：12.5。</p>
<p>再来举个例子，顾客到超市购物，购买牙膏 2 盒，面巾纸 4 盒。其中牙膏的价格是 10.9 元，面巾纸的价格是 5.8 元，求商品总价格。实现代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">float price1 = 10.9f; // 定义牙膏的价格，单精度浮点型float</span><br><span class="line">double price2 = 5.8; // 定义面巾纸的价格，双精度浮点型double</span><br><span class="line">int num1 = 2; // 定义牙膏的数量，整型 int</span><br><span class="line">int num2 = 4; // 定义面巾纸的数量</span><br><span class="line">double res = price1 * num1 + price2 * num2; // 计算总价</span><br><span class="line">System.out.println(&quot;一共付给收银员&quot; + res + &quot;元&quot;); // 输出总价</span><br></pre></td></tr></table></figure>
<p>上述代码中首先定义了一个 float 类型的变量存储牙膏的价格，然后定义了一个 double 类型的变量存储面巾纸的价格，再定义两个 int 类型的变量存储物品的数量，最后进行了乘运算以及和运算之后，将结果储存在一个 double 类型的变量中进行输出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一共付给收银员44.99999923706055元</span><br></pre></td></tr></table></figure>
<p>从执行结果看出，float、int 和 double 三种数据类型参与运算，最后输出的结果为 double 类型的数据。这种转换一般称为“表达式中类型的自动提升”。</p>
<p>自动类型提升有好处，但它也会引起令人疑惑的编译错误。例如，下面看起来正确的程序却会引起问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">byte b = 50;</span><br><span class="line">b = b * 2; // Type mismatch: cannot convert from int to byte</span><br></pre></td></tr></table></figure>
<p>如上所示，第二行会报“类型不匹配：无法从int转换为byte”错误。</p>
<p>该程序试图将一个完全合法的 byte 型的值 50*2 存储给一个 byte 型的变量。但是当表达式求值的时候，操作数被自动的提升为 int 型，计算结果也被提升为 int 型。这样表达式的结果现在是 int 型，不强制转换它就不能被赋为 byte 型。</p>
<p>所以应该使用一个显示的强制类型转换，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">byte b = 50;</span><br><span class="line">b = (byte)(b*2);</span><br></pre></td></tr></table></figure>
<p>这样就能产生正确的值 100。</p>
<p>注意：char 类型比较特殊，char 自动转换成 int、long、float 和 double，但 byte 和 short 不能自动转换为 char，而且 char 也不能自动转换为 byte 或 short。</p>
<p><strong>02、强制类型转换 </strong></p>
<p>强制类型转换是 Java 中将一种数据类型显式转换为另一种数据类型的过程。与自动类型转换不同，强制类型转换需要程序员显式地指定要执行的转换。强制类型转换在以下情况中可能需要：</p>
<ul>
<li>将较大的数据类型转换为较小的数据类型。</li>
<li>将浮点数转换为整数。</li>
<li>将字符类型转换为数值类型。</li>
</ul>
<p>需要注意的是，强制类型转换可能会导致数据丢失或精度降低，因为目标类型可能无法容纳原始类型的所有可能值。因此，在进行强制类型转换时，需要确保转换后的值仍然在目标类型的范围内。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double -&gt; float -&gt; long -&gt; int -&gt; char -&gt; short -&gt; byte</span><br></pre></td></tr></table></figure>
<p>以下是一个简单的示例，演示了强制类型转换：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">double doubleValue = 42.8;</span><br><span class="line">// 强制类型转换：将 double 类型转换为 int 类型</span><br><span class="line">int intValue = (int) doubleValue;</span><br><span class="line">System.out.println(&quot;整数值: &quot; + intValue); // 输出：整数值: 42</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们有一个 double 类型的变量 doubleValue。我们希望将其转换为 int 类型的变量 intValue。为此，我们使用强制类型转换语法，即在要转换的变量之前加上目标类型的括号（如 (int)）。</p>
<p>需要注意的是，将 doubleValue 转换为 int 类型时，小数部分将被截断。因此，输出结果将是：Integer value: 42。在这种情况下，精度丢失是可以接受的，但在其他情况下，我们可能需要更加小心地处理类型转换以避免数据丢失。</p>
<p>顾客到超市购物，购买牙膏 2 盒，面巾纸 4 盒。其中牙膏的价格是 10.9 元，面巾纸的价格是 5.8 元，求商品总价格，在计算总价时采用 int 类型的数据进行存储。实现代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">float price1 = 10.9f;</span><br><span class="line">double price2 = 5.8;</span><br><span class="line">int num1 = 2;</span><br><span class="line">int num2 = 4;</span><br><span class="line">int res2 = (int) (price1 * num1 + price2 * num2);</span><br><span class="line">System.out.println(&quot;一共付给收银员&quot; + res2 + &quot;元&quot;);</span><br></pre></td></tr></table></figure>
<p>在上述实例中，有 double 类型、float 类型和 int 类型的数据参与运算，其运算结果默认为 double 类型，题目要求的结果为 int 类型，因为 int 类型的取值范围要小于 double 类型的取值范围，所以需要进行强制类型转换。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一共付给收银员44元</span><br></pre></td></tr></table></figure>
<h2 id="1-5-Java基本数据类型缓存池"><a href="#1-5-Java基本数据类型缓存池" class="headerlink" title="1.5 Java基本数据类型缓存池"></a>1.5 Java基本数据类型缓存池</h2><p>“考你一个问题哈： new Integer(18) 与 Integer.valueOf(18) 的区别是什么？”</p>
<p>new Integer(18) 每次都会新建一个对象;</p>
<p>Integer.valueOf(18) 会使⽤用缓存池中的对象，多次调用只会取同⼀一个对象的引用。</p>
<p>来看下面这段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Integer x = new Integer(18);</span><br><span class="line">Integer y = new Integer(18);</span><br><span class="line">System.out.println(x == y);</span><br><span class="line">Integer z = Integer.valueOf(18);</span><br><span class="line">Integer k = Integer.valueOf(18);</span><br><span class="line">System.out.println(z == k);</span><br><span class="line">Integer m = Integer.valueOf(300);</span><br><span class="line">Integer p = Integer.valueOf(300);</span><br><span class="line">System.out.println(m == p);</span><br></pre></td></tr></table></figure>
<p>来看一下输出结果吧：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure>
<p>“第一个 false，我知道原因，因为 new 出来的是不同的对象，地址不同。”“第二个和第三个我认为都应该是 true 啊，为什么第三个会输出 false 呢？这个我理解不了。”</p>
<p>“其实原因也很简单。”我胸有成竹地说。</p>
<p>基本数据类型的包装类除了 Float 和 Double 之外，其他六个包装器类（Byte、Short、Integer、Long、Character、Boolean）都有常量缓存池。</p>
<ul>
<li>Byte：-128~127，也就是所有的 byte 值</li>
<li>Short：-128~127</li>
<li>Long：-128~127</li>
<li>Character：\u0000 - \u007F</li>
<li>Boolean：true 和 false</li>
</ul>
<p>拿 Integer 来举例子，Integer 类内部中内置了 256 个 Integer 类型的缓存数据，当使用的数据范围在 -128~127 之间时，会直接返回常量池中数据的引用，而不是创建对象，超过这个范围时会创建新的对象。</p>
<p>18 在 -128~127 之间，300 不在。</p>
<p>来看一下 valueOf 方法的源码吧。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static Integer valueOf(int i) &#123;</span><br><span class="line">    if (i &gt;=IntegerCache.low &amp;&amp; i &lt;=IntegerCache.high)</span><br><span class="line">        return IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    return new Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“哦，原来是因为 Integer.IntegerCache 这个内部类的原因啊！”</p>
<p>“是滴。来看一下 IntegerCache 这个静态内部类的源码吧。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private static class IntegerCache &#123;</span><br><span class="line">    static final int low = -128;</span><br><span class="line">    static final int high;</span><br><span class="line">    static final Integer cache[];</span><br><span class="line">    static &#123;</span><br><span class="line">        // high value may be configured by property</span><br><span class="line">        int h = 127;</span><br><span class="line">        String integerCacheHighPropValue =</span><br><span class="line">                sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);</span><br><span class="line">        if (integerCacheHighPropValue != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                int i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, 127);</span><br><span class="line">                // Maximum array size is Integer.MAX_VALUE</span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -1);</span><br><span class="line">            &#125; catch( NumberFormatException nfe) &#123;</span><br><span class="line">                // If the property cannot be parsed into an int, ignore it.</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line">        cache = new Integer[(high - low) + 1];</span><br><span class="line">        int j = low;</span><br><span class="line">        for(int k = 0; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = new Integer(j++);</span><br><span class="line">        // range [-128, 127] must be interned (JLS7 5.1.7)</span><br><span class="line">        assert Integer.IntegerCache.high &gt;= 127;</span><br><span class="line">    &#125;</span><br><span class="line">    private IntegerCache() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>详细解释下：当我们通过 Integer.valueOf() 方法获取整数对象时，会先检查该整数是否在 IntegerCache 中，如果在，则返回缓存中的对象，否则创建一个新的对象并缓存起来。</p>
<p>需要注意的是，如果使用 new Integer() 创建对象，即使值在 -128 到 127 范围内，也不会被缓存，每次都会创建新的对象。因此，推荐使用 Integer.valueOf() 方法获取整数对象。</p>
<p>学习 static 关键字的时候，会详细解释静态代码块，你暂时先记住，<strong>静态代码块通常用来初始化一些静态变量，它会优先于 main() 方法执行</strong>。</p>
<p>在静态代码块中，low 为 -128，也就是缓存池的最小值；high 默认为 127，也就是缓存池的最大值，共计 256 个。</p>
<p>可以在 JVM 启动的时候，通过 -XX:AutoBoxCacheMax=NNN来设置缓存池的大小，当然了，不能无限大，最大到 Integer.MAX_VALUES - 129</p>
<p>之后，初始化 cache 数组的大小，然后遍历填充，下标从 0 开始。</p>
<p>“这段代码不难理解，难理解的是 assert Integer.IntegerCache.high &gt;= 127; ，这行代码是干嘛的呀？”</p>
<p>assert 是 Java 中的一个关键字，寓意是断言，为了方便调试程序，并不是发布程序的组成部分。</p>
<p>默认情况下，断言是关闭的，可以在命令行运行 Java 程序的时候加上 -ea 参数打开断言。</p>
<p>来看这段代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class AssertTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int high = 126;</span><br><span class="line">        assert high &gt;= 127;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设手动设置的缓存池大小为 126，显然不太符合缓存池的预期值 127，结果会输出什么呢？直接在 Intellij IDEA 中打开命令行终端，进入 classes 文件，执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/libexec/java_home -v 1.8 --exec java -ea com.itwanger.s51.AssertTest</span><br></pre></td></tr></table></figure>
<p>我用的 macOS 环境，装了好多个版本的 JDK，该命令可以切换到 JDK 8</p>
<p>也可以不指定 Java 版本直接执行（加上 -ea 参数）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -ea com.itwanger.s51.AssertTest</span><br></pre></td></tr></table></figure>
<p>“呀，报错了呀。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.AssertionError</span><br><span class="line">        at com.itwanger.s51.AssertTest.main(AssertTest.java:9)</span><br></pre></td></tr></table></figure>
<p>“是滴，因为 126 小于 127。”</p>
<p>“原来 assert 是这样用的啊，我明白了。”</p>
<p>在 Java 中，针对一些基本数据类型（如 Integer、Long、Boolean 等），Java 会在程序启动时创建一些常用的对象并缓存在内存中，以提高程序的性能和节省内存开销。这些常用对象被缓存在一个固定的范围内，超出这个范围的值会被重新创建新的对象。</p>
<p>使用数据类型缓存池可以有效提高程序的性能和节省内存开销，但需要注意的是，在特定的业务场景下，缓存池可能会带来一些问题，例如缓存池中的对象被不同的线程同时修改，导致数据错误等问题。因此，在实际开发中，需要根据具体的业务需求来决定是否使用数据类型缓存池。</p>
<h2 id="1-6-Java运算符"><a href="#1-6-Java运算符" class="headerlink" title="1.6 Java运算符"></a>1.6 Java运算符</h2><p>运算符在 Java 中占据着重要的位置，对程序的执行有着很大的帮助。除了常见的加减乘除，还有许多其他类型的运算符，来看下面这张思维导图。”</p>
<p><img src="\assets\note\image-20230925135407003.png" alt="image-20230925135407003"></p>
<p><strong>01、算术运算符 </strong></p>
<p>算术运算符除了最常见的加减乘除，还有一个取余的运算符，用于得到除法运算后的余数，来串代码感受下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int a = 10;</span><br><span class="line">int b = 5;</span><br><span class="line">System.out.println(a + b);//15</span><br><span class="line">System.out.println(a - b);//5</span><br><span class="line">System.out.println(a * b);//50</span><br><span class="line">System.out.println(a / b);//2</span><br><span class="line">System.out.println(a % b);//0</span><br><span class="line">b = 3;</span><br><span class="line">System.out.println(a + b);//13</span><br><span class="line">System.out.println(a - b);//7</span><br><span class="line">System.out.println(a * b);//30</span><br><span class="line">System.out.println(a / b);//3</span><br><span class="line">System.out.println(a % b);//1</span><br></pre></td></tr></table></figure>
<p>对于初学者来说，加法（+）、减法（-）、乘法（*）很好理解，但除法（/）和取余（%）会有一点点疑惑。在以往的认知里，10/3 是除不尽的，结果应该是 3.333333…，而不应该是 3。相应的，余数也不应该是 1。这是为什么呢？</p>
<p>因为数字在程序中可以分为两种，一种是整型，一种是浮点型（不清楚的同学可以回头看看数据类型那篇），整型和整型的运算结果就是整型，不会出现浮点型。否则，就会出现浮点型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int a = 10;</span><br><span class="line">float c = 3.0f;</span><br><span class="line">double d = 3.0;</span><br><span class="line">System.out.println(a / c); // 3.3333333</span><br><span class="line">System.out.println(a / d); // 3.3333333333333335</span><br><span class="line">System.out.println(a % c); // 1.0</span><br><span class="line">System.out.println(a % d); // 1.0</span><br></pre></td></tr></table></figure>
<p>需要注意的是，当浮点数除以 0 的时候，结果为 Infinity 或者 NaN。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(10.0 / 0.0); // Infinity</span><br><span class="line">System.out.println(0.0 / 0.0); // NaN</span><br></pre></td></tr></table></figure>
<p>Infinity 的中文意思是无穷大，NaN 的中文意思是这不是一个数字（Not a Number）。</p>
<p>当整数除以 0 的时候（ 10 / 0 ），会抛出异常：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.ArithmeticException: / by zero</span><br><span class="line">    at com.itwanger.eleven.ArithmeticOperator.main(ArithmeticOperator.java:32)</span><br></pre></td></tr></table></figure>
<p>所以整数在进行除法运算时，需要先判断除数是否为 0，以免程序抛出异常。</p>
<p>算术运算符中还有两种特殊的运算符，自增运算符（++）和自减运算符（—），它们也叫做一元运算符，只有一个操作数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int x = 10;</span><br><span class="line">System.out.println(x++);//10 (11)  </span><br><span class="line">System.out.println(++x);//12  </span><br><span class="line">System.out.println(x--);//12 (11)  </span><br><span class="line">System.out.println(--x);//10 </span><br></pre></td></tr></table></figure>
<p>一元运算符可以放在数字的前面或者后面，放在前面叫前自增（前自减），放在后面叫后自增（后自减）。</p>
<p>前自增和后自增是有区别的，拿 int y = ++x 这个表达式来说（x = 10），它可以拆分为 x = x+1 = 11; y = x = 11 ，所以表达式的结果为 x = 11, y = 11 。拿 int y = x++ 这个表达式来说（x = 10），它可以拆分为 y = x = 10; x = x+1 = 11 ，所以表达式的结果为 x = 11, y = 10 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int x = 10;</span><br><span class="line">int y = ++x;</span><br><span class="line">System.out.println(y + &quot; &quot; + x);// 11 11</span><br><span class="line">x = 10;</span><br><span class="line">y = x++;</span><br><span class="line">System.out.println(y + &quot; &quot; + x);// 10 11</span><br></pre></td></tr></table></figure>
<p>对于前自减和后自减来说，你可以自己试一把。</p>
<p><strong>02、关系运算符 </strong></p>
<p>关系运算符用来比较两个操作数，返回结果为 true 或者 false。</p>
<p><img src="\assets\note\image-20230926134500081.png" alt="image-20230926134500081"></p>
<p>来看示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int a = 10, b = 20;</span><br><span class="line">System.out.println(a == b); // false</span><br><span class="line">System.out.println(a != b); // true</span><br><span class="line">System.out.println(a &gt; b); // false</span><br><span class="line">System.out.println(a &lt; b); // true</span><br><span class="line">System.out.println(a &gt;= b); // false</span><br><span class="line">System.out.println(a &lt;= b); // true</span><br></pre></td></tr></table></figure>
<p><strong>03、位运算符 </strong></p>
<p>在学习位运算符之前，需要先学习一下二进制，因为位运算符操作的不是整型数值（int、long、short、char、byte）本身，而是整型数值对应的二进制。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Integer.toBinaryString(60)); // 111100</span><br><span class="line">System.out.println(Integer.toBinaryString(13)); // 1101</span><br></pre></td></tr></table></figure>
<p>从程序的输出结果可以看得出来，60 的二进制是 0011 1100（用 0 补到 8 位），13 的二进制是 0000 1101。</p>
<p>PS：现代的二进制记数系统由戈特弗里德·威廉·莱布尼茨于 1679 年设计。莱布尼茨是德意志哲学家、数学家，历史上少见的通才。</p>
<p><img src="\assets\note\image-20230926134711867.png" alt="image-20230926134711867"></p>
<p>来看示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int a = 60, b = 13;</span><br><span class="line">System.out.println(&quot;a 的二进制：&quot; + Integer.toBinaryString(a)); // 111100</span><br><span class="line">System.out.println(&quot;b 的二进制：&quot; + Integer.toBinaryString(b)); // 1101</span><br><span class="line">int c = a &amp; b;</span><br><span class="line">System.out.println(&quot;a &amp; b：&quot; + c + &quot;，二进制是：&quot; + Integer.toBinaryString(c));</span><br><span class="line">c = a | b;</span><br><span class="line">System.out.println(&quot;a | b：&quot; + c + &quot;，二进制是：&quot; + Integer.toBinaryString(c));</span><br><span class="line">c = a ^ b;</span><br><span class="line">System.out.println(&quot;a ^ b：&quot; + c + &quot;，二进制是：&quot; + Integer.toBinaryString(c));</span><br><span class="line">c = ~a;</span><br><span class="line">System.out.println(&quot;~a：&quot; + c + &quot;，二进制是：&quot; + Integer.toBinaryString(c));</span><br><span class="line">c = a &lt;&lt; 2;</span><br><span class="line">System.out.println(&quot;a &lt;&lt; 2：&quot; + c + &quot;，二进制是：&quot; + Integer.toBinaryString(c));</span><br><span class="line">c = a &gt;&gt; 2;</span><br><span class="line">System.out.println(&quot;a &gt;&gt; 2：&quot; + c + &quot;，二进制是：&quot; + Integer.toBinaryString(c));</span><br><span class="line">c = a &gt;&gt;&gt; 2;</span><br><span class="line">System.out.println(&quot;a &gt;&gt;&gt; 2：&quot; + c + &quot;，二进制是：&quot; + Integer.toBinaryString(c));</span><br></pre></td></tr></table></figure>
<p>对于初学者来说，位运算符无法从直观上去计算出结果，不像加减乘除那样。因为我们日常接触的都是十进制，位运算的时候需要先转成二进制，然后再计算出结果。</p>
<p>鉴于此，初学者在写代码的时候其实很少会用到位运算。对于编程高手来说，为了提高程序的性能，会在一些地方使用位运算。比如说，HashMap 在计算哈希值的时候：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果对位运算一点都不懂的话，遇到这样的源码就很吃力。所以说，虽然位运算用的少，但还是要懂。</p>
<p>1）按位左移运算符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(10&lt;&lt;2);//10*2^2=10*4=40  </span><br><span class="line">System.out.println(10&lt;&lt;3);//10*2^3=10*8=80  </span><br><span class="line">System.out.println(20&lt;&lt;2);//20*2^2=20*4=80  </span><br><span class="line">System.out.println(15&lt;&lt;4);//15*2^4=15*16=240 </span><br></pre></td></tr></table></figure>
<p>10&lt;&lt;2 等于 10 乘以 2 的 2 次方； 10&lt;&lt;3 等于 10 乘以 2 的 3 次方。</p>
<p>2）按位右移运算符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(10&gt;&gt;2);//10/2^2=10/4=2</span><br><span class="line">System.out.println(20&gt;&gt;2);//20/2^2=20/4=5</span><br><span class="line">System.out.println(20&gt;&gt;3);//20/2^3=20/8=2</span><br></pre></td></tr></table></figure>
<p>10&gt;&gt;2 等于 10 除以 2 的 2 次方； 20&gt;&gt;2 等于 20 除以 2 的 2 次方。</p>
<p><strong>04、逻辑运算符 </strong></p>
<p>逻辑与运算符（&amp;&amp;）：多个条件中只要有一个为 false 结果就为 false。</p>
<p>逻辑或运算符（||）：多个条件只要有一个为 true 结果就为 true。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a=10;</span><br><span class="line">int b=5;</span><br><span class="line">int c=20;</span><br><span class="line">System.out.println(a&lt;b&amp;&amp;a&lt;c);//false &amp;&amp; true = false</span><br><span class="line">System.out.println(a&gt;b||a&lt;c);//true || true = true</span><br></pre></td></tr></table></figure>
<p>逻辑非运算符（!）：用来反转条件的结果，如果条件为 true，则逻辑非运算符将得到 false。</p>
<p>单逻辑与运算符（&amp;）：很少用，因为不管第一个条件为 true 还是 false，依然会检查第二个。</p>
<p>单逻辑或运算符（|）：也会检查第二个条件。</p>
<p>也就是说，&amp; 和 | 性能不如 &amp;&amp; 和 ||，但用法一样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a=10;</span><br><span class="line">int b=5;</span><br><span class="line">int c=20;</span><br><span class="line">System.out.println(a&lt;b&amp;a&lt;c);//false &amp; true = false</span><br><span class="line">System.out.println(a&gt;b|a&lt;c);//true | true = true  </span><br></pre></td></tr></table></figure>
<p><strong>05、赋值运算符 </strong></p>
<p>赋值操作符恐怕是 Java 中使用最频繁的操作符了，它就是把操作符右侧的值赋值给左侧的变量。来看示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int a=10;</span><br><span class="line">int b=20;</span><br><span class="line">a+=4;//a=a+4 (a=10+4)  </span><br><span class="line">b-=4;//b=b-4 (b=20-4)  </span><br><span class="line">System.out.println(a);</span><br><span class="line">System.out.println(b);</span><br></pre></td></tr></table></figure>
<p>不过在进行数值的赋值时，需要小点心，比如说下面这种情况：</p>
<p><img src="\assets\note\image-20230926135245627.png" alt="image-20230926135245627"></p>
<p>编译器之所以提示错误，是因为 = 右侧的算术表达式默认为 int 类型，左侧是 short 类型的时候需要进行强转。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">short a = 10;</span><br><span class="line">short b = 10;</span><br><span class="line">//a+=b;//a=a+b internally so fine</span><br><span class="line">a = (short)(a + b);</span><br><span class="line">System.out.println(a);</span><br></pre></td></tr></table></figure>
<p>除此之外，还会有边界问题，比如说，两个非常大的 int 相乘，结果可能就超出了 int 的范围：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a = Integer.MAX_VALUE;</span><br><span class="line">int b = 10000;</span><br><span class="line">int c = a * b;</span><br><span class="line">System.out.println(c); // -10000</span><br></pre></td></tr></table></figure>
<p>程序输出的结果为 -10000，这个答案很明显不是我们想要的结果，虽然可以通过右侧表达式强转 long 的方法解决：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a = Integer.MAX_VALUE;</span><br><span class="line">int b = 10000;</span><br><span class="line">long c = (long)a * b;</span><br><span class="line">System.out.println(c); // 21474836470000</span><br></pre></td></tr></table></figure>
<p>但尽量不要这样做，结果非常大的时候，尽量提前使用相应的类型进行赋值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">long a = Integer.MAX_VALUE - 1;</span><br><span class="line">long b = 10000;</span><br><span class="line">long c = a * b;</span><br><span class="line">System.out.println(c); // 21474836460000</span><br></pre></td></tr></table></figure>
<p><strong>06、三元运算符 </strong></p>
<p>三元运算符用于替代 if-else，可以使用一行代码完成条件判断的要求。来看示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a=2;</span><br><span class="line">int b=5;</span><br><span class="line">int min=(a&lt;b)?a:b;</span><br><span class="line">System.out.println(min);</span><br></pre></td></tr></table></figure>
<p>如果 ? 前面的条件为 true，则结果为 : 前的值，否则为 : 后的值。</p>
<p><strong>07、小结 </strong></p>
<p>本文全面介绍了Java运算符，包括算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符等。通过阅读本文，您将了解到Java运算符的分类、用法和优先级，以及如何在实际开发中灵活运用各类运算符提高编程效率。</p>
<h2 id="1-7-Java流程控制语句"><a href="#1-7-Java流程控制语句" class="headerlink" title="1.7 Java流程控制语句"></a>1.7 Java流程控制语句</h2><p>“流程控制语句都有哪些呢？”</p>
<p>“比如说 if-else、switch、for、while、do-while、return、break、continue 等等，接下来，我们一个个来了解下。”</p>
<p><strong>01、if-else 相关</strong></p>
<p><img src="\assets\note\image-20230926135653439.png" alt="image-20230926135653439"></p>
<p>1）if 语句 </p>
<p>if 语句的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(布尔表达式)&#123;  </span><br><span class="line">// 如果条件为 true，则执行这块代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>画个流程图表示一下：</p>
<p><img src="\assets\note\image-20230926135814299.png" alt="image-20230926135814299"></p>
<p>来写个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int age = 20;</span><br><span class="line">if (age &lt; 30) &#123;</span><br><span class="line">    System.out.println(&quot;青春年华&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">青春年华</span><br></pre></td></tr></table></figure>
<p>2）if-else 语句 </p>
<p>if-else 语句的格式如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(布尔表达式)&#123;  </span><br><span class="line">// 条件为 true 时执行的代码块</span><br><span class="line">&#125;else&#123;  </span><br><span class="line">// 条件为 false  时执行的代码块</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>画个流程图表示一下：</p>
<p><img src="\assets\note\image-20230926135950470.png" alt="image-20230926135950470"></p>
<p>来写个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int age = 31;</span><br><span class="line">if (age &lt; 30) &#123;</span><br><span class="line">    System.out.println(&quot;青春年华&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    System.out.println(&quot;而立之年&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">而立之年</span><br></pre></td></tr></table></figure>
<p>除了这个例子之外，还有一个判断闰年（被 4 整除但不能被 100 整除或者被 400 整除）的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int year = 2020;</span><br><span class="line">if (((year % 4 == 0) &amp;&amp; (year % 100 != 0)) || (year % 400 == 0)) &#123;</span><br><span class="line">    System.out.println(&quot;闰年&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    System.out.println(&quot;普通年份&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">闰年</span><br></pre></td></tr></table></figure>
<p>如果执行语句比较简单的话，可以使用三元运算符来代替 if-else 语句，如果条件为 true，返回 ? 后面 : 前面的值；如果条件为 false，返回 : 后面的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int num = 13;</span><br><span class="line">String result = (num % 2 == 0) ? &quot;偶数&quot; : &quot;奇数&quot;;</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">奇数</span><br></pre></td></tr></table></figure>
<p>3）if-else-if 语句 </p>
<p>if-else-if 语句的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if(条件1)&#123;  </span><br><span class="line">// 条件1 为 true 时执行的代码</span><br><span class="line">&#125;else if(条件2)&#123;  </span><br><span class="line">// 条件2 为 true 时执行的代码</span><br><span class="line">&#125;  </span><br><span class="line">else if(条件3)&#123;  </span><br><span class="line">// 条件3 为 true 时执行的代码</span><br><span class="line">&#125;  </span><br><span class="line">...  </span><br><span class="line">else&#123;  </span><br><span class="line">// 以上条件均为 false 时执行的代码</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>画个流程图表示一下：</p>
<p><img src="\assets\note\image-20230926140244236.png" alt="image-20230926140244236"></p>
<p>来写个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int age = 31;</span><br><span class="line">if (age &lt; 30) &#123;</span><br><span class="line">    System.out.println(&quot;青春年华&quot;);</span><br><span class="line">&#125; else if (age &gt;= 30 &amp;&amp; age &lt; 40 ) &#123;</span><br><span class="line">    System.out.println(&quot;而立之年&quot;);</span><br><span class="line">&#125; else if (age &gt;= 40 &amp;&amp; age &lt; 50 ) &#123;</span><br><span class="line">    System.out.println(&quot;不惑之年&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    System.out.println(&quot;知天命&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">而立之年</span><br></pre></td></tr></table></figure>
<p>4）if 嵌套语句 </p>
<p>if 嵌套语句的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if(外侧条件)&#123;    </span><br><span class="line">     // 外侧条件为 true 时执行的代码 </span><br><span class="line">    if(内侧条件)&#123;  </span><br><span class="line">        // 内侧条件为 true 时执行的代码</span><br><span class="line">    &#125;    </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>画个流程图表示一下：</p>
<p><img src="\assets\note\image-20230926141351915.png" alt="image-20230926141351915"></p>
<p>来写个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int age = 20;</span><br><span class="line">boolean isGirl = true;</span><br><span class="line">if (age &gt;= 20) &#123;</span><br><span class="line">    if (isGirl) &#123;</span><br><span class="line">        System.out.println(&quot;女生法定结婚年龄&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">女生法定结婚年龄</span><br></pre></td></tr></table></figure>
<p><strong>02、switch 语句 </strong></p>
<p>switch 语句用来判断变量与多个值之间的相等性。变量的类型可以是 byte、short、int 或者 char，或者对应的包装器类型 Byte、Short、Integer、Character，以及字符串和枚举类型。</p>
<p>来看一下 switch 语句的格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">switch(变量) &#123;    </span><br><span class="line">case 可选值1:    </span><br><span class="line"> // 可选值1匹配后执行的代码;    </span><br><span class="line"> break;  // 该关键字是可选项</span><br><span class="line">case 可选值2:    </span><br><span class="line"> // 可选值2匹配后执行的代码;    </span><br><span class="line"> break;  // 该关键字是可选项</span><br><span class="line">......    </span><br><span class="line">    </span><br><span class="line">default: // 该关键字是可选项     </span><br><span class="line"> // 所有可选值都不匹配后执行的代码 </span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<ul>
<li>变量可以有 1 个或者 N 个值。</li>
<li>值类型必须和变量类型是一致的，并且值是确定的。</li>
<li>值必须是唯一的，不能重复，否则编译会出错。</li>
<li>break 关键字是可选的，如果没有，则执行下一个 case，如果有，则跳出 switch 语句。</li>
<li>default 关键字也是可选的。</li>
</ul>
<p>画个流程图：</p>
<p><img src="\assets\note\image-20230926141611240.png" alt="image-20230926141611240"></p>
<p>来个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int age = 20;</span><br><span class="line">switch (age) &#123;</span><br><span class="line">    case 20 :</span><br><span class="line">        System.out.println(&quot;上学&quot;);</span><br><span class="line">        break;</span><br><span class="line">    case 24 :</span><br><span class="line">        System.out.println(&quot;苏州工作&quot;);</span><br><span class="line">        break;</span><br><span class="line">    case 30 :</span><br><span class="line">        System.out.println(&quot;洛阳工作&quot;);</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        System.out.println(&quot;未知&quot;);</span><br><span class="line">        break; // 可省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">上学</span><br></pre></td></tr></table></figure>
<p>当两个值要执行的代码相同时，可以把要执行的代码写在下一个 case 语句中，而上一个 case 语句中什么也没有，来看一下示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">String name = &quot;沉默王二&quot;;</span><br><span class="line">switch (name) &#123;</span><br><span class="line">    case &quot;詹姆斯&quot;:</span><br><span class="line">        System.out.println(&quot;篮球运动员&quot;);</span><br><span class="line">        break;</span><br><span class="line">    case &quot;穆里尼奥&quot;:</span><br><span class="line">        System.out.println(&quot;足球教练&quot;);</span><br><span class="line">        break;</span><br><span class="line">    case &quot;沉默王二&quot;:</span><br><span class="line">    case &quot;沉默王三&quot;:</span><br><span class="line">        System.out.println(&quot;乒乓球爱好者&quot;);</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        throw new IllegalArgumentException(</span><br><span class="line">                &quot;名字没有匹配项&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">乒乓球爱好者</span><br></pre></td></tr></table></figure>
<p>枚举作为 switch 语句的变量也很常见，来看例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class SwitchEnumDemo &#123;</span><br><span class="line">    public enum PlayerTypes &#123;</span><br><span class="line">        TENNIS,</span><br><span class="line">        FOOTBALL,</span><br><span class="line">        BASKETBALL,</span><br><span class="line">        UNKNOWN</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(createPlayer(PlayerTypes.BASKETBALL));</span><br><span class="line">    &#125;</span><br><span class="line">    private static String createPlayer(PlayerTypes playerType) &#123;</span><br><span class="line">        switch (playerType) &#123;</span><br><span class="line">            case TENNIS:</span><br><span class="line">                return &quot;网球运动员费德勒&quot;;</span><br><span class="line">            case FOOTBALL:</span><br><span class="line">                return &quot;足球运动员C罗&quot;;</span><br><span class="line">            case BASKETBALL:</span><br><span class="line">                return &quot;篮球运动员詹姆斯&quot;;</span><br><span class="line">            case UNKNOWN:</span><br><span class="line">                throw new IllegalArgumentException(&quot;未知&quot;);</span><br><span class="line">            default:</span><br><span class="line">                throw new IllegalArgumentException(</span><br><span class="line">                        &quot;运动员类型: &quot; + playerType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">篮球运动员詹姆斯</span><br></pre></td></tr></table></figure>
<p><strong>03、for 循环</strong></p>
<p><img src="\assets\note\image-20230926141859323.png" alt="image-20230926141859323"></p>
<p>1）普通 for 循环 </p>
<p>普通的 for 循环可以分为 4 个部分：</p>
<p>1）初始变量：循环开始执行时的初始条件。</p>
<p>2）条件：循环每次执行时要判断的条件，如果为 true，就执行循环体；如果为 false，就跳出循环。当然了，条件是可选的，如果没有条件，则会一直循环。</p>
<p>3）循环体：循环每次要执行的代码块，直到条件变为 false。</p>
<p>4）自增/自减：初始变量变化的方式。</p>
<p>来看一下普通 for 循环的格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(初始变量;条件;自增/自减)&#123;  </span><br><span class="line">// 循环体</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>画个流程图：</p>
<p><img src="\assets\note\image-20230926142018436.png" alt="image-20230926142018436"></p>
<p>来个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">    System.out.println(&quot;沉默好美啊&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">沉默好美啊</span><br><span class="line">沉默好美啊</span><br><span class="line">沉默好美啊</span><br><span class="line">沉默好美啊</span><br><span class="line">沉默好美啊</span><br></pre></td></tr></table></figure>
<p>循环语句还可以嵌套呢，这样就可以打印出更好玩的呢</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">    for (int j = 0;j&lt;= i;j++) &#123;</span><br><span class="line">        System.out.print(&quot;❤&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印出什么玩意呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">❤</span><br><span class="line">❤❤</span><br><span class="line">❤❤❤</span><br><span class="line">❤❤❤❤</span><br><span class="line">❤❤❤❤❤</span><br></pre></td></tr></table></figure>
<p>2）for-each </p>
<p>for-each 循环通常用于遍历数组和集合，它的使用规则比普通的 for 循环还要简单，不需要初始变量，不需要条件，不需要下标来自增或者自减。来看一下语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(元素类型 元素 : 数组或集合)&#123;  </span><br><span class="line">// 要执行的代码</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>来看一下示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] strs = &#123;&quot;沉默&quot;, &quot;一枚有趣的程序员&quot;&#125;;</span><br><span class="line">for (String str : strs) &#123;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">沉默</span><br><span class="line">一枚有趣的程序员</span><br></pre></td></tr></table></figure>
<p>3）无限 for 循环 </p>
<p>“你想不想体验一下无限 for 循环的威力，也就是死循环。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(;;)&#123;</span><br><span class="line">    System.out.println(&quot;停不下来。。。。&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">停不下来。。。。</span><br><span class="line">停不下来。。。。</span><br><span class="line">停不下来。。。。</span><br><span class="line">停不下来。。。。</span><br></pre></td></tr></table></figure>
<p>一旦运行起来，就停不下来了，除非强制停止。</p>
<p><strong>04、while 循环 </strong></p>
<p>来看一下 while 循环的格式：</p>
<p><img src="\assets\note\image-20230926142456894.png" alt="image-20230926142456894"></p>
<p>来个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int i = 0;</span><br><span class="line">while (true) &#123;</span><br><span class="line">    System.out.println(&quot;沉默&quot;);</span><br><span class="line">    i++;</span><br><span class="line">    if (i == 5) &#123;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">沉默</span><br><span class="line">沉默</span><br><span class="line">沉默</span><br><span class="line">沉默</span><br><span class="line">沉默</span><br></pre></td></tr></table></figure>
<p>“你想不想体验一下无限 while 循环的威力，也就是死循环。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while (true) &#123;</span><br><span class="line">    System.out.println(&quot;停不下来。。。。&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">停不下来。。。。</span><br><span class="line">停不下来。。。。</span><br><span class="line">停不下来。。。。</span><br><span class="line">停不下来。。。。</span><br></pre></td></tr></table></figure>
<p>把 while 的条件设置为 true，并且循环体中没有 break 关键字的话，程序一旦运行起来，就根本停不下来了，除非强制停止。</p>
<p><strong>05、do-while 循环 </strong></p>
<p>来看一下 do-while 循环的格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">do&#123;  </span><br><span class="line">// 循环体</span><br><span class="line">&#125;while(提交);  </span><br></pre></td></tr></table></figure>
<p>画个流程图：</p>
<p><img src="\assets\note\image-20230926142727978.png" alt="image-20230926142727978"></p>
<p>来个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int i = 0;</span><br><span class="line">do &#123;</span><br><span class="line">    System.out.println(&quot;沉默&quot;);</span><br><span class="line">    i++;</span><br><span class="line">    if (i == 5) &#123;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; while (true);</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">沉默</span><br><span class="line">沉默</span><br><span class="line">沉默</span><br><span class="line">沉默</span><br><span class="line">沉默</span><br></pre></td></tr></table></figure>
<p>“你想不想体验一下无限 do-while 循环的威力……”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">    System.out.println(&quot;停不下来。。。。&quot;);</span><br><span class="line">&#125; while (true);</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">停不下来。。。。</span><br><span class="line">停不下来。。。。</span><br><span class="line">停不下来。。。。</span><br><span class="line">停不下来。。。。</span><br></pre></td></tr></table></figure>
<p>把 do-while 的条件设置为 true，并且循环体中没有 break 关键字的话，程序一旦运行起来，就根本停不下来了，除非强制停止。</p>
<p><img src="\assets\note\image-20230926155231166.png" alt="image-20230926155231166"></p>
<p><strong>06、break </strong></p>
<p>break 关键字通常用于中断循环或 switch 语句，它在指定条件下中断程序的当前流程。如果是内部循环，则仅中断内部循环。</p>
<p>可以将 break 关键字用于所有类型循环语句中，比如说 for 循环、while 循环，以及 do-while 循环。</p>
<p>来画个流程图感受一下：</p>
<p><img src="\assets\note\image-20230926155326551.png" alt="image-20230926155326551"></p>
<p>用在 for 循环中的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 1; i &lt;= 10; i++) &#123;</span><br><span class="line">    if (i == 5) &#123;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用在嵌套 for 循环中的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 1; i &lt;= 3; i++) &#123;</span><br><span class="line">    for (int j = 1; j &lt;= 3; j++) &#123;</span><br><span class="line">        if (i == 2 &amp;&amp; j == 2) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(i + &quot; &quot; + j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用在 while 循环中的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int i = 1;</span><br><span class="line">while (i &lt;= 10) &#123;</span><br><span class="line">    if (i == 5) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用在 do-while 循环中的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int j = 1;</span><br><span class="line">do &#123;</span><br><span class="line">    if (j == 5) &#123; </span><br><span class="line">        j++;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(j);</span><br><span class="line">    j++;</span><br><span class="line">&#125; while (j &lt;= 10);</span><br></pre></td></tr></table></figure>
<p>用在 switch 语句中的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">switch (age) &#123;</span><br><span class="line">    case 20 :</span><br><span class="line">        System.out.println(&quot;上学&quot;);</span><br><span class="line">        break;</span><br><span class="line">    case 24 :</span><br><span class="line">        System.out.println(&quot;苏州工作&quot;);</span><br><span class="line">        break;</span><br><span class="line">    case 30 :</span><br><span class="line">        System.out.println(&quot;洛阳工作&quot;);</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        System.out.println(&quot;未知&quot;);</span><br><span class="line">        break; // 可省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>07、continue </strong></p>
<p>当我们需要在 for 循环或者 （do）while 循环中立即跳转到下一个循环时，就可以使用 continue 关键字，通常用于跳过指定条件下的循环体，如果循环是嵌套的，仅跳过当前循环。</p>
<p>来个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 1; i &lt;= 10; i++) &#123;</span><br><span class="line">    if (i == 5) &#123;</span><br><span class="line">        // 使用 continue 关键字</span><br><span class="line">        continue;// 5 将会被跳过</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>再来个循环嵌套的例子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 1; i &lt;= 3; i++) &#123;</span><br><span class="line">    for (int j = 1; j &lt;= 3; j++) &#123;</span><br><span class="line">        if (i == 2 &amp;&amp; j == 2) &#123;</span><br><span class="line">            //  当i=2，j=2时跳过</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(i + &quot; &quot; + j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印出什么玩意呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 1</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 1</span><br><span class="line">2 3</span><br><span class="line">3 1</span><br><span class="line">3 2</span><br><span class="line">3 3</span><br></pre></td></tr></table></figure>
<p>“2 2” 没有输出，被跳过了。</p>
<p>再来看一下 while 循环时 continue 的使用示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int i = 1;</span><br><span class="line">while (i &lt;= 10) &#123;</span><br><span class="line">    if (i == 5) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        continue;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>注意：如果把 if 条件中的“i++”省略掉的话，程序就会进入死循环，一直在 continue。</p>
<p>最后，再来看一下 do-while 循环时 continue 的使用示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int i=1;</span><br><span class="line">do&#123;</span><br><span class="line">    if(i==5)&#123;</span><br><span class="line">        i++;</span><br><span class="line">        continue;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    i++;</span><br><span class="line">&#125;while(i&lt;=10);</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>注意：同样的，如果把 if 条件中的“i++”省略掉的话，程序就会进入死循环，一直在 continue。</p>
<p><strong>08、小结 </strong></p>
<p>本文全面讲解了Java流程控制语句，包括if、switch、while、for等结构。通过学习本文，你将了解到Java流程控制语句的基本概念、语法结构和使用场景，帮助你在实际编程过程中更加灵活地运用各类控制结构。</p>
<h1 id="2-数组-amp-字符串"><a href="#2-数组-amp-字符串" class="headerlink" title="2 数组&amp;字符串"></a>2 数组&amp;字符串</h1><h2 id="2-1-掌握Java数组"><a href="#2-1-掌握Java数组" class="headerlink" title="2.1 掌握Java数组"></a>2.1 掌握Java数组</h2><p>“ArrayList 的内部是用数组实现的”</p>
<p>“的确是的，看 ArrayList 的源码就一清二楚了。”我一边说，一边打开 Intellij IDEA，并找到了 ArrayList 的源码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The array buffer into which the elements of the ArrayList are stored.</span><br><span class="line"> * The capacity of the ArrayList is the length of this array buffer. Any</span><br><span class="line"> * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><br><span class="line"> * will be expanded to DEFAULT_CAPACITY when the first element is added.</span><br><span class="line"> */</span><br><span class="line">transient Object[] elementData; // non-private to simplify nested class access</span><br><span class="line">/**</span><br><span class="line"> * The size of the ArrayList (the number of elements it contains).</span><br><span class="line"> *</span><br><span class="line"> * @serial</span><br><span class="line"> */</span><br><span class="line">private int size;</span><br></pre></td></tr></table></figure>
<p>“瞧见没？ Object[] elementData 就是数组。”我指着显示屏上这串代码继续说。</p>
<p>数组是一个对象，它包含了一组固定数量的元素，并且这些元素的类型是相同的。数组会按照索引的方式将元素放在指定的位置上，意味着我们可以通过索引来访问这些元素。在 Java 中，索引是从 0 开始的。</p>
<p>“能说一下为什么索引从 0 开始吗？”</p>
<p>“哦，Java 是基于 C/C++ 语言实现的，而 C 语言的下标是从 0 开始的，所以 Java 就继承了这个良好的传统习惯。C语言有一个很重要概念，叫做指针，它实际上是一个偏移量，距离开始位置的偏移量，第一个元素就在开始的位置，它的偏移量就为 0，所以索引就为 0。”此刻，我很自信。</p>
<p>“此外，还有另外一种说法。早期的计算机资源比较匮乏，0 作为起始下标相比较于 1 作为起始下标，编译的效率更高。”</p>
<p>我们可以将数组理解为一个个整齐排列的单元格，每个单元格里面存放着一个元素。</p>
<p>数组元素的类型可以是基本数据类型（比如说 int、double），也可以是引用数据类型（比如说 String），包括自定义类型。</p>
<p>数组的声明方式分两种。</p>
<p>先来看第一种：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[] anArray;</span><br></pre></td></tr></table></figure>
<p>再来看第二种：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int anOtherArray[];</span><br></pre></td></tr></table></figure>
<p>不同之处就在于中括号的位置，是跟在类型关键字的后面，还是跟在变量的名称的后面。前一种的使用频率更高一些，像 ArrayList 的源码中就用了第一种方式。</p>
<p>同样的，数组的初始化方式也有多种，最常见的是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[] anArray = new int[10];</span><br></pre></td></tr></table></figure>
<p>看到了没？上面这行代码中使用了 new 关键字，这就意味着数组的确是一个对象，只有对象的创建才会用到 new 关键字，基本数据类型是不用的。然后，我们需要在方括号中指定数组的长度。</p>
<p>这时候，数组中的每个元素都会被初始化为默认值，int 类型的就为 0，Object 类型的就为 null。 不同数据类型的默认值不同。</p>
<p>另外，还可以使用大括号的方式，直接初始化数组中的元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int anOtherArray[] = new int[] &#123;1, 2, 3, 4, 5&#125;;</span><br></pre></td></tr></table></figure>
<p>这时候，数组的元素分别是 1、2、3、4、5，索引依次是 0、1、2、3、4，长度是 5。</p>
<p>“怎么访问数组呢？”</p>
<p>前面提到过，可以通过索引来访问数组的元素，就像下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">anArray[0] = 10;</span><br></pre></td></tr></table></figure>
<p>变量名，加上中括号，加上元素的索引，就可以访问到数组，通过“=”操作符可以对元素进行赋值。</p>
<p>如果索引的值超出了数组的界限，就会抛出 ArrayIndexOutOfBoundException 。</p>
<p>既然数组的索引是从 0 开始，那就是到数组的 length - 1 结束，不要使用超出这个范围内的索引访问数组，就不会抛出数组越界的异常了。 </p>
<p>当数组的元素非常多的时候，逐个访问数组就太辛苦了，所以需要通过遍历的方式。</p>
<p>第一种，使用 for 循环：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int anOtherArray[] = new int[] &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">for (int i = 0; i &lt; anOtherArray.length; i++) &#123;</span><br><span class="line">    System.out.println(anOtherArray[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 length 属性获取到数组的长度，然后从 0 开始遍历，就得到了数组的所有元素。</p>
<p>第二种，使用 for-each 循环：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (int element : anOtherArray) &#123;</span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不需要关心索引的话（意味着不需要修改数组的某个元素），使用 for-each 遍历更简洁一些。当然，也可以使用 while 和 do-while 循环。</p>
<p>在 Java 中，可变参数用于将任意数量的参数传递给方法，来看 varargsMethod() 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void varargsMethod(String... varargs) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>该方法可以接收任意数量的字符串参数，可以是 0 个或者 N 个，本质上，可变参数就是通过数组实现的。为了证明这一点，我们可以看一下反编译一后的字节码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class VarargsDemo</span><br><span class="line">&#123;</span><br><span class="line">    public VarargsDemo()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    transient void varargsMethod(String as[])</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，我们其实可以直接将数组作为参数传递给该方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VarargsDemo demo = new VarargsDemo();</span><br><span class="line">String[] anArray = new String[] &#123;&quot;沉默&quot;, &quot;一枚有趣的程序员&quot;&#125;;</span><br><span class="line">demo.varargsMethod(anArray);</span><br></pre></td></tr></table></figure>
<p>也可以直接传递多个字符串，通过逗号隔开的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">demo.varargsMethod(&quot;沉默&quot;, &quot;一枚有趣的程序员&quot;);</span><br></pre></td></tr></table></figure>
<p>在 Java 中，数组与 List 关系非常密切。List 封装了很多常用的方法，方便我们对集合进行一些操作，而如果直接操作数组的话，有很多不便，因为数组本身没有提供这些封装好的操作，所以有时候我们需要把数组转成 List。</p>
<p>“怎么转呢？”</p>
<p>最原始的方式，就是通过遍历数组的方式，一个个将数组添加到 List 中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int[] anArray = new int[] &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">List&lt;Integer&gt; aList = new ArrayList&lt;&gt;();</span><br><span class="line">for (int element : anArray) &#123;</span><br><span class="line">    aList.add(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更优雅的方式是通过 Arrays 类的 asList() 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; aList = Arrays.asList(anArray);</span><br></pre></td></tr></table></figure>
<p>不过需要注意的是，Arrays.asList 的参数需要是 Integer 数组，而 anArray 目前是 int 类型，我们需要换另外一种方式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; aList = Arrays.stream(anArray).boxed().collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<p>这又涉及到了 Java 流的知识，后面会讲到。</p>
<p>还有一个需要注意的是，Arrays.asList 方法返回的 ArrayList 并不是 java.util.ArrayList ，它其实是Arrays 类的一个内部类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class="line">        implements RandomAccess, java.io.Serializable&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>如果需要添加元素或者删除元素的话，需要把它转成 java.util.ArrayList 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new ArrayList&lt;&gt;(Arrays.asList(anArray));</span><br></pre></td></tr></table></figure>
<p>Java 8 新增了 Stream 流的概念，这就意味着我们也可以将数组转成 Stream 进行操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] anArray = new String[] &#123;&quot;沉默&quot;, &quot;一枚有趣的程序员&quot;, &quot;好好珍重他&quot;&#125;;</span><br><span class="line">Stream&lt;String&gt; aStream = Arrays.stream(anArray);</span><br></pre></td></tr></table></figure>
<p>如果想对数组进行排序的话，可以使用 Arrays 类提供的 sort() 方法。</p>
<ul>
<li>基本数据类型按照升序排列</li>
<li>实现了 Comparable 接口的对象按照 compareTo() 的排序</li>
</ul>
<p>来看第一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int[] anArray = new int[] &#123;5, 2, 1, 4, 8&#125;;</span><br><span class="line">Arrays.sort(anArray);</span><br></pre></td></tr></table></figure>
<p>排序后的结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 4, 5, 8]</span><br></pre></td></tr></table></figure>
<p>来看第二个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] yetAnotherArray = new String[] &#123;&quot;A&quot;, &quot;E&quot;, &quot;Z&quot;, &quot;B&quot;, &quot;C&quot;&#125;;</span><br><span class="line">Arrays.sort(yetAnotherArray, 1, 3,</span><br><span class="line">                Comparator.comparing(String::toString).reversed());</span><br></pre></td></tr></table></figure>
<p>只对 1-3 位置上的元素进行反序，所以结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[A, Z, E, B, C]</span><br></pre></td></tr></table></figure>
<p>有时候，我们需要从数组中查找某个具体的元素，最直接的方式就是通过遍历的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int[] anArray = new int[] &#123;5, 2, 1, 4, 8&#125;;</span><br><span class="line">for (int i = 0; i &lt; anArray.length; i++) &#123;</span><br><span class="line">    if (anArray[i] == 4) &#123;</span><br><span class="line">        System.out.println(&quot;找到了 &quot; + i);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上例中从数组中查询元素 4，找到后通过 break 关键字退出循环。</p>
<p>如果数组提前进行了排序，就可以使用二分查找法，这样效率就会更高一些。 Arrays.binarySearch() 方法可供我们使用，它需要传递一个数组，和要查找的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int[] anArray = new int[] &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">int index = Arrays.binarySearch(anArray, 4);</span><br></pre></td></tr></table></figure>
<h2 id="2-2-掌握Java二维数组"><a href="#2-2-掌握Java二维数组" class="headerlink" title="2.2 掌握Java二维数组"></a>2.2 掌握Java二维数组</h2><p><strong>01、什么是二维数组 </strong></p>
<p>二维数组是一种数据类型，可以存储多行和多列的数据。它由一系列的行和列组成，每个元素都可以通过一个行索引和列索引来访问。例如，一个3行4列的二维数组可以表示为以下形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array = [</span><br><span class="line">  [a, b, c, d],</span><br><span class="line">  [e, f, g, h],</span><br><span class="line">  [i, j, k, l]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>在这个例子中，第一行有4个元素，第二行有4个元素，第三行有4个元素，每个元素都有一个行索引和一个列索引。例如，元素 array[1][2] 是第2行第3列的元素，它的值是 g。</p>
<p>使用二维数组可以有效地存储和处理表格数据，如矩阵、图像、地图等等。</p>
<p><strong>02、创建二维数组 </strong></p>
<p>要在 Java 中创建二维数组，你必须指定要存储在数组中的数据类型，后跟两个方括号和数组的名称。</p>
<p>语法如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data_type[][] array_name;</span><br></pre></td></tr></table></figure>
<p>让我们看一个代码示例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[][] oddNumbers = &#123; &#123;1, 3, 5, 7&#125;, &#123;9, 11, 13, 15&#125; &#125;;</span><br></pre></td></tr></table></figure>
<p><strong>03、访问二维数组中的元素 </strong></p>
<p>我们可以使用两个方括号来访问二维中的元素。</p>
<p>第一个表示我们要从中访问元素的数组，而第二个表示我们要访问的元素索引。</p>
<p>让我们用一个例子来简化上面的解释：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int[][] oddNumbers = &#123; &#123;1, 3, 5, 7&#125;, &#123;9, 11, 13, 15&#125; &#125;;</span><br><span class="line">System.out.println(oddNumbers[0][0]);</span><br><span class="line">// 1</span><br></pre></td></tr></table></figure>
<p>在上面的示例中， oddNumbers 数组中有两个数组—— {1, 3, 5, 7} 和 {9, 11, 13, 15} 。</p>
<p>第一个数组—— {1, 3, 5, 7} ——用 0 表示。</p>
<p>第二个数组—— {9, 11, 13, 15} ——用 1 表示。</p>
<p>第一个数组是 0，第二个是 1，第三个是 2，依此类推。</p>
<p>因此，要访问第一个数组中的项目，我们将 0 分配给第一个方括号。由于我们试图访问数组中的第一项，我们将使用它的索引，即 0： oddNumbers[0][0] 。</p>
<p>让我们进一步分解它。</p>
<p>这是访问元素的代码： oddNumbers[?][?] 。</p>
<p>我在两个方括号中都加上了问号——随着进展填写它们。</p>
<p>假设我们要访问第二个数组中的元素，我们的代码将如下所示： oddNumbers[1][?] 。</p>
<p>现在我们要在第二个数组（ {9, 11, 13, 15} ）中尝试访问其中一个元素。就像一维数组一样，每个元素都有一个从零开始的索引。</p>
<p>因此，要访问第三个元素 13 ，我们将其索引号传递给第二个方括号： oddNumbers[1][2] 。</p>
<p>来看这样一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[][] oddNumbers = &#123; &#123;1, 3, 5, 7&#125;, &#123;9, 11, 13, 15&#125;, &#123;17, 19, 21, 23&#125; &#125;;</span><br></pre></td></tr></table></figure>
<p>我们的目标是访问第三个数组中的 21。访问方式仍然通过问号来表示： oddNumbers[?][?] 。</p>
<p>我们首先给第一个问号一个指向要访问的特定数组的值。</p>
<p>数组 0 =&gt; {1, 3, 5, 7}</p>
<p>数组 1 =&gt; {9, 11, 13, 15}</p>
<p>数组 2 =&gt; {17, 19, 21, 23}</p>
<p>我们要查找的数字在第三个数组中，所以是： oddNumbers[2][?] 。</p>
<p>第二个方括号的值将指向要访问的元素。为此，我们必须指定元素的索引。以下是该数组中的索引：</p>
<p>17 =&gt; 索引 0</p>
<p>19 =&gt; 索引 1</p>
<p>21 =&gt; 索引 2</p>
<p>23 =&gt; 索引 3</p>
<p>21 的索引为 2，因此我们可以将其添加到第二个方括号： oddNumbers[2][2] 。当你将其打印到控制台时，将会打印出 21。</p>
<p>代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int[][] oddNumbers = &#123; &#123;1, 3, 5, 7&#125;, &#123;9, 11, 13, 15&#125;, &#123;17, 19, 21, 23&#125; &#125;;</span><br><span class="line">System.out.println(oddNumbers[2][2]);</span><br><span class="line">// 21</span><br></pre></td></tr></table></figure>
<p>你可以使用嵌套循环，遍历二维数组中的所有项目。这是一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int[][] oddNumbers = &#123; &#123;1, 3, 5, 7&#125;, &#123;9, 11, 13, 15&#125;, &#123;17, 19, 21, 23&#125; &#125;;</span><br><span class="line">for(int i = 0; i &lt; oddNumbers.length; i++)&#123;</span><br><span class="line">    for(int j = 0; j &lt; oddNumbers[i].length; j++)&#123;</span><br><span class="line">        System.out.println(oddNumbers[i][j]);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line">// 1</span><br><span class="line">// 3</span><br><span class="line">// 5</span><br><span class="line">// 7</span><br><span class="line">// 9</span><br><span class="line">// 11</span><br><span class="line">// 13</span><br><span class="line">// 15</span><br><span class="line">// 17</span><br><span class="line">// 19</span><br><span class="line">// 21</span><br><span class="line">// 23</span><br></pre></td></tr></table></figure>
<p>上面的代码将会打印出 oddNumbers 数组中的所有项目。</p>
<p><strong>04、二维数组打印杨辉三角</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class YangHuiTriangle &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner input = new Scanner(System.in);</span><br><span class="line">        System.out.print(&quot;请输入要打印的行数：&quot;);</span><br><span class="line">        int n = input.nextInt();</span><br><span class="line">        printYangHuiTriangle(n);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void printYangHuiTriangle(int n) &#123;</span><br><span class="line">        int[][] triangle = new int[n][n];</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            // 每行的第一个和最后一个数字都是1</span><br><span class="line">            triangle[i][0] = 1;</span><br><span class="line">            triangle[i][i] = 1;</span><br><span class="line">            for (int j = 1; j &lt; i; j++) &#123;</span><br><span class="line">                // 其他数字是上一行的两个数字之和</span><br><span class="line">                triangle[i][j] = triangle[i - 1][j - 1] + triangle[i - 1][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 打印杨辉三角</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt;= i; j++) &#123;</span><br><span class="line">                System.out.print(triangle[i][j] + &quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“这段代码使用了一个二维数组来存储杨辉三角中的数字。首先，程序要求用户输入要打印的行数，然后调用 printYangHuiTriangle 方法来生成和打印杨辉三角。在 printYangHuiTriangle 方法中，程序使用了一个嵌套的 for 循环来计算杨辉三角中的每个数字，并将结果存储在二维数组 triangle 中。最后，程序再次使用循环来遍历数组并打印出杨辉三角中的数字。”</p>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">请输入要打印的行数：6</span><br><span class="line">1 </span><br><span class="line">1 1 </span><br><span class="line">1 2 1 </span><br><span class="line">1 3 3 1 </span><br><span class="line">1 4 6 4 1 </span><br><span class="line">1 5 10 10 5 1 </span><br></pre></td></tr></table></figure>
<h2 id="2-3-打印Java数组"><a href="#2-3-打印Java数组" class="headerlink" title="2.3 打印Java数组"></a>2.3 打印Java数组</h2><p>“数组也是一个对象，但 Java 中并未明确的定义这样一个类。”</p>
<p>“是的，因此数组也就没有机会覆盖 Object.toString() 方法。如果尝试直接打印数组的话，输出的结果并不是我们预期的结果。”</p>
<p>“那怎么打印数组呢？”</p>
<p>为什么不能直接打印数组</p>
<p>“首先，我们来看一下，为什么不能直接打印数组，直接打印的话，会出现什么问题。”</p>
<p>来看这样一个例子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String [] cmowers = &#123;&quot;沉默&quot;,&quot;一枚有趣的程序员&quot;&#125;;</span><br><span class="line">System.out.println(cmowers);</span><br></pre></td></tr></table></figure>
<p>程序打印的结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Ljava.lang.String;@3d075dc0</span><br></pre></td></tr></table></figure>
<p>[Ljava.lang.String; 表示字符串数组的 Class 名，@ 后面的是十六进制的 hashCode——这样的打印结果太“人性化”了，一般人表示看不懂！为什么会这样显示呢？查看一下 java.lang.Object 类的 toString() 方法就明白了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String [] cmowers = &#123;&quot;沉默&quot;,&quot;王二&quot;,&quot;一枚有趣的程序员&quot;&#125;;</span><br><span class="line">System.out.println(cmowers);</span><br></pre></td></tr></table></figure>
<p>再次证明，数组虽然没有显式定义成一个类，但它的确是一个对象，继承了祖先类 Object 的所有方法。</p>
<p>“那为什么数组不单独定义一个类来表示呢？就像字符串 String 类那样呢？”</p>
<p>“一个合理的说法是 Java 将其隐藏了。假如真的存在这么一个类，就叫 Array.java 吧，我们假想一下它真实的样子，必须得有一个容器来存放数组的每一个元素，就像 String 类那样。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final class String</span><br><span class="line">    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    /** The value is used for character storage. */</span><br><span class="line">    private final char value[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“最终还是要用类似一种数组的形式来存放数组的元素，对吧？这就变得很没有必要了，不妨就把数组当做是一个没有形体的对象吧！”</p>
<p><strong>stream 流打印 Java 数组 </strong></p>
<p>“我们来看第一种打印数组的方法，使用时髦一点的Stream 流。”</p>
<p>第一种形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList(cmowers).stream().forEach(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure>
<p>第二种形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(cmowers).forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>第三种形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.stream(cmowers).forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>打印的结果如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">沉默</span><br><span class="line">一枚有趣的程序员</span><br></pre></td></tr></table></figure>
<p>没错，这三种方式都可以轻松胜任本职工作，并且显得有点高大上，毕竟用到了 Stream，以及 lambda 表达式。</p>
<p><strong>for 循环打印 Java 数组 </strong></p>
<p>“当然了，也可以使用传统的方式，for 循环。甚至 for-each 也行。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(int i = 0; i &lt; cmowers.length; i++)&#123;</span><br><span class="line">    System.out.println(cmowers[i]);</span><br><span class="line">&#125;</span><br><span class="line">for (String s : cmowers) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Arrays 工具类打印 Java 数组 </strong></p>
<p>“当然没有了，我认为 Arrays.toString() 是打印数组的最佳方式，没有之一。”Arrays.toString() 可以将任意类型的数组转成字符串，包括基本类型数组和引用类型数组。该方法有多种重载形式。</p>
<p><img src="\assets\note\image-20230927095033931.png" alt="image-20230927095033931"></p>
<p>使用 Arrays.toString() 方法来打印数组再优雅不过了，就像，就像，就像蒙娜丽莎的微笑。</p>
<p><img src="\assets\note\image-20230927095116614.png" alt="image-20230927095116614"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String [] cmowers = &#123;&quot;沉默&quot;,&quot;一枚有趣的程序员&quot;&#125;;</span><br><span class="line">System.out.println(Arrays.toString(cmowers));</span><br></pre></td></tr></table></figure>
<p>程序打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[沉默, 一枚有趣的程序员]</span><br></pre></td></tr></table></figure>
<p>哇，打印格式不要太完美，不多不少！完全是我们预期的结果： [] 表明是一个数组， , 点和空格用来分割元素。</p>
<p><strong>Arrays工具类打印二维数组 </strong></p>
<p>“那如果我想打印二维数组呢？”</p>
<p>“可以使用 Arrays.deepToString() 方法。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[][] deepArray = new String[][] &#123;&#123;&quot;沉默&quot;&#125;, &#123;&quot;一枚有趣的程序员&quot;&#125;&#125;;</span><br><span class="line">System.out.println(Arrays.deepToString(deepArray));</span><br></pre></td></tr></table></figure>
<p>打印结果如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[沉默], [一枚有趣的程序员]]</span><br></pre></td></tr></table></figure>
<p><strong>POJO 的打印规约 </strong></p>
<p>“说到打印，哥给你提醒一点。阿里巴巴的 Java 开发手册上有这样一条规约，你看。”</p>
<p><img src="\assets\note\image-20230927095402737.png" alt="image-20230927095402737"></p>
<p>“什么是 POJO 呢，就是 Plain Ordinary Java Object 的缩写，一般在 Web 应用程序中建立一个数据库的映射对象时，我们称它为 POJO，这类对象不继承或不实现任何其它 Java 框架的类或接口。”</p>
<p>“对于这样的类，最好是重写一下它的 toString() 方法，方便查看这个对象到底包含了什么字段，好排查问题。”</p>
<p>“如果不重写的话，打印出来的 Java 对象就像直接打印数组的那样，一串谁也看不懂的字符序列。”</p>
<p>“可以借助 Intellij IDEA 生成重写的  toString() 方法，特别方便。”</p>
<p><strong>2.4 解读String类源码 </strong></p>
<p>String 类的声明 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final class String</span><br><span class="line">    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“第一，String 类是 final 的，意味着它不能被子类继承。”</p>
<p>“第二，String 类实现了 Serializable 接口，意味着它可以序列化。”</p>
<p>“第三，String 类实现了 Comparable 接口，意味着最好不要用‘==’来比较两个字符串是否相等，而应该用 compareTo() 方法去比较。”</p>
<p>因为 == 是用来比较两个对象的地址，这个在讲字符串比较的时候会详细讲。如果只是说比较字符串内容的话，可以使用 String 类的 equals 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object anObject) &#123;</span><br><span class="line">    if (this == anObject) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (anObject instanceof String) &#123;</span><br><span class="line">        String anotherString = (String) anObject;</span><br><span class="line">        int n = value.length;</span><br><span class="line">        if (n == anotherString.value.length) &#123;</span><br><span class="line">            char v1[] = value;</span><br><span class="line">            char v2[] = anotherString.value;</span><br><span class="line">            int i = 0;</span><br><span class="line">            while (n-- != 0) &#123;</span><br><span class="line">                if (v1[i] != v2[i])</span><br><span class="line">                    return false;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“第四，StringBuffer、StringBuilder 和 String 一样，都实现了 CharSequence 接口，所以它们仨属于近亲。由于 String 是不可变的，所以遇到字符串拼接的时候就可以考虑一下 String 的另外两个好兄弟，<strong>StringBuffer 和 StringBuilder，它俩是可变的。”</strong></p>
<p><strong>String 类的底层实现 </strong></p>
<p>“第五，Java 9 以前，String 是用 char 型数组实现的，之后改成了 byte 型数组实现，并增加了 coder 来表示编码。这样做的好处是在 Latin1 字符为主的程序里，可以把 String 占用的内存减少一半。当然，天下没有免费的午餐，这个改进在节省内存的同时引入了编码检测的开销。”</p>
<blockquote>
<p>Latin1（Latin-1）是一种单字节字符集（即每个字符只使用一个字节的编码方式），也称为ISO-8859-1（国际标准化组织8859-1），它包含了西欧语言中使用的所有字符，包括英语、法语、德语、西班牙语、葡萄牙语、意大利语等等。在Latin1编码中，每个字符使用一个8位（即一个字节）的编码，可以表示256种不同的字符，其中包括ASCII字符集中的所有字符，即0x00到0x7F，以及其他西欧语言中的特殊字符，例如é、ü、ñ等等。由于Latin1只使用一个字节表示一个字符，因此在存储和传输文本时具有较小的存储空间和较快的速度</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final class String</span><br><span class="line">    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    @Stable</span><br><span class="line">    private final byte[] value;</span><br><span class="line">    private final byte coder;</span><br><span class="line">    private int hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们来详细地说一下。</p>
<p>从 char[] 到 byte[] ，最主要的目的是节省字符串占用的内存空间。内存占用减少带来的另外一个好处，就是 GC 次数也会减少。</p>
<p>我们使用 jmap -histo:live pid | head -n 10 命令就可以查看到堆内对象示例的统计信息、查看 ClassLoader 的信息以及 finalizer 队列。</p>
<p>以我正在运行着的编程喵项目实例（基于 Java 8）来说，结果是这样的。</p>
<p><img src="\assets\note\image-20230927100036881.png" alt="image-20230927100036881"></p>
<p>其中 String 对象有 17638 个，占用了 423312 个字节的内存，排在第三位。</p>
<p>由于 Java 8 的 String 内部实现仍然是 char[] ，所以我们可以看到内存占用排在第 1 位的就是 char 数组。char[] 对象有 17673 个，占用了 1621352 个字节的内存，排在第一位。</p>
<p>那也就是说优化 String 节省内存空间是非常有必要的，如果是去优化一个使用频率没有 String 这么高的类，就没什么必要，对吧？</p>
<p>众所周知，char 类型的数据在 JVM 中是占用两个字节的，并且使用的是 UTF-8 编码，其值范围在 ‘\u0000’（0）和 ‘\uffff’（65,535）（包含）之间。</p>
<p>也就是说，使用 char[] 来表示 String 就会导致，即使 String 中的字符只用一个字节就能表示，也得占用两个字节。</p>
<blockquote>
<p>PS：在计算机中，单字节字符通常指的是一个字节（8位）可以表示的字符，而双字节字符则指需要两个字节（16位）才能表示的字符。单字节字符和双字节字符的定义是相对的，不同的编码方式对应的单字节和双字节字符集也不同。常见的单字节字符集有ASCII（美国信息交换标准代码）、ISO-8859（国际标准化组织标准编号8859）、GBK（汉字内码扩展规范）、GB2312（中国国家标准，现在已经被GBK取代），像拉丁字母、数字、标点符号、控制字符都是单字节字符。双字节字符集包括 Unicode、UTF-8、GB18030（中国国家标准），中文、日文、韩文、拉丁文扩展字符属于双字节字符。</p>
</blockquote>
<p>当然了，仅仅将 char[] 优化为 byte[] 是不够的，还要配合 Latin-1 的编码方式，该编码方式是用单个字节来表示字符的，这样就比 UTF-8 编码节省了更多的空间。</p>
<p>换句话说，对于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String name = &quot;jack&quot;;</span><br></pre></td></tr></table></figure>
<p>这样的，使用 Latin-1 编码，占用 4 个字节就够了。</p>
<p>但对于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String name = &quot;小二&quot;;</span><br></pre></td></tr></table></figure>
<p>这种，木的办法，只能使用 UTF16 来编码。</p>
<p>针对 JDK 9 的 String 源码里，为了区别编码方式，追加了一个 coder 字段来区分。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The identifier of the encoding used to encode the bytes in</span><br><span class="line"> * &#123;@code value&#125;. The supported values in this implementation are</span><br><span class="line"> *</span><br><span class="line"> * LATIN1</span><br><span class="line"> * UTF16</span><br><span class="line"> *</span><br><span class="line"> * @implNote This field is trusted by the VM, and is a subject to</span><br><span class="line"> * constant folding if String instance is constant. Overwriting this</span><br><span class="line"> * field after construction will cause problems.</span><br><span class="line"> */</span><br><span class="line">private final byte coder;</span><br></pre></td></tr></table></figure>
<p>Java 会根据字符串的内容自动设置为相应的编码，要么 Latin-1 要么 UTF16。</p>
<p>也就是说，从 char[] 到 byte[] ，<strong>中文是两个字节，纯英文是一个字节，在此之前呢，中文是两个字节，英文也是两个字节。</strong></p>
<p>在 UTF-8 中，0-127 号的字符用 1 个字节来表示，使用和 ASCII 相同的编码。只有 128 号及以上的字符才用 2 个、3 个或者 4 个字节来表示。</p>
<ul>
<li>如果只有一个字节，那么最高的比特位为 0；</li>
<li>如果有多个字节，那么第一个字节从最高位开始，连续有几个比特位的值为 1，就使用几个字节编码，剩下的字节均以 10 开头。</li>
</ul>
<p>具体的表现形式为：</p>
<ul>
<li>0xxxxxxx：一个字节；</li>
<li>110xxxxx 10xxxxxx：两个字节编码形式（开始两个 1）；</li>
<li>1110xxxx 10xxxxxx 10xxxxxx：三字节编码形式（开始三个 1）；</li>
<li>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx：四字节编码形式（开始四个 1）。</li>
</ul>
<p>也就是说，UTF-8 是变长的，那对于 String 这种有随机访问方法的类来说，就很不方便。所谓的随机访问，就是charAt、subString这种方法，随便指定一个数字，String要能给出结果。如果字符串中的每个字符占用的内存是不定长的，那么进行随机访问的时候，就需要从头开始数每个字符的长度，才能找到你想要的字符。</p>
<p>那你可能会问，UTF-16也是变长的呢？一个字符还可能占用 4 个字节呢？</p>
<p>的确，UTF-16 使用 2 个或者 4 个字节来存储字符。</p>
<ul>
<li>对于 Unicode 编号范围在 0 ~ FFFF 之间的字符，UTF-16 使用两个字节存储。</li>
<li>对于 Unicode 编号范围在 10000 ~ 10FFFF 之间的字符，UTF-16 使用四个字节存储，具体来说就是：将字符编号的所有比特位分成两部分，较高的一些比特位用一个值介于 D800~DBFF 之间的双字节存储，较低的一些比特位（剩下的比特位）用一个值介于 DC00~DFFF 之间的双字节存储。</li>
</ul>
<p>但是在 Java 中，一个字符（char）就是 2 个字节，占 4 个字节的字符，在 Java 里也是用两个 char 来存储的，而String的各种操作，都是以Java的字符（char）为单位的，charAt是取得第几个char，subString取的也是第几个到第几个char组成的子串，甚至length返回的都是char的个数。</p>
<p>所以UTF-16在Java的世界里，就可以视为一个定长的编码。</p>
<p><strong>String 类的 hashCode 方法 </strong></p>
<p>“第六，每一个字符串都会有一个 hash 值，这个哈希值在很大概率是不会重复的，因此 String 很适合来作为 HashMap 的键值。”</p>
<p>来看 String 类的 hashCode 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private int hash; // Cache the hash code for the string</span><br><span class="line">public int hashCode() &#123;</span><br><span class="line">    int h = hash;</span><br><span class="line">    if (h == 0 &amp;&amp; value.length &gt; 0) &#123;</span><br><span class="line">        char val[] = value;</span><br><span class="line">        for (int i = 0; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = 31 * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    return h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>hashCode 方法首先检查是否已经计算过哈希码，如果已经计算过，则直接返回缓存的哈希码。否则，方法将使用一个循环遍历字符串的所有字符，并使用一个乘法和加法的组合计算哈希码。这种计算方法被称为“31 倍哈希法”。计算完成后，将得到的哈希值存储在 hash 成员变量中，以便下次调用 hashCode 方法时直接返回该值，而不需要重新计算。这是一种缓存优化，称为“惰性计算”。</p>
<p>31倍哈希法（31-Hash）是一种简单有效的字符串哈希算法，常用于对字符串进行哈希处理。该算法的基本思想是将字符串中的每个字符乘以一个固定的质数31的幂次方，并将它们相加得到哈希值。具体地，假设字符串为s，长度为n，则31倍哈希值计算公式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">H(s) = (s[0] * 31^(n-1)) + (s[1] * 31^(n-2)) + ... + (s[n-1] * 31^0)</span><br></pre></td></tr></table></figure>
<p>其中，s[i]表示字符串s中第i个字符的ASCII码值， ^表示幂运算。31倍哈希法的优点在于简单易实现，计算速度快，同时也比较均匀地分布在哈希表中。</p>
<p>hashCode 方法，我们会在另外一个章节里详细讲。</p>
<p>我们可以通过以下方法模拟 String 的 hashCode 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class HashCodeExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String text = &quot;沉默王二&quot;;</span><br><span class="line">        int hashCode = computeHashCode(text);</span><br><span class="line">        System.out.println(&quot;字符串 \&quot;&quot; + text + &quot;\&quot; 的哈希码是: &quot; + hashCode);</span><br><span class="line">        System.out.println(&quot;String 的 hashCode &quot; + text.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">    public static int computeHashCode(String text) &#123;</span><br><span class="line">        int h = 0;</span><br><span class="line">        for (int i = 0; i &lt; text.length(); i++) &#123;</span><br><span class="line">            h = 31 * h + text.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看一下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">字符串 &quot;沉默&quot; 的哈希码是: 867758096</span><br><span class="line">String 的 hashCode 867758096</span><br></pre></td></tr></table></figure>
<p>结果是一样的，又学到了吧？</p>
<p><strong>String 类的 substring 方法 </strong></p>
<p>String 类中还有一个方法比较常用 substring，用来截取字符串的，来看源码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public String substring(int beginIndex) &#123;</span><br><span class="line">    if (beginIndex &lt; 0) &#123;</span><br><span class="line">        throw new StringIndexOutOfBoundsException(beginIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    int subLen = value.length - beginIndex;</span><br><span class="line">    if (subLen &lt; 0) &#123;</span><br><span class="line">        throw new StringIndexOutOfBoundsException(subLen);</span><br><span class="line">    &#125;</span><br><span class="line">    return (beginIndex == 0) ? this : new String(value, beginIndex, subLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>substring 方法首先检查参数的有效性，如果参数无效，则抛出 StringIndexOutOfBoundsException 异常。</p>
<p>接下来，方法根据参数计算子字符串的长度。如果子字符串长度小于零，抛出StringIndexOutOfBoundsException异常。</p>
<p>如果 beginIndex 为 0，且 endIndex 等于字符串的长度，说明子串与原字符串相同，因此直接返回原字符串。否则，使用 value 数组（原字符串的字符数组）的一部分创建一个新的 String 对象并返回。</p>
<p>下面是几个使用 substring 方法的示例：</p>
<p>①、提取字符串中的一段子串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;Hello, world!&quot;;</span><br><span class="line">String subStr = str.substring(7, 12);  // 从第7个字符（包括）提取到第12个字符（不包括）</span><br><span class="line">System.out.println(subStr);  // 输出 &quot;world&quot;</span><br></pre></td></tr></table></figure>
<p>②、提取字符串中的前缀或后缀：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;Hello, world!&quot;;</span><br><span class="line">String prefix = str.substring(0, 5);  // 提取前5个字符，即 &quot;Hello,&quot;</span><br><span class="line">String suffix = str.substring(7);     // 提取从第7个字符开始的所有字符，即 &quot;world!&quot;</span><br></pre></td></tr></table></figure>
<p>③、处理字符串中的空格和分隔符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;   Hello,   world!  &quot;;</span><br><span class="line">String trimmed = str.trim();                  // 去除字符串开头和结尾的空格</span><br><span class="line">String[] words = trimmed.split(&quot;\\s+&quot;);       // 将字符串按照空格分隔成单词数组</span><br><span class="line">String firstWord = words[0].substring(0, 1);  // 提取第一个单词的首字母</span><br><span class="line">System.out.println(firstWord);  </span><br></pre></td></tr></table></figure>
<p>④、处理字符串中的数字和符号：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;1234-5678-9012-3456&quot;;</span><br><span class="line">String[] parts = str.split(&quot;-&quot;);             // 将字符串按照连字符分隔成四个部分</span><br><span class="line">String last4Digits = parts[3].substring(1);  // 提取最后一个部分的后三位数字</span><br><span class="line">System.out.println(last4Digits);             // 输出 &quot;456&quot;</span><br></pre></td></tr></table></figure>
<p>总之，substring 方法可以根据需求灵活地提取字符串中的子串，为字符串处理提供了便利。</p>
<p><strong>String 类的 indexOf 方法 </strong></p>
<p>indexOf 方法用于查找一个子字符串在原字符串中第一次出现的位置，并返回该位置的索引。来看该方法的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 查找字符数组 target 在字符数组 source 中第一次出现的位置。</span><br><span class="line"> * sourceOffset 和 sourceCount 参数指定 source 数组中要搜索的范围，</span><br><span class="line"> * targetOffset 和 targetCount 参数指定 target 数组中要搜索的范围，</span><br><span class="line"> * fromIndex 参数指定开始搜索的位置。</span><br><span class="line"> * 如果找到了 target 数组，则返回它在 source 数组中的位置索引（从0开始），</span><br><span class="line"> * 否则返回-1。</span><br><span class="line"> */</span><br><span class="line">static int indexOf(char[] source, int sourceOffset, int sourceCount,</span><br><span class="line">        char[] target, int targetOffset, int targetCount,</span><br><span class="line">        int fromIndex) &#123;</span><br><span class="line">    // 如果开始搜索的位置已经超出 source 数组的范围，则直接返回-1（如果 target 数组为空，则返回 </span><br><span class="line">sourceCount）</span><br><span class="line">    if (fromIndex &gt;= sourceCount) &#123;</span><br><span class="line">        return (targetCount == 0 ? sourceCount : -1);</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果开始搜索的位置小于0，则从0开始搜索</span><br><span class="line">    if (fromIndex &lt; 0) &#123;</span><br><span class="line">        fromIndex = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果 target 数组为空，则直接返回开始搜索的位置</span><br><span class="line">    if (targetCount == 0) &#123;</span><br><span class="line">        return fromIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    // 查找 target 数组的第一个字符在 source 数组中的位置</span><br><span class="line">    char first = target[targetOffset];</span><br><span class="line">    int max = sourceOffset + (sourceCount - targetCount);</span><br><span class="line">    // 循环查找 target 数组在 source 数组中的位置</span><br><span class="line">    for (int i = sourceOffset + fromIndex; i &lt;= max; i++) &#123;</span><br><span class="line">        /* Look for first character. */</span><br><span class="line">        // 如果 source 数组中当前位置的字符不是 target 数组的第一个字符，则在 source 数组中继</span><br><span class="line">续查找 target 数组的第一个字符</span><br><span class="line">        if (source[i] != first) &#123;</span><br><span class="line">            while (++i &lt;= max &amp;&amp; source[i] != first);</span><br><span class="line">        &#125;</span><br><span class="line">        /* Found first character, now look at the rest of v2 */</span><br><span class="line">        // 如果在 source 数组中找到了 target 数组的第一个字符，则继续查找 target 数组的剩余部</span><br><span class="line">分是否匹配</span><br><span class="line">        if (i &lt;= max) &#123;</span><br><span class="line">            int j = i + 1;</span><br><span class="line">            int end = j + targetCount - 1;</span><br><span class="line">            for (int k = targetOffset + 1; j &lt; end &amp;&amp; source[j]</span><br><span class="line">                    == target[k]; j++, k++);</span><br><span class="line">            // 如果 target 数组全部匹配，则返回在 source 数组中的位置索引</span><br><span class="line">            if (j == end) &#123;</span><br><span class="line">                /* Found whole string. */</span><br><span class="line">                return i - sourceOffset;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 没有找到 target 数组，则返回-1</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看示例。</p>
<p>①、示例1：查找子字符串的位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;Hello, world!&quot;;</span><br><span class="line">int index = str.indexOf(&quot;world&quot;);  // 查找 &quot;world&quot; 子字符串在 str 中第一次出现的位置</span><br><span class="line">System.out.println(index);        // 输出 7</span><br></pre></td></tr></table></figure>
<p>②、示例2：查找字符串中某个字符的位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;Hello, world!&quot;;</span><br><span class="line">int index = str.indexOf(&quot;,&quot;);     // 查找逗号在 str 中第一次出现的位置</span><br><span class="line">System.out.println(index);        // 输出 5</span><br></pre></td></tr></table></figure>
<p>③、示例3：查找子字符串的位置（从指定位置开始查找）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;Hello, world!&quot;;</span><br><span class="line">int index = str.indexOf(&quot;l&quot;, 3);  // 从索引为3的位置开始查找 &quot;l&quot; 子字符串在 str 中第一次出现的位置</span><br><span class="line">System.out.println(index);        // 输出 3</span><br></pre></td></tr></table></figure>
<p>④、示例4：查找多个子字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;Hello, world!&quot;;</span><br><span class="line">int index1 = str.indexOf(&quot;o&quot;);    // 查找 &quot;o&quot; 子字符串在 str 中第一次出现的位置</span><br><span class="line">int index2 = str.indexOf(&quot;o&quot;, 5); // 从索引为5的位置开始查找 &quot;o&quot; 子字符串在 str 中第一次出现的位置</span><br><span class="line">System.out.println(index1);       // 输出 4</span><br><span class="line">System.out.println(index2);       // 输出 8</span><br></pre></td></tr></table></figure>
<p><strong>String 类的其他方法 </strong></p>
<p>比如说 length() 用于返回字符串长度。</p>
<p>比如说 isEmpty() 用于判断字符串是否为空。</p>
<p>比如说 charAt() 用于返回指定索引处的字符。</p>
<p>比如说 getBytes() 用于返回字符串的字节数组，可以指定编码方式，比如说：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String text = &quot;沉默&quot;;</span><br><span class="line">System.out.println(Arrays.toString(text.getBytes(StandardCharsets.UTF_8)));</span><br></pre></td></tr></table></figure>
<p>比如说 trim() 用于去除字符串两侧的空白字符，来看源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public String trim() &#123;</span><br><span class="line">    int len = value.length;</span><br><span class="line">    int st = 0;</span><br><span class="line">    char[] val = value;    /* avoid getfield opcode */</span><br><span class="line">    while ((st &lt; len) &amp;&amp; (val[st] &lt;= &#x27; &#x27;)) &#123;</span><br><span class="line">        st++;</span><br><span class="line">    &#125;</span><br><span class="line">    while ((st &lt; len) &amp;&amp; (val[len - 1] &lt;= &#x27; &#x27;)) &#123;</span><br><span class="line">        len--;</span><br><span class="line">    &#125;</span><br><span class="line">    return ((st &gt; 0) || (len &lt; value.length)) ? substring(st, len) : this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举例： “  沉默   “.trim() 会返回”沉默”</p>
<p>除此之外，还有 split、equals、join 等这些方法，我们后面会一一来细讲。</p>
<h2 id="2-5-String为什么不可变"><a href="#2-5-String为什么不可变" class="headerlink" title="2.5 String为什么不可变"></a>2.5 String为什么不可变</h2><p>String 可能是 Java 中使用频率最高的引用类型了，因此 String 类的设计者可以说是用心良苦。比如说 String 的不可变性。</p>
<p>String 类被 final 关键字修饰，所以它不会有子类，这就意味着没有子类可以重写它的方法，改变它的行为。</p>
<p>String 类的数据存储在 char[] 数组中，而这个数组也被 final 关键字修饰了，这就表示 String 对象是没法被修改的，只要初始化一次，值就确定了。</p>
<p>“为什么要这样设计呢？”</p>
<p>“我先简单来说下，能懂最好，不能懂后面再细说。”</p>
<p>第一，可以保证 String 对象的安全性，避免被篡改，毕竟像密码这种隐私信息一般就是用字符串存储的。</p>
<p>以下是一个简单的 Java 示例，演示了字符串的不可变性如何有助于保证 String 对象的安全性。在本例中，我们创建了一个简单的 User 类，该类使用 String 类型的字段存储用户名和密码。同时，我们使用一个静态方法 getUserCredentials 从外部获取用户凭据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">    private String username;</span><br><span class="line">    private String password;</span><br><span class="line">    public User(String username, String password) &#123;</span><br><span class="line">        this.username = username;</span><br><span class="line">        this.password = password;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getUsername() &#123;</span><br><span class="line">        return username;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getPassword() &#123;</span><br><span class="line">        return password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class StringSecurityExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String username = &quot;沉默&quot;;</span><br><span class="line">        String password = &quot;123456&quot;;</span><br><span class="line">        User user = new User(username, password);</span><br><span class="line">        // 获取用户凭据</span><br><span class="line">        String[] credentials = getUserCredentials(user);</span><br><span class="line">        // 尝试修改从 getUserCredentials 返回的用户名和密码字符串</span><br><span class="line">        credentials[0] = &quot;陈清扬&quot;;</span><br><span class="line">        credentials[1] = &quot;612311&quot;;</span><br><span class="line">        // 输出原始 User 对象中的用户名和密码</span><br><span class="line">        System.out.println(&quot;原始用户名: &quot; + user.getUsername()); // 输出 &quot;JohnDoe&quot;</span><br><span class="line">        System.out.println(&quot;原始密码: &quot; + user.getPassword()); // 输出 </span><br><span class="line">&quot;mySecurePassword&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    public static String[] getUserCredentials(User user) &#123;</span><br><span class="line">        String[] credentials = new String[2];</span><br><span class="line">        credentials[0] = user.getUsername();</span><br><span class="line">        credentials[1] = user.getPassword();</span><br><span class="line">        return credentials;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，尽管我们尝试修改 getUserCredentials 返回的字符串数组（即用户名和密码），但原始 User 对象中的用户名和密码保持不变。这证明了字符串的不可变性有助于保护 String 对象的安全性。</p>
<p>第二，保证哈希值不会频繁变更。毕竟要经常作为哈希表的键值，经常变更的话，哈希表的性能就会很差劲。</p>
<p>在 String 类中，哈希值是在第一次计算时缓存的，后续对该哈希值的请求将直接使用缓存值。这有助于提高哈希表等数据结构的性能。以下是一个简单的示例，演示了字符串的哈希值缓存机制：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String text1 = &quot;沉默&quot;;</span><br><span class="line">String text2 = &quot;沉默&quot;;</span><br><span class="line">// 计算字符串 text1 的哈希值，此时会进行计算并缓存哈希值</span><br><span class="line">int hashCode1 = text1.hashCode();</span><br><span class="line">System.out.println(&quot;第一次计算 text1 的哈希值: &quot; + hashCode1);</span><br><span class="line">// 再次计算字符串 text1 的哈希值，此时直接返回缓存的哈希值</span><br><span class="line">int hashCode1Cached = text1.hashCode();</span><br><span class="line">System.out.println(&quot;第二次计算: &quot; + hashCode1Cached);</span><br><span class="line">// 计算字符串 text2 的哈希值，由于字符串常量池的存在，实际上 text1 和 text2 指向同一个字符串对象</span><br><span class="line">// 所以这里直接返回缓存的哈希值</span><br><span class="line">int hashCode2 = text2.hashCode();</span><br><span class="line">System.out.println(&quot;text2 直接使用缓存: &quot; + hashCode2);</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们创建了两个具有相同内容的字符串 text1 和 text2。首次计算 text1 的哈希值时，会进行实际计算并缓存该值。当我们再次计算 text1 的哈希值或计算具有相同内容的 text2 的哈希值时，将直接返回缓存的哈希值，而不进行重新计算。</p>
<p>由于 String 对象是不可变的，其哈希值在创建后不会发生变化。这使得 String 类可以缓存哈希值，提高哈希表等数据结构的性能。如果 String 是可变的，那么在每次修改时都需要重新计算哈希值，这会降低性能。</p>
<p>第三，可以实现字符串常量池，Java 会将相同内容的字符串存储在字符串常量池中。这样，具有相同内容的字符串变量可以指向同一个 String 对象，节省内存空间。</p>
<p>“由于字符串的不可变性，String 类的一些方法实现最终都返回了新的字符串对象。”</p>
<p>“就拿 substring() 方法来说。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public String substring(int beginIndex) &#123;</span><br><span class="line">    if (beginIndex &lt; 0) &#123;</span><br><span class="line">        throw new StringIndexOutOfBoundsException(beginIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    int subLen = value.length - beginIndex;</span><br><span class="line">    if (subLen &lt; 0) &#123;</span><br><span class="line">        throw new StringIndexOutOfBoundsException(subLen);</span><br><span class="line">    &#125;</span><br><span class="line">    return (beginIndex == 0) ? this : new String(value, beginIndex, subLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>substring() 方法用于截取字符串，最终返回的都是 new 出来的新字符串对象。</p>
<p>“还有 concat() 方法。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public String concat(String str) &#123;</span><br><span class="line">    int olen = str.length();</span><br><span class="line">    if (olen == 0) &#123;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">    if (coder() == str.coder()) &#123;</span><br><span class="line">        byte[] val = this.value;</span><br><span class="line">        byte[] oval = str.value;</span><br><span class="line">        int len = val.length + oval.length;</span><br><span class="line">        byte[] buf = Arrays.copyOf(val, len);</span><br><span class="line">        System.arraycopy(oval, 0, buf, val.length, oval.length);</span><br><span class="line">        return new String(buf, coder);</span><br><span class="line">    &#125;</span><br><span class="line">    int len = length();</span><br><span class="line">    byte[] buf = StringUTF16.newBytesFor(len + olen);</span><br><span class="line">    getBytes(buf, 0, UTF16);</span><br><span class="line">    str.getBytes(buf, len, UTF16);</span><br><span class="line">    return new String(buf, UTF16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>concat() 方法用于拼接字符串，<strong>不管编码是否一致，最终也返回的是新的字符串对象。</strong></p>
<p>“ replace() 替换方法其实也一样，三妹，你可以自己一会看一下源码，也是返回新的字符串对象。”</p>
<p>“这就意味着，不管是截取、拼接，还是替换，都不是在原有的字符串上进行的，而是<strong>重新生成了新的字符串对象</strong>。也就是说，这些操作执行过后，<strong>原来的字符串对象并没有发生改变。”</strong></p>
<p>“String 对象一旦被创建后就固定不变了，对 String 对象的任何修改都不会影响到原来的字符串对象，都会生成新的字符串对象。”</p>
<p><strong>2.6 深入理解Java字符串常量池 </strong></p>
<p>“今天我们来学习一下字符串常量池，这是字符串中非常关键的一个知识点。”</p>
<p>new String(“二哥”)创建了几个对象 </p>
<p>“先从这道面试题开始吧！”</p>
<p>“这行代码创建了几个对象？”</p>
<p>“不就一个吗？”</p>
<p>“不，两个！”“使用 new 关键字创建一个字符串对象时，Java 虚拟机会先在字符串常量池中查找有没有‘二哥’这个字符串对象，如果有，就不会在字符串常量池中创建‘二哥’这个对象了，直接在堆中创建一个‘二哥’的字符串对象，然后将堆中这个‘二哥’的对象地址返回赋值给变量 s。”</p>
<p>“如果没有，先在字符串常量池中创建一个‘二哥’的字符串对象，然后再在堆中创建一个‘二哥’的字符串对象，然后将堆中这个‘二哥’的字符串对象地址返回赋值给变量 s。”</p>
<p>我画图表示一下，会更加清楚。</p>
<p><img src="\assets\note\image-20230927103252744.png" alt="image-20230927103252744"></p>
<p>在Java中，栈上存储的是基本数据类型的变量和对象的引用，而对象本身则存储在堆上。</p>
<p>对于这行代码 String s = new String(“二哥”); ，它创建了两个对象：一个是字符串对象 “二哥”，它被添加到了字符串常量池中，另一个是通过 new String() 构造函数创建的字符串对象 “二哥”，它被分配在堆内存中，同时引用变量 s 存储在栈上，它指向堆内存中的字符串对象 “二哥”。</p>
<p>“为什么要先在字符串常量池中创建对象，然后再在堆上创建呢？这样不就多此一举了？”</p>
<p>我回答，“是的。由于字符串的使用频率实在是太高了，所以 Java 虚拟机为了提高性能和减少内存开销，在创建字符串对象的时候进行了一些优化，特意为字符串开辟了一块空间——也就是字符串常量池。”</p>
<p><strong>字符串常量池的作用 </strong></p>
<p>通常情况下，我们会采用双引号的方式来创建字符串对象，而不是通过 new 关键字的方式，就像下面 这样，这样就不会多此一举：</p>
<p>当执行 String s = “三妹” 时，Java 虚拟机会先在字符串常量池中查找有没有“三妹”这个字符串对象，如果有，则不创建任何对象，直接将字符串常量池中这个“三妹”的对象地址返回，赋给变量 s；如果没有，在字符串常量池中创建“三妹”这个对象，然后将其地址返回，赋给变量 s。</p>
<p><img src="\assets\note\image-20230927103456823.png" alt="image-20230927103456823"></p>
<p>Java 虚拟机创建了一个字符串对象 “三妹”，它被添加到了字符串常量池中，同时引用变量 s 存储在栈上，它指向字符串常量池中的字符串对象 “三妹”。你看，是不是省了一步，比之前高效了。</p>
<p>““有了字符串常量池，就可以通过双引号的方式直接创建字符串对象，不用再通过 new 的方式在堆中创建对象了，对吧？”</p>
<p>“是滴。new 的方式始终会创建一个对象，不管字符串的内容是否已经存在，而双引号的方式会重复利用字符串常量池中已经存在的对象。”我说。</p>
<p>来看下面这个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = new String(&quot;二哥&quot;);</span><br><span class="line">String s1 = new String(&quot;二哥&quot;);</span><br></pre></td></tr></table></figure>
<p>按照我们之前的分析，这两行代码会创建三个对象，字符串常量池中一个，堆上两个。</p>
<p>再来看下面这个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = &quot;三妹&quot;;</span><br><span class="line">String s1 = &quot;三妹&quot;;</span><br></pre></td></tr></table></figure>
<p>这两行代码只会创建一个对象，就是字符串常量池中的那个。这样的话，性能肯定就提高了！</p>
<p><strong>字符串常量池在内存中的什么位置呢？ </strong></p>
<p>分为三个阶段。</p>
<p><strong>Java 7 之前 </strong></p>
<p>在 Java 7 之前，字符串常量池位于永久代（Permanent Generation）的内存区域中，主要用来存储一些字符串常量（静态数据的一种）。永久代是 Java 堆（Java Heap）的一部分，用于存储类信息、方法信息、常量池信息等静态数据。</p>
<p>而 Java 堆是 JVM 中存储对象实例和数组的内存区域，也就是说，永久代是 Java 堆的一个子区域。换句话说，永久代中存储的静态数据与堆中存储的对象实例和数组是分开的，它们有不同的生命周期和分配方式。</p>
<p>但是，永久代和堆的大小是相互影响的，因为它们都使用了 JVM 堆内存，因此它们的大小都受到 JVM 堆大小的限制。</p>
<p>于是，当我们创建一个字符串常量时，它会被储存在永久代的字符串常量池中。如果我们创建一个普通字符串对象，则它将被储存在堆中。如果字符串对象的内容是一个已经存在于字符串常量池中的字符串常量，那么这个对象会指向已经存在的字符串常量，而不是重新创建一个新的字符串对象。</p>
<p>画幅图，大概就是这个样子。</p>
<p><img src="\assets\note\image-20230927103826496.png" alt="image-20230927103826496"></p>
<p><strong>Java 7 </strong></p>
<p>需要注意的是，永久代的大小是有限的，并且很难准确地确定一个应用程序需要多少永久代空间。如果我们在应用程序中使用了大量的类、方法、常量等静态数据，就有可能导致永久代空间不足。这种情况下，JVM 就会抛出 OutOfMemoryError 错误。</p>
<p>因此，从 Java 7 开始，为了解决永久代空间不足的问题，将字符串常量池从永久代中移动到堆中。这个改变也是为了更好地支持动态语言的运行时特性。</p>
<p>再画幅图，大概就是这样子。</p>
<p><img src="\assets\note\image-20230927103920703.png" alt="image-20230927103920703"></p>
<p><strong>Java 8 </strong></p>
<p>到了 Java 8，永久代（PermGen）被取消，并由元空间（Metaspace）取代。元空间是一块本机内存区域，和 JVM 内存区域是分开的。不过，元空间的作用依然和之前的永久代一样，用于存储类信息、方法信息、常量池信息等静态数据。</p>
<p>与永久代不同，元空间具有一些优点，例如：</p>
<ul>
<li>它不会导致 OutOfMemoryError 错误，因为元空间的大小可以动态调整。</li>
<li>元空间使用本机内存，而不是 JVM 堆内存，这可以避免堆内存的碎片化问题。</li>
<li>元空间中的垃圾收集与堆中的垃圾收集是分离的，这可以避免应用程序在运行过程中因为进行类加载和卸载而频繁地触发 Full GC。</li>
</ul>
<p>再画幅图，对比来看一下，就会一目了然。</p>
<p><img src="\assets\note\image-20230927104032476.png" alt="image-20230927104032476"></p>
<p><strong>永久代、方法区、元空间 </strong></p>
<p>“能再简单给我解释一下方法区，永久代和元空间的概念吗？有点模糊。”</p>
<p>“可以呀。”</p>
<ul>
<li>方法区是 Java 虚拟机规范中的一个概念，就像是一个接口吧；</li>
<li>永久代是 HotSpot 虚拟机中对方法区的一个实现，就像是接口的实现类；</li>
<li>Java 8 的时候，移除了永久代，取而代之的是元空间，是方法区的另外一种实现，更灵活了。</li>
</ul>
<p>永久代是放在运行时数据区中的，所以它的大小受到 Java 虚拟机本身大小的限制，所以 Java 8 之前，会经常遇到 java.lang.OutOfMemoryError: PremGen Space 的异常，PremGen Space 就是方法区的意思；而元空间是直接放在内存中的，所以只受本机可用内存的限制。</p>
<h2 id="2-7-详解-String-intern-方法"><a href="#2-7-详解-String-intern-方法" class="headerlink" title="2.7 详解 String.intern() 方法"></a>2.7 详解 String.intern() 方法</h2><p>“看一下美团技术团队深入解析 String.intern() 文章”</p>
<p>要理解美团技术团队的这篇文章，你只需要记住这几点内容：</p>
<p>第一，使用双引号声明的字符串对象会保存在字符串常量池中。</p>
<p>第二，使用 new 关键字创建的字符串对象会先从字符串常量池中找，如果没找到就创建一个，然后再在堆中创建字符串对象；如果找到了，就直接在堆中创建字符串对象。</p>
<p>第三，针对没有使用双引号声明的字符串对象来说，就像下面代码中的 s1 那样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s1 = new String(&quot;二哥&quot;) + new String(&quot;三妹&quot;);</span><br></pre></td></tr></table></figure>
<p>如果想把 s1 的内容也放入字符串常量池的话，可以调用 intern() 方法来完成。</p>
<p>不过，需要注意的是，Java 7 的时候，字符串常量池从永久代中移动到了堆中，虽然此时永久代还没有完全被移除。Java 8 的时候，永久代被彻底移除。</p>
<p>这个变化也直接影响了  String.intern() 方法在执行时的策略，Java 7 之前，执行 String.intern() 方法的时候，不管对象在堆中是否已经创建，字符串常量池中仍然会创建一个内容完全相同的新对象； Java 7 之后呢，由于字符串常量池放在了堆中，执行 String.intern() 方法的时候，如果对象在堆中已经创建了，字符串常量池中就不需要再创建新的对象了，而是直接保存堆中对象的引用，也就节省了一部分的内存<br>空间。</p>
<p>“先来猜猜这段代码输出的结果吧。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1 = new String(&quot;二哥三妹&quot;);</span><br><span class="line">String s2 = s1.intern();</span><br><span class="line">System.out.println(s1 == s2);</span><br></pre></td></tr></table></figure>
<p>第一行代码，字符串常量池中会先创建一个“二哥三妹”的对象，然后堆中会再创建一个“二哥三妹”的对象，s1 引用的是堆中的对象。</p>
<p>第二行代码，对 s1 执行 intern() 方法，该方法会从字符串常量池中查找“二哥三妹”这个字符串是否存在，此时是存在的，所以 s2 引用的是字符串常量池中的对象。</p>
<p>也就意味着 s1 和 s2 的引用地址是不同的，一个来自堆，一个来自字符串常量池，所以输出的结果为 false。</p>
<p>“来看一下运行结果。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">false</span><br></pre></td></tr></table></figure>
<p>“我来画幅图，帮助你理解下。”</p>
<p><img src="\assets\note\image-20230927104641609.png" alt="image-20230927104641609"></p>
<p>“好，我们再来看下面这段代码。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1 = new String(&quot;二哥&quot;) + new String(&quot;三妹&quot;);</span><br><span class="line">String s2 = s1.intern();</span><br><span class="line">System.out.println(s1 == s2);</span><br></pre></td></tr></table></figure>
<p>“难道也输出 false ？”</p>
<p>“不，这段代码会输出 true。”</p>
<p>“为啥呀？”</p>
<p>第一行代码，会在字符串常量池中创建两个对象，一个是“二哥”，一个是“三妹”，然后在堆中会创建两个匿名对象“二哥”和“三妹”，最后还有一个“二哥三妹”的对象（稍后会解释），s1 引用的是堆中“二哥三妹”这个对象。</p>
<p>第二行代码，对 s1 执行 intern() 方法，该方法会从字符串常量池中查找“二哥三妹”这个对象是否存在，此时不存在的，但堆中已经存在了，所以字符串常量池中保存的是堆中这个“二哥三妹”对象的引用，也就是说，s2 和 s1 的引用地址是相同的，所以输出的结果为 true。</p>
<p>“来看一下运行结果。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure>
<p>“我再来画幅图，帮助你理解下。”</p>
<p><img src="\assets\note\image-20230927104855320.png" alt="image-20230927104855320"></p>
<p>“不过，我有一个疑惑，“二哥三妹”这个对象是什么时候创建的呢？”</p>
<p>“不错嘛，能抓住问题的关键。再来解释一下 String s1 = new String(“二哥”) + new String(“三妹”) 这行代码。”</p>
<ol>
<li>创建 “二哥” 字符串对象，存储在字符串常量池中。</li>
<li>创建 “三妹” 字符串对象，存储在字符串常量池中。</li>
<li>执行 new String(“二哥”) ，在堆上创建一个字符串对象，内容为 “二哥”。</li>
<li>执行 new String(“三妹”) ，在堆上创建一个字符串对象，内容为 “三妹”。</li>
<li>执行 new String(“二哥”) + new String(“三妹”) ，会创建一个 StringBuilder 对象，并将 “二哥” 和 “三妹” 追加到其中，然后调用 StringBuilder 对象的 toString() 方法，将其转换为一个新的字符串对象，内容为 “二哥三妹”。这个新的字符串对象存储在堆上。</li>
</ol>
<p>也就是说，当编译器遇到 + 号这个操作符的时候，会将 new String(“二哥”) + new String(“三妹”) 这行代码编译为以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new StringBuilder().append(&quot;二哥&quot;).append(&quot;三妹&quot;).toString();</span><br></pre></td></tr></table></figure>
<p>实际执行过程如下：</p>
<ul>
<li>创建一个 StringBuilder 对象。</li>
<li>在 StringBuilder 对象上调用 append(“二哥”)，将 “二哥” 追加到 StringBuilder 中。</li>
<li>在 StringBuilder 对象上调用 append(“三妹”)，将 “三妹” 追加到 StringBuilder 中。</li>
<li>在 StringBuilder 对象上调用 toString() 方法，将 StringBuilder 转换为一个新的字符串对象，内容为 “二哥三妹”。</li>
</ul>
<p>关于 StringBuilder，我们随后会详细地讲到。今天先了解到这。</p>
<p>不过需要注意的是，尽管 intern 可以确保所有具有相同内容的字符串共享相同的内存空间，但也不要烂用 intern，因为任何的缓存池都是有大小限制的，不能无缘无故就占用了相对稀缺的缓存空间，导致其他字符串没有坑位可占。</p>
<p>另外，字符串常量池本质上是一个固定大小的 StringTable，如果放进去的字符串过多，就会造成严重的哈希冲突，从而导致链表变长，链表变长也就意味着字符串常量池的性能会大幅下降，因为要一个一个找是需要花费时间的。</p>
<h2 id="2-8-String、StringBuilder、StringBuffer"><a href="#2-8-String、StringBuilder、StringBuffer" class="headerlink" title="2.8 String、StringBuilder、StringBuffer"></a>2.8 String、StringBuilder、StringBuffer</h2><p>“上一篇深入理解 String.intern() 讲到了 StringBuilder，这一节我们就来聊聊吧！”</p>
<p>由于字符串是不可变的，所以当遇到字符串拼接（尤其是使用 +号操作符）的时候，就需要考量性能的问题，你不能毫无顾虑地生产太多 String 对象，对珍贵的内存造成不必要的压力。</p>
<p>于是 Java 就设计了一个专门用来解决此问题的 StringBuffer 类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public final class StringBuffer extends AbstractStringBuilder implements </span><br><span class="line">Serializable, CharSequence &#123;</span><br><span class="line">    public StringBuffer() &#123;</span><br><span class="line">        super(16);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public synchronized StringBuffer append(String str) &#123;</span><br><span class="line">        super.append(str);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">    public synchronized String toString() &#123;</span><br><span class="line">        return new String(value, 0, count);</span><br><span class="line">    &#125;</span><br><span class="line">    // 其他方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过，由于 StringBuffer 操作字符串的方法加了 synchronized 关键字进行了同步，主要是考虑到多线程环境下的安全问题，所以执行效率会比较低。</p>
<p>于是 Java 就给 StringBuffer “生了个兄弟”，名叫 StringBuilder，说，“孩子，你别管线程安全了，你就在单线程环境下使用，这样效率会高得多，如果要在多线程环境下修改字符串，你到时候可以使用 ThreadLocal 来避免多线程冲突。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public final class StringBuilder extends AbstractStringBuilder</span><br><span class="line">    implements java.io.Serializable, CharSequence</span><br><span class="line">&#123;</span><br><span class="line">    // ...</span><br><span class="line">    public StringBuilder append(String str) &#123;</span><br><span class="line">        super.append(str);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        // Create a copy, don&#x27;t share the array</span><br><span class="line">        return new String(value, 0, count);</span><br><span class="line">    &#125;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了类名不同，方法没有加 synchronized，基本上完全一样。</p>
<p>实际开发中，StringBuilder 的使用频率也是远高于 StringBuffer，甚至可以这么说，StringBuilder 完全取代了 StringBuffer。</p>
<p>之前我们也曾聊过，Java 是一门解释型的编程语言，所以当编译器遇到 + 号这个操作符的时候，会将 new String(“二哥”) + new String(“三妹”) 这行代码编译为以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new StringBuilder().append(&quot;二哥&quot;).append(&quot;三妹&quot;).toString();</span><br></pre></td></tr></table></figure>
<p>这个过程是我们看不见的，但这正是 Java 的“智能”之处，它可以在编译的时候偷偷地帮我们做很多优化，这样既可以提高我们的开发效率（ + 号写起来比创建 StringBuilder 对象便捷得多），也不会影响 JVM 的执行效率。</p>
<p>当然了，如果我们使用 javap 反编译 new String(“二哥”) + new String(“三妹”) 的字节码的时候，也是能看出 StringBuilder 的影子的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">0: new           #2                  // class java/lang/StringBuilder</span><br><span class="line">3: dup</span><br><span class="line">4: invokespecial #3                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">7: new           #4                  // class java/lang/String</span><br><span class="line">10: dup</span><br><span class="line">11: ldc           #5                  // String 二哥</span><br><span class="line">13: invokespecial #6                  // Method java/lang/String.&quot;&lt;init&gt;&quot;:</span><br><span class="line">(Ljava/lang/String;)V</span><br><span class="line">16: invokevirtual #7                  // Method java/lang/StringBuilder.append:</span><br><span class="line">(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">19: new           #4                  // class java/lang/String</span><br><span class="line">22: dup</span><br><span class="line">23: ldc           #8                  // String 三妹</span><br><span class="line">25: invokespecial #6                  // Method java/lang/String.&quot;&lt;init&gt;&quot;:</span><br><span class="line">(Ljava/lang/String;)V</span><br><span class="line">28: invokevirtual #7                  // Method java/lang/StringBuilder.append:</span><br><span class="line">(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">31: invokevirtual #9                  // Method java/lang/StringBuilder.toString:</span><br><span class="line">()Ljava/lang/String;</span><br><span class="line">34: areturn</span><br></pre></td></tr></table></figure>
<p>可以看到 Java 编译器将字符串拼接操作（ + ）转换为了 StringBuilder 对象的 append 方法，然后再调用 StringBuilder 对象的 toString 方法返回拼接后的字符串。</p>
<p>来看一下 StringBuilder 的 toString 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public String toString() &#123;</span><br><span class="line">    return new String(value, 0, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>value 是一个 char 类型的数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The value is used for character storage.</span><br><span class="line"> */</span><br><span class="line">char[] value;</span><br></pre></td></tr></table></figure>
<p>在 StringBuilder 对象创建时，会为 value 分配一定的内存空间（初始容量 16），用于存储字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Constructs a string builder with no characters in it and an</span><br><span class="line"> * initial capacity of 16 characters.</span><br><span class="line"> */</span><br><span class="line">public StringBuilder() &#123;</span><br><span class="line">    super(16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>随着字符串的拼接，value 数组的长度会不断增加，因此在 StringBuilder 对象的实现中，value 数组的长度是可以<strong>动态扩展的，就像ArrayList那样。</strong></p>
<p>继续来看 StringBuilder 的 toString 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public String toString() &#123;</span><br><span class="line">    return new String(value, 0, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>value 用于存储 StringBuilder 对象中包含的字符序列。count 是一个 int 类型的变量，表示字符序列的长度。toString() 方法会调用 new String(value, 0, count) ，使用 value 数组中从 0 开始的前 count 个元素创建一个新的字符串对象，并将其返回。</p>
<p>再来看一下 append 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public StringBuilder append(String str) &#123;</span><br><span class="line">    super.append(str);</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上是调用了 AbstractStringBuilder 中的 append(String str) 方法。在 AbstractStringBuilder 中，append(String str) 方法会检查当前字符序列中的字符是否够用，如果不够用则会进行扩容，并将指定字符串追加到字符序列的末尾。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Appends the specified string to this character sequence.</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * The characters of the &#123;@code String&#125; argument are appended, in order,</span><br><span class="line"> * increasing the length of this sequence by the length of the argument.</span><br><span class="line"> * If &#123;@code str&#125; is &#123;@code null&#125;, then the four characters &#123;@code &quot;null&quot;&#125;</span><br><span class="line"> * are appended.</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * Let &lt;i&gt;n&lt;/i&gt; be the length of this character sequence just prior to</span><br><span class="line"> * execution of the &#123;@code append&#125; method. Then the character at index</span><br><span class="line"> * &lt;i&gt;k&lt;/i&gt; in this character sequence is equal to the character at index</span><br><span class="line"> * &lt;i&gt;k&lt;/i&gt; in the argument &#123;@code str&#125;, if &lt;i&gt;k&lt;/i&gt; is less than</span><br><span class="line"> * &lt;i&gt;n&lt;/i&gt;; otherwise, it is equal to the character at index</span><br><span class="line"> * &lt;i&gt;k-n&lt;/i&gt; in the argument &#123;@code str&#125;.</span><br><span class="line"> *</span><br><span class="line"> * @param   str   a string.</span><br><span class="line"> * @return  a reference to this object.</span><br><span class="line"> */</span><br><span class="line">public AbstractStringBuilder append(String str) &#123;</span><br><span class="line">    if (str == null)</span><br><span class="line">        return appendNull();</span><br><span class="line">    int len = str.length();</span><br><span class="line">    ensureCapacityInternal(count + len);</span><br><span class="line">    str.getChars(0, len, value, count);</span><br><span class="line">    count += len;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>append(String str) 方法将指定字符串追加到当前字符序列中。如果指定字符串为 null，则追加字符串 “null”；否则会检查指定字符串的长度，然后根据当前字符序列中的字符数和指定字符串的长度来判断是否需要扩容。</p>
<p>如果需要扩容，则会调用 ensureCapacityInternal(int minimumCapacity)方法进行扩容。扩容之后，将指定字符串的字符拷贝到字符序列中。</p>
<p>来看一下 ensureCapacityInternal 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private void ensureCapacityInternal(int minimumCapacity) &#123;</span><br><span class="line">    // overflow-conscious code</span><br><span class="line">    if (minimumCapacity - value.length &gt; 0)</span><br><span class="line">        expandCapacity(minimumCapacity);</span><br><span class="line">&#125;</span><br><span class="line">void expandCapacity(int minimumCapacity) &#123;</span><br><span class="line">    int newCapacity = value.length * 2 + 2;</span><br><span class="line">    if (newCapacity - minimumCapacity &lt; 0)</span><br><span class="line">        newCapacity = minimumCapacity;</span><br><span class="line">    if (newCapacity &lt; 0) &#123;</span><br><span class="line">        if (minimumCapacity &lt; 0) // overflow</span><br><span class="line">            throw new OutOfMemoryError();</span><br><span class="line">        newCapacity = Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    value = Arrays.copyOf(value, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ensureCapacityInternal(int minimumCapacity) 方法用于确保当前字符序列的容量至少等于指定的最小容量 minimumCapacity。如果当前容量小于指定的容量，就会为字符序列分配一个新的内部数组。新容量的计算方式如下：</p>
<ul>
<li>如果指定的最小容量大于当前容量，则新容量为两倍的旧容量加上 2；</li>
<li>如果指定的最小容量小于等于当前容量，则不会进行扩容，直接返回当前对象。</li>
</ul>
<p>在进行扩容之前， ensureCapacityInternal(int minimumCapacity) 方法会先检查当前字符序列的容量是否足够，如果不足就会调用 expandCapacity(int minimumCapacity) 方法进行扩容。</p>
<p>expandCapacity(int minimumCapacity) 方法首先计算出新容量，然后使用 Arrays.copyOf(char[] original, int newLength) 方法将原字符数组扩容到新容量的大小。</p>
<p>关于扩容，后面在讲ArrayList的时候会再次说明，今天就先聊到这吧。</p>
<h2 id="2-9-String相等判断"><a href="#2-9-String相等判断" class="headerlink" title="2.9 String相等判断"></a>2.9 String相等判断</h2><p>“如何比较两个字符串相等啊？”</p>
<p>“这个问题看似简单，却在 Stack Overflow 上有超过 370 万+的访问量。”我说，“这个问题也可以引申为 .equals() 和 ‘\==’ 操作符有什么区别。”</p>
<ul>
<li>“\==”操作符用于比较两个对象的地址是否相等。</li>
<li>.equals() 方法用于比较两个对象的内容是否相等。</li>
</ul>
<p>“我来举个不恰当又很恰当的例子，一看你就明白了。”</p>
<p>有一对双胞胎，姐姐叫阿丽塔，妹妹叫洛丽塔。我们普通人可能完全无法分辨谁是姐姐谁是妹妹，可她们的妈妈却可以轻而易举地辨认出。</p>
<p><img src="\assets\note\image-20230927110501241.png" alt="image-20230927110501241"></p>
<p>.equals() 就好像我们普通人，看见阿丽塔以为是洛丽塔，看见洛丽塔以为是阿丽塔，看起来一样就觉得她们是同一个人；“\==”操作符就好像她们的妈妈，要求更严格，观察更细致，一眼就能分辨出谁是姐姐谁是妹妹。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String alita = new String(&quot;小萝莉&quot;);</span><br><span class="line">String luolita = new String(&quot;小萝莉&quot;);</span><br><span class="line">System.out.println(alita.equals(luolita)); // true</span><br><span class="line">System.out.println(alita == luolita); // false</span><br></pre></td></tr></table></figure>
<p>就上面这段代码来说， .equals() 输出的结果为 true，而“\==”操作符输出的结果为 false——前者要求内容相等就可以，后者要求必须是同一个对象。</p>
<p>“之前已经学过了，Java 的所有类都默认地继承 Object 这个超类，该类有一个名为 .equals() 的方法。”一边说，我一边打开了 Object 类的源码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">    return (this == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你看，Object 类的 .equals() 方法默认采用的是“\==”操作符进行比较。假如子类没有重写该方法的话，那么“\==”操作符和 .equals() 方法的功效就完全一样——比较两个对象的内存地址是否相等。</p>
<p>但实际情况中，有不少类重写了 .equals() 方法，因为比较内存地址的要求比较严格，不太符合现实中所有的场景需求。拿 String 类来说，我们在比较字符串的时候，的确只想判断它们俩的内容是相等的就可以了，并不想比较它们俩是不是同一个对象。</p>
<p>况且，字符串有字符串常量池的概念，本身就推荐使用 String s = “字符串” 这种形式来创建字符串对象，而不是通过 new 关键字的方式，因为可以把字符串缓存在字符串常量池中，方便下次使用，不用遇到 new 就在堆上开辟一块新的空间。</p>
<p>“那就来看一下 String 类的 .equals() 方法的源码吧。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object anObject) &#123;</span><br><span class="line">    if (this == anObject) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (anObject instanceof String) &#123;</span><br><span class="line">        String aString = (String)anObject;</span><br><span class="line">        if (coder() == aString.coder()) &#123;</span><br><span class="line">            return isLatin1() ? StringLatin1.equals(value, aString.value)</span><br><span class="line">                    : StringUTF16.equals(value, aString.value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，如果两个字符串对象的可以“\==”，那就直接返回 true 了，因为这种情况下，字符串内容是必然相等的。否则就按照字符编码进行比较，分为 UTF16 和 Latin1，差别不是很大，就拿 Latin1 的来说吧。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@HotSpotIntrinsicCandidate</span><br><span class="line">public static boolean equals(byte[] value, byte[] other) &#123;</span><br><span class="line">    if (value.length == other.length) &#123;</span><br><span class="line">        for (int i = 0; i &lt; value.length; i++) &#123;</span><br><span class="line">            if (value[i] != other[i]) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 JDK 版本是 Java 17，也就是最新的 LTS（长期支持）版本。该版本中，String 类使用字节数组实现的，所以比较两个字符串的内容是否相等时，可以先比较字节数组的长度是否相等，不相等就直接返回 false；否则就遍历两个字符串的字节数组，只有有一个字节不相等，就返回 false。</p>
<p>这是 Java 8 中的 equals 方法源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object anObject) &#123;</span><br><span class="line">    // 判断是否为同一对象</span><br><span class="line">    if (this == anObject) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    // 判断对象是否为 String 类型</span><br><span class="line">    if (anObject instanceof String) &#123;</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        int n = value.length;</span><br><span class="line">        // 判断字符串长度是否相等</span><br><span class="line">        if (n == anotherString.value.length) &#123;</span><br><span class="line">            char v1[] = value;</span><br><span class="line">            char v2[] = anotherString.value;</span><br><span class="line">            int i = 0;</span><br><span class="line">            // 判断每个字符是否相等</span><br><span class="line">            while (n-- != 0) &#123;</span><br><span class="line">                if (v1[i] != v2[i])</span><br><span class="line">                    return false;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JDK 8 比 JDK 17 更容易懂一些：首先判断两个对象是否为同一个对象，如果是，则返回 true。接着，判断对象是否为 String 类型，如果不是，则返回 false。如果对象为 String 类型，则比较两个字符串的长度是否相等，如果长度不相等，则返回 false。如果长度相等，则逐个比较每个字符是否相等，如果都相等，则返回 true，否则返回 false。</p>
<p>“那出几道题考考你吧！”</p>
<p>第一题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new String(&quot;小萝莉&quot;).equals(&quot;小萝莉&quot;)</span><br></pre></td></tr></table></figure>
<p>“输出什么呢？”我问。</p>
<p>“ .equals() 比较的是两个字符串对象的内容是否相等，所以结果为 true。”</p>
<p>第二题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new String(&quot;小萝莉&quot;) == &quot;小萝莉&quot;</span><br></pre></td></tr></table></figure>
<p>“==操作符左侧的是在堆中创建的对象，右侧是在字符串常量池中的对象，尽管内容相同，但内存地址不同，所以返回 false。”</p>
<p>第三题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new String(&quot;小萝莉&quot;) == new String(&quot;小萝莉&quot;)</span><br></pre></td></tr></table></figure>
<p>“new 出来的对象肯定是完全不同的内存地址，所以返回 false。”</p>
<p>第四题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;小萝莉&quot; == &quot;小萝莉&quot;</span><br></pre></td></tr></table></figure>
<p>“字符串常量池中只会有一个相同内容的对象，所以返回 true。”</p>
<p>第五题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;小萝莉&quot; == &quot;小&quot; + &quot;萝莉&quot;</span><br></pre></td></tr></table></figure>
<p>“由于‘小’和‘萝莉’都在字符串常量池，所以编译器在遇到‘+’操作符的时候将其自动优化为“小萝莉”，所以返回 true。”</p>
<p>PS：至于为什么，查看这篇String、StringBuilder、StringBuffer</p>
<p>第六题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new String(&quot;小萝莉&quot;).intern() == &quot;小萝莉&quot;</span><br></pre></td></tr></table></figure>
<p>“ new String(“小萝莉”) 在执行的时候，会先在字符串常量池中创建对象，然后再在堆中创建对象；执行 intern() 方法的时候发现字符串常量池中已经有了‘小萝莉’这个对象，所以就直接返回字符串常量池中的对象引用了，那再与字符串常量池中的‘小萝莉’比较，当然会返回 true 了。”</p>
<p>PS：intern 方法我们之前已经深究过了。</p>
<p>“哥再给你补充一点。”</p>
<p>“如果要进行两个字符串对象的内容比较，除了 .equals() 方法，还有其他两个可选的方案。”</p>
<p>1） Objects.equals()</p>
<p>Objects.equals() 这个静态方法的优势在于不需要在调用之前判空。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static boolean equals(Object a, Object b) &#123;</span><br><span class="line">    return (a == b) || (a != null &amp;&amp; a.equals(b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果直接使用 a.equals(b) ，则需要在调用之前对 a 进行判空，否则可能会抛出空指针 java.lang.NullPointerException 。 Objects.equals() 用起来就完全没有这个担心。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Objects.equals(&quot;小萝莉&quot;, new String(&quot;小&quot; + &quot;萝莉&quot;)) // --&gt; true</span><br><span class="line">Objects.equals(null, new String(&quot;小&quot; + &quot;萝莉&quot;)); // --&gt; false</span><br><span class="line">Objects.equals(null, null) // --&gt; true</span><br><span class="line">String a = null;</span><br><span class="line">a.equals(new String(&quot;小&quot; + &quot;萝莉&quot;)); // throw exception</span><br></pre></td></tr></table></figure>
<p>2）String 类的 .contentEquals()</p>
<p>.contentEquals() 的优势在于可以将字符串与任何的字符序列（StringBuffer、StringBuilder、String、CharSequence）进行比较。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public boolean contentEquals(CharSequence cs) &#123;</span><br><span class="line">    // Argument is a StringBuffer, StringBuilder</span><br><span class="line">    if (cs instanceof AbstractStringBuilder) &#123;</span><br><span class="line">        if (cs instanceof StringBuffer) &#123;</span><br><span class="line">            synchronized(cs) &#123;</span><br><span class="line">                return nonSyncContentEquals((AbstractStringBuilder)cs);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return nonSyncContentEquals((AbstractStringBuilder)cs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // Argument is a String</span><br><span class="line">    if (cs instanceof String) &#123;</span><br><span class="line">        return equals(cs);</span><br><span class="line">    &#125;</span><br><span class="line">    // Argument is a generic CharSequence</span><br><span class="line">    int n = cs.length();</span><br><span class="line">    if (n != length()) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    byte[] val = this.value;</span><br><span class="line">    if (isLatin1()) &#123;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            if ((val[i] &amp; 0xff) != cs.charAt(i)) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (!StringUTF16.contentEquals(val, cs, n)) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从源码上可以看得出，如果 cs 是 StringBuffer，该方法还会进行同步，非常的智能化；如果是 String 的话，其实调用的还是 equals() 方法。当然了，这也就意味着使用该方法进行比较的时候，多出来了很多步骤，性能上有些损失。</p>
<p>同样来看一下 JDK 8 的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public boolean contentEquals(CharSequence cs) &#123;</span><br><span class="line">    // argument can be any CharSequence implementation</span><br><span class="line">    if (cs.length() != value.length) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    // Argument is a StringBuffer, StringBuilder or String</span><br><span class="line">    if (cs instanceof AbstractStringBuilder) &#123;</span><br><span class="line">        char v1[] = value;</span><br><span class="line">        char v2[] = ((AbstractStringBuilder)cs).getValue();</span><br><span class="line">        int i = 0;</span><br><span class="line">        int n = value.length;</span><br><span class="line">        while (n-- != 0) &#123;</span><br><span class="line">            if (v1[i] != v2[i])</span><br><span class="line">                return false;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    // Argument is a String</span><br><span class="line">    if (cs.equals(this))</span><br><span class="line">        return true;</span><br><span class="line">    // Argument is a non-String, non-AbstractStringBuilder CharSequence</span><br><span class="line">    char v1[] = value;</span><br><span class="line">    int i = 0;</span><br><span class="line">    int n = value.length;</span><br><span class="line">    while (n-- != 0) &#123;</span><br><span class="line">        if (v1[i] != cs.charAt(i))</span><br><span class="line">            return false;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   同样更容易理解一些：首先判断参数长度是否相等，不相等则返回 false。如果参数是 AbstractStringBuilder 的实例，则取出其 char 数组，遍历比较两个 char 数组的每个元素是否相等。如果参数是 String 的实例，则直接调用 equals 方法比较两个字符串是否相等。如果参数是其他实现了 CharSequence 接口的对象，则遍历比较两个对象的每个字符是否相等。    </p>
<h2 id="2-10-String拼接"><a href="#2-10-String拼接" class="headerlink" title="2.10 String拼接"></a>2.10 String拼接</h2><p>“《Java 开发手册》上有这么一段内容：循环体内，拼接字符串最好使用 StringBuilder 的 append() 方法，而不是 + 号操作符。这是为什么呀？”</p>
<p>“其实这个问题，我们之前已经聊过。”</p>
<p><strong>javap 探究+号操作符拼接字符串的本质 </strong></p>
<p>“+ 号操作符其实被 Java 在编译的时候重新解释了，换一种说法就是，+ 号操作符是一种语法糖，让字符串的拼接变得更简便了。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Demo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String chenmo = &quot;沉默&quot;;</span><br><span class="line">        String wanger = &quot;王二&quot;;</span><br><span class="line">        System.out.println(chenmo + wanger);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Java 8 的环境下，使用 javap -c Demo.class 反编译字节码后，可以看到以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Compiled from &quot;Demo.java&quot;</span><br><span class="line">class Demo &#123;</span><br><span class="line">  Demo();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: return</span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: ldc           #2                  // String 沉默</span><br><span class="line">       2: astore_1</span><br><span class="line">       3: ldc           #3                  // String 王二</span><br><span class="line">       5: astore_2</span><br><span class="line">       6: getstatic     #4                  // Field </span><br><span class="line">java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       9: new           #5                  // class java/lang/StringBuilder</span><br><span class="line">      12: dup</span><br><span class="line">      13: invokespecial #6                  // Method java/lang/StringBuilder.&quot;</span><br><span class="line">&lt;init&gt;&quot;:()V</span><br><span class="line">      16: aload_1</span><br><span class="line">      17: invokevirtual #7                  // Method </span><br><span class="line">java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      20: aload_2</span><br><span class="line">      21: invokevirtual #7                  // Method </span><br><span class="line">java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      24: invokevirtual #8                  // Method </span><br><span class="line">java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">      27: invokevirtual #9                  // Method java/io/PrintStream.println:</span><br><span class="line">(Ljava/lang/String;)V</span><br><span class="line">      30: return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“这里有一个 new 关键字，并且 class 类型为 java/lang/StringBuilder 。”我指着标号为 9 的那行说，“这意味着新建了一个 StringBuilder 的对象。”</p>
<p>“然后看标号为 17 的这行，是一个 invokevirtual 指令，用于调用对象的方法，也就是 StringBuilder 对象的 append() 方法。”</p>
<p>“也就意味着把 chenmo（”沉默”）这个字符串添加到 StringBuilder 对象中了。”</p>
<p>“再往下看，标号为 21 的这行，又调用了一次 append() 方法，意味着把 wanger（”王二”）这个字符串添加到 StringBuilder 对象中了。”</p>
<p>换成 Java 代码来表示的话，大概是这个样子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Demo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String chenmo = &quot;沉默&quot;;</span><br><span class="line">        String wanger = &quot;王二&quot;;</span><br><span class="line">        System.out.println((new StringBuilder(chenmo)).append(wanger).toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“哦，原来编译的时候把“+”号操作符替换成了 StringBuilder 的 append() 方法啊。”</p>
<p>“是的，不过到了 Java 9（不是长期支持版本，所以我会拿 Java 11 来演示），情况发生了一些改变，同样的代码，字节码指令完全不同了。”我说。</p>
<p>同样的代码，在 Java 11 的环境下，字节码指令是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Compiled from &quot;Demo.java&quot;</span><br><span class="line">public class com.itwanger.thirtyseven.Demo &#123;</span><br><span class="line">  public com.itwanger.thirtyseven.Demo();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: return</span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: ldc           #2                  // String</span><br><span class="line">       2: astore_1</span><br><span class="line">       3: iconst_0</span><br><span class="line">       4: istore_2</span><br><span class="line">       5: iload_2</span><br><span class="line">       6: bipush        10</span><br><span class="line">       8: if_icmpge     41</span><br><span class="line">      11: new           #3                  // class java/lang/String</span><br><span class="line">      14: dup</span><br><span class="line">      15: ldc           #4                  // String 沉默</span><br><span class="line">      17: invokespecial #5                  // Method java/lang/String.&quot;&lt;init&gt;&quot;:</span><br><span class="line">(Ljava/lang/String;)V</span><br><span class="line">      20: astore_3</span><br><span class="line">      21: ldc           #6                  // String 王二</span><br><span class="line">      23: astore        4</span><br><span class="line">      25: aload_1</span><br><span class="line">      26: aload_3</span><br><span class="line">      27: aload         4</span><br><span class="line">      29: invokedynamic #7,  0              // InvokeDynamic </span><br><span class="line">#0:makeConcatWithConstants:</span><br><span class="line">(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;</span><br><span class="line">      34: astore_1</span><br><span class="line">      35: iinc          2, 1</span><br><span class="line">      38: goto          5</span><br><span class="line">      41: return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看标号为 29 的这行，字节码指令为 invokedynamic ，该指令允许由应用级的代码来决定方法解析，所谓的应用级的代码其实是一个方法——被称为引导方法（Bootstrap Method），简称 BSM，BSM 会返回一个 CallSite（调用点） 对象，这个对象就和 invokedynamic 指令链接在一起。以后再执行这条 invokedynamic 指令时就不会创建新的 CallSite 对象。CallSite 其实就是一个 MethodHandle（方法句<br>柄）的 holder，指向一个调用点真正执行的方法——此时就是 StringConcatFactory.makeConcatWithConstants() 方法。</p>
<p>“好吧，总之就是 Java 9 以后，JDK 用了另外一种方法来动态解释 + 号操作符，具体的实现方式在字节码指令层面已经看不到了，所以我就以 Java 8 来继续讲解吧。”</p>
<p><strong>为什么要编译为 StringBuilder.append </strong></p>
<p>“再回到《Java 开发手册》上的那段内容：循环体内，拼接字符串最好使用 StringBuilder 的 append() 方法，而不是 + 号操作符。原因就在于循环体内如果用 + 号操作符的话，就会产生大量的 StringBuilder 对象，不仅占用了更多的内存空间，还会让 Java 虚拟机不停的进行垃圾回收，从而降低了程序的性能。”</p>
<p>更好的写法就是在循环的外部新建一个 StringBuilder 对象，然后使用 append() 方法将循环体内的字符串添加进来：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Demo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        for (int i = 1; i &lt; 10; i++) &#123;</span><br><span class="line">            String chenmo = &quot;沉默&quot;;</span><br><span class="line">            String wanger = &quot;王二&quot;;</span><br><span class="line">            sb.append(chenmo);</span><br><span class="line">            sb.append(wanger);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来做个小测试。</p>
<p>第一个，for 循环中使用”+”号操作符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String result = &quot;&quot;;</span><br><span class="line">for (int i = 0; i &lt; 100000; i++) &#123;</span><br><span class="line">    result += &quot;六六六&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二个，for 循环外部新建 StringBuilder，循环体内使用 append() 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder sb = new StringBuilder();</span><br><span class="line">for (int i = 0; i &lt; 100000; i++) &#123;</span><br><span class="line">    sb.append(&quot;六六六&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“这两个小测试分别会耗时多长时间呢？”</p>
<p>“哇，第一个小测试的执行时间是 6212 毫秒，第二个只用了不到 1 毫秒，差距也太大了吧！”</p>
<p>“是的，这下明白了原因吧？”我说。</p>
<p><strong>append方法源码解析 </strong></p>
<p>“好了，来看一下 StringBuilder 类的 append() 方法的源码吧！”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public StringBuilder append(String str) &#123;</span><br><span class="line">    super.append(str);</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这 3 行代码其实没啥看的。我们来看父类 AbstractStringBuilder 的 append() 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public AbstractStringBuilder append(String str) &#123;</span><br><span class="line">    if (str == null)</span><br><span class="line">        return appendNull();</span><br><span class="line">    int len = str.length();</span><br><span class="line">    ensureCapacityInternal(count + len);</span><br><span class="line">    str.getChars(0, len, value, count);</span><br><span class="line">    count += len;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1）判断拼接的字符串是不是 null，如果是，当做字符串“null”来处理。 appendNull() 方法的源码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private AbstractStringBuilder appendNull() &#123;</span><br><span class="line">    int c = count;</span><br><span class="line">    ensureCapacityInternal(c + 4);</span><br><span class="line">    final char[] value = this.value;</span><br><span class="line">    value[c++] = &#x27;n&#x27;;</span><br><span class="line">    value[c++] = &#x27;u&#x27;;</span><br><span class="line">    value[c++] = &#x27;l&#x27;;</span><br><span class="line">    value[c++] = &#x27;l&#x27;;</span><br><span class="line">    count = c;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2）获取字符串的长度。</p>
<p>3） ensureCapacityInternal() 方法的源码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private void ensureCapacityInternal(int minimumCapacity) &#123;</span><br><span class="line">    // overflow-conscious code</span><br><span class="line">    if (minimumCapacity - value.length &gt; 0) &#123;</span><br><span class="line">        value = Arrays.copyOf(value,</span><br><span class="line">                newCapacity(minimumCapacity));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于字符串内部是用数组实现的，所以需要先判断拼接后的字符数组长度是否超过当前数组的长度，如果超过，先对数组进行扩容，然后把原有的值复制到新的数组中。</p>
<p> 4）将拼接的字符串 str 复制到目标数组 value 中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.getChars(0, len, value, count)</span><br></pre></td></tr></table></figure>
<p>5）更新数组的长度 count。</p>
<p><strong>String.concat 拼接字符串 </strong></p>
<p>“除了可以使用 + 号操作符，StringBuilder 的 append() 方法，还有其他的字符串拼接方法吗？”</p>
<p>“有啊，比如说 String 类的 concat() 方法，有点像 StringBuilder 类的 append() 方法。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String chenmo = &quot;沉默&quot;;</span><br><span class="line">String wanger = &quot;王二&quot;;</span><br><span class="line">System.out.println(chenmo.concat(wanger));</span><br></pre></td></tr></table></figure>
<p>可以来看一下 concat() 方法的源码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public String concat(String str) &#123;</span><br><span class="line">    int otherLen = str.length();</span><br><span class="line">    if (otherLen == 0) &#123;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">    int len = value.length;</span><br><span class="line">    char buf[] = Arrays.copyOf(value, len + otherLen);</span><br><span class="line">    str.getChars(buf, len);</span><br><span class="line">    return new String(buf, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1）如果拼接的字符串的长度为 0，那么返回拼接前的字符串。</p>
<p>2）将原字符串的字符数组 value 复制到变量 buf 数组中。</p>
<p>3）把拼接的字符串 str 复制到字符数组 buf 中，并返回新的字符串对象。</p>
<p>我一行一行地解释着。</p>
<p>“和 + 号操作符相比， concat() 方法在遇到字符串为 null 的时候，会抛出 NullPointerException，而“+”号操作符会把 null 当做是“null”字符串来处理。”</p>
<p>如果拼接的字符串非常多， concat() 的效率就会下降，因为创建的字符串对象越来越多。</p>
<p>“还有吗？”</p>
<p>“有，当然有。”</p>
<p><strong>String.join 拼接字符串 </strong></p>
<p>String 类有一个静态方法 join() ，可以这样来使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String chenmo = &quot;沉默&quot;;</span><br><span class="line">String wanger = &quot;王二&quot;;</span><br><span class="line">String cmower = String.join(&quot;&quot;, chenmo, wanger);</span><br><span class="line">System.out.println(cmower);</span><br></pre></td></tr></table></figure>
<p>第一个参数为字符串连接符，比如说：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String message = String.join(&quot;-&quot;, &quot;王二&quot;, &quot;太特么&quot;, &quot;有趣了&quot;);</span><br></pre></td></tr></table></figure>
<p>输出结果为：王二-太特么-有趣了 。</p>
<p>来看一下 join 方法的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static String join(CharSequence delimiter, CharSequence... elements) &#123;</span><br><span class="line">    Objects.requireNonNull(delimiter);</span><br><span class="line">    Objects.requireNonNull(elements);</span><br><span class="line">    // Number of elements not likely worth Arrays.stream overhead.</span><br><span class="line">    StringJoiner joiner = new StringJoiner(delimiter);</span><br><span class="line">    for (CharSequence cs: elements) &#123;</span><br><span class="line">        joiner.add(cs);</span><br><span class="line">    &#125;</span><br><span class="line">    return joiner.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>里面新建了一个叫 StringJoiner 的对象，然后通过 for-each 循环把可变参数添加了进来，最后调用 toString() 方法返回 String。</p>
<p><strong>StringUtils.join 拼接字符串 </strong></p>
<p>“实际的工作中， org.apache.commons.lang3.StringUtils 的 join() 方法也经常用来进行字符串拼接。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String chenmo = &quot;沉默&quot;;</span><br><span class="line">String wanger = &quot;王二&quot;;</span><br><span class="line">StringUtils.join(chenmo, wanger);</span><br></pre></td></tr></table></figure>
<p>该方法不用担心 NullPointerException。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StringUtils.join(null)            = null</span><br><span class="line">StringUtils.join([])              = &quot;&quot;</span><br><span class="line">StringUtils.join([null])          = &quot;&quot;</span><br><span class="line">StringUtils.join([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]) = &quot;abc&quot;</span><br><span class="line">StringUtils.join([null, &quot;&quot;, &quot;a&quot;]) = &quot;a&quot;</span><br></pre></td></tr></table></figure>
<p>来看一下源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static String join(final Object[] array, String separator, final int </span><br><span class="line">startIndex, final int endIndex) &#123;</span><br><span class="line">    if (array == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    if (separator == null) &#123;</span><br><span class="line">        separator = EMPTY;</span><br><span class="line">    &#125;</span><br><span class="line">    final StringBuilder buf = new StringBuilder(noOfItems * 16);</span><br><span class="line">    for (int i = startIndex; i &lt; endIndex; i++) &#123;</span><br><span class="line">        if (i &gt; startIndex) &#123;</span><br><span class="line">            buf.append(separator);</span><br><span class="line">        &#125;</span><br><span class="line">        if (array[i] != null) &#123;</span><br><span class="line">            buf.append(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return buf.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部使用的仍然是 StringBuilder。</p>
<p>“好了，关于字符串拼接的知识点我们就讲到这吧。注意 Java 9 以后，对 + 号操作符的解释和之前发生了变化，字节码指令已经不同了，等后面你学了字节码指令后我们再详细地讲一次。”</p>
<h2 id="2-11-String拆分"><a href="#2-11-String拆分" class="headerlink" title="2.11 String拆分"></a>2.11 String拆分</h2><p>“哥，我感觉字符串拆分没什么可讲的呀，直接上 String 类的 split() 方法不就可以了！”三妹毫不客气地说。</p>
<p>“假如你真的这么觉得，那可要注意了，事情远没这么简单。”我微笑着说。</p>
<p>假如现在有这样一串字符序列“沉默王二，一枚有趣的程序员”，需要按照中文逗号“，”进行拆分，这意味着第一串字符序列为逗号前面的“沉默王二”，第二串字符序列为逗号后面的“一枚有趣的程序员”。</p>
<p>“这不等于没说吗？哥！”还没等我说，三妹就打断了我。</p>
<p>“别着急嘛，等哥说完。”我依然保持着微笑继续说，“在拆分之前，要先进行检查，判断一下这串字符是否包含逗号，否则应该抛出异常。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String cmower = &quot;沉默王二，一枚有趣的程序员&quot;;</span><br><span class="line">        if (cmower.contains(&quot;，&quot;)) &#123;</span><br><span class="line">            String [] parts = cmower.split(&quot;，&quot;);</span><br><span class="line">            System.out.println(&quot;第一部分：&quot; + parts[0] +&quot; 第二部分：&quot; + parts[1]);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;当前字符串没有包含逗号&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“三妹你看，这段代码挺严谨的吧？”我说，“来看一下程序的输出结果。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第一部分：沉默王二 第二部分：一枚有趣的程序员</span><br></pre></td></tr></table></figure>
<p>“的确和预期完全一致。”三妹说。</p>
<p>“这是建立在字符串是确定的情况下，最重要的是分隔符是确定的。否则，麻烦就来了。”我说，“大约有 12 种英文特殊符号，如果直接拿这些特殊符号替换上面代码中的分隔符（中文逗号），这段程序在运行的时候就会出现以下提到的错误。”</p>
<ul>
<li>反斜杠 \ （ArrayIndexOutOfBoundsException）</li>
<li>插入符号 ^ （同上）</li>
<li>美元符号 $ （同上）</li>
<li>逗点 . （同上）</li>
<li>竖线 | （正常，没有出错）</li>
<li>问号 ? （PatternSyntaxException）</li>
<li>星号 * （同上）</li>
<li>加号 + （同上）</li>
<li>左小括号或者右小括号 () （同上）</li>
<li>左方括号或者右方括号 [] （同上）</li>
<li>左大括号或者右大括号 {} （同上）</li>
</ul>
<p>“那遇到这些特殊符号该怎么办呢？”三妹问。</p>
<p>“用正则表达式。”我说，“正则表达式是一组由字母和符号组成的特殊文本，它可以用来从文本中找出满足你想要的格式的句子。”</p>
<p>我在 GitHub 上找打了一个开源的正则表达式学习文档，非常详细。一开始写正则表达式的时候难免会感觉到非常生疏，你可以查看一下这份文档。记不住没关系，遇到就查。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/cdoco/learn-regex-zh">https://github.com/cdoco/learn-regex-zh</a></p>
</blockquote>
<p>除了这份文档，还有一份：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/cdoco/common-regex">https://github.com/cdoco/common-regex</a></p>
</blockquote>
<p>作者收集了一些在平时项目开发中经常用到的正则表达式，可以直接拿来用。</p>
<p>“哥，你真周到。”三妹笑着说。</p>
<p>“好了，来用英文逗点 . 替换一下分隔符。”我说。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String cmower = &quot;沉默王二.一枚有趣的程序员&quot;;</span><br><span class="line">if (cmower.contains(&quot;.&quot;)) &#123;</span><br><span class="line">    String [] parts = cmower.split(&quot;\\.&quot;);</span><br><span class="line">    System.out.println(&quot;第一部分：&quot; + parts[0] +&quot; 第二部分：&quot; + parts[1]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于英文逗点属于特殊符号，所以在使用 split() 方法的时候，就需要使用正则表达式 \. 而不能直接使用 . 。</p>
<p>“为什么用两个反斜杠呢？”三妹问。</p>
<p>“因为反斜杠本身就是一个特殊字符，需要用反斜杠来转义。”我说。</p>
<p>当然了，你也可以使用 [] 来包裹住英文逗点“.”， [] 也是一个正则表达式，用来匹配方括号中包含的任意字符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmower.split(&quot;[.]&quot;);</span><br></pre></td></tr></table></figure>
<p>除此之外， 还可以使用 Pattern 类的 quote() 方法来包裹英文逗点“.”，该方法会返回一个使用 \Q\E 包裹的字符串。</p>
<p><img src="\assets\note\image-20230927113429819.png" alt="image-20230927113429819"></p>
<p>来看示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String [] parts = cmower.split(Pattern.quote(&quot;.&quot;));</span><br></pre></td></tr></table></figure>
<p>当 split() 方法的参数是正则表达式的时候，方法最终会执行下面这行代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return Pattern.compile(regex).split(this, limit);</span><br></pre></td></tr></table></figure>
<p>也就意味着，拆分字符串有了新的选择，可以不使用 String 类的 split() 方法，直接用下面的方式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class TestPatternSplit &#123;</span><br><span class="line">    private static Pattern twopart = Pattern.compile(&quot;\\.&quot;);</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String [] parts = twopart.split(&quot;沉默王二.一枚有趣的程序员&quot;);</span><br><span class="line">        System.out.println(&quot;第一部分：&quot; + parts[0] +&quot; 第二部分：&quot; + parts[1]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“为什么要把 Pattern 表达式声明称 static 的呢？”三妹问。</p>
<p>“由于模式是确定的，通过 static 的预编译功能可以提高程序的效率。”我说，“除此之外，还可以使用 Pattern 配合 Matcher 类进行字符串拆分，这样做的好处是可以对要拆分的字符串进行一些严格的限制，来看这段示例代码。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class TestPatternMatch &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 使用预编译功能，提高效率</span><br><span class="line">     */</span><br><span class="line">    private static Pattern twopart = Pattern.compile(&quot;(.+)\\.(.+)&quot;);</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        checkString(&quot;沉默王二.一枚有趣的程序员&quot;);</span><br><span class="line">        checkString(&quot;沉默王二.&quot;);</span><br><span class="line">        checkString(&quot;.一枚有趣的程序员&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    private static void checkString(String str) &#123;</span><br><span class="line">        Matcher m = twopart.matcher(str);</span><br><span class="line">        if (m.matches()) &#123;</span><br><span class="line">            System.out.println(&quot;第一部分：&quot; + m.group(1) + &quot; 第二部分：&quot; + m.group(2));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;不匹配&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正则表达式 (.+)\.(.+) 的意思是，不仅要把字符串按照英文标点的方式拆成两部分，并且英文逗点的前后要有内容。</p>
<p>来看一下程序的输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一部分：沉默王二 第二部分：一枚有趣的程序员</span><br><span class="line">不匹配</span><br><span class="line">不匹配</span><br></pre></td></tr></table></figure>
<p>不过，使用 Matcher 来匹配一些简单的字符串时相对比较沉重一些，使用 String 类的 split() 仍然是首选，因为该方法还有其他一些牛逼的功能。比如说，如果你想把分隔符包裹在拆分后的字符串的第一部分，可以这样做：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String cmower = &quot;沉默王二，一枚有趣的程序员&quot;;</span><br><span class="line">if (cmower.contains(&quot;，&quot;)) &#123;</span><br><span class="line">    String [] parts = cmower.split(&quot;(?&lt;=，)&quot;);</span><br><span class="line">    System.out.println(&quot;第一部分：&quot; + parts[0] +&quot; 第二部分：&quot; + parts[1]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出的结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第一部分：沉默王二， 第二部分：一枚有趣的程序员</span><br></pre></td></tr></table></figure>
<p>可以看到分隔符“，”包裹在了第一部分，如果希望包裹在第二部分，可以这样做：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String [] parts = cmower.split(&quot;(?=，)&quot;);</span><br></pre></td></tr></table></figure>
<p>“ ?&lt;= 和 ?= 是什么东东啊？”三妹好奇地问。</p>
<p>“它其实是正则表达式中的断言模式。”我说，“你有时间的话，可以看看前面我推荐的两份开源文档。”</p>
<p><img src="\assets\note\image-20230927114020912.png" alt="image-20230927114020912"></p>
<p>“ split() 方法可以传递 2 个参数，第一个为分隔符，第二个为拆分的字符串个数。”我说。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String cmower = &quot;沉默王二，一枚有趣的程序员，宠爱他&quot;;</span><br><span class="line">if (cmower.contains(&quot;，&quot;)) &#123;</span><br><span class="line">    String [] parts = cmower.split(&quot;，&quot;, 2);</span><br><span class="line">    System.out.println(&quot;第一部分：&quot; + parts[0] +&quot; 第二部分：&quot; + parts[1]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进入 debug 模式的话，可以看到以下内容：</p>
<p><img src="\assets\note\image-20230927114123803.png" alt="image-20230927114123803"></p>
<p>也就是说，传递 2 个参数的时候，会直接调用 substring() 进行截取，第二个分隔符后的就不再拆分了。</p>
<p>来看一下程序输出的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第一部分：沉默王二 第二部分：一枚有趣的程序员，宠爱他</span><br></pre></td></tr></table></figure>
<p>“没想到啊，这个字符串拆分还挺讲究的呀！”三妹感慨地说。</p>
<p>“是的，其实字符串拆分在实际的工作当中还是挺经常用的。前端经常会按照规则传递一长串字符序列到后端，后端就需要按照规则把字符串拆分再做处理。”我说。</p>
<h1 id="3-面向对象编程"><a href="#3-面向对象编程" class="headerlink" title="3 面向对象编程"></a>3 面向对象编程</h1><h2 id="3-1-Java中的类和对象"><a href="#3-1-Java中的类和对象" class="headerlink" title="3.1 Java中的类和对象"></a>3.1 Java中的类和对象</h2><p>“二哥，那天我在图书馆复习《Java进阶之路》的时候，刚好碰见一个学长，他问我有没有‘对象’，我说还没有啊。结果你猜他说什么，‘要不要我给你 new 一个啊？’我当时就懵了，new 是啥意思啊，二哥？”三妹满是疑惑的问我。</p>
<p>“哈哈，三妹，你学长还挺幽默啊。new 是 Java 中的一个关键字，用来把类变成对象。”我笑着对三妹说，“对象和类是 Java 中最基本的两个概念，可以说撑起了面向对象编程（OOP）的一片天。”</p>
<p><strong>01、面向过程和面向对象</strong></p>
<p>三妹是不是要问，什么是 OOP？</p>
<p>OOP 的英文全称是 Object Oriented Programming，要理解它的话，就要先理解面向对象，要想理解面向对象的话，就要先理解面向过程，因为一开始没有面向对象的编程语言，都是面向过程。</p>
<p>举个简单点的例子来区分一下面向过程和面向对象</p>
<p>有一天，你想吃小碗汤了，怎么办呢？有两个选择：</p>
<p>1）自己买食材，豆腐皮啊、肉啊、蒜苔啊等等，自己动手做。</p>
<p>2）到饭店去，只需要对老板喊一声，“来份小碗汤。”</p>
<p>第一种就是面向过程，第二种就是面向对象。</p>
<p>面向过程有什么劣势呢？假如你买了小碗汤的食材，临了又想吃宫保鸡丁了，你是不是还得重新买食材？</p>
<p>面向对象有什么优势呢？假如你不想吃小碗汤了，你只需要对老板说，“我那个小碗汤如果没做的话，换成宫保鸡丁吧！”</p>
<p>面向过程是流程化的，一步一步，上一步做完了，再做下一步。</p>
<p>面向对象是模块化的，我做我的，你做你的，我需要你做的话，我就告诉你一声。我不需要知道你到底怎么做，只看功劳不看苦劳。</p>
<p>不过，如果追到底的话，面向对象的底层其实还是面向过程，只不过把面向过程进行了抽象化，封装成了类，方便我们的调用。</p>
<p><strong>02、类</strong></p>
<p>对象可以是现实中看得见的任何物体，比如说，一只特立独行的猪；也可以是想象中的任何虚拟物体，比如说能七十二变的孙悟空。</p>
<p>Java 通过类（class）来定义这些物体，这些物体有什么状态，通过字段来定义，比如说比如说猪的颜色是纯色还是花色；这些物体有什么行为，通过方法来定义，比如说猪会吃，会睡觉。</p>
<p>来，定义一个简单的类给你看看。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 微信搜索「二哈进阶之路」</span><br><span class="line"> */</span><br><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private int sex;</span><br><span class="line">    private void eat() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    private void sleep() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    private void dadoudou() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个类可以包含：</p>
<ul>
<li>字段（Filed）</li>
<li>方法（Method）</li>
<li>构造方法（Constructor）</li>
</ul>
<p>在 Person 类中，字段有 3 个，分别是 name、age 和 sex，它们也称为成员变量——在类内部但在方法外部，方法内部的叫临时变量。</p>
<p>成员变量有时候也叫做实例变量，在编译时不占用内存空间，在运行时获取内存，也就是说，只有在对象实例化（ new Person() ）后，字段才会获取到内存，这也正是它被称作“实例”变量的原因。</p>
<p>方法有 3 个，分别是 eat() 、 sleep() 和 dadoudou() ，表示 Person 这个对象可以做什么，也就是吃饭睡觉打豆豆。</p>
<p>那三妹是不是要问，“怎么没有构造方法呢？”</p>
<p>的确在 Person 类的源码文件（.java）中没看到，但在反编译后的字节码文件（.class）中是可以看得到的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">// Source code recreated from a .class file by IntelliJ IDEA</span><br><span class="line">// (powered by Fernflower decompiler)</span><br><span class="line">//</span><br><span class="line">package com.itwanger.twentythree;</span><br><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private int sex;</span><br><span class="line">    public Person() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    private void eat() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    private void sleep() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    private void dadoudou() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>public Person(){} 就是默认的构造方法，因为是空的构造方法（方法体中没有内容），所以可以缺省。</p>
<p>Java 聪明就聪明在这，有些很死板的代码不需要开发人员添加，它会偷偷地做了。</p>
<p><strong>03、new 一个对象</strong></p>
<p>创建 Java 对象时，需要用到 new 关键字。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person person = new Person();</span><br></pre></td></tr></table></figure>
<p>这行代码就通过 Person 类创建了一个 Person 对象。所有对象在创建的时候都会在堆内存中分配空间。</p>
<p>创建对象的时候，需要一个 main() 方法作为入口， main() 方法可以在当前类中，也可以在另外一个类中。</p>
<p>第一种： main() 方法直接放在 Person 类中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private int sex;</span><br><span class="line">    private void eat() &#123;&#125;</span><br><span class="line">    private void sleep() &#123;&#125;</span><br><span class="line">    private void dadoudou() &#123;&#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person person = new Person();</span><br><span class="line">        System.out.println(person.name);</span><br><span class="line">        System.out.println(person.age);</span><br><span class="line">        System.out.println(person.sex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">null</span><br><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>第二种： main() 方法不在 Person 类中，而在另外一个类中。</p>
<p><img src="\assets\note\image-20230927211518119.png" alt="image-20230927211518119"></p>
<p>实际开发中，我们通常不在当前类中直接创建对象并使用它，而是放在使用对象的类中，比如说上图中的PersonTest 类。</p>
<p>可以把 PersonTest 类和 Person 类放在两个文件中，也可以放在一个文件（命名为 PersonTest.java）中，就像下面这样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author 微信搜「二哈进阶之路」</span><br><span class="line"> */</span><br><span class="line">public class PersonTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person person = new Person();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private int sex;</span><br><span class="line">    private void eat() &#123;&#125;</span><br><span class="line">    private void sleep() &#123;&#125;</span><br><span class="line">    private void dadoudou() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>04、初始化对象</strong></p>
<p>在之前的例子中，程序输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">null</span><br><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>为什么会有这样的输出结果呢？因为 Person 对象没有初始化，因此输出了 String 的默认值 null，int 的默认值 0。</p>
<p>那怎么初始化 Person 对象（对字段赋值）呢？</p>
<p><strong>第一种：通过对象的引用变量。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private int sex;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person person = new Person();</span><br><span class="line">        person.name = &quot;沉默王二&quot;;</span><br><span class="line">        person.age = 18;</span><br><span class="line">        person.sex = 1;</span><br><span class="line">        </span><br><span class="line">        System.out.println(person.name);</span><br><span class="line">        System.out.println(person.age);</span><br><span class="line">        System.out.println(person.sex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>person 被称为对象 Person 的引用变量，见下图：</p>
<p><img src="\assets\note\image-20230927211924036.png" alt="image-20230927211924036"></p>
<p>通过对象的引用变量，可以直接对字段进行初始化（ person.name = “沉默” ），所以以上代码输出结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">沉默</span><br><span class="line">18</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p><strong>第二种：通过方法初始化。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private int sex;</span><br><span class="line">    public void initialize(String n, int a, int s) &#123;</span><br><span class="line">        name = n;</span><br><span class="line">        age = a;</span><br><span class="line">        sex = s;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person person = new Person();</span><br><span class="line">        person.initialize(&quot;沉默王二&quot;,18,1);</span><br><span class="line">        System.out.println(person.name);</span><br><span class="line">        System.out.println(person.age);</span><br><span class="line">        System.out.println(person.sex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Person 类中新增方法 initialize() ，然后在新建对象后传参进行初始化（ person.initialize(“沉默”, 18, 1) ）。</p>
<p><strong>第三种：通过构造方法初始化。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private int sex;</span><br><span class="line">    public Person(String name, int age, int sex) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person person = new Person(&quot;沉默王二&quot;, 18, 1);</span><br><span class="line">        System.out.println(person.name);</span><br><span class="line">        System.out.println(person.age);</span><br><span class="line">        System.out.println(person.sex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这也是最标准的一种做法，直接在 new 的时候把参数传递过去。</p>
<p>补充一点知识，匿名对象。匿名对象意味着没有引用变量，它只能在创建的时候被使用一次。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Person();</span><br></pre></td></tr></table></figure>
<p>可以直接通过匿名对象调用方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Person().initialize(&quot;沉默王二&quot;, 18, 1);</span><br></pre></td></tr></table></figure>
<p><strong>05、关于对象</strong></p>
<p><strong>1）抽象的历程</strong></p>
<p>所有编程语言都是一种抽象，甚至可以说，我们能够解决的问题的复杂程度取决于抽象的类型和质量。</p>
<p>Smalltalk 是历史上第一门获得成功的面向对象语言，也为 Java 提供了灵感。它有 5 个基本特征：</p>
<ul>
<li>万物皆对象。</li>
<li>一段程序实际上就是多个对象通过发送消息的方式来告诉彼此该做什么。</li>
<li>通过组合的方式，可以将多个对象封装成其他更为基础的对象。</li>
<li>对象是通过类实例化的。</li>
<li>同一类型的对象可以接收相同的消息。</li>
</ul>
<p>总结一句话就是：</p>
<blockquote>
<p>状态+行为+标识=对象，每个对象在内存中都会有一个唯一的地址。</p>
</blockquote>
<p><strong>2）对象具有接口</strong></p>
<p>所有的对象，都可以被归为一类，并且同一类对象拥有一些共同的行为和特征。在 Java 中，class 关键字用来定义一个类型。</p>
<p>创建抽象数据类型是面向对象编程的一个基本概念。你可以创建某种类型的变量，Java 中称之为对象或者实例，然后你就可以操作这些变量，Java 中称之为发送消息或者发送请求，最后对象决定自己该怎么做。</p>
<p>类描述了一系列具有相同特征和行为的对象，从宽泛的概念上来说，类其实就是一种自定义的数据类型。</p>
<p>一旦创建了一个类，就可以用它创建任意多个对象。面向对象编程语言遇到的最大一个挑战就是，如何把现实/虚拟的元素抽象为 Java 中的对象。</p>
<p>对象能够接收什么样的请求是由它的接口定义的。具体是怎么做到的，就由它的实现方法来实现。</p>
<p><strong>3）访问权限修饰符</strong></p>
<p>类的创建者有时候也被称为 API 提供者，对应的，类的使用者就被称为 API 调用者。</p>
<p>JDK 就给我们提供了 Java 的基础实现，JDK 的作者也就是基础 API 的提供者（Java 多线程部分的作者 Doug Lea 是被 Java 程序员敬佩的一个大佬），我们这些 Java 语言的使用者，说白了就是 JDK 的调用者。</p>
<p><img src="\assets\note\image-20230927213040360.png" alt="image-20230927213040360"></p>
<p>当然了，假如我们也提供了新的类给其他调用者，我们也就成为了新的创建者。</p>
<p>API 创建者在创建新的类的时候，只暴露必要的接口，而隐藏其他所有不必要的信息，之所以要这么做，是因为如果这些信息对调用者是不可见的，那么创建者就可以随意修改隐藏的信息，而不用担心对调用者的影响。</p>
<p>这里就必须要讲到 Java 的权限修饰符。</p>
<p>访问权限修饰符的第一个作用是，防止类的调用者接触到他们不该接触的内部实现；第二个作用是，让类的创建者可以轻松修改内部机制而不用担心影响到调用者的使用。</p>
<ul>
<li>public</li>
<li>private</li>
<li>protected</li>
</ul>
<p>还有一种“默认”的权限修饰符，是缺省的，它修饰的类可以访问同一个包下面的其他类。</p>
<p><strong>4）组合</strong></p>
<p>我们可以把一个创建好的类作为另外一个类的成员变量来使用，利用已有的类组成成一个新的类，被称为“复用”，组合代表的关系是 has-a 的关系。</p>
<p><strong>5）继承</strong></p>
<p>继承是 Java 中非常重要的一个概念，子类继承父类，也就拥有了父类中 protected 和 public 修饰的方法和字段，同时，子类还可以扩展一些自己的方法和字段，也可以重写继承过来方法。</p>
<p>常见的例子，就是形状可以有子类圆形、方形、三角形，它们的基础接口是相同的，比如说都有一个draw() 的方法，子类可以继承这个方法实现自己的绘制方法。</p>
<p>如果子类只是重写了父类的方法，那么它们之间的关系就是 is-a 的关系，但如果子类增加了新的方法，那么它们之间的关系就变成了 is-like-a 的关系。</p>
<p>6）多态</p>
<p>比如说有一个父类Shape</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Shape &#123;</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        System.out.println(&quot;形状&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类Circle</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Circle extends Shape&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        System.out.println(&quot;圆形&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类Line</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Line extends Shape &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        System.out.println(&quot;线&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Shape shape1 = new Line();</span><br><span class="line">        shape1.draw();</span><br><span class="line">        Shape shape2 = new Circle();</span><br><span class="line">        shape2.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">线</span><br><span class="line">圆形</span><br></pre></td></tr></table></figure>
<p>在测试类中，shape1 的类型为 Shape，shape2 的类型也为 Shape，但调用 draw() 方法后，却能自动调用子类 Line 和 Circle 的 draw() 方法，这是为什么呢？</p>
<p>其实就是 Java 中的多态。</p>
<p><strong>06、小结</strong></p>
<p>“怎么样，三妹，是不是对 Java 有了更深入更清晰的理解？”终于讲完了，我深呼了一口气，好舒畅啊！</p>
<p>“是的，哥，感觉 Java 也就那么回事嘛。”哎呀，三妹有点狂了起来，“万物皆对象，除了基本数据类型。”</p>
<p>“哇，三妹，你可以啊，都会自己梳理总结了。”我倍感欣慰，觉得果然是劳有所获，你讲的认真，听众就能理解和 get，满足了。</p>
<h2 id="3-2-Java中的包"><a href="#3-2-Java中的包" class="headerlink" title="3.2 Java中的包"></a>3.2 Java中的包</h2><p>“三妹，这一节，我们简单过一下 Java 中的包，也就是 package，这个一点就透，很好掌握。”我放下手中的雪碧，翻开笔记本，点开《Java 进阶之路》，找到这篇「Java 中的包」，开始滔滔不绝起来。</p>
<p>“二哥，你等一下。”让我打开思维导图做一下笔记 。</p>
<p><strong>关于包</strong></p>
<p>在前面的代码中，我们把类和接口命名为 Person 、 Student 、 Hello 等简单的名字。</p>
<p>在团队开发中，如果小明写了一个 Person 类，小红也写了一个 Person 类，现在，小白既想用小明的Person ，也想用小红的 Person ，怎么办？</p>
<p>如果小军写了一个 Arrays 类，恰好 JDK 也自带了一个 Arrays 类，如何解决类名冲突？</p>
<p>在 Java 中，我们使用 package 来解决名字冲突。</p>
<p>Java 定义了一种名字空间，称之为包： package 。一个类总是属于某个包，类名（比如 Person ）只是一个简写，真正的完整类名是 包名.类名 。</p>
<p>例如：</p>
<p>小明的 Person 类存放在包 ming 下面，因此，完整类名是 ming.Person ；</p>
<p>小红的 Person 类存放在包 hong 下面，因此，完整类名是 hong.Person ；</p>
<p>小军的 Arrays 类存放在包 mr.jun 下面，因此，完整类名是 mr.jun.Arrays ；</p>
<p>JDK 的 Arrays 类存放在包 java.util 下面，因此，完整类名是 java.util.Arrays 。</p>
<p>在定义 class 的时候，我们需要在第一行声明这个 class 属于哪个包。</p>
<p>小明的 Person.java 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">package ming; // 申明包名ming</span><br><span class="line">public class Person &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>小军的 Arrays.java 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">package mr.jun; // 申明包名mr.jun</span><br><span class="line">public class Arrays &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Java 虚拟机执行的时候，JVM 只看完整类名，因此，只要包名不同，类就不同。</p>
<p>包可以是多层结构，用 . 隔开。例如： java.util 。</p>
<blockquote>
<p>要特别注意：包没有父子关系。java.util和java.util.zip是不同的包，两者没有任何继承关系。</p>
</blockquote>
<p>没有定义包名的 class ，它使用的是默认包，非常容易引起名字冲突，因此，不推荐不写包名的做法。</p>
<p>我们还需要按照包结构把上面的 Java 文件组织起来。假设以 package_sample 作为根目录， src 作为源码目录，那么所有文件结构就是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package_sample</span><br><span class="line">└─ src</span><br><span class="line">    ├─ hong</span><br><span class="line">    │  └─ Person.java</span><br><span class="line">    │  ming</span><br><span class="line">    │  └─ Person.java</span><br><span class="line">    └─ mr</span><br><span class="line">       └─ jun</span><br><span class="line">          └─ Arrays.java</span><br></pre></td></tr></table></figure>
<p>即所有 Java 文件对应的目录层次要和包的层次一致。</p>
<p>编译后的 .class 文件也需要按照包结构存放。如果使用 IDE，把编译后的 .class 文件放到 bin 目录下，那么，编译的文件结构就是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package_sample</span><br><span class="line">└─ bin</span><br><span class="line">   ├─ hong</span><br><span class="line">   │  └─ Person.class</span><br><span class="line">   │  ming</span><br><span class="line">   │  └─ Person.class</span><br><span class="line">   └─ mr</span><br><span class="line">      └─ jun</span><br><span class="line">         └─ Arrays.class</span><br></pre></td></tr></table></figure>
<p>编译的命令相对比较复杂，我们需要在 src 目录下执行 javac 命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -d ../bin ming/Person.java hong/Person.java mr/jun/Arrays.java</span><br></pre></td></tr></table></figure>
<p>在 IDE 中，会自动根据包结构编译所有 Java 源码，所以不必担心使用命令行编译的复杂命令。</p>
<p><strong>包的作用域</strong></p>
<p>位于同一个包的类，可以访问包作用域的字段和方法。</p>
<p>不用 public 、 protected 、 private 修饰的字段和方法就是包作用域。例如， Person 类定义在 hello 包</p>
<p>下面：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package hello;</span><br><span class="line">public class Person &#123;</span><br><span class="line">    // 包作用域:</span><br><span class="line">    void hello() &#123;</span><br><span class="line">        System.out.println(&quot;Hello!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Main 类也定义在 hello 包下面，就可以直接访问 Person 类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package hello;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person p = new Person();</span><br><span class="line">        p.hello(); // 可以调用，因为Main和Person在同一个包</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>导入包</strong></p>
<p>在一个 class 中，我们总会引用其他的 class 。例如，小明的 ming.Person 类，如果要引用小军的mr.jun.Arrays 类，他有三种写法：</p>
<p>第一种，直接写出完整类名，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Person.java</span><br><span class="line">package ming;</span><br><span class="line">public class Person &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        mr.jun.Arrays arrays = new mr.jun.Arrays();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很显然，每次都要写完整的类名比较痛苦。</p>
<p>因此，第二种写法是用 import 语句，导入小军的 Arrays ，然后写简单类名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/ Person.java</span><br><span class="line">package ming;</span><br><span class="line">// 导入完整类名:</span><br><span class="line">import mr.jun.Arrays;</span><br><span class="line">public class Person &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        Arrays arrays = new Arrays();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在写 import 的时候，可以使用 * ，表示把这个包下面的所有 class 都导入进来（但不包括子包的class ）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Person.java</span><br><span class="line">package ming;</span><br><span class="line">// 导入mr.jun包的所有class:</span><br><span class="line">import mr.jun.*;</span><br><span class="line">public class Person &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        Arrays arrays = new Arrays();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们一般不推荐这种写法，因为在导入了多个包后，很难看出 Arrays 类属于哪个包。</p>
<p>还有一种 import static 的语法，它可以导入一个类的静态字段和静态方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package main;</span><br><span class="line">// 导入System类的所有静态字段和静态方法:</span><br><span class="line">import static java.lang.System.*;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 相当于调用System.out.println(…)</span><br><span class="line">        out.println(&quot;Hello, world!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>import static 很少使用。</p>
<p>Java 编译器最终编译出的 .class 文件只使用 完整类名，因此，在代码中，当编译器遇到一个 class 名称时：</p>
<ul>
<li>如果是完整类名，就直接根据完整类名查找这个 class ；</li>
<li><p>如果是简单类名，按下面的顺序依次查找：</p>
<ul>
<li><p>查找当前 package 是否存在这个 class ；</p>
</li>
<li><p>查找 import 的包是否包含这个 class ；</p>
</li>
<li><p>查找 java.lang 包是否包含这个 class 。</p>
</li>
</ul>
</li>
</ul>
<p>如果按照上面的规则还无法确定类名，则编译报错。</p>
<p>我们来看一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// Main.java</span><br><span class="line">package test;</span><br><span class="line">import java.text.Format;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        java.util.List list; // ok，使用完整类名 -&gt; java.util.List</span><br><span class="line">        Format format = null; // ok，使用import的类 -&gt; java.text.Format</span><br><span class="line">        String s = &quot;hi&quot;; // ok，使用java.lang包的String -&gt; java.lang.String</span><br><span class="line">        System.out.println(s); // ok，使用java.lang包的System -&gt; java.lang.System</span><br><span class="line">        MessageFormat mf = null; // 编译错误：无法找到MessageFormat: MessageFormat </span><br><span class="line">cannot be resolved to a type</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，编写 class 的时候，编译器会自动帮我们做两个 import 动作：</p>
<ul>
<li>默认自动 import 当前 package 的其他 class ；</li>
<li>默认自动 import java.lang.* 。</li>
</ul>
<blockquote>
<p>注意：自动导入的是java.lang包，但类似java.lang.reflect这些包仍需要手动导入。</p>
</blockquote>
<p>如果有两个 class 名称相同，例如， mr.jun.Arrays 和 java.util.Arrays ，那么只能 import 其中一个，另一个必须写完整类名。</p>
<p><strong>包的最佳实践</strong></p>
<p>为了避免名字冲突，我们需要确定唯一的包名。推荐的做法是使用倒置的域名来确保唯一性。例如：</p>
<ul>
<li>org.apache</li>
<li>org.apache.commons.log</li>
<li>com.tobebetterjavaer.sample</li>
</ul>
<p>子包就可以根据功能自行命名。</p>
<p>要注意不要和 java.lang 包的类重名，即自己的类不要使用这些名字：</p>
<ul>
<li>String</li>
<li>System</li>
<li>Runtime</li>
<li>…</li>
</ul>
<p>要注意也不要和 JDK 常用类重名：</p>
<ul>
<li>java.util.List</li>
<li>java.text.Format</li>
<li>java.math.BigInteger</li>
<li>…</li>
</ul>
<p><strong>小结</strong></p>
<p>Java 内建的 package 机制是为了避免 class 命名冲突；</p>
<p>JDK 的核心类使用 java.lang 包，编译器会自动导入；</p>
<p>JDK 的其它常用类定义在 java.util.<em> ， java.math.</em> ， java.text.* ，……；</p>
<p>包名推荐使用倒置的域名，例如 org.apache 。</p>
<h2 id="3-3-Java中的变量"><a href="#3-3-Java中的变量" class="headerlink" title="3.3 Java中的变量"></a>3.3 Java中的变量</h2><p>“二哥，听说 Java 变量在以后的日子里经常用，能不能提前给我透露透露？”三妹咪了一口麦香可可奶茶后对我说。</p>
<p>“三妹啊，搬个凳子坐我旁边，听二哥来给你慢慢说啊。”</p>
<p>Java 变量就好像一个容器，可以保存程序在运行过程中的值，它在声明的时候会定义对应的数据类型（Java分为两种数据类型：基本数据类型和引用数据类型）。变量按照作用域的范围又可分为三种类型：局部变量，成员变量和静态变量。</p>
<p>比如说， int data = 88; ，其中 data 就是一个变量，它的值为 88，类型为整型（int）。</p>
<p><strong>01、局部变量</strong></p>
<ul>
<li>在方法体内声明的变量被称为局部变量，该变量只能在该方法内使用，类中的其他方法并不知道该变量。来看下面这个示例：</li>
<li>其中 a、b、c 就是局部变量，它们只能在当前这个 main 方法中使用。</li>
<li>声明局部变量时的注意事项：</li>
<li>局部变量声明在方法、构造方法或者语句块中。</li>
<li>局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，将会被销毁。</li>
<li>访问修饰符不能用于局部变量。</li>
<li>局部变量只在声明它的方法、构造方法或者语句块中可见。</li>
<li>局部变量是在栈上分配的。</li>
<li>局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。</li>
</ul>
<p><strong>02、成员变量</strong></p>
<p>在类内部但在方法体外声明的变量称为成员变量，或者实例变量，或者字段。之所以称为实例变量，是因为该变量只能通过类的实例（对象）来访问。来看下面这个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class InstanceVariable &#123;</span><br><span class="line">    int data = 88;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        InstanceVariable iv = new InstanceVariable();</span><br><span class="line">        System.out.println(iv.data); // 88</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 iv 是一个变量，它是一个引用类型的变量。 new 关键字可以创建一个类的实例（也称为对象），通过“=”操作符赋值给 iv 这个变量，iv 就成了这个对象的引用，通过 iv.data 就可以访问成员变量了。</p>
<ul>
<li>声明成员变量时的注意事项：</li>
<li>成员变量声明在一个类中，但在方法、构造方法和语句块之外。</li>
<li>当一个对象被实例化之后，每个成员变量的值就跟着确定。</li>
<li>成员变量在对象创建的时候创建，在对象被销毁的时候销毁。</li>
<li>成员变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息。</li>
<li>成员变量可以声明在使用前或者使用后。</li>
<li>访问修饰符可以修饰成员变量。</li>
<li>成员变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把成员变量设为私有。通过使用访问修饰符可以使成员变量对子类可见；成员变量具有默认值。数值型变量的默认值是 0，布尔型变量的默认值是 false，引用类型变量的默认值是 null。变量的值可以在声明时指定，也可以在构造方法中指定。</li>
</ul>
<p><strong>03、静态变量</strong></p>
<p>通过 static 关键字声明的变量被称为静态变量（类变量），它可以直接被类访问，来看下面这个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class StaticVariable &#123;</span><br><span class="line">    static int data = 99;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(StaticVariable.data); // 99</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 data 就是静态变量，通过 类名.静态变量 就可以访问了，不需要创建类的实例。</p>
<p>声明静态变量时的注意事项：</p>
<ul>
<li>静态变量在类中以 static 关键字声明，但必须在方法构造方法和语句块之外。</li>
<li>无论一个类创建了多少个对象，类只拥有静态变量的一份拷贝。</li>
<li>静态变量除了被声明为常量外很少使用。</li>
<li>静态变量储存在静态存储区。</li>
<li>静态变量在程序开始时创建，在程序结束时销毁。</li>
<li>与成员变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为 public 类型。</li>
<li>静态变量的默认值和实例变量相似。</li>
<li>静态变量还可以在静态语句块中初始化。</li>
</ul>
<p><strong>04、常量</strong></p>
<p>在 Java 中，有些数据的值是不会发生改变的，这些数据被叫做常量——使用 final 关键字修饰的成员变量。</p>
<p>常量的值一旦给定就无法改变！</p>
<p>常量在程序运行过程中主要有 2 个作用：</p>
<ul>
<li>代表常数，便于修改（例如：圆周率的值， final double PI = 3.14 ）</li>
<li>增强程序的可读性（例如：常量 UP、DOWN 用来代表上和下， final int UP = 0 ）</li>
</ul>
<p>Java 要求常量名必须大写。来看下面这个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class FinalVariable &#123;</span><br><span class="line">    final String CHEN = &quot;沉&quot;;</span><br><span class="line">    static final String MO = &quot;默&quot;;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        FinalVariable fv = new FinalVariable();</span><br><span class="line">        System.out.println(fv.CHEN);</span><br><span class="line">        System.out.println(MO);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“好了，三妹，关于 Java 变量就先说这么多吧，你是不是已经清楚了？”转动了一下僵硬的脖子后，我对三妹说。</p>
<p>“是啊，二哥，我想以后还会再见到它们吧？”</p>
<p>“那见的次数可就多了，就好像你每天眨眼的次数一样多。”</p>
<h2 id="3-4-Java中的方法"><a href="#3-4-Java中的方法" class="headerlink" title="3.4 Java中的方法"></a>3.4 Java中的方法</h2><p>“二哥，这一节我们学什么呢？”三妹满是期待的问我。</p>
<p>“这一节我们来了解一下 Java 中的方法——什么是方法？如何声明方法？方法有哪几种？什么是实例方法？</p>
<p>什么是静态方法？什么是抽象方法？什么是本地方法？”我笑着对三妹说，“我开始了啊，你要注意力集中啊。”</p>
<p><strong>01、Java中的方法是什么？</strong></p>
<p>方法用来实现代码的可重用性，我们编写一次方法，并多次使用它。通过增加或者删除方法中的一部分代码，就可以提高整体代码的可读性。</p>
<p>只有方法被调用时，它才会执行。Java 中最有名的方法当属 main() 方法，这是程序的入口。</p>
<p><strong>02、如何声明方法？</strong></p>
<p>方法的声明反映了方法的一些信息，比如说可见性、返回类型、方法名和参数。如下图所示。</p>
<p><img src="\assets\note\image-20230927220335052.png" alt="image-20230927220335052"></p>
<p><strong>访问权限</strong>：它指定了方法的可见性。Java 提供了四种访问权限修饰符：</p>
<ul>
<li>public：该方法可以被所有类访问。</li>
<li>private：该方法只能在定义它的类中访问。</li>
<li>protected：该方法可以被同一个包中的类，或者不同包中的子类访问。</li>
<li>default：如果一个方法没有使用任何访问权限修饰符，那么它是 package-private 的，意味着该方法只能被同一个包中的类可见。</li>
</ul>
<p><strong>返回类型</strong>：方法返回的数据类型，可以是基本数据类型、对象和集合，如果不需要返回数据，则使用 void 关键字。</p>
<p><strong>方法名</strong>：方法名最好反应出方法的功能，比如，我们要创建一个将两个数字相减的方法，那么方法名最好是subtract。</p>
<p>方法名最好是一个动词，并且以小写字母开头。如果方法名包含两个以上单词，那么第一个单词最好是动词，然后是形容词或者名词，并且要以驼峰式的命名方式命名。比如：</p>
<ul>
<li>一个单词的方法名： sum()</li>
<li>多个单词的方法名： stringComparision()</li>
</ul>
<p>一个方法可能与同一个类中的另外一个方法同名，这被称为方法重载。</p>
<p><strong>参数</strong>：参数被放在一个圆括号内，如果有多个参数，可以使用逗号隔开。参数包含两个部分，参数类型和参数名。如果方法没有参数，圆括号是空的。</p>
<p><strong>方法签名</strong>：每一个方法都有一个签名，包括方法名和参数。</p>
<p><strong>方法体</strong>：方法体放在一对花括号内，把一些代码放在一起，用来执行特定的任务。</p>
<p><strong>03、方法有哪几种？</strong></p>
<p>方法可以分为两种，一种叫标准类库方法，一种叫用户自定义方法。</p>
<p><strong>1）预先定义方法</strong></p>
<p>Java 提供了大量预先定义好的方法供我们调用，也称为标准类库方法，或者内置方法。比如说 String 类的length() 、 equals() 、 compare() 方法，以及我们在初学 Java 阶段最常用的 println() 方法，用来在控制台打印信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class PredefinedMethodDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;沉默王二，一枚有趣的程序员&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们使用了两个预先定义的方法， main() 方法是程序运行的入口， println() 方法是PrintStream 类的一个方法。这些方法已经提前定义好了，所以我们可以直接使用它们。</p>
<p>我们可以通过集成开发工具查看预先定义方法的方法签名，当我们把鼠标停留在 println() 方法上面时，就会显示下图中的内容：</p>
<p><img src="\assets\note\image-20230927220656781.png" alt="image-20230927220656781"></p>
<p>println() 方法的访问权限修饰符是 public，返回类型为 void，方法名为 println，参数为 String x ，以及 Javadoc（方法是干嘛的）。</p>
<p>预先定义方法让编程变得简单了起来，我们只需要在实现某些功能的时候直接调用这些方法即可，不需要重新编写。</p>
<p>Java 的一个非常大的优势，就是，JDK 的设计者（开发者）为我们提供了大量的标准类库方法，这对于初学编程的新手来说极其友好；不仅如此，GitHub/码云上也有大量可以直接拿到生产环境下使用的第三方类库，比如说 hutool 啊、Apache 包啊、一线大厂或者顶级开发大佬贡献的类库，比如说 Druid、Gson 等等。</p>
<p>但如果你想从一个初级开发者（俗称调包侠）晋升为一名优秀的 Java 工程师，那就需要深入研究这些源码，并掌握，最好是能自己写出来这些源码，最起码能自定义一些源码，以便为我们所用。</p>
<p><strong>2）用户自定义方法</strong></p>
<p>当预先定义方法无法满足我们的要求时，就需要自定义一些方法，比如说，我们来定义这样一个方法，用来检查数字是偶数还是奇数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void findEvenOdd(int num) &#123;</span><br><span class="line">    if (num % 2 == 0) &#123;</span><br><span class="line">        System.out.println(num + &quot; 是偶数&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        System.out.println(num + &quot; 是奇数&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法名叫做 findEvenOdd ，访问权限修饰符是 public，并且是静态的（static），返回类型是 void，参数有一个整型（int）的 num。方法体中有一个 if else 语句，如果 num 可以被 2 整除，那么就打印这个数字是偶数，否则就打印这个数字是奇数。</p>
<p>方法被定义好后，如何被调用呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class EvenOddDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        findEvenOdd(10);</span><br><span class="line">        findEvenOdd(11);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void findEvenOdd(int num) &#123;</span><br><span class="line">        if (num % 2 == 0) &#123;</span><br><span class="line">            System.out.println(num + &quot; 是偶数&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(num + &quot; 是奇数&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main() 方法是程序的入口，并且是静态的，那么就可以直接调用同样是静态方法的 findEvenOdd() 。</p>
<p>当一个方法被 static 关键字修饰时，它就是一个静态方法。换句话说，静态方法是属于类的，不属于类实例的（不需要通过 new 关键字创建对象来调用，直接通过类名就可以调用）。</p>
<p><strong>04、什么是实例方法？</strong></p>
<p>没有使用 static 关键字修饰，但在类中声明的方法被称为实例方法，在调用实例方法之前，必须创建类的对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class InstanceMethodExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        InstanceMethodExample instanceMethodExample = new InstanceMethodExample();</span><br><span class="line">        System.out.println(instanceMethodExample.add(1, 2));</span><br><span class="line">    &#125;</span><br><span class="line">    public int add(int a, int b) &#123;</span><br><span class="line">        return a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>add() 方法是一个实例方法，需要创建 InstanceMethodExample 对象来访问。</p>
<p>实例方法有两种特殊类型：</p>
<ul>
<li>getter 方法</li>
<li>setter 方法</li>
</ul>
<p>getter 方法用来获取私有变量（private 修饰的字段）的值，setter 方法用来设置私有变量的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private int sex;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getSex() &#123;</span><br><span class="line">        return sex;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setSex(int sex) &#123;</span><br><span class="line">        this.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getter 方法以 get 开头，setter 方法以 set 开头。</p>
<p><strong>05、什么是静态方法？</strong></p>
<p>相应的，有 static 关键字修饰的方法就叫做静态方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class StaticMethodExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(add(1,2));</span><br><span class="line">    &#125;</span><br><span class="line">    public static int add(int a, int b) &#123;</span><br><span class="line">        return a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>StaticMethodExample 类中，mian 和 add 方法都是静态方法，不同的是，main 方法是程序的入口。当我们调用静态方法的时候，就不需要 new 出来类的对象，就可以直接调用静态方法了，一些工具类的方法都是静态方法，比如说 hutool 工具类库，里面有大量的静态方法可以直接调用。</p>
<blockquote>
<p>Hutool 的目标是使用一个工具方法代替一段复杂代码，从而最大限度的避免“复制粘贴”代码的问题，彻底改变我们写代码的方式。</p>
</blockquote>
<p>以计算 MD5 为例：</p>
<ul>
<li>【以前】打开搜索引擎 -&gt; 搜“Java MD5 加密” -&gt; 打开某篇博客-&gt; 复制粘贴 -&gt; 改改好用</li>
<li>【现在】引入 Hutool -&gt; SecureUtil.md5()</li>
</ul>
<p>Hutool 的存在就是为了减少代码搜索成本，避免网络上参差不齐的代码出现导致的 bug。</p>
<p><strong>06、什么是抽象方法？</strong></p>
<p>没有方法体的方法被称为抽象方法，它总是在抽象类中声明。这意味着如果类有抽象方法的话，这个类就必须是抽象的。可以使用 atstract 关键字创建抽象方法和抽象类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abstract class AbstractDemo &#123;</span><br><span class="line">    abstract void display();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当一个类继承了抽象类后，就必须重写抽象方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class MyAbstractDemo extends AbstractDemo &#123;</span><br><span class="line">    @Override</span><br><span class="line">    void display() &#123;</span><br><span class="line">        System.out.println(&quot;重写了抽象方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyAbstractDemo myAbstractDemo = new MyAbstractDemo();</span><br><span class="line">        myAbstractDemo.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">重写了抽象方法</span><br></pre></td></tr></table></figure>
<p>“关于方法，我们就讲到这里吧，学会了类/变量/方法，基本上就可以做一个入门级的 Java 程序员了。”我面露微笑，继续对三妹说，“继续加油吧！”</p>
<p>“好的，谢谢二哥你的细心帮助。”</p>
<h2 id="3-5-Java可变参数"><a href="#3-5-Java可变参数" class="headerlink" title="3.5 Java可变参数"></a>3.5 Java可变参数</h2><p>为了让铁粉们能白票到阿里云的服务器，我当了整整两天的客服，真正体验到了什么叫做“为人民群众谋福利”的不易和辛酸。正在我眼睛红肿打算要休息之际，三妹跑过来问：“Java 的可变参数究竟是怎么一回事？”</p>
<p>我一下子又清醒了，我爱 Java，我爱传道解惑，也享受三妹的赞许（ ）。</p>
<p>可变参数是 Java 1.5 的时候引入的功能，它允许方法使用任意多个、类型相同（ is-a ）的值作为参数。就像下面这样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    print(&quot;沉&quot;);</span><br><span class="line">    print(&quot;沉&quot;, &quot;默&quot;);</span><br><span class="line">    print(&quot;沉&quot;, &quot;默&quot;, &quot;王&quot;);</span><br><span class="line">    print(&quot;沉&quot;, &quot;默&quot;, &quot;王&quot;, &quot;二&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public static void print(String... strs) &#123;</span><br><span class="line">    for (String s : strs)</span><br><span class="line">        System.out.print(s);</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态方法 print() 就使用了可变参数，所以 print(“沉”) 可以， print(“沉”, “默”) 也可以，甚至 3个、 4 个或者更多个字符串都可以作为参数传递给 print() 方法。</p>
<p>说到可变参数，我想起来阿里巴巴开发手册上有这样一条规约。</p>
<p><img src="\assets\note\image-20230927221603351.png" alt="image-20230927221603351"></p>
<p>意思就是尽量不要使用可变参数，如果要用的话，可变参数必须要在参数列表的最后一位。既然坑位有限，只能在最后，那么可变参数就只能有一个（悠着点，悠着点）。如果可变参数不在最后一位，IDE 就会提示对应的错误，如下图所示。</p>
<p><img src="\assets\note\image-20230927221705144.png" alt="image-20230927221705144"></p>
<p>可变参数看起来就像是个语法糖，它背后究竟隐藏了什么呢？让我们来一探究竟，在追求真理这条路上我们要执着。</p>
<p>其实也很简单。<strong>当使用可变参数的时候，实际上是先创建了一个数组，该数组的大小就是可变参数的个数，然后将参数放入数组当中，再将数组传递给被调用的方法。</strong></p>
<p>这就是为什么可以使用数组作为参数来调用带有可变参数的方法的根本原因。代码如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    print(new String[]&#123;&quot;沉&quot;&#125;);</span><br><span class="line">    print(new String[]&#123;&quot;沉&quot;, &quot;默&quot;&#125;);</span><br><span class="line">    print(new String[]&#123;&quot;沉&quot;, &quot;默&quot;, &quot;王&quot;&#125;);</span><br><span class="line">    print(new String[]&#123;&quot;沉&quot;, &quot;默&quot;, &quot;王&quot;, &quot;二&quot;&#125;);</span><br><span class="line">&#125;</span><br><span class="line">public static void print(String... strs) &#123;</span><br><span class="line">    for (String s : strs)</span><br><span class="line">        System.out.print(s);</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那如果方法的参数是一个数组，然后像使用可变参数那样去调用方法的时候，能行得通吗？</p>
<p>“三妹，给你留个思考题：一般什么时候使用可变参数呢？”</p>
<p>可变参数，可变参数，顾名思义，当一个方法需要处理任意多个相同类型的对象时，就可以定义可变参数。</p>
<p>Java 中有一个很好的例子，就是 String 类的 format() 方法，就像下面这样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(String.format(&quot;年纪是: %d&quot;, 18));</span><br><span class="line">System.out.println(String.format(&quot;年纪是: %d 名字是: %s&quot;, 18, &quot;沉默王二&quot;));</span><br></pre></td></tr></table></figure>
<p>%d 表示将整数格式化为 10 进制整数， %s 表示输出字符串。</p>
<p>如果不使用可变参数，那需要格式化的参数就必须使用“+”号操作符拼接起来了。麻烦也就惹上身了。</p>
<p>在实际的项目代码中，slf4j 的日志输出就经常要用到可变参数（log4j 就没法使用可变参数，日志中需要记录多个参数时就痛苦不堪了）。就像下面这样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line">logger.debug(&quot;名字是&#123;&#125;&quot;, mem.getName());</span><br><span class="line">logger.debug(&quot;名字是&#123;&#125;，年纪是&#123;&#125;&quot;, mem.getName(), mem.getAge());</span><br></pre></td></tr></table></figure>
<p>查看源码就可以发现， debug() 方法使用了可变参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public void debug(String format, Object... arguments);</span><br></pre></td></tr></table></figure>
<p>“那在使用可变参数的时候有什么注意事项吗？”三妹问。</p>
<p>有的。我们要避免重载带有可变参数的方法——这样很容易让编译器陷入自我怀疑中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    print(null);</span><br><span class="line">&#125;</span><br><span class="line">public static void print(String... strs) &#123;</span><br><span class="line">    for (String a : strs)</span><br><span class="line">        System.out.print(a);</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">public static void print(Integer... ints) &#123;</span><br><span class="line">    for (Integer i : ints)</span><br><span class="line">        System.out.print(i);</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候，编译器完全不知道该调用哪个 print() 方法， print(String… strs) 还是print(Integer… ints) ，傻傻分不清。</p>
<p><img src="\assets\note\image-20230927221944053.png" alt="image-20230927221944053"></p>
<p>假如真的需要重载带有可变参数的方法，就必须在调用方法的时候给出明确的指示，不要让编译器去猜。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String [] strs = null;</span><br><span class="line">    print(strs);</span><br><span class="line">    Integer [] ints = null;</span><br><span class="line">    print(ints);</span><br><span class="line">&#125;</span><br><span class="line">public static void print(String... strs) &#123;</span><br><span class="line">&#125;</span><br><span class="line">public static void print(Integer... ints) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码是可以编译通过的。因为编译器知道参数是 String 类型还是 Integer 类型，只不过为了运行时不抛出 NullPointerException ，两个 print() 方法的内部要做好判空操作。</p>
<p>“好了，关于可变参数，我们就先讲到这里吧。三妹，你都理解了吧？”</p>
<p>“嗯嗯，不难，我理解了，哥。”三妹最近的学习状态真不错，能看得出来，她有在认真地做笔记 。</p>
<h2 id="3-6-Java-native方法"><a href="#3-6-Java-native方法" class="headerlink" title="3.6 Java native方法"></a>3.6 Java native方法</h2><p>“三妹，之前我们学习了 Java 中的基本方法，其实 Java 还有一种方法，本地方法，或者叫 native 方法，它与之前的方法有很大的不同。”我放下手中的手机，扭过脸来对三妹说。</p>
<p>“听起来挺有意思的。”三妹很期待。</p>
<p>“我会教你用 C语言实现一个 native 方法。”我继续说到，“C语言是另外一种编程语言，让我们开始吧”</p>
<p>类似 Thread 类中的 private native start0() 方法；</p>
<p>又或者 Object.class 类中的 getClass() 方法、hashCode()方法、clone() 方法，其中方法签名如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final native Class&lt;?&gt; getClass();</span><br><span class="line">public native int hashCode();</span><br><span class="line">protected native Object clone() throws CloneNotSupportedException;</span><br></pre></td></tr></table></figure>
<p>也就是用【native】关键词修饰的方法，多数情况下不需要用 Java 语言实现。</p>
<p>“二哥，为什么要用 native 来修饰方法呢，这样做有什么用？”三妹很乖，但这个问题也问的很掷地有声。</p>
<p>“好的，三妹，我们一步步来扒拉”。</p>
<p><strong>1、JNI：Java Native Interface</strong></p>
<p>在介绍 native 之前，我们先了解什么是 JNI。</p>
<p>一般情况下，我们完全可以使用 Java 语言编写程序，但某些情况下，Java 可能满足不了需求，或者不能更好的满足需求，比如：</p>
<p>①、标准的 Java 类库不支持。</p>
<p>②、我们已经用另一种语言，比如说 C/C++ 编写了一个类库，如何用 Java 代码调用呢？</p>
<p>③、某些运行次数特别多的方法，为了加快性能，需要用更接近硬件的语言（比如汇编）编写。</p>
<p>上面这三种需求，说到底就是如何用 Java 代码调用不同语言编写的代码。那么 JNI 应运而生了。</p>
<p>从 Java 1.1 开始，Java Native Interface (JNI)标准就成为 Java 平台的一部分，它允许 Java 代码和其他语言编写的代码进行交互。</p>
<p>JNI 一开始是为了本地已编译语言，尤其是 C 和 C++而设计的，但是它并不妨碍你使用其他语言，只要调用约定受支持就可以了。使用 Java 与本地已编译的代码交互，通常会丧失平台可移植性，但是，有些情况下这样做是可以接受的，甚至是必须的，比如，使用一些旧的库，与硬件、操作系统进行交互，或者为了提高程序的性能。JNI 标准至少保证本地代码能工作能在任何 Java 虚拟机实现下。</p>
<p><img src="\assets\note\image-20230927222301852.png" alt="image-20230927222301852"></p>
<p>通过 JNI，我们就可以通过 Java 程序（代码）调用到操作系统相关的技术实现的库函数，从而与其他技术和系统交互；同时其他技术和系统也可以通过 JNI 提供的相应原生接口调用 Java 应用系统内部实现的功能。</p>
<p>“二哥，等一下，Java 不是跨平台的吗？如果用 JNI，那么程序不就失去了跨平台的优点？”不得不说，三妹这个问题起到好处。</p>
<p>“确实是这样的。”我掐灭了中指和无名指之间的烟头，继续娓娓道来。</p>
<p>JNI 的缺点：</p>
<p>①、程序不再跨平台。要想跨平台，必须在不同的系统环境下重新编译本地语言部分。</p>
<p>②、程序不再是绝对安全的，本地代码的不当使用可能导致整个程序崩溃。一个通用规则是，你应该让本地方法集中在少数几个类当中。这样就降低了 Java 和 C/C++ 之间的耦合性。</p>
<p>目前来讲使用 JNI 的缺点相对于优点还是可以接受的，可能后面随着 Java 的技术发展，我们不在需要 JNI，</p>
<p>但是目前 JDK 还是一直提供了对 JNI 标准的支持。</p>
<p><strong>2、用 C 语言编写程序本地方法</strong></p>
<p>“上面讲解了什么是 JNI，接下来我们来写个例子：如何用 Java 代码调用本地的 C 程序。”我扭头对三妹说，</p>
<p>“你注意 看。”</p>
<blockquote>
<p>官方文档如下：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/jniTOC.html">https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/jniTOC.html</a></p>
</blockquote>
<p>步骤如下：</p>
<ol>
<li>编写带有 native 方法的 Java 类，生成.java 文件；</li>
<li>使用 javac 命令编译所编写的 Java 类，生成.class 文件；</li>
<li>使用 javah -jni java 类名 生成扩展名为 h 的头文件，也即生成 .h 文件；</li>
<li>使用 C/C++（或者其他编程想语言）实现本地方法，创建 .h 文件的实现，也就是创建 .cpp 文件实现.h文件中的方法；</li>
<li>将 C/C++ 编写的文件生成动态连接库，生成 dll 文件；</li>
</ol>
<p>下面我们通过一个 HelloWorld 程序的调用来完成这几个步骤。</p>
<p><strong>01）编写带有 native 方法的 Java 类 HelloJNI.java</strong></p>
<p>在 /Users/itwanger/Documents/Github/javabetter/testjni 目录下创建 HelloJNI.java 文件，内容如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class HelloJNI &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.loadLibrary(&quot;hello&quot;); // 加载名为 libhello.dylib 的动态链接库</span><br><span class="line">    &#125;</span><br><span class="line">    // 定义本地方法</span><br><span class="line">    private native void helloJNI();</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new HelloJNI().helloJNI(); // 调用本地方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS：后面执行的命令都将在 testjni 的目录下。</p>
<p>解释一下这段代码：</p>
<p>private native void helloJNI() ：用 native 声明的方法告知 JVM 调用该方法在外部定义，也就是我们会用 C 语言去实现。</p>
<p>System.loadLibrary(“hello”) ：加载动态库，参数 hello 是动态库的名字。我们可以这样理解：程序中的方法 helloJNI() 在程序中没有实现，但是我们下面要调用这个方法，怎么办呢？</p>
<p>我们就需要对这个方法进行初始化，所以用了 static 代码块进行初始化，后面会讲到。</p>
<p><strong>02）编译 HelloJNI.java</strong></p>
<p>在命令行通过 javac HelloJNI.java 来编译源代码。</p>
<p><img src="\assets\note\image-20230927222723939.png" alt="image-20230927222723939"></p>
<p><strong>03）使用 生成扩展名为 h 的头文件</strong></p>
<p><img src="\assets\note\image-20230927222756496.png" alt="image-20230927222756496"></p>
<blockquote>
<p>PS：Java 9 以后，javah 被弃用，取而代之的是使用 -h 选项来生成头文件，例如 javac -h .ClassName.java 。</p>
</blockquote>
<p>执行完毕后，会在 HelloJNI.java 所在目录下生成一个名为 HelloJNI.h 的头文件。打开 HelloJNI.h 文件，可以看到如下代码。</p>
<p><img src="\assets\note\image-20230927222847344.png" alt="image-20230927222847344"></p>
<p>看不懂没关系，无所谓，直到它是自动生成的就好。</p>
<p><strong>04）使用 C 语言实现本地方法</strong></p>
<p>创建一个 C 文件 HelloJNI.c，实现本地方法 sayHello。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;jni.h&gt;</span><br><span class="line">#include &quot;HelloJNI.h&quot;</span><br><span class="line">JNIEXPORT void JNICALL Java_HelloJNI_helloJNI(JNIEnv *env, jobject obj) &#123;</span><br><span class="line">    printf(&quot;Hello, JNI!\n&quot;);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，这里需要引入 JNI 头文件，并且实现的方法名称需要与在 Java 中声明的名称一致（ HelloJNI_helloJNI HelloJNI 类的 helloJNI 方法）。</p>
<p><strong>05）编写编译脚本 compile.sh</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># 编译 HelloJNI.c 文件</span><br><span class="line">gcc -I&quot;$JAVA_HOME/include&quot; -I&quot;$JAVA_HOME/include/darwin&quot; -shared -o libhello.dylib </span><br><span class="line">HelloJNI.c</span><br><span class="line"># 把生成的 libhello.dylib 文件拷贝到当前目录</span><br><span class="line">cp libhello.dylib .</span><br></pre></td></tr></table></figure>
<p>注意事项：</p>
<ul>
<li>$JAVA_HOME 是 JDK 的安装路径，需要根据实际情况修改。</li>
<li>在 macOS 上，动态链接库（hello）的后缀是 .dylib，而不是 Linux 上的 .so。</li>
</ul>
<p>这里的 -I 选项是为了告诉编译器头文件的位置， $​JAVA_HOME 是 Java 安装目录的路径。</p>
<p><strong>06）执行编译脚本</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh compile.sh</span><br></pre></td></tr></table></figure>
<p>执行完毕后，会在当前目录下生成一个名为 libhello.dylib 的动态链接库。</p>
<p><img src="\assets\note\image-20230927223317700.png" alt="image-20230927223317700"></p>
<p><strong>07）运行 HelloJNI</strong></p>
<p>执行 java HelloJNI 命令运行 HelloJNI，如果一切正常，就会在终端上输出 Hello, JNI!。</p>
<p><img src="\assets\note\image-20230927223359693.png" alt="image-20230927223359693"></p>
<p><strong>3、JNI 调用 C 的流程图</strong></p>
<p><img src="\assets\note\image-20230927223447275.png" alt="image-20230927223447275"></p>
<p><strong>4、native 关键字</strong></p>
<p>“三妹，现在应该知道什么是 native 了吧？”我问三妹。</p>
<p>“嗯嗯，我来简述一下，二哥你看看我说的是否正确。”</p>
<p>native 用来修饰方法，用 native 声明的方法表示该方法的实现在外部定义，可以用任何语言去实现它，比如说 C/C++。 简单地讲，一个 native Method 就是一个 Java 调用非 Java 代码的接口。</p>
<p>native 语法：</p>
<p>①、修饰方法的位置必须在返回类型之前，和其余的方法控制符前后关系不受限制。</p>
<p>②、不能用 abstract 修饰，也没有方法体，也没有左右大括号。</p>
<p>③、返回值可以是任意类型</p>
<p>“三妹，你学的不错嘛。”我对三妹的学习能力感到非常的欣慰，“<strong>我们在日常编程中看到 native 修饰的方法，只需要知道这个方法的作用是什么，至于别的就不用管了，操作系统会给我们实现，初学的时候也不需要太过深入。”</strong></p>
<h2 id="3-7-Java构造方法"><a href="#3-7-Java构造方法" class="headerlink" title="3.7 Java构造方法"></a>3.7 Java构造方法</h2><p>“三妹，上一节学了 Java 中的方法，接着学构造方法的话，难度就小很多了。”刚吃完中午饭，虽然有些困意，但趁机学个 10 分钟也是不错的，睡眠会更心满意足一些，于是我面露微笑地对三妹说。</p>
<p>“在 Java 中，构造方法是一种特殊的方法，当一个类被实例化的时候，就会调用构造方法。只有在构造方法被调用的时候，对象才会被分配内存空间。每次使用 new 关键字创建对象的时候，构造方法至少会被调用一次。”</p>
<p>“如果你在一个类中没有看见构造方法，并不是因为构造方法不存在，而是被缺省了，编译器会给这个类提供一个默认的构造方法。就是说，Java 有两种类型的构造方法：无参构造方法和有参构造方法。”</p>
<p>“注意，之所以叫它构造方法，是因为对象在创建的时候，需要通过构造方法初始化值——描写对象有哪些初始化状态。”</p>
<p>“哥，你缓缓，一口气说这么多，也真有你的。”三妹听得聚精会神，但也知道关心她这个既当哥又当老师的二哥了。</p>
<p><strong>01、创建构造方法的规则</strong></p>
<p>构造方法必须符合以下规则：</p>
<ul>
<li>构造方法的名字必须和类名一样；</li>
<li>构造方法没有返回类型，包括 void；</li>
<li>构造方法不能是抽象的（abstract）、静态的（static）、最终的（final）、同步的（synchronized）。</li>
</ul>
<p>简单解析一下最后一条规则。</p>
<ul>
<li>由于构造方法不能被子类继承，所以用 final 和 abstract 关键字修饰没有意义；</li>
<li>构造方法用于初始化一个对象，所以用 static 关键字修饰没有意义；</li>
<li>多个线程不会同时创建内存地址相同的同一个对象，所以用 synchronized 关键字修饰没有必要。</li>
</ul>
<p>构造方法的语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class class_name &#123;</span><br><span class="line">    public class_name()&#123;&#125;    // 默认无参构造方法</span><br><span class="line">    public ciass_name([paramList])&#123;&#125;    // 定义有参数列表的构造方法</span><br><span class="line">    …</span><br><span class="line">    // 类主体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得注意的是，如果用 void 声明构造方法的话，编译时不会报错，但 Java 会把这个所谓的“构造方法”当成普通方法来处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">    void Demo()&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>void Demo(){} 看起来很符合构造方法的写法（与类名相同），但其实只是一个不符合规范的普通方法，方法名的首字母使用了大写，方法体为空，它并不是默认的无参构造方法，可以通过反编译后的字节码验证。<br>class class_name {</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">    public Demo() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    void Demo() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>public Demo() {} 才是真正的无参构造方法。</p>
<p>不过，可以使用访问权限修饰符（private、protected、public、default）来修饰构造方法，访问权限修饰符决定了构造方法的创建方式。</p>
<p><strong>02、默认构造方法</strong></p>
<p>如果一个构造方法中没有任何参数，那么它就是一个默认构造方法，也称为无参构造方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Bike &#123;</span><br><span class="line">    Bike()&#123;</span><br><span class="line">        System.out.println(&quot;一辆自行车被创建&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Bike bike = new Bike();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面这个例子中，我们为 Bike 类中创建了一个无参的构造方法，它在我们创建对象的时候被调用。</p>
<p>程序输出结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一辆自行车被创建</span><br></pre></td></tr></table></figure>
<p>通常情况下，无参构造方法是可以缺省的，我们开发者并不需要显式的声明无参构造方法，把这项工作交给编译器就可以了。</p>
<p><img src="\assets\note\image-20231008193525406.png" alt="image-20231008193525406"></p>
<p>“二哥，默认构造方法的目的是什么？它为什么是一个空的啊？”三妹疑惑地看着我，提出了这个尖锐的问题。</p>
<p>“三妹啊，默认构造方法的目的主要是为对象的字段提供默认值，看下面这个例子你就明白了。”我胸有成竹地回答道。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person p = new Person();</span><br><span class="line">        System.out.println(&quot;姓名 &quot; + p.name + &quot; 年龄 &quot; + p.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">姓名 null 年龄 0</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，默认构造方法初始化了 name 和 age 的值，name 是 String 类型，所以默认值为 null，age 是 int 类型，所以默认值为 0。如果没有默认构造方法的话，这项工作就无法完成了。</p>
<p>**03、有参构造方法</p>
<p>有参数的构造方法被称为有参构造方法，参数可以有一个或多个。有参构造方法可以为不同的对象提供不同的值。当然，也可以提供相同的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class ParamConstructorPerson &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    public ParamConstructorPerson(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    public void out() &#123;</span><br><span class="line">        System.out.println(&quot;姓名 &quot; + name + &quot; 年龄 &quot; + age);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ParamConstructorPerson p1 = new ParamConstructorPerson(&quot;沉默王二&quot;,18);</span><br><span class="line">        p1.out();</span><br><span class="line">        ParamConstructorPerson p2 = new ParamConstructorPerson(&quot;沉默王三&quot;,16);</span><br><span class="line">        p2.out();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，构造方法有两个参数（name 和 age），这样的话，我们在创建对象的时候就可以直接为name 和 age 赋值了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new ParamConstructorPerson(&quot;沉默&quot;,18);</span><br><span class="line">new ParamConstructorPerson(&quot;沉默&quot;,16);</span><br></pre></td></tr></table></figure>
<p>如果没有有参构造方法的话，就需要通过 setter 方法给字段赋值了。</p>
<p><strong>04、重载构造方法</strong></p>
<p>在 Java 中，构造方法和方法类似，只不过没有返回类型。它也可以像方法一样被重载。构造方法的重载也很简单，只需要提供不同的参数列表即可。编译器会通过参数的数量来决定应该调用哪一个构造方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class OverloadingConstrutorPerson &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private int sex;</span><br><span class="line">    public OverloadingConstrutorPerson(String name, int age, int sex) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">    public OverloadingConstrutorPerson(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    public void out() &#123;</span><br><span class="line">        System.out.println(&quot;姓名 &quot; + name + &quot; 年龄 &quot; + age + &quot; 性别 &quot; + sex);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        OverloadingConstrutorPerson p1 = new OverloadingConstrutorPerson(&quot;沉默王</span><br><span class="line">二&quot;,18, 1);</span><br><span class="line">        p1.out();</span><br><span class="line">        OverloadingConstrutorPerson p2 = new OverloadingConstrutorPerson(&quot;沉默王</span><br><span class="line">三&quot;,16);</span><br><span class="line">        p2.out();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建对象的时候，如果传递的是三个参数，那么就会调用 OverloadingConstrutorPerson(String name, int age, int sex) 这个构造方法；如果传递的是两个参数，那么就会调用OverloadingConstrutorPerson(String name, int age) 这个构造方法。</p>
<p><strong>05、构造方法和方法的区别</strong></p>
<p>构造方法和方法之间的区别还是蛮多的，比如说下面这些：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">构造方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">方法反映了对象的行为</td>
<td style="text-align:center">构造方法用于初始化对象的字段</td>
</tr>
<tr>
<td style="text-align:center">方法可以有返回类型</td>
<td style="text-align:center">构造方法没有返回类型</td>
</tr>
<tr>
<td style="text-align:center">方法的调用是明确的，开发者通过代码决定调用哪一个</td>
<td style="text-align:center">构造方法的调用是隐式的，通过编译器完成</td>
</tr>
<tr>
<td style="text-align:center">方法在任何情况下都不能由编译器提供</td>
<td style="text-align:center">如果没有明确提供无参构造方法，编译器会提供</td>
</tr>
<tr>
<td style="text-align:center">方法名可以和类名相同，也可以不同</td>
<td style="text-align:center">构造方法的名称必须和类名相同</td>
</tr>
</tbody>
</table>
</div>
<p><strong>06、复制对象</strong></p>
<p>复制一个对象可以通过下面三种方式完成：</p>
<ul>
<li>通过构造方法</li>
<li>通过对象的值</li>
<li>通过 Object 类的 clone() 方法</li>
</ul>
<p><strong>1）通过构造方法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class CopyConstrutorPerson &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public CopyConstrutorPerson(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public CopyConstrutorPerson(CopyConstrutorPerson person) &#123;</span><br><span class="line">        this.name = person.name;</span><br><span class="line">        this.age = person.age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void out() &#123;</span><br><span class="line">        System.out.println(&quot;姓名 &quot; + name + &quot; 年龄 &quot; + age);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CopyConstrutorPerson p1 = new CopyConstrutorPerson(&quot;沉默王二&quot;,18);</span><br><span class="line">        p1.out();</span><br><span class="line">        CopyConstrutorPerson p2 = new CopyConstrutorPerson(p1);</span><br><span class="line">        p2.out();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，有一个参数为 CopyConstrutorPerson 的构造方法，可以把该参数的字段直接复制到新的对象中，这样的话，就可以在 new 关键字创建新对象的时候把之前的 p1 对象传递过去。</p>
<p><strong>2）通过对象的值</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class CopyValuePerson &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    </span><br><span class="line">    public CopyValuePerson(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public CopyValuePerson() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void out() &#123;</span><br><span class="line">        System.out.println(&quot;姓名 &quot; + name + &quot; 年龄 &quot; + age);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CopyValuePerson p1 = new CopyValuePerson(&quot;沉默王二&quot;,18);</span><br><span class="line">        p1.out();</span><br><span class="line">        CopyValuePerson p2 = new CopyValuePerson();</span><br><span class="line">        p2.name = p1.name;</span><br><span class="line">        p2.age = p1.age;</span><br><span class="line">        </span><br><span class="line">        p2.out();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式比较粗暴，直接拿 p1 的字段值复制给 p2 对象（ p2.name = p1.name ）。</p>
<p><strong>3）通过 Object 类的 方法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class ClonePerson implements Cloneable &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    </span><br><span class="line">    public ClonePerson(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    protected Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        return super.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void out() &#123;</span><br><span class="line">        System.out.println(&quot;姓名 &quot; + name + &quot; 年龄 &quot; + age);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) throws CloneNotSupportedException &#123;</span><br><span class="line">        ClonePerson p1 = new ClonePerson(&quot;沉默王二&quot;,18);</span><br><span class="line">        p1.out();</span><br><span class="line">        ClonePerson p2 = (ClonePerson) p1.clone();</span><br><span class="line">        p2.out();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 clone() 方法复制对象的时候，ClonePerson 必须先实现 Cloneable 接口的 clone() 方法，然后再调用 clone() 方法（ ClonePerson p2 = (ClonePerson) p1.clone() ）。</p>
<p><strong>07、ending</strong></p>
<p>“二哥，我能问一些问题吗？”三妹精神焕发，没有丝毫的疲惫。</p>
<p>“当然可以啊，你问。”我很欣赏三妹孜孜不倦的态度。</p>
<p>“构造方法真的不返回任何值吗？”</p>
<p>“构造方法虽然没有返回值，但返回的是类的对象。”</p>
<p>“构造方法只能完成字段初始化的工作吗？”</p>
<p>“初始化字段只是构造方法的一种工作，它还可以做更多，比如启动线程，调用其他方法等。”</p>
<p>“好的，二哥，我的问题问完了，今天的学习可以结束了！”三妹一脸得意的样子。</p>
<p>“那你记得复习下一节的内容哦。”感受到三妹已经学到了知识，我也很欣慰。</p>
<h2 id="3-8-Java访问权限修饰符"><a href="#3-8-Java访问权限修饰符" class="headerlink" title="3.8 Java访问权限修饰符"></a>3.8 Java访问权限修饰符</h2><p>“我们先来讨论一下为什么需要访问权限控制。其实之前我们在讲类和对象的时候有提到，今天我们来详细地聊一聊，三妹。”我开门见山地说，“三妹，你打开思维导图，记得做笔记哦。”</p>
<p>“好的。”三妹应声回答。</p>
<p>考虑两个场景：</p>
<p>场景 1：工程师 A 编写了一个类 ClassA，但是工程师 A 并不希望 ClassA 被其他类都访问到，该如何处理呢？</p>
<p>场景 2：工程师 A 编写了一个类 ClassA，其中有两个方法 fun1、fun2，工程师只想让 fun1 对外可见，也就是说，如果别的工程师来调用 ClassA，只可以调用方法 fun1，该怎么处理呢？</p>
<p>此时，访问权限控制便可以起到作用了。</p>
<p>在 Java 中，提供了四种访问权限控制：</p>
<ul>
<li>默认访问权限（包访问权限）</li>
<li>public</li>
<li>private</li>
<li>protected</li>
</ul>
<p>类只可以用默认访问权限和 public 修饰。比如说：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class Wanger&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Wanger&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>但变量和方法则都可以修饰。</p>
<p><strong>1.修饰类</strong></p>
<ul>
<li>默认访问权限（包访问权限）：用来修饰类的话，表示该类只对同一个包中的其他类可见。</li>
<li>public：用来修饰类的话，表示该类对其他所有的类都可见。</li>
</ul>
<p>例 1：</p>
<p>Main.java:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package com.tobetterjavaer.test1;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String\[\] args) &#123;</span><br><span class="line">        People people = new People(&quot;Tom&quot;);</span><br><span class="line">        System.out.println(people.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>People.java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.tobetterjavaer.test1;</span><br><span class="line">class People &#123;//默认访问权限（包访问权限）</span><br><span class="line">    private String name = null;</span><br><span class="line">    </span><br><span class="line">    public People(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码可以看出，修饰 People 类采用的是默认访问权限，而由于 People 类和 Main 类在同一个包中，因此People 类对于 Main 类是可见的。</p>
<p>例子 2：</p>
<p>People.java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.tobetterjavaer.test2;</span><br><span class="line">class People &#123;//默认访问权限（包访问权限）</span><br><span class="line">    private String name = null;</span><br><span class="line">    </span><br><span class="line">    public People(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时 People 类和 Main 类不在同一个包中，会发生什么情况呢？</p>
<p>下面是 Main 类中的提示的错误：</p>
<p><img src="\assets\note\image-20231008195929488.png" alt="image-20231008195929488"></p>
<p>提示 Peolple 类在 Main 类中不可见。从这里就可以看出，如果用默认访问权限去修饰一个类，该类只对同一个包中的其他类可见，对于不同包中的类是不可见的。</p>
<p>正如上图的快速修正提示所示，将 People 类的默认访问权限更改为 public 的话，People 类对于 Main 类便可见了。</p>
<p><strong>2.修饰方法和变量</strong></p>
<ul>
<li>默认访问权限（包访问权限）：如果一个类的方法或变量被包访问权限修饰，也就意味着只能在同一个包中的其他类中显示地调用该类的方法或者变量，在不同包中的类中不能显式地调用该类的方法或变量。</li>
<li>private：如果一个类的方法或者变量被 private 修饰，那么这个类的方法或者变量只能在该类本身中被访问，在类外以及其他类中都不能显式的进行访问。</li>
<li>protected：如果一个类的方法或者变量被 protected 修饰，对于同一个包的类，这个类的方法或变量是可以被访问的。对于不同包的类，只有继承于该类的类才可以访问到该类的方法或者变量。</li>
<li>public：被 public 修饰的方法或者变量，在任何地方都是可见的。</li>
</ul>
<p>例 3：</p>
<p>Main.java 没有变化</p>
<p>People.java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.tobebetterjavaer.test1;</span><br><span class="line">public class People &#123;</span><br><span class="line">    private String name = null;</span><br><span class="line">    </span><br><span class="line">    public People(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    String getName() &#123;    //默认访问权限（包访问权限）</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void setName(String name) &#123;   //默认访问权限（包访问权限）</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时在 Main 类是可以显示调用方法 getName 和 setName 的。</p>
<p>但是如果 People 类和 Main 类不在同一个包中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.tobebetterjavaer.test2;    //与Main类处于不同包中</span><br><span class="line">public class People &#123;</span><br><span class="line">    private String name = null;</span><br><span class="line">    public People(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    String getName() &#123;    //默认访问权限（包访问权限）</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    void setName(String name) &#123;   //默认访问权限（包访问权限）</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时在 Main 类中会提示错误：</p>
<p><img src="\assets\note\image-20231008200209205.png" alt="image-20231008200209205"></p>
<p>由此可以看出，如果用默认访问权限来修饰类的方法或者变量，则只能在同一个包的其他类中进行访问。</p>
<p>例 4:</p>
<p>People.java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.tobebetterjavaer.test1;</span><br><span class="line">public class People &#123;</span><br><span class="line">    private String name = null;</span><br><span class="line">    </span><br><span class="line">    public People(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    protected void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时是可以在 Main 中显示调用方法 getName 和 setName 的。</p>
<p>如果 People 类和 Main 类处于不同包中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.tobebetterjavaer.test2;</span><br><span class="line">public class People &#123;</span><br><span class="line">    private String name = null;</span><br><span class="line">    public People(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    protected String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    protected void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>则会在 Main 中报错：</p>
<p><img src="\assets\note\image-20231008200350535.png" alt="image-20231008200350535"></p>
<p>如果在 com.cxh.test1 中定一个类 Man 继承 People，则可以在类 Man 中显示调用方法 getName 和setName：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package com.tobebetterjavaer.test1;</span><br><span class="line">import com.tobebetterjavaer.test2.People;</span><br><span class="line">public class Man extends People &#123;</span><br><span class="line">    public Man(String name)&#123;</span><br><span class="line">        super(name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>补充一些关于 Java 包和类文件的知识：</p>
<p>1）Java 中的包主要是为了防止类文件命名冲突以及方便进行代码组织和管理；</p>
<p>2）对于一个 Java 源代码文件，如果存在 public 类的话，只能有一个 public 类，且此时源代码文件的名称必须和 public 类的名称完全相同。</p>
<p>另外，如果还存在其他类，这些类在包外是不可见的。如果源代码文件没有 public 类，则源代码文件的名称可以随意命名。</p>
<p>“三妹，理解了吧？”我问三妹。</p>
<p>“是的，很简单，换句话说，不想让别人看的就 private，想让人看的就 public，想同一个班级/部门看的就默认，想让下一级看的就 protected，对吧？哥”三妹很自信地回答。</p>
<p>“不错不错，总结得有那味了。”</p>
<h2 id="3-9-Java代码初始化块"><a href="#3-9-Java代码初始化块" class="headerlink" title="3.9 Java代码初始化块"></a>3.9 Java代码初始化块</h2><p>“哥，今天我们要学习的内容是‘代码初始化块’，对吧？”看来三妹已经提前预习了我上次留给她的作业。</p>
<p>“是的，三妹。代码初始化块用于初始化一些成员变量。 ”我面带着朴实无华的微笑回答着她，“对象在创建的时候会执行代码初始化块，又称实例初始化块，主要和静态初始化块做区分。”</p>
<p>“可以直接通过‘=’操作符对成员变量进行初始化，但通过代码初始化块可以做更多的事情，比如说打印出成员变量初始化后的值。”</p>
<p>“三妹，来看下面的代码，我们可以直接通过 = 操作符对成员变量进行初始化。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Bike&#123;  </span><br><span class="line">    int speed=100;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>“哥，那为什么还需要代码初始化块呢？”三妹眨了眨眼睛，不解地问。</p>
<p>“我们可以通过代码初始化块执行一个更复杂的操作，比如为集合填充值。来看下面这段代码。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Bike &#123;</span><br><span class="line">    List&lt;String&gt; list;</span><br><span class="line">    &#123;</span><br><span class="line">        list = new ArrayList&lt;&gt;();</span><br><span class="line">        list.add(&quot;沉默&quot;);</span><br><span class="line">        list.add(&quot;沉默&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(new Bike().list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“如果只使用‘=’操作符的话，是没办法完成集合初始化的，对吧？‘=’ 后面只能 new 出集合，却没办法填充值，代码初始化就可以完成这项工作。”</p>
<p>“构造方法执行得早还是代码初始化块啊，哥？”三妹这个问题问的还是挺有水平的。</p>
<p>“不要着急，三妹，先来看下面这个例子。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Car &#123;</span><br><span class="line">    Car() &#123;</span><br><span class="line">        System.out.println(&quot;构造方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;代码初始化块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Car();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“我们来看一下程序的输出结果就一下子明白了。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">代码初始化块</span><br><span class="line">构造方法</span><br></pre></td></tr></table></figure>
<p>“从输出结果看上去，仿佛代码初始化块执行得更早，对吧？事实上是这样子吗？”我露出神秘的微笑，问三妹。</p>
<p>“难道我看到的是假象吗？”三妹睁大了眼睛。</p>
<p>“不是的，对象在初始化的时候会先调用构造方法，这是毫无疑问的，只不过，构造方法在执行的时候会把代码初始化块放在构造方法中其他代码之前，所以，先看到了‘代码初始化块’，后看到了‘’构造方法’。”</p>
<p>说完这句话，我打开 draw.io，使上了吃奶的劲，画出了下面这幅图。</p>
<p><img src="\assets\note\image-20231008200932252.png" alt="image-20231008200932252"></p>
<p>“哦，原来如此啊！”三妹仿佛发现了新大陆，意味深长地说，“编译器把代码初始化块放到了构造方法中，怪不得。”</p>
<p>等三妹明白彻底搞明白后，我对她继续说道：“对于代码初始化来说，它有三个规则。”</p>
<ul>
<li>类实例化的时候执行代码初始化块；</li>
<li>实际上，代码初始化块是放在构造方法中执行的，只不过比较靠前；</li>
<li>代码初始化块里的执行顺序是从前到后的。</li>
</ul>
<p>“这些规则不用死记硬背，大致了解一下就行了。我们继续来看下面这段代码。”话音刚落，我就在新版的IDEA 中噼里啪啦地敲了起来，新版真香。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    A () &#123;</span><br><span class="line">        System.out.println(&quot;父类构造方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class B extends A&#123;</span><br><span class="line">    B() &#123;</span><br><span class="line">        System.out.println(&quot;子类构造方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;代码初始化块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new B();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“来看一下输出结果。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">父类构造方法</span><br><span class="line">代码初始化块</span><br><span class="line">子类构造方法</span><br></pre></td></tr></table></figure>
<p>“在默认情况下，子类的构造方法在执行的时候会主动去调用父类的构造方法。也就是说，其实是构造方法先执行的，再执行的代码初始化块。”</p>
<p>“这个例子再次印证了之前的第二条规则：代码初始化块是放在构造方法中执行的，只不过比较靠前。”</p>
<p>除了这种实例化代码初始化块，还有静态初始化，不过我们会放到 static 关键字中去讲，这里先大致了解一下。</p>
<p>下面是一个 Java 示例代码，演示实例初始化块和静态初始化块的用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class Example &#123;</span><br><span class="line">    // 静态变量</span><br><span class="line">    public static int staticVar = 1;</span><br><span class="line">    // 实例变量</span><br><span class="line">    public int instanceVar = 2;</span><br><span class="line">    </span><br><span class="line">    // 静态初始化块</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;执行静态初始化块&quot;);</span><br><span class="line">        staticVar = 3;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 实例初始化块</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;执行实例初始化块&quot;);</span><br><span class="line">        instanceVar = 4;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 构造方法</span><br><span class="line">    public Example() &#123;</span><br><span class="line">        System.out.println(&quot;执行构造方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;执行main方法&quot;);</span><br><span class="line">        Example e1 = new Example();</span><br><span class="line">        Example e2 = new Example();</span><br><span class="line">        System.out.println(&quot;e1的静态变量：&quot; + e1.staticVar);</span><br><span class="line">        System.out.println(&quot;e1的实例变量：&quot; + e1.instanceVar);</span><br><span class="line">        System.out.println(&quot;e2的静态变量：&quot; + e2.staticVar);</span><br><span class="line">        System.out.println(&quot;e2的实例变量：&quot; + e2.instanceVar);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例代码中，有一个静态变量 staticVar 和一个实例变量 instanceVar，以及一个静态初始化块和一个实例初始化块。在静态初始化块中，我们打印了一条消息并修改了静态变量的值；在实例初始化块中，我们也打印了一条消息并修改了实例变量的值。</p>
<p>来看一下执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">执行静态初始化块</span><br><span class="line">执行main方法</span><br><span class="line">执行实例初始化块</span><br><span class="line">执行构造方法</span><br><span class="line">执行实例初始化块</span><br><span class="line">执行构造方法</span><br><span class="line">e1的静态变量：3</span><br><span class="line">e1的实例变量：4</span><br><span class="line">e2的静态变量：3</span><br><span class="line">e2的实例变量：4</span><br></pre></td></tr></table></figure>
<p>从输出结果可以看出，静态初始化块在类加载时执行，只会执行一次，并且优先于实例初始化块和构造方法的执行；实例初始化块在每次创建对象时执行，在构造方法之前执行。</p>
<p>“好了，今天就先讲到这吧，中午休息一下，下午的精神会更足。”刚对三妹说完这句话，我的哈欠就上来了，好困。</p>
<h2 id="3-10-Java抽象类"><a href="#3-10-Java抽象类" class="headerlink" title="3.10 Java抽象类"></a>3.10 Java抽象类</h2><p>“二哥，你这明显加快了更新的频率呀！”三妹对于我最近的肝劲由衷的佩服了起来。</p>
<p>“哈哈，是呀，我要给广大的学弟学妹们一个完整的 Java 学习体系，记住我们的口号，学 Java 就上二哥的Java 进阶之路。”我对未来充满了信心。</p>
<p>“那就开始吧。”三妹说。</p>
<p><strong>01、定义抽象类</strong></p>
<p>定义抽象类的时候需要用到关键字 abstract ，放在 class 关键字前，就像下面这样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">abstract class AbstractPlayer &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于抽象类的命名，《阿里的 Java 开发手册》上有强调，“抽象类命名要使用 Abstract 或 Base 开头”，这条规约还是值得遵守的，真正做到名如其意。</p>
<p><strong>02、抽象类的特征</strong></p>
<p>抽象类是不能实例化的，尝试通过 new 关键字实例化的话，编译器会报错，提示“类是抽象的，不能实例化”。</p>
<p><img src="\assets\note\image-20231008201407072.png" alt="image-20231008201407072"></p>
<p>虽然抽象类不能实例化，但可以有子类。子类通过 extends 关键字来继承抽象类。就像下面这样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class BasketballPlayer extends AbstractPlayer &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果一个类定义了一个或多个抽象方法，那么这个类必须是抽象类。</p>
<p>当我们尝试在一个普通类中定义抽象方法的时候，编译器会有两处错误提示。第一处在类级别上，提示“这个类必须通过 abstract 关键字定义”，见下图。</p>
<p><img src="C:\Users\xht\AppData\Roaming\Typora\typora-user-images\image-20231008201509135.png" alt="image-20231008201509135"></p>
<p>第二处在尝试定义 abstract 的方法上，提示“抽象方法所在的类不是抽象的”，见下图。</p>
<p><img src="C:\Users\xht\AppData\Roaming\Typora\typora-user-images\image-20231008201528683.png" alt="image-20231008201528683"></p>
<p>抽象类中既可以定义抽象方法，也可以定义普通方法，就像下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractPlayer &#123;</span><br><span class="line">    abstract void play();</span><br><span class="line">    </span><br><span class="line">    public void sleep() &#123;</span><br><span class="line">        System.out.println(&quot;运动员也要休息而不是挑战极限&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抽象类派生的子类必须实现父类中定义的抽象方法。比如说，抽象类 AbstractPlayer 中定义了 play() 方法，子类 BasketballPlayer 中就必须实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class BasketballPlayer extends AbstractPlayer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    void play() &#123;</span><br><span class="line">        System.out.println(&quot;我是张伯伦，篮球场上得过 100 分&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果没有实现的话，编译器会提示“子类必须实现抽象方法”，见下图。</p>
<p><img src="C:\Users\xht\AppData\Roaming\Typora\typora-user-images\image-20231009084933649.png" alt="image-20231009084933649"></p>
<p><strong>03、抽象类的应用场景</strong></p>
<p>“二哥，抽象方法我明白了，那什么时候使用抽象方法呢？能给我讲讲它的应用场景吗？”三妹及时的插话道。</p>
<p>“这问题问的恰到好处呀！”我扶了扶眼镜继续说。</p>
<p><strong>01）第一种场景</strong></p>
<p>当我们希望一些通用的功能被多个子类复用的时候，就可以使用抽象类。比如说，AbstractPlayer 抽象类中有一个普通的方法 sleep() ，表明所有运动员都需要休息，那么这个方法就可以被子类复用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">abstract class AbstractPlayer &#123;</span><br><span class="line">    public void sleep() &#123;</span><br><span class="line">        System.out.println(&quot;运动员也要休息而不是挑战极限&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类 BasketballPlayer 继承了 AbstractPlayer 类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class BasketballPlayer extends AbstractPlayer &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就拥有了 sleep() 方法。BasketballPlayer 的对象可以直接调用父类的 sleep() 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BasketballPlayer basketballPlayer = new BasketballPlayer();</span><br><span class="line">basketballPlayer.sleep();</span><br></pre></td></tr></table></figure>
<p>子类 FootballPlayer 继承了 AbstractPlayer 类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class FootballPlayer extends AbstractPlayer &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也拥有了 sleep() 方法，FootballPlayer 的对象也可以直接调用父类的 sleep() 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FootballPlayer footballPlayer = new FootballPlayer();</span><br><span class="line">footballPlayer.sleep();</span><br></pre></td></tr></table></figure>
<p>这样是不是就实现了代码的复用呢？</p>
<p><strong>02）第二种场景</strong></p>
<p>当我们需要在抽象类中定义好 API，然后在子类中扩展实现的时候就可以使用抽象类。比如说，AbstractPlayer 抽象类中定义了一个抽象方法 play() ，表明所有运动员都可以从事某项运动，但需要对应子类去扩展实现，表明篮球运动员打篮球，足球运动员踢足球。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abstract class AbstractPlayer &#123;</span><br><span class="line">    abstract void play();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BasketballPlayer 继承了 AbstractPlayer 类，扩展实现了自己的 play() 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class BasketballPlayer extends AbstractPlayer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    void play() &#123;</span><br><span class="line">        System.out.println(&quot;我是张伯伦，我篮球场上得过 100 分，&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FootballPlayer 继承了 AbstractPlayer 类，扩展实现了自己的 play() 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class FootballPlayer extends AbstractPlayer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    void play() &#123;</span><br><span class="line">        System.out.println(&quot;我是C罗，我能接住任意高度的头球&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了进一步展示抽象类的特性，我们再来看一个具体的示例。</p>
<blockquote>
<p>PS：网站评论区说涉及到了文件的读写以及 Java 8 的新特性，不适合新人，如果觉得自己实在是看不懂，跳过，等学了 IO 流再来看也行。如果说是为了复习 Java 基础知识，就不存在这个问题了。</p>
</blockquote>
<p>假设现在有一个文件，里面的内容非常简单，只有一个“Hello World”，现在需要有一个读取器将内容从文件中读取出来，最好能按照大写的方式，或者小写的方式来读。</p>
<p>这时候，最好定义一个抽象类 BaseFileReader：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 抽象类，定义了一个读取文件的基础框架，其中 mapFileLine 是一个抽象方法，具体实现需要由子类来完成</span><br><span class="line"> */</span><br><span class="line">abstract class BaseFileReader &#123;</span><br><span class="line">    protected Path filePath; // 定义一个 protected 的 Path 对象，表示读取的文件路径</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 构造方法，传入读取的文件路径</span><br><span class="line">     * @param filePath 读取的文件路径</span><br><span class="line">     */</span><br><span class="line">    protected BaseFileReader(Path filePath) &#123;</span><br><span class="line">        this.filePath = filePath;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 读取文件的方法，返回一个字符串列表</span><br><span class="line">     * @return 字符串列表，表示文件的内容</span><br><span class="line">     * @throws IOException 如果文件读取出错，抛出该异常</span><br><span class="line">     */</span><br><span class="line">    public List&lt;String&gt; readFile() throws IOException &#123;</span><br><span class="line">        return Files.lines(filePath) // 使用 Files 类的 lines 方法，读取文件的每一行</span><br><span class="line">                .map(this::mapFileLine) // 对每一行应用 mapFileLine 方法，将其转化为指定的格式</span><br><span class="line">                .collect(Collectors.toList()); // 将处理后的每一行收集到一个字符串列表中，返回</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 抽象方法，子类需要实现该方法，将文件中的每一行转化为指定的格式</span><br><span class="line">     * @param line 文件中的每一行</span><br><span class="line">     * @return 转化后的字符串</span><br><span class="line">     */</span><br><span class="line">    protected abstract String mapFileLine(String line);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>filePath 为文件路径，使用 protected 修饰，表明该成员变量可以在需要时被子类访问到。</li>
<li>readFile() 方法用来读取文件，方法体里面调用了抽象方法 mapFileLine() ——需要子类来扩展实现大小写的不同读取方式。</li>
</ul>
<p>在我看来，BaseFileReader 类设计的就非常合理，并且易于扩展，子类只需要专注于具体的大小写实现方式就可以了。</p>
<p>小写的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class LowercaseFileReader extends BaseFileReader &#123;</span><br><span class="line">    protected LowercaseFileReader(Path filePath) &#123;</span><br><span class="line">        super(filePath);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected String mapFileLine(String line) &#123;</span><br><span class="line">        return line.toLowerCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大写的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class UppercaseFileReader extends BaseFileReader &#123;</span><br><span class="line">    protected UppercaseFileReader(Path filePath) &#123;</span><br><span class="line">        super(filePath);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected String mapFileLine(String line) &#123;</span><br><span class="line">        return line.toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从文件里面一行一行读取内容的代码被子类复用了。与此同时，子类只需要专注于自己该做的工作，LowercaseFileReader 以小写的方式读取文件内容，UppercaseFileReader 以大写的方式读取文件内容。</p>
<p>来看一下测试类 FileReaderTest：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class FileReaderTest &#123;</span><br><span class="line">    public static void main(String[] args) throws URISyntaxException, IOException &#123;</span><br><span class="line">        URL location = </span><br><span class="line">FileReaderTest.class.getClassLoader().getResource(&quot;helloworld.txt&quot;);</span><br><span class="line">        Path path = Paths.get(location.toURI());</span><br><span class="line">        BaseFileReader lowercaseFileReader = new LowercaseFileReader(path);</span><br><span class="line">        BaseFileReader uppercaseFileReader = new UppercaseFileReader(path);</span><br><span class="line">        System.out.println(lowercaseFileReader.readFile());</span><br><span class="line">        System.out.println(uppercaseFileReader.readFile());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在项目的 resource 目录下建一个文本文件，名字叫 helloworld.txt，里面的内容就是“Hello World”。文件的具体位置如下图所示，我用的集成开发环境是 Intellij IDEA。</p>
<p><img src="C:\Users\xht\AppData\Roaming\Typora\typora-user-images\image-20231009085712342.png" alt="image-20231009085712342"></p>
<p>在 resource 目录下的文件可以通过 ClassLoader.getResource() 的方式获取到 URI 路径，然后就可以取到文本内容了。</p>
<p>输出结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[hello world]</span><br><span class="line">[HELLO WORLD]</span><br></pre></td></tr></table></figure>
<p><strong>04、抽象类总结</strong></p>
<p>好了，对于抽象类我们简单总结一下：</p>
<ol>
<li>抽象类不能被实例化。</li>
<li>抽象类应该至少有一个抽象方法，否则它没有任何意义。</li>
<li>抽象类中的抽象方法没有方法体。</li>
<li>抽象类的子类必须给出父类中的抽象方法的具体实现，除非该子类也是抽象类。</li>
</ol>
<p>“完了吗？二哥”三妹似乎还沉浸在聆听教诲的快乐中。</p>
<p>“是滴，这次我们系统化的学习了抽象类，可以说面面俱到了。三妹你可以把代码敲一遍，加强了一些印象，电脑交给你了。”</p>
<h2 id="3-11-Java接口"><a href="#3-11-Java接口" class="headerlink" title="3.11 Java接口"></a>3.11 Java接口</h2><p>“今天开始讲 Java 的接口。”我对三妹说，“对于面向对象编程来说，抽象是一个极具魅力的特征。如果一个程序员的抽象思维很差，那他在编程中就会遇到很多困难，无法把业务变成具体的代码。在 Java 中，可以通过两种形式来达到抽象的目的，一种上一篇的主角——抽象类，另外一种就是今天的主角——接口。”</p>
<p>“是呀是呀，让我们开始吧！”</p>
<p><strong>01、定义接口</strong></p>
<p>“接口是什么呀？”三妹顺着我的话题及时的插话到。</p>
<p>接口通过 interface 关键字来定义，它可以包含一些常量和方法，来看下面这个示例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public interface Electronic &#123;</span><br><span class="line">    // 常量</span><br><span class="line">    String LED = &quot;LED&quot;;</span><br><span class="line">    // 抽象方法</span><br><span class="line">    int getElectricityUse();</span><br><span class="line">    // 静态方法</span><br><span class="line">    static boolean isEnergyEfficient(String electtronicType) &#123;</span><br><span class="line">        return electtronicType.equals(LED);</span><br><span class="line">    &#125;</span><br><span class="line">    // 默认方法</span><br><span class="line">    default void printDescription() &#123;</span><br><span class="line">        System.out.println(&quot;电子&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看一下这段代码反编译后的字节码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public interface Electronic</span><br><span class="line">&#123;</span><br><span class="line">    public abstract int getElectricityUse();</span><br><span class="line">    public static boolean isEnergyEfficient(String electtronicType)</span><br><span class="line">    &#123;</span><br><span class="line">        return electtronicType.equals(&quot;LED&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void printDescription()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;\u7535\u5B50&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static final String LED = &quot;LED&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现没？接口中定义的所有变量或者方法，都会自动添加上 public 关键字。</p>
<p>接下来，我来一一解释下 Electronic 接口中的核心知识点。</p>
<p>1）<strong>接口中定义的变量会在编译的时候自动加上 public static final修饰符</strong>（注意看一下反编译后的字节码），也就是说上例中的 LED 变量其实就是一个常量。</p>
<p>Java 官方文档上有这样的声明：</p>
<blockquote>
<p>Every field declaration in the body of an interface is implicitly public, static, and final.</p>
</blockquote>
<p>换句话说，接口可以用来作为常量类使用，还能省略掉 public static final ，看似不错的一种选择，对吧？</p>
<p>不过，这种选择并不可取。因为接口的本意是对方法进行抽象，而常量接口会对子类中的变量造成命名空间上的“污染”。</p>
<p>2）<strong>没有使用 private、 default或者 static关键字修饰的方法是隐式抽象的</strong>，在编译的时候会自动加上 public abstract 修饰符。也就是说上例中的 getElectricityUse() 其实是一个抽象方法，没有方法体——这是定义接口的本意。</p>
<p>3）<strong>从 Java 8 开始，接口中允许有静态方法</strong>，比如说上例中的 isEnergyEfficient() 方法。</p>
<p>静态方法无法由（实现了该接口的）类的对象调用，它只能通过接口名来调用，比如说Electronic.isEnergyEfficient(“LED”) 。</p>
<p>接口中定义静态方法的目的是为了提供一种简单的机制，使我们不必创建对象就能调用方法，从而提高接口的竞争力。</p>
<p>4）<strong>接口中允许定义 方法也是从 Java 8 开始的</strong>，比如说上例中的 printDescription() 方法，它始终由一个代码块组成，为实现该接口而不覆盖该方法的类提供默认实现。既然要提供默认实现，就要有方法体，换句话说，默认方法后面不能直接使用“;”号来结束——编译器会报错。</p>
<p><img src="C:\Users\xht\AppData\Roaming\Typora\typora-user-images\image-20231009090314788.png" alt="image-20231009090314788"></p>
<p>“为什么要在接口中定义默认方法呢？”三妹好奇地问到。</p>
<p>允许在接口中定义默认方法的理由很充分，因为一个接口可能有多个实现类，这些类就必须实现接口中定义的抽象类，否则编译器就会报错。假如我们需要在所有的实现类中追加某个具体的方法，在没有 default方法的帮助下，我们就必须挨个对实现类进行修改。</p>
<p>由之前的例子我们就可以得出下面这些结论：</p>
<ul>
<li>接口中允许定义变量</li>
<li>接口中允许定义抽象方法</li>
<li>接口中允许定义静态方法（Java 8 之后）</li>
<li>接口中允许定义默认方法（Java 8 之后）</li>
</ul>
<p>除此之外，我们还应该知道：</p>
<p>1）<strong>接口不允许直接实例化</strong>，否则编译器会报错。</p>
<p><img src="C:\Users\xht\AppData\Roaming\Typora\typora-user-images\image-20231009090411986.png" alt="image-20231009090411986"></p>
<p>需要定义一个类去实现接口，见下例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Computer implements Electronic &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Computer();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public int getElectricityUse() &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后再实例化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Electronic e = new Computer();</span><br></pre></td></tr></table></figure>
<p>2）<strong>接口可以是空的</strong>，既可以不定义变量，也可以不定义方法。最典型的例子就是 Serializable 接口，在java.io 包下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public interface Serializable &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Serializable 接口用来为序列化的具体实现提供一个标记，也就是说，只要某个类实现了 Serializable 接口，那么它就可以用来序列化了。</p>
<p>3）<strong>不要在定义接口的时候使用 final 关键字</strong>，否则会报编译错误，因为接口就是为了让子类实现的，而final 阻止了这种行为。</p>
<p><img src="C:\Users\xht\AppData\Roaming\Typora\typora-user-images\image-20231009090541758.png" alt="image-20231009090541758"></p>
<p>4）<strong>接口的抽象方法不能是 private、protected 或者 final</strong>，否则编译器都会报错。</p>
<p><img src="C:\Users\xht\AppData\Roaming\Typora\typora-user-images\image-20231009090603974.png" alt="image-20231009090603974"></p>
<p>5）<strong>接口的变量是隐式 public static final（常量）</strong>，所以其值无法改变。</p>
<p><strong>02、接口的作用</strong></p>
<p>“接口可以做什么呢？”三妹见缝插针，问的很及时。</p>
<p>第一，<strong>使某些实现类具有我们想要的功能</strong>，比如说，实现了 Cloneable 接口的类具有拷贝的功能，实现了Comparable 或者 Comparator 的类具有比较功能。</p>
<p>Cloneable 和 Serializable 一样，都属于标记型接口，它们内部都是空的。实现了 Cloneable 接口的类可以使用 Object.clone() 方法，否则会抛出 CloneNotSupportedException。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class CloneableTest implements Cloneable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        return super.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws CloneNotSupportedException &#123;</span><br><span class="line">        CloneableTest c1 = new CloneableTest();</span><br><span class="line">        CloneableTest c2 = (CloneableTest) c1.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后没有报错。现在把 implements Cloneable 去掉。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class CloneableTest &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        return super.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws CloneNotSupportedException &#123;</span><br><span class="line">        CloneableTest c1 = new CloneableTest();</span><br><span class="line">        CloneableTest c2 = (CloneableTest) c1.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后抛出 CloneNotSupportedException：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.CloneNotSupportedException: </span><br><span class="line">com.cmower.baeldung.interface1.CloneableTest</span><br><span class="line">    at java.base/java.lang.Object.clone(Native Method)</span><br><span class="line">    at com.cmower.baeldung.interface1.CloneableTest.clone(CloneableTest.java:6)</span><br><span class="line">    at com.cmower.baeldung.interface1.CloneableTest.main(CloneableTest.java:11)</span><br></pre></td></tr></table></figure>
<p>第二，<strong>Java 原则上只支持单一继承，但通过接口可以实现多重继承的目的。</strong></p>
<p>如果有两个类共同继承（extends）一个父类，那么父类的方法就会被两个子类重写。然后，如果有一个新类同时继承了这两个子类，那么在调用重写方法的时候，编译器就不能识别要调用哪个类的方法了。这也正是著名的菱形问题，见下图。</p>
<p><img src="C:\Users\xht\AppData\Roaming\Typora\typora-user-images\image-20231009090838159.png" alt="image-20231009090838159"></p>
<p>简单解释下，ClassC 同时继承了 ClassA 和 ClassB，ClassC 的对象在调用 ClassA 和 ClassB 中重写的方法时，就不知道该调用 ClassA 的方法，还是 ClassB 的方法。</p>
<p>接口没有这方面的困܃。来定义两个接口，Fly 接口会飞，Run 接口会跑。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface Fly &#123;</span><br><span class="line">    void fly();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface Run &#123;</span><br><span class="line">    void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后让 Pig 类同时实现这两个接口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Pig implements Fly,Run&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void fly() &#123;</span><br><span class="line">        System.out.println(&quot;会飞的猪&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;会跑的猪&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在某种形式上，接口实现了多重继承的目的：现实世界里，猪的确只会跑，但在雷军的眼里，站在风口的猪就会飞，这就需要赋予这只猪更多的能力，通过抽象类是无法实现的，只能通过接口。</p>
<p>第三，<strong>实现多态。</strong></p>
<p>什么是多态呢？通俗的理解，就是同一个事件发生在不同的对象上会产生不同的结果，鼠标左键点击窗口上的 X 号可以关闭窗口，点击超链接却可以打开新的网页。</p>
<p>多态可以通过继承（ extends ）的关系实现，也可以通过接口的形式实现。</p>
<p>Shape 接口表示一个形状。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Shape &#123;</span><br><span class="line">    String name();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Circle 类实现了 Shape 接口，并重写了 name() 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Circle implements Shape &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String name() &#123;</span><br><span class="line">        return &quot;圆&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Square 类也实现了 Shape 接口，并重写了 name() 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Square implements Shape &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String name() &#123;</span><br><span class="line">        return &quot;正方形&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后来看测试类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Shape&gt; shapes = new ArrayList&lt;&gt;();</span><br><span class="line">Shape circleShape = new Circle();</span><br><span class="line">Shape squareShape = new Square();</span><br><span class="line">shapes.add(circleShape);</span><br><span class="line">shapes.add(squareShape);</span><br><span class="line">for (Shape shape : shapes) &#123;</span><br><span class="line">    System.out.println(shape.name());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就实现了多态，变量 circleShape、squareShape 的引用类型都是 Shape，但执行 shape.name() 方法的时候，Java 虚拟机知道该去调用 Circle 的 name() 方法还是 Square 的 name() 方法。</p>
<p>说一下多态存在的 3 个前提：</p>
<ol>
<li>要有继承关系，比如说 Circle 和 Square 都实现了 Shape 接口。</li>
<li>子类要重写父类的方法，Circle 和 Square 都重写了 name() 方法。</li>
<li>父类引用指向子类对象，circleShape 和 squareShape 的类型都为 Shape，但前者指向的是 Circle对象，后者指向的是 Square 对象。</li>
</ol>
<p>然后，我们来看一下测试结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">圆</span><br><span class="line">正方形</span><br></pre></td></tr></table></figure>
<p>也就意味着，尽管在 for 循环中，shape 的类型都为 Shape，但在调用 name() 方法的时候，它知道 Circle对象应该调用 Circle 类的 name() 方法，Square 对象应该调用 Square 类的 name() 方法。</p>
<p><strong>03、接口的三种模式</strong></p>
<p><strong>在编程领域，好的设计模式能够让我们的代码事半功倍</strong>。在使用接口的时候，经常会用到三种模式，分别是策略模式、适配器模式和工厂模式。</p>
<p><strong>1）策略模式</strong></p>
<p>策略模式的思想是，针对一组算法，将每一种算法封装到具有共同接口的实现类中，接口的设计者可以在不影响调用者的情况下对算法做出改变。示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 接口：教练</span><br><span class="line">interface Coach &#123;</span><br><span class="line">    // 方法：防守</span><br><span class="line">    void defend();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 何塞·穆里尼奥</span><br><span class="line">class Hesai implements Coach &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void defend() &#123;</span><br><span class="line">        System.out.println(&quot;防守赢得冠军&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 德普·瓜迪奥拉</span><br><span class="line">class Guatu implements Coach &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void defend() &#123;</span><br><span class="line">        System.out.println(&quot;进攻就是最好的防守&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Demo &#123;</span><br><span class="line">    // 参数为接口</span><br><span class="line">    public static void defend(Coach coach) &#123;</span><br><span class="line">        coach.defend();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 为同一个方法传递不同的对象</span><br><span class="line">        defend(new Hesai());</span><br><span class="line">        defend(new Guatu());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Demo.defend() 方法可以接受不同风格的 Coach，并根据所传递的参数对象的不同而产生不同的行为，这被称为“策略模式”。</p>
<p><strong>2）适配器模式</strong></p>
<p>适配器模式的思想是，针对调用者的需求对原有的接口进行转接。生活当中最常见的适配器就是HDMI（英语： High Definition Multimedia Interface ，中文：高清多媒体接口）线，可以同时发送音频和视频信号。适配器模式的示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">interface Coach &#123;</span><br><span class="line">    void defend();</span><br><span class="line">    void attack();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 抽象类实现接口，并置空方法</span><br><span class="line">abstract class AdapterCoach implements Coach &#123;</span><br><span class="line">    public void defend() &#123;&#125;;</span><br><span class="line">    public void attack() &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 新类继承适配器</span><br><span class="line">class Hesai extends AdapterCoach &#123;</span><br><span class="line">    public void defend() &#123;</span><br><span class="line">        System.out.println(&quot;防守赢得冠军&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Demo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Coach coach = new Hesai();</span><br><span class="line">        coach.defend();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Coach 接口中定义了两个方法（ defend() 和 attack() ），如果类直接实现该接口的话，就需要对两个方法进行实现。</p>
<p>如果我们只需要对其中一个方法进行实现的话，就可以使用一个抽象类作为中间件，即适配器（AdapterCoach），用这个抽象类实现接口，并对抽象类中的方法置空（方法体只有一对花括号），这时候，新类就可以绕过接口，继承抽象类，我们就可以只对需要的方法进行覆盖，而不是接口中的所有方法。</p>
<p><strong>3）工厂模式</strong></p>
<p>所谓的工厂模式理解起来也不难，就是什么工厂生产什么，比如说宝马工厂生产宝马，奔驰工厂生产奔驰，A 级学院毕业 A 级教练，C 级学院毕业 C 级教练。示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">// 教练</span><br><span class="line">interface Coach &#123;</span><br><span class="line">    void command();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 教练学院</span><br><span class="line">interface CoachFactory &#123;</span><br><span class="line">    Coach createCoach();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// A级教练</span><br><span class="line">class ACoach implements Coach &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void command() &#123;</span><br><span class="line">        System.out.println(&quot;我是A级证书教练&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// A级教练学院</span><br><span class="line">class ACoachFactory implements CoachFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Coach createCoach() &#123;</span><br><span class="line">        return new ACoach();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// C级教练</span><br><span class="line">class CCoach implements Coach &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void command() &#123;</span><br><span class="line">        System.out.println(&quot;我是C级证书教练&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// C级教练学院</span><br><span class="line">class CCoachFactory implements CoachFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Coach createCoach() &#123;</span><br><span class="line">        return new CCoach();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Demo &#123;</span><br><span class="line">    public static void create(CoachFactory factory) &#123;</span><br><span class="line">        factory.createCoach().command();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 对于一支球队来说，需要什么样的教练就去找什么样的学院</span><br><span class="line">        // 学院会介绍球队对应水平的教练。</span><br><span class="line">        create(new ACoachFactory());</span><br><span class="line">        create(new CCoachFactory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有两个接口，一个是 Coach（教练），可以 command() （指挥球队）；另外一个是 CoachFactory（教练学院），能 createCoach() （教出一名优秀的教练）。然后 ACoach 类实现 Coach 接口，ACoachFactory 类实现 CoachFactory 接口；CCoach 类实现 Coach 接口，CCoachFactory 类实现 CoachFactory 接口。当需要 A 级教练时，就去找 A 级教练学院；当需要 C 级教练时，就去找 C 级教练学院。</p>
<p>依次类推，我们还可以用 BCoach 类实现 Coach 接口，BCoachFactory 类实现 CoachFactory 接口，从而不断地丰富教练的梯队。</p>
<p>“怎么样三妹，一下子接收这么多知识点不容易吧？”</p>
<p>“其实还好啊，二哥你讲的这么细致，我都做好笔记 了，学习嘛，认真一点，效果就会好很多了。”</p>
<p>三妹这种积极乐观的态度真的让我感觉到“付出就会有收获。</p>
<p><strong>04、抽象类和接口的区别</strong></p>
<p>简单总结一下抽象类和接口的区别。</p>
<p>在 Java 中，通过关键字 abstract 定义的类叫做抽象类。Java 是一门面向对象的语言，因此所有的对象都是通过类来描述的；但反过来，并不是所有的类都是用来描述对象的，抽象类就是其中的一种。</p>
<p>以下示例展示了一个简单的抽象类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 个人认为，一名教练必须攻守兼备</span><br><span class="line">abstract class Coach &#123;</span><br><span class="line">    public abstract void defend();</span><br><span class="line">    public abstract void attack();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们知道，有抽象方法的类被称为抽象类，也就意味着抽象类中还能有不是抽象方法的方法。这样的类就不能算作纯粹的接口，尽管它也可以提供接口的功能——只能说抽象类是普通类与接口之间的一种中庸之道。</p>
<p><strong>接口（英文：Interface），在 Java 中是一个抽象类型，是抽象方法的集合</strong>；接口通过关键字 interface来定义。接口与抽象类的不同之处在于：</p>
<ol>
<li>抽象类可以有方法体的方法，但接口没有（Java 8 以前）。</li>
<li>接口中的成员变量隐式为 static final ，但抽象类不是的。</li>
<li>一个类可以实现多个接口，但只能继承一个抽象类。</li>
</ol>
<p>以下示例展示了一个简单的接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 隐式的abstract</span><br><span class="line">interface Coach &#123;</span><br><span class="line">    // 隐式的public</span><br><span class="line">    void defend();</span><br><span class="line">    void attack();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>接口是隐式抽象的，所以声明时没有必要使用 abstract 关键字；</li>
<li>接口的每个方法都是隐式抽象的，所以同样不需要使用 abstract 关键字；</li>
<li>接口中的方法都是隐式 public 的。</li>
</ul>
<p>“哦，我理解了哥。那我再问一下，抽象类和接口有什么差别呢？”</p>
<p>“哇，三妹呀，你这个问题恰到好处，问到了点子上。”我不由得为三妹竖起了大拇指。</p>
<p><strong>1）语法层面上</strong></p>
<ul>
<li>抽象类可以提供成员方法的实现细节，而接口中只能存在 public abstract 方法；</li>
<li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的；</li>
<li>接口中不能含有静态代码块，而抽象类可以有静态代码块；</li>
<li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li>
</ul>
<p><strong>2）设计层面上</strong></p>
<p>抽象类是对一种事物的抽象，即对类抽象，继承抽象类的子类和抽象类本身是一种 is-a 的关系。而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。</p>
<p>举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类 Airplane，将鸟设计为一个类 Bird，但是不能将 飞行 这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。</p>
<p>此时可以将 飞行 设计为一个接口 Fly，包含方法 fly()，然后 Airplane 和 Bird 分别根据自己的需要实现 Fly这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承 Airplane 即可，对于鸟也是类似的，不同种类的鸟直接继承 Bird 类即可。从这里可以看出，继承是一个 “是不是”的关系，而 接口 实现则是”有没有”的关系。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。</p>
<p>接口是对类的某种行为的一种抽象，接口和类之间并没有很强的关联关系，举个例子来说，所有的类都可以实现 Serializable 接口，从而具有序列化的功能，但不能说所有的类和 Serializable 之间是 is-a 的关系。</p>
<p>抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。什么是模板式设计？最简单例子，大家都用过 ppt 里面的模板，如果用模板 A 设计了 ppt B 和 ppt C，ppt B 和ppt C 公共的部分就是模板 A 了，如果它们的公共部分需要改动，则只需要改动模板 A 就可以了，不需要重新对 ppt B 和 ppt C 进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。</p>
<h2 id="3-12-Java内部类"><a href="#3-12-Java内部类" class="headerlink" title="3.12 Java内部类"></a>3.12 Java内部类</h2><p>“在 Java 中，可以将一个类定义在另外一个类里面或者一个方法里面，这样的类叫做内部类。”我放下手中的枸杞杯，对三妹说，“一般来说，内部类分为成员内部类、局部内部类、匿名内部类和静态内部类。”</p>
<p><strong>1）成员内部类</strong></p>
<p>成员内部类是最常见的内部类，看下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Wanger &#123;</span><br><span class="line">    int age = 18;</span><br><span class="line">    </span><br><span class="line">    class Wangxiaoer &#123;</span><br><span class="line">        int age = 81;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看起来内部类 Wangxiaoer 就好像 Wanger 的一个成员，成员内部类可以无限制访问外部类的所有成员属性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Wanger &#123;</span><br><span class="line">    int age = 18;</span><br><span class="line">    private String name = &quot;沉默&quot;;</span><br><span class="line">    static double money = 1;</span><br><span class="line">    </span><br><span class="line">    class Wangxiaoer &#123;</span><br><span class="line">        int age = 81;</span><br><span class="line">        </span><br><span class="line">        public void print() &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">            System.out.println(money);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部类可以随心所欲地访问外部类的成员，但外部类想要访问内部类的成员，就不那么容易了，必须先创建一个成员内部类的对象，再通过这个对象来访问：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Wanger &#123;</span><br><span class="line">    int age = 18;</span><br><span class="line">    private String name = &quot;沉默&quot;;</span><br><span class="line">    static double money = 1;</span><br><span class="line">    </span><br><span class="line">    public Wanger () &#123;</span><br><span class="line">        new Wangxiaoer().print();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    class Wangxiaoer &#123;</span><br><span class="line">        int age = 81;</span><br><span class="line">        public void print() &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">            System.out.println(money);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这也就意味着，如果想要在静态方法中访问成员内部类的时候，就必须先得创建一个外部类的对象，因为内部类是依附于外部类的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Wanger &#123;</span><br><span class="line">    int age = 18;</span><br><span class="line">    private String name = &quot;沉默&quot;;</span><br><span class="line">    static double money = 1;</span><br><span class="line">    </span><br><span class="line">    public Wanger () &#123;</span><br><span class="line">        new Wangxiaoer().print();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Wanger wanger = new Wanger();</span><br><span class="line">        Wangxiaoer xiaoer = wanger.new Wangxiaoer();</span><br><span class="line">        xiaoer.print();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    class Wangxiaoer &#123;</span><br><span class="line">        int age = 81;</span><br><span class="line">        </span><br><span class="line">        public void print() &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">            System.out.println(money);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种创建内部类的方式在实际开发中并不常用，因为内部类和外部类紧紧地绑定在一起，使用起来非常不便。</p>
<p><strong>2）局部内部类</strong></p>
<p>局部内部类是定义在一个方法或者一个作用域里面的类，所以局部内部类的生命周期仅限于作用域内。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Wangsan &#123;</span><br><span class="line">    public Wangsan print() &#123;</span><br><span class="line">        class Wangxiaosan extends Wangsan&#123;</span><br><span class="line">            private int age = 18;</span><br><span class="line">        &#125;</span><br><span class="line">        return new Wangxiaosan();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>局部内部类就好像一个局部变量一样，它是不能被权限修饰符修饰的，比如说 public、protected、private和 static 等。</p>
<p><img src="C:\Users\xht\AppData\Roaming\Typora\typora-user-images\image-20231009092647012.png" alt="image-20231009092647012"></p>
<p><strong>3）匿名内部类</strong></p>
<p>匿名内部类是我们平常用得最多的，尤其是启动多线程的时候，会经常用到，并且 IDE 也会帮我们自动生成。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread t = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>匿名内部类就好像一个方法的参数一样，用完就没了，以至于我们都不需要为它专门写一个构造方法，它的名字也是由系统自动命名的。仔细观察编译后的字节码文件也可以发现，匿名内部类连名字都不配拥有，哈哈，直接借用的外部类，然后 $1 就搞定了。</p>
<p><img src="C:\Users\xht\AppData\Roaming\Typora\typora-user-images\image-20231009092806871.png" alt="image-20231009092806871"></p>
<p>匿名内部类是唯一一种没有构造方法的类。就上面的写法来说，匿名内部类也不允许我们为其编写构造方法，因为它就像是直接通过 new 关键字创建出来的一个对象。</p>
<p>匿名内部类的作用主要是用来继承其他类或者实现接口，并不需要增加额外的方法，方便对继承的方法进行实现或者重写。</p>
<p><strong>4）静态内部类</strong></p>
<p>静态内部类和成员内部类类似，只是多了一个 static 关键字。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Wangsi &#123;</span><br><span class="line">    static int age;</span><br><span class="line">    double money;</span><br><span class="line">    </span><br><span class="line">    static class Wangxxiaosi &#123;</span><br><span class="line">        public Wangxxiaosi ()&#123;</span><br><span class="line">            System.out.println(age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 static 关键字的存在，静态内部类是不允许访问外部类中非 static 的变量和方法的，这一点也非常好理解：你一个静态的内部类访问我非静态的成员变量干嘛？</p>
<p><img src="C:\Users\xht\AppData\Roaming\Typora\typora-user-images\image-20231009093032698.png" alt="image-20231009093032698"></p>
<p>“为什么要使用内部类呢？”三妹问。</p>
<p>三妹这个问题问的非常妙，是时候引经据典了。</p>
<p>在《Think in java》中有这样一句话：</p>
<blockquote>
<p>使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。</p>
</blockquote>
<p>在我们程序设计中有时候会存在一些使用接口很难解决的问题，这个时候我们可以利用内部类提供的、可以继承多个具体的或者抽象的类的能力来解决这些程序设计问题。可以这样说，接口只是解决了部分问题，而内部类使得多重继承的解决方案变得更加完整。</p>
<p>使用内部类还能够为我们带来如下特性：</p>
<ol>
<li>内部类可以使用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。</li>
<li>在单个外部类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。</li>
<li>创建内部类对象的时刻并不依赖于外部类对象的创建。</li>
<li>内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。</li>
<li>内部类提供了更好的封装，除了该外围类，其他类都不能访问。</li>
</ol>
<h2 id="3-13-Java封装继承多态"><a href="#3-13-Java封装继承多态" class="headerlink" title="3.13 Java封装继承多态"></a>3.13 Java封装继承多态</h2><p>在谈 Java 面向对象的时候，不得不提到面向对象的三大特征：封装、继承、多态。三大特征紧密联系而又有区别，合理使用继承能大大减少重复代码，提高代码复用性。</p>
<p>**1）封装</p>
<p>“三妹，准备好了没，我们来讲 Java 封装，算是 Java 的三大特征之一，理清楚了，对以后的编程有较大的帮助。”我对三妹说。</p>
<p>“好的，哥，准备好了。”三妹一边听我说，一边迅速地打开了 XMind，看来一边学习一边总结思维导图这个高效的学习方式三妹已经牢记在心了。</p>
<p>封装从字面上来理解就是包装的意思，专业点就是信息隐藏，是<strong>指利用抽象将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。</strong></p>
<p>数据被保护在类的内部，尽可能地隐藏内部的实现细节，只保留一些对外接口使之与外部发生联系。</p>
<p>其他对象只能通过已经授权的操作来与这个封装的对象进行交互。也就是说用户是无需知道对象内部的细节（当然也无从知道），但可以通过该对象对外的提供的接口来访问该对象。</p>
<p>使用封装有 4 大好处：</p>
<ol>
<li>良好的封装能够减少耦合。</li>
<li>类内部的结构可以自由修改。</li>
<li>可以对成员进行更精确的控制。</li>
<li>隐藏信息，实现细节。</li>
</ol>
<p>首先我们先来看两个类。</p>
<p>Husband.java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class Husband &#123;</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">     * 对属性的封装</span><br><span class="line">     * 一个人的姓名、性别、年龄、妻子都是这个人的私有属性</span><br><span class="line">     */</span><br><span class="line">    private String name ;</span><br><span class="line">    private String sex ;</span><br><span class="line">    private int age ;</span><br><span class="line">    private Wife wife;</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">     * setter()、getter()是该对象对外开发的接口</span><br><span class="line">     */</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public String getSex() &#123;</span><br><span class="line">        return sex;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setSex(String sex) &#123;</span><br><span class="line">        this.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setWife(Wife wife) &#123;</span><br><span class="line">        this.wife = wife;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Wife.java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class Wife &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private String sex;</span><br><span class="line">    private Husband husband;</span><br><span class="line">    </span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public String getSex() &#123;</span><br><span class="line">        return sex;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setSex(String sex) &#123;</span><br><span class="line">        this.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setHusband(Husband husband) &#123;</span><br><span class="line">        this.husband = husband;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Husband getHusband() &#123;</span><br><span class="line">        return husband;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看得出， Husband 类里面的 wife 属性是没有 getter() 的，同时 Wife 类的 age 属性也是没有getter() 方法的。至于理由我想三妹你是懂的。</p>
<p>没有哪个女人愿意别人知道她的年龄。</p>
<p>所以封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果不想被外界方法，我们大可不必提供方法给外界访问。</p>
<p>但是如果一个类没有提供给外界任何可以访问的方法，那么这个类也没有什么意义了。</p>
<p>比如我们将一个房子看做是一个对象，里面有漂亮的装饰，如沙发、电视剧、空调、茶桌等等都是该房子的私有属性，但是如果我们没有那些墙遮挡，是不是别人就会一览无余呢？没有一点儿隐私！</p>
<p>因为存在那个遮挡的墙，我们既能够有自己的隐私而且我们可以随意的更改里面的摆设而不会影响到外面的人。</p>
<p>但是如果没有门窗，一个包裹的严严实实的黑盒子，又有什么存在的意义呢？所以通过门窗别人也能够看到里面的风景。所以说门窗就是房子对象留给外界访问的接口。</p>
<p>通过这个我们还不能真正体会封装的好处。现在我们从程序的角度来分析封装带来的好处。如果我们不使用封装，那么该对象就没有 setter() 和 getter() ，那么 Husband 类应该这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Husband &#123;</span><br><span class="line">    public String name ;</span><br><span class="line">    public String sex ;</span><br><span class="line">    public int age ;</span><br><span class="line">    public Wife wife;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们应该这样来使用它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Husband husband = new Husband();</span><br><span class="line">husband.age = 30;</span><br><span class="line">husband.name = &quot;张三&quot;;</span><br><span class="line">husband.sex = &quot;男&quot;;    //貌似有点儿多余</span><br></pre></td></tr></table></figure>
<p>但是哪天如果我们需要修改 Husband，例如将 age 修改为 String 类型的呢？你只有一处使用了这个类还好，如果你有几十个甚至上百个这样地方，你是不是要改到崩溃。如果使用了封装，我们完全可以不需要做任何修改，只需要稍微改变下 Husband 类的 setAge() 方法即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Husband &#123;</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">     * 对属性的封装</span><br><span class="line">     * 一个人的姓名、性别、年龄、妻子都是这个人的私有属性</span><br><span class="line">     */</span><br><span class="line">    private String name ;</span><br><span class="line">    private String sex ;</span><br><span class="line">    private String age ;    /* 改成 String类型的*/</span><br><span class="line">    private Wife wife;</span><br><span class="line">    </span><br><span class="line">    public String getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        //转换即可</span><br><span class="line">        this.age = String.valueOf(age);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** 省略其他属性的setter、getter **/</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他的地方依然这样引用( husband.setAge(22) )保持不变。</p>
<p>到了这里我们确实可以看出，<strong>封装确实可以使我们更容易地修改类的内部实现，而无需修改使用了该类的代码。</strong></p>
<p>我们再看这个好处：<strong>封装可以对成员变量进行更精确的控制。</strong></p>
<p>还是那个 Husband，一般来说我们在引用这个对象的时候是不容易出错的，但是有时你迷糊了，写成了这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Husband husband = new Husband();</span><br><span class="line">husband.age = 300;</span><br></pre></td></tr></table></figure>
<p>也许你是因为粗心写成了这样，你发现了还好，如果没有发现那就麻烦大了，谁见过 300 岁的老妖怪啊！但是使用封装我们就可以避免这个问题，我们对 age 的访问入口做一些控制(setter)如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Husband &#123;</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">     * 对属性的封装</span><br><span class="line">     * 一个人的姓名、性别、年龄、妻子都是这个人的私有属性</span><br><span class="line">     */</span><br><span class="line">    private String name ;</span><br><span class="line">    private String sex ;</span><br><span class="line">    private int age ;    /* 改成 String类型的*/</span><br><span class="line">    private Wife wife;</span><br><span class="line">    </span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        if(age &gt; 120)&#123;</span><br><span class="line">            System.out.println(&quot;ERROR：error age input....&quot;);    //提示錯誤信息</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            this.age = age;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** 省略其他属性的setter、getter **/</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面都是对 setter 方法的控制，其实通过封装我们也能够对对象的出口做出很好的控制。例如性别在数据库中一般都是以 1、0 的方式来存储的，但是在前台我们又不能展示 1、0，这里我们只需要在 getter() 方法里面做一些转换即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public String getSexName() &#123;</span><br><span class="line">    if(&quot;0&quot;.equals(sex))&#123;</span><br><span class="line">        sexName = &quot;女&quot;;</span><br><span class="line">    &#125;else if(&quot;1&quot;.equals(sex))&#123;</span><br><span class="line">        sexName = &quot;男&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return sexName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用的时候我们只需要使用 sexName 即可实现正确的性别显示。同理也可以用于针对不同的状态做出不同的操作。</p>
<p>“好了，关于封装我们就暂时就聊这么多吧。”我喝了一口普洱茶后，对三妹说。</p>
<p>“好的，哥，我懂了。”</p>
<p><strong>2）继承</strong></p>
<p><strong>01、什么是继承</strong></p>
<p>继承（英语：inheritance）是面向对象软件技术中的一个概念。它<strong>使得复用以前的代码非常容易。</strong></p>
<p>Java 语言是非常典型的面向对象的语言，在 Java 语言中<strong>继承就是子类继承父类的属性和方法，使得子类对象（实例）具有父类的属性和方法，或子类从父类继承方法，使得子类具有父类相同的方法。</strong></p>
<p>我们来举个例子：动物有很多种，是一个比较大的概念。在动物的种类中，我们熟悉的有猫(Cat)、狗(Dog)等动物，它们都有动物的一般特征（比如能够吃东西，能够发出声音），不过又在细节上有区别（不同动物的吃的不同，叫声不一样）。</p>
<p>在 Java 语言中实现 Cat 和 Dog 等类的时候，就需要继承 Animal 这个类。继承之后 Cat、Dog 等具体动物类就是子类，Animal 类就是父类。</p>
<p><img src="C:\Users\xht\AppData\Roaming\Typora\typora-user-images\image-20231009104042170.png" alt="image-20231009104042170"></p>
<p><strong>02、为什么需要继承</strong></p>
<p>三妹，你可能会问为什么需要继承？</p>
<p>如果仅仅只有两三个类，每个类的属性和方法很有限的情况下确实没必要实现继承，但事情并非如此，事实上一个系统中往往有很多个类并且有着很多相似之处，比如猫和狗同属动物，或者学生和老师同属人。各个类可能又有很多个相同的属性和方法，这样的话如果每个类都重新写不仅代码显得很乱，代码工作量也很大。</p>
<p>这时继承的优势就出来了：可以直接使用父类的属性和方法，自己也可以有自己新的属性和方法满足拓展，父类的方法如果自己有需求更改也可以重写。这样<strong>使用继承不仅大大的减少了代码量，也使得代码结构更加清晰可见。</strong></p>
<p><img src="C:\Users\xht\AppData\Roaming\Typora\typora-user-images\image-20231009104136062.png" alt="image-20231009104136062"></p>
<p>所以这样从代码的层面上来看我们设计这个完整的 Animal 类是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Animal</span><br><span class="line">&#123;</span><br><span class="line">    public int id;</span><br><span class="line">    public String name;</span><br><span class="line">    public int age;</span><br><span class="line">    public int weight;</span><br><span class="line">    </span><br><span class="line">    public Animal(int id, String name, int age, int weight) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //这里省略get set方法</span><br><span class="line">    public void sayHello()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void eat()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;I&#x27;m eating&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void sing()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;sing&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而 Dog，Cat，Chicken 类可以这样设计：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Dog extends Animal//继承animal</span><br><span class="line">&#123;</span><br><span class="line">    public Dog(int id, String name, int age, int weight) &#123;</span><br><span class="line">        super(id, name, age, weight);//调用父类构造方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Cat extends Animal&#123;</span><br><span class="line">    public Cat(int id, String name, int age, int weight) &#123;</span><br><span class="line">        super(id, name, age, weight);//调用父类构造方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Chicken extends Animal&#123;</span><br><span class="line">    public Chicken(int id, String name, int age, int weight) &#123;</span><br><span class="line">        super(id, name, age, weight);//调用父类构造方法</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //鸡下蛋</span><br><span class="line">    public void layEggs()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;我是老母鸡下蛋啦，咯哒咯！咯哒咯！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>各自的类继承 Animal 后可以直接使用 Animal 类的属性和方法而不需要重复编写，各个类如果有自己的方法<br>也可很容易地拓展。</p>
<p><strong>03、继承的分类</strong></p>
<p>继承分为单继承和多继承，Java 语言只支持类的单继承，但可以通过实现接口的方式达到多继承的目的。这个我们之前在讲接口的时候就提到过，这里我们再聊一下。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">继承</th>
<th style="text-align:center">定义</th>
<th style="text-align:center">优缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">单继承<img src="C:\Users\xht\AppData\Roaming\Typora\typora-user-images\image-20231009104637899.png" alt="image-20231009104637899"></td>
<td style="text-align:center">一个子类只拥有一个父类</td>
<td style="text-align:center">优点：在类层次结构上比较清晰<br/>缺点：结构的丰富度有时不能满足使用需求</td>
</tr>
<tr>
<td style="text-align:center">多继承（Java 不支持，但可以用其它方式满足多继承使用需求）<img src="C:\Users\xht\AppData\Roaming\Typora\typora-user-images\image-20231009104707021.png" alt="image-20231009104707021"></td>
<td style="text-align:center">一个子类拥有多个直接的父类</td>
<td style="text-align:center">优点：子类的丰富度很高<br/>缺点：容易造成混乱</td>
</tr>
</tbody>
</table>
</div>
<p><strong>单继承</strong></p>
<p>单继承，一个子类只有一个父类，如我们上面讲过的 Animal 类和它的子类。<strong>单继承在类层次结构上比较清晰，但缺点是结构的丰富度有时不能满足使用需求。</strong></p>
<p><strong>多继承</strong></p>
<p>多继承，一个子类有多个直接的父类。这样做的好处是子类拥有所有父类的特征，<strong>子类的丰富度很高，但是缺点就是容易造成混乱。</strong>下图为一个混乱的例子。</p>
<p><img src="C:\Users\xht\AppData\Roaming\Typora\typora-user-images\image-20231009104922728.png" alt="image-20231009104922728"></p>
<p>Java 虽然不支持多继承，但是 Java 有三种实现多继承效果的方式，分别是内部类、多层继承和实现接口。</p>
<p>内部类可以继承一个与外部类无关的类，保证了内部类的独立性，正是基于这一点，可以达到多继承的效果。</p>
<p><strong>多层继承：</strong>子类继承父类，父类如果还继承其他的类，那么这就叫多层继承。这样子类就会拥有所有被继承类的属性和方法。</p>
<p><img src="C:\Users\xht\AppData\Roaming\Typora\typora-user-images\image-20231009105109312.png" alt="image-20231009105109312"></p>
<p>实现接口无疑是满足多继承使用需求的最好方式，一个类可以实现多个接口满足自己在丰富性和复杂环境的使用需求。</p>
<p>类和接口相比，<strong>类就是一个实体，有属性和方法，而接口更倾向于一组方法。</strong>举个例子，就拿斗罗大陆的唐三来看，他存在的继承关系可能是这样的：</p>
<p><img src="C:\Users\xht\AppData\Roaming\Typora\typora-user-images\image-20231009105144388.png" alt="image-20231009105144388"></p>
<p><strong>04、如何实现继承</strong></p>
<p><strong>extends 关键字</strong></p>
<p>在 Java 中，类的继承是单一继承，也就是说一个子类只能拥有一个父类，所以extends只能继承一个类。其使用语法为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class 子类名 extends 父类名&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>例如 Dog 类继承 Animal 类，它是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Animal&#123;&#125; //定义Animal类</span><br><span class="line">class Dog extends Animal&#123;&#125; //Dog类继承Animal类</span><br></pre></td></tr></table></figure>
<p>子类继承父类后，就拥有父类的非私有的属性和方法。如果不明白，请看这个案例，在 IDEA 下创建一个项目，创建一个 test 类做测试，分别创建 Animal 类和 Dog 类，Animal 作为父类写一个 sayHello()方法，Dog 类继承 Animal 类之后就可以调用 sayHello()方法。具体代码为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    public void  sayHello()//父类的方法</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;hello,everybody&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal//继承animal</span><br><span class="line">&#123; &#125;</span><br><span class="line"></span><br><span class="line">public class test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">       Dog dog=new Dog();</span><br><span class="line">       dog.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>点击运行的时候 Dog 子类可以直接使用 Animal 父类的方法。</p>
<p><img src="C:\Users\xht\AppData\Roaming\Typora\typora-user-images\image-20231009105347508.png" alt="image-20231009105347508"></p>
<p><strong>implements 关键字</strong></p>
<p>使用 implements 关键字可以变相使 Java 拥有多继承的特性，使用范围为类实现接口的情况，一个类可以实现多个接口(接口与接口之间用逗号分开)。</p>
<p>我们来看一个案例，创建一个 test2 类做测试，分别创建 doA 接口和 doB 接口，doA 接口声明 sayHello()方法，doB 接口声明 eat()方法，创建 Cat2 类实现 doA 和 doB 接口，并且在类中需要重写 sayHello()方法和eat()方法。具体代码为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">interface doA&#123;</span><br><span class="line">     void sayHello();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface doB&#123;</span><br><span class="line">     void eat();</span><br><span class="line">    //以下会报错 接口中的方法不能具体定义只能声明</span><br><span class="line">    //public void eat()&#123;System.out.println(&quot;eating&quot;);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Cat2 implements  doA,doB&#123;</span><br><span class="line">    @Override//必须重写接口内的方法</span><br><span class="line">    public void sayHello() &#123;</span><br><span class="line">        System.out.println(&quot;hello!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        System.out.println(&quot;I&#x27;m eating&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class test2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Cat2 cat=new Cat2();</span><br><span class="line">        cat.sayHello();</span><br><span class="line">        cat.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Cat 类实现 doA 和 doB 接口的时候，需要实现其声明的方法，点击运行结果如下，这就是一个类实现接口的简单案例：</p>
<p><img src="C:\Users\xht\AppData\Roaming\Typora\typora-user-images\image-20231009105517320.png" alt="image-20231009105517320"></p>
<p><strong>05、继承的特点</strong></p>
<p>继承的主要内容就是子类继承父类，并重写父类的方法。使用子类的属性或方法时候，首先要创建一个对象，而对象通过构造方法去创建，在构造方法中我们可能会调用子父类的一些属性和方法，所以就需要提前掌握 this 和 super关键字。</p>
<p>创建完这个对象之后，再调用重写父类后的方法，注意重写和重载的区别。</p>
<p><strong>this 和 super 关键字</strong></p>
<p>后面会详细讲，这里先来简单了解一下。</p>
<p>this 和 super 关键字是继承中非常重要的知识点，分别表示当前对象的引用和父类对象的引用，两者有很大相似又有一些区别。</p>
<p><strong>this 表示当前对象，是指向自己的引用。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.属性 // 调用成员变量，要区别成员变量和局部变量</span><br><span class="line">this.() // 调用本类的某个方法</span><br><span class="line">this() // 表示调用本类构造方法</span><br></pre></td></tr></table></figure>
<p><strong>super 表示父类对象，是指向父类的引用。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">super.属性 // 表示父类对象中的成员变量</span><br><span class="line">super.方法() // 表示父类对象中定义的方法</span><br><span class="line">super() // 表示调用父类构造方法</span><br></pre></td></tr></table></figure>
<p><strong>构造方法</strong></p>
<p>构造方法是一种特殊的方法，它是一个与类同名的方法。在继承中构造方法是一种比较特殊的方法（比如不能继承），所以要了解和学习在继承中构造方法的规则和要求。</p>
<p>继承中的构造方法有以下几点需要注意：</p>
<p><strong>父类的构造方法不能被继承：</strong></p>
<p>因为构造方法语法是与类同名，而继承则不更改方法名，如果子类继承父类的构造方法，那明显与构造方法的语法冲突了。比如 Father 类的构造方法名为 Father()，Son 类如果继承 Father 类的构造方法 Father()，那就和构造方法定义：<strong>构造方法与类同名冲突了</strong>，所以在子类中不能继承父类的构造方法，但子类会调用父类的构造方法。</p>
<p><strong>子类的构造过程必须调用其父类的构造方法：</strong></p>
<p>Java 虚拟机构造子类对象前会先构造父类对象，父类对象构造完成之后再来构造子类特有的属性，这被称为内存叠加。而 Java 虚拟机构造父类对象会执行父类的构造方法，所以子类构造方法必须调用 super()即父类的构造方法。就比如一个简单的继承案例应该这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">    public String name;</span><br><span class="line">    </span><br><span class="line">    public A() &#123;//无参构造</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public A (String name)&#123;//有参构造</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A&#123;</span><br><span class="line">    public B() &#123;//无参构造</span><br><span class="line">       super();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public B(String name) &#123;//有参构造</span><br><span class="line">      //super();</span><br><span class="line">       super(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>如果子类的构造方法中没有显示地调用父类构造方法，则系统默认调用父类无参数的构造方法。</strong></p>
<p>你可能有时候在写继承的时候子类并没有使用 super()调用，程序依然没问题，其实这样是为了节省代码，系统执行时会自动添加父类的无参构造方式，如果不信的话我们对上面的类稍作修改执行：</p>
<p><img src="C:\Users\xht\AppData\Roaming\Typora\typora-user-images\image-20231009105905569.png" alt="image-20231009105905569"></p>
<p><strong>方法重写(Override)</strong></p>
<p>方法重写也就是子类中出现和父类中一模一样的方法(包括返回值类型，方法名，参数列表)，它建立在继承的基础上。你可以理解为方法的<strong>外壳不变，但是核心内容重写。</strong></p>
<p>在这里提供一个简单易懂的方法重写案例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class E1&#123;</span><br><span class="line">    public void doA(int a)&#123;</span><br><span class="line">        System.out.println(&quot;这是父类的方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class E2 extends E1&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void doA(int a) &#123;</span><br><span class="line">        System.out.println(&quot;我重写父类方法，这是子类的方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 @Override 注解显示声明该方法为注解方法，可以帮你检查重写方法的语法正确性，当然如果不加也是可以的，但建议加上。</p>
<p><strong>方法重载(Overload)</strong></p>
<p>如果有两个方法的<strong>方法名相同，但参数不一致</strong>，那么可以说一个方法是另一个方法的重载。</p>
<p>重载可以通常理解为完成同一个事情的方法名相同，但是参数列表不同其他条件也可能不同。一个简单的方法重载的例子，类 E3 中的 add()方法就是一个重载方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class E3&#123;</span><br><span class="line">    public int add(int a,int b)&#123;</span><br><span class="line">        return a+b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public double add(double a,double b) &#123;</span><br><span class="line">        return a+b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int add(int a,int b,int c) &#123;</span><br><span class="line">        return a+b+c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>06、继承与修饰符</strong></p>
<p>Java 修饰符的作用就是对类或类成员进行修饰或限制，每个修饰符都有自己的作用，而在继承中可能有些特殊修饰符使得被修饰的属性或方法不能被继承，或者继承需要一些其他的条件。</p>
<p>Java 语言提供了很多修饰符，修饰符用来定义类、方法或者变量，通常放在语句的最前端。主要分为以下两类：</p>
<ul>
<li>访问权限修饰符，也就是 public、private、protected 等</li>
<li>非访问修饰符，也就是 static、final、abstract 等</li>
</ul>
<p><strong>访问修饰符</strong></p>
<p>Java 子类重写继承的方法时，<strong>不可以降低方法的访问权限，子类继承父类的访问修饰符作用域不能比父类小</strong>，也就是更加开放，假如父类是 protected 修饰的，其子类只能是 protected 或者 public，绝对不能是default(默认的访问范围)或者 private。所以在继承中需要重写的方法不能使用 private 修饰词修饰。</p>
<p>如果还是不太清楚可以看几个小案例就很容易搞懂，写一个 A1 类中用四种修饰词实现四个方法，用子类 A2继承 A1，重写 A1 方法时候你就会发现父类私有方法不能重写，非私有方法重写使用的修饰符作用域不能变小(大于等于)。</p>
<p><img src="C:\Users\xht\AppData\Roaming\Typora\typora-user-images\image-20231009110222959.png" alt="image-20231009110222959"></p>
<p>正确的案例应该为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class A1 &#123;</span><br><span class="line">    private void doA()&#123; &#125;</span><br><span class="line">    void doB()&#123;&#125;//default</span><br><span class="line">    protected void doC()&#123;&#125;</span><br><span class="line">    public void doD()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class A2 extends A1&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void doB() &#123; &#125;//继承子类重写的方法访问修饰符权限可扩大</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    protected void doC() &#123; &#125;//继承子类重写的方法访问修饰符权限可和父类一致</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void doD() &#123; &#125;//不可用protected或者default修饰</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还要注意的是，<strong>继承当中子类抛出的异常必须是父类抛出的异常或父类抛出异常的子异常。</strong>下面的一个案例四种方法测试可以发现子类方法的异常不可大于父类对应方法抛出异常的范围。</p>
<p><img src="C:\Users\xht\AppData\Roaming\Typora\typora-user-images\image-20231009110517889.png" alt="image-20231009110517889"></p>
<p>正确的案例应该为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class B1&#123;</span><br><span class="line">    public void doA() throws Exception&#123;&#125;</span><br><span class="line">    public void doB() throws Exception&#123;&#125;</span><br><span class="line">    public void doC() throws IOException&#123;&#125;</span><br><span class="line">    public void doD() throws IOException&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B2 extends B1&#123;</span><br><span class="line">    //异常范围和父类可以一致</span><br><span class="line">    @Override</span><br><span class="line">    public void doA() throws Exception &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    //异常范围可以比父类更小</span><br><span class="line">    @Override</span><br><span class="line">    public void doB() throws IOException &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    //异常范围 不可以比父类范围更大</span><br><span class="line">    @Override</span><br><span class="line">    public void doC() throws IOException &#123; &#125;//不可抛出Exception等比IOException更大的异常</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void doD() throws IOException &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>非访问修饰符</strong></p>
<p>访问修饰符用来控制访问权限，而非访问修饰符每个都有各自的作用，下面针对 static、final、abstract 修饰符进行介绍。</p>
<p><strong>static 修饰符</strong></p>
<p>static 翻译为“静态的”，能够与变量，方法和类一起使用，<strong>称为静态变量，静态方法(也称为类变量、类方法)。</strong>如果在一个类中使用 static 修饰变量或者方法的话，它们<strong>可以直接通过类访问，不需要创建一个类的对象来访问成员。</strong></p>
<p>我们在设计类的时候可能会使用静态方法，有很多工具类比如 Math ， Arrays 等类里面就写了很多静态方法。</p>
<p>可以看以下的案例证明上述规则：</p>
<p><img src="C:\Users\xht\AppData\Roaming\Typora\typora-user-images\image-20231009110655864.png" alt="image-20231009110655864"></p>
<p>源代码为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class C1&#123;</span><br><span class="line">    public  int a;</span><br><span class="line">    public C1()&#123;&#125;</span><br><span class="line">   // public static C1()&#123;&#125;// 构造方法不允许被声明为static</span><br><span class="line">    public static void doA() &#123;&#125;</span><br><span class="line">    public static void doB() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C2 extends C1&#123;</span><br><span class="line">    public static  void doC()//静态方法中不存在当前对象，因而不能使用this和super。</span><br><span class="line">    &#123;</span><br><span class="line">        //System.out.println(super.a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void doA()&#123;&#125;//静态方法能被静态方法重写</span><br><span class="line">   // public void doB()&#123;&#125;//静态方法不能被非静态方法重写</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>final 修饰符</strong></p>
<p>final 变量：</p>
<ul>
<li>final 表示”最后的、最终的”含义，<strong>变量一旦赋值后，不能被重新赋值。</strong>被 final 修饰的实例变量必须显式指定初始值(即不能只声明)。final 修饰符通常和 static 修饰符一起使用来创建类常量。</li>
</ul>
<p>final 方法：</p>
<ul>
<li><strong>父类中的 final 方法可以被子类继承，但是不能被子类重写。</strong>声明 final 方法的主要目的是防止该方法的内容被修改。</li>
</ul>
<p>final 类：</p>
<ul>
<li><strong>final 类不能被继承</strong>，没有类能够继承 final 类的任何特性。</li>
</ul>
<p>所以无论是变量、方法还是类被 final 修饰之后，都有代表最终、最后的意思。内容无法被修改。</p>
<p><strong>abstract 修饰符</strong></p>
<p>abstract 英文名为“抽象的”，主要用来修饰类和方法，称为抽象类和抽象方法。</p>
<p><strong>抽象方法：</strong>有很多不同类的方法是相似的，但是具体内容又不太一样，所以我们只能抽取他的声明，没有具体的方法体，即抽象方法可以表达概念但无法具体实现。</p>
<p><strong>抽象类：有抽象方法的类必须是抽象类</strong>，抽象类可以表达概念但是无法构造实体的类。</p>
<p><img src="C:\Users\xht\AppData\Roaming\Typora\typora-user-images\image-20231009110939662.png" alt="image-20231009110939662"></p>
<p>比如我们可以这样设计一个 People 抽象类以及一个抽象方法，在子类中具体完成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">abstract class People&#123;</span><br><span class="line">    public abstract void sayHello();//抽象方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Chinese extends People&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void sayHello() &#123;//实现抽象方法</span><br><span class="line">        System.out.println(&quot;你好&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Japanese extends People&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void sayHello() &#123;//实现抽象方法</span><br><span class="line">        System.out.println(&quot;口你七哇&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class American extends People&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void sayHello() &#123;//实现抽象方法</span><br><span class="line">        System.out.println(&quot;hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>07、Object 类和转型</strong></p>
<p>提到 Java 继承，不得不提及所有类的根类：Object(java.lang.Object)类，如果一个类没有显式声明它的父类（即没有写 extends xx），那么默认这个类的父类就是 Object 类，任何类都可以使用 Object 类的方法，创建的类也可和 Object 进行向上、向下转型，所以 Object 类是掌握和理解继承所必须的知识点。</p>
<p>Java 向上和向下转型在 Java 中运用很多，也是建立在继承的基础上，所以 Java 转型也是掌握和理解继承所必须的知识点。</p>
<p><strong>Object 类概述</strong></p>
<ol>
<li>Object 是类层次结构的根类，所有的类都隐式的继承自 Object 类。</li>
<li>Java 中，所有的对象都拥有 Object 的默认方法。</li>
<li>Object 类有一个构造方法，并且是无参构造方法。</li>
</ol>
<p>Object 是 Java 所有类的父类，是整个类继承结构的顶端，也是最抽象的一个类。</p>
<p>像 toString()、equals()、hashCode()、wait()、notify()、getClass()等都是 Object 的方法。你以后可能会经常碰到，但其中遇到更多的就是 toString()方法和 equals()方法，我们经常需要重写这两种方法满足我们的使用需求。</p>
<p>toString()方法表示返回该对象的字符串，由于各个对象构造不同所以需要重写，如果不重写的话默认返回 类名@hashCode 格式。</p>
<p>如果重写 toString()方法后直接调用 toString()方法就可以返回我们自定义的该类转成字符串类型的内容输出，而不需要每次都手动的拼凑成字符串内容输出，大大简化输出操作。</p>
<p>equals()方法主要比较两个对象是否相等，因为对象的相等不一定非要严格要求两个对象地址上的相同，有时内容上的相同我们就会认为它相等，比如 String 类就重写了euqals()方法，通过字符串的内容比较是否相等。</p>
<p><img src="C:\Users\xht\AppData\Roaming\Typora\typora-user-images\image-20231009111259886.png" alt="image-20231009111259886"></p>
<p><strong>向上转型</strong></p>
<p><strong>向上转型 : </strong>通过子类对象(小范围)实例化父类对象(大范围)，这种属于自动转换。用一张图就能很好地表示向上转型的逻辑：</p>
<p><img src="C:\Users\xht\AppData\Roaming\Typora\typora-user-images\image-20231009111323351.png" alt="image-20231009111323351"></p>
<p>父类引用变量指向子类对象后，只能使用父类已声明的方法，但方法如果被重写会执行子类的方法，如果方法未被重写那么将执行父类的方法。</p>
<p><strong>向下转型</strong></p>
<p><strong>向下转型 : </strong>通过父类对象(大范围)实例化子类对象(小范围)，在书写上父类对象需要加括号 () 强制转换为子类类型。但父类引用变量实际引用必须是子类对象才能成功转型，这里也用一张图就能很好表示向下转型的逻辑：</p>
<p><img src="C:\Users\xht\AppData\Roaming\Typora\typora-user-images\image-20231009111414766.png" alt="image-20231009111414766"></p>
<p>子类引用变量指向父类引用变量指向的对象后(一个 Son()对象)，就完成向下转型，就可以调用一些子类特有而父类没有的方法 。</p>
<p>在这里写一个向上转型和向下转型的案例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object object=new Integer(666);//向上转型</span><br><span class="line">Integer i=(Integer)object;//向下转型Object-&gt;Integer，object的实质还是指向Integer</span><br><span class="line">String str=(String)object;//错误的向下转型，虽然编译器不会报错但是运行会报错</span><br></pre></td></tr></table></figure>
<p><strong>08、子父类初始化顺序</strong></p>
<p>在 Java 继承中，父子类初始化先后顺序为：</p>
<ol>
<li>父类中静态成员变量和静态代码块</li>
<li>子类中静态成员变量和静态代码块</li>
<li>父类中普通成员变量和代码块，父类的构造方法</li>
<li>子类中普通成员变量和代码块，子类的构造方法</li>
</ol>
<p>总的来说，就是<strong>静态&gt;非静态，父类&gt;子类，非构造方法&gt;构造方法。</strong>同一类别（例如普通变量和普通代码块）成员变量和代码块执行从前到后，需要注意逻辑。</p>
<p>这个也不难理解，静态变量也称类变量，可以看成一个全局变量，静态成员变量和静态代码块在类加载的时候就初始化，而非静态变量和代码块在对象创建的时候初始化。所以静态快于非静态初始化。</p>
<p>而在创建子类对象的时候需要先创建父类对象，所以父类优先于子类。</p>
<p>而在调用构造方法的时候，是对成员变量进行一些初始化操作，所以普通成员变量和代码块优于构造方法执行。</p>
<p>至于更深层次为什么这个顺序，就要更深入了解 JVM 执行流程啦。下面一个测试代码为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Father&#123;</span><br><span class="line">    public Father() &#123;</span><br><span class="line">        System.out.println(++b1+&quot;父类构造方法&quot;);</span><br><span class="line">    &#125;//父类构造方法 第四</span><br><span class="line">    </span><br><span class="line">    static int a1=0;//父类static 第一 注意顺序</span><br><span class="line">    </span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(++a1+&quot;父类static&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int b1=a1;//父类成员变量和代码块 第三</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(++b1+&quot;父类代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Son extends Father&#123;</span><br><span class="line">    public Son() &#123;</span><br><span class="line">        System.out.println(++b2+&quot;子类构造方法&quot;);</span><br><span class="line">    &#125;//子类构造方法 第六</span><br><span class="line">    </span><br><span class="line">    static &#123;//子类static第二步</span><br><span class="line">        System.out.println(++a1+&quot;子类static&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int b2=b1;//子类成员变量和代码块 第五</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(++b2 + &quot;子类代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class test9 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Son son=new Son();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<p><img src="C:\Users\xht\AppData\Roaming\Typora\typora-user-images\image-20231009111730506.png" alt="image-20231009111730506"></p>
<p><strong>3）多态</strong></p>
<p>Java 多态是指在面向对象编程中，同一个类的对象在不同情况下表现出不同的行为和状态。</p>
<ul>
<li>子类可以继承父类的属性和方法，子类对象可以直接使用父类中的方法和变量。</li>
<li>子类可以对从父类继承的方法进行重新实现，使得子类对象调用这个方法时表现出不同的行为。</li>
<li>可以将子类对象赋给父类类型的变量，这样就可以通过父类类型的变量调用子类中重写的方法，实现多态。</li>
</ul>
<p>“很枯燥，有没有？再具体的分析一下。”</p>
<p><strong>01、多态是什么</strong></p>
<p>在我刻板的印象里，西游记里的那段孙悟空和二郎神的精彩对战就能很好的解释“多态”这个词：一个孙悟<br>空，能七十二变；一个二郎神，也能七十二变；他们都可以变成不同的形态，但只需要悄悄地喊一声“变”。<br>Java的多态是什么呢？其实就是一种能力——同一个行为具有不同的表现形式；换句话说就是，执行一段代<br>码，Java 在运行时能根据对象的不同产生不同的结果。和孙悟空和二郎神都只需要喊一声“变”，然后就变<br>了，并且每次变得还不一样；一个道理。<br>多态的前提条件有三个：<br>子类继承父类<br>子类覆盖父类的方法<br>父类引用指向子类对象<br>多态的一个简单应用，来看程序清单1-1：<br>02、多态与后期绑定<br>现在，我们来思考一个问题：程序清单1-1在执行 wanger.write() 时，由于编译器只有一个 Wanger 引<br>用，它怎么知道究竟该调用父类 Wanger 的 write() 方法，还是子类 Wangxiaoer 的 write() 方法呢？<br>答案是在运行时根据对象的类型进行后期绑定，编译器在编译阶段并不知道对象的类型，但是Java的方法调<br>用机制能找到正确的方法体，然后执行出正确的结果。<br>多态机制提供的一个重要的好处程序具有良好的扩展性。来看程序清单2-1：<br>//子类继承父类<br>public class Wangxiaoer extends Wanger {<br>public void write() { // 子类覆盖父类方法<br>System.out.println(“记住仇恨，表明我们要奋发图强的心智”);<br>}<br>public static void main(String[] args) {<br>// 父类引用指向子类对象<br>Wanger[] wangers = { new Wanger(), new Wangxiaoer() };<br>for (Wanger wanger : wangers) {<br>// 对象是王二的时候输出：勿忘国耻<br>// 对象是王小二的时候输出：记住仇恨，表明我们要奋发图强的心智<br>wanger.write();<br>}<br>}<br>}<br>class Wanger {<br>public void write() {<br>System.out.println(“勿忘国耻”);<br>}<br>}<br>//子类继承父类<br>学Java，就认准二哥的Java进阶之路<br>No. 306 / 963<br>在程序清单 2-1 中，我们在 Wanger 类中增加了 read() 方法，在 Wangxiaoer 类中增加了eat()方法，但这丝<br>毫不会影响到 write() 方法的调用。write() 方法忽略了周围代码发生的变化，依然正常运行。这让我想起了<br>金庸《倚天屠龙记》里九阳真经的口诀：“他强由他强，清风拂山岗；他横由他横，明月照大江。”<br>多态的这个优秀的特性，让我们在修改代码的时候不必过于紧张，因为多态是一项让程序员“将改变的与未改<br>变的分离开来”的重要特性。<br>03、多态与构造方法<br>在构造方法中调用多态方法，会产生一个奇妙的结果，我们来看程序清单3-1：<br>public class Wangxiaoer extends Wanger {<br>public void write() { // 子类覆盖父类方法<br>System.out.println(“记住仇恨，表明我们要奋发图强的心智”);<br>}<br>public void eat() {<br>System.out.println(“我不喜欢读书，我就喜欢吃”);<br>}<br>public static void main(String[] args) {<br>// 父类引用指向子类对象<br>Wanger[] wangers = { new Wanger(), new Wangxiaoer() };<br>for (Wanger wanger : wangers) {<br>// 对象是王二的时候输出：勿忘国耻<br>// 对象是王小二的时候输出：记住仇恨，表明我们要奋发图强的心智<br>wanger.write();<br>}<br>}<br>}<br>class Wanger {<br>public void write() {<br>System.out.println(“勿忘国耻”);<br>}<br>public void read() {<br>System.out.println(“每周读一本好书”);<br>}<br>}<br>public class Wangxiaosan extends Wangsan {<br>private int age = 3;<br>public Wangxiaosan(int age) {<br>this.age = age;<br>System.out.println(“王小三的年龄：” + this.age);<br>}<br>public void write() { // 子类覆盖父类方法<br>System.out.println(“我小三上幼儿园的年龄是：” + this.age);<br>}<br>学Java，就认准二哥的Java进阶之路<br>No. 307 / 963<br>从输出结果上看，是不是有点诧异？明明在创建 Wangxiaosan 对象的时候，年龄传递的是 4，但输出结果<br>既不是“老子上幼儿园的年龄是 3 岁半”，也不是“我小三上幼儿园的年龄是：4”。<br>为什么？<br>因为在创建子类对象时，会先去调用父类的构造方法，而父类构造方法中又调用了被子类覆盖的多态方法，<br>由于父类并不清楚子类对象中的属性值是什么，于是把int类型的属性暂时初始化为 0，然后再调用子类的构<br>造方法（子类构造方法知道王小二的年龄是 4）。<br>04、多态与向下转型<br>向下转型是指将父类引用强转为子类类型；这是不安全的，因为有的时候，父类引用指向的是父类对象，向<br>下转型就会抛出 ClassCastException，表示类型转换失败；但如果父类引用指向的是子类对象，那么向下转<br>型就是成功的。<br>来看程序清单4-1：<br>public static void main(String[] args) {<br>new Wangxiaosan(4);<br>// 上幼儿园之前<br>// 我小三上幼儿园的年龄是：0<br>// 上幼儿园之后<br>// 王小三的年龄：4<br>}<br>}<br>class Wangsan {<br>Wangsan () {<br>System.out.println(“上幼儿园之前”);<br>write();<br>System.out.println(“上幼儿园之后”);<br>}<br>public void write() {<br>System.out.println(“老子上幼儿园的年龄是3岁半”);<br>}<br>}<br>public class Wangxiaosi extends Wangsi {<br>public void write() {<br>System.out.println(“记住仇恨，表明我们要奋发图强的心智”);<br>}<br>public void eat() {<br>System.out.println(“我不喜欢读书，我就喜欢吃”);<br>}<br>public static void main(String[] args) {<br>Wangsi[] wangsis = { new Wangsi(), new Wangxiaosi() };<br>// wangsis[1]能够向下转型<br>((Wangxiaosi) wangsis[1]).write();<br>学Java，就认准二哥的Java进阶之路<br>No. 308 / 963<br>“好了，三妹，到此为止，我们就将 Java 的三大特性，封装继承多态全部讲完了，希望你能重新把他们梳理<br>一下。”<br>“好的，二哥，遵命。”三妹顽皮地笑了。<br>4）小结<br>好啦，三妹，本次继承就介绍到这里啦，Java 面向对象三大特征之一继承——优秀的你已经掌握。<br>封装：是对类的封装，封装是对类的属性和方法进行封装，只对外暴露方法而不暴露具体使用细节，所以我<br>们一般设计类成员变量时候大多设为私有而通过一些 get、set 方法去读写。<br>继承：子类继承父类，即“子承父业”，子类拥有父类除私有的所有属性和方法，自己还能在此基础上拓展自<br>己新的属性和方法。主要目的是复用代码。<br>多态：多态是同一个行为具有多个不同表现形式或形态的能力。即一个父类可能有若干子类，各子类实现父<br>类方法有多种多样，调用父类方法时，父类引用变量指向不同子类实例而执行不同方法，这就是所谓父类方<br>法是多态的。<br>最后送你一张图捋一捋其中的关系吧。<br>// wangsis[0]不能向下转型<br>((Wangxiaosi)wangsis[0]).write();<br>}<br>}<br>class Wangsi {<br>public void write() {<br>System.out.println(“勿忘国耻”);<br>}<br>public void read() {<br>System.out.println(“每周读一本好书”);<br>}<br>}<br>学Java，就认准二哥的Java进阶之路<br>No. 309 / 963<br>“好的，二哥，我来消化一下，今天内容真不少。你先去休息一下。”三妹回应到。<br>参考链接：<a target="_blank" rel="noopener" href="https://bbs.huaweicloud.com/blogs/271358，作者：bigsai，整理：沉默王二">https://bbs.huaweicloud.com/blogs/271358，作者：bigsai，整理：沉默王二</a><br>GitHub 上标星 7600+ 的开源知识库《二哥的 Java 进阶之路》第一版 PDF 终于来了！包括Java基础语法、<br>数组&amp;字符串、OOP、集合框架、Java IO、异常处理、Java 新特性、网络编程、NIO、并发编程、JVM等<br>等，共计 32 万余字，可以说是通俗易懂、风趣幽默……详情戳：太赞了，GitHub 上标星 7600+ 的 Java 教<br>程<br>微信搜 沉默王二 或۾描下方二维码关注二哥的原创公众号沉默王二，回复 222 即可免费领取。<br>5.14 Java this和super关键字<br>学Java，就认准二哥的Java进阶之路<br>No. 310 / 963<br>“哥，被喊大舅子的感觉怎么样啊？”三妹不怀好意地对我说，她眼睛里充满着不屑。<br>“说实话，这种感觉还不错。”我有点难为情的回答她，“不过，有一点令我感到些许失落。大家的焦点似乎都<br>是你的颜值，完全忽略了我的盛世美颜啊！”<br>“哥，你想啥呢，那是因为你文章写得好，不然谁认识我是谁啊！有你这样的哥哥，我还是挺自豪的。”三妹<br>郑重其事地说，“话说今天咱学啥呢？”<br>“三妹啊，你这句话说得我喜欢。今天来学习一下 Java 中的 this 关键字吧。”喝了一口农夫山泉后，我对三妹<br>说。<br>“this 关键字有很多种用法，其中最常用的一个是，它可以作为引用变量，指向当前对象。”我面带着朴实无<br>华的微笑继续说，“除此之外， this 关键字还可以完成以下工作。”<br>调用当前类的方法；<br>this() 可以调用当前类的构造方法；<br>this 可以作为参数在方法中传递；<br>this 可以作为参数在构造方法中传递；<br>this 可以作为方法的返回值，返回当前类的对象。<br>01、 指向当前对象<br>“三妹，来看下面这段代码。”话音刚落，我就在键盘上噼里啪啦一阵敲。<br>“在上面的例子中，构造方法的参数名和实例变量名相同，由于没有使用 this 关键字，所以无法为实例变量<br>赋值。”我抬起右手的食指，指着屏幕上的 name 和 age 对着三妹说。<br>“来看一下程序的输出结果。”<br>public class WithoutThisStudent {<br>String name;<br>int age;<br>WithoutThisStudent(String name, int age) {<br>name = name;<br>age = age;<br>}<br>void out() {<br>System.out.println(name+” “ + age);<br>}<br>public static void main(String[] args) {<br>WithoutThisStudent s1 = new WithoutThisStudent(“沉默王二”, 18);<br>WithoutThisStudent s2 = new WithoutThisStudent(“沉默王三”, 16);<br>s1.out();<br>s2.out();<br>}<br>}<br>学Java，就认准二哥的Java进阶之路<br>No. 311 / 963<br>学Java，就认准二哥的Java进阶之路<br>null 0<br>null 0<br>“从结果中可以看得出来，尽管创建对象的时候传递了参数，但实例变量并没有赋值。这是因为如果构造方法<br>中没有使用 this 关键字的话，name 和 age 指向的并不是实例变量而是参数本身。”我把脖子܀向右侧，看<br>着三妹说。<br>“那怎么解决这个问题呢？哥。”三妹着急地问。<br>“如果参数名和实例变量名产生了冲突…..”我正准备给出答案，三妹打断了我。<br>“难道用 this 吗？”三妹脱口而出。<br>“哇，越来越棒了呀，你。”我感觉三妹在学习 Java 这条道路上逐渐有了自己主动思考的意愿。<br>“是的，来看加上 this 关键字后的代码。”<br>安静的屋子里又响起了一阵噼里啪啦的键盘声。<br>public class WithThisStudent {<br>String name;<br>int age;<br>WithThisStudent(String name, int age) {<br>this.name = name;<br>this.age = age;<br>}<br>void out() {<br>System.out.println(name+” “ + age);<br>}<br>public static void main(String[] args) {<br>WithThisStudent s1 = new WithThisStudent(“沉默王二”, 18);<br>WithThisStudent s2 = new WithThisStudent(“沉默王三”, 16);<br>s1.out();<br>s2.out();<br>}<br>}<br>“再来看一下程序的输出结果。”<br>沉默王二 18<br>沉默王三 16<br>“这次，实例变量有值了，在构造方法中， this.xxx 指向的就是实例变量，而不再是参数本身了。”我慢吞<br>吞地说着，“当然了，如果参数名和实例变量名不同的话，就不必使用 this 关键字，但我建议使用 this 关键<br>字，这样的代码更有意义。”<br>No. 312 / 963<br>02、调用当前类的方法<br>“仔细听，三妹，看我敲键盘的速度是不是够快。”<br>“仔细瞧，三妹，上面这段代码中没有见到 this 关键字吧？”我面带着神秘的微笑，准备给三妹变个魔术。<br>“确实没有，哥，我确认过了。”<br>“那接下来，神奇的事情就要发生了。”我突然感觉刘谦附身了。<br>我快速的在 classes 目录下找到 InvokeCurrentClassMethod.class 文件，然后双击打开（IDEA 默认会使用<br>FernFlower 打开字节码文件）。<br>“瞪大眼睛仔细瞧，三妹， this 关键字是不是出现了？”<br>“哇，真的呢，好神奇啊！”三妹为了配合我的演出，也是十二分的卖力。<br>“我们可以在一个类中使用 this 关键字来调用另外一个方法，如果没有使用的话，编译器会自动帮我们加<br>上。”我对自己深厚的编程功底充满自信，“在源代码中， method2() 在调用 method1() 的时候并没有使用<br>this 关键字，但通过反编译后的字节码可以看得到。”<br>public class InvokeCurrentClassMethod {<br>void method1() {}<br>void method2() {<br>method1();<br>}<br>public static void main(String[] args) {<br>new InvokeCurrentClassMethod().method1();<br>}<br>}<br>public class InvokeCurrentClassMethod {<br>public InvokeCurrentClassMethod() {<br>}<br>void method1() {<br>}<br>void method2() {<br>this.method1();<br>}<br>public static void main(String[] args) {<br>(new InvokeCurrentClassMethod()).method1();<br>}<br>}<br>学Java，就认准二哥的Java进阶之路<br>No. 313 / 963<br>03、调用当前类的构造方法<br>“再来看下面这段代码。”<br>“在有参构造方法 InvokeConstrutor(int count) 中，使用了 this() 来调用无参构造方法<br>InvokeConstrutor() 。”这次，我换成了左手的食指，指着屏幕对三妹说，“ this() 可用于调用当前类的<br>构造方法——构造方法可以重用了。”<br>“来看一下输出结果。”<br>“真的啊，无参构造方法也被调用了，所以程序输出了 hello。”三妹看到输出结果后不假思索地说。<br>“也可以在无参构造方法中使用 this() 并传递参数来调用有参构造方法。”话音没落，我就在键盘上敲了起<br>来，“来看下面这段代码。”<br>“再来看一下程序的输出结果。”<br>public class InvokeConstrutor {<br>InvokeConstrutor() {<br>System.out.println(“hello”);<br>}<br>InvokeConstrutor(int count) {<br>this();<br>System.out.println(count);<br>}<br>public static void main(String[] args) {<br>InvokeConstrutor invokeConstrutor = new InvokeConstrutor(10);<br>}<br>}<br>hello<br>10<br>public class InvokeParamConstrutor {<br>InvokeParamConstrutor() {<br>this(10);<br>System.out.println(“hello”);<br>}<br>InvokeParamConstrutor(int count) {<br>System.out.println(count);<br>}<br>public static void main(String[] args) {<br>InvokeParamConstrutor invokeConstrutor = new InvokeParamConstrutor();<br>}<br>}<br>学Java，就认准二哥的Java进阶之路<br>No. 314 / 963<br>“不过，需要注意的是， this() 必须放在构造方法的第一行，否则就报错了。”<br>04、作为参数在方法中传递<br>“来看下面这段代码。”<br>“ this 关键字可以作为参数在方法中传递，此时，它指向的是当前类的对象。”一不小心，半个小时过去<br>了，我感到嗓子冒烟，于是赶紧又喝了一口水，润润嗓子后继续说道。<br>“来看一下输出结果，你就明白了，三妹。”<br>10<br>hello<br>public class ThisAsParam {<br>void method1(ThisAsParam p) {<br>System.out.println(p);<br>}<br>void method2() {<br>method1(this);<br>}<br>public static void main(String[] args) {<br>ThisAsParam thisAsParam = new ThisAsParam();<br>System.out.println(thisAsParam);<br>thisAsParam.method2();<br>}<br>}<br>com.itwanger.twentyseven.ThisAsParam@77459877<br>com.itwanger.twentyseven.ThisAsParam@77459877<br>学Java，就认准二哥的Java进阶之路<br>No. 315 / 963<br>“ method2() 调用了 method1() ，并传递了参数 this， method1() 中打印了当前对象的字符串。 main()<br>方法中打印了 thisAsParam 对象的字符串。从输出结果中可以看得出来，两者是同一个对象。”<br>05、作为参数在构造方法中传递<br>“继续来看代码。”<br>“在构造方法 ThisAsConstrutorParam() 中，我们使用 this 关键字作为参数传递给了 Data 对象，它其实<br>指向的就是 new ThisAsConstrutorParam() 这个对象。”<br>“ this 关键字也可以作为参数在构造方法中传递，它指向的是当前类的对象。当我们需要在多个类中使用一<br>个对象的时候，这非常有用。”<br>“来看一下输出结果。”<br>06、作为方法的返回值<br>“需要休息会吗？三妹”<br>“没事的，哥，我的注意力还是很集中的，你继续讲吧。”<br>“好的，那来继续看代码。”<br>public class ThisAsConstrutorParam {<br>int count = 10;<br>ThisAsConstrutorParam() {<br>Data data = new Data(this);<br>data.out();<br>}<br>public static void main(String[] args) {<br>new ThisAsConstrutorParam();<br>}<br>}<br>class Data {<br>ThisAsConstrutorParam param;<br>Data(ThisAsConstrutorParam param) {<br>this.param = param;<br>}<br>void out() {<br>System.out.println(param.count);<br>}<br>}<br>10<br>学Java，就认准二哥的Java进阶之路<br>No. 316 / 963<br>“ getThisAsMethodResult() 方法返回了 this 关键字，指向的就是 new ThisAsMethodResult() 这个对<br>象，所以可以紧接着调用 out() 方法——达到了链式调用的目的，这也是 this 关键字非常经典的一种用<br>法。”<br>“链式调用的形式在 JavaScript 代码更加常见。”为了向三妹证实这一点，我打开了 jQuery 的源码。<br>“原来这么多链式调用啊！”三妹感叹到。<br>“是的。”我点点头，然后指着 getThisAsMethodResult() 方法的返回值对三妹说，“需要注意的是， this<br>关键字作为方法的返回值的时候，方法的返回类型为类的类型。”<br>“来看一下输出结果。”<br>“那么，关于 this 关键字的介绍，就到此为止了。”我活动了一下僵硬的脖子后，对三妹说，“如果你学习劲头<br>还可以的话，我们顺带把 super 关键字捎带着过一下，怎么样？”<br>“不用了吧，听说 super 关键字更简单，我自己看看就行了，不用你讲了！”<br>“不不不，三妹啊，你得假装听一下，不然我怎么向读者们交差。”<br>“噢噢噢噢。”三妹意味深长地笑了。<br>07、super 关键字<br>“super 关键字的用法主要有三种。”<br>指向父类对象；<br>调用父类的方法；<br>super() 可以调用父类的构造方法。<br>“其实和 this 有些相似，只不过用意不大相同。”我端起水瓶，咕咚咕咚又喝了几大口，好渴。“每当创建一个<br>子类对象的时候，也会隐式的创建父类对象，由 super 关键字引用。”<br>“如果父类和子类拥有同样名称的字段，super 关键字可以用来访问父类的同名字段。”<br>“来看下面这段代码。”<br>public class ThisAsMethodResult {<br>ThisAsMethodResult getThisAsMethodResult() {<br>return this;<br>}<br>void out() {<br>System.out.println(“hello”);<br>}<br>public static void main(String[] args) {<br>new ThisAsMethodResult().getThisAsMethodResult().out();<br>}<br>}<br>hello<br>学Java，就认准二哥的Java进阶之路<br>No. 317 / 963<br>学Java，就认准二哥的Java进阶之路<br>public class ReferParentField {<br>public static void main(String[] args) {<br>new Dog().printColor();<br>}<br>}<br>class Animal {<br>String color = “白色”;<br>}<br>class Dog extends Animal {<br>String color = “黑色”;<br>void printColor() {<br>System.out.println(color);<br>System.out.println(super.color);<br>}<br>}<br>“父类 Animal 中有一个名为 color 的字段，子类 Dog 中也有一个名为 color 的字段，子类的 printColor()<br>方法中，通过 super 关键字可以访问父类的 color。”<br>“来看一下输出结果。”<br>黑色<br>白色<br>“当子类和父类的方法名相同时，可以使用 super 关键字来调用父类的方法。换句话说，super 关键字可以用<br>于方法重写时访问到父类的方法。”<br>public class ReferParentMethod {<br>public static void main(String[] args) {<br>new Dog().work();<br>}<br>}<br>class Animal {<br>void eat() {<br>System.out.println(“吃…”);<br>}<br>}<br>class Dog extends Animal {<br>@Override<br>void eat() {<br>System.out.println(“吃…”);<br>}<br>void bark() {<br>System.out.println(“汪汪汪…”);<br>}<br>No. 318 / 963<br>学Java，就认准二哥的Java进阶之路<br>void work() {<br>super.eat();<br>bark();<br>}<br>}<br>“瞧，三妹。父类 Animal 和子类 Dog 中都有一个名为 eat() 的方法，通过 super.eat() 可以访问到父类<br>的 eat() 方法。”<br>等三妹在自我消化的时候，我在键盘上又敲完了一串代码。<br>public class ReferParentConstructor {<br>public static void main(String[] args) {<br>new Dog();<br>}<br>}<br>class Animal {<br>Animal(){<br>System.out.println(“动物来了”);<br>}<br>}<br>class Dog extends Animal {<br>Dog() {<br>super();<br>System.out.println(“狗狗来了”);<br>}<br>}<br>“子类 Dog 的构造方法中，第一行代码为 super() ，它就是用来调用父类的构造方法的。”<br>“来看一下输出结果。”<br>动物来了<br>狗狗来了<br>“当然了，在默认情况下， super() 是可以省略的，编译器会主动去调用父类的构造方法。也就是说，子类<br>即使不使用 super() 主动调用父类的构造方法，父类的构造方法仍然会先执行。”<br>public class ReferParentConstructor {<br>public static void main(String[] args) {<br>new Dog();<br>}<br>}<br>class Animal {<br>Animal(){<br>System.out.println(“动物来了”);<br>No. 319 / 963<br>学Java，就认准二哥的Java进阶之路<br>}<br>}<br>class Dog extends Animal {<br>Dog() {<br>System.out.println(“狗狗来了”);<br>}<br>}<br>“输出结果和之前一样。”<br>动物来了<br>狗狗来了<br>“ super() 也可以用来调用父类的有参构造方法，这样可以提高代码的可重用性。”<br>class Person {<br>int id;<br>String name;<br>Person(int id, String name) {<br>this.id = id;<br>this.name = name;<br>}<br>}<br>class Emp extends Person {<br>float salary;<br>Emp(int id, String name, float salary) {<br>super(id, name);<br>this.salary = salary;<br>}<br>void display() {<br>System.out.println(id + “ “ + name + “ “ + salary);<br>}<br>}<br>public class CallParentParamConstrutor {<br>public static void main(String[] args) {<br>new Emp(1, “沉默王二”, 20000f).display();<br>}<br>}<br>“Emp 类继承了 Person 类，也就继承了 id 和 name 字段，当在 Emp 中新增了 salary 字段后，构造方法中<br>就可以使用 super(id, name) 来调用父类的有参构造方法。”<br>“来看一下输出结果。”<br>No. 320 / 963<br>三妹点了点头，所有所思。<br>GitHub 上标星 7600+ 的开源知识库《二哥的 Java 进阶之路》第一版 PDF 终于来了！包括Java基础语法、<br>数组&amp;字符串、OOP、集合框架、Java IO、异常处理、Java 新特性、网络编程、NIO、并发编程、JVM等<br>等，共计 32 万余字，可以说是通俗易懂、风趣幽默……详情戳：太赞了，GitHub 上标星 7600+ 的 Java 教<br>程<br>微信搜 沉默王二 或۾描下方二维码关注二哥的原创公众号沉默王二，回复 222 即可免费领取。<br>5.15 Java static关键字<br>“哥，你牙龈肿痛轻点没？周一的《教妹学 Java》（二哥的Java进阶之路前身）你都没有更新，偷懒了呀！”<br>三妹关心地问我。<br>“今天周四了，吃了三天的药，疼痛已经减轻不少，咱妈还给我打了电话，让我买点牛黄解毒片下下火。”我<br>面带着微笑对三妹说，“学习可不能落下，今天我们来学 Java 中 static 关键字吧。”<br>“static 是 Java 中比较难以理解的一个关键字，也是各大公司的面试官最喜欢问到的一个知识点之一。”我喝<br>了一口咖啡继续说道。<br>“既然是面试重点，那我可得好好学习下。”三妹连忙说。<br>“static 关键字的作用可以用一句话来描述：‘方便在没有创建对象的情况下进行调用，包括变量和方法’。也就<br>是说，只要类被加载了，就可以通过类名进行访问。”我扶了扶沉重眼镜，继续说到，“static 可以用来修饰类<br>的成员变量，以及成员方法。我们一个个来看。”<br>1 沉默王二 20000.0<br>学Java，就认准二哥的Java进阶之路<br>No. 321 / 963<br>01、静态变量<br>“如果在声明变量的时候使用了 static 关键字，那么这个变量就被称为静态变量。静态变量只在类加载的时候<br>获取一次内存空间，这使得静态变量很节省内存空间。”家里的暖气有点足，我跑去开了一点窗户后继续说<br>道。<br>“来考虑这样一个 Student 类。”话音刚落，我就在键盘上噼里啪啦一阵敲。<br>这段代码敲完后，我对三妹说：“假设郑州大学录取了一万名新生，那么在创建一万个 Student 对象的时候，<br>所有的字段（name、age 和 school）都会获取到一块内存。学生的姓名和年纪不尽相同，但都属于郑州大<br>学，如果每创建一个对象，school 这个字段都要占用一块内存的话，就很浪费，对吧？三妹。”<br>“因此，最好将 school 这个字段设置为 static，这样就只会占用一块内存，而不是一万块。”<br>安静的房子里又响起了一阵噼里啪啦的键盘声。<br>“瞧，三妹。s1 和 s2 这两个引用变量存放在栈区（stack），沉默王二+18 这个对象和沉默王三+16 这个对<br>象存放在堆区（heap），school 这个静态变量存放在静态区。”<br>“等等，哥，栈、堆、静态区？”三妹的脸上塞满了疑惑。<br>“哦哦，别担心，三妹，画幅图你就全明白了。”说完我就打开 draw.io 这个网址，认真地画起了图。<br>public class Student {<br>String name;<br>int age;<br>String school = “郑州大学”;<br>}<br>public class Student {<br>String name;<br>int age;<br>static String school = “郑州大学”;<br>public Student(String name, int age) {<br>this.name = name;<br>this.age = age;<br>}<br>public static void main(String[] args) {<br>Student s1 = new Student(“沉默王二”, 18);<br>Student s2 = new Student(“沉默王三”, 16);<br>}<br>}<br>学Java，就认准二哥的Java进阶之路<br>No. 322 / 963<br>学Java，就认准二哥的Java进阶之路<br>“现在，是不是一下子就明白了？”看着这幅漂亮的手绘图，我心里有点小开心。<br>“哇，哥，惊艳了呀！”三妹也不忘拍马屁，给我了一个大大的赞。<br>“好了，三妹，我们来看下面这串代码。”<br>public class Counter {<br>int count = 0;<br>Counter() {<br>count++;<br>System.out.println(count);<br>}<br>public static void main(String args[]) {<br>Counter c1 = new Counter();<br>Counter c2 = new Counter();<br>Counter c3 = new Counter();<br>}<br>}<br>“我们创建一个成员变量 count，并且在构造函数中让它自增。因为成员变量会在创建对象的时候获取内存，<br>因此每一个对象都会有一个 count 的副本， count 的值并不会随着对象的增多而递增。”<br>我在侃侃而谈，而三妹似乎有些不太明白。<br>No. 323 / 963<br>学Java，就认准二哥的Java进阶之路<br>“没关系，三妹，你先盲猜一下，这段代码输出的结果是什么？”<br>“按照你的逻辑，应该输出三个 1？是这样吗？”三妹眨眨眼，有点不太自信地回答。<br>“哎呀，不错哟。”<br>我在 IDEA 中点了一下运行按钮，程序跑了起来。<br>1<br>1<br>1<br>“每创建一个 Counter 对象，count 的值就从 0 自增到 1。三妹，想一下，如果 count 是静态的呢？”<br>“我不知道啊。”<br>“嗯，来看下面这段代码。”<br>public class StaticCounter {<br>static int count = 0;<br>StaticCounter() {<br>count++;<br>System.out.println(count);<br>}<br>public static void main(String args[]) {<br>StaticCounter c1 = new StaticCounter();<br>StaticCounter c2 = new StaticCounter();<br>StaticCounter c3 = new StaticCounter();<br>}<br>}<br>“来看一下输出结果。”<br>1<br>2<br>3<br>No. 324 / 963<br>“简单解释一下哈，由于静态变量只会获取一次内存空间，所以任何对象对它的修改都会得到保留，所以每创<br>建一个对象，count 的值就会加 1，所以最终的结果是 3，明白了吧？三妹。这就是静态变量和成员变量之<br>间的差别。”<br>“另外，需要注意的是，由于静态变量属于一个类，所以不要通过对象引用来访问，而应该直接通过类名来访<br>问，否则编译器会发出警告。”<br>02、静态方法<br>“说完静态变量，我们来说静态方法。”说完，我准备点一支华子来抽，三妹阻止了我，她指一指烟盒上的<br>「吸烟有害身体健康」，我笑了。<br>“好吧。”我只好喝了一口咖啡继续说，“如果方法上加了 static 关键字，那么它就是一个静态方法。”<br>“静态方法有以下这些特征。”<br>静态方法属于这个类而不是这个类的对象；<br>调用静态方法的时候不需要创建这个类的对象；<br>静态方法可以访问静态变量。<br>“来，继续上代码”<br>public class StaticMethodStudent {<br>String name;<br>int age;<br>static String school = “郑州大学”;<br>public StaticMethodStudent(String name, int age) {<br>this.name = name;<br>this.age = age;<br>}<br>static void change() {<br>school = “河南大学”;<br>}<br>void out() {<br>System.out.println(name + “ “ + age + “ “ + school);<br>}<br>public static void main(String[] args) {<br>StaticMethodStudent.change();<br>StaticMethodStudent s1 = new StaticMethodStudent(“沉默王二”, 18);<br>StaticMethodStudent s2 = new StaticMethodStudent(“沉默王三”, 16);<br>学Java，就认准二哥的Java进阶之路<br>No. 325 / 963<br>学Java，就认准二哥的Java进阶之路<br>s1.out();<br>s2.out();<br>}<br>}<br>“仔细听，三妹。 change() 方法就是一个静态方法，所以它可以直接访问静态变量 school，把它的值更改<br>为河南大学；并且，可以通过类名直接调用 change() 方法，就像 StaticMethodStudent.change() 这<br>样。”<br>“来看一下程序的输出结果吧。”<br>沉默王二 18 河南大学<br>沉默王三 16 河南大学<br>“需要注意的是，静态方法不能访问非静态变量和调用非静态方法。你看，三妹，我稍微改动一下代码，编译<br>器就会报错。”<br>“先是在静态方法中访问非静态变量，编译器不允许。”<br>“然后在静态方法中访问非静态方法，编译器同样不允许。”<br>“关于静态方法的使用，这下清楚了吧，三妹？”<br>看着三妹点点头，我欣慰地笑了。<br>“哥，我想到了一个问题，为什么 main 方法是静态的啊？”没想到，三妹串联知识点的功力还是不错的。<br>“如果 main 方法不是静态的，就意味着 Java 虚拟机在执行的时候需要先创建一个对象才能调用 main 方法，<br>而 main 方法作为程序的入口，创建一个额外的对象显得非常多余。”我不假思索的回答令三妹感到非常的钦<br>佩。<br>“java.lang.Math 类的几乎所有方法都是静态的，可以直接通过类名来调用，不需要创建类的对象。”<br>No. 326 / 963<br>03、静态代码块<br>“三妹，站起来活动一下，我的脖子都有点僵硬了。”<br>我们一起走到窗户边，映入眼帘的是从天而降的雪花。三妹和我都高兴坏了，迫不及待地打开窗口，伸出手<br>去触摸雪花的温度，那种稍纵即逝的冰凉，真的舒服极了。<br>“北国风光，千里冰封，万里雪飘。望长城内外，惟余莽莽；大河上下，顿失滔滔。山舞银蛇，原驰蜡象，欲<br>与天公试比高。须晴日，看红装素裹，分外妖娆。。。。。。”三妹竟然情不自禁地朗诵起了《沁园春·<br>雪》。<br>确实令人欣喜，这是 2020 年洛阳的第一场雪，的确令人感到开心。<br>片刻之后。<br>“除了静态变量和静态方法，static 关键字还有一个重要的作用。”我心情愉悦地对三妹说，“用一个 static 关<br>键字，外加一个大括号括起来的代码被称为静态代码块。”<br>“就像下面这串代码。”<br>“静态代码块通常用来初始化一些静态变量，它会优先于 main() 方法执行。”<br>“来看一下程序的输出结果吧。”<br>public class StaticBlock {<br>static {<br>System.out.println(“静态代码块”);<br>}<br>public static void main(String[] args) {<br>System.out.println(“main 方法”);<br>}<br>}<br>静态代码块<br>main 方法<br>学Java，就认准二哥的Java进阶之路<br>No. 327 / 963<br>“二哥，既然静态代码块先于 main() 方法执行，那没有 main() 方法的 Java 类能执行成功吗？”三妹的脑<br>回路越来越令我敬佩了。<br>“Java 1.6 是可以的，但 Java 7 开始就无法执行了。”我胸有成竹地回答到。<br>“在命令行中执行 java StaticBlockNoMain 的时候，会抛出 NoClassDefFoundError 的错误。”<br>“三妹，来看下面这个例子。”<br>“writes 是一个静态的 ArrayList，所以不太可能在声明的时候完成初始化，因此需要在静态代码块中完成初<br>始化。”<br>“静态代码块在初始集合的时候，真的非常有用。在实际的项目开发中，通常使用静态代码块来加载配置文件<br>到内存当中。”<br>04、静态内部类<br>“三妹啊，除了以上只写，static 还有一个不太常用的功能——静态内部类。”<br>“Java 允许我们在一个类中声明一个内部类，它提供了一种令人信服的方式，允许我们只在一个地方使用一些<br>变量，使代码更具有条理性和可读性。”<br>“常见的内部类有四种，成员内部类、局部内部类、匿名内部类和静态内部类，限于篇幅原因，前三种不在我<br>们本次的讨论范围之内，以后有机会再细说。”<br>public class StaticBlockNoMain {<br>static {<br>System.out.println(“静态代码块，没有 main”);<br>}<br>}<br>public class StaticBlockDemo {<br>public static List<String> writes = new ArrayList&lt;&gt;();<br>static {<br>writes.add(“沉默王二”);<br>writes.add(“沉默王三”);<br>writes.add(“沉默王四”);<br>System.out.println(“第一块”);<br>}<br>static {<br>writes.add(“沉默王五”);<br>writes.add(“沉默王六”);<br>System.out.println(“第二块”);<br>}<br>}<br>学Java，就认准二哥的Java进阶之路<br>No. 328 / 963<br>学Java，就认准二哥的Java进阶之路<br>“来看下面这个例子。”三妹有点走神，我敲了敲她的脑袋后继续说。<br>public class Singleton {<br>private Singleton() {}<br>private static class SingletonHolder {<br>public static final Singleton instance = new Singleton();<br>}<br>public static Singleton getInstance() {<br>return SingletonHolder.instance;<br>}<br>}<br>“三妹，打起精神，马上就结束了。”<br>“哦哦，这段代码看起来很别致啊，哥。”<br>“是的，三妹，这段代码在以后创建单例的时候还会见到。”<br>“第一次加载 Singleton 类时并不会初始化 instance，只有第一次调用 getInstance() 方法时 Java 虚拟机<br>才开始加载 SingletonHolder 并初始化 instance，这样不仅能确保线程安全，也能保证 Singleton 类的唯一<br>性。不过，创建单例更优雅的一种方式是使用枚举，以后再讲给你听。”<br>“需要注意的是。第一，静态内部类不能访问外部类的所有成员变量；第二，静态内部类可以访问外部类的所<br>有静态变量，包括私有静态变量。第三，外部类不能声明为 static。”<br>“三妹，你看，在 Singleton 类上加 static 后，编译器就提示错误了。”<br>三妹点了点头，所有所思。<br>GitHub 上标星 7600+ 的开源知识库《二哥的 Java 进阶之路》第一版 PDF 终于来了！包括Java基础语法、<br>数组&amp;字符串、OOP、集合框架、Java IO、异常处理、Java 新特性、网络编程、NIO、并发编程、JVM等<br>等，共计 32 万余字，可以说是通俗易懂、风趣幽默……详情戳：太赞了，GitHub 上标星 7600+ 的 Java 教<br>程<br>微信搜 沉默王二 或۾描下方二维码关注二哥的原创公众号沉默王二，回复 222 即可免费领取。<br>No. 329 / 963<br>5.16 Java final关键字<br>“哥，今天学什么呢？”<br>“今天学一个重要的关键字——final。 ”我面带着朴实无华的微笑回答着她，“对了，三妹，你打算考研吗？”<br>“还没想过，我今年才大一呢，到时候再说吧，你决定。”<br>“好吧。”我摊摊手，表示很无辜，真的是所有的决定都交给我这个哥哥了，如果决定错了，锅得背上。<br>01、final 变量<br>“好了，我们先来看 final 修饰的变量吧！”<br>“被 final 修饰的变量无法重新赋值。换句话说，final 变量一旦初始化，就无法更改。”<br>“来看这行代码。”<br>“当尝试将 age 的值修改为 30 的时候，编译器就生气了。”<br>“再来看这段代码。”<br>final int age = 18;<br>学Java，就认准二哥的Java进阶之路<br>No. 330 / 963<br>学Java，就认准二哥的Java进阶之路<br>public class Pig {<br>private String name;<br>public String getName() {<br>return name;<br>}<br>public void setName(String name) {<br>this.name = name;<br>}<br>}<br>“这是一个很普通的 Java 类，它有一个字段 name。”<br>“然后，我们创建一个测试类，并声明一个 final 修饰的 Pig 对象。”<br>final Pig pig = new Pig();<br>“如果尝试将 pig 重新赋值的话，编译器同样会生气。”<br>“但我们仍然可以去修改 pig 对象的 name。”<br>final Pig pig = new Pig();<br>pig.setName(“特立独行”);<br>System.out.println(pig.getName()); // 特立独行<br>“另外，final 修饰的成员变量必须有一个默认值，否则编译器将会提醒没有初始化。”<br>“final 和 static 一起修饰的成员变量叫做常量，常量名必须全部大写。”<br>public class Pig {<br>private final int age = 1;<br>public static final double PRICE = 36.5;<br>}<br>“有时候，我们还会用 final 关键字来修饰参数，它意味着参数在方法体内不能被再修改。”<br>“来看下面这段代码。”<br>No. 331 / 963<br>“如果尝试去修改它的话，编译器会提示以下错误。”<br>02、final 方法<br>“被 final 修饰的方法不能被重写。如果我们在设计一个类的时候，认为某些方法不应该被重写，就应该把它<br>设计成 final 的。”<br>“Thread 类就是一个例子，它本身不是 final 的，这意味着我们可以扩展它，但它的 isAlive() 方法是<br>final 的。”<br>“需要注意的是，该方法是一个本地（native）方法，用于确认线程是否处于活跃状态。而本地方法是由操作<br>系统决定的，因此重写该方法并不容易实现。”<br>“来看这段代码。”<br>“当我们想要重写该方法的话，就会出现编译错误。”<br>public class ArgFinalTest {<br>public void arg(final int age) {<br>}<br>public void arg1(final String name) {<br>}<br>}<br>public class Thread implements Runnable {<br>public final native boolean isAlive();<br>}<br>public class Actor {<br>public final void show() {<br>}<br>}<br>学Java，就认准二哥的Java进阶之路<br>No. 332 / 963<br>“三妹，来问你一个问题吧。”正想趁三妹回答问题的时候喝口水。<br>“你说吧，哥。”<br>“一个类是 final 的，和一个类不是 final，但它所有的方法都是 final 的，考虑一下，它们之间有什么区别？”<br>“我能想到的一点，就是前者不能被继承，也就是说方法无法被重写；后者呢，可以被继承，然后追加一些非<br>final 的方法。”还没等我把水咽下去，三妹就回答好了，着实惊呆了我。<br>“嗯嗯嗯，没毛病没毛病，进步很大啊！”<br>“那必须啊，谁叫我是你妹呢。”<br>03、final 类<br>“如果一个类使用了 final 关键字修饰，那么它就无法被继承…..”<br>“等等，哥，我知道，String 类就是一个 final 类。”还没等我说完，三妹就抢着说到。<br>“说得没毛病。”<br>“那三妹你知道为什么 String 类要设计成 final 吗？”<br>“这个还真不知道。”三妹的表情透露出这种无奈。<br>“原因大致有 3 个。”<br>为了实现字符串常量池<br>为了线程安全<br>为了 HashCode 的不可变性<br>“想了解更详细的原因，可以一会看看我之前写的这篇文章。”<br>为什么 Java 字符串是不可变的？<br>“任何尝试从 final 类继承的行为将会引发编译错误。来看这段代码。”<br>public final class String<br>implements java.io.Serializable, Comparable<String>, CharSequence,<br>Constable, ConstantDesc {}<br>学Java，就认准二哥的Java进阶之路<br>No. 333 / 963<br>学Java，就认准二哥的Java进阶之路<br>public final class Writer {<br>private String name;<br>public String getName() {<br>return name;<br>}<br>public void setName(String name) {<br>this.name = name;<br>}<br>}<br>“尝试去继承它，编译器会提示以下错误，Writer 类是 final 的，无法继承。”<br>“不过，类是 final 的，并不意味着该类的对象是不可变的。”<br>“来看这段代码。”<br>Writer writer = new Writer();<br>writer.setName(“沉默王二”);<br>System.out.println(writer.getName()); // 沉默王二<br>“Writer 的 name 字段的默认值是 null，但可以通过 settter 方法将其更改为沉默王二。也就是说，如果一个<br>类只是 final 的，那么它并不是不可变的全部条件。”<br>“关于不可变类，我们留到后面来细讲。”<br>不可变类<br>“把一个类设计成 final 的，有其安全方面的考虑，但不应该故意为之，因为把一个类定义成 final 的，意味着<br>它没办法继承，假如这个类的一些方法存在一些问题的话，我们就无法通过重写的方式去修复它。”<br>“三妹，final 关键字我们就学到这里吧，你一会再学习一下 Java 字符串为什么是不可变的和不可变类。”我揉<br>一揉犯困的双眼，疲惫地给三妹说，“学完这两个知识点，你会对 final 的认知更清晰一些。”<br>“好的，二哥，我这就去学习去。你去休息会。”<br>我起身站到阳台上，看着窗外的车水马龙，不一会儿，就发起来呆。<br>“好想去再看一场周杰伦的演唱会，不知道 2021 有没有这个机会。”<br>我心里这样想着，天渐渐地暗了下来。<br>GitHub 上标星 7600+ 的开源知识库《二哥的 Java 进阶之路》第一版 PDF 终于来了！包括Java基础语法、<br>数组&amp;字符串、OOP、集合框架、Java IO、异常处理、Java 新特性、网络编程、NIO、并发编程、JVM等<br>等，共计 32 万余字，可以说是通俗易懂、风趣幽默……详情戳：太赞了，GitHub 上标星 7600+ 的 Java 教<br>程<br>微信搜 沉默王二 或۾描下方二维码关注二哥的原创公众号沉默王二，回复 222 即可免费领取。<br>No. 334 / 963<br>5.17 Java instanceof关键字<br>“三妹，今天我们来过一个非常简单的知识点，instanceof关键字。”<br>“用不着哥你来讲了，今天就换个形式，我来讲给你听。”三妹雄赳赳气昂昂地说。<br>instanceof 关键字的用法其实很简单：<br>用意也非常简单，判断对象是否符合指定的类型，结果要么是 true，要么是 false。在反序列化的时候，<br>instanceof 操作符还是蛮常用的，因为这时候我们不太确定对象属不属于指定的类型，如果不进行判断的<br>话，就容易抛出 ClassCastException 异常。<br>我们来建这样一个简单的类 Round：<br>然后新增一个扩展类 Ring：<br>这时候，我们就可以通过 instanceof 来检查 Ring 对象是否属于 Round 类型。<br>结果会输出 true，因为 Ring 继承了 Round，也就意味着 Ring 和 Round 符合 is-a 的关系，而 instanceof<br>操作符正是基于类与类之间的继承关系，以及类与接口之间的实现关系的。<br>(object) instanceof (type)<br>class Round {<br>}<br>class Ring extends Round {<br>}<br>Ring ring = new Ring();<br>System.out.println(ring instanceof Round);<br>学Java，就认准二哥的Java进阶之路<br>No. 335 / 963<br>学Java，就认准二哥的Java进阶之路<br>我们再来新建一个接口 Shape：<br>interface Shape {<br>}<br>然后新建 Circle 类实现 Shape 接口并继承 Round 类：<br>class Circle extends Round implements Shape {<br>}<br>如果对象是由该类创建的，那么 instanceof 的结果肯定为 true。<br>Circle circle = new Circle();<br>System.out.println(circle instanceof Circle);<br>这个肯定没毛病，instanceof 就是干这个活的，大家也很好理解。那如果类型是父类呢？<br>System.out.println(circle instanceof Round);<br>结果肯定还是 true，因为依然符合 is-a 的关系。那如果类型为接口呢？<br>System.out.println(circle instanceof Shape);<br>结果仍然为 true， 因为也符合 is-a 的关系。如果要比较的对象和要比较的类型之间没有关系，当然是不<br>能使用 instanceof 进行比较的。<br>为了验证这一点，我们来创建一个实现了 Shape 但与 Circle 无关的 Triangle 类：<br>class Triangle implements Shape {<br>}<br>这时候，再使用 instanceof 进行比较的话，编译器就报错了。<br>System.out.println(circle instanceof Triangle);<br>错误信息如下所示：<br>Inconvertible types; cannot cast ‘com.itwanger.twentyfour.instanceof1.Circle’ to<br>‘com.itwanger.twentyfour.instanceof1.Triangle’<br>意思就是类型不匹配，不能转换，我们使用 instanceof 比较的目的，也就是希望如果结果为 true 的时候能<br>进行类型转换。但显然 Circle 不能转为 Triangle。<br>编译器已经提前帮我们预知了，很聪明。<br>Java 是一门面向对象的编程语言，也就意味着除了基本数据类型，所有的类都会隐式继承 Object 类。所以<br>下面的结果肯定也会输出 true。<br>No. 336 / 963<br>学Java，就认准二哥的Java进阶之路<br>Thread thread = new Thread();<br>System.out.println(thread instanceof Object);<br>“那如果对象为 null 呢？”我这时候插话了。<br>“这个还真的是一个好问题啊。”三妹忍不住对我竖了一个大拇指。<br>System.out.println(null instanceof Object);<br>只有对象才会有 null 值，所以编译器是不会报错的，只不过，对于 null 来说，instanceof 的结果为 false。<br>因为所有的对象都可以为 null，所以也不好确定 null 到底属于哪一个类。<br>通常，我们是这样使用 instanceof 操作符的。<br>// 先判断类型<br>if (obj instanceof String) {<br>// 然后强制转换<br>String s = (String) obj;<br>// 然后才能使用<br>}<br>先用 instanceof 进行类型判断，然后再把 obj 强制转换成我们期望的类型再进行使用。<br>JDK 16 的时候，instanceof 模式匹配转了正，意味着使用 instanceof 的时候更便捷了。<br>if (obj instanceof String s) {<br>// 如果类型匹配 直接使用 s<br>}<br>可以直接在 if 条件判断类型的时候添加一个变量，就不需要再强转和声明新的变量了。<br>“哇，这样就简洁了呀！”为了配合三妹，我不仅惊叹到！<br>“好了，关于 instanceof 操作符我们就先讲到这吧，难是一点都不难，希望哥也能够很好的掌握。”三妹笑嘻<br>嘻地说，看来她很享受这个讲的过程嘛。<br>GitHub 上标星 7600+ 的开源知识库《二哥的 Java 进阶之路》第一版 PDF 终于来了！包括Java基础语法、<br>数组&amp;字符串、OOP、集合框架、Java IO、异常处理、Java 新特性、网络编程、NIO、并发编程、JVM等<br>等，共计 32 万余字，可以说是通俗易懂、风趣幽默……详情戳：太赞了，GitHub 上标星 7600+ 的 Java 教<br>程<br>微信搜 沉默王二 或۾描下方二维码关注二哥的原创公众号沉默王二，回复 222 即可免费领取。<br>No. 337 / 963<br>5.18 Java不可变对象<br>“二哥，你能给我说说为什么 String 是 immutable 类（不可变对象）吗？我想研究它，想知道为什么它就不<br>可变了，这种强烈的愿望就像想研究浩瀚的星空一样。但无奈自身功力有限，始终觉得雾里看花终隔一层。”<br>三妹的这句话里满是彩虹屁的味道。<br>“既然三妹你说话这么好听，那我们就开始吧！”我愉快的心情就好像吃了两罐蜂蜜一样（ ）。<br>01、什么是不可变类<br>一个类的对象在通过构造方法创建后如果状态不会再被改变，那么它就是一个不可变（immutable）类。它<br>的所有成员变量的赋值仅在构造方法中完成，不会提供任何 setter 方法供外部类去修改。<br>还记得《神雕侠侣》中小龙女的古墓吗？随着那一声巨响，仅有的通道就被无情地关闭了。别较真那个密<br>道，我这么说只是为了打开你的想象力，让你对不可变类有一个更直观的印象。<br>自从有了多线程，生产力就被无限地放大了，所有的程序员都爱它，因为强大的硬件能力被充分地利用了。<br>但与此同时，所有的程序员都对它心生忌惮，因为一不小心，多线程就会把对象的状态变得混乱不堪。<br>为了保护状态的原子性、可见性、有序性，我们程序员可以说是竭尽所能。其中，synchronized（同步）关<br>键字是最简单最入门的一种解决方案。<br>假如说类是不可变的，那么对象的状态就也是不可变的。这样的话，每次修改对象的状态，就会产生一个新<br>的对象供不同的线程使用，我们程序员就不必再担心并发问题了。<br>02、常见的不可变类<br>提到不可变类，几乎所有的程序员第一个想到的，就是 String 类。那为什么 String 类要被设计成不可变的<br>呢？<br>学Java，就认准二哥的Java进阶之路<br>No. 338 / 963<br>1）常量池的需要<br>字符串常量池是 Java 堆内存中一个特殊的存储区域，当创建一个 String 对象时，假如此字符串在常量池中<br>不存在，那么就创建一个；假如已经存，就不会再创建了，而是直接引用已经存在的对象。这样做能够减少<br>JVM 的内存开销，提高效率。<br>2）hashCode 需要<br>因为字符串是不可变的，所以在它创建的时候，其 hashCode 就被缓存了，因此非常适合作为哈希值（比如<br>说作为 HashMap 的键），多次调用只返回同一个值，来提高效率。<br>3）线程安全<br>就像之前说的那样，如果对象的状态是可变的，那么在多线程环境下，就很容易造成不可预期的结果。而<br>String 是不可变的，就可以在多个线程之间共享，不需要同步处理。<br>因此，当我们调用 String 类的任何方法（比如说 trim() 、 substring() 、 toLowerCase() ）时，总会返<br>回一个新的对象，而不影响之前的值。<br>虽然调用 substring() 方法对 cmower 进行了截取，但 cmower 的值没有改变。<br>除了 String 类，包装器类 Integer、Long 等也是不可变类。<br>03、手撸一个不可变类<br>看懂一个不可变类也许容易，但要创建一个自定义的不可变类恐怕就有点难了。但知难而进是我们作为一名<br>优秀的程序员不可或缺的品质，正因为不容易，我们才能真正地掌握它。<br>接下来，就请和我一起，来自定义一个不可变类吧。一个不可变类，必须要满足以下 4 个条件：<br>1）确保类是 final 的，不允许被其他类继承*。<br>2）确保所有的成员变量（字段）是 final 的，这样的话，它们就只能在构造方法中初始化值，并且不会在随<br>后被修改。<br>3）不要提供任何 setter 方法。<br>4）如果要修改类的状态，必须返回一个新的对象。<br>按照以上条件，我们来自定义一个简单的不可变类 Writer。<br>String cmower = “沉默王二，一枚有趣的程序员”;<br>cmower.substring(0,4);<br>System.out.println(cmower);// 沉默王二，一枚有趣的程序员<br>public final class Writer {<br>private final String name;<br>private final int age;<br>public Writer(String name, int age) {<br>this.name = name;<br>this.age = age;<br>}<br>学Java，就认准二哥的Java进阶之路<br>No. 339 / 963<br>学Java，就认准二哥的Java进阶之路<br>public int getAge() {<br>return age;<br>}<br>public String getName() {<br>return name;<br>}<br>}<br>Writer 类是 final 的，name 和 age 也是 final 的，没有 setter 方法。<br>OK，据说这个作者分享了很多博客，广受读者的喜爱，因此某某出版社找他写了一本书（Book）。Book 类<br>是这样定义的：<br>public class Book {<br>private String name;<br>private int price;<br>public String getName() {<br>return name;<br>}<br>public void setName(String name) {<br>this.name = name;<br>}<br>public int getPrice() {<br>return price;<br>}<br>public void setPrice(int price) {<br>this.price = price;<br>}<br>@Override<br>public String toString() {<br>return “Book{“ +<br>“name=’” + name + ‘\’’ +<br>“, price=” + price +<br>‘}’;<br>}<br>}<br>2 个字段，分别是 name 和 price，以及 getter 和 setter，重写后的 toString() 方法。然后，在 Writer<br>类中追加一个可变对象字段 book。<br>public final class Writer {<br>private final String name;<br>private final int age;<br>private final Book book;<br>No. 340 / 963<br>学Java，就认准二哥的Java进阶之路<br>public Writer(String name, int age, Book book) {<br>this.name = name;<br>this.age = age;<br>this.book = book;<br>}<br>public int getAge() {<br>return age;<br>}<br>public String getName() {<br>return name;<br>}<br>public Book getBook() {<br>return book;<br>}<br>}<br>并在构造方法中追加了 Book 参数，以及 Book 的 getter 方法。<br>完成以上工作后，我们来新建一个测试类，看看 Writer 类的状态是否真的不可变。<br>public class WriterDemo {<br>public static void main(String[] args) {<br>Book book = new Book();<br>book.setName(“二哥的 Java 进阶之路”);<br>book.setPrice(79);<br>Writer writer = new Writer(“沉默王二”,18, book);<br>System.out.println(“定价：” + writer.getBook());<br>writer.getBook().setPrice(59);<br>System.out.println(“促销价：” + writer.getBook());<br>}<br>}<br>程序输出的结果如下所示：<br>定价：Book{name=’二哥的 Java 进阶之路’, price=79}<br>促销价：Book{name=’二哥的 Java 进阶之路’, price=59}<br>糟糕，Writer 类的不可变性被破坏了，价格发生了变化。为了解决这个问题，我们需要为不可变类的定义规<br>则追加一条内容：<br>如果一个不可变类中包含了可变类的对象，那么就需要确保返回的是可变对象的副本。也就是说，Writer 类<br>中的 getBook() 方法应该修改为：<br>No. 341 / 963<br>这样的话，构造方法初始化后的 Book 对象就不会再被修改了。此时，运行 WriterDemo，就会发现价格不<br>再发生变化了。<br>04、总结<br>不可变类有很多优点，就像之前提到的 String 类那样，尤其是在多线程环境下，它非常的安全。尽管每次修<br>改都会创建一个新的对象，增加了内存的消耗，但这个缺点相比它带来的优点，显然是微不足道的——无非<br>就是捡了西瓜，丢了芝麻。<br>“好了，三妹，你应该理解了吧？”<br>“嗯，哥，你这本《Java 进阶之路》还没有出书吧？”三妹质疑道。<br>“害，出版社都找过来要签合同了，我只好推脱说 GitHub 破 1 万 star 再考虑，先优化吧，后面看机会。”<br>“哦哦，原来如此啊。”三妹释然道。<br>GitHub 上标星 7600+ 的开源知识库《二哥的 Java 进阶之路》第一版 PDF 终于来了！包括Java基础语法、<br>数组&amp;字符串、OOP、集合框架、Java IO、异常处理、Java 新特性、网络编程、NIO、并发编程、JVM等<br>等，共计 32 万余字，可以说是通俗易懂、风趣幽默……详情戳：太赞了，GitHub 上标星 7600+ 的 Java 教<br>程<br>微信搜 沉默王二 或۾描下方二维码关注二哥的原创公众号沉默王二，回复 222 即可免费领取。<br>public Book getBook() {<br>Book clone = new Book();<br>clone.setPrice(this.book.getPrice());<br>clone.setName(this.book.getName());<br>return clone;<br>}<br>定价：Book{name=’二哥的 Java 进阶之路’, price=79}<br>促销价：Book{name=’二哥的 Java 进阶之路’, price=79}<br>学Java，就认准二哥的Java进阶之路<br>No. 342 / 963<br>5.19 Java方法重写和方法重载<br>入冬的夜，总是来得特别的早。我静静地站在阳台，目光所及之处，不过是若隐若现的钢筋混凝土，还有那<br>毫无情调的灯光。<br>“哥，别站在那发呆了。今天学啥啊，七点半我就要回学校了，留给你的时间不多了，你要抓紧哦。”三妹傲<br>娇的声音一下子把我从游离的状态拉回到了现实。<br>“今天要学习 Java 中的方法重载与方法重写。”我迅速地走到电脑前面，打开一份 Excel 文档，看了一下《教<br>妹学 Java（二哥的 Java 进阶之路前身）》的进度，然后对三妹说。<br>“如果一个类有多个名字相同但参数个数不同的方法，我们通常称这些方法为方法重载。 ”我面带着朴实无华<br>的微笑继续说，“如果方法的功能是一样的，但参数不同，使用相同的名字可以提高程序的可读性。”<br>“如果子类具有和父类一样的方法（参数相同、返回类型相同、方法名相同，但方法体可能不同），我们称之<br>为方法重写。 方法重写用于提供父类已经声明的方法的特殊实现，是实现多态的基础条件。”<br>“只不过，方法重载与方法重写在名字上很相似，就像是兄弟俩，导致初学者经常把它们俩搞混。”<br>“方法重载的英文名叫 Overloading，方法重写的英文名叫 Overriding，因此，不仅中文名很相近，英文名之<br>间也很相近，这就更容易让初学者搞混了。”<br>“但两者其实是完全不同的！通过下面这张图，你就能看得一清二楚。”<br>话音刚落，我就在 IDEA 中噼里啪啦地敲了起来。两段代码，分别是方法重写和方法重载。然后，把这两段<br>代码截图到 draw.io（一个很漂亮的在线画图网站）上，加了一些文字说明。最后，打开 Photoscape X，把<br>两张图片合并到了一起。<br>学Java，就认准二哥的Java进阶之路<br>No. 343 / 963<br>01、方法重载<br>“三妹，你仔细听哦。”我缓了一口气后继续说道。<br>“在 Java 中，有两种方式可以达到方法重载的目的。”<br>“第一，改变参数的数目。来看下面这段代码。”<br>public class OverloadingByParamNum {<br>public static void main(String[] args) {<br>System.out.println(Adder.add(10, 19));<br>System.out.println(Adder.add(10, 19, 20));<br>}<br>}<br>class Adder {<br>static int add(int a, int b) {<br>return a + b;<br>}<br>static int add(int a, int b, int c) {<br>return a + b + c;<br>}<br>}<br>学Java，就认准二哥的Java进阶之路<br>No. 344 / 963<br>学Java，就认准二哥的Java进阶之路<br>“Adder 类有两个方法，第一个 add() 方法有两个参数，在调用的时候可以传递两个参数；第二个 add()<br>方法有三个参数，在调用的时候可以传递三个参数。”<br>“二哥，这样的代码不会显得啰嗦吗？如果有四个参数的时候就再追加一个方法？”三妹突然提了一个很尖锐<br>的问题。<br>“那倒是，这个例子只是为了说明方法重载的一种类型。如果参数类型相同的话，Java 提供了可变参数的方<br>式，就像下面这样。”<br>static int add(int … args) {<br>int sum = 0;<br>for ( int a: args) {<br>sum += a;<br>}<br>return sum;<br>}<br>“第二，通过改变参数类型，也可以达到方法重载的目的。来看下面这段代码。”<br>public class OverloadingByParamType {<br>public static void main(String[] args) {<br>System.out.println(Adder.add(10, 19));<br>System.out.println(Adder.add(10.1, 19.2));<br>}<br>}<br>class Adder {<br>static int add(int a, int b) {<br>return a + b;<br>}<br>static double add(double a, double b) {<br>return a + b;<br>}<br>}<br>“Adder 类有两个方法，第一个 add() 方法的参数类型为 int，第二个 add() 方法的参数类型为 double。”<br>“二哥，改变参数的数目和类型都可以实现方法重载，为什么改变方法的返回值类型就不可以呢？”三妹很能<br>抓住问题的重点嘛。<br>“因为仅仅改变返回值类型的话，会把编译器搞懵逼的。”我略带调皮的口吻回答她。<br>“编译时报错优于运行时报错，所以当两个方法的名字相同，参数个数和类型也相同的时候，虽然返回值类型<br>不同，但依然会提示方法已经被定义的错误。”<br>No. 345 / 963<br>学Java，就认准二哥的Java进阶之路<br>“你想啊，三妹。我们在调用一个方法的时候，可以指定返回值类型，也可以不指定。当不指定的时候，直接<br>指定 add(1, 2) 的时候，编译器就不知道该调用返回 int 的 add() 方法还是返回 double 的 add() 方<br>法，产生了歧义。”<br>“方法的返回值只是作为方法运行后的一个状态，它是保持方法的调用者和被调用者进行通信的一个纽带，但<br>并不能作为某个方法的‘标识’。”<br>“二哥，我想到了一个点， main() 方法可以重载吗？”<br>“三妹，这是个好问题啊！答案是肯定的，毕竟 main() 方法也是个方法，只不过，Java 虚拟机在运行的时<br>候只会调用带有 String 数组的那个 main() 方法。”<br>public class OverloadingMain {<br>public static void main(String[] args) {<br>System.out.println(“String[] args”);<br>}<br>public static void main(String args) {<br>System.out.println(“String args”);<br>}<br>public static void main() {<br>System.out.println(“无参”);<br>}<br>}<br>“第一个 main() 方法的参数形式为 String[] args ，是最标准的写法；第二个 main() 方法的参数形式<br>为 String args ，少了中括号；第三个 main() 方法没有参数。”<br>“来看一下程序的输出结果。”<br>String[] args<br>“从结果中，我们可以看得出，尽管 main() 方法可以重载，但程序只认标准写法。”<br>“由于可以通过改变参数类型的方式实现方法重载，那么当传递的参数没有找到匹配的方法时，就会发生隐式<br>的类型转换。”<br>No. 346 / 963<br>学Java，就认准二哥的Java进阶之路<br>“如上图所示，byte 可以向上转换为 short、int、long、float 和 double，short 可以向上转换为 int、<br>long、float 和 double，char 可以向上转换为 int、long、float 和 double，依次类推。”<br>“三妹，来看下面这个示例。”<br>public class OverloadingTypePromotion {<br>void sum(int a, long b) {<br>System.out.println(a + b);<br>}<br>void sum(int a, int b, int c) {<br>System.out.println(a + b + c);<br>}<br>public static void main(String args[]) {<br>OverloadingTypePromotion obj = new OverloadingTypePromotion();<br>obj.sum(20, 20);<br>obj.sum(20, 20, 20);<br>No. 347 / 963<br>学Java，就认准二哥的Java进阶之路<br>}<br>}<br>“执行 obj.sum(20, 20) 的时候，发现没有 sum(int a, int b) 的方法，所以此时第二个 20 向上转型为<br>long，所以调用的是 sum(int a, long b) 的方法。”<br>“再来看一个示例。”<br>public class OverloadingTypePromotion1 {<br>void sum(int a, int b) {<br>System.out.println(“int”);<br>}<br>void sum(long a, long b) {<br>System.out.println(“long”);<br>}<br>public static void main(String args[]) {<br>OverloadingTypePromotion1 obj = new OverloadingTypePromotion1();<br>obj.sum(20, 20);<br>}<br>}<br>“执行 obj.sum(20, 20) 的时候，发现有 sum(int a, int b) 的方法，所以就不会向上转型为 long，调<br>用 sum(long a, long b) 。”<br>“来看一下程序的输出结果。”<br>int<br>“继续来看示例。”<br>public class OverloadingTypePromotion2 {<br>void sum(long a, int b) {<br>System.out.println(“long int”);<br>}<br>void sum(int a, long b) {<br>System.out.println(“int long”);<br>}<br>public static void main(String args[]) {<br>OverloadingTypePromotion2 obj = new OverloadingTypePromotion2();<br>obj.sum(20, 20);<br>}<br>}<br>“二哥，我又想到一个问题。当有两个方法 sum(long a, int b) 和 sum(int a, long b) ，参数个数相<br>同，参数类型相同，只不过位置不同的时候，会发生什么呢？”<br>No. 348 / 963<br>“当通过 obj.sum(20, 20) 来调用 sum 方法的时候，编译器会提示错误。”<br>“不明确，编译器会很为难，究竟是把第一个 20 从 int 转成 long 呢，还是把第二个 20 从 int 转成 long，智<br>障了！所以，不能写这样让编译器左右为难的代码。”<br>02、方法重写<br>“三妹，累吗？我们稍微休息一下吧。”我把眼镜摘下来，放到桌子上，闭上了眼睛，开始胡思乱想起来。<br>2000 年，周杰伦横空出世，让青黄不接的唱片行业为之一振，由此开启了新一代天王争霸的黄金时代。<br>2020 年，杰伦胖了，也贪玩了，一年出一张单曲都变得可遇不可求。<br>20 年前，程序员很稀有；20 年后，程序员内卷了。时间永远不会停下脚步，明年会不会好起来呢？<br>“哥，醒醒，你就说休息一会，没说睡着啊。赶紧，我还有半个小时就要走了。”<br>我戴上眼镜，对三妹继续说道：“在 Java 中，方法重写需要满足以下三个规则。”<br>重写的方法必须和父类中的方法有着相同的名字；<br>重写的方法必须和父类中的方法有着相同的参数；<br>必须是 is-a 的关系（继承关系）。<br>“来看下面这段代码。”<br>“来看一下程序的输出结果。”<br>public class Bike extends Vehicle {<br>public static void main(String[] args) {<br>Bike bike = new Bike();<br>bike.run();<br>}<br>}<br>class Vehicle {<br>void run() {<br>System.out.println(“车辆在跑”);<br>}<br>}<br>车辆在跑<br>学Java，就认准二哥的Java进阶之路<br>No. 349 / 963<br>“Bike is-a Vehicle，自行车是一种车，没错。Vehicle 类有一个 run() 的方法，也就是说车辆可以跑，Bike<br>继承了 Vehicle，也可以跑。但如果 Bike 没有重写 run() 方法的话，自行车就只能是‘车辆在跑’，而不是‘自<br>行车在跑’，对吧？”<br>“如果有了方法重写，一切就好办了。”<br>我把鼠标移动到 Bike 类的 run() 方法，对三妹说：“你看，在方法重写的时候，IDEA 会建议使用<br>@Override 注解，显式的表示这是一个重写后的方法，尽管可以缺省。”<br>“来看一下程序的输出结果。”<br>“Bike 重写了 run() 方法，也就意味着，Bike 可以跑出自己的风格。”<br>好，接下来说一下重写时应当遵守的 12 条规则，应当谨记哦。<br>规则一：只能重写继承过来的方法。<br>因为重写是在子类重新实现从父类继承过来的方法时发生的，所以只能重写继承过来的方法，这很好理解。<br>这就意味着，只能重写那些被 public、protected 或者 default 修饰的方法，private 修饰的方法无法被重<br>写。<br>Animal 类有 move() 、 eat() 和 sleep() 三个方法：<br>public class Bike extends Vehicle {<br>@Override<br>void run() {<br>System.out.println(“自行车在跑”);<br>}<br>public static void main(String[] args) {<br>Bike bike = new Bike();<br>bike.run();<br>}<br>}<br>class Vehicle {<br>void run() {<br>System.out.println(“车辆在跑”);<br>}<br>}<br>自行车在跑<br>public class Animal {<br>public void move() { }<br>protected void eat() { }<br>void sleep(){ }<br>}<br>学Java，就认准二哥的Java进阶之路<br>No. 350 / 963<br>Dog 类来重写这三个方法：<br>OK，完全没有问题。但如果父类中的方法是 private 的，就行不通了。<br>此时，Dog 类中的 move() 方法就不再是一个重写方法了，因为父类的 move() 方法是 private 的，对子类<br>并不可见。<br>规则二：final、static 的方法不能被重写。<br>一个方法是 final 的就意味着它无法被子类继承到，所以就没办法重写。<br>由于父类 Animal 中的 move() 是 final 的，所以子类在尝试重写该方法的时候就出现编译错误了！<br>同样的，如果一个方法是 static 的，也不允许重写，因为静态方法可用于父类以及子类的所有实例。<br>重写的目的在于根据对象的类型不同而表现出多态，而静态方法不需要创建对象就可以使用。没有了对象，<br>重写所需要的“对象的类型”也就没有存在的意义了。<br>public class Dog extends Animal {<br>public void move() { }<br>protected void eat() { }<br>void sleep(){ }<br>}<br>public class Animal {<br>private void move() { }<br>}<br>public class Dog extends Animal {<br>public void move() { }<br>}<br>public class Animal {<br>final void move() { }<br>}<br>public class Animal {<br>final void move() { }<br>}<br>学Java，就认准二哥的Java进阶之路<br>No. 351 / 963<br>规则三：重写的方法必须有相同的参数列表。<br>Dog 类中的 eat() 方法保持了父类方法 eat() 的同一个调调，都有一个参数——String 类型的 food。<br>一旦子类没有按照这个规则来，比如说增加了一个参数：<br>这就不再是重写的范畴了，当然也不是重载的范畴，因为重载考虑的是同一个类。<br>规则四：重写的方法必须返回相同的类型。<br>父类没有返回类型：<br>子类尝试返回 String：<br>于是就编译出错了（返回类型不兼容）。<br>public class Animal {<br>void eat(String food) { }<br>}<br>public class Dog extends Animal {<br>public void eat(String food) { }<br>}<br>public class Dog extends Animal {<br>public void eat(String food, int amount) { }<br>}<br>public class Animal {<br>void eat(String food) { }<br>}<br>public class Dog extends Animal {<br>public String eat(String food) {<br>return null;<br>}<br>}<br>学Java，就认准二哥的Java进阶之路<br>No. 352 / 963<br>规则五：重写的方法不能使用限制等级更严格的权限修饰符。<br>可以这样来理解：<br>如果被重写的方法是 default，那么重写的方法可以是 default、protected 或者 public。<br>如果被重写的方法是 protected，那么重写的方法只能是 protected 或者 public。<br>如果被重写的方法是 public， 那么重写的方法就只能是 public。<br>举个例子，父类中的方法是 protected：<br>子类中的方法可以是 public：<br>如果子类中的方法用了更严格的权限修饰符，编译器就报错了。<br>规则六：重写后的方法不能抛出比父类中更高级别的异常。<br>举例来说，如果父类中的方法抛出的是 IOException，那么子类中重写的方法不能抛出 Exception，可以是<br>IOException 的子类或者不抛出任何异常。这条规则只适用于可检查的异常。<br>可检查（checked）异常必须在源代码中显式地进行捕获处理，不检查（unchecked）异常就是所谓的运行<br>时异常，比如说 NullPointerException、ArrayIndexOutOfBoundsException 之类的，不会在编译器强制要<br>求。<br>父类抛出 IOException：<br>子类抛出 FileNotFoundException 是可以满足重写的规则的，因为 FileNotFoundException 是 IOException<br>的子类。<br>如果子类抛出了一个新的异常，并且是一个 checked 异常：<br>public class Animal {<br>protected void eat() { }<br>}<br>public class Dog extends Animal {<br>public void eat() { }<br>}<br>public class Animal {<br>protected void eat() throws IOException { }<br>}<br>public class Dog extends Animal {<br>public void eat() throws FileNotFoundException { }<br>}<br>学Java，就认准二哥的Java进阶之路<br>No. 353 / 963<br>那编译器就会提示错误：<br>但如果子类抛出的是一个 unchecked 异常，那就没有冲突：<br>如果子类抛出的是一个更高级别的异常：<br>编译器同样会提示错误，因为 Exception 是 IOException 的父类。<br>规则七：可以在子类中通过 super 关键字来调用父类中被重写的方法。<br>子类继承父类的方法而不是重新实现是很常见的一种做法，在这种情况下，可以按照下面的形式调用父类的<br>方法：<br>来看例子。<br>子类重写了 eat() 方法，然后在子类的 eat() 方法中，可以在方法体的第一行通过 super.eat() 调用父<br>类的方法，然后再增加属于自己的代码。<br>public class Dog extends Animal {<br>public void eat() throws FileNotFoundException, InterruptedException { }<br>}<br>Error:(9, 16) java: com.itwanger.overriding.Dog中的eat()无法覆盖<br>com.itwanger.overriding.Animal中的eat()<br>被覆盖的方法未抛出java.lang.InterruptedException<br>public class Dog extends Animal {<br>public void eat() throws FileNotFoundException, IllegalArgumentException { }<br>}<br>public class Dog extends Animal {<br>public void eat() throws Exception { }<br>}<br>Error:(9, 16) java: com.itwanger.overriding.Dog中的eat()无法覆盖<br>com.itwanger.overriding.Animal中的eat()<br>被覆盖的方法未抛出java.lang.Exception<br>super.overriddenMethodName();<br>public class Animal {<br>protected void eat() { }<br>}<br>学Java，就认准二哥的Java进阶之路<br>No. 354 / 963<br>规则八：构造方法不能被重写。<br>因为构造方法很特殊，而且子类的构造方法不能和父类的构造方法同名（类名不同），所以构造方法和重写<br>之间没有任何关系。<br>规则九：如果一个类继承了抽象类，抽象类中的抽象方法必须在子类中被重写。<br>先来看这样一个接口：<br>接口中的方法默认都是抽象方法，通过反编译是可以看得到的：<br>如果一个抽象类实现了 Animal 接口， move() 方法不是必须被重写的：<br>但如果一个类继承了抽象类 AbstractDog，那么 Animal 接口中的 move() 方法和抽象类 AbstractDog 中的<br>抽象方法 bark() 都必须被重写：<br>public class Dog extends Animal {<br>public void eat() {<br>super.eat();<br>// Dog-eat<br>}<br>}<br>public interface Animal {<br>void move();<br>}<br>public interface Animal<br>{<br>public abstract void move();<br>}<br>public abstract class AbstractDog implements Animal {<br>protected abstract void bark();<br>}<br>public class BullDog extends AbstractDog {<br>public void move() {}<br>protected void bark() {}<br>}<br>学Java，就认准二哥的Java进阶之路<br>No. 355 / 963<br>规则十：synchronized 关键字对重写规则没有任何影响。<br>synchronized 关键字用于在多线程环境中获取和释放监听对象，因此它对重写规则没有任何影响，这就意味<br>着 synchronized 方法可以去重写一个非同步方法。<br>规则十一：strictfp 关键字对重写规则没有任何影响。<br>如果你想让浮点运算更加精确，而且不会因为硬件平台的不同导致执行的结果不一致的话，可以在方法上添<br>加 strictfp 关键字，之前讲过。因此 strictfp 关键字和重写规则无关。<br>03、总结<br>“好了，三妹，我来简单做个总结。”我瞥了一眼电脑右上角的时钟，离三妹离开的时间不到 10 分钟了。<br>“首先来说一下方法重载时的注意事项，‘两同一不同’。”<br>“‘两同’：在同一个类，方法名相同。”<br>“‘一不同’：参数不同。”<br>“再来说一下方法重写时的注意事项，‘两同一小一大’。”<br>“‘两同’：方法名相同，参数相同。”<br>“‘一小’：子类方法声明的异常类型要比父类小一些或者相等。”<br>“‘一大’：子类方法的访问权限应该比父类的更大或者相等。”<br>“记住了吧？三妹。带上口罩，拿好手机，咱准备出门吧。”今天限号，没法开车送三妹去学校了。<br>GitHub 上标星 7600+ 的开源知识库《二哥的 Java 进阶之路》第一版 PDF 终于来了！包括Java基础语法、<br>数组&amp;字符串、OOP、集合框架、Java IO、异常处理、Java 新特性、网络编程、NIO、并发编程、JVM等<br>等，共计 32 万余字，可以说是通俗易懂、风趣幽默……详情戳：太赞了，GitHub 上标星 7600+ 的 Java 教<br>程<br>微信搜 沉默王二 或۾描下方二维码关注二哥的原创公众号沉默王二，回复 222 即可免费领取。<br>学Java，就认准二哥的Java进阶之路<br>No. 356 / 963<br>5.20 Java注解<br>“二哥，这节讲注解吗？”三妹问。<br>“是的。”我说，“注解是 Java 中非常重要的一部分，但经常被忽视也是真的。之所以这么说是因为我们更倾向<br>成为一名注解的使用者而不是创建者。 @Override 注解用过吧？方法重写的时候用到过。但你知道怎么自<br>定义一个注解吗？”<br>三妹毫不犹豫地摇摇头，摆摆手，不好意思地承认自己的确没有自定义过。<br>“好吧，哥来告诉你吧。”<br>注解（Annotation）是在 Java 1.5 时引入的概念，同 class 和 interface 一样，也属于一种类型。注解提供<br>了一系列数据用来装饰程序代码（类、方法、字段等），但是注解并不是所装饰代码的一部分，它对代码的<br>运行效果没有直接影响，由编译器决定该执行哪些操作。<br>来看一段代码。<br>学Java，就认准二哥的Java进阶之路<br>No. 357 / 963<br>学Java，就认准二哥的Java进阶之路<br>public class AutowiredTest {<br>@Autowired<br>private String name;<br>public static void main(String[] args) {<br>System.out.println(“沉默王二，一枚有趣的程序员”);<br>}<br>}<br>注意到 @Autowired 这个注解了吧？它本来是为 Spring（后面会讲）容器注入 Bean 的，现在被我无情地<br>扔在了字段 name 的身上，但这段代码所在的项目中并没有启用 Spring，意味着 @Autowired 注解此时只<br>是一个摆设。<br>“既然只是个摆设，那你这个地方为什么还要用 @Autowired 呢？”三妹好奇地问。<br>“傻呀你，就是给你举个例子，证明：注解对代码的运行效果没有直接影响，明白我的用意了吧？”我毫不客<br>气地说。<br>“哦。”三妹若有所思地说。<br>“认真听哈，接下来给你讲讲注解的生命周期。”我瞅了瞅三妹，看她是否在专注的听，然后继续说，“注解的<br>生命周期有 3 种策略，定义在 RetentionPolicy 枚举中。”<br>1）SOURCE：在源文件中有效，被编译器丢弃。<br>2）CLASS：在编译器生成的字节码文件中有效，但在运行时会被处理类文件的 JVM 丢弃。<br>3）RUNTIME：在运行时有效。这也是注解生命周期中最常用的一种策略，它允许程序通过反射的方式访问<br>注解，并根据注解的定义执行相应的代码。<br>“然后我们来讲注解装饰的目标。”我看三妹还在线，就继续说。<br>注解的目标定义了注解将适用于哪一种级别的 Java 代码上，有些注解只适用于方法，有些只适用于成员变<br>量，有些只适用于类，有些则都适用。截止到 Java 9，注解的类型一共有 11 种，定义在 ElementType 枚举<br>中。<br>1）TYPE：用于类、接口、注解、枚举<br>2）FIELD：用于字段（类的成员变量），或者枚举常量<br>3）METHOD：用于方法<br>4）PARAMETER：用于普通方法或者构造方法的参数<br>5）CONSTRUCTOR：用于构造方法<br>6）LOCAL_VARIABLE：用于变量<br>7）ANNOTATION_TYPE：用于注解<br>8）PACKAGE：用于包<br>9）TYPE_PARAMETER：用于泛型参数<br>10）TYPE_USE：用于声明语句、泛型或者强制转换语句中的类型<br>11）MODULE：用于模块<br>No. 358 / 963<br>学Java，就认准二哥的Java进阶之路<br>“哥，你将这些我都记不住，能不能直接开撸注解呀！！！！！”三妹不耐烦了。<br>“确实哈，说再多，都不如撸个注解来得让人心动。撸个什么样的注解呢？一个字段注解吧，它用来标记对象<br>在序列化成 JSON 的时候要不要包含这个字段。”我笑着对三妹说，“怎么样？”<br>“好呀！”<br>“来看下面这段代码。”<br>@Retention(RetentionPolicy.RUNTIME)<br>@Target(ElementType.FIELD)<br>public @interface JsonField {<br>public String value() default “”;<br>}<br>1）JsonField 注解的生命周期是 RUNTIME，也就是运行时有效。<br>2）JsonField 注解装饰的目标是 FIELD，也就是针对字段的。<br>3）创建注解需要用到 @interface 关键字。<br>4）JsonField 注解有一个参数，名字为 value，类型为 String，默认值为一个空字符串。<br>“为什么参数名要为 value 呢？有什么特殊的含义吗？”三妹问。<br>“当然是有的，value 允许注解的使用者提供一个无需指定名字的参数。举个例子，我们可以在一个字段上使<br>用 @JsonField(value = “沉默王二”) ，也可以把 value = 省略，变成 @JsonField(“沉默王二”) 。”我<br>说。<br>“那 default “” 有什么特殊含义吗？”三妹继续问。<br>“当然也是有的，它允许我们在一个字段上直接使用 @JsonField ，而无需指定参数的名和值。”我回答说。<br>“明白了，那 @JsonField 注解已经撸好了，是不是可以使用它了呀？”三妹激动地说。<br>“嗯，假设有一个 Writer 类，他有 3 个字段，分别是 age、name 和 bookName，后 2 个是必须序列化的字<br>段。就可以这样来用 @JsonField 注解。”我说。<br>public class Writer {<br>private int age;<br>@JsonField(“writerName”)<br>private String name;<br>@JsonField<br>private String bookName;<br>public Writer(int age, String name, String bookName) {<br>this.age = age;<br>this.name = name;<br>this.bookName = bookName;<br>No. 359 / 963<br>学Java，就认准二哥的Java进阶之路<br>}<br>// getter / setter<br>@Override<br>public String toString() {<br>return “Writer{“ +<br>“age=” + age +<br>“, name=’” + name + ‘\’’ +<br>“, bookName=’” + bookName + ‘\’’ +<br>‘}’;<br>}<br>}<br>1）name 上的 @JsonField 注解提供了显式的字符串值。<br>2）bookName 上的 @JsonField 注解使用了缺省项。<br>接下来，我们来编写序列化类 JsonSerializer，内容如下：<br>public class JsonSerializer {<br>public static String serialize(Object object) throws IllegalAccessException {<br>Class&lt;?&gt; objectClass = object.getClass();<br>Map<String, String> jsonElements = new HashMap&lt;&gt;();<br>for (Field field : objectClass.getDeclaredFields()) {<br>field.setAccessible(true);<br>if (field.isAnnotationPresent(JsonField.class)) {<br>jsonElements.put(getSerializedKey(field), (String)<br>field.get(object));<br>}<br>}<br>return toJsonString(jsonElements);<br>}<br>private static String getSerializedKey(Field field) {<br>String annotationValue = field.getAnnotation(JsonField.class).value();<br>if (annotationValue.isEmpty()) {<br>return field.getName();<br>} else {<br>return annotationValue;<br>}<br>}<br>private static String toJsonString(Map<String, String> jsonMap) {<br>String elementsString = jsonMap.entrySet()<br>.stream()<br>.map(entry -&gt; “\”” + entry.getKey() + “\”:\”” + entry.getValue() +<br>“\””)<br>.collect(Collectors.joining(“,”));<br>return “{“ + elementsString + “}”;<br>}<br>}<br>No. 360 / 963<br>学Java，就认准二哥的Java进阶之路<br>“JsonSerializer 类的内容看起来似乎有点多啊，二哥，我有点看不懂。”三妹说。<br>“不要怕，我一点点来解释，直到你搞明白为止。”<br>1） serialize() 方法是用来序列化对象的，它接收一个 Object 类型的参数。<br>objectClass.getDeclaredFields() 通过反射的方式获取对象声明的所有字段，然后进行 for 循环遍历。<br>在 for 循环中，先通过 field.setAccessible(true) 将反射对象的可访问性设置为 true，供序列化使用<br>（如果没有这个步骤的话，private 字段是无法获取的，会抛出 IllegalAccessException 异常）；再通过<br>isAnnotationPresent() 判断字段是否装饰了 JsonField 注解，如果是的话，调用<br>getSerializedKey() 方法，以及获取该对象上由此字段表示的值，并放入 jsonElements 中。<br>2） getSerializedKey() 方法用来获取字段上注解的值，如果注解的值是空的，则返回字段名。<br>3） toJsonString() 方法借助 Stream 流的方式返回格式化后的 JSON 字符串。Stream 流你还没有接触<br>过，不过没关系，后面我再给你讲。<br>“现在是不是豁然开朗了？”我问三妹，看到三妹点了点头，我继续说，“接下来，我们来写一个测试类<br>JsonFieldTest。”<br>public class JsonFieldTest {<br>public static void main(String[] args) throws IllegalAccessException {<br>Writer cmower = new Writer(18,”沉默王二”,”Web全栈开发进阶之路”);<br>System.out.println(JsonSerializer.serialize(cmower));<br>}<br>}<br>程序输出结果如下：<br>{“bookName”:”Web全栈开发进阶之路”,”writerName”:”沉默王二”}<br>从结果上来看：<br>1）Writer 类的 age 字段没有装饰 @JsonField 注解，所以没有序列化。<br>2）Writer 类的 name 字段装饰了 @JsonField 注解，并且显示指定了字符串“writerName”，所以序列化<br>后变成了 writerName。<br>3）Writer 类的 bookName 字段装饰了 @JsonField 注解，但没有显式指定值，所以序列化后仍然是<br>bookName。<br>“怎么样，三妹，是不是也不是特别难？”我对三妹说。<br>“撸个注解好像真没什么难度，但你接下来的那个 JsonSerializer 我还需要再消化一下。”三妹很认真地说。<br>“嗯，你好好复习下，我看会《编译原理》。”说完我拿起桌子边上的一本书就走了。<br>GitHub 上标星 7600+ 的开源知识库《二哥的 Java 进阶之路》第一版 PDF 终于来了！包括Java基础语法、<br>数组&amp;字符串、OOP、集合框架、Java IO、异常处理、Java 新特性、网络编程、NIO、并发编程、JVM等<br>等，共计 32 万余字，可以说是通俗易懂、风趣幽默……详情戳：太赞了，GitHub 上标星 7600+ 的 Java 教<br>程<br>微信搜 沉默王二 或۾描下方二维码关注二哥的原创公众号沉默王二，回复 222 即可免费领取。<br>No. 361 / 963<br>5.21 Java枚举（enum）<br>“今天我们来学习枚举吧，三妹！”我说，“同学让你去她家玩了两天，感觉怎么样呀？”<br>“心情放松了不少。”三妹说，“可以开始学 Java 了，二哥。”<br>“OK。”<br>“枚举（enum），是 Java 1.5 时引入的关键字，它表示一种特殊类型的类，继承自 java.lang.Enum。”<br>“我们来新建一个枚举 PlayerType。”<br>“二哥，我没看到有继承关系呀！”<br>“别着急，看一下反编译后的字节码，你就明白了。”<br>public enum PlayerType {<br>TENNIS,<br>FOOTBALL,<br>BASKETBALL<br>}<br>public final class PlayerType extends Enum<br>{<br>public static PlayerType[] values()<br>{<br>return (PlayerType[])$VALUES.clone();<br>}<br>public static PlayerType valueOf(String name)<br>{<br>return (PlayerType)Enum.valueOf(com/cmower/baeldung/enum1/PlayerType, name);<br>学Java，就认准二哥的Java进阶之路<br>No. 362 / 963<br>学Java，就认准二哥的Java进阶之路<br>}<br>private PlayerType(String s, int i)<br>{<br>super(s, i);<br>}<br>public static final PlayerType TENNIS;<br>public static final PlayerType FOOTBALL;<br>public static final PlayerType BASKETBALL;<br>private static final PlayerType $VALUES[];<br>static<br>{<br>TENNIS = new PlayerType(“TENNIS”, 0);<br>FOOTBALL = new PlayerType(“FOOTBALL”, 1);<br>BASKETBALL = new PlayerType(“BASKETBALL”, 2);<br>$VALUES = (new PlayerType[] {<br>TENNIS, FOOTBALL, BASKETBALL<br>});<br>}<br>}<br>“看到没？Java 编译器帮我们做了很多隐式的工作，不然手写一个枚举就没那么省心省事了。”<br>要继承 Enum 类；<br>要写构造方法；<br>要声明静态变量和数组；<br>要用 static 块来初始化静态变量和数组；<br>要提供静态方法，比如说 values() 和 valueOf(String name) 。<br>“确实，作为开发者，我们的代码量减少了，枚举看起来简洁明了。”三妹说。<br>“既然枚举是一种特殊的类，那它其实是可以定义在一个类的内部的，这样它的作用域就可以限定于这个外部<br>类中使用。”我说。<br>public class Player {<br>private PlayerType type;<br>public enum PlayerType {<br>TENNIS,<br>FOOTBALL,<br>BASKETBALL<br>}<br>public boolean isBasketballPlayer() {<br>return getType() == PlayerType.BASKETBALL;<br>}<br>public PlayerType getType() {<br>return type;<br>No. 363 / 963<br>学Java，就认准二哥的Java进阶之路<br>}<br>public void setType(PlayerType type) {<br>this.type = type;<br>}<br>}<br>PlayerType 就相当于 Player 的内部类。<br>由于枚举是 final 的，所以可以确保在 Java 虚拟机中仅有一个常量对象，基于这个原因，我们可以使用“==”<br>运算符来比较两个枚举是否相等，参照 isBasketballPlayer() 方法。<br>“那为什么不使用 equals() 方法判断呢？”三妹问。<br>if(player.getType().equals(Player.PlayerType.BASKETBALL)){};<br>“我来给你解释下。”<br>“==”运算符比较的时候，如果两个对象都为 null，并不会发生 NullPointerException ，而 equals() 方<br>法则会。<br>另外， “==”运算符会在编译时进行检查，如果两侧的类型不匹配，会提示错误，而 equals() 方法则不会。<br>“枚举还可用于 switch 语句，和基本数据类型的用法一致。”我说。<br>switch (playerType) {<br>case TENNIS:<br>return “网球运动员费德勒”;<br>case FOOTBALL:<br>return “足球运动员C罗”;<br>case BASKETBALL:<br>return “篮球运动员詹姆斯”;<br>case UNKNOWN:<br>throw new IllegalArgumentException(“未知”);<br>default:<br>throw new IllegalArgumentException(<br>“运动员类型: “ + playerType);<br>}<br>“如果枚举中需要包含更多信息的话，可以为其添加一些字段，比如下面示例中的 name，此时需要为枚举添<br>加一个带参的构造方法，这样就可以在定义枚举时添加对应的名称了。”我继续说。<br>No. 364 / 963<br>学Java，就认准二哥的Java进阶之路<br>public enum PlayerType {<br>TENNIS(“网球”),<br>FOOTBALL(“足球”),<br>BASKETBALL(“篮球”);<br>private String name;<br>PlayerType(String name) {<br>this.name = name;<br>}<br>}<br>“get 了吧，三妹？”<br>“嗯，比较好理解。”<br>“那接下来，我就来说点不一样的。”<br>“来吧，我准备好了。”<br>“EnumSet 是一个专门针对枚举类型的 Set 接口（后面会讲）的实现类，它是处理枚举类型数据的一把利<br>器，非常高效。”我说，“从名字上就可以看得出，EnumSet 不仅和 Set 有关系，和枚举也有关系。”<br>“因为 EnumSet 是一个抽象类，所以创建 EnumSet 时不能使用 new 关键字。不过，EnumSet 提供了很多<br>有用的静态工厂方法。”<br>“来看下面这个例子，我们使用 noneOf() 静态工厂方法创建了一个空的 PlayerType 类型的 EnumSet；使<br>用 allOf() 静态工厂方法创建了一个包含所有 PlayerType 类型的 EnumSet。”<br>public class EnumSetTest {<br>public enum PlayerType {<br>TENNIS,<br>FOOTBALL,<br>BASKETBALL<br>}<br>No. 365 / 963<br>学Java，就认准二哥的Java进阶之路<br>public static void main(String[] args) {<br>EnumSet<PlayerType> enumSetNone = EnumSet.noneOf(PlayerType.class);<br>System.out.println(enumSetNone);<br>EnumSet<PlayerType> enumSetAll = EnumSet.allOf(PlayerType.class);<br>System.out.println(enumSetAll);<br>}<br>}<br>“来看一下输出结果。”<br>[]<br>[TENNIS, FOOTBALL, BASKETBALL]<br>有了 EnumSet 后，就可以使用 Set 的一些方法了，见下图。<br>“除了 EnumSet，还有 EnumMap，是一个专门针对枚举类型的 Map 接口的实现类，它可以将枚举常量作为<br>键来使用。EnumMap 的效率比 HashMap 还要高，可以直接通过数组下标（枚举的 ordinal 值）访问到元<br>素。”<br>“和 EnumSet 不同，EnumMap 不是一个抽象类，所以创建 EnumMap 时可以使用 new 关键字。”<br>EnumMap<PlayerType, String> enumMap = new EnumMap&lt;&gt;(PlayerType.class);<br>有了 EnumMap 对象后就可以使用 Map 的一些方法了，见下图。<br>No. 366 / 963<br>学Java，就认准二哥的Java进阶之路<br>和 HashMap（后面会讲）的使用方法大致相同，来看下面的例子。<br>EnumMap<PlayerType, String> enumMap = new EnumMap&lt;&gt;(PlayerType.class);<br>enumMap.put(PlayerType.BASKETBALL,”篮球运动员”);<br>enumMap.put(PlayerType.FOOTBALL,”足球运动员”);<br>enumMap.put(PlayerType.TENNIS,”网球运动员”);<br>System.out.println(enumMap);<br>System.out.println(enumMap.get(PlayerType.BASKETBALL));<br>System.out.println(enumMap.containsKey(PlayerType.BASKETBALL));<br>System.out.println(enumMap.remove(PlayerType.BASKETBALL));<br>“来看一下输出结果。”<br>{TENNIS=网球运动员, FOOTBALL=足球运动员, BASKETBALL=篮球运动员}<br>篮球运动员<br>true<br>篮球运动员<br>“除了以上这些，《Effective Java》这本书里还提到了一点，如果要实现单例的话，最好使用枚举的方式。”<br>我说。<br>“等等二哥，单例是什么？”三妹没等我往下说，就连忙问道。<br>“单例（Singleton）用来保证一个类仅有一个对象，并提供一个访问它的全局访问点，在一个进程中。因为<br>这个类只有一个对象，所以就不能再使用 new 关键字来创建新的对象了。”<br>“Java 标准库有一些类就是单例，比如说 Runtime 这个类。”<br>Runtime runtime = Runtime.getRuntime();<br>“Runtime 类可以用来获取 Java 程序运行时的环境。”<br>“关于单例，懂了些吧？”我问三妹。<br>“噢噢噢噢。”三妹点了点头。<br>No. 367 / 963<br>学Java，就认准二哥的Java进阶之路<br>“通常情况下，实现单例并非易事，来看下面这种写法。”<br>public class Singleton {<br>private volatile static Singleton singleton;<br>private Singleton (){}<br>public static Singleton getSingleton() {<br>if (singleton == null) {<br>synchronized (Singleton.class) {<br>if (singleton == null) {<br>singleton = new Singleton();<br>}<br>}<br>}<br>return singleton;<br>}<br>}<br>“要用到 volatile、synchronized 关键字等等，但枚举的出现，让代码量减少到极致。”<br>public enum EasySingleton{<br>INSTANCE;<br>}<br>“就这？”三妹睁大了眼睛。<br>“对啊，枚举默认实现了 Serializable 接口，因此 Java 虚拟机可以保证该类为单例，这与传统的实现方式不<br>大相同。传统方式中，我们必须确保单例在反序列化期间不能创建任何新实例。”我说。<br>“好了，关于枚举就讲这么多吧，三妹，你把这些代码都手敲一遍吧！”<br>“好勒，这就安排。二哥，你去休息吧。”<br>“嗯嗯。”讲了这么多，必须跑去抽烟机那里安排一根华子了。<br>GitHub 上标星 7600+ 的开源知识库《二哥的 Java 进阶之路》第一版 PDF 终于来了！包括Java基础语法、<br>数组&amp;字符串、OOP、集合框架、Java IO、异常处理、Java 新特性、网络编程、NIO、并发编程、JVM等<br>等，共计 32 万余字，可以说是通俗易懂、风趣幽默……详情戳：太赞了，GitHub 上标星 7600+ 的 Java 教<br>程<br>微信搜 沉默王二 或۾描下方二维码关注二哥的原创公众号沉默王二，回复 222 即可免费领取。<br>No. 368 / 963</p>
<h1 id="4-Java-集合框架"><a href="#4-Java-集合框架" class="headerlink" title="4 Java 集合框架"></a>4 Java 集合框架</h1><p>  4.1 List、Set、Map、队列，全面解析</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://htx-rest.github.io">鲸落</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://htx-rest.github.io/posts/7ec90956.html">https://htx-rest.github.io/posts/7ec90956.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://htx-rest.github.io" target="_blank">鲸落</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a><a class="post-meta__tags" href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">基础知识</a></div><div class="post_share"><div class="social-share" data-image="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/assets/weplay.png" target="_blank"><img class="post-qr-code-img" src="/assets/weplay.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/assets/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/assets/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/aeeccc.html" title="携程校招笔试编程真题及其解析（2023.3.7）"><img class="cover" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">携程校招笔试编程真题及其解析（2023.3.7）</div></div></a></div><div class="next-post pull-right"><a href="/posts/815405c2.html" title="科大讯飞校招笔试编程真题及其解析（2023.8.13）"><img class="cover" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">科大讯飞校招笔试编程真题及其解析（2023.8.13）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/8f70f515.html" title="小红书校招笔试编程真题（2023.3.26）"><img class="cover" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2023-09-24</div><div class="title">小红书校招笔试编程真题（2023.3.26）</div></div></a></div><div><a href="/posts/7d093ba9.html" title="小红书校招笔试编程真题（2023.4.23）"><img class="cover" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2023-09-24</div><div class="title">小红书校招笔试编程真题（2023.4.23）</div></div></a></div><div><a href="/posts/befb4d57.html" title="小红书校招笔试编程真题（2023.5.7）"><img class="cover" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2023-09-24</div><div class="title">小红书校招笔试编程真题（2023.5.7）</div></div></a></div><div><a href="/posts/9578e9c1.html" title="小红书校招笔试编程真题（2023.4.9）"><img class="cover" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2023-09-24</div><div class="title">小红书校招笔试编程真题（2023.4.9）</div></div></a></div><div><a href="/posts/4ce12134.html" title="小红书校招笔试编程真题（2023.7.23）"><img class="cover" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2023-09-24</div><div class="title">小红书校招笔试编程真题（2023.7.23）</div></div></a></div><div><a href="/posts/92b4cb69.html" title="小红书校招笔试编程真题（2023.8.19）"><img class="cover" src="https://img0.baidu.com/it/u=4155835667,974645702&fm=253&fmt=auto&app=138&f=PNG?w=889&h=500" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2023-09-24</div><div class="title">小红书校招笔试编程真题（2023.8.19）</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://tuchuang.voooe.cn/images/2023/01/02/avatar.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">鲸落</div><div class="author-info__description">随波不逐流</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">85</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">123</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/htx-rest"><i class="fab fa-github"></i><span>前往小窝</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="/assets/wenxin.jpg" target="_blank" title="微信"><i class="iconfont icon-weixin" style="color: #24292e;"></i></a><a class="social-icon" href="/assets/weixingongzhonghao.jpg" target="_blank" title="微信公众号"><i class="iconfont icon-weixingongzhonghao" style="color: #24292e;"></i></a><a class="social-icon" href="https://res.abeim.cn/api/qq/?qq=1656855152" target="_blank" title="QQ"><i class="iconfont icon-QQ" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:1656855152@qq.com" target="_blank" title="QQ邮箱"><i class="iconfont icon-youxiang" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">摸鱼中！！！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-Java%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80"><span class="toc-text">1 Java语法基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-Java%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C%E4%BF%9D%E7%95%99%E5%AD%97"><span class="toc-text">1.1 Java关键字和保留字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-Java%E6%B3%A8%E9%87%8A"><span class="toc-text">1.2 Java注释</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text"> ，因为 javadoc 会插入自己的标题，容易发生冲突。
3）文档注释中可以插入一些 @ 注解，比如说 @see 引用其他类， @version 版本号， @param 参数标识符， @author 作者标识符， @deprecated 已废弃标识符，等等。
05、注释规约 
1）类、字段、方法必须使用文档注释，不能使用单行注释和多行注释。因为注释文档在 IDE 编辑窗口中可以悬浮提示，提高编码效率。
比如说，在使用 String 类的时候，鼠标悬停在 String 上时可以得到以下提示。

2）所有的抽象方法(包括接口中的方法)必须要用 Javadoc 注释、除了返回值、参数、 异常说明外，还必须指出该方法做什么事情，实现什么功能。
3）所有的类都必须添加创建者和创建日期。
Intellij IDEA 中可以在「File and Code Templates」中设置。

语法如下所示：
12345&#x2F;*** 微信搜索「二哈进阶之路」* @author 二哈* @date ${DATE}*&#x2F;
设置好后，在新建一个类的时候就可以自动生成了。
12345678&#x2F;** * 微信搜索「二哈进阶之路」 * * @author 二哈 * @date 2020&#x2F;11&#x2F;16 *&#x2F;public class Test {}
4）所有的枚举类型字段必须要有注释，说明每个数据项的用途。
5）代码修改的同时，注释也要进行相应的修改。
“记住一点，注释是程序固有的一部分。”

第一、注释要能够准确反映设计思想和代码逻辑;
第二、注释要能够描述业务含 义，使别的程序员能够迅速了解到代码背后的信息。

完全没有注释的大段代码对于阅读者形同 天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路;注释也是给继任者看 的，使其能够快速接替自己的工作。
1.3 Java数据类型Java 中的数据类型可分为 2 种：
1）基本数据类型。
基本数据类型是 Java 语言操作数据的基础，包括 boolean、char、byte、short、int、long、float 和 double，共 8 种。
2）引用数据类型。
除了基本数据类型以外的类型，都是所谓的引用类型。常见的有数组（对，没错，数组是引用类型，后面我们会讲）、class（也就是类），以及接口（指向的是实现接口的类的对象）。来个思维导图，感受下。

变量可以分为局部变量、成员变量、静态变量。
当变量是局部变量的时候，必须得先初始化，否则编译器不允许你使用它。拿 int 来举例吧，看下图。

当变量是成员变量或者静态变量时，可以不进行初始化，它们会有一个默认值，仍然以 int 为例，来看代码：
123456789101112&#x2F;** * @author 微信搜「二哈进阶之路」 *&#x2F;public class LocalVar {    private int a;    static int b;    public static void main(String[] args) {        LocalVar lv &#x3D; new LocalVar();        System.out.println(lv.a);        System.out.println(b);    }}
来看输出结果：
1200
瞧见没，int 作为成员变量时或者静态变量时的默认值是 0。那不同的基本数据类型，是有不同的默认值和大小的，来个表格感受下。




数据类型
默认值
大小




boolean
false
1 比特


char
‘\u0000’
2 字节


byte
0
1 字节


short
0
2 字节


int
0
4 字节


long
0L
8 字节


float
0.0f
4 字节


double
0.0
8 字节




01、比特和字节 
比特币（Bitcoin）听说过吧？字节跳动（Byte Dance）听说过吧？这些名字当然不是乱起的，确实和比特、字节有关系。
1）bit（比特） 
比特作为信息技术的最基本存储单位，非常小，但大名鼎鼎的比特币就是以此命名的，它的简写为小写字母“b”。
大家都知道，计算机是以二进制存储数据的，二进制的一位，就是 1 比特，也就是说，比特要么为 0 要么为 1。
2）Byte（字节） 
通常来说，一个英文字符是一个字节，一个中文字符是两个字节。字节与比特的换算关系是：1 字节 &#x3D; 8 比特。
在往上的单位就是 KB，并不是 1000 字节，因为计算机只认识二进制，因此是 2 的 10 次方，也就是 1024个字节。（终于知道 1024 和程序员的关系了吧？狗头保命）

02、基本数据类型 
接下来，我们再来详细地了解一下 8 种基本数据类型。
1）布尔 
布尔（boolean）仅用于存储两个值：true 和 false，也就是真和假，通常用于条件的判断。代码示例：
12boolean hasMoney &#x3D; true;boolean hasGirlFriend &#x3D; false;
2）byte 
一个字节可以表示 2^8 &#x3D; 256 个不同的值。由于 byte 是有符号的，它的值可以是负数或正数，其取值范围是 -128 到 127（包括 -128 和 127）。
在网络传输、大文件读写时，为了节省空间，常用字节来作为数据的传输方式。代码示例：
123byte b; &#x2F;&#x2F; 声明一个 byte 类型变量b &#x3D; 10; &#x2F;&#x2F; 将值 10 赋给变量 bbyte c &#x3D; -100; &#x2F;&#x2F; 声明并初始化一个 byte 类型变量 c，赋值为 -100
3）short 
short 的取值范围在 -32,768 和 32,767 之间，包含 32,767。代码示例：
123short s; &#x2F;&#x2F; 声明一个 short 类型变量s &#x3D; 1000; &#x2F;&#x2F; 将值 1000 赋给变量 sshort t &#x3D; -2000; &#x2F;&#x2F; 声明并初始化一个 short 类型变量 t，赋值为 -2000
实际开发中，short 比较少用，整型用 int 就 OK。
4）int 
int 的取值范围在 -2,147,483,648（-2 ^ 31）和 2,147,483,647（2 ^ 31 -1）（含）之间。如果没有特殊需求，整型数据就用 int。代码示例：
123int i; &#x2F;&#x2F; 声明一个 int 类型变量i &#x3D; 1000000; &#x2F;&#x2F; 将值 1000000 赋给变量 iint j &#x3D; -2000000; &#x2F;&#x2F; 声明并初始化一个 int 类型变量 j，赋值为 -2000000
5）long 
long 的取值范围在 -9,223,372,036,854,775,808(-2^63) 和 9,223,372,036,854,775,807(2^63 -1)（含）之间。如果 int 存储不下，就用 long。代码示例：
123long l; &#x2F;&#x2F; 声明一个 long 类型变量l &#x3D; 100000000000L; &#x2F;&#x2F; 将值 100000000000L 赋给变量 l（注意要加上 L 后缀）long m &#x3D; -20000000000L; &#x2F;&#x2F; 声明并初始化一个 long 类型变量 m，赋值为 -20000000000L
为了和 int 作区分，long 型变量在声明的时候，末尾要带上大写的“L”。不用小写的“l”，是因为小写的“l”容易和数字“1”混淆。
6）float 
float 是单精度的浮点数（单精度浮点数的有效数字大约为 6 到 7 位），32 位（4 字节），遵循 IEEE 754（二进制浮点数算术标准），取值范围为 1.4E-45 到 3.4E+38。float 不适合用于精确的数值，比如说金额。
代码示例：
123float f; &#x2F;&#x2F; 声明一个 float 类型变量f &#x3D; 3.14159f; &#x2F;&#x2F; 将值 3.14159f 赋给变量 f（注意要加上 f 后缀）float g &#x3D; -2.71828f; &#x2F;&#x2F; 声明并初始化一个 float 类型变量 g，赋值为 -2.71828f
为了和 double 作区分，float 型变量在声明的时候，末尾要带上小写的“f”。不需要使用大写的“F”，是因为小写的“f”很容易辨别。
7）double 
double 是双精度浮点数（双精度浮点数的有效数字大约为 15 到 17 位），占 64 位（8 字节），也遵循 IEEE 754 标准，取值范围大约 ±4.9E-324 到 ±1.7976931348623157E308。double 同样不适合用于精确的数值，比如说金额。
代码示例：
1double myDouble &#x3D; 3.141592653589793;
在进行金融计算或需要精确小数计算的场景中，可以使用 BigDecimal 类来避免浮点数舍入误差。
BigDecimal 可以表示一个任意大小且精度完全准确的浮点数。

在实际开发中，如果不是特别大的金额（精确到 0.01 元，也就是一分钱），一般建议乘以 100 转成整型进行处理。

8）char 
char 用于表示 Unicode 字符，占 16 位（2 字节）的存储空间，取值范围为 0 到 65,535。
代码示例：
1char letterA &#x3D; &#39;A&#39;; &#x2F;&#x2F; 用英文的单引号包裹住。
注意，字符字面量应该用单引号（’’）包围，而不是双引号（””），因为双引号表示字符串字面量。
03、单精度和双精度 
单精度（single-precision）和双精度（double-precision）是指两种不同精度的浮点数表示方法。单精度是这样的格式，1 位符号，8 位指数，23 位小数。

单精度浮点数通常占用 32 位（4 字节）存储空间。数值范围大约是 ±1.4E-45 到 ±3.4028235E38，精度大约为 6 到 9 位有效数字。
双精度是这样的格式，1 位符号，11 位指数，52 为小数。

双精度浮点数通常占用 64 位（8 字节）存储空间，数值范围大约是 ±4.9E-324 到 ±1.7976931348623157E308，精度大约为 15 到 17 位有效数字。
计算精度取决于小数位（尾数）。小数位越多，则能表示的数越大，那么计算精度则越高。
一个数由若干位数字组成，其中影响测量精度的数字称作有效数字，也称有效数位。有效数字指科学计算中用以表示一个浮点数精度的那些数字。一般地，指一个用小数形式表示的浮点数中，从第一个非零的数字算起的所有数字。如 1.24 和 0.00124 的有效数字都有 3 位。
以下是确定有效数字的一些基本规则：

非零数字总是有效的。
位于两个非零数字之间的零是有效的。
对于小数，从左侧开始的第一个非零数字之前的零是无效的。
对于整数，从右侧开始的第一个非零数字之后的零是无效的。

下面是一些示例，说明如何确定有效数字：

1234：4 个有效数字（所有数字都是非零数字）
1002：4 个有效数字（零位于两个非零数字之间）
0.00234：3 个有效数字（从左侧开始的前两个零是无效的）
1200：2 个有效数字（从右侧开始的两个零是无效的）

04、int 和 char 类型互转 
int 和 char 之间比较特殊，可以互转，也会在以后的学习当中经常遇到。
1）可以通过强制类型转换将整型 int 转换为字符 char。
123int value_int &#x3D; 65;char value_char  &#x3D; (char) value_int;System.out.println(value_char);
输出 A (其 ASCII 值可以通过整数 65 来表示)。
2）可以使用 Character.forDigit() 方法将整型 int 转换为字符 char，参数 radix 为基数，十进制为 10，十六进制为 16。
1234int radix &#x3D; 10;int value_int &#x3D; 6;char value_char &#x3D; Character.forDigit(value_int , radix);System.out.println(value_char );
Character 为 char 的包装器类型。我们随后会讲。
3）可以使用 int 的包装器类型 Integer 的 toString() 方法+String 的 charAt() 方法转成 char。
123int value_int &#x3D; 1;char value_char &#x3D; Integer.toString(value_int).charAt(0);System.out.println(value_char );
4）char 转 int
当然了，如果只是简单的 char 转 int，直接赋值就可以了。
1int a &#x3D; &#39;a&#39;;
因为发生了自动类型转换，后面会细讲。
05、包装器类型 
包装器类型（Wrapper Types）是 Java 中的一种特殊类型，用于将基本数据类型（如 int、float、char 等）转换为对应的对象类型。

Java 提供了以下包装器类型，与基本数据类型一一对应：
Byte（对应 byte）
Short（对应 short）
Integer（对应 int）
Long（对应 long）
Float（对应 float）
Double（对应 double）
Character（对应 char）
Boolean（对应 boolean）

包装器类型允许我们使用基本数据类型提供的各种实用方法，并兼容需要对象类型的场景。例如，我们可以使用 Integer 类的 parseInt 方法将字符串转换为整数，或使用 Character 类的 isDigit 方法检查字符是否为数字，还有前面提到的 Character.forDigit() 方法。
下面是一个简单的示例，演示了如何使用包装器类型：
123456789101112131415&#x2F;&#x2F; 使用 Integer 包装器类型Integer integerValue &#x3D; new Integer(42);System.out.println(&quot;整数值: &quot; + integerValue);&#x2F;&#x2F; 将字符串转换为整数String numberString &#x3D; &quot;123&quot;;int parsedNumber &#x3D; Integer.parseInt(numberString);System.out.println(&quot;整数值: &quot; + parsedNumber);&#x2F;&#x2F; 使用 Character 包装器类型Character charValue &#x3D; new Character(&#39;A&#39;);System.out.println(&quot;字符: &quot; + charValue);&#x2F;&#x2F; 检查字符是否为数字char testChar &#x3D; &#39;9&#39;;if (Character.isDigit(testChar)) {System.out.println(&quot;字符是个数字.&quot;);}
上面的示例中，我们创建了一个 Integer 类型的对象 integerValue 并为其赋值 42。然后，我们将其值打印到控制台。
我们有一个包含数字的字符串 numberString。我们使用 Integer.parseInt() 方法将其转换为整数 parsedNumber。然后，我们将转换后的值打印到控制台。
我们有一个字符变量 testChar，并为其赋值字符 ‘9’。我们使用 Character.isDigit() 方法检查 testChar 是否为数字字符。如果是数字字符，我们将输出一条消息到控制台。
从 Java 5 开始，自动装箱（Autoboxing）和自动拆箱（Unboxing）机制允许我们在基本数据类型和包装器类型之间自动转换，无需显式地调用构造方法或转换方法。
12Integer integerValue &#x3D; 42; &#x2F;&#x2F; 自动装箱，等同于 new Integer(42)int primitiveValue &#x3D; integerValue; &#x2F;&#x2F; 自动拆箱，等同于 integerValue.intValue()
06、引用数据类型 
基本数据类型在作为成员变量和静态变量的时候有默认值，引用数据类型也有的（学完数组&amp;字符串，以及面向对象编程后会更加清楚，这里先简单过一下）。
String 是最典型的引用数据类型，所以我们就拿 String 类举例，看下面这段代码：
123456789101112&#x2F;** * @author 微信搜「二哈进阶之路」 *&#x2F;public class LocalRef {    private String a;    static String b;    public static void main(String[] args) {        LocalRef lv &#x3D; new LocalRef();        System.out.println(lv.a);        System.out.println(b);    }}
输出结果如下所示：
12nullnull
null 在 Java 中是一个很神奇的存在，在你以后的程序生涯中，见它的次数不会少，尤其是伴随着令人烦恼的“空指针异常”，也就是所谓的 NullPointerException 。
也就是说，引用数据类型的默认值为 null，包括数组和接口。
那你是不是很好奇，为什么数组和接口也是引用数据类型啊？
先来看数组：
12int [] arrays &#x3D; {1,2,3};System.out.println(arrays);
arrays 是一个 int 类型的数组，对吧？打印结果如下所示：
1[I@2d209079
[I 表示数组是 int 类型的，@ 后面是十六进制的 hashCode——这样的打印结果太“人性化”了，一般人表示看不懂！为什么会这样显示呢？查看一下 java.lang.Object 类的 toString() 方法就明白了。

数组虽然没有显式定义成一个类，但它的确是一个对象，继承了祖先类 Object 的所有方法。那为什么数组不单独定义一个类来表示呢？就像字符串 String 类那样呢？
一个合理的解释是 Java 将其隐藏了。假如真的存在一个 Array.java，我们也可以假想它真实的样子，它必须要定义一个容器来存放数组的元素，就像 String 类那样。
12345public final class String    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {    &#x2F;** The value is used for character storage. *&#x2F;    private final char value[];}
数组内部定义数组？没必要的！
再来看接口：
12List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();System.out.println(list);
List 是一个非常典型的接口：
1public interface List&lt;E&gt; extends Collection&lt;E&gt; {}
而 ArrayList 是 List 接口的一个实现：
123public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable{}
对于接口类型的引用变量来说，你没法直接 new 一个：

只能 new 一个实现它的类的对象——那自然接口也是引用数据类型了。
来看一下基本数据类型和引用数据类型之间最大的差别。
基本数据类型：

变量名指向具体的数值。
基本数据类型存储在栈上。

引用数据类型：

变量名指向的是存储对象的内存地址，在栈上。
内存地址指向的对象存储在堆上。

07、堆和栈 
堆是堆（heap），栈是栈（stack），如果看到“堆栈”的话，请不要怀疑自己，那是翻译的错，堆栈也是栈，反正我很不喜欢“堆栈”这种叫法，容易让新人掉坑里。
堆是在程序运行时在内存中申请的空间（可理解为动态的过程）；切记，不是在编译时；因此，Java 中的对象就放在这里，这样做的好处就是：

当需要一个对象时，只需要通过 new 关键字写一行代码即可，当执行这行代码时，会自动在内存的“堆”区分配空间——这样就很灵活。

栈，能够和处理器（CPU，也就是脑子）直接关联，因此访问速度更快。既然访问速度快，要好好利用啊！Java 就把对象的引用放在栈里。为什么呢？因为引用的使用频率高吗？
不是的，因为 Java 在编译程序时，必须明确的知道存储在栈里的东西的生命周期，否则就没法释放旧的内存来开辟新的内存空间存放引用——空间就那么大，前浪要把后浪拍死在沙滩上啊。
这么说就理解了吧？
用图来表示一下，左侧是栈，右侧是堆。

这里再补充一些额外的知识点，能看懂就继续吸收，看不懂可以先去学下一节，以后再来补，没关系的。学习就是这样，可以跳过，可以温故。
举个例子。
1String a &#x3D; new String(&quot;沉默&quot;)
这段代码会先在堆里创建一个 沉默的字符串对象，然后再把对象的引用 a 放到栈里面。这里面还会涉及到字符串常量池，后面会讲。
那么对于这样一段代码，有基本数据类型的变量，有引用类型的变量，堆和栈都是如何存储他们的呢？
123456public void test(){    int i &#x3D; 4;    int y &#x3D; 2;    Object o1 &#x3D; new Object();}
我来画个图表示下。

08、小结 
本文详细探讨了 Java 数据类型，包括比特与字节、基本数据类型、单精度与双精度、int 与 char 互转、包装器类型、引用数据类型以及堆与栈的内存模型。通过阅读本文，你将全面了解 Java 数据类型的概念与使用方法，为 Java 编程打下坚实基础。
1.4 Java数据类型转换数据类型转换的目的是确保在表达式求值时，不同类型的数据能够相互兼容。
01、自动类型转换 
自动类型转换（自动类型提升）是 Java 编译器在不需要显式转换的情况下，将一种基本数据类型自动转换为另一种基本数据类型的过程。这种转换通常发生在表达式求值期间，当不同类型的数据需要相互兼容时。自动类型转换遵循以下规则：

如果任何操作数是 double 类型，其他操作数将被转换为 double 类型。
否则，如果任何操作数是 float 类型，其他操作数将被转换为 float 类型。
否则，如果任何操作数是 long 类型，其他操作数将被转换为 long 类型。
否则，所有操作数将被转换为 int 类型。

需要注意的是，自动类型转换只发生在兼容类型之间。例如，从较小的数据类型（如 int）到较大的数据类型（如 long 或 double）的转换是安全的，因为较大的数据类型可以容纳较小数据类型的所有可能值。
12byte -&gt; short -&gt; int -&gt; long -&gt; float -&gt; doublechar -&gt; int -&gt; long -&gt; float -&gt; double
下面是一个简单的示例，演示了自动类型转换：
12345int intValue &#x3D; 5;double doubleValue &#x3D; 2.5;&#x2F;&#x2F; 自动类型转换：intValue 被转换为 double 类型double result &#x3D; intValue * doubleValue;System.out.println(&quot;结果: &quot; + result); &#x2F;&#x2F; 输出：结果: 12.5
在这个示例中，我们有一个 int 类型的变量 intValue 和一个 double 类型的变量 doubleValue。当我们将它们相乘时，根据自动类型转换的规则，intValue 将被转换为 double 类型，以便将两个 double 类型的操作数相乘。最终结果将是一个 double 类型的值：12.5。
再来举个例子，顾客到超市购物，购买牙膏 2 盒，面巾纸 4 盒。其中牙膏的价格是 10.9 元，面巾纸的价格是 5.8 元，求商品总价格。实现代码如下：
123456float price1 &#x3D; 10.9f; &#x2F;&#x2F; 定义牙膏的价格，单精度浮点型floatdouble price2 &#x3D; 5.8; &#x2F;&#x2F; 定义面巾纸的价格，双精度浮点型doubleint num1 &#x3D; 2; &#x2F;&#x2F; 定义牙膏的数量，整型 intint num2 &#x3D; 4; &#x2F;&#x2F; 定义面巾纸的数量double res &#x3D; price1 * num1 + price2 * num2; &#x2F;&#x2F; 计算总价System.out.println(&quot;一共付给收银员&quot; + res + &quot;元&quot;); &#x2F;&#x2F; 输出总价
上述代码中首先定义了一个 float 类型的变量存储牙膏的价格，然后定义了一个 double 类型的变量存储面巾纸的价格，再定义两个 int 类型的变量存储物品的数量，最后进行了乘运算以及和运算之后，将结果储存在一个 double 类型的变量中进行输出。
1一共付给收银员44.99999923706055元
从执行结果看出，float、int 和 double 三种数据类型参与运算，最后输出的结果为 double 类型的数据。这种转换一般称为“表达式中类型的自动提升”。
自动类型提升有好处，但它也会引起令人疑惑的编译错误。例如，下面看起来正确的程序却会引起问题：
12byte b &#x3D; 50;b &#x3D; b * 2; &#x2F;&#x2F; Type mismatch: cannot convert from int to byte
如上所示，第二行会报“类型不匹配：无法从int转换为byte”错误。
该程序试图将一个完全合法的 byte 型的值 50*2 存储给一个 byte 型的变量。但是当表达式求值的时候，操作数被自动的提升为 int 型，计算结果也被提升为 int 型。这样表达式的结果现在是 int 型，不强制转换它就不能被赋为 byte 型。
所以应该使用一个显示的强制类型转换，例如：
12byte b &#x3D; 50;b &#x3D; (byte)(b*2);
这样就能产生正确的值 100。
注意：char 类型比较特殊，char 自动转换成 int、long、float 和 double，但 byte 和 short 不能自动转换为 char，而且 char 也不能自动转换为 byte 或 short。
02、强制类型转换 
强制类型转换是 Java 中将一种数据类型显式转换为另一种数据类型的过程。与自动类型转换不同，强制类型转换需要程序员显式地指定要执行的转换。强制类型转换在以下情况中可能需要：

将较大的数据类型转换为较小的数据类型。
将浮点数转换为整数。
将字符类型转换为数值类型。

需要注意的是，强制类型转换可能会导致数据丢失或精度降低，因为目标类型可能无法容纳原始类型的所有可能值。因此，在进行强制类型转换时，需要确保转换后的值仍然在目标类型的范围内。
1double -&gt; float -&gt; long -&gt; int -&gt; char -&gt; short -&gt; byte
以下是一个简单的示例，演示了强制类型转换：
1234double doubleValue &#x3D; 42.8;&#x2F;&#x2F; 强制类型转换：将 double 类型转换为 int 类型int intValue &#x3D; (int) doubleValue;System.out.println(&quot;整数值: &quot; + intValue); &#x2F;&#x2F; 输出：整数值: 42
在这个示例中，我们有一个 double 类型的变量 doubleValue。我们希望将其转换为 int 类型的变量 intValue。为此，我们使用强制类型转换语法，即在要转换的变量之前加上目标类型的括号（如 (int)）。
需要注意的是，将 doubleValue 转换为 int 类型时，小数部分将被截断。因此，输出结果将是：Integer value: 42。在这种情况下，精度丢失是可以接受的，但在其他情况下，我们可能需要更加小心地处理类型转换以避免数据丢失。
顾客到超市购物，购买牙膏 2 盒，面巾纸 4 盒。其中牙膏的价格是 10.9 元，面巾纸的价格是 5.8 元，求商品总价格，在计算总价时采用 int 类型的数据进行存储。实现代码如下：
123456float price1 &#x3D; 10.9f;double price2 &#x3D; 5.8;int num1 &#x3D; 2;int num2 &#x3D; 4;int res2 &#x3D; (int) (price1 * num1 + price2 * num2);System.out.println(&quot;一共付给收银员&quot; + res2 + &quot;元&quot;);
在上述实例中，有 double 类型、float 类型和 int 类型的数据参与运算，其运算结果默认为 double 类型，题目要求的结果为 int 类型，因为 int 类型的取值范围要小于 double 类型的取值范围，所以需要进行强制类型转换。
1一共付给收银员44元
1.5 Java基本数据类型缓存池“考你一个问题哈： new Integer(18) 与 Integer.valueOf(18) 的区别是什么？”
new Integer(18) 每次都会新建一个对象;
Integer.valueOf(18) 会使⽤用缓存池中的对象，多次调用只会取同⼀一个对象的引用。
来看下面这段代码：
123456789Integer x &#x3D; new Integer(18);Integer y &#x3D; new Integer(18);System.out.println(x &#x3D;&#x3D; y);Integer z &#x3D; Integer.valueOf(18);Integer k &#x3D; Integer.valueOf(18);System.out.println(z &#x3D;&#x3D; k);Integer m &#x3D; Integer.valueOf(300);Integer p &#x3D; Integer.valueOf(300);System.out.println(m &#x3D;&#x3D; p);
来看一下输出结果吧：
123falsetruefalse
“第一个 false，我知道原因，因为 new 出来的是不同的对象，地址不同。”“第二个和第三个我认为都应该是 true 啊，为什么第三个会输出 false 呢？这个我理解不了。”
“其实原因也很简单。”我胸有成竹地说。
基本数据类型的包装类除了 Float 和 Double 之外，其他六个包装器类（Byte、Short、Integer、Long、Character、Boolean）都有常量缓存池。

Byte：-128~127，也就是所有的 byte 值
Short：-128~127
Long：-128~127
Character：\u0000 - \u007F
Boolean：true 和 false

拿 Integer 来举例子，Integer 类内部中内置了 256 个 Integer 类型的缓存数据，当使用的数据范围在 -128~127 之间时，会直接返回常量池中数据的引用，而不是创建对象，超过这个范围时会创建新的对象。
18 在 -128~127 之间，300 不在。
来看一下 valueOf 方法的源码吧。
12345public static Integer valueOf(int i) {    if (i &gt;&#x3D;IntegerCache.low &amp;&amp; i &lt;&#x3D;IntegerCache.high)        return IntegerCache.cache[i + (-IntegerCache.low)];    return new Integer(i);}
“哦，原来是因为 Integer.IntegerCache 这个内部类的原因啊！”
“是滴。来看一下 IntegerCache 这个静态内部类的源码吧。”
1234567891011121314151617181920212223242526272829private static class IntegerCache {    static final int low &#x3D; -128;    static final int high;    static final Integer cache[];    static {        &#x2F;&#x2F; high value may be configured by property        int h &#x3D; 127;        String integerCacheHighPropValue &#x3D;                sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);        if (integerCacheHighPropValue !&#x3D; null) {            try {                int i &#x3D; parseInt(integerCacheHighPropValue);                i &#x3D; Math.max(i, 127);                &#x2F;&#x2F; Maximum array size is Integer.MAX_VALUE                h &#x3D; Math.min(i, Integer.MAX_VALUE - (-low) -1);            } catch( NumberFormatException nfe) {                &#x2F;&#x2F; If the property cannot be parsed into an int, ignore it.            }        }        high &#x3D; h;        cache &#x3D; new Integer[(high - low) + 1];        int j &#x3D; low;        for(int k &#x3D; 0; k &lt; cache.length; k++)            cache[k] &#x3D; new Integer(j++);        &#x2F;&#x2F; range [-128, 127] must be interned (JLS7 5.1.7)        assert Integer.IntegerCache.high &gt;&#x3D; 127;    }    private IntegerCache() {}}
详细解释下：当我们通过 Integer.valueOf() 方法获取整数对象时，会先检查该整数是否在 IntegerCache 中，如果在，则返回缓存中的对象，否则创建一个新的对象并缓存起来。
需要注意的是，如果使用 new Integer() 创建对象，即使值在 -128 到 127 范围内，也不会被缓存，每次都会创建新的对象。因此，推荐使用 Integer.valueOf() 方法获取整数对象。
学习 static 关键字的时候，会详细解释静态代码块，你暂时先记住，静态代码块通常用来初始化一些静态变量，它会优先于 main() 方法执行。
在静态代码块中，low 为 -128，也就是缓存池的最小值；high 默认为 127，也就是缓存池的最大值，共计 256 个。
可以在 JVM 启动的时候，通过 -XX:AutoBoxCacheMax&#x3D;NNN来设置缓存池的大小，当然了，不能无限大，最大到 Integer.MAX_VALUES - 129
之后，初始化 cache 数组的大小，然后遍历填充，下标从 0 开始。
“这段代码不难理解，难理解的是 assert Integer.IntegerCache.high &gt;&#x3D; 127; ，这行代码是干嘛的呀？”
assert 是 Java 中的一个关键字，寓意是断言，为了方便调试程序，并不是发布程序的组成部分。
默认情况下，断言是关闭的，可以在命令行运行 Java 程序的时候加上 -ea 参数打开断言。
来看这段代码。
123456public class AssertTest {    public static void main(String[] args) {        int high &#x3D; 126;        assert high &gt;&#x3D; 127;    }}
假设手动设置的缓存池大小为 126，显然不太符合缓存池的预期值 127，结果会输出什么呢？直接在 Intellij IDEA 中打开命令行终端，进入 classes 文件，执行：
1&#x2F;usr&#x2F;libexec&#x2F;java_home -v 1.8 --exec java -ea com.itwanger.s51.AssertTest
我用的 macOS 环境，装了好多个版本的 JDK，该命令可以切换到 JDK 8
也可以不指定 Java 版本直接执行（加上 -ea 参数）：
1java -ea com.itwanger.s51.AssertTest
“呀，报错了呀。”
12Exception in thread &quot;main&quot; java.lang.AssertionError        at com.itwanger.s51.AssertTest.main(AssertTest.java:9)
“是滴，因为 126 小于 127。”
“原来 assert 是这样用的啊，我明白了。”
在 Java 中，针对一些基本数据类型（如 Integer、Long、Boolean 等），Java 会在程序启动时创建一些常用的对象并缓存在内存中，以提高程序的性能和节省内存开销。这些常用对象被缓存在一个固定的范围内，超出这个范围的值会被重新创建新的对象。
使用数据类型缓存池可以有效提高程序的性能和节省内存开销，但需要注意的是，在特定的业务场景下，缓存池可能会带来一些问题，例如缓存池中的对象被不同的线程同时修改，导致数据错误等问题。因此，在实际开发中，需要根据具体的业务需求来决定是否使用数据类型缓存池。
1.6 Java运算符运算符在 Java 中占据着重要的位置，对程序的执行有着很大的帮助。除了常见的加减乘除，还有许多其他类型的运算符，来看下面这张思维导图。”

01、算术运算符 
算术运算符除了最常见的加减乘除，还有一个取余的运算符，用于得到除法运算后的余数，来串代码感受下。
12345678910111213int a &#x3D; 10;int b &#x3D; 5;System.out.println(a + b);&#x2F;&#x2F;15System.out.println(a - b);&#x2F;&#x2F;5System.out.println(a * b);&#x2F;&#x2F;50System.out.println(a &#x2F; b);&#x2F;&#x2F;2System.out.println(a % b);&#x2F;&#x2F;0b &#x3D; 3;System.out.println(a + b);&#x2F;&#x2F;13System.out.println(a - b);&#x2F;&#x2F;7System.out.println(a * b);&#x2F;&#x2F;30System.out.println(a &#x2F; b);&#x2F;&#x2F;3System.out.println(a % b);&#x2F;&#x2F;1
对于初学者来说，加法（+）、减法（-）、乘法（*）很好理解，但除法（&#x2F;）和取余（%）会有一点点疑惑。在以往的认知里，10&#x2F;3 是除不尽的，结果应该是 3.333333…，而不应该是 3。相应的，余数也不应该是 1。这是为什么呢？
因为数字在程序中可以分为两种，一种是整型，一种是浮点型（不清楚的同学可以回头看看数据类型那篇），整型和整型的运算结果就是整型，不会出现浮点型。否则，就会出现浮点型。
1234567int a &#x3D; 10;float c &#x3D; 3.0f;double d &#x3D; 3.0;System.out.println(a &#x2F; c); &#x2F;&#x2F; 3.3333333System.out.println(a &#x2F; d); &#x2F;&#x2F; 3.3333333333333335System.out.println(a % c); &#x2F;&#x2F; 1.0System.out.println(a % d); &#x2F;&#x2F; 1.0
需要注意的是，当浮点数除以 0 的时候，结果为 Infinity 或者 NaN。
12System.out.println(10.0 &#x2F; 0.0); &#x2F;&#x2F; InfinitySystem.out.println(0.0 &#x2F; 0.0); &#x2F;&#x2F; NaN
Infinity 的中文意思是无穷大，NaN 的中文意思是这不是一个数字（Not a Number）。
当整数除以 0 的时候（ 10 &#x2F; 0 ），会抛出异常：
12Exception in thread &quot;main&quot; java.lang.ArithmeticException: &#x2F; by zero    at com.itwanger.eleven.ArithmeticOperator.main(ArithmeticOperator.java:32)
所以整数在进行除法运算时，需要先判断除数是否为 0，以免程序抛出异常。
算术运算符中还有两种特殊的运算符，自增运算符（++）和自减运算符（—），它们也叫做一元运算符，只有一个操作数。
12345int x &#x3D; 10;System.out.println(x++);&#x2F;&#x2F;10 (11)  System.out.println(++x);&#x2F;&#x2F;12  System.out.println(x--);&#x2F;&#x2F;12 (11)  System.out.println(--x);&#x2F;&#x2F;10 
一元运算符可以放在数字的前面或者后面，放在前面叫前自增（前自减），放在后面叫后自增（后自减）。
前自增和后自增是有区别的，拿 int y &#x3D; ++x 这个表达式来说（x &#x3D; 10），它可以拆分为 x &#x3D; x+1 &#x3D; 11; y &#x3D; x &#x3D; 11 ，所以表达式的结果为 x &#x3D; 11, y &#x3D; 11 。拿 int y &#x3D; x++ 这个表达式来说（x &#x3D; 10），它可以拆分为 y &#x3D; x &#x3D; 10; x &#x3D; x+1 &#x3D; 11 ，所以表达式的结果为 x &#x3D; 11, y &#x3D; 10 。
123456int x &#x3D; 10;int y &#x3D; ++x;System.out.println(y + &quot; &quot; + x);&#x2F;&#x2F; 11 11x &#x3D; 10;y &#x3D; x++;System.out.println(y + &quot; &quot; + x);&#x2F;&#x2F; 10 11
对于前自减和后自减来说，你可以自己试一把。
02、关系运算符 
关系运算符用来比较两个操作数，返回结果为 true 或者 false。

来看示例：
1234567int a &#x3D; 10, b &#x3D; 20;System.out.println(a &#x3D;&#x3D; b); &#x2F;&#x2F; falseSystem.out.println(a !&#x3D; b); &#x2F;&#x2F; trueSystem.out.println(a &gt; b); &#x2F;&#x2F; falseSystem.out.println(a &lt; b); &#x2F;&#x2F; trueSystem.out.println(a &gt;&#x3D; b); &#x2F;&#x2F; falseSystem.out.println(a &lt;&#x3D; b); &#x2F;&#x2F; true
03、位运算符 
在学习位运算符之前，需要先学习一下二进制，因为位运算符操作的不是整型数值（int、long、short、char、byte）本身，而是整型数值对应的二进制。
12System.out.println(Integer.toBinaryString(60)); &#x2F;&#x2F; 111100System.out.println(Integer.toBinaryString(13)); &#x2F;&#x2F; 1101
从程序的输出结果可以看得出来，60 的二进制是 0011 1100（用 0 补到 8 位），13 的二进制是 0000 1101。
PS：现代的二进制记数系统由戈特弗里德·威廉·莱布尼茨于 1679 年设计。莱布尼茨是德意志哲学家、数学家，历史上少见的通才。

来看示例：
1234567891011121314151617int a &#x3D; 60, b &#x3D; 13;System.out.println(&quot;a 的二进制：&quot; + Integer.toBinaryString(a)); &#x2F;&#x2F; 111100System.out.println(&quot;b 的二进制：&quot; + Integer.toBinaryString(b)); &#x2F;&#x2F; 1101int c &#x3D; a &amp; b;System.out.println(&quot;a &amp; b：&quot; + c + &quot;，二进制是：&quot; + Integer.toBinaryString(c));c &#x3D; a | b;System.out.println(&quot;a | b：&quot; + c + &quot;，二进制是：&quot; + Integer.toBinaryString(c));c &#x3D; a ^ b;System.out.println(&quot;a ^ b：&quot; + c + &quot;，二进制是：&quot; + Integer.toBinaryString(c));c &#x3D; ~a;System.out.println(&quot;~a：&quot; + c + &quot;，二进制是：&quot; + Integer.toBinaryString(c));c &#x3D; a &lt;&lt; 2;System.out.println(&quot;a &lt;&lt; 2：&quot; + c + &quot;，二进制是：&quot; + Integer.toBinaryString(c));c &#x3D; a &gt;&gt; 2;System.out.println(&quot;a &gt;&gt; 2：&quot; + c + &quot;，二进制是：&quot; + Integer.toBinaryString(c));c &#x3D; a &gt;&gt;&gt; 2;System.out.println(&quot;a &gt;&gt;&gt; 2：&quot; + c + &quot;，二进制是：&quot; + Integer.toBinaryString(c));
对于初学者来说，位运算符无法从直观上去计算出结果，不像加减乘除那样。因为我们日常接触的都是十进制，位运算的时候需要先转成二进制，然后再计算出结果。
鉴于此，初学者在写代码的时候其实很少会用到位运算。对于编程高手来说，为了提高程序的性能，会在一些地方使用位运算。比如说，HashMap 在计算哈希值的时候：
1234static final int hash(Object key) {    int h;    return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);}
如果对位运算一点都不懂的话，遇到这样的源码就很吃力。所以说，虽然位运算用的少，但还是要懂。
1）按位左移运算符：
1234System.out.println(10&lt;&lt;2);&#x2F;&#x2F;10*2^2&#x3D;10*4&#x3D;40  System.out.println(10&lt;&lt;3);&#x2F;&#x2F;10*2^3&#x3D;10*8&#x3D;80  System.out.println(20&lt;&lt;2);&#x2F;&#x2F;20*2^2&#x3D;20*4&#x3D;80  System.out.println(15&lt;&lt;4);&#x2F;&#x2F;15*2^4&#x3D;15*16&#x3D;240 
10&lt;&lt;2 等于 10 乘以 2 的 2 次方； 10&lt;&lt;3 等于 10 乘以 2 的 3 次方。
2）按位右移运算符：
123System.out.println(10&gt;&gt;2);&#x2F;&#x2F;10&#x2F;2^2&#x3D;10&#x2F;4&#x3D;2System.out.println(20&gt;&gt;2);&#x2F;&#x2F;20&#x2F;2^2&#x3D;20&#x2F;4&#x3D;5System.out.println(20&gt;&gt;3);&#x2F;&#x2F;20&#x2F;2^3&#x3D;20&#x2F;8&#x3D;2
10&gt;&gt;2 等于 10 除以 2 的 2 次方； 20&gt;&gt;2 等于 20 除以 2 的 2 次方。
04、逻辑运算符 
逻辑与运算符（&amp;&amp;）：多个条件中只要有一个为 false 结果就为 false。
逻辑或运算符（||）：多个条件只要有一个为 true 结果就为 true。
12345int a&#x3D;10;int b&#x3D;5;int c&#x3D;20;System.out.println(a&lt;b&amp;&amp;a&lt;c);&#x2F;&#x2F;false &amp;&amp; true &#x3D; falseSystem.out.println(a&gt;b||a&lt;c);&#x2F;&#x2F;true || true &#x3D; true
逻辑非运算符（!）：用来反转条件的结果，如果条件为 true，则逻辑非运算符将得到 false。
单逻辑与运算符（&amp;）：很少用，因为不管第一个条件为 true 还是 false，依然会检查第二个。
单逻辑或运算符（|）：也会检查第二个条件。
也就是说，&amp; 和 | 性能不如 &amp;&amp; 和 ||，但用法一样：
12345int a&#x3D;10;int b&#x3D;5;int c&#x3D;20;System.out.println(a&lt;b&amp;a&lt;c);&#x2F;&#x2F;false &amp; true &#x3D; falseSystem.out.println(a&gt;b|a&lt;c);&#x2F;&#x2F;true | true &#x3D; true  
05、赋值运算符 
赋值操作符恐怕是 Java 中使用最频繁的操作符了，它就是把操作符右侧的值赋值给左侧的变量。来看示例：
123456int a&#x3D;10;int b&#x3D;20;a+&#x3D;4;&#x2F;&#x2F;a&#x3D;a+4 (a&#x3D;10+4)  b-&#x3D;4;&#x2F;&#x2F;b&#x3D;b-4 (b&#x3D;20-4)  System.out.println(a);System.out.println(b);
不过在进行数值的赋值时，需要小点心，比如说下面这种情况：

编译器之所以提示错误，是因为 &#x3D; 右侧的算术表达式默认为 int 类型，左侧是 short 类型的时候需要进行强转。
12345short a &#x3D; 10;short b &#x3D; 10;&#x2F;&#x2F;a+&#x3D;b;&#x2F;&#x2F;a&#x3D;a+b internally so finea &#x3D; (short)(a + b);System.out.println(a);
除此之外，还会有边界问题，比如说，两个非常大的 int 相乘，结果可能就超出了 int 的范围：
1234int a &#x3D; Integer.MAX_VALUE;int b &#x3D; 10000;int c &#x3D; a * b;System.out.println(c); &#x2F;&#x2F; -10000
程序输出的结果为 -10000，这个答案很明显不是我们想要的结果，虽然可以通过右侧表达式强转 long 的方法解决：
1234int a &#x3D; Integer.MAX_VALUE;int b &#x3D; 10000;long c &#x3D; (long)a * b;System.out.println(c); &#x2F;&#x2F; 21474836470000
但尽量不要这样做，结果非常大的时候，尽量提前使用相应的类型进行赋值。
1234long a &#x3D; Integer.MAX_VALUE - 1;long b &#x3D; 10000;long c &#x3D; a * b;System.out.println(c); &#x2F;&#x2F; 21474836460000
06、三元运算符 
三元运算符用于替代 if-else，可以使用一行代码完成条件判断的要求。来看示例：
1234int a&#x3D;2;int b&#x3D;5;int min&#x3D;(a&lt;b)?a:b;System.out.println(min);
如果 ? 前面的条件为 true，则结果为 : 前的值，否则为 : 后的值。
07、小结 
本文全面介绍了Java运算符，包括算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符等。通过阅读本文，您将了解到Java运算符的分类、用法和优先级，以及如何在实际开发中灵活运用各类运算符提高编程效率。
1.7 Java流程控制语句“流程控制语句都有哪些呢？”
“比如说 if-else、switch、for、while、do-while、return、break、continue 等等，接下来，我们一个个来了解下。”
01、if-else 相关

1）if 语句 
if 语句的格式如下：
123if(布尔表达式){  &#x2F;&#x2F; 如果条件为 true，则执行这块代码}
画个流程图表示一下：

来写个示例：
1234int age &#x3D; 20;if (age &lt; 30) {    System.out.println(&quot;青春年华&quot;);}
输出：
1青春年华
2）if-else 语句 
if-else 语句的格式如下:
12345if(布尔表达式){  &#x2F;&#x2F; 条件为 true 时执行的代码块}else{  &#x2F;&#x2F; 条件为 false  时执行的代码块} 
画个流程图表示一下：

来写个示例：
123456int age &#x3D; 31;if (age &lt; 30) {    System.out.println(&quot;青春年华&quot;);} else {    System.out.println(&quot;而立之年&quot;);}
输出：
1而立之年
除了这个例子之外，还有一个判断闰年（被 4 整除但不能被 100 整除或者被 400 整除）的例子：
123456int year &#x3D; 2020;if (((year % 4 &#x3D;&#x3D; 0) &amp;&amp; (year % 100 !&#x3D; 0)) || (year % 400 &#x3D;&#x3D; 0)) {    System.out.println(&quot;闰年&quot;);} else {    System.out.println(&quot;普通年份&quot;);}
输出：
1闰年
如果执行语句比较简单的话，可以使用三元运算符来代替 if-else 语句，如果条件为 true，返回 ? 后面 : 前面的值；如果条件为 false，返回 : 后面的值。
123int num &#x3D; 13;String result &#x3D; (num % 2 &#x3D;&#x3D; 0) ? &quot;偶数&quot; : &quot;奇数&quot;;System.out.println(result);
输出：
1奇数
3）if-else-if 语句 
if-else-if 语句的格式如下：
123456789101112if(条件1){  &#x2F;&#x2F; 条件1 为 true 时执行的代码}else if(条件2){  &#x2F;&#x2F; 条件2 为 true 时执行的代码}  else if(条件3){  &#x2F;&#x2F; 条件3 为 true 时执行的代码}  ...  else{  &#x2F;&#x2F; 以上条件均为 false 时执行的代码} 
画个流程图表示一下：

来写个示例：
12345678910int age &#x3D; 31;if (age &lt; 30) {    System.out.println(&quot;青春年华&quot;);} else if (age &gt;&#x3D; 30 &amp;&amp; age &lt; 40 ) {    System.out.println(&quot;而立之年&quot;);} else if (age &gt;&#x3D; 40 &amp;&amp; age &lt; 50 ) {    System.out.println(&quot;不惑之年&quot;);} else {    System.out.println(&quot;知天命&quot;);}
输出：
1而立之年
4）if 嵌套语句 
if 嵌套语句的格式如下：
123456if(外侧条件){         &#x2F;&#x2F; 外侧条件为 true 时执行的代码     if(内侧条件){          &#x2F;&#x2F; 内侧条件为 true 时执行的代码    }    } 
画个流程图表示一下：

来写个示例：
1234567int age &#x3D; 20;boolean isGirl &#x3D; true;if (age &gt;&#x3D; 20) {    if (isGirl) {        System.out.println(&quot;女生法定结婚年龄&quot;);    }}
输出：
1女生法定结婚年龄
02、switch 语句 
switch 语句用来判断变量与多个值之间的相等性。变量的类型可以是 byte、short、int 或者 char，或者对应的包装器类型 Byte、Short、Integer、Character，以及字符串和枚举类型。
来看一下 switch 语句的格式：
123456789101112switch(变量) {    case 可选值1:     &#x2F;&#x2F; 可选值1匹配后执行的代码;     break;  &#x2F;&#x2F; 该关键字是可选项case 可选值2:     &#x2F;&#x2F; 可选值2匹配后执行的代码;     break;  &#x2F;&#x2F; 该关键字是可选项......        default: &#x2F;&#x2F; 该关键字是可选项      &#x2F;&#x2F; 所有可选值都不匹配后执行的代码 }    

变量可以有 1 个或者 N 个值。
值类型必须和变量类型是一致的，并且值是确定的。
值必须是唯一的，不能重复，否则编译会出错。
break 关键字是可选的，如果没有，则执行下一个 case，如果有，则跳出 switch 语句。
default 关键字也是可选的。

画个流程图：

来个示例：
123456789101112131415int age &#x3D; 20;switch (age) {    case 20 :        System.out.println(&quot;上学&quot;);        break;    case 24 :        System.out.println(&quot;苏州工作&quot;);        break;    case 30 :        System.out.println(&quot;洛阳工作&quot;);        break;    default:        System.out.println(&quot;未知&quot;);        break; &#x2F;&#x2F; 可省略}
输出：
1上学
当两个值要执行的代码相同时，可以把要执行的代码写在下一个 case 语句中，而上一个 case 语句中什么也没有，来看一下示例：
12345678910111213141516String name &#x3D; &quot;沉默王二&quot;;switch (name) {    case &quot;詹姆斯&quot;:        System.out.println(&quot;篮球运动员&quot;);        break;    case &quot;穆里尼奥&quot;:        System.out.println(&quot;足球教练&quot;);        break;    case &quot;沉默王二&quot;:    case &quot;沉默王三&quot;:        System.out.println(&quot;乒乓球爱好者&quot;);        break;    default:        throw new IllegalArgumentException(                &quot;名字没有匹配项&quot;);}
输出：
1乒乓球爱好者
枚举作为 switch 语句的变量也很常见，来看例子：
1234567891011121314151617181920212223242526public class SwitchEnumDemo {    public enum PlayerTypes {        TENNIS,        FOOTBALL,        BASKETBALL,        UNKNOWN    }    public static void main(String[] args) {        System.out.println(createPlayer(PlayerTypes.BASKETBALL));    }    private static String createPlayer(PlayerTypes playerType) {        switch (playerType) {            case TENNIS:                return &quot;网球运动员费德勒&quot;;            case FOOTBALL:                return &quot;足球运动员C罗&quot;;            case BASKETBALL:                return &quot;篮球运动员詹姆斯&quot;;            case UNKNOWN:                throw new IllegalArgumentException(&quot;未知&quot;);            default:                throw new IllegalArgumentException(                        &quot;运动员类型: &quot; + playerType);        }    }}
输出：
1篮球运动员詹姆斯
03、for 循环

1）普通 for 循环 
普通的 for 循环可以分为 4 个部分：
1）初始变量：循环开始执行时的初始条件。
2）条件：循环每次执行时要判断的条件，如果为 true，就执行循环体；如果为 false，就跳出循环。当然了，条件是可选的，如果没有条件，则会一直循环。
3）循环体：循环每次要执行的代码块，直到条件变为 false。
4）自增&#x2F;自减：初始变量变化的方式。
来看一下普通 for 循环的格式：
123for(初始变量;条件;自增&#x2F;自减){  &#x2F;&#x2F; 循环体} 
画个流程图：

来个示例：
123for (int i &#x3D; 0; i &lt; 5; i++) {    System.out.println(&quot;沉默好美啊&quot;);}
输出：
12345沉默好美啊沉默好美啊沉默好美啊沉默好美啊沉默好美啊
循环语句还可以嵌套呢，这样就可以打印出更好玩的呢
123456for (int i &#x3D; 0; i &lt; 5; i++) {    for (int j &#x3D; 0;j&lt;&#x3D; i;j++) {        System.out.print(&quot;❤&quot;);    }    System.out.println();}
打印出什么玩意呢？
12345❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤
2）for-each 
for-each 循环通常用于遍历数组和集合，它的使用规则比普通的 for 循环还要简单，不需要初始变量，不需要条件，不需要下标来自增或者自减。来看一下语法：
123for(元素类型 元素 : 数组或集合){  &#x2F;&#x2F; 要执行的代码}  
来看一下示例：
1234String[] strs &#x3D; {&quot;沉默&quot;, &quot;一枚有趣的程序员&quot;};for (String str : strs) {    System.out.println(str);}
输出：
12沉默一枚有趣的程序员
3）无限 for 循环 
“你想不想体验一下无限 for 循环的威力，也就是死循环。”
123for(;;){    System.out.println(&quot;停不下来。。。。&quot;);}
输出：
1234停不下来。。。。停不下来。。。。停不下来。。。。停不下来。。。。
一旦运行起来，就停不下来了，除非强制停止。
04、while 循环 
来看一下 while 循环的格式：

来个示例：
12345678int i &#x3D; 0;while (true) {    System.out.println(&quot;沉默&quot;);    i++;    if (i &#x3D;&#x3D; 5) {        break;    }}
输出：
12345沉默沉默沉默沉默沉默
“你想不想体验一下无限 while 循环的威力，也就是死循环。”
123while (true) {    System.out.println(&quot;停不下来。。。。&quot;);}
输出：
1234停不下来。。。。停不下来。。。。停不下来。。。。停不下来。。。。
把 while 的条件设置为 true，并且循环体中没有 break 关键字的话，程序一旦运行起来，就根本停不下来了，除非强制停止。
05、do-while 循环 
来看一下 do-while 循环的格式：
123do{  &#x2F;&#x2F; 循环体}while(提交);  
画个流程图：

来个示例：
12345678int i &#x3D; 0;do {    System.out.println(&quot;沉默&quot;);    i++;    if (i &#x3D;&#x3D; 5) {        break;    }} while (true);
输出：
12345沉默沉默沉默沉默沉默
“你想不想体验一下无限 do-while 循环的威力……”
123do {    System.out.println(&quot;停不下来。。。。&quot;);} while (true);
输出：
1234停不下来。。。。停不下来。。。。停不下来。。。。停不下来。。。。
把 do-while 的条件设置为 true，并且循环体中没有 break 关键字的话，程序一旦运行起来，就根本停不下来了，除非强制停止。

06、break 
break 关键字通常用于中断循环或 switch 语句，它在指定条件下中断程序的当前流程。如果是内部循环，则仅中断内部循环。
可以将 break 关键字用于所有类型循环语句中，比如说 for 循环、while 循环，以及 do-while 循环。
来画个流程图感受一下：

用在 for 循环中的示例：
123456for (int i &#x3D; 1; i &lt;&#x3D; 10; i++) {    if (i &#x3D;&#x3D; 5) {        break;    }    System.out.println(i);}
用在嵌套 for 循环中的示例：
12345678for (int i &#x3D; 1; i &lt;&#x3D; 3; i++) {    for (int j &#x3D; 1; j &lt;&#x3D; 3; j++) {        if (i &#x3D;&#x3D; 2 &amp;&amp; j &#x3D;&#x3D; 2) {            break;        }        System.out.println(i + &quot; &quot; + j);    }}
用在 while 循环中的示例：
123456789int i &#x3D; 1;while (i &lt;&#x3D; 10) {    if (i &#x3D;&#x3D; 5) {        i++;        break;    }    System.out.println(i);    i++;}
用在 do-while 循环中的示例：
123456789int j &#x3D; 1;do {    if (j &#x3D;&#x3D; 5) {         j++;        break;    }    System.out.println(j);    j++;} while (j &lt;&#x3D; 10);
用在 switch 语句中的示例：
1234567891011121314switch (age) {    case 20 :        System.out.println(&quot;上学&quot;);        break;    case 24 :        System.out.println(&quot;苏州工作&quot;);        break;    case 30 :        System.out.println(&quot;洛阳工作&quot;);        break;    default:        System.out.println(&quot;未知&quot;);        break; &#x2F;&#x2F; 可省略}
07、continue 
当我们需要在 for 循环或者 （do）while 循环中立即跳转到下一个循环时，就可以使用 continue 关键字，通常用于跳过指定条件下的循环体，如果循环是嵌套的，仅跳过当前循环。
来个示例：
1234567for (int i &#x3D; 1; i &lt;&#x3D; 10; i++) {    if (i &#x3D;&#x3D; 5) {        &#x2F;&#x2F; 使用 continue 关键字        continue;&#x2F;&#x2F; 5 将会被跳过    }    System.out.println(i);}
输出：
1234567891234678910
再来个循环嵌套的例子。
123456789for (int i &#x3D; 1; i &lt;&#x3D; 3; i++) {    for (int j &#x3D; 1; j &lt;&#x3D; 3; j++) {        if (i &#x3D;&#x3D; 2 &amp;&amp; j &#x3D;&#x3D; 2) {            &#x2F;&#x2F;  当i&#x3D;2，j&#x3D;2时跳过            continue;        }        System.out.println(i + &quot; &quot; + j);    }}
打印出什么玩意呢？
123456781 11 21 32 12 33 13 23 3
“2 2” 没有输出，被跳过了。
再来看一下 while 循环时 continue 的使用示例：
123456789int i &#x3D; 1;while (i &lt;&#x3D; 10) {    if (i &#x3D;&#x3D; 5) {        i++;        continue;    }    System.out.println(i);    i++;}
输出：
1234567891234678910
注意：如果把 if 条件中的“i++”省略掉的话，程序就会进入死循环，一直在 continue。
最后，再来看一下 do-while 循环时 continue 的使用示例：
123456789int i&#x3D;1;do{    if(i&#x3D;&#x3D;5){        i++;        continue;    }    System.out.println(i);    i++;}while(i&lt;&#x3D;10);
输出：
1234567891234678910
注意：同样的，如果把 if 条件中的“i++”省略掉的话，程序就会进入死循环，一直在 continue。
08、小结 
本文全面讲解了Java流程控制语句，包括if、switch、while、for等结构。通过学习本文，你将了解到Java流程控制语句的基本概念、语法结构和使用场景，帮助你在实际编程过程中更加灵活地运用各类控制结构。
2 数组&amp;字符串2.1 掌握Java数组“ArrayList 的内部是用数组实现的”
“的确是的，看 ArrayList 的源码就一清二楚了。”我一边说，一边打开 Intellij IDEA，并找到了 ArrayList 的源码。
12345678910111213&#x2F;** * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData &#x3D;&#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA * will be expanded to DEFAULT_CAPACITY when the first element is added. *&#x2F;transient Object[] elementData; &#x2F;&#x2F; non-private to simplify nested class access&#x2F;** * The size of the ArrayList (the number of elements it contains). * * @serial *&#x2F;private int size;
“瞧见没？ Object[] elementData 就是数组。”我指着显示屏上这串代码继续说。
数组是一个对象，它包含了一组固定数量的元素，并且这些元素的类型是相同的。数组会按照索引的方式将元素放在指定的位置上，意味着我们可以通过索引来访问这些元素。在 Java 中，索引是从 0 开始的。
“能说一下为什么索引从 0 开始吗？”
“哦，Java 是基于 C&#x2F;C++ 语言实现的，而 C 语言的下标是从 0 开始的，所以 Java 就继承了这个良好的传统习惯。C语言有一个很重要概念，叫做指针，它实际上是一个偏移量，距离开始位置的偏移量，第一个元素就在开始的位置，它的偏移量就为 0，所以索引就为 0。”此刻，我很自信。
“此外，还有另外一种说法。早期的计算机资源比较匮乏，0 作为起始下标相比较于 1 作为起始下标，编译的效率更高。”
我们可以将数组理解为一个个整齐排列的单元格，每个单元格里面存放着一个元素。
数组元素的类型可以是基本数据类型（比如说 int、double），也可以是引用数据类型（比如说 String），包括自定义类型。
数组的声明方式分两种。
先来看第一种：
1int[] anArray;
再来看第二种：
1int anOtherArray[];
不同之处就在于中括号的位置，是跟在类型关键字的后面，还是跟在变量的名称的后面。前一种的使用频率更高一些，像 ArrayList 的源码中就用了第一种方式。
同样的，数组的初始化方式也有多种，最常见的是：
1int[] anArray &#x3D; new int[10];
看到了没？上面这行代码中使用了 new 关键字，这就意味着数组的确是一个对象，只有对象的创建才会用到 new 关键字，基本数据类型是不用的。然后，我们需要在方括号中指定数组的长度。
这时候，数组中的每个元素都会被初始化为默认值，int 类型的就为 0，Object 类型的就为 null。 不同数据类型的默认值不同。
另外，还可以使用大括号的方式，直接初始化数组中的元素：
1int anOtherArray[] &#x3D; new int[] {1, 2, 3, 4, 5};
这时候，数组的元素分别是 1、2、3、4、5，索引依次是 0、1、2、3、4，长度是 5。
“怎么访问数组呢？”
前面提到过，可以通过索引来访问数组的元素，就像下面这样：
1anArray[0] &#x3D; 10;
变量名，加上中括号，加上元素的索引，就可以访问到数组，通过“&#x3D;”操作符可以对元素进行赋值。
如果索引的值超出了数组的界限，就会抛出 ArrayIndexOutOfBoundException 。
既然数组的索引是从 0 开始，那就是到数组的 length - 1 结束，不要使用超出这个范围内的索引访问数组，就不会抛出数组越界的异常了。 
当数组的元素非常多的时候，逐个访问数组就太辛苦了，所以需要通过遍历的方式。
第一种，使用 for 循环：
1234int anOtherArray[] &#x3D; new int[] {1, 2, 3, 4, 5};for (int i &#x3D; 0; i &lt; anOtherArray.length; i++) {    System.out.println(anOtherArray[i]);}
通过 length 属性获取到数组的长度，然后从 0 开始遍历，就得到了数组的所有元素。
第二种，使用 for-each 循环：
123for (int element : anOtherArray) {    System.out.println(element);}
如果不需要关心索引的话（意味着不需要修改数组的某个元素），使用 for-each 遍历更简洁一些。当然，也可以使用 while 和 do-while 循环。
在 Java 中，可变参数用于将任意数量的参数传递给方法，来看 varargsMethod() 方法：
1void varargsMethod(String... varargs) {}
该方法可以接收任意数量的字符串参数，可以是 0 个或者 N 个，本质上，可变参数就是通过数组实现的。为了证明这一点，我们可以看一下反编译一后的字节码：
123456789public class VarargsDemo{    public VarargsDemo()    {    }    transient void varargsMethod(String as[])    {    }}
所以，我们其实可以直接将数组作为参数传递给该方法：
123VarargsDemo demo &#x3D; new VarargsDemo();String[] anArray &#x3D; new String[] {&quot;沉默&quot;, &quot;一枚有趣的程序员&quot;};demo.varargsMethod(anArray);
也可以直接传递多个字符串，通过逗号隔开的方式：
1demo.varargsMethod(&quot;沉默&quot;, &quot;一枚有趣的程序员&quot;);
在 Java 中，数组与 List 关系非常密切。List 封装了很多常用的方法，方便我们对集合进行一些操作，而如果直接操作数组的话，有很多不便，因为数组本身没有提供这些封装好的操作，所以有时候我们需要把数组转成 List。
“怎么转呢？”
最原始的方式，就是通过遍历数组的方式，一个个将数组添加到 List 中。
12345int[] anArray &#x3D; new int[] {1, 2, 3, 4, 5};List&lt;Integer&gt; aList &#x3D; new ArrayList&lt;&gt;();for (int element : anArray) {    aList.add(element);}
更优雅的方式是通过 Arrays 类的 asList() 方法：
1List&lt;Integer&gt; aList &#x3D; Arrays.asList(anArray);
不过需要注意的是，Arrays.asList 的参数需要是 Integer 数组，而 anArray 目前是 int 类型，我们需要换另外一种方式。
1List&lt;Integer&gt; aList &#x3D; Arrays.stream(anArray).boxed().collect(Collectors.toList());
这又涉及到了 Java 流的知识，后面会讲到。
还有一个需要注意的是，Arrays.asList 方法返回的 ArrayList 并不是 java.util.ArrayList ，它其实是Arrays 类的一个内部类：
12private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;        implements RandomAccess, java.io.Serializable{}
如果需要添加元素或者删除元素的话，需要把它转成 java.util.ArrayList 。
1new ArrayList&lt;&gt;(Arrays.asList(anArray));
Java 8 新增了 Stream 流的概念，这就意味着我们也可以将数组转成 Stream 进行操作。
12String[] anArray &#x3D; new String[] {&quot;沉默&quot;, &quot;一枚有趣的程序员&quot;, &quot;好好珍重他&quot;};Stream&lt;String&gt; aStream &#x3D; Arrays.stream(anArray);
如果想对数组进行排序的话，可以使用 Arrays 类提供的 sort() 方法。

基本数据类型按照升序排列
实现了 Comparable 接口的对象按照 compareTo() 的排序

来看第一个例子：
12int[] anArray &#x3D; new int[] {5, 2, 1, 4, 8};Arrays.sort(anArray);
排序后的结果如下所示：
1[1, 2, 4, 5, 8]
来看第二个例子：
123String[] yetAnotherArray &#x3D; new String[] {&quot;A&quot;, &quot;E&quot;, &quot;Z&quot;, &quot;B&quot;, &quot;C&quot;};Arrays.sort(yetAnotherArray, 1, 3,                Comparator.comparing(String::toString).reversed());
只对 1-3 位置上的元素进行反序，所以结果如下所示：
1[A, Z, E, B, C]
有时候，我们需要从数组中查找某个具体的元素，最直接的方式就是通过遍历的方式：
1234567int[] anArray &#x3D; new int[] {5, 2, 1, 4, 8};for (int i &#x3D; 0; i &lt; anArray.length; i++) {    if (anArray[i] &#x3D;&#x3D; 4) {        System.out.println(&quot;找到了 &quot; + i);        break;    }}
上例中从数组中查询元素 4，找到后通过 break 关键字退出循环。
如果数组提前进行了排序，就可以使用二分查找法，这样效率就会更高一些。 Arrays.binarySearch() 方法可供我们使用，它需要传递一个数组，和要查找的元素。
12int[] anArray &#x3D; new int[] {1, 2, 3, 4, 5};int index &#x3D; Arrays.binarySearch(anArray, 4);
2.2 掌握Java二维数组01、什么是二维数组 
二维数组是一种数据类型，可以存储多行和多列的数据。它由一系列的行和列组成，每个元素都可以通过一个行索引和列索引来访问。例如，一个3行4列的二维数组可以表示为以下形式：
12345array &#x3D; [  [a, b, c, d],  [e, f, g, h],  [i, j, k, l]]
在这个例子中，第一行有4个元素，第二行有4个元素，第三行有4个元素，每个元素都有一个行索引和一个列索引。例如，元素 array[1][2] 是第2行第3列的元素，它的值是 g。
使用二维数组可以有效地存储和处理表格数据，如矩阵、图像、地图等等。
02、创建二维数组 
要在 Java 中创建二维数组，你必须指定要存储在数组中的数据类型，后跟两个方括号和数组的名称。
语法如下所示：
1data_type[][] array_name;
让我们看一个代码示例。
1int[][] oddNumbers &#x3D; { {1, 3, 5, 7}, {9, 11, 13, 15} };
03、访问二维数组中的元素 
我们可以使用两个方括号来访问二维中的元素。
第一个表示我们要从中访问元素的数组，而第二个表示我们要访问的元素索引。
让我们用一个例子来简化上面的解释：
123int[][] oddNumbers &#x3D; { {1, 3, 5, 7}, {9, 11, 13, 15} };System.out.println(oddNumbers[0][0]);&#x2F;&#x2F; 1
在上面的示例中， oddNumbers 数组中有两个数组—— {1, 3, 5, 7} 和 {9, 11, 13, 15} 。
第一个数组—— {1, 3, 5, 7} ——用 0 表示。
第二个数组—— {9, 11, 13, 15} ——用 1 表示。
第一个数组是 0，第二个是 1，第三个是 2，依此类推。
因此，要访问第一个数组中的项目，我们将 0 分配给第一个方括号。由于我们试图访问数组中的第一项，我们将使用它的索引，即 0： oddNumbers[0][0] 。
让我们进一步分解它。
这是访问元素的代码： oddNumbers[?][?] 。
我在两个方括号中都加上了问号——随着进展填写它们。
假设我们要访问第二个数组中的元素，我们的代码将如下所示： oddNumbers[1][?] 。
现在我们要在第二个数组（ {9, 11, 13, 15} ）中尝试访问其中一个元素。就像一维数组一样，每个元素都有一个从零开始的索引。
因此，要访问第三个元素 13 ，我们将其索引号传递给第二个方括号： oddNumbers[1][2] 。
来看这样一个例子：
1int[][] oddNumbers &#x3D; { {1, 3, 5, 7}, {9, 11, 13, 15}, {17, 19, 21, 23} };
我们的目标是访问第三个数组中的 21。访问方式仍然通过问号来表示： oddNumbers[?][?] 。
我们首先给第一个问号一个指向要访问的特定数组的值。
数组 0 &#x3D;&gt; {1, 3, 5, 7}
数组 1 &#x3D;&gt; {9, 11, 13, 15}
数组 2 &#x3D;&gt; {17, 19, 21, 23}
我们要查找的数字在第三个数组中，所以是： oddNumbers[2][?] 。
第二个方括号的值将指向要访问的元素。为此，我们必须指定元素的索引。以下是该数组中的索引：
17 &#x3D;&gt; 索引 0
19 &#x3D;&gt; 索引 1
21 &#x3D;&gt; 索引 2
23 &#x3D;&gt; 索引 3
21 的索引为 2，因此我们可以将其添加到第二个方括号： oddNumbers[2][2] 。当你将其打印到控制台时，将会打印出 21。
代码如下所示：
123int[][] oddNumbers &#x3D; { {1, 3, 5, 7}, {9, 11, 13, 15}, {17, 19, 21, 23} };System.out.println(oddNumbers[2][2]);&#x2F;&#x2F; 21
你可以使用嵌套循环，遍历二维数组中的所有项目。这是一个例子：
123456789101112131415161718int[][] oddNumbers &#x3D; { {1, 3, 5, 7}, {9, 11, 13, 15}, {17, 19, 21, 23} };for(int i &#x3D; 0; i &lt; oddNumbers.length; i++){    for(int j &#x3D; 0; j &lt; oddNumbers[i].length; j++){        System.out.println(oddNumbers[i][j]);    }   }&#x2F;&#x2F; 1&#x2F;&#x2F; 3&#x2F;&#x2F; 5&#x2F;&#x2F; 7&#x2F;&#x2F; 9&#x2F;&#x2F; 11&#x2F;&#x2F; 13&#x2F;&#x2F; 15&#x2F;&#x2F; 17&#x2F;&#x2F; 19&#x2F;&#x2F; 21&#x2F;&#x2F; 23
上面的代码将会打印出 oddNumbers 数组中的所有项目。
04、二维数组打印杨辉三角
12345678910111213141516171819202122232425262728import java.util.Scanner;public class YangHuiTriangle {    public static void main(String[] args) {        Scanner input &#x3D; new Scanner(System.in);        System.out.print(&quot;请输入要打印的行数：&quot;);        int n &#x3D; input.nextInt();        printYangHuiTriangle(n);    }    public static void printYangHuiTriangle(int n) {        int[][] triangle &#x3D; new int[n][n];        for (int i &#x3D; 0; i &lt; n; i++) {            &#x2F;&#x2F; 每行的第一个和最后一个数字都是1            triangle[i][0] &#x3D; 1;            triangle[i][i] &#x3D; 1;            for (int j &#x3D; 1; j &lt; i; j++) {                &#x2F;&#x2F; 其他数字是上一行的两个数字之和                triangle[i][j] &#x3D; triangle[i - 1][j - 1] + triangle[i - 1][j];            }        }        &#x2F;&#x2F; 打印杨辉三角        for (int i &#x3D; 0; i &lt; n; i++) {            for (int j &#x3D; 0; j &lt;&#x3D; i; j++) {                System.out.print(triangle[i][j] + &quot; &quot;);            }            System.out.println();        }    }}
“这段代码使用了一个二维数组来存储杨辉三角中的数字。首先，程序要求用户输入要打印的行数，然后调用 printYangHuiTriangle 方法来生成和打印杨辉三角。在 printYangHuiTriangle 方法中，程序使用了一个嵌套的 for 循环来计算杨辉三角中的每个数字，并将结果存储在二维数组 triangle 中。最后，程序再次使用循环来遍历数组并打印出杨辉三角中的数字。”
输出：
1234567请输入要打印的行数：61 1 1 1 2 1 1 3 3 1 1 4 6 4 1 1 5 10 10 5 1 
2.3 打印Java数组“数组也是一个对象，但 Java 中并未明确的定义这样一个类。”
“是的，因此数组也就没有机会覆盖 Object.toString() 方法。如果尝试直接打印数组的话，输出的结果并不是我们预期的结果。”
“那怎么打印数组呢？”
为什么不能直接打印数组
“首先，我们来看一下，为什么不能直接打印数组，直接打印的话，会出现什么问题。”
来看这样一个例子。
12String [] cmowers &#x3D; {&quot;沉默&quot;,&quot;一枚有趣的程序员&quot;};System.out.println(cmowers);
程序打印的结果是：
1[Ljava.lang.String;@3d075dc0
[Ljava.lang.String; 表示字符串数组的 Class 名，@ 后面的是十六进制的 hashCode——这样的打印结果太“人性化”了，一般人表示看不懂！为什么会这样显示呢？查看一下 java.lang.Object 类的 toString() 方法就明白了。
12String [] cmowers &#x3D; {&quot;沉默&quot;,&quot;王二&quot;,&quot;一枚有趣的程序员&quot;};System.out.println(cmowers);
再次证明，数组虽然没有显式定义成一个类，但它的确是一个对象，继承了祖先类 Object 的所有方法。
“那为什么数组不单独定义一个类来表示呢？就像字符串 String 类那样呢？”
“一个合理的说法是 Java 将其隐藏了。假如真的存在这么一个类，就叫 Array.java 吧，我们假想一下它真实的样子，必须得有一个容器来存放数组的每一个元素，就像 String 类那样。”
12345public final class String    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {    &#x2F;** The value is used for character storage. *&#x2F;    private final char value[];}
“最终还是要用类似一种数组的形式来存放数组的元素，对吧？这就变得很没有必要了，不妨就把数组当做是一个没有形体的对象吧！”
stream 流打印 Java 数组 
“我们来看第一种打印数组的方法，使用时髦一点的Stream 流。”
第一种形式：
1Arrays.asList(cmowers).stream().forEach(s -&gt; System.out.println(s));
第二种形式：
1Stream.of(cmowers).forEach(System.out::println);
第三种形式：
1Arrays.stream(cmowers).forEach(System.out::println);
打印的结果如下所示。
12沉默一枚有趣的程序员
没错，这三种方式都可以轻松胜任本职工作，并且显得有点高大上，毕竟用到了 Stream，以及 lambda 表达式。
for 循环打印 Java 数组 
“当然了，也可以使用传统的方式，for 循环。甚至 for-each 也行。”
123456for(int i &#x3D; 0; i &lt; cmowers.length; i++){    System.out.println(cmowers[i]);}for (String s : cmowers) {    System.out.println(s);}
Arrays 工具类打印 Java 数组 
“当然没有了，我认为 Arrays.toString() 是打印数组的最佳方式，没有之一。”Arrays.toString() 可以将任意类型的数组转成字符串，包括基本类型数组和引用类型数组。该方法有多种重载形式。

使用 Arrays.toString() 方法来打印数组再优雅不过了，就像，就像，就像蒙娜丽莎的微笑。

12String [] cmowers &#x3D; {&quot;沉默&quot;,&quot;一枚有趣的程序员&quot;};System.out.println(Arrays.toString(cmowers));
程序打印结果：
1[沉默, 一枚有趣的程序员]
哇，打印格式不要太完美，不多不少！完全是我们预期的结果： [] 表明是一个数组， , 点和空格用来分割元素。
Arrays工具类打印二维数组 
“那如果我想打印二维数组呢？”
“可以使用 Arrays.deepToString() 方法。”
12String[][] deepArray &#x3D; new String[][] {{&quot;沉默&quot;}, {&quot;一枚有趣的程序员&quot;}};System.out.println(Arrays.deepToString(deepArray));
打印结果如下所示。
1[[沉默], [一枚有趣的程序员]]
POJO 的打印规约 
“说到打印，哥给你提醒一点。阿里巴巴的 Java 开发手册上有这样一条规约，你看。”

“什么是 POJO 呢，就是 Plain Ordinary Java Object 的缩写，一般在 Web 应用程序中建立一个数据库的映射对象时，我们称它为 POJO，这类对象不继承或不实现任何其它 Java 框架的类或接口。”
“对于这样的类，最好是重写一下它的 toString() 方法，方便查看这个对象到底包含了什么字段，好排查问题。”
“如果不重写的话，打印出来的 Java 对象就像直接打印数组的那样，一串谁也看不懂的字符序列。”
“可以借助 Intellij IDEA 生成重写的  toString() 方法，特别方便。”
2.4 解读String类源码 
String 类的声明 
123public final class String    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {}
“第一，String 类是 final 的，意味着它不能被子类继承。”
“第二，String 类实现了 Serializable 接口，意味着它可以序列化。”
“第三，String 类实现了 Comparable 接口，意味着最好不要用‘&#x3D;&#x3D;’来比较两个字符串是否相等，而应该用 compareTo() 方法去比较。”
因为 &#x3D;&#x3D; 是用来比较两个对象的地址，这个在讲字符串比较的时候会详细讲。如果只是说比较字符串内容的话，可以使用 String 类的 equals 方法：
123456789101112131415161718192021public boolean equals(Object anObject) {    if (this &#x3D;&#x3D; anObject) {        return true;    }    if (anObject instanceof String) {        String anotherString &#x3D; (String) anObject;        int n &#x3D; value.length;        if (n &#x3D;&#x3D; anotherString.value.length) {            char v1[] &#x3D; value;            char v2[] &#x3D; anotherString.value;            int i &#x3D; 0;            while (n-- !&#x3D; 0) {                if (v1[i] !&#x3D; v2[i])                    return false;                i++;            }            return true;        }    }    return false;}
“第四，StringBuffer、StringBuilder 和 String 一样，都实现了 CharSequence 接口，所以它们仨属于近亲。由于 String 是不可变的，所以遇到字符串拼接的时候就可以考虑一下 String 的另外两个好兄弟，StringBuffer 和 StringBuilder，它俩是可变的。”
String 类的底层实现 
“第五，Java 9 以前，String 是用 char 型数组实现的，之后改成了 byte 型数组实现，并增加了 coder 来表示编码。这样做的好处是在 Latin1 字符为主的程序里，可以把 String 占用的内存减少一半。当然，天下没有免费的午餐，这个改进在节省内存的同时引入了编码检测的开销。”

Latin1（Latin-1）是一种单字节字符集（即每个字符只使用一个字节的编码方式），也称为ISO-8859-1（国际标准化组织8859-1），它包含了西欧语言中使用的所有字符，包括英语、法语、德语、西班牙语、葡萄牙语、意大利语等等。在Latin1编码中，每个字符使用一个8位（即一个字节）的编码，可以表示256种不同的字符，其中包括ASCII字符集中的所有字符，即0x00到0x7F，以及其他西欧语言中的特殊字符，例如é、ü、ñ等等。由于Latin1只使用一个字节表示一个字符，因此在存储和传输文本时具有较小的存储空间和较快的速度

1234567public final class String    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {    @Stable    private final byte[] value;    private final byte coder;    private int hash;}
接下来，我们来详细地说一下。
从 char[] 到 byte[] ，最主要的目的是节省字符串占用的内存空间。内存占用减少带来的另外一个好处，就是 GC 次数也会减少。
我们使用 jmap -histo:live pid | head -n 10 命令就可以查看到堆内对象示例的统计信息、查看 ClassLoader 的信息以及 finalizer 队列。
以我正在运行着的编程喵项目实例（基于 Java 8）来说，结果是这样的。

其中 String 对象有 17638 个，占用了 423312 个字节的内存，排在第三位。
由于 Java 8 的 String 内部实现仍然是 char[] ，所以我们可以看到内存占用排在第 1 位的就是 char 数组。char[] 对象有 17673 个，占用了 1621352 个字节的内存，排在第一位。
那也就是说优化 String 节省内存空间是非常有必要的，如果是去优化一个使用频率没有 String 这么高的类，就没什么必要，对吧？
众所周知，char 类型的数据在 JVM 中是占用两个字节的，并且使用的是 UTF-8 编码，其值范围在 ‘\u0000’（0）和 ‘\uffff’（65,535）（包含）之间。
也就是说，使用 char[] 来表示 String 就会导致，即使 String 中的字符只用一个字节就能表示，也得占用两个字节。

PS：在计算机中，单字节字符通常指的是一个字节（8位）可以表示的字符，而双字节字符则指需要两个字节（16位）才能表示的字符。单字节字符和双字节字符的定义是相对的，不同的编码方式对应的单字节和双字节字符集也不同。常见的单字节字符集有ASCII（美国信息交换标准代码）、ISO-8859（国际标准化组织标准编号8859）、GBK（汉字内码扩展规范）、GB2312（中国国家标准，现在已经被GBK取代），像拉丁字母、数字、标点符号、控制字符都是单字节字符。双字节字符集包括 Unicode、UTF-8、GB18030（中国国家标准），中文、日文、韩文、拉丁文扩展字符属于双字节字符。

当然了，仅仅将 char[] 优化为 byte[] 是不够的，还要配合 Latin-1 的编码方式，该编码方式是用单个字节来表示字符的，这样就比 UTF-8 编码节省了更多的空间。
换句话说，对于：
1String name &#x3D; &quot;jack&quot;;
这样的，使用 Latin-1 编码，占用 4 个字节就够了。
但对于：
1String name &#x3D; &quot;小二&quot;;
这种，木的办法，只能使用 UTF16 来编码。
针对 JDK 9 的 String 源码里，为了区别编码方式，追加了一个 coder 字段来区分。
123456789101112&#x2F;** * The identifier of the encoding used to encode the bytes in * {@code value}. The supported values in this implementation are * * LATIN1 * UTF16 * * @implNote This field is trusted by the VM, and is a subject to * constant folding if String instance is constant. Overwriting this * field after construction will cause problems. *&#x2F;private final byte coder;
Java 会根据字符串的内容自动设置为相应的编码，要么 Latin-1 要么 UTF16。
也就是说，从 char[] 到 byte[] ，中文是两个字节，纯英文是一个字节，在此之前呢，中文是两个字节，英文也是两个字节。
在 UTF-8 中，0-127 号的字符用 1 个字节来表示，使用和 ASCII 相同的编码。只有 128 号及以上的字符才用 2 个、3 个或者 4 个字节来表示。

如果只有一个字节，那么最高的比特位为 0；
如果有多个字节，那么第一个字节从最高位开始，连续有几个比特位的值为 1，就使用几个字节编码，剩下的字节均以 10 开头。

具体的表现形式为：

0xxxxxxx：一个字节；
110xxxxx 10xxxxxx：两个字节编码形式（开始两个 1）；
1110xxxx 10xxxxxx 10xxxxxx：三字节编码形式（开始三个 1）；
11110xxx 10xxxxxx 10xxxxxx 10xxxxxx：四字节编码形式（开始四个 1）。

也就是说，UTF-8 是变长的，那对于 String 这种有随机访问方法的类来说，就很不方便。所谓的随机访问，就是charAt、subString这种方法，随便指定一个数字，String要能给出结果。如果字符串中的每个字符占用的内存是不定长的，那么进行随机访问的时候，就需要从头开始数每个字符的长度，才能找到你想要的字符。
那你可能会问，UTF-16也是变长的呢？一个字符还可能占用 4 个字节呢？
的确，UTF-16 使用 2 个或者 4 个字节来存储字符。

对于 Unicode 编号范围在 0 ~ FFFF 之间的字符，UTF-16 使用两个字节存储。
对于 Unicode 编号范围在 10000 ~ 10FFFF 之间的字符，UTF-16 使用四个字节存储，具体来说就是：将字符编号的所有比特位分成两部分，较高的一些比特位用一个值介于 D800~DBFF 之间的双字节存储，较低的一些比特位（剩下的比特位）用一个值介于 DC00~DFFF 之间的双字节存储。

但是在 Java 中，一个字符（char）就是 2 个字节，占 4 个字节的字符，在 Java 里也是用两个 char 来存储的，而String的各种操作，都是以Java的字符（char）为单位的，charAt是取得第几个char，subString取的也是第几个到第几个char组成的子串，甚至length返回的都是char的个数。
所以UTF-16在Java的世界里，就可以视为一个定长的编码。
String 类的 hashCode 方法 
“第六，每一个字符串都会有一个 hash 值，这个哈希值在很大概率是不会重复的，因此 String 很适合来作为 HashMap 的键值。”
来看 String 类的 hashCode 方法。
123456789101112private int hash; &#x2F;&#x2F; Cache the hash code for the stringpublic int hashCode() {    int h &#x3D; hash;    if (h &#x3D;&#x3D; 0 &amp;&amp; value.length &gt; 0) {        char val[] &#x3D; value;        for (int i &#x3D; 0; i &lt; value.length; i++) {            h &#x3D; 31 * h + val[i];        }        hash &#x3D; h;    }    return h;}
hashCode 方法首先检查是否已经计算过哈希码，如果已经计算过，则直接返回缓存的哈希码。否则，方法将使用一个循环遍历字符串的所有字符，并使用一个乘法和加法的组合计算哈希码。这种计算方法被称为“31 倍哈希法”。计算完成后，将得到的哈希值存储在 hash 成员变量中，以便下次调用 hashCode 方法时直接返回该值，而不需要重新计算。这是一种缓存优化，称为“惰性计算”。
31倍哈希法（31-Hash）是一种简单有效的字符串哈希算法，常用于对字符串进行哈希处理。该算法的基本思想是将字符串中的每个字符乘以一个固定的质数31的幂次方，并将它们相加得到哈希值。具体地，假设字符串为s，长度为n，则31倍哈希值计算公式如下：
1H(s) &#x3D; (s[0] * 31^(n-1)) + (s[1] * 31^(n-2)) + ... + (s[n-1] * 31^0)
其中，s[i]表示字符串s中第i个字符的ASCII码值， ^表示幂运算。31倍哈希法的优点在于简单易实现，计算速度快，同时也比较均匀地分布在哈希表中。
hashCode 方法，我们会在另外一个章节里详细讲。
我们可以通过以下方法模拟 String 的 hashCode 方法：
123456789101112131415public class HashCodeExample {    public static void main(String[] args) {        String text &#x3D; &quot;沉默王二&quot;;        int hashCode &#x3D; computeHashCode(text);        System.out.println(&quot;字符串 \&quot;&quot; + text + &quot;\&quot; 的哈希码是: &quot; + hashCode);        System.out.println(&quot;String 的 hashCode &quot; + text.hashCode());    }    public static int computeHashCode(String text) {        int h &#x3D; 0;        for (int i &#x3D; 0; i &lt; text.length(); i++) {            h &#x3D; 31 * h + text.charAt(i);        }        return h;    }}
看一下结果：
12字符串 &quot;沉默&quot; 的哈希码是: 867758096String 的 hashCode 867758096
结果是一样的，又学到了吧？
String 类的 substring 方法 
String 类中还有一个方法比较常用 substring，用来截取字符串的，来看源码。
12345678910public String substring(int beginIndex) {    if (beginIndex &lt; 0) {        throw new StringIndexOutOfBoundsException(beginIndex);    }    int subLen &#x3D; value.length - beginIndex;    if (subLen &lt; 0) {        throw new StringIndexOutOfBoundsException(subLen);    }    return (beginIndex &#x3D;&#x3D; 0) ? this : new String(value, beginIndex, subLen);}
substring 方法首先检查参数的有效性，如果参数无效，则抛出 StringIndexOutOfBoundsException 异常。
接下来，方法根据参数计算子字符串的长度。如果子字符串长度小于零，抛出StringIndexOutOfBoundsException异常。
如果 beginIndex 为 0，且 endIndex 等于字符串的长度，说明子串与原字符串相同，因此直接返回原字符串。否则，使用 value 数组（原字符串的字符数组）的一部分创建一个新的 String 对象并返回。
下面是几个使用 substring 方法的示例：
①、提取字符串中的一段子串：
123String str &#x3D; &quot;Hello, world!&quot;;String subStr &#x3D; str.substring(7, 12);  &#x2F;&#x2F; 从第7个字符（包括）提取到第12个字符（不包括）System.out.println(subStr);  &#x2F;&#x2F; 输出 &quot;world&quot;
②、提取字符串中的前缀或后缀：
123String str &#x3D; &quot;Hello, world!&quot;;String prefix &#x3D; str.substring(0, 5);  &#x2F;&#x2F; 提取前5个字符，即 &quot;Hello,&quot;String suffix &#x3D; str.substring(7);     &#x2F;&#x2F; 提取从第7个字符开始的所有字符，即 &quot;world!&quot;
③、处理字符串中的空格和分隔符：
12345String str &#x3D; &quot;   Hello,   world!  &quot;;String trimmed &#x3D; str.trim();                  &#x2F;&#x2F; 去除字符串开头和结尾的空格String[] words &#x3D; trimmed.split(&quot;\\s+&quot;);       &#x2F;&#x2F; 将字符串按照空格分隔成单词数组String firstWord &#x3D; words[0].substring(0, 1);  &#x2F;&#x2F; 提取第一个单词的首字母System.out.println(firstWord);  
④、处理字符串中的数字和符号：
1234String str &#x3D; &quot;1234-5678-9012-3456&quot;;String[] parts &#x3D; str.split(&quot;-&quot;);             &#x2F;&#x2F; 将字符串按照连字符分隔成四个部分String last4Digits &#x3D; parts[3].substring(1);  &#x2F;&#x2F; 提取最后一个部分的后三位数字System.out.println(last4Digits);             &#x2F;&#x2F; 输出 &quot;456&quot;
总之，substring 方法可以根据需求灵活地提取字符串中的子串，为字符串处理提供了便利。
String 类的 indexOf 方法 
indexOf 方法用于查找一个子字符串在原字符串中第一次出现的位置，并返回该位置的索引。来看该方法的源码：
1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&#x2F;* * 查找字符数组 target 在字符数组 source 中第一次出现的位置。 * sourceOffset 和 sourceCount 参数指定 source 数组中要搜索的范围， * targetOffset 和 targetCount 参数指定 target 数组中要搜索的范围， * fromIndex 参数指定开始搜索的位置。 * 如果找到了 target 数组，则返回它在 source 数组中的位置索引（从0开始）， * 否则返回-1。 *&#x2F;static int indexOf(char[] source, int sourceOffset, int sourceCount,        char[] target, int targetOffset, int targetCount,        int fromIndex) {    &#x2F;&#x2F; 如果开始搜索的位置已经超出 source 数组的范围，则直接返回-1（如果 target 数组为空，则返回 sourceCount）    if (fromIndex &gt;&#x3D; sourceCount) {        return (targetCount &#x3D;&#x3D; 0 ? sourceCount : -1);    }    &#x2F;&#x2F; 如果开始搜索的位置小于0，则从0开始搜索    if (fromIndex &lt; 0) {        fromIndex &#x3D; 0;    }    &#x2F;&#x2F; 如果 target 数组为空，则直接返回开始搜索的位置    if (targetCount &#x3D;&#x3D; 0) {        return fromIndex;    }    &#x2F;&#x2F; 查找 target 数组的第一个字符在 source 数组中的位置    char first &#x3D; target[targetOffset];    int max &#x3D; sourceOffset + (sourceCount - targetCount);    &#x2F;&#x2F; 循环查找 target 数组在 source 数组中的位置    for (int i &#x3D; sourceOffset + fromIndex; i &lt;&#x3D; max; i++) {        &#x2F;* Look for first character. *&#x2F;        &#x2F;&#x2F; 如果 source 数组中当前位置的字符不是 target 数组的第一个字符，则在 source 数组中继续查找 target 数组的第一个字符        if (source[i] !&#x3D; first) {            while (++i &lt;&#x3D; max &amp;&amp; source[i] !&#x3D; first);        }        &#x2F;* Found first character, now look at the rest of v2 *&#x2F;        &#x2F;&#x2F; 如果在 source 数组中找到了 target 数组的第一个字符，则继续查找 target 数组的剩余部分是否匹配        if (i &lt;&#x3D; max) {            int j &#x3D; i + 1;            int end &#x3D; j + targetCount - 1;            for (int k &#x3D; targetOffset + 1; j &lt; end &amp;&amp; source[j]                    &#x3D;&#x3D; target[k]; j++, k++);            &#x2F;&#x2F; 如果 target 数组全部匹配，则返回在 source 数组中的位置索引            if (j &#x3D;&#x3D; end) {                &#x2F;* Found whole string. *&#x2F;                return i - sourceOffset;            }        }    }    &#x2F;&#x2F; 没有找到 target 数组，则返回-1    return -1;}
来看示例。
①、示例1：查找子字符串的位置
123String str &#x3D; &quot;Hello, world!&quot;;int index &#x3D; str.indexOf(&quot;world&quot;);  &#x2F;&#x2F; 查找 &quot;world&quot; 子字符串在 str 中第一次出现的位置System.out.println(index);        &#x2F;&#x2F; 输出 7
②、示例2：查找字符串中某个字符的位置
123String str &#x3D; &quot;Hello, world!&quot;;int index &#x3D; str.indexOf(&quot;,&quot;);     &#x2F;&#x2F; 查找逗号在 str 中第一次出现的位置System.out.println(index);        &#x2F;&#x2F; 输出 5
③、示例3：查找子字符串的位置（从指定位置开始查找）
123String str &#x3D; &quot;Hello, world!&quot;;int index &#x3D; str.indexOf(&quot;l&quot;, 3);  &#x2F;&#x2F; 从索引为3的位置开始查找 &quot;l&quot; 子字符串在 str 中第一次出现的位置System.out.println(index);        &#x2F;&#x2F; 输出 3
④、示例4：查找多个子字符串
12345String str &#x3D; &quot;Hello, world!&quot;;int index1 &#x3D; str.indexOf(&quot;o&quot;);    &#x2F;&#x2F; 查找 &quot;o&quot; 子字符串在 str 中第一次出现的位置int index2 &#x3D; str.indexOf(&quot;o&quot;, 5); &#x2F;&#x2F; 从索引为5的位置开始查找 &quot;o&quot; 子字符串在 str 中第一次出现的位置System.out.println(index1);       &#x2F;&#x2F; 输出 4System.out.println(index2);       &#x2F;&#x2F; 输出 8
String 类的其他方法 
比如说 length() 用于返回字符串长度。
比如说 isEmpty() 用于判断字符串是否为空。
比如说 charAt() 用于返回指定索引处的字符。
比如说 getBytes() 用于返回字符串的字节数组，可以指定编码方式，比如说：
12String text &#x3D; &quot;沉默&quot;;System.out.println(Arrays.toString(text.getBytes(StandardCharsets.UTF_8)));
比如说 trim() 用于去除字符串两侧的空白字符，来看源码：
123456789101112public String trim() {    int len &#x3D; value.length;    int st &#x3D; 0;    char[] val &#x3D; value;    &#x2F;* avoid getfield opcode *&#x2F;    while ((st &lt; len) &amp;&amp; (val[st] &lt;&#x3D; &#39; &#39;)) {        st++;    }    while ((st &lt; len) &amp;&amp; (val[len - 1] &lt;&#x3D; &#39; &#39;)) {        len--;    }    return ((st &gt; 0) || (len &lt; value.length)) ? substring(st, len) : this;}
举例： “  沉默   “.trim() 会返回”沉默”
除此之外，还有 split、equals、join 等这些方法，我们后面会一一来细讲。
2.5 String为什么不可变String 可能是 Java 中使用频率最高的引用类型了，因此 String 类的设计者可以说是用心良苦。比如说 String 的不可变性。
String 类被 final 关键字修饰，所以它不会有子类，这就意味着没有子类可以重写它的方法，改变它的行为。
String 类的数据存储在 char[] 数组中，而这个数组也被 final 关键字修饰了，这就表示 String 对象是没法被修改的，只要初始化一次，值就确定了。
“为什么要这样设计呢？”
“我先简单来说下，能懂最好，不能懂后面再细说。”
第一，可以保证 String 对象的安全性，避免被篡改，毕竟像密码这种隐私信息一般就是用字符串存储的。
以下是一个简单的 Java 示例，演示了字符串的不可变性如何有助于保证 String 对象的安全性。在本例中，我们创建了一个简单的 User 类，该类使用 String 类型的字段存储用户名和密码。同时，我们使用一个静态方法 getUserCredentials 从外部获取用户凭据。
123456789101112131415161718192021222324252627282930313233343536class User {    private String username;    private String password;    public User(String username, String password) {        this.username &#x3D; username;        this.password &#x3D; password;    }    public String getUsername() {        return username;    }    public String getPassword() {        return password;    }}public class StringSecurityExample {    public static void main(String[] args) {        String username &#x3D; &quot;沉默&quot;;        String password &#x3D; &quot;123456&quot;;        User user &#x3D; new User(username, password);        &#x2F;&#x2F; 获取用户凭据        String[] credentials &#x3D; getUserCredentials(user);        &#x2F;&#x2F; 尝试修改从 getUserCredentials 返回的用户名和密码字符串        credentials[0] &#x3D; &quot;陈清扬&quot;;        credentials[1] &#x3D; &quot;612311&quot;;        &#x2F;&#x2F; 输出原始 User 对象中的用户名和密码        System.out.println(&quot;原始用户名: &quot; + user.getUsername()); &#x2F;&#x2F; 输出 &quot;JohnDoe&quot;        System.out.println(&quot;原始密码: &quot; + user.getPassword()); &#x2F;&#x2F; 输出 &quot;mySecurePassword&quot;    }    public static String[] getUserCredentials(User user) {        String[] credentials &#x3D; new String[2];        credentials[0] &#x3D; user.getUsername();        credentials[1] &#x3D; user.getPassword();        return credentials;    }}
在这个示例中，尽管我们尝试修改 getUserCredentials 返回的字符串数组（即用户名和密码），但原始 User 对象中的用户名和密码保持不变。这证明了字符串的不可变性有助于保护 String 对象的安全性。
第二，保证哈希值不会频繁变更。毕竟要经常作为哈希表的键值，经常变更的话，哈希表的性能就会很差劲。
在 String 类中，哈希值是在第一次计算时缓存的，后续对该哈希值的请求将直接使用缓存值。这有助于提高哈希表等数据结构的性能。以下是一个简单的示例，演示了字符串的哈希值缓存机制：
123456789101112String text1 &#x3D; &quot;沉默&quot;;String text2 &#x3D; &quot;沉默&quot;;&#x2F;&#x2F; 计算字符串 text1 的哈希值，此时会进行计算并缓存哈希值int hashCode1 &#x3D; text1.hashCode();System.out.println(&quot;第一次计算 text1 的哈希值: &quot; + hashCode1);&#x2F;&#x2F; 再次计算字符串 text1 的哈希值，此时直接返回缓存的哈希值int hashCode1Cached &#x3D; text1.hashCode();System.out.println(&quot;第二次计算: &quot; + hashCode1Cached);&#x2F;&#x2F; 计算字符串 text2 的哈希值，由于字符串常量池的存在，实际上 text1 和 text2 指向同一个字符串对象&#x2F;&#x2F; 所以这里直接返回缓存的哈希值int hashCode2 &#x3D; text2.hashCode();System.out.println(&quot;text2 直接使用缓存: &quot; + hashCode2);
在这个示例中，我们创建了两个具有相同内容的字符串 text1 和 text2。首次计算 text1 的哈希值时，会进行实际计算并缓存该值。当我们再次计算 text1 的哈希值或计算具有相同内容的 text2 的哈希值时，将直接返回缓存的哈希值，而不进行重新计算。
由于 String 对象是不可变的，其哈希值在创建后不会发生变化。这使得 String 类可以缓存哈希值，提高哈希表等数据结构的性能。如果 String 是可变的，那么在每次修改时都需要重新计算哈希值，这会降低性能。
第三，可以实现字符串常量池，Java 会将相同内容的字符串存储在字符串常量池中。这样，具有相同内容的字符串变量可以指向同一个 String 对象，节省内存空间。
“由于字符串的不可变性，String 类的一些方法实现最终都返回了新的字符串对象。”
“就拿 substring() 方法来说。”
12345678910public String substring(int beginIndex) {    if (beginIndex &lt; 0) {        throw new StringIndexOutOfBoundsException(beginIndex);    }    int subLen &#x3D; value.length - beginIndex;    if (subLen &lt; 0) {        throw new StringIndexOutOfBoundsException(subLen);    }    return (beginIndex &#x3D;&#x3D; 0) ? this : new String(value, beginIndex, subLen);}
substring() 方法用于截取字符串，最终返回的都是 new 出来的新字符串对象。
“还有 concat() 方法。”
12345678910111213141516171819public String concat(String str) {    int olen &#x3D; str.length();    if (olen &#x3D;&#x3D; 0) {        return this;    }    if (coder() &#x3D;&#x3D; str.coder()) {        byte[] val &#x3D; this.value;        byte[] oval &#x3D; str.value;        int len &#x3D; val.length + oval.length;        byte[] buf &#x3D; Arrays.copyOf(val, len);        System.arraycopy(oval, 0, buf, val.length, oval.length);        return new String(buf, coder);    }    int len &#x3D; length();    byte[] buf &#x3D; StringUTF16.newBytesFor(len + olen);    getBytes(buf, 0, UTF16);    str.getBytes(buf, len, UTF16);    return new String(buf, UTF16);}
concat() 方法用于拼接字符串，不管编码是否一致，最终也返回的是新的字符串对象。
“ replace() 替换方法其实也一样，三妹，你可以自己一会看一下源码，也是返回新的字符串对象。”
“这就意味着，不管是截取、拼接，还是替换，都不是在原有的字符串上进行的，而是重新生成了新的字符串对象。也就是说，这些操作执行过后，原来的字符串对象并没有发生改变。”
“String 对象一旦被创建后就固定不变了，对 String 对象的任何修改都不会影响到原来的字符串对象，都会生成新的字符串对象。”
2.6 深入理解Java字符串常量池 
“今天我们来学习一下字符串常量池，这是字符串中非常关键的一个知识点。”
new String(“二哥”)创建了几个对象 
“先从这道面试题开始吧！”
“这行代码创建了几个对象？”
“不就一个吗？”
“不，两个！”“使用 new 关键字创建一个字符串对象时，Java 虚拟机会先在字符串常量池中查找有没有‘二哥’这个字符串对象，如果有，就不会在字符串常量池中创建‘二哥’这个对象了，直接在堆中创建一个‘二哥’的字符串对象，然后将堆中这个‘二哥’的对象地址返回赋值给变量 s。”
“如果没有，先在字符串常量池中创建一个‘二哥’的字符串对象，然后再在堆中创建一个‘二哥’的字符串对象，然后将堆中这个‘二哥’的字符串对象地址返回赋值给变量 s。”
我画图表示一下，会更加清楚。

在Java中，栈上存储的是基本数据类型的变量和对象的引用，而对象本身则存储在堆上。
对于这行代码 String s &#x3D; new String(“二哥”); ，它创建了两个对象：一个是字符串对象 “二哥”，它被添加到了字符串常量池中，另一个是通过 new String() 构造函数创建的字符串对象 “二哥”，它被分配在堆内存中，同时引用变量 s 存储在栈上，它指向堆内存中的字符串对象 “二哥”。
“为什么要先在字符串常量池中创建对象，然后再在堆上创建呢？这样不就多此一举了？”
我回答，“是的。由于字符串的使用频率实在是太高了，所以 Java 虚拟机为了提高性能和减少内存开销，在创建字符串对象的时候进行了一些优化，特意为字符串开辟了一块空间——也就是字符串常量池。”
字符串常量池的作用 
通常情况下，我们会采用双引号的方式来创建字符串对象，而不是通过 new 关键字的方式，就像下面 这样，这样就不会多此一举：
当执行 String s &#x3D; “三妹” 时，Java 虚拟机会先在字符串常量池中查找有没有“三妹”这个字符串对象，如果有，则不创建任何对象，直接将字符串常量池中这个“三妹”的对象地址返回，赋给变量 s；如果没有，在字符串常量池中创建“三妹”这个对象，然后将其地址返回，赋给变量 s。

Java 虚拟机创建了一个字符串对象 “三妹”，它被添加到了字符串常量池中，同时引用变量 s 存储在栈上，它指向字符串常量池中的字符串对象 “三妹”。你看，是不是省了一步，比之前高效了。
““有了字符串常量池，就可以通过双引号的方式直接创建字符串对象，不用再通过 new 的方式在堆中创建对象了，对吧？”
“是滴。new 的方式始终会创建一个对象，不管字符串的内容是否已经存在，而双引号的方式会重复利用字符串常量池中已经存在的对象。”我说。
来看下面这个例子：
12String s &#x3D; new String(&quot;二哥&quot;);String s1 &#x3D; new String(&quot;二哥&quot;);
按照我们之前的分析，这两行代码会创建三个对象，字符串常量池中一个，堆上两个。
再来看下面这个例子：
12String s &#x3D; &quot;三妹&quot;;String s1 &#x3D; &quot;三妹&quot;;
这两行代码只会创建一个对象，就是字符串常量池中的那个。这样的话，性能肯定就提高了！
字符串常量池在内存中的什么位置呢？ 
分为三个阶段。
Java 7 之前 
在 Java 7 之前，字符串常量池位于永久代（Permanent Generation）的内存区域中，主要用来存储一些字符串常量（静态数据的一种）。永久代是 Java 堆（Java Heap）的一部分，用于存储类信息、方法信息、常量池信息等静态数据。
而 Java 堆是 JVM 中存储对象实例和数组的内存区域，也就是说，永久代是 Java 堆的一个子区域。换句话说，永久代中存储的静态数据与堆中存储的对象实例和数组是分开的，它们有不同的生命周期和分配方式。
但是，永久代和堆的大小是相互影响的，因为它们都使用了 JVM 堆内存，因此它们的大小都受到 JVM 堆大小的限制。
于是，当我们创建一个字符串常量时，它会被储存在永久代的字符串常量池中。如果我们创建一个普通字符串对象，则它将被储存在堆中。如果字符串对象的内容是一个已经存在于字符串常量池中的字符串常量，那么这个对象会指向已经存在的字符串常量，而不是重新创建一个新的字符串对象。
画幅图，大概就是这个样子。

Java 7 
需要注意的是，永久代的大小是有限的，并且很难准确地确定一个应用程序需要多少永久代空间。如果我们在应用程序中使用了大量的类、方法、常量等静态数据，就有可能导致永久代空间不足。这种情况下，JVM 就会抛出 OutOfMemoryError 错误。
因此，从 Java 7 开始，为了解决永久代空间不足的问题，将字符串常量池从永久代中移动到堆中。这个改变也是为了更好地支持动态语言的运行时特性。
再画幅图，大概就是这样子。

Java 8 
到了 Java 8，永久代（PermGen）被取消，并由元空间（Metaspace）取代。元空间是一块本机内存区域，和 JVM 内存区域是分开的。不过，元空间的作用依然和之前的永久代一样，用于存储类信息、方法信息、常量池信息等静态数据。
与永久代不同，元空间具有一些优点，例如：

它不会导致 OutOfMemoryError 错误，因为元空间的大小可以动态调整。
元空间使用本机内存，而不是 JVM 堆内存，这可以避免堆内存的碎片化问题。
元空间中的垃圾收集与堆中的垃圾收集是分离的，这可以避免应用程序在运行过程中因为进行类加载和卸载而频繁地触发 Full GC。

再画幅图，对比来看一下，就会一目了然。

永久代、方法区、元空间 
“能再简单给我解释一下方法区，永久代和元空间的概念吗？有点模糊。”
“可以呀。”

方法区是 Java 虚拟机规范中的一个概念，就像是一个接口吧；
永久代是 HotSpot 虚拟机中对方法区的一个实现，就像是接口的实现类；
Java 8 的时候，移除了永久代，取而代之的是元空间，是方法区的另外一种实现，更灵活了。

永久代是放在运行时数据区中的，所以它的大小受到 Java 虚拟机本身大小的限制，所以 Java 8 之前，会经常遇到 java.lang.OutOfMemoryError: PremGen Space 的异常，PremGen Space 就是方法区的意思；而元空间是直接放在内存中的，所以只受本机可用内存的限制。
2.7 详解 String.intern() 方法“看一下美团技术团队深入解析 String.intern() 文章”
要理解美团技术团队的这篇文章，你只需要记住这几点内容：
第一，使用双引号声明的字符串对象会保存在字符串常量池中。
第二，使用 new 关键字创建的字符串对象会先从字符串常量池中找，如果没找到就创建一个，然后再在堆中创建字符串对象；如果找到了，就直接在堆中创建字符串对象。
第三，针对没有使用双引号声明的字符串对象来说，就像下面代码中的 s1 那样：
1String s1 &#x3D; new String(&quot;二哥&quot;) + new String(&quot;三妹&quot;);
如果想把 s1 的内容也放入字符串常量池的话，可以调用 intern() 方法来完成。
不过，需要注意的是，Java 7 的时候，字符串常量池从永久代中移动到了堆中，虽然此时永久代还没有完全被移除。Java 8 的时候，永久代被彻底移除。
这个变化也直接影响了  String.intern() 方法在执行时的策略，Java 7 之前，执行 String.intern() 方法的时候，不管对象在堆中是否已经创建，字符串常量池中仍然会创建一个内容完全相同的新对象； Java 7 之后呢，由于字符串常量池放在了堆中，执行 String.intern() 方法的时候，如果对象在堆中已经创建了，字符串常量池中就不需要再创建新的对象了，而是直接保存堆中对象的引用，也就节省了一部分的内存空间。
“先来猜猜这段代码输出的结果吧。”
123String s1 &#x3D; new String(&quot;二哥三妹&quot;);String s2 &#x3D; s1.intern();System.out.println(s1 &#x3D;&#x3D; s2);
第一行代码，字符串常量池中会先创建一个“二哥三妹”的对象，然后堆中会再创建一个“二哥三妹”的对象，s1 引用的是堆中的对象。
第二行代码，对 s1 执行 intern() 方法，该方法会从字符串常量池中查找“二哥三妹”这个字符串是否存在，此时是存在的，所以 s2 引用的是字符串常量池中的对象。
也就意味着 s1 和 s2 的引用地址是不同的，一个来自堆，一个来自字符串常量池，所以输出的结果为 false。
“来看一下运行结果。”
1false
“我来画幅图，帮助你理解下。”

“好，我们再来看下面这段代码。”
123String s1 &#x3D; new String(&quot;二哥&quot;) + new String(&quot;三妹&quot;);String s2 &#x3D; s1.intern();System.out.println(s1 &#x3D;&#x3D; s2);
“难道也输出 false ？”
“不，这段代码会输出 true。”
“为啥呀？”
第一行代码，会在字符串常量池中创建两个对象，一个是“二哥”，一个是“三妹”，然后在堆中会创建两个匿名对象“二哥”和“三妹”，最后还有一个“二哥三妹”的对象（稍后会解释），s1 引用的是堆中“二哥三妹”这个对象。
第二行代码，对 s1 执行 intern() 方法，该方法会从字符串常量池中查找“二哥三妹”这个对象是否存在，此时不存在的，但堆中已经存在了，所以字符串常量池中保存的是堆中这个“二哥三妹”对象的引用，也就是说，s2 和 s1 的引用地址是相同的，所以输出的结果为 true。
“来看一下运行结果。”
1true
“我再来画幅图，帮助你理解下。”

“不过，我有一个疑惑，“二哥三妹”这个对象是什么时候创建的呢？”
“不错嘛，能抓住问题的关键。再来解释一下 String s1 &#x3D; new String(“二哥”) + new String(“三妹”) 这行代码。”

创建 “二哥” 字符串对象，存储在字符串常量池中。
创建 “三妹” 字符串对象，存储在字符串常量池中。
执行 new String(“二哥”) ，在堆上创建一个字符串对象，内容为 “二哥”。
执行 new String(“三妹”) ，在堆上创建一个字符串对象，内容为 “三妹”。
执行 new String(“二哥”) + new String(“三妹”) ，会创建一个 StringBuilder 对象，并将 “二哥” 和 “三妹” 追加到其中，然后调用 StringBuilder 对象的 toString() 方法，将其转换为一个新的字符串对象，内容为 “二哥三妹”。这个新的字符串对象存储在堆上。

也就是说，当编译器遇到 + 号这个操作符的时候，会将 new String(“二哥”) + new String(“三妹”) 这行代码编译为以下代码：
1new StringBuilder().append(&quot;二哥&quot;).append(&quot;三妹&quot;).toString();
实际执行过程如下：

创建一个 StringBuilder 对象。
在 StringBuilder 对象上调用 append(“二哥”)，将 “二哥” 追加到 StringBuilder 中。
在 StringBuilder 对象上调用 append(“三妹”)，将 “三妹” 追加到 StringBuilder 中。
在 StringBuilder 对象上调用 toString() 方法，将 StringBuilder 转换为一个新的字符串对象，内容为 “二哥三妹”。

关于 StringBuilder，我们随后会详细地讲到。今天先了解到这。
不过需要注意的是，尽管 intern 可以确保所有具有相同内容的字符串共享相同的内存空间，但也不要烂用 intern，因为任何的缓存池都是有大小限制的，不能无缘无故就占用了相对稀缺的缓存空间，导致其他字符串没有坑位可占。
另外，字符串常量池本质上是一个固定大小的 StringTable，如果放进去的字符串过多，就会造成严重的哈希冲突，从而导致链表变长，链表变长也就意味着字符串常量池的性能会大幅下降，因为要一个一个找是需要花费时间的。
2.8 String、StringBuilder、StringBuffer“上一篇深入理解 String.intern() 讲到了 StringBuilder，这一节我们就来聊聊吧！”
由于字符串是不可变的，所以当遇到字符串拼接（尤其是使用 +号操作符）的时候，就需要考量性能的问题，你不能毫无顾虑地生产太多 String 对象，对珍贵的内存造成不必要的压力。
于是 Java 就设计了一个专门用来解决此问题的 StringBuffer 类。
123456789101112131415public final class StringBuffer extends AbstractStringBuilder implements Serializable, CharSequence {    public StringBuffer() {        super(16);    }        public synchronized StringBuffer append(String str) {        super.append(str);        return this;    }    public synchronized String toString() {        return new String(value, 0, count);    }    &#x2F;&#x2F; 其他方法}
不过，由于 StringBuffer 操作字符串的方法加了 synchronized 关键字进行了同步，主要是考虑到多线程环境下的安全问题，所以执行效率会比较低。
于是 Java 就给 StringBuffer “生了个兄弟”，名叫 StringBuilder，说，“孩子，你别管线程安全了，你就在单线程环境下使用，这样效率会高得多，如果要在多线程环境下修改字符串，你到时候可以使用 ThreadLocal 来避免多线程冲突。”
1234567891011121314public final class StringBuilder extends AbstractStringBuilder    implements java.io.Serializable, CharSequence{    &#x2F;&#x2F; ...    public StringBuilder append(String str) {        super.append(str);        return this;    }    public String toString() {        &#x2F;&#x2F; Create a copy, don&#39;t share the array        return new String(value, 0, count);    }    &#x2F;&#x2F; ...}
除了类名不同，方法没有加 synchronized，基本上完全一样。
实际开发中，StringBuilder 的使用频率也是远高于 StringBuffer，甚至可以这么说，StringBuilder 完全取代了 StringBuffer。
之前我们也曾聊过，Java 是一门解释型的编程语言，所以当编译器遇到 + 号这个操作符的时候，会将 new String(“二哥”) + new String(“三妹”) 这行代码编译为以下代码：
1new StringBuilder().append(&quot;二哥&quot;).append(&quot;三妹&quot;).toString();
这个过程是我们看不见的，但这正是 Java 的“智能”之处，它可以在编译的时候偷偷地帮我们做很多优化，这样既可以提高我们的开发效率（ + 号写起来比创建 StringBuilder 对象便捷得多），也不会影响 JVM 的执行效率。
当然了，如果我们使用 javap 反编译 new String(“二哥”) + new String(“三妹”) 的字节码的时候，也是能看出 StringBuilder 的影子的。
12345678910111213141516171819200: new           #2                  &#x2F;&#x2F; class java&#x2F;lang&#x2F;StringBuilder3: dup4: invokespecial #3                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.&quot;&lt;init&gt;&quot;:()V7: new           #4                  &#x2F;&#x2F; class java&#x2F;lang&#x2F;String10: dup11: ldc           #5                  &#x2F;&#x2F; String 二哥13: invokespecial #6                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;String.&quot;&lt;init&gt;&quot;:(Ljava&#x2F;lang&#x2F;String;)V16: invokevirtual #7                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;19: new           #4                  &#x2F;&#x2F; class java&#x2F;lang&#x2F;String22: dup23: ldc           #8                  &#x2F;&#x2F; String 三妹25: invokespecial #6                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;String.&quot;&lt;init&gt;&quot;:(Ljava&#x2F;lang&#x2F;String;)V28: invokevirtual #7                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;31: invokevirtual #9                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.toString:()Ljava&#x2F;lang&#x2F;String;34: areturn
可以看到 Java 编译器将字符串拼接操作（ + ）转换为了 StringBuilder 对象的 append 方法，然后再调用 StringBuilder 对象的 toString 方法返回拼接后的字符串。
来看一下 StringBuilder 的 toString 方法：
123public String toString() {    return new String(value, 0, count);}
value 是一个 char 类型的数组：
1234&#x2F;** * The value is used for character storage. *&#x2F;char[] value;
在 StringBuilder 对象创建时，会为 value 分配一定的内存空间（初始容量 16），用于存储字符串。
1234567&#x2F;** * Constructs a string builder with no characters in it and an * initial capacity of 16 characters. *&#x2F;public StringBuilder() {    super(16);}
随着字符串的拼接，value 数组的长度会不断增加，因此在 StringBuilder 对象的实现中，value 数组的长度是可以动态扩展的，就像ArrayList那样。
继续来看 StringBuilder 的 toString 方法：
123public String toString() {    return new String(value, 0, count);}
value 用于存储 StringBuilder 对象中包含的字符序列。count 是一个 int 类型的变量，表示字符序列的长度。toString() 方法会调用 new String(value, 0, count) ，使用 value 数组中从 0 开始的前 count 个元素创建一个新的字符串对象，并将其返回。
再来看一下 append 方法：
1234public StringBuilder append(String str) {    super.append(str);    return this;}
实际上是调用了 AbstractStringBuilder 中的 append(String str) 方法。在 AbstractStringBuilder 中，append(String str) 方法会检查当前字符序列中的字符是否够用，如果不够用则会进行扩容，并将指定字符串追加到字符序列的末尾。
123456789101112131415161718192021222324252627&#x2F;** * Appends the specified string to this character sequence. * &lt;p&gt; * The characters of the {@code String} argument are appended, in order, * increasing the length of this sequence by the length of the argument. * If {@code str} is {@code null}, then the four characters {@code &quot;null&quot;} * are appended. * &lt;p&gt; * Let &lt;i&gt;n&lt;&#x2F;i&gt; be the length of this character sequence just prior to * execution of the {@code append} method. Then the character at index * &lt;i&gt;k&lt;&#x2F;i&gt; in this character sequence is equal to the character at index * &lt;i&gt;k&lt;&#x2F;i&gt; in the argument {@code str}, if &lt;i&gt;k&lt;&#x2F;i&gt; is less than * &lt;i&gt;n&lt;&#x2F;i&gt;; otherwise, it is equal to the character at index * &lt;i&gt;k-n&lt;&#x2F;i&gt; in the argument {@code str}. * * @param   str   a string. * @return  a reference to this object. *&#x2F;public AbstractStringBuilder append(String str) {    if (str &#x3D;&#x3D; null)        return appendNull();    int len &#x3D; str.length();    ensureCapacityInternal(count + len);    str.getChars(0, len, value, count);    count +&#x3D; len;    return this;}
append(String str) 方法将指定字符串追加到当前字符序列中。如果指定字符串为 null，则追加字符串 “null”；否则会检查指定字符串的长度，然后根据当前字符序列中的字符数和指定字符串的长度来判断是否需要扩容。
如果需要扩容，则会调用 ensureCapacityInternal(int minimumCapacity)方法进行扩容。扩容之后，将指定字符串的字符拷贝到字符序列中。
来看一下 ensureCapacityInternal 方法：
12345678910111213141516private void ensureCapacityInternal(int minimumCapacity) {    &#x2F;&#x2F; overflow-conscious code    if (minimumCapacity - value.length &gt; 0)        expandCapacity(minimumCapacity);}void expandCapacity(int minimumCapacity) {    int newCapacity &#x3D; value.length * 2 + 2;    if (newCapacity - minimumCapacity &lt; 0)        newCapacity &#x3D; minimumCapacity;    if (newCapacity &lt; 0) {        if (minimumCapacity &lt; 0) &#x2F;&#x2F; overflow            throw new OutOfMemoryError();        newCapacity &#x3D; Integer.MAX_VALUE;    }    value &#x3D; Arrays.copyOf(value, newCapacity);}
ensureCapacityInternal(int minimumCapacity) 方法用于确保当前字符序列的容量至少等于指定的最小容量 minimumCapacity。如果当前容量小于指定的容量，就会为字符序列分配一个新的内部数组。新容量的计算方式如下：

如果指定的最小容量大于当前容量，则新容量为两倍的旧容量加上 2；
如果指定的最小容量小于等于当前容量，则不会进行扩容，直接返回当前对象。

在进行扩容之前， ensureCapacityInternal(int minimumCapacity) 方法会先检查当前字符序列的容量是否足够，如果不足就会调用 expandCapacity(int minimumCapacity) 方法进行扩容。
expandCapacity(int minimumCapacity) 方法首先计算出新容量，然后使用 Arrays.copyOf(char[] original, int newLength) 方法将原字符数组扩容到新容量的大小。
关于扩容，后面在讲ArrayList的时候会再次说明，今天就先聊到这吧。
2.9 String相等判断“如何比较两个字符串相等啊？”
“这个问题看似简单，却在 Stack Overflow 上有超过 370 万+的访问量。”我说，“这个问题也可以引申为 .equals() 和 ‘\&#x3D;&#x3D;’ 操作符有什么区别。”

“\&#x3D;&#x3D;”操作符用于比较两个对象的地址是否相等。
.equals() 方法用于比较两个对象的内容是否相等。

“我来举个不恰当又很恰当的例子，一看你就明白了。”
有一对双胞胎，姐姐叫阿丽塔，妹妹叫洛丽塔。我们普通人可能完全无法分辨谁是姐姐谁是妹妹，可她们的妈妈却可以轻而易举地辨认出。

.equals() 就好像我们普通人，看见阿丽塔以为是洛丽塔，看见洛丽塔以为是阿丽塔，看起来一样就觉得她们是同一个人；“\&#x3D;&#x3D;”操作符就好像她们的妈妈，要求更严格，观察更细致，一眼就能分辨出谁是姐姐谁是妹妹。
1234String alita &#x3D; new String(&quot;小萝莉&quot;);String luolita &#x3D; new String(&quot;小萝莉&quot;);System.out.println(alita.equals(luolita)); &#x2F;&#x2F; trueSystem.out.println(alita &#x3D;&#x3D; luolita); &#x2F;&#x2F; false
就上面这段代码来说， .equals() 输出的结果为 true，而“\&#x3D;&#x3D;”操作符输出的结果为 false——前者要求内容相等就可以，后者要求必须是同一个对象。
“之前已经学过了，Java 的所有类都默认地继承 Object 这个超类，该类有一个名为 .equals() 的方法。”一边说，我一边打开了 Object 类的源码。
123public boolean equals(Object obj) {    return (this &#x3D;&#x3D; obj);}
你看，Object 类的 .equals() 方法默认采用的是“\&#x3D;&#x3D;”操作符进行比较。假如子类没有重写该方法的话，那么“\&#x3D;&#x3D;”操作符和 .equals() 方法的功效就完全一样——比较两个对象的内存地址是否相等。
但实际情况中，有不少类重写了 .equals() 方法，因为比较内存地址的要求比较严格，不太符合现实中所有的场景需求。拿 String 类来说，我们在比较字符串的时候，的确只想判断它们俩的内容是相等的就可以了，并不想比较它们俩是不是同一个对象。
况且，字符串有字符串常量池的概念，本身就推荐使用 String s &#x3D; “字符串” 这种形式来创建字符串对象，而不是通过 new 关键字的方式，因为可以把字符串缓存在字符串常量池中，方便下次使用，不用遇到 new 就在堆上开辟一块新的空间。
“那就来看一下 String 类的 .equals() 方法的源码吧。”
12345678910111213public boolean equals(Object anObject) {    if (this &#x3D;&#x3D; anObject) {        return true;    }    if (anObject instanceof String) {        String aString &#x3D; (String)anObject;        if (coder() &#x3D;&#x3D; aString.coder()) {            return isLatin1() ? StringLatin1.equals(value, aString.value)                    : StringUTF16.equals(value, aString.value);        }    }    return false;}
首先，如果两个字符串对象的可以“\&#x3D;&#x3D;”，那就直接返回 true 了，因为这种情况下，字符串内容是必然相等的。否则就按照字符编码进行比较，分为 UTF16 和 Latin1，差别不是很大，就拿 Latin1 的来说吧。
123456789101112@HotSpotIntrinsicCandidatepublic static boolean equals(byte[] value, byte[] other) {    if (value.length &#x3D;&#x3D; other.length) {        for (int i &#x3D; 0; i &lt; value.length; i++) {            if (value[i] !&#x3D; other[i]) {                return false;            }        }        return true;    }    return false;}
这个 JDK 版本是 Java 17，也就是最新的 LTS（长期支持）版本。该版本中，String 类使用字节数组实现的，所以比较两个字符串的内容是否相等时，可以先比较字节数组的长度是否相等，不相等就直接返回 false；否则就遍历两个字符串的字节数组，只有有一个字节不相等，就返回 false。
这是 Java 8 中的 equals 方法源码：
12345678910111213141516171819202122232425public boolean equals(Object anObject) {    &#x2F;&#x2F; 判断是否为同一对象    if (this &#x3D;&#x3D; anObject) {        return true;    }    &#x2F;&#x2F; 判断对象是否为 String 类型    if (anObject instanceof String) {        String anotherString &#x3D; (String)anObject;        int n &#x3D; value.length;        &#x2F;&#x2F; 判断字符串长度是否相等        if (n &#x3D;&#x3D; anotherString.value.length) {            char v1[] &#x3D; value;            char v2[] &#x3D; anotherString.value;            int i &#x3D; 0;            &#x2F;&#x2F; 判断每个字符是否相等            while (n-- !&#x3D; 0) {                if (v1[i] !&#x3D; v2[i])                    return false;                i++;            }            return true;        }    }    return false;}
JDK 8 比 JDK 17 更容易懂一些：首先判断两个对象是否为同一个对象，如果是，则返回 true。接着，判断对象是否为 String 类型，如果不是，则返回 false。如果对象为 String 类型，则比较两个字符串的长度是否相等，如果长度不相等，则返回 false。如果长度相等，则逐个比较每个字符是否相等，如果都相等，则返回 true，否则返回 false。
“那出几道题考考你吧！”
第一题：
1new String(&quot;小萝莉&quot;).equals(&quot;小萝莉&quot;)
“输出什么呢？”我问。
“ .equals() 比较的是两个字符串对象的内容是否相等，所以结果为 true。”
第二题：
1new String(&quot;小萝莉&quot;) &#x3D;&#x3D; &quot;小萝莉&quot;
“&#x3D;&#x3D;操作符左侧的是在堆中创建的对象，右侧是在字符串常量池中的对象，尽管内容相同，但内存地址不同，所以返回 false。”
第三题：
1new String(&quot;小萝莉&quot;) &#x3D;&#x3D; new String(&quot;小萝莉&quot;)
“new 出来的对象肯定是完全不同的内存地址，所以返回 false。”
第四题：
1&quot;小萝莉&quot; &#x3D;&#x3D; &quot;小萝莉&quot;
“字符串常量池中只会有一个相同内容的对象，所以返回 true。”
第五题：
1&quot;小萝莉&quot; &#x3D;&#x3D; &quot;小&quot; + &quot;萝莉&quot;
“由于‘小’和‘萝莉’都在字符串常量池，所以编译器在遇到‘+’操作符的时候将其自动优化为“小萝莉”，所以返回 true。”
PS：至于为什么，查看这篇String、StringBuilder、StringBuffer
第六题：
1new String(&quot;小萝莉&quot;).intern() &#x3D;&#x3D; &quot;小萝莉&quot;
“ new String(“小萝莉”) 在执行的时候，会先在字符串常量池中创建对象，然后再在堆中创建对象；执行 intern() 方法的时候发现字符串常量池中已经有了‘小萝莉’这个对象，所以就直接返回字符串常量池中的对象引用了，那再与字符串常量池中的‘小萝莉’比较，当然会返回 true 了。”
PS：intern 方法我们之前已经深究过了。
“哥再给你补充一点。”
“如果要进行两个字符串对象的内容比较，除了 .equals() 方法，还有其他两个可选的方案。”
1） Objects.equals()
Objects.equals() 这个静态方法的优势在于不需要在调用之前判空。
123public static boolean equals(Object a, Object b) {    return (a &#x3D;&#x3D; b) || (a !&#x3D; null &amp;&amp; a.equals(b));}
如果直接使用 a.equals(b) ，则需要在调用之前对 a 进行判空，否则可能会抛出空指针 java.lang.NullPointerException 。 Objects.equals() 用起来就完全没有这个担心。
12345Objects.equals(&quot;小萝莉&quot;, new String(&quot;小&quot; + &quot;萝莉&quot;)) &#x2F;&#x2F; --&gt; trueObjects.equals(null, new String(&quot;小&quot; + &quot;萝莉&quot;)); &#x2F;&#x2F; --&gt; falseObjects.equals(null, null) &#x2F;&#x2F; --&gt; trueString a &#x3D; null;a.equals(new String(&quot;小&quot; + &quot;萝莉&quot;)); &#x2F;&#x2F; throw exception
2）String 类的 .contentEquals()
.contentEquals() 的优势在于可以将字符串与任何的字符序列（StringBuffer、StringBuilder、String、CharSequence）进行比较。
12345678910111213141516171819202122232425262728293031323334public boolean contentEquals(CharSequence cs) {    &#x2F;&#x2F; Argument is a StringBuffer, StringBuilder    if (cs instanceof AbstractStringBuilder) {        if (cs instanceof StringBuffer) {            synchronized(cs) {                return nonSyncContentEquals((AbstractStringBuilder)cs);            }        } else {            return nonSyncContentEquals((AbstractStringBuilder)cs);        }    }    &#x2F;&#x2F; Argument is a String    if (cs instanceof String) {        return equals(cs);    }    &#x2F;&#x2F; Argument is a generic CharSequence    int n &#x3D; cs.length();    if (n !&#x3D; length()) {        return false;    }    byte[] val &#x3D; this.value;    if (isLatin1()) {        for (int i &#x3D; 0; i &lt; n; i++) {            if ((val[i] &amp; 0xff) !&#x3D; cs.charAt(i)) {                return false;            }        }    } else {        if (!StringUTF16.contentEquals(val, cs, n)) {            return false;        }    }    return true;}
从源码上可以看得出，如果 cs 是 StringBuffer，该方法还会进行同步，非常的智能化；如果是 String 的话，其实调用的还是 equals() 方法。当然了，这也就意味着使用该方法进行比较的时候，多出来了很多步骤，性能上有些损失。
同样来看一下 JDK 8 的源码：
1234567891011121314151617181920212223242526272829303132public boolean contentEquals(CharSequence cs) {    &#x2F;&#x2F; argument can be any CharSequence implementation    if (cs.length() !&#x3D; value.length) {        return false;    }    &#x2F;&#x2F; Argument is a StringBuffer, StringBuilder or String    if (cs instanceof AbstractStringBuilder) {        char v1[] &#x3D; value;        char v2[] &#x3D; ((AbstractStringBuilder)cs).getValue();        int i &#x3D; 0;        int n &#x3D; value.length;        while (n-- !&#x3D; 0) {            if (v1[i] !&#x3D; v2[i])                return false;            i++;        }        return true;    }    &#x2F;&#x2F; Argument is a String    if (cs.equals(this))        return true;    &#x2F;&#x2F; Argument is a non-String, non-AbstractStringBuilder CharSequence    char v1[] &#x3D; value;    int i &#x3D; 0;    int n &#x3D; value.length;    while (n-- !&#x3D; 0) {        if (v1[i] !&#x3D; cs.charAt(i))            return false;        i++;    }    return true;}
   同样更容易理解一些：首先判断参数长度是否相等，不相等则返回 false。如果参数是 AbstractStringBuilder 的实例，则取出其 char 数组，遍历比较两个 char 数组的每个元素是否相等。如果参数是 String 的实例，则直接调用 equals 方法比较两个字符串是否相等。如果参数是其他实现了 CharSequence 接口的对象，则遍历比较两个对象的每个字符是否相等。    
2.10 String拼接“《Java 开发手册》上有这么一段内容：循环体内，拼接字符串最好使用 StringBuilder 的 append() 方法，而不是 + 号操作符。这是为什么呀？”
“其实这个问题，我们之前已经聊过。”
javap 探究+号操作符拼接字符串的本质 
“+ 号操作符其实被 Java 在编译的时候重新解释了，换一种说法就是，+ 号操作符是一种语法糖，让字符串的拼接变得更简便了。”
1234567class Demo {    public static void main(String[] args) {        String chenmo &#x3D; &quot;沉默&quot;;        String wanger &#x3D; &quot;王二&quot;;        System.out.println(chenmo + wanger);    }}
在 Java 8 的环境下，使用 javap -c Demo.class 反编译字节码后，可以看到以下内容：
12345678910111213141516171819202122232425262728293031Compiled from &quot;Demo.java&quot;class Demo {  Demo();    Code:       0: aload_0       1: invokespecial #1                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V       4: return  public static void main(java.lang.String[]);    Code:       0: ldc           #2                  &#x2F;&#x2F; String 沉默       2: astore_1       3: ldc           #3                  &#x2F;&#x2F; String 王二       5: astore_2       6: getstatic     #4                  &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;       9: new           #5                  &#x2F;&#x2F; class java&#x2F;lang&#x2F;StringBuilder      12: dup      13: invokespecial #6                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.&quot;&lt;init&gt;&quot;:()V      16: aload_1      17: invokevirtual #7                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;      20: aload_2      21: invokevirtual #7                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;      24: invokevirtual #8                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.toString:()Ljava&#x2F;lang&#x2F;String;      27: invokevirtual #9                  &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.println:(Ljava&#x2F;lang&#x2F;String;)V      30: return}
“这里有一个 new 关键字，并且 class 类型为 java&#x2F;lang&#x2F;StringBuilder 。”我指着标号为 9 的那行说，“这意味着新建了一个 StringBuilder 的对象。”
“然后看标号为 17 的这行，是一个 invokevirtual 指令，用于调用对象的方法，也就是 StringBuilder 对象的 append() 方法。”
“也就意味着把 chenmo（”沉默”）这个字符串添加到 StringBuilder 对象中了。”
“再往下看，标号为 21 的这行，又调用了一次 append() 方法，意味着把 wanger（”王二”）这个字符串添加到 StringBuilder 对象中了。”
换成 Java 代码来表示的话，大概是这个样子：
1234567class Demo {    public static void main(String[] args) {        String chenmo &#x3D; &quot;沉默&quot;;        String wanger &#x3D; &quot;王二&quot;;        System.out.println((new StringBuilder(chenmo)).append(wanger).toString());    }}
“哦，原来编译的时候把“+”号操作符替换成了 StringBuilder 的 append() 方法啊。”
“是的，不过到了 Java 9（不是长期支持版本，所以我会拿 Java 11 来演示），情况发生了一些改变，同样的代码，字节码指令完全不同了。”我说。
同样的代码，在 Java 11 的环境下，字节码指令是这样的：
1234567891011121314151617181920212223242526272829303132333435Compiled from &quot;Demo.java&quot;public class com.itwanger.thirtyseven.Demo {  public com.itwanger.thirtyseven.Demo();    Code:       0: aload_0       1: invokespecial #1                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V       4: return  public static void main(java.lang.String[]);    Code:       0: ldc           #2                  &#x2F;&#x2F; String       2: astore_1       3: iconst_0       4: istore_2       5: iload_2       6: bipush        10       8: if_icmpge     41      11: new           #3                  &#x2F;&#x2F; class java&#x2F;lang&#x2F;String      14: dup      15: ldc           #4                  &#x2F;&#x2F; String 沉默      17: invokespecial #5                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;String.&quot;&lt;init&gt;&quot;:(Ljava&#x2F;lang&#x2F;String;)V      20: astore_3      21: ldc           #6                  &#x2F;&#x2F; String 王二      23: astore        4      25: aload_1      26: aload_3      27: aload         4      29: invokedynamic #7,  0              &#x2F;&#x2F; InvokeDynamic #0:makeConcatWithConstants:(Ljava&#x2F;lang&#x2F;String;Ljava&#x2F;lang&#x2F;String;Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;String;      34: astore_1      35: iinc          2, 1      38: goto          5      41: return}
看标号为 29 的这行，字节码指令为 invokedynamic ，该指令允许由应用级的代码来决定方法解析，所谓的应用级的代码其实是一个方法——被称为引导方法（Bootstrap Method），简称 BSM，BSM 会返回一个 CallSite（调用点） 对象，这个对象就和 invokedynamic 指令链接在一起。以后再执行这条 invokedynamic 指令时就不会创建新的 CallSite 对象。CallSite 其实就是一个 MethodHandle（方法句柄）的 holder，指向一个调用点真正执行的方法——此时就是 StringConcatFactory.makeConcatWithConstants() 方法。
“好吧，总之就是 Java 9 以后，JDK 用了另外一种方法来动态解释 + 号操作符，具体的实现方式在字节码指令层面已经看不到了，所以我就以 Java 8 来继续讲解吧。”
为什么要编译为 StringBuilder.append 
“再回到《Java 开发手册》上的那段内容：循环体内，拼接字符串最好使用 StringBuilder 的 append() 方法，而不是 + 号操作符。原因就在于循环体内如果用 + 号操作符的话，就会产生大量的 StringBuilder 对象，不仅占用了更多的内存空间，还会让 Java 虚拟机不停的进行垃圾回收，从而降低了程序的性能。”
更好的写法就是在循环的外部新建一个 StringBuilder 对象，然后使用 append() 方法将循环体内的字符串添加进来：
123456789101112class Demo {    public static void main(String[] args) {        StringBuilder sb &#x3D; new StringBuilder();        for (int i &#x3D; 1; i &lt; 10; i++) {            String chenmo &#x3D; &quot;沉默&quot;;            String wanger &#x3D; &quot;王二&quot;;            sb.append(chenmo);            sb.append(wanger);        }        System.out.println(sb);    }}
来做个小测试。
第一个，for 循环中使用”+”号操作符。
1234String result &#x3D; &quot;&quot;;for (int i &#x3D; 0; i &lt; 100000; i++) {    result +&#x3D; &quot;六六六&quot;;}
第二个，for 循环外部新建 StringBuilder，循环体内使用 append() 方法。
1234StringBuilder sb &#x3D; new StringBuilder();for (int i &#x3D; 0; i &lt; 100000; i++) {    sb.append(&quot;六六六&quot;);}
“这两个小测试分别会耗时多长时间呢？”
“哇，第一个小测试的执行时间是 6212 毫秒，第二个只用了不到 1 毫秒，差距也太大了吧！”
“是的，这下明白了原因吧？”我说。
append方法源码解析 
“好了，来看一下 StringBuilder 类的 append() 方法的源码吧！”
1234public StringBuilder append(String str) {    super.append(str);    return this;}
这 3 行代码其实没啥看的。我们来看父类 AbstractStringBuilder 的 append() 方法：
123456789public AbstractStringBuilder append(String str) {    if (str &#x3D;&#x3D; null)        return appendNull();    int len &#x3D; str.length();    ensureCapacityInternal(count + len);    str.getChars(0, len, value, count);    count +&#x3D; len;    return this;}
1）判断拼接的字符串是不是 null，如果是，当做字符串“null”来处理。 appendNull() 方法的源码如下：
1234567891011private AbstractStringBuilder appendNull() {    int c &#x3D; count;    ensureCapacityInternal(c + 4);    final char[] value &#x3D; this.value;    value[c++] &#x3D; &#39;n&#39;;    value[c++] &#x3D; &#39;u&#39;;    value[c++] &#x3D; &#39;l&#39;;    value[c++] &#x3D; &#39;l&#39;;    count &#x3D; c;    return this;}
2）获取字符串的长度。
3） ensureCapacityInternal() 方法的源码如下：
1234567private void ensureCapacityInternal(int minimumCapacity) {    &#x2F;&#x2F; overflow-conscious code    if (minimumCapacity - value.length &gt; 0) {        value &#x3D; Arrays.copyOf(value,                newCapacity(minimumCapacity));    }}
由于字符串内部是用数组实现的，所以需要先判断拼接后的字符数组长度是否超过当前数组的长度，如果超过，先对数组进行扩容，然后把原有的值复制到新的数组中。
 4）将拼接的字符串 str 复制到目标数组 value 中。
1str.getChars(0, len, value, count)
5）更新数组的长度 count。
String.concat 拼接字符串 
“除了可以使用 + 号操作符，StringBuilder 的 append() 方法，还有其他的字符串拼接方法吗？”
“有啊，比如说 String 类的 concat() 方法，有点像 StringBuilder 类的 append() 方法。”
123String chenmo &#x3D; &quot;沉默&quot;;String wanger &#x3D; &quot;王二&quot;;System.out.println(chenmo.concat(wanger));
可以来看一下 concat() 方法的源码。
12345678910public String concat(String str) {    int otherLen &#x3D; str.length();    if (otherLen &#x3D;&#x3D; 0) {        return this;    }    int len &#x3D; value.length;    char buf[] &#x3D; Arrays.copyOf(value, len + otherLen);    str.getChars(buf, len);    return new String(buf, true);}
1）如果拼接的字符串的长度为 0，那么返回拼接前的字符串。
2）将原字符串的字符数组 value 复制到变量 buf 数组中。
3）把拼接的字符串 str 复制到字符数组 buf 中，并返回新的字符串对象。
我一行一行地解释着。
“和 + 号操作符相比， concat() 方法在遇到字符串为 null 的时候，会抛出 NullPointerException，而“+”号操作符会把 null 当做是“null”字符串来处理。”
如果拼接的字符串非常多， concat() 的效率就会下降，因为创建的字符串对象越来越多。
“还有吗？”
“有，当然有。”
String.join 拼接字符串 
String 类有一个静态方法 join() ，可以这样来使用。
1234String chenmo &#x3D; &quot;沉默&quot;;String wanger &#x3D; &quot;王二&quot;;String cmower &#x3D; String.join(&quot;&quot;, chenmo, wanger);System.out.println(cmower);
第一个参数为字符串连接符，比如说：
1String message &#x3D; String.join(&quot;-&quot;, &quot;王二&quot;, &quot;太特么&quot;, &quot;有趣了&quot;);
输出结果为：王二-太特么-有趣了 。
来看一下 join 方法的源码：
12345678910public static String join(CharSequence delimiter, CharSequence... elements) {    Objects.requireNonNull(delimiter);    Objects.requireNonNull(elements);    &#x2F;&#x2F; Number of elements not likely worth Arrays.stream overhead.    StringJoiner joiner &#x3D; new StringJoiner(delimiter);    for (CharSequence cs: elements) {        joiner.add(cs);    }    return joiner.toString();}
里面新建了一个叫 StringJoiner 的对象，然后通过 for-each 循环把可变参数添加了进来，最后调用 toString() 方法返回 String。
StringUtils.join 拼接字符串 
“实际的工作中， org.apache.commons.lang3.StringUtils 的 join() 方法也经常用来进行字符串拼接。”
123String chenmo &#x3D; &quot;沉默&quot;;String wanger &#x3D; &quot;王二&quot;;StringUtils.join(chenmo, wanger);
该方法不用担心 NullPointerException。
12345StringUtils.join(null)            &#x3D; nullStringUtils.join([])              &#x3D; &quot;&quot;StringUtils.join([null])          &#x3D; &quot;&quot;StringUtils.join([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]) &#x3D; &quot;abc&quot;StringUtils.join([null, &quot;&quot;, &quot;a&quot;]) &#x3D; &quot;a&quot;
来看一下源码：
12345678910111213141516171819public static String join(final Object[] array, String separator, final int startIndex, final int endIndex) {    if (array &#x3D;&#x3D; null) {        return null;    }    if (separator &#x3D;&#x3D; null) {        separator &#x3D; EMPTY;    }    final StringBuilder buf &#x3D; new StringBuilder(noOfItems * 16);    for (int i &#x3D; startIndex; i &lt; endIndex; i++) {        if (i &gt; startIndex) {            buf.append(separator);        }        if (array[i] !&#x3D; null) {            buf.append(array[i]);        }    }    return buf.toString();}
内部使用的仍然是 StringBuilder。
“好了，关于字符串拼接的知识点我们就讲到这吧。注意 Java 9 以后，对 + 号操作符的解释和之前发生了变化，字节码指令已经不同了，等后面你学了字节码指令后我们再详细地讲一次。”
2.11 String拆分“哥，我感觉字符串拆分没什么可讲的呀，直接上 String 类的 split() 方法不就可以了！”三妹毫不客气地说。
“假如你真的这么觉得，那可要注意了，事情远没这么简单。”我微笑着说。
假如现在有这样一串字符序列“沉默王二，一枚有趣的程序员”，需要按照中文逗号“，”进行拆分，这意味着第一串字符序列为逗号前面的“沉默王二”，第二串字符序列为逗号后面的“一枚有趣的程序员”。
“这不等于没说吗？哥！”还没等我说，三妹就打断了我。
“别着急嘛，等哥说完。”我依然保持着微笑继续说，“在拆分之前，要先进行检查，判断一下这串字符是否包含逗号，否则应该抛出异常。”
1234567891011public class Test {    public static void main(String[] args) {        String cmower &#x3D; &quot;沉默王二，一枚有趣的程序员&quot;;        if (cmower.contains(&quot;，&quot;)) {            String [] parts &#x3D; cmower.split(&quot;，&quot;);            System.out.println(&quot;第一部分：&quot; + parts[0] +&quot; 第二部分：&quot; + parts[1]);        } else {            throw new IllegalArgumentException(&quot;当前字符串没有包含逗号&quot;);        }    }}
“三妹你看，这段代码挺严谨的吧？”我说，“来看一下程序的输出结果。”
1第一部分：沉默王二 第二部分：一枚有趣的程序员
“的确和预期完全一致。”三妹说。
“这是建立在字符串是确定的情况下，最重要的是分隔符是确定的。否则，麻烦就来了。”我说，“大约有 12 种英文特殊符号，如果直接拿这些特殊符号替换上面代码中的分隔符（中文逗号），这段程序在运行的时候就会出现以下提到的错误。”

反斜杠 \ （ArrayIndexOutOfBoundsException）
插入符号 ^ （同上）
美元符号 $ （同上）
逗点 . （同上）
竖线 | （正常，没有出错）
问号 ? （PatternSyntaxException）
星号 * （同上）
加号 + （同上）
左小括号或者右小括号 () （同上）
左方括号或者右方括号 [] （同上）
左大括号或者右大括号 {} （同上）

“那遇到这些特殊符号该怎么办呢？”三妹问。
“用正则表达式。”我说，“正则表达式是一组由字母和符号组成的特殊文本，它可以用来从文本中找出满足你想要的格式的句子。”
我在 GitHub 上找打了一个开源的正则表达式学习文档，非常详细。一开始写正则表达式的时候难免会感觉到非常生疏，你可以查看一下这份文档。记不住没关系，遇到就查。

https:&#x2F;&#x2F;github.com&#x2F;cdoco&#x2F;learn-regex-zh

除了这份文档，还有一份：

https:&#x2F;&#x2F;github.com&#x2F;cdoco&#x2F;common-regex

作者收集了一些在平时项目开发中经常用到的正则表达式，可以直接拿来用。
“哥，你真周到。”三妹笑着说。
“好了，来用英文逗点 . 替换一下分隔符。”我说。
12345String cmower &#x3D; &quot;沉默王二.一枚有趣的程序员&quot;;if (cmower.contains(&quot;.&quot;)) {    String [] parts &#x3D; cmower.split(&quot;\\.&quot;);    System.out.println(&quot;第一部分：&quot; + parts[0] +&quot; 第二部分：&quot; + parts[1]);}
由于英文逗点属于特殊符号，所以在使用 split() 方法的时候，就需要使用正则表达式 \. 而不能直接使用 . 。
“为什么用两个反斜杠呢？”三妹问。
“因为反斜杠本身就是一个特殊字符，需要用反斜杠来转义。”我说。
当然了，你也可以使用 [] 来包裹住英文逗点“.”， [] 也是一个正则表达式，用来匹配方括号中包含的任意字符。
1cmower.split(&quot;[.]&quot;);
除此之外， 还可以使用 Pattern 类的 quote() 方法来包裹英文逗点“.”，该方法会返回一个使用 \Q\E 包裹的字符串。

来看示例：
1String [] parts &#x3D; cmower.split(Pattern.quote(&quot;.&quot;));
当 split() 方法的参数是正则表达式的时候，方法最终会执行下面这行代码：
1return Pattern.compile(regex).split(this, limit);
也就意味着，拆分字符串有了新的选择，可以不使用 String 类的 split() 方法，直接用下面的方式。
1234567public class TestPatternSplit {    private static Pattern twopart &#x3D; Pattern.compile(&quot;\\.&quot;);    public static void main(String[] args) {        String [] parts &#x3D; twopart.split(&quot;沉默王二.一枚有趣的程序员&quot;);        System.out.println(&quot;第一部分：&quot; + parts[0] +&quot; 第二部分：&quot; + parts[1]);    }}
“为什么要把 Pattern 表达式声明称 static 的呢？”三妹问。
“由于模式是确定的，通过 static 的预编译功能可以提高程序的效率。”我说，“除此之外，还可以使用 Pattern 配合 Matcher 类进行字符串拆分，这样做的好处是可以对要拆分的字符串进行一些严格的限制，来看这段示例代码。”
12345678910111213141516171819public class TestPatternMatch {    &#x2F;**     * 使用预编译功能，提高效率     *&#x2F;    private static Pattern twopart &#x3D; Pattern.compile(&quot;(.+)\\.(.+)&quot;);    public static void main(String[] args) {        checkString(&quot;沉默王二.一枚有趣的程序员&quot;);        checkString(&quot;沉默王二.&quot;);        checkString(&quot;.一枚有趣的程序员&quot;);    }    private static void checkString(String str) {        Matcher m &#x3D; twopart.matcher(str);        if (m.matches()) {            System.out.println(&quot;第一部分：&quot; + m.group(1) + &quot; 第二部分：&quot; + m.group(2));        } else {            System.out.println(&quot;不匹配&quot;);        }    }}
正则表达式 (.+)\.(.+) 的意思是，不仅要把字符串按照英文标点的方式拆成两部分，并且英文逗点的前后要有内容。
来看一下程序的输出结果：
123第一部分：沉默王二 第二部分：一枚有趣的程序员不匹配不匹配
不过，使用 Matcher 来匹配一些简单的字符串时相对比较沉重一些，使用 String 类的 split() 仍然是首选，因为该方法还有其他一些牛逼的功能。比如说，如果你想把分隔符包裹在拆分后的字符串的第一部分，可以这样做：
12345String cmower &#x3D; &quot;沉默王二，一枚有趣的程序员&quot;;if (cmower.contains(&quot;，&quot;)) {    String [] parts &#x3D; cmower.split(&quot;(?&lt;&#x3D;，)&quot;);    System.out.println(&quot;第一部分：&quot; + parts[0] +&quot; 第二部分：&quot; + parts[1]);}
程序输出的结果如下所示：
1第一部分：沉默王二， 第二部分：一枚有趣的程序员
可以看到分隔符“，”包裹在了第一部分，如果希望包裹在第二部分，可以这样做：
1String [] parts &#x3D; cmower.split(&quot;(?&#x3D;，)&quot;);
“ ?&lt;&#x3D; 和 ?&#x3D; 是什么东东啊？”三妹好奇地问。
“它其实是正则表达式中的断言模式。”我说，“你有时间的话，可以看看前面我推荐的两份开源文档。”

“ split() 方法可以传递 2 个参数，第一个为分隔符，第二个为拆分的字符串个数。”我说。
12345String cmower &#x3D; &quot;沉默王二，一枚有趣的程序员，宠爱他&quot;;if (cmower.contains(&quot;，&quot;)) {    String [] parts &#x3D; cmower.split(&quot;，&quot;, 2);    System.out.println(&quot;第一部分：&quot; + parts[0] +&quot; 第二部分：&quot; + parts[1]);}
进入 debug 模式的话，可以看到以下内容：

也就是说，传递 2 个参数的时候，会直接调用 substring() 进行截取，第二个分隔符后的就不再拆分了。
来看一下程序输出的结果：
1第一部分：沉默王二 第二部分：一枚有趣的程序员，宠爱他
“没想到啊，这个字符串拆分还挺讲究的呀！”三妹感慨地说。
“是的，其实字符串拆分在实际的工作当中还是挺经常用的。前端经常会按照规则传递一长串字符序列到后端，后端就需要按照规则把字符串拆分再做处理。”我说。
3 面向对象编程3.1 Java中的类和对象“二哥，那天我在图书馆复习《Java进阶之路》的时候，刚好碰见一个学长，他问我有没有‘对象’，我说还没有啊。结果你猜他说什么，‘要不要我给你 new 一个啊？’我当时就懵了，new 是啥意思啊，二哥？”三妹满是疑惑的问我。
“哈哈，三妹，你学长还挺幽默啊。new 是 Java 中的一个关键字，用来把类变成对象。”我笑着对三妹说，“对象和类是 Java 中最基本的两个概念，可以说撑起了面向对象编程（OOP）的一片天。”
01、面向过程和面向对象
三妹是不是要问，什么是 OOP？
OOP 的英文全称是 Object Oriented Programming，要理解它的话，就要先理解面向对象，要想理解面向对象的话，就要先理解面向过程，因为一开始没有面向对象的编程语言，都是面向过程。
举个简单点的例子来区分一下面向过程和面向对象
有一天，你想吃小碗汤了，怎么办呢？有两个选择：
1）自己买食材，豆腐皮啊、肉啊、蒜苔啊等等，自己动手做。
2）到饭店去，只需要对老板喊一声，“来份小碗汤。”
第一种就是面向过程，第二种就是面向对象。
面向过程有什么劣势呢？假如你买了小碗汤的食材，临了又想吃宫保鸡丁了，你是不是还得重新买食材？
面向对象有什么优势呢？假如你不想吃小碗汤了，你只需要对老板说，“我那个小碗汤如果没做的话，换成宫保鸡丁吧！”
面向过程是流程化的，一步一步，上一步做完了，再做下一步。
面向对象是模块化的，我做我的，你做你的，我需要你做的话，我就告诉你一声。我不需要知道你到底怎么做，只看功劳不看苦劳。
不过，如果追到底的话，面向对象的底层其实还是面向过程，只不过把面向过程进行了抽象化，封装成了类，方便我们的调用。
02、类
对象可以是现实中看得见的任何物体，比如说，一只特立独行的猪；也可以是想象中的任何虚拟物体，比如说能七十二变的孙悟空。
Java 通过类（class）来定义这些物体，这些物体有什么状态，通过字段来定义，比如说比如说猪的颜色是纯色还是花色；这些物体有什么行为，通过方法来定义，比如说猪会吃，会睡觉。
来，定义一个简单的类给你看看。
1234567891011121314&#x2F;** * 微信搜索「二哈进阶之路」 *&#x2F;public class Person {    private String name;    private int age;    private int sex;    private void eat() {    }    private void sleep() {    }    private void dadoudou() {    }}
一个类可以包含：

字段（Filed）
方法（Method）
构造方法（Constructor）

在 Person 类中，字段有 3 个，分别是 name、age 和 sex，它们也称为成员变量——在类内部但在方法外部，方法内部的叫临时变量。
成员变量有时候也叫做实例变量，在编译时不占用内存空间，在运行时获取内存，也就是说，只有在对象实例化（ new Person() ）后，字段才会获取到内存，这也正是它被称作“实例”变量的原因。
方法有 3 个，分别是 eat() 、 sleep() 和 dadoudou() ，表示 Person 这个对象可以做什么，也就是吃饭睡觉打豆豆。
那三妹是不是要问，“怎么没有构造方法呢？”
的确在 Person 类的源码文件（.java）中没看到，但在反编译后的字节码文件（.class）中是可以看得到的。
123456789101112131415161718&#x2F;&#x2F;&#x2F;&#x2F; Source code recreated from a .class file by IntelliJ IDEA&#x2F;&#x2F; (powered by Fernflower decompiler)&#x2F;&#x2F;package com.itwanger.twentythree;public class Person {    private String name;    private int age;    private int sex;    public Person() {    }    private void eat() {    }    private void sleep() {    }    private void dadoudou() {    }}
public Person(){} 就是默认的构造方法，因为是空的构造方法（方法体中没有内容），所以可以缺省。
Java 聪明就聪明在这，有些很死板的代码不需要开发人员添加，它会偷偷地做了。
03、new 一个对象
创建 Java 对象时，需要用到 new 关键字。
1Person person &#x3D; new Person();
这行代码就通过 Person 类创建了一个 Person 对象。所有对象在创建的时候都会在堆内存中分配空间。
创建对象的时候，需要一个 main() 方法作为入口， main() 方法可以在当前类中，也可以在另外一个类中。
第一种： main() 方法直接放在 Person 类中。
1234567891011121314public class Person {    private String name;    private int age;    private int sex;    private void eat() {}    private void sleep() {}    private void dadoudou() {}    public static void main(String[] args) {        Person person &#x3D; new Person();        System.out.println(person.name);        System.out.println(person.age);        System.out.println(person.sex);    }}
输出结果如下所示：
123null00
第二种： main() 方法不在 Person 类中，而在另外一个类中。

实际开发中，我们通常不在当前类中直接创建对象并使用它，而是放在使用对象的类中，比如说上图中的PersonTest 类。
可以把 PersonTest 类和 Person 类放在两个文件中，也可以放在一个文件（命名为 PersonTest.java）中，就像下面这样。
12345678910111213141516&#x2F;** * @author 微信搜「二哈进阶之路」 *&#x2F;public class PersonTest {    public static void main(String[] args) {        Person person &#x3D; new Person();    }}class Person {    private String name;    private int age;    private int sex;    private void eat() {}    private void sleep() {}    private void dadoudou() {}}
04、初始化对象
在之前的例子中，程序输出结果为：
123null00
为什么会有这样的输出结果呢？因为 Person 对象没有初始化，因此输出了 String 的默认值 null，int 的默认值 0。
那怎么初始化 Person 对象（对字段赋值）呢？
第一种：通过对象的引用变量。
123456789101112131415public class Person {    private String name;    private int age;    private int sex;    public static void main(String[] args) {        Person person &#x3D; new Person();        person.name &#x3D; &quot;沉默王二&quot;;        person.age &#x3D; 18;        person.sex &#x3D; 1;                System.out.println(person.name);        System.out.println(person.age);        System.out.println(person.sex);    }}
person 被称为对象 Person 的引用变量，见下图：

通过对象的引用变量，可以直接对字段进行初始化（ person.name &#x3D; “沉默” ），所以以上代码输出结果如下所示：
123沉默181
第二种：通过方法初始化。
1234567891011121314151617public class Person {    private String name;    private int age;    private int sex;    public void initialize(String n, int a, int s) {        name &#x3D; n;        age &#x3D; a;        sex &#x3D; s;    }    public static void main(String[] args) {        Person person &#x3D; new Person();        person.initialize(&quot;沉默王二&quot;,18,1);        System.out.println(person.name);        System.out.println(person.age);        System.out.println(person.sex);    }}
在 Person 类中新增方法 initialize() ，然后在新建对象后传参进行初始化（ person.initialize(“沉默”, 18, 1) ）。
第三种：通过构造方法初始化。
12345678910111213141516public class Person {    private String name;    private int age;    private int sex;    public Person(String name, int age, int sex) {        this.name &#x3D; name;        this.age &#x3D; age;        this.sex &#x3D; sex;    }    public static void main(String[] args) {        Person person &#x3D; new Person(&quot;沉默王二&quot;, 18, 1);        System.out.println(person.name);        System.out.println(person.age);        System.out.println(person.sex);    }}
这也是最标准的一种做法，直接在 new 的时候把参数传递过去。
补充一点知识，匿名对象。匿名对象意味着没有引用变量，它只能在创建的时候被使用一次。
1new Person();
可以直接通过匿名对象调用方法：
1new Person().initialize(&quot;沉默王二&quot;, 18, 1);
05、关于对象
1）抽象的历程
所有编程语言都是一种抽象，甚至可以说，我们能够解决的问题的复杂程度取决于抽象的类型和质量。
Smalltalk 是历史上第一门获得成功的面向对象语言，也为 Java 提供了灵感。它有 5 个基本特征：

万物皆对象。
一段程序实际上就是多个对象通过发送消息的方式来告诉彼此该做什么。
通过组合的方式，可以将多个对象封装成其他更为基础的对象。
对象是通过类实例化的。
同一类型的对象可以接收相同的消息。

总结一句话就是：

状态+行为+标识&#x3D;对象，每个对象在内存中都会有一个唯一的地址。

2）对象具有接口
所有的对象，都可以被归为一类，并且同一类对象拥有一些共同的行为和特征。在 Java 中，class 关键字用来定义一个类型。
创建抽象数据类型是面向对象编程的一个基本概念。你可以创建某种类型的变量，Java 中称之为对象或者实例，然后你就可以操作这些变量，Java 中称之为发送消息或者发送请求，最后对象决定自己该怎么做。
类描述了一系列具有相同特征和行为的对象，从宽泛的概念上来说，类其实就是一种自定义的数据类型。
一旦创建了一个类，就可以用它创建任意多个对象。面向对象编程语言遇到的最大一个挑战就是，如何把现实&#x2F;虚拟的元素抽象为 Java 中的对象。
对象能够接收什么样的请求是由它的接口定义的。具体是怎么做到的，就由它的实现方法来实现。
3）访问权限修饰符
类的创建者有时候也被称为 API 提供者，对应的，类的使用者就被称为 API 调用者。
JDK 就给我们提供了 Java 的基础实现，JDK 的作者也就是基础 API 的提供者（Java 多线程部分的作者 Doug Lea 是被 Java 程序员敬佩的一个大佬），我们这些 Java 语言的使用者，说白了就是 JDK 的调用者。

当然了，假如我们也提供了新的类给其他调用者，我们也就成为了新的创建者。
API 创建者在创建新的类的时候，只暴露必要的接口，而隐藏其他所有不必要的信息，之所以要这么做，是因为如果这些信息对调用者是不可见的，那么创建者就可以随意修改隐藏的信息，而不用担心对调用者的影响。
这里就必须要讲到 Java 的权限修饰符。
访问权限修饰符的第一个作用是，防止类的调用者接触到他们不该接触的内部实现；第二个作用是，让类的创建者可以轻松修改内部机制而不用担心影响到调用者的使用。

public
private
protected

还有一种“默认”的权限修饰符，是缺省的，它修饰的类可以访问同一个包下面的其他类。
4）组合
我们可以把一个创建好的类作为另外一个类的成员变量来使用，利用已有的类组成成一个新的类，被称为“复用”，组合代表的关系是 has-a 的关系。
5）继承
继承是 Java 中非常重要的一个概念，子类继承父类，也就拥有了父类中 protected 和 public 修饰的方法和字段，同时，子类还可以扩展一些自己的方法和字段，也可以重写继承过来方法。
常见的例子，就是形状可以有子类圆形、方形、三角形，它们的基础接口是相同的，比如说都有一个draw() 的方法，子类可以继承这个方法实现自己的绘制方法。
如果子类只是重写了父类的方法，那么它们之间的关系就是 is-a 的关系，但如果子类增加了新的方法，那么它们之间的关系就变成了 is-like-a 的关系。
6）多态
比如说有一个父类Shape
12345public class Shape {    public void draw() {        System.out.println(&quot;形状&quot;);    }}
子类Circle
123456public class Circle extends Shape{    @Override    public void draw() {        System.out.println(&quot;圆形&quot;);    }}
子类Line
123456public class Line extends Shape {    @Override    public void draw() {        System.out.println(&quot;线&quot;);    }}
测试类
12345678public class Test {    public static void main(String[] args) {        Shape shape1 &#x3D; new Line();        shape1.draw();        Shape shape2 &#x3D; new Circle();        shape2.draw();    }}
运行结果：
12线圆形
在测试类中，shape1 的类型为 Shape，shape2 的类型也为 Shape，但调用 draw() 方法后，却能自动调用子类 Line 和 Circle 的 draw() 方法，这是为什么呢？
其实就是 Java 中的多态。
06、小结
“怎么样，三妹，是不是对 Java 有了更深入更清晰的理解？”终于讲完了，我深呼了一口气，好舒畅啊！
“是的，哥，感觉 Java 也就那么回事嘛。”哎呀，三妹有点狂了起来，“万物皆对象，除了基本数据类型。”
“哇，三妹，你可以啊，都会自己梳理总结了。”我倍感欣慰，觉得果然是劳有所获，你讲的认真，听众就能理解和 get，满足了。
3.2 Java中的包“三妹，这一节，我们简单过一下 Java 中的包，也就是 package，这个一点就透，很好掌握。”我放下手中的雪碧，翻开笔记本，点开《Java 进阶之路》，找到这篇「Java 中的包」，开始滔滔不绝起来。
“二哥，你等一下。”让我打开思维导图做一下笔记 。
关于包
在前面的代码中，我们把类和接口命名为 Person 、 Student 、 Hello 等简单的名字。
在团队开发中，如果小明写了一个 Person 类，小红也写了一个 Person 类，现在，小白既想用小明的Person ，也想用小红的 Person ，怎么办？
如果小军写了一个 Arrays 类，恰好 JDK 也自带了一个 Arrays 类，如何解决类名冲突？
在 Java 中，我们使用 package 来解决名字冲突。
Java 定义了一种名字空间，称之为包： package 。一个类总是属于某个包，类名（比如 Person ）只是一个简写，真正的完整类名是 包名.类名 。
例如：
小明的 Person 类存放在包 ming 下面，因此，完整类名是 ming.Person ；
小红的 Person 类存放在包 hong 下面，因此，完整类名是 hong.Person ；
小军的 Arrays 类存放在包 mr.jun 下面，因此，完整类名是 mr.jun.Arrays ；
JDK 的 Arrays 类存放在包 java.util 下面，因此，完整类名是 java.util.Arrays 。
在定义 class 的时候，我们需要在第一行声明这个 class 属于哪个包。
小明的 Person.java 文件：
123package ming; &#x2F;&#x2F; 申明包名mingpublic class Person {}
小军的 Arrays.java 文件：
123package mr.jun; &#x2F;&#x2F; 申明包名mr.junpublic class Arrays {}
在 Java 虚拟机执行的时候，JVM 只看完整类名，因此，只要包名不同，类就不同。
包可以是多层结构，用 . 隔开。例如： java.util 。

要特别注意：包没有父子关系。java.util和java.util.zip是不同的包，两者没有任何继承关系。

没有定义包名的 class ，它使用的是默认包，非常容易引起名字冲突，因此，不推荐不写包名的做法。
我们还需要按照包结构把上面的 Java 文件组织起来。假设以 package_sample 作为根目录， src 作为源码目录，那么所有文件结构就是：
123456789package_sample└─ src    ├─ hong    │  └─ Person.java    │  ming    │  └─ Person.java    └─ mr       └─ jun          └─ Arrays.java
即所有 Java 文件对应的目录层次要和包的层次一致。
编译后的 .class 文件也需要按照包结构存放。如果使用 IDE，把编译后的 .class 文件放到 bin 目录下，那么，编译的文件结构就是：
123456789package_sample└─ bin   ├─ hong   │  └─ Person.class   │  ming   │  └─ Person.class   └─ mr      └─ jun         └─ Arrays.class
编译的命令相对比较复杂，我们需要在 src 目录下执行 javac 命令：
1javac -d ..&#x2F;bin ming&#x2F;Person.java hong&#x2F;Person.java mr&#x2F;jun&#x2F;Arrays.java
在 IDE 中，会自动根据包结构编译所有 Java 源码，所以不必担心使用命令行编译的复杂命令。
包的作用域
位于同一个包的类，可以访问包作用域的字段和方法。
不用 public 、 protected 、 private 修饰的字段和方法就是包作用域。例如， Person 类定义在 hello 包
下面：
1234567package hello;public class Person {    &#x2F;&#x2F; 包作用域:    void hello() {        System.out.println(&quot;Hello!&quot;);    }}
Main 类也定义在 hello 包下面，就可以直接访问 Person 类：
1234567package hello;public class Main {    public static void main(String[] args) {        Person p &#x3D; new Person();        p.hello(); &#x2F;&#x2F; 可以调用，因为Main和Person在同一个包    }}
导入包
在一个 class 中，我们总会引用其他的 class 。例如，小明的 ming.Person 类，如果要引用小军的mr.jun.Arrays 类，他有三种写法：
第一种，直接写出完整类名，例如：
1234567&#x2F;&#x2F; Person.javapackage ming;public class Person {    public void run() {        mr.jun.Arrays arrays &#x3D; new mr.jun.Arrays();    }}
很显然，每次都要写完整的类名比较痛苦。
因此，第二种写法是用 import 语句，导入小军的 Arrays ，然后写简单类名：
123456789&#x2F; Person.javapackage ming;&#x2F;&#x2F; 导入完整类名:import mr.jun.Arrays;public class Person {    public void run() {        Arrays arrays &#x3D; new Arrays();    }}
在写 import 的时候，可以使用 * ，表示把这个包下面的所有 class 都导入进来（但不包括子包的class ）：
123456789&#x2F;&#x2F; Person.javapackage ming;&#x2F;&#x2F; 导入mr.jun包的所有class:import mr.jun.*;public class Person {    public void run() {        Arrays arrays &#x3D; new Arrays();    }}
我们一般不推荐这种写法，因为在导入了多个包后，很难看出 Arrays 类属于哪个包。
还有一种 import static 的语法，它可以导入一个类的静态字段和静态方法：
123456789package main;&#x2F;&#x2F; 导入System类的所有静态字段和静态方法:import static java.lang.System.*;public class Main {    public static void main(String[] args) {        &#x2F;&#x2F; 相当于调用System.out.println(…)        out.println(&quot;Hello, world!&quot;);    }}
import static 很少使用。
Java 编译器最终编译出的 .class 文件只使用 完整类名，因此，在代码中，当编译器遇到一个 class 名称时：

如果是完整类名，就直接根据完整类名查找这个 class ；
如果是简单类名，按下面的顺序依次查找：

查找当前 package 是否存在这个 class ；

查找 import 的包是否包含这个 class ；

查找 java.lang 包是否包含这个 class 。




如果按照上面的规则还无法确定类名，则编译报错。
我们来看一个例子：
12345678910111213&#x2F;&#x2F; Main.javapackage test;import java.text.Format;public class Main {    public static void main(String[] args) {        java.util.List list; &#x2F;&#x2F; ok，使用完整类名 -&gt; java.util.List        Format format &#x3D; null; &#x2F;&#x2F; ok，使用import的类 -&gt; java.text.Format        String s &#x3D; &quot;hi&quot;; &#x2F;&#x2F; ok，使用java.lang包的String -&gt; java.lang.String        System.out.println(s); &#x2F;&#x2F; ok，使用java.lang包的System -&gt; java.lang.System        MessageFormat mf &#x3D; null; &#x2F;&#x2F; 编译错误：无法找到MessageFormat: MessageFormat cannot be resolved to a type    }}
因此，编写 class 的时候，编译器会自动帮我们做两个 import 动作：

默认自动 import 当前 package 的其他 class ；
默认自动 import java.lang.* 。


注意：自动导入的是java.lang包，但类似java.lang.reflect这些包仍需要手动导入。

如果有两个 class 名称相同，例如， mr.jun.Arrays 和 java.util.Arrays ，那么只能 import 其中一个，另一个必须写完整类名。
包的最佳实践
为了避免名字冲突，我们需要确定唯一的包名。推荐的做法是使用倒置的域名来确保唯一性。例如：

org.apache
org.apache.commons.log
com.tobebetterjavaer.sample

子包就可以根据功能自行命名。
要注意不要和 java.lang 包的类重名，即自己的类不要使用这些名字：

String
System
Runtime
…

要注意也不要和 JDK 常用类重名：

java.util.List
java.text.Format
java.math.BigInteger
…

小结
Java 内建的 package 机制是为了避免 class 命名冲突；
JDK 的核心类使用 java.lang 包，编译器会自动导入；
JDK 的其它常用类定义在 java.util. ， java.math. ， java.text.* ，……；
包名推荐使用倒置的域名，例如 org.apache 。
3.3 Java中的变量“二哥，听说 Java 变量在以后的日子里经常用，能不能提前给我透露透露？”三妹咪了一口麦香可可奶茶后对我说。
“三妹啊，搬个凳子坐我旁边，听二哥来给你慢慢说啊。”
Java 变量就好像一个容器，可以保存程序在运行过程中的值，它在声明的时候会定义对应的数据类型（Java分为两种数据类型：基本数据类型和引用数据类型）。变量按照作用域的范围又可分为三种类型：局部变量，成员变量和静态变量。
比如说， int data &#x3D; 88; ，其中 data 就是一个变量，它的值为 88，类型为整型（int）。
01、局部变量

在方法体内声明的变量被称为局部变量，该变量只能在该方法内使用，类中的其他方法并不知道该变量。来看下面这个示例：
其中 a、b、c 就是局部变量，它们只能在当前这个 main 方法中使用。
声明局部变量时的注意事项：
局部变量声明在方法、构造方法或者语句块中。
局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，将会被销毁。
访问修饰符不能用于局部变量。
局部变量只在声明它的方法、构造方法或者语句块中可见。
局部变量是在栈上分配的。
局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。

02、成员变量
在类内部但在方法体外声明的变量称为成员变量，或者实例变量，或者字段。之所以称为实例变量，是因为该变量只能通过类的实例（对象）来访问。来看下面这个示例：
1234567public class InstanceVariable {    int data &#x3D; 88;    public static void main(String[] args) {        InstanceVariable iv &#x3D; new InstanceVariable();        System.out.println(iv.data); &#x2F;&#x2F; 88    }}
其中 iv 是一个变量，它是一个引用类型的变量。 new 关键字可以创建一个类的实例（也称为对象），通过“&#x3D;”操作符赋值给 iv 这个变量，iv 就成了这个对象的引用，通过 iv.data 就可以访问成员变量了。

声明成员变量时的注意事项：
成员变量声明在一个类中，但在方法、构造方法和语句块之外。
当一个对象被实例化之后，每个成员变量的值就跟着确定。
成员变量在对象创建的时候创建，在对象被销毁的时候销毁。
成员变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息。
成员变量可以声明在使用前或者使用后。
访问修饰符可以修饰成员变量。
成员变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把成员变量设为私有。通过使用访问修饰符可以使成员变量对子类可见；成员变量具有默认值。数值型变量的默认值是 0，布尔型变量的默认值是 false，引用类型变量的默认值是 null。变量的值可以在声明时指定，也可以在构造方法中指定。

03、静态变量
通过 static 关键字声明的变量被称为静态变量（类变量），它可以直接被类访问，来看下面这个示例：
123456public class StaticVariable {    static int data &#x3D; 99;    public static void main(String[] args) {        System.out.println(StaticVariable.data); &#x2F;&#x2F; 99    }}
其中 data 就是静态变量，通过 类名.静态变量 就可以访问了，不需要创建类的实例。
声明静态变量时的注意事项：

静态变量在类中以 static 关键字声明，但必须在方法构造方法和语句块之外。
无论一个类创建了多少个对象，类只拥有静态变量的一份拷贝。
静态变量除了被声明为常量外很少使用。
静态变量储存在静态存储区。
静态变量在程序开始时创建，在程序结束时销毁。
与成员变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为 public 类型。
静态变量的默认值和实例变量相似。
静态变量还可以在静态语句块中初始化。

04、常量
在 Java 中，有些数据的值是不会发生改变的，这些数据被叫做常量——使用 final 关键字修饰的成员变量。
常量的值一旦给定就无法改变！
常量在程序运行过程中主要有 2 个作用：

代表常数，便于修改（例如：圆周率的值， final double PI &#x3D; 3.14 ）
增强程序的可读性（例如：常量 UP、DOWN 用来代表上和下， final int UP &#x3D; 0 ）

Java 要求常量名必须大写。来看下面这个示例：
123456789public class FinalVariable {    final String CHEN &#x3D; &quot;沉&quot;;    static final String MO &#x3D; &quot;默&quot;;    public static void main(String[] args) {        FinalVariable fv &#x3D; new FinalVariable();        System.out.println(fv.CHEN);        System.out.println(MO);    }}
“好了，三妹，关于 Java 变量就先说这么多吧，你是不是已经清楚了？”转动了一下僵硬的脖子后，我对三妹说。
“是啊，二哥，我想以后还会再见到它们吧？”
“那见的次数可就多了，就好像你每天眨眼的次数一样多。”
3.4 Java中的方法“二哥，这一节我们学什么呢？”三妹满是期待的问我。
“这一节我们来了解一下 Java 中的方法——什么是方法？如何声明方法？方法有哪几种？什么是实例方法？
什么是静态方法？什么是抽象方法？什么是本地方法？”我笑着对三妹说，“我开始了啊，你要注意力集中啊。”
01、Java中的方法是什么？
方法用来实现代码的可重用性，我们编写一次方法，并多次使用它。通过增加或者删除方法中的一部分代码，就可以提高整体代码的可读性。
只有方法被调用时，它才会执行。Java 中最有名的方法当属 main() 方法，这是程序的入口。
02、如何声明方法？
方法的声明反映了方法的一些信息，比如说可见性、返回类型、方法名和参数。如下图所示。

访问权限：它指定了方法的可见性。Java 提供了四种访问权限修饰符：

public：该方法可以被所有类访问。
private：该方法只能在定义它的类中访问。
protected：该方法可以被同一个包中的类，或者不同包中的子类访问。
default：如果一个方法没有使用任何访问权限修饰符，那么它是 package-private 的，意味着该方法只能被同一个包中的类可见。

返回类型：方法返回的数据类型，可以是基本数据类型、对象和集合，如果不需要返回数据，则使用 void 关键字。
方法名：方法名最好反应出方法的功能，比如，我们要创建一个将两个数字相减的方法，那么方法名最好是subtract。
方法名最好是一个动词，并且以小写字母开头。如果方法名包含两个以上单词，那么第一个单词最好是动词，然后是形容词或者名词，并且要以驼峰式的命名方式命名。比如：

一个单词的方法名： sum()
多个单词的方法名： stringComparision()

一个方法可能与同一个类中的另外一个方法同名，这被称为方法重载。
参数：参数被放在一个圆括号内，如果有多个参数，可以使用逗号隔开。参数包含两个部分，参数类型和参数名。如果方法没有参数，圆括号是空的。
方法签名：每一个方法都有一个签名，包括方法名和参数。
方法体：方法体放在一对花括号内，把一些代码放在一起，用来执行特定的任务。
03、方法有哪几种？
方法可以分为两种，一种叫标准类库方法，一种叫用户自定义方法。
1）预先定义方法
Java 提供了大量预先定义好的方法供我们调用，也称为标准类库方法，或者内置方法。比如说 String 类的length() 、 equals() 、 compare() 方法，以及我们在初学 Java 阶段最常用的 println() 方法，用来在控制台打印信息。
12345public class PredefinedMethodDemo {    public static void main(String[] args) {        System.out.println(&quot;沉默王二，一枚有趣的程序员&quot;);    }}
在上面的代码中，我们使用了两个预先定义的方法， main() 方法是程序运行的入口， println() 方法是PrintStream 类的一个方法。这些方法已经提前定义好了，所以我们可以直接使用它们。
我们可以通过集成开发工具查看预先定义方法的方法签名，当我们把鼠标停留在 println() 方法上面时，就会显示下图中的内容：

println() 方法的访问权限修饰符是 public，返回类型为 void，方法名为 println，参数为 String x ，以及 Javadoc（方法是干嘛的）。
预先定义方法让编程变得简单了起来，我们只需要在实现某些功能的时候直接调用这些方法即可，不需要重新编写。
Java 的一个非常大的优势，就是，JDK 的设计者（开发者）为我们提供了大量的标准类库方法，这对于初学编程的新手来说极其友好；不仅如此，GitHub&#x2F;码云上也有大量可以直接拿到生产环境下使用的第三方类库，比如说 hutool 啊、Apache 包啊、一线大厂或者顶级开发大佬贡献的类库，比如说 Druid、Gson 等等。
但如果你想从一个初级开发者（俗称调包侠）晋升为一名优秀的 Java 工程师，那就需要深入研究这些源码，并掌握，最好是能自己写出来这些源码，最起码能自定义一些源码，以便为我们所用。
2）用户自定义方法
当预先定义方法无法满足我们的要求时，就需要自定义一些方法，比如说，我们来定义这样一个方法，用来检查数字是偶数还是奇数。
1234567public static void findEvenOdd(int num) {    if (num % 2 &#x3D;&#x3D; 0) {        System.out.println(num + &quot; 是偶数&quot;);    } else {        System.out.println(num + &quot; 是奇数&quot;);    }}
方法名叫做 findEvenOdd ，访问权限修饰符是 public，并且是静态的（static），返回类型是 void，参数有一个整型（int）的 num。方法体中有一个 if else 语句，如果 num 可以被 2 整除，那么就打印这个数字是偶数，否则就打印这个数字是奇数。
方法被定义好后，如何被调用呢？
12345678910111213public class EvenOddDemo {    public static void main(String[] args) {        findEvenOdd(10);        findEvenOdd(11);    }    public static void findEvenOdd(int num) {        if (num % 2 &#x3D;&#x3D; 0) {            System.out.println(num + &quot; 是偶数&quot;);        } else {            System.out.println(num + &quot; 是奇数&quot;);        }    }}
main() 方法是程序的入口，并且是静态的，那么就可以直接调用同样是静态方法的 findEvenOdd() 。
当一个方法被 static 关键字修饰时，它就是一个静态方法。换句话说，静态方法是属于类的，不属于类实例的（不需要通过 new 关键字创建对象来调用，直接通过类名就可以调用）。
04、什么是实例方法？
没有使用 static 关键字修饰，但在类中声明的方法被称为实例方法，在调用实例方法之前，必须创建类的对象。
123456789public class InstanceMethodExample {    public static void main(String[] args) {        InstanceMethodExample instanceMethodExample &#x3D; new InstanceMethodExample();        System.out.println(instanceMethodExample.add(1, 2));    }    public int add(int a, int b) {        return a + b;    }}
add() 方法是一个实例方法，需要创建 InstanceMethodExample 对象来访问。
实例方法有两种特殊类型：

getter 方法
setter 方法

getter 方法用来获取私有变量（private 修饰的字段）的值，setter 方法用来设置私有变量的值。
1234567891011121314151617181920212223public class Person {    private String name;    private int age;    private int sex;    public String getName() {        return name;    }    public void setName(String name) {        this.name &#x3D; name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age &#x3D; age;    }    public int getSex() {        return sex;    }    public void setSex(int sex) {        this.sex &#x3D; sex;    }}
getter 方法以 get 开头，setter 方法以 set 开头。
05、什么是静态方法？
相应的，有 static 关键字修饰的方法就叫做静态方法。
12345678public class StaticMethodExample {    public static void main(String[] args) {        System.out.println(add(1,2));    }    public static int add(int a, int b) {        return a + b;    }}
StaticMethodExample 类中，mian 和 add 方法都是静态方法，不同的是，main 方法是程序的入口。当我们调用静态方法的时候，就不需要 new 出来类的对象，就可以直接调用静态方法了，一些工具类的方法都是静态方法，比如说 hutool 工具类库，里面有大量的静态方法可以直接调用。

Hutool 的目标是使用一个工具方法代替一段复杂代码，从而最大限度的避免“复制粘贴”代码的问题，彻底改变我们写代码的方式。

以计算 MD5 为例：

【以前】打开搜索引擎 -&gt; 搜“Java MD5 加密” -&gt; 打开某篇博客-&gt; 复制粘贴 -&gt; 改改好用
【现在】引入 Hutool -&gt; SecureUtil.md5()

Hutool 的存在就是为了减少代码搜索成本，避免网络上参差不齐的代码出现导致的 bug。
06、什么是抽象方法？
没有方法体的方法被称为抽象方法，它总是在抽象类中声明。这意味着如果类有抽象方法的话，这个类就必须是抽象的。可以使用 atstract 关键字创建抽象方法和抽象类。
123abstract class AbstractDemo {    abstract void display();}
当一个类继承了抽象类后，就必须重写抽象方法：
12345678910public class MyAbstractDemo extends AbstractDemo {    @Override    void display() {        System.out.println(&quot;重写了抽象方法&quot;);    }    public static void main(String[] args) {        MyAbstractDemo myAbstractDemo &#x3D; new MyAbstractDemo();        myAbstractDemo.display();    }}
输出结果如下所示：
1重写了抽象方法
“关于方法，我们就讲到这里吧，学会了类&#x2F;变量&#x2F;方法，基本上就可以做一个入门级的 Java 程序员了。”我面露微笑，继续对三妹说，“继续加油吧！”
“好的，谢谢二哥你的细心帮助。”
3.5 Java可变参数为了让铁粉们能白票到阿里云的服务器，我当了整整两天的客服，真正体验到了什么叫做“为人民群众谋福利”的不易和辛酸。正在我眼睛红肿打算要休息之际，三妹跑过来问：“Java 的可变参数究竟是怎么一回事？”
我一下子又清醒了，我爱 Java，我爱传道解惑，也享受三妹的赞许（ ）。
可变参数是 Java 1.5 的时候引入的功能，它允许方法使用任意多个、类型相同（ is-a ）的值作为参数。就像下面这样。
1234567891011public static void main(String[] args) {    print(&quot;沉&quot;);    print(&quot;沉&quot;, &quot;默&quot;);    print(&quot;沉&quot;, &quot;默&quot;, &quot;王&quot;);    print(&quot;沉&quot;, &quot;默&quot;, &quot;王&quot;, &quot;二&quot;);}public static void print(String... strs) {    for (String s : strs)        System.out.print(s);    System.out.println();}
静态方法 print() 就使用了可变参数，所以 print(“沉”) 可以， print(“沉”, “默”) 也可以，甚至 3个、 4 个或者更多个字符串都可以作为参数传递给 print() 方法。
说到可变参数，我想起来阿里巴巴开发手册上有这样一条规约。

意思就是尽量不要使用可变参数，如果要用的话，可变参数必须要在参数列表的最后一位。既然坑位有限，只能在最后，那么可变参数就只能有一个（悠着点，悠着点）。如果可变参数不在最后一位，IDE 就会提示对应的错误，如下图所示。

可变参数看起来就像是个语法糖，它背后究竟隐藏了什么呢？让我们来一探究竟，在追求真理这条路上我们要执着。
其实也很简单。当使用可变参数的时候，实际上是先创建了一个数组，该数组的大小就是可变参数的个数，然后将参数放入数组当中，再将数组传递给被调用的方法。
这就是为什么可以使用数组作为参数来调用带有可变参数的方法的根本原因。代码如下所示。
1234567891011public static void main(String[] args) {    print(new String[]{&quot;沉&quot;});    print(new String[]{&quot;沉&quot;, &quot;默&quot;});    print(new String[]{&quot;沉&quot;, &quot;默&quot;, &quot;王&quot;});    print(new String[]{&quot;沉&quot;, &quot;默&quot;, &quot;王&quot;, &quot;二&quot;});}public static void print(String... strs) {    for (String s : strs)        System.out.print(s);    System.out.println();}
那如果方法的参数是一个数组，然后像使用可变参数那样去调用方法的时候，能行得通吗？
“三妹，给你留个思考题：一般什么时候使用可变参数呢？”
可变参数，可变参数，顾名思义，当一个方法需要处理任意多个相同类型的对象时，就可以定义可变参数。
Java 中有一个很好的例子，就是 String 类的 format() 方法，就像下面这样。
12System.out.println(String.format(&quot;年纪是: %d&quot;, 18));System.out.println(String.format(&quot;年纪是: %d 名字是: %s&quot;, 18, &quot;沉默王二&quot;));
%d 表示将整数格式化为 10 进制整数， %s 表示输出字符串。
如果不使用可变参数，那需要格式化的参数就必须使用“+”号操作符拼接起来了。麻烦也就惹上身了。
在实际的项目代码中，slf4j 的日志输出就经常要用到可变参数（log4j 就没法使用可变参数，日志中需要记录多个参数时就痛苦不堪了）。就像下面这样。
123protected Logger logger &#x3D; LoggerFactory.getLogger(getClass());logger.debug(&quot;名字是{}&quot;, mem.getName());logger.debug(&quot;名字是{}，年纪是{}&quot;, mem.getName(), mem.getAge());
查看源码就可以发现， debug() 方法使用了可变参数。
1public void debug(String format, Object... arguments);
“那在使用可变参数的时候有什么注意事项吗？”三妹问。
有的。我们要避免重载带有可变参数的方法——这样很容易让编译器陷入自我怀疑中。
12345678910111213public static void main(String[] args) {    print(null);}public static void print(String... strs) {    for (String a : strs)        System.out.print(a);    System.out.println();}public static void print(Integer... ints) {    for (Integer i : ints)        System.out.print(i);    System.out.println();}
这时候，编译器完全不知道该调用哪个 print() 方法， print(String… strs) 还是print(Integer… ints) ，傻傻分不清。

假如真的需要重载带有可变参数的方法，就必须在调用方法的时候给出明确的指示，不要让编译器去猜。
12345678910public static void main(String[] args) {    String [] strs &#x3D; null;    print(strs);    Integer [] ints &#x3D; null;    print(ints);}public static void print(String... strs) {}public static void print(Integer... ints) {}
上面这段代码是可以编译通过的。因为编译器知道参数是 String 类型还是 Integer 类型，只不过为了运行时不抛出 NullPointerException ，两个 print() 方法的内部要做好判空操作。
“好了，关于可变参数，我们就先讲到这里吧。三妹，你都理解了吧？”
“嗯嗯，不难，我理解了，哥。”三妹最近的学习状态真不错，能看得出来，她有在认真地做笔记 。
3.6 Java native方法“三妹，之前我们学习了 Java 中的基本方法，其实 Java 还有一种方法，本地方法，或者叫 native 方法，它与之前的方法有很大的不同。”我放下手中的手机，扭过脸来对三妹说。
“听起来挺有意思的。”三妹很期待。
“我会教你用 C语言实现一个 native 方法。”我继续说到，“C语言是另外一种编程语言，让我们开始吧”
类似 Thread 类中的 private native start0() 方法；
又或者 Object.class 类中的 getClass() 方法、hashCode()方法、clone() 方法，其中方法签名如下：
123public final native Class&lt;?&gt; getClass();public native int hashCode();protected native Object clone() throws CloneNotSupportedException;
也就是用【native】关键词修饰的方法，多数情况下不需要用 Java 语言实现。
“二哥，为什么要用 native 来修饰方法呢，这样做有什么用？”三妹很乖，但这个问题也问的很掷地有声。
“好的，三妹，我们一步步来扒拉”。
1、JNI：Java Native Interface
在介绍 native 之前，我们先了解什么是 JNI。
一般情况下，我们完全可以使用 Java 语言编写程序，但某些情况下，Java 可能满足不了需求，或者不能更好的满足需求，比如：
①、标准的 Java 类库不支持。
②、我们已经用另一种语言，比如说 C&#x2F;C++ 编写了一个类库，如何用 Java 代码调用呢？
③、某些运行次数特别多的方法，为了加快性能，需要用更接近硬件的语言（比如汇编）编写。
上面这三种需求，说到底就是如何用 Java 代码调用不同语言编写的代码。那么 JNI 应运而生了。
从 Java 1.1 开始，Java Native Interface (JNI)标准就成为 Java 平台的一部分，它允许 Java 代码和其他语言编写的代码进行交互。
JNI 一开始是为了本地已编译语言，尤其是 C 和 C++而设计的，但是它并不妨碍你使用其他语言，只要调用约定受支持就可以了。使用 Java 与本地已编译的代码交互，通常会丧失平台可移植性，但是，有些情况下这样做是可以接受的，甚至是必须的，比如，使用一些旧的库，与硬件、操作系统进行交互，或者为了提高程序的性能。JNI 标准至少保证本地代码能工作能在任何 Java 虚拟机实现下。

通过 JNI，我们就可以通过 Java 程序（代码）调用到操作系统相关的技术实现的库函数，从而与其他技术和系统交互；同时其他技术和系统也可以通过 JNI 提供的相应原生接口调用 Java 应用系统内部实现的功能。
“二哥，等一下，Java 不是跨平台的吗？如果用 JNI，那么程序不就失去了跨平台的优点？”不得不说，三妹这个问题起到好处。
“确实是这样的。”我掐灭了中指和无名指之间的烟头，继续娓娓道来。
JNI 的缺点：
①、程序不再跨平台。要想跨平台，必须在不同的系统环境下重新编译本地语言部分。
②、程序不再是绝对安全的，本地代码的不当使用可能导致整个程序崩溃。一个通用规则是，你应该让本地方法集中在少数几个类当中。这样就降低了 Java 和 C&#x2F;C++ 之间的耦合性。
目前来讲使用 JNI 的缺点相对于优点还是可以接受的，可能后面随着 Java 的技术发展，我们不在需要 JNI，
但是目前 JDK 还是一直提供了对 JNI 标准的支持。
2、用 C 语言编写程序本地方法
“上面讲解了什么是 JNI，接下来我们来写个例子：如何用 Java 代码调用本地的 C 程序。”我扭头对三妹说，
“你注意 看。”

官方文档如下：https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;8&#x2F;docs&#x2F;technotes&#x2F;guides&#x2F;jni&#x2F;spec&#x2F;jniTOC.html

步骤如下：

编写带有 native 方法的 Java 类，生成.java 文件；
使用 javac 命令编译所编写的 Java 类，生成.class 文件；
使用 javah -jni java 类名 生成扩展名为 h 的头文件，也即生成 .h 文件；
使用 C&#x2F;C++（或者其他编程想语言）实现本地方法，创建 .h 文件的实现，也就是创建 .cpp 文件实现.h文件中的方法；
将 C&#x2F;C++ 编写的文件生成动态连接库，生成 dll 文件；

下面我们通过一个 HelloWorld 程序的调用来完成这几个步骤。
01）编写带有 native 方法的 Java 类 HelloJNI.java
在 &#x2F;Users&#x2F;itwanger&#x2F;Documents&#x2F;Github&#x2F;javabetter&#x2F;testjni 目录下创建 HelloJNI.java 文件，内容如下所示。
12345678910public class HelloJNI {    static {        System.loadLibrary(&quot;hello&quot;); &#x2F;&#x2F; 加载名为 libhello.dylib 的动态链接库    }    &#x2F;&#x2F; 定义本地方法    private native void helloJNI();    public static void main(String[] args) {        new HelloJNI().helloJNI(); &#x2F;&#x2F; 调用本地方法    }}
PS：后面执行的命令都将在 testjni 的目录下。
解释一下这段代码：
private native void helloJNI() ：用 native 声明的方法告知 JVM 调用该方法在外部定义，也就是我们会用 C 语言去实现。
System.loadLibrary(“hello”) ：加载动态库，参数 hello 是动态库的名字。我们可以这样理解：程序中的方法 helloJNI() 在程序中没有实现，但是我们下面要调用这个方法，怎么办呢？
我们就需要对这个方法进行初始化，所以用了 static 代码块进行初始化，后面会讲到。
02）编译 HelloJNI.java
在命令行通过 javac HelloJNI.java 来编译源代码。

03）使用 生成扩展名为 h 的头文件


PS：Java 9 以后，javah 被弃用，取而代之的是使用 -h 选项来生成头文件，例如 javac -h .ClassName.java 。

执行完毕后，会在 HelloJNI.java 所在目录下生成一个名为 HelloJNI.h 的头文件。打开 HelloJNI.h 文件，可以看到如下代码。

看不懂没关系，无所谓，直到它是自动生成的就好。
04）使用 C 语言实现本地方法
创建一个 C 文件 HelloJNI.c，实现本地方法 sayHello。
1234567#include &lt;stdio.h&gt;#include &lt;jni.h&gt;#include &quot;HelloJNI.h&quot;JNIEXPORT void JNICALL Java_HelloJNI_helloJNI(JNIEnv *env, jobject obj) {    printf(&quot;Hello, JNI!\n&quot;);    return;}
注意，这里需要引入 JNI 头文件，并且实现的方法名称需要与在 Java 中声明的名称一致（ HelloJNI_helloJNI HelloJNI 类的 helloJNI 方法）。
05）编写编译脚本 compile.sh
123456#!&#x2F;bin&#x2F;bash# 编译 HelloJNI.c 文件gcc -I&quot;$JAVA_HOME&#x2F;include&quot; -I&quot;$JAVA_HOME&#x2F;include&#x2F;darwin&quot; -shared -o libhello.dylib HelloJNI.c# 把生成的 libhello.dylib 文件拷贝到当前目录cp libhello.dylib .
注意事项：

$JAVA_HOME 是 JDK 的安装路径，需要根据实际情况修改。
在 macOS 上，动态链接库（hello）的后缀是 .dylib，而不是 Linux 上的 .so。

这里的 -I 选项是为了告诉编译器头文件的位置， $​JAVA_HOME 是 Java 安装目录的路径。
06）执行编译脚本
1sh compile.sh
执行完毕后，会在当前目录下生成一个名为 libhello.dylib 的动态链接库。

07）运行 HelloJNI
执行 java HelloJNI 命令运行 HelloJNI，如果一切正常，就会在终端上输出 Hello, JNI!。

3、JNI 调用 C 的流程图

4、native 关键字
“三妹，现在应该知道什么是 native 了吧？”我问三妹。
“嗯嗯，我来简述一下，二哥你看看我说的是否正确。”
native 用来修饰方法，用 native 声明的方法表示该方法的实现在外部定义，可以用任何语言去实现它，比如说 C&#x2F;C++。 简单地讲，一个 native Method 就是一个 Java 调用非 Java 代码的接口。
native 语法：
①、修饰方法的位置必须在返回类型之前，和其余的方法控制符前后关系不受限制。
②、不能用 abstract 修饰，也没有方法体，也没有左右大括号。
③、返回值可以是任意类型
“三妹，你学的不错嘛。”我对三妹的学习能力感到非常的欣慰，“我们在日常编程中看到 native 修饰的方法，只需要知道这个方法的作用是什么，至于别的就不用管了，操作系统会给我们实现，初学的时候也不需要太过深入。”
3.7 Java构造方法“三妹，上一节学了 Java 中的方法，接着学构造方法的话，难度就小很多了。”刚吃完中午饭，虽然有些困意，但趁机学个 10 分钟也是不错的，睡眠会更心满意足一些，于是我面露微笑地对三妹说。
“在 Java 中，构造方法是一种特殊的方法，当一个类被实例化的时候，就会调用构造方法。只有在构造方法被调用的时候，对象才会被分配内存空间。每次使用 new 关键字创建对象的时候，构造方法至少会被调用一次。”
“如果你在一个类中没有看见构造方法，并不是因为构造方法不存在，而是被缺省了，编译器会给这个类提供一个默认的构造方法。就是说，Java 有两种类型的构造方法：无参构造方法和有参构造方法。”
“注意，之所以叫它构造方法，是因为对象在创建的时候，需要通过构造方法初始化值——描写对象有哪些初始化状态。”
“哥，你缓缓，一口气说这么多，也真有你的。”三妹听得聚精会神，但也知道关心她这个既当哥又当老师的二哥了。
01、创建构造方法的规则
构造方法必须符合以下规则：

构造方法的名字必须和类名一样；
构造方法没有返回类型，包括 void；
构造方法不能是抽象的（abstract）、静态的（static）、最终的（final）、同步的（synchronized）。

简单解析一下最后一条规则。

由于构造方法不能被子类继承，所以用 final 和 abstract 关键字修饰没有意义；
构造方法用于初始化一个对象，所以用 static 关键字修饰没有意义；
多个线程不会同时创建内存地址相同的同一个对象，所以用 synchronized 关键字修饰没有必要。

构造方法的语法格式如下：
123456class class_name {    public class_name(){}    &#x2F;&#x2F; 默认无参构造方法    public ciass_name([paramList]){}    &#x2F;&#x2F; 定义有参数列表的构造方法    …    &#x2F;&#x2F; 类主体}
值得注意的是，如果用 void 声明构造方法的话，编译时不会报错，但 Java 会把这个所谓的“构造方法”当成普通方法来处理。
123public class Demo {    void Demo(){ }}
void Demo(){} 看起来很符合构造方法的写法（与类名相同），但其实只是一个不符合规范的普通方法，方法名的首字母使用了大写，方法体为空，它并不是默认的无参构造方法，可以通过反编译后的字节码验证。class class_name {
123456public class Demo {    public Demo() {    }    void Demo() {    }}
public Demo() {} 才是真正的无参构造方法。
不过，可以使用访问权限修饰符（private、protected、public、default）来修饰构造方法，访问权限修饰符决定了构造方法的创建方式。
02、默认构造方法
如果一个构造方法中没有任何参数，那么它就是一个默认构造方法，也称为无参构造方法。
12345678public class Bike {    Bike(){        System.out.println(&quot;一辆自行车被创建&quot;);    }    public static void main(String[] args) {        Bike bike &#x3D; new Bike();    }}
在上面这个例子中，我们为 Bike 类中创建了一个无参的构造方法，它在我们创建对象的时候被调用。
程序输出结果如下所示：
1一辆自行车被创建
通常情况下，无参构造方法是可以缺省的，我们开发者并不需要显式的声明无参构造方法，把这项工作交给编译器就可以了。

“二哥，默认构造方法的目的是什么？它为什么是一个空的啊？”三妹疑惑地看着我，提出了这个尖锐的问题。
“三妹啊，默认构造方法的目的主要是为对象的字段提供默认值，看下面这个例子你就明白了。”我胸有成竹地回答道。
12345678public class Person {    private String name;    private int age;    public static void main(String[] args) {        Person p &#x3D; new Person();        System.out.println(&quot;姓名 &quot; + p.name + &quot; 年龄 &quot; + p.age);    }}
输出结果如下所示：
1姓名 null 年龄 0
在上面的例子中，默认构造方法初始化了 name 和 age 的值，name 是 String 类型，所以默认值为 null，age 是 int 类型，所以默认值为 0。如果没有默认构造方法的话，这项工作就无法完成了。
**03、有参构造方法
有参数的构造方法被称为有参构造方法，参数可以有一个或多个。有参构造方法可以为不同的对象提供不同的值。当然，也可以提供相同的值。
1234567891011121314151617public class ParamConstructorPerson {    private String name;    private int age;    public ParamConstructorPerson(String name, int age) {        this.name &#x3D; name;        this.age &#x3D; age;    }    public void out() {        System.out.println(&quot;姓名 &quot; + name + &quot; 年龄 &quot; + age);    }    public static void main(String[] args) {        ParamConstructorPerson p1 &#x3D; new ParamConstructorPerson(&quot;沉默王二&quot;,18);        p1.out();        ParamConstructorPerson p2 &#x3D; new ParamConstructorPerson(&quot;沉默王三&quot;,16);        p2.out();    }}
在上面的例子中，构造方法有两个参数（name 和 age），这样的话，我们在创建对象的时候就可以直接为name 和 age 赋值了。
12new ParamConstructorPerson(&quot;沉默&quot;,18);new ParamConstructorPerson(&quot;沉默&quot;,16);
如果没有有参构造方法的话，就需要通过 setter 方法给字段赋值了。
04、重载构造方法
在 Java 中，构造方法和方法类似，只不过没有返回类型。它也可以像方法一样被重载。构造方法的重载也很简单，只需要提供不同的参数列表即可。编译器会通过参数的数量来决定应该调用哪一个构造方法。
12345678910111213141516171819202122232425public class OverloadingConstrutorPerson {    private String name;    private int age;    private int sex;    public OverloadingConstrutorPerson(String name, int age, int sex) {        this.name &#x3D; name;        this.age &#x3D; age;        this.sex &#x3D; sex;    }    public OverloadingConstrutorPerson(String name, int age) {        this.name &#x3D; name;        this.age &#x3D; age;    }    public void out() {        System.out.println(&quot;姓名 &quot; + name + &quot; 年龄 &quot; + age + &quot; 性别 &quot; + sex);    }    public static void main(String[] args) {        OverloadingConstrutorPerson p1 &#x3D; new OverloadingConstrutorPerson(&quot;沉默王二&quot;,18, 1);        p1.out();        OverloadingConstrutorPerson p2 &#x3D; new OverloadingConstrutorPerson(&quot;沉默王三&quot;,16);        p2.out();    }}
创建对象的时候，如果传递的是三个参数，那么就会调用 OverloadingConstrutorPerson(String name, int age, int sex) 这个构造方法；如果传递的是两个参数，那么就会调用OverloadingConstrutorPerson(String name, int age) 这个构造方法。
05、构造方法和方法的区别
构造方法和方法之间的区别还是蛮多的，比如说下面这些：




方法
构造方法




方法反映了对象的行为
构造方法用于初始化对象的字段


方法可以有返回类型
构造方法没有返回类型


方法的调用是明确的，开发者通过代码决定调用哪一个
构造方法的调用是隐式的，通过编译器完成


方法在任何情况下都不能由编译器提供
如果没有明确提供无参构造方法，编译器会提供


方法名可以和类名相同，也可以不同
构造方法的名称必须和类名相同




06、复制对象
复制一个对象可以通过下面三种方式完成：

通过构造方法
通过对象的值
通过 Object 类的 clone() 方法

1）通过构造方法
12345678910111213141516171819202122232425public class CopyConstrutorPerson {    private String name;    private int age;    public CopyConstrutorPerson(String name, int age) {        this.name &#x3D; name;        this.age &#x3D; age;    }        public CopyConstrutorPerson(CopyConstrutorPerson person) {        this.name &#x3D; person.name;        this.age &#x3D; person.age;    }        public void out() {        System.out.println(&quot;姓名 &quot; + name + &quot; 年龄 &quot; + age);    }        public static void main(String[] args) {        CopyConstrutorPerson p1 &#x3D; new CopyConstrutorPerson(&quot;沉默王二&quot;,18);        p1.out();        CopyConstrutorPerson p2 &#x3D; new CopyConstrutorPerson(p1);        p2.out();    }}
在上面的例子中，有一个参数为 CopyConstrutorPerson 的构造方法，可以把该参数的字段直接复制到新的对象中，这样的话，就可以在 new 关键字创建新对象的时候把之前的 p1 对象传递过去。
2）通过对象的值
1234567891011121314151617181920212223242526public class CopyValuePerson {    private String name;    private int age;        public CopyValuePerson(String name, int age) {        this.name &#x3D; name;        this.age &#x3D; age;    }        public CopyValuePerson() {    }        public void out() {        System.out.println(&quot;姓名 &quot; + name + &quot; 年龄 &quot; + age);    }        public static void main(String[] args) {        CopyValuePerson p1 &#x3D; new CopyValuePerson(&quot;沉默王二&quot;,18);        p1.out();        CopyValuePerson p2 &#x3D; new CopyValuePerson();        p2.name &#x3D; p1.name;        p2.age &#x3D; p1.age;                p2.out();    }}
这种方式比较粗暴，直接拿 p1 的字段值复制给 p2 对象（ p2.name &#x3D; p1.name ）。
3）通过 Object 类的 方法
12345678910111213141516171819202122232425public class ClonePerson implements Cloneable {    private String name;    private int age;        public ClonePerson(String name, int age) {        this.name &#x3D; name;        this.age &#x3D; age;    }        @Override    protected Object clone() throws CloneNotSupportedException {        return super.clone();    }        public void out() {        System.out.println(&quot;姓名 &quot; + name + &quot; 年龄 &quot; + age);    }        public static void main(String[] args) throws CloneNotSupportedException {        ClonePerson p1 &#x3D; new ClonePerson(&quot;沉默王二&quot;,18);        p1.out();        ClonePerson p2 &#x3D; (ClonePerson) p1.clone();        p2.out();    }}
通过 clone() 方法复制对象的时候，ClonePerson 必须先实现 Cloneable 接口的 clone() 方法，然后再调用 clone() 方法（ ClonePerson p2 &#x3D; (ClonePerson) p1.clone() ）。
07、ending
“二哥，我能问一些问题吗？”三妹精神焕发，没有丝毫的疲惫。
“当然可以啊，你问。”我很欣赏三妹孜孜不倦的态度。
“构造方法真的不返回任何值吗？”
“构造方法虽然没有返回值，但返回的是类的对象。”
“构造方法只能完成字段初始化的工作吗？”
“初始化字段只是构造方法的一种工作，它还可以做更多，比如启动线程，调用其他方法等。”
“好的，二哥，我的问题问完了，今天的学习可以结束了！”三妹一脸得意的样子。
“那你记得复习下一节的内容哦。”感受到三妹已经学到了知识，我也很欣慰。
3.8 Java访问权限修饰符“我们先来讨论一下为什么需要访问权限控制。其实之前我们在讲类和对象的时候有提到，今天我们来详细地聊一聊，三妹。”我开门见山地说，“三妹，你打开思维导图，记得做笔记哦。”
“好的。”三妹应声回答。
考虑两个场景：
场景 1：工程师 A 编写了一个类 ClassA，但是工程师 A 并不希望 ClassA 被其他类都访问到，该如何处理呢？
场景 2：工程师 A 编写了一个类 ClassA，其中有两个方法 fun1、fun2，工程师只想让 fun1 对外可见，也就是说，如果别的工程师来调用 ClassA，只可以调用方法 fun1，该怎么处理呢？
此时，访问权限控制便可以起到作用了。
在 Java 中，提供了四种访问权限控制：

默认访问权限（包访问权限）
public
private
protected

类只可以用默认访问权限和 public 修饰。比如说：
1public class Wanger{}
或者
1class Wanger{}
但变量和方法则都可以修饰。
1.修饰类

默认访问权限（包访问权限）：用来修饰类的话，表示该类只对同一个包中的其他类可见。
public：用来修饰类的话，表示该类对其他所有的类都可见。

例 1：
Main.java:
1234567package com.tobetterjavaer.test1;public class Main {    public static void main(String\[\] args) {        People people &#x3D; new People(&quot;Tom&quot;);        System.out.println(people.getName());    }}
People.java
12345678910111213141516package com.tobetterjavaer.test1;class People {&#x2F;&#x2F;默认访问权限（包访问权限）    private String name &#x3D; null;        public People(String name) {        this.name &#x3D; name;    }        public String getName() {        return name;    }        public void setName(String name) {        this.name &#x3D; name;    }}
从代码可以看出，修饰 People 类采用的是默认访问权限，而由于 People 类和 Main 类在同一个包中，因此People 类对于 Main 类是可见的。
例子 2：
People.java
12345678910111213141516package com.tobetterjavaer.test2;class People {&#x2F;&#x2F;默认访问权限（包访问权限）    private String name &#x3D; null;        public People(String name) {        this.name &#x3D; name;    }        public String getName() {        return name;    }        public void setName(String name) {        this.name &#x3D; name;    }}
此时 People 类和 Main 类不在同一个包中，会发生什么情况呢？
下面是 Main 类中的提示的错误：

提示 Peolple 类在 Main 类中不可见。从这里就可以看出，如果用默认访问权限去修饰一个类，该类只对同一个包中的其他类可见，对于不同包中的类是不可见的。
正如上图的快速修正提示所示，将 People 类的默认访问权限更改为 public 的话，People 类对于 Main 类便可见了。
2.修饰方法和变量

默认访问权限（包访问权限）：如果一个类的方法或变量被包访问权限修饰，也就意味着只能在同一个包中的其他类中显示地调用该类的方法或者变量，在不同包中的类中不能显式地调用该类的方法或变量。
private：如果一个类的方法或者变量被 private 修饰，那么这个类的方法或者变量只能在该类本身中被访问，在类外以及其他类中都不能显式的进行访问。
protected：如果一个类的方法或者变量被 protected 修饰，对于同一个包的类，这个类的方法或变量是可以被访问的。对于不同包的类，只有继承于该类的类才可以访问到该类的方法或者变量。
public：被 public 修饰的方法或者变量，在任何地方都是可见的。

例 3：
Main.java 没有变化
People.java
12345678910111213141516package com.tobebetterjavaer.test1;public class People {    private String name &#x3D; null;        public People(String name) {        this.name &#x3D; name;    }        String getName() {    &#x2F;&#x2F;默认访问权限（包访问权限）        return name;    }        void setName(String name) {   &#x2F;&#x2F;默认访问权限（包访问权限）        this.name &#x3D; name;    }}
此时在 Main 类是可以显示调用方法 getName 和 setName 的。
但是如果 People 类和 Main 类不在同一个包中：
12345678910111213package com.tobebetterjavaer.test2;    &#x2F;&#x2F;与Main类处于不同包中public class People {    private String name &#x3D; null;    public People(String name) {        this.name &#x3D; name;    }    String getName() {    &#x2F;&#x2F;默认访问权限（包访问权限）        return name;    }    void setName(String name) {   &#x2F;&#x2F;默认访问权限（包访问权限）        this.name &#x3D; name;    }}
此时在 Main 类中会提示错误：

由此可以看出，如果用默认访问权限来修饰类的方法或者变量，则只能在同一个包的其他类中进行访问。
例 4:
People.java
12345678910111213141516package com.tobebetterjavaer.test1;public class People {    private String name &#x3D; null;        public People(String name) {        this.name &#x3D; name;    }    protected String getName() {        return name;    }        protected void setName(String name) {        this.name &#x3D; name;    }}
此时是可以在 Main 中显示调用方法 getName 和 setName 的。
如果 People 类和 Main 类处于不同包中：
12345678910111213package com.tobebetterjavaer.test2;public class People {    private String name &#x3D; null;    public People(String name) {        this.name &#x3D; name;    }    protected String getName() {        return name;    }    protected void setName(String name) {        this.name &#x3D; name;    }}
则会在 Main 中报错：

如果在 com.cxh.test1 中定一个类 Man 继承 People，则可以在类 Man 中显示调用方法 getName 和setName：
1234567891011package com.tobebetterjavaer.test1;import com.tobebetterjavaer.test2.People;public class Man extends People {    public Man(String name){        super(name);    }        public String toString() {        return getName();    }}
补充一些关于 Java 包和类文件的知识：
1）Java 中的包主要是为了防止类文件命名冲突以及方便进行代码组织和管理；
2）对于一个 Java 源代码文件，如果存在 public 类的话，只能有一个 public 类，且此时源代码文件的名称必须和 public 类的名称完全相同。
另外，如果还存在其他类，这些类在包外是不可见的。如果源代码文件没有 public 类，则源代码文件的名称可以随意命名。
“三妹，理解了吧？”我问三妹。
“是的，很简单，换句话说，不想让别人看的就 private，想让人看的就 public，想同一个班级&#x2F;部门看的就默认，想让下一级看的就 protected，对吧？哥”三妹很自信地回答。
“不错不错，总结得有那味了。”
3.9 Java代码初始化块“哥，今天我们要学习的内容是‘代码初始化块’，对吧？”看来三妹已经提前预习了我上次留给她的作业。
“是的，三妹。代码初始化块用于初始化一些成员变量。 ”我面带着朴实无华的微笑回答着她，“对象在创建的时候会执行代码初始化块，又称实例初始化块，主要和静态初始化块做区分。”
“可以直接通过‘&#x3D;’操作符对成员变量进行初始化，但通过代码初始化块可以做更多的事情，比如说打印出成员变量初始化后的值。”
“三妹，来看下面的代码，我们可以直接通过 &#x3D; 操作符对成员变量进行初始化。”
123class Bike{      int speed&#x3D;100;  } 
“哥，那为什么还需要代码初始化块呢？”三妹眨了眨眼睛，不解地问。
“我们可以通过代码初始化块执行一个更复杂的操作，比如为集合填充值。来看下面这段代码。”
123456789101112public class Bike {    List&lt;String&gt; list;    {        list &#x3D; new ArrayList&lt;&gt;();        list.add(&quot;沉默&quot;);        list.add(&quot;沉默&quot;);    }        public static void main(String[] args) {        System.out.println(new Bike().list);    }}
“如果只使用‘&#x3D;’操作符的话，是没办法完成集合初始化的，对吧？‘&#x3D;’ 后面只能 new 出集合，却没办法填充值，代码初始化就可以完成这项工作。”
“构造方法执行得早还是代码初始化块啊，哥？”三妹这个问题问的还是挺有水平的。
“不要着急，三妹，先来看下面这个例子。”
12345678910111213public class Car {    Car() {        System.out.println(&quot;构造方法&quot;);    }        {        System.out.println(&quot;代码初始化块&quot;);    }        public static void main(String[] args) {        new Car();    }}
“我们来看一下程序的输出结果就一下子明白了。”
12代码初始化块构造方法
“从输出结果看上去，仿佛代码初始化块执行得更早，对吧？事实上是这样子吗？”我露出神秘的微笑，问三妹。
“难道我看到的是假象吗？”三妹睁大了眼睛。
“不是的，对象在初始化的时候会先调用构造方法，这是毫无疑问的，只不过，构造方法在执行的时候会把代码初始化块放在构造方法中其他代码之前，所以，先看到了‘代码初始化块’，后看到了‘’构造方法’。”
说完这句话，我打开 draw.io，使上了吃奶的劲，画出了下面这幅图。

“哦，原来如此啊！”三妹仿佛发现了新大陆，意味深长地说，“编译器把代码初始化块放到了构造方法中，怪不得。”
等三妹明白彻底搞明白后，我对她继续说道：“对于代码初始化来说，它有三个规则。”

类实例化的时候执行代码初始化块；
实际上，代码初始化块是放在构造方法中执行的，只不过比较靠前；
代码初始化块里的执行顺序是从前到后的。

“这些规则不用死记硬背，大致了解一下就行了。我们继续来看下面这段代码。”话音刚落，我就在新版的IDEA 中噼里啪啦地敲了起来，新版真香。
123456789101112131415161718class A {    A () {        System.out.println(&quot;父类构造方法&quot;);    }}public class B extends A{    B() {        System.out.println(&quot;子类构造方法&quot;);    }        {        System.out.println(&quot;代码初始化块&quot;);    }        public static void main(String[] args) {        new B();    }}
“来看一下输出结果。”
123父类构造方法代码初始化块子类构造方法
“在默认情况下，子类的构造方法在执行的时候会主动去调用父类的构造方法。也就是说，其实是构造方法先执行的，再执行的代码初始化块。”
“这个例子再次印证了之前的第二条规则：代码初始化块是放在构造方法中执行的，只不过比较靠前。”
除了这种实例化代码初始化块，还有静态初始化，不过我们会放到 static 关键字中去讲，这里先大致了解一下。
下面是一个 Java 示例代码，演示实例初始化块和静态初始化块的用法：
123456789101112131415161718192021222324252627282930313233public class Example {    &#x2F;&#x2F; 静态变量    public static int staticVar &#x3D; 1;    &#x2F;&#x2F; 实例变量    public int instanceVar &#x3D; 2;        &#x2F;&#x2F; 静态初始化块    static {        System.out.println(&quot;执行静态初始化块&quot;);        staticVar &#x3D; 3;    }        &#x2F;&#x2F; 实例初始化块    {        System.out.println(&quot;执行实例初始化块&quot;);        instanceVar &#x3D; 4;    }        &#x2F;&#x2F; 构造方法    public Example() {        System.out.println(&quot;执行构造方法&quot;);    }        public static void main(String[] args) {        System.out.println(&quot;执行main方法&quot;);        Example e1 &#x3D; new Example();        Example e2 &#x3D; new Example();        System.out.println(&quot;e1的静态变量：&quot; + e1.staticVar);        System.out.println(&quot;e1的实例变量：&quot; + e1.instanceVar);        System.out.println(&quot;e2的静态变量：&quot; + e2.staticVar);        System.out.println(&quot;e2的实例变量：&quot; + e2.instanceVar);    }}
在这个示例代码中，有一个静态变量 staticVar 和一个实例变量 instanceVar，以及一个静态初始化块和一个实例初始化块。在静态初始化块中，我们打印了一条消息并修改了静态变量的值；在实例初始化块中，我们也打印了一条消息并修改了实例变量的值。
来看一下执行结果：
12345678910执行静态初始化块执行main方法执行实例初始化块执行构造方法执行实例初始化块执行构造方法e1的静态变量：3e1的实例变量：4e2的静态变量：3e2的实例变量：4
从输出结果可以看出，静态初始化块在类加载时执行，只会执行一次，并且优先于实例初始化块和构造方法的执行；实例初始化块在每次创建对象时执行，在构造方法之前执行。
“好了，今天就先讲到这吧，中午休息一下，下午的精神会更足。”刚对三妹说完这句话，我的哈欠就上来了，好困。
3.10 Java抽象类“二哥，你这明显加快了更新的频率呀！”三妹对于我最近的肝劲由衷的佩服了起来。
“哈哈，是呀，我要给广大的学弟学妹们一个完整的 Java 学习体系，记住我们的口号，学 Java 就上二哥的Java 进阶之路。”我对未来充满了信心。
“那就开始吧。”三妹说。
01、定义抽象类
定义抽象类的时候需要用到关键字 abstract ，放在 class 关键字前，就像下面这样。
12abstract class AbstractPlayer {}
关于抽象类的命名，《阿里的 Java 开发手册》上有强调，“抽象类命名要使用 Abstract 或 Base 开头”，这条规约还是值得遵守的，真正做到名如其意。
02、抽象类的特征
抽象类是不能实例化的，尝试通过 new 关键字实例化的话，编译器会报错，提示“类是抽象的，不能实例化”。

虽然抽象类不能实例化，但可以有子类。子类通过 extends 关键字来继承抽象类。就像下面这样。
12public class BasketballPlayer extends AbstractPlayer {}
如果一个类定义了一个或多个抽象方法，那么这个类必须是抽象类。
当我们尝试在一个普通类中定义抽象方法的时候，编译器会有两处错误提示。第一处在类级别上，提示“这个类必须通过 abstract 关键字定义”，见下图。

第二处在尝试定义 abstract 的方法上，提示“抽象方法所在的类不是抽象的”，见下图。

抽象类中既可以定义抽象方法，也可以定义普通方法，就像下面这样：
1234567public abstract class AbstractPlayer {    abstract void play();        public void sleep() {        System.out.println(&quot;运动员也要休息而不是挑战极限&quot;);    }}
抽象类派生的子类必须实现父类中定义的抽象方法。比如说，抽象类 AbstractPlayer 中定义了 play() 方法，子类 BasketballPlayer 中就必须实现。
123456public class BasketballPlayer extends AbstractPlayer {    @Override    void play() {        System.out.println(&quot;我是张伯伦，篮球场上得过 100 分&quot;);    }}
如果没有实现的话，编译器会提示“子类必须实现抽象方法”，见下图。

03、抽象类的应用场景
“二哥，抽象方法我明白了，那什么时候使用抽象方法呢？能给我讲讲它的应用场景吗？”三妹及时的插话道。
“这问题问的恰到好处呀！”我扶了扶眼镜继续说。
01）第一种场景
当我们希望一些通用的功能被多个子类复用的时候，就可以使用抽象类。比如说，AbstractPlayer 抽象类中有一个普通的方法 sleep() ，表明所有运动员都需要休息，那么这个方法就可以被子类复用。
12345abstract class AbstractPlayer {    public void sleep() {        System.out.println(&quot;运动员也要休息而不是挑战极限&quot;);    }}
子类 BasketballPlayer 继承了 AbstractPlayer 类：
12class BasketballPlayer extends AbstractPlayer {}
也就拥有了 sleep() 方法。BasketballPlayer 的对象可以直接调用父类的 sleep() 方法：
12BasketballPlayer basketballPlayer &#x3D; new BasketballPlayer();basketballPlayer.sleep();
子类 FootballPlayer 继承了 AbstractPlayer 类：
12class FootballPlayer extends AbstractPlayer {}
也拥有了 sleep() 方法，FootballPlayer 的对象也可以直接调用父类的 sleep() 方法：
12FootballPlayer footballPlayer &#x3D; new FootballPlayer();footballPlayer.sleep();
这样是不是就实现了代码的复用呢？
02）第二种场景
当我们需要在抽象类中定义好 API，然后在子类中扩展实现的时候就可以使用抽象类。比如说，AbstractPlayer 抽象类中定义了一个抽象方法 play() ，表明所有运动员都可以从事某项运动，但需要对应子类去扩展实现，表明篮球运动员打篮球，足球运动员踢足球。
123abstract class AbstractPlayer {    abstract void play();}
BasketballPlayer 继承了 AbstractPlayer 类，扩展实现了自己的 play() 方法。
123456public class BasketballPlayer extends AbstractPlayer {    @Override    void play() {        System.out.println(&quot;我是张伯伦，我篮球场上得过 100 分，&quot;);    }}
FootballPlayer 继承了 AbstractPlayer 类，扩展实现了自己的 play() 方法。
123456public class FootballPlayer extends AbstractPlayer {    @Override    void play() {        System.out.println(&quot;我是C罗，我能接住任意高度的头球&quot;);    }}
为了进一步展示抽象类的特性，我们再来看一个具体的示例。

PS：网站评论区说涉及到了文件的读写以及 Java 8 的新特性，不适合新人，如果觉得自己实在是看不懂，跳过，等学了 IO 流再来看也行。如果说是为了复习 Java 基础知识，就不存在这个问题了。

假设现在有一个文件，里面的内容非常简单，只有一个“Hello World”，现在需要有一个读取器将内容从文件中读取出来，最好能按照大写的方式，或者小写的方式来读。
这时候，最好定义一个抽象类 BaseFileReader：
1234567891011121314151617181920212223242526272829303132&#x2F;** * 抽象类，定义了一个读取文件的基础框架，其中 mapFileLine 是一个抽象方法，具体实现需要由子类来完成 *&#x2F;abstract class BaseFileReader {    protected Path filePath; &#x2F;&#x2F; 定义一个 protected 的 Path 对象，表示读取的文件路径        &#x2F;**     * 构造方法，传入读取的文件路径     * @param filePath 读取的文件路径     *&#x2F;    protected BaseFileReader(Path filePath) {        this.filePath &#x3D; filePath;    }        &#x2F;**     * 读取文件的方法，返回一个字符串列表     * @return 字符串列表，表示文件的内容     * @throws IOException 如果文件读取出错，抛出该异常     *&#x2F;    public List&lt;String&gt; readFile() throws IOException {        return Files.lines(filePath) &#x2F;&#x2F; 使用 Files 类的 lines 方法，读取文件的每一行                .map(this::mapFileLine) &#x2F;&#x2F; 对每一行应用 mapFileLine 方法，将其转化为指定的格式                .collect(Collectors.toList()); &#x2F;&#x2F; 将处理后的每一行收集到一个字符串列表中，返回    }        &#x2F;**     * 抽象方法，子类需要实现该方法，将文件中的每一行转化为指定的格式     * @param line 文件中的每一行     * @return 转化后的字符串     *&#x2F;    protected abstract String mapFileLine(String line);}

filePath 为文件路径，使用 protected 修饰，表明该成员变量可以在需要时被子类访问到。
readFile() 方法用来读取文件，方法体里面调用了抽象方法 mapFileLine() ——需要子类来扩展实现大小写的不同读取方式。

在我看来，BaseFileReader 类设计的就非常合理，并且易于扩展，子类只需要专注于具体的大小写实现方式就可以了。
小写的方式：
123456789class LowercaseFileReader extends BaseFileReader {    protected LowercaseFileReader(Path filePath) {        super(filePath);    }    @Override    protected String mapFileLine(String line) {        return line.toLowerCase();    }}
大写的方式：
123456789class UppercaseFileReader extends BaseFileReader {    protected UppercaseFileReader(Path filePath) {        super(filePath);    }    @Override    protected String mapFileLine(String line) {        return line.toUpperCase();    }}
从文件里面一行一行读取内容的代码被子类复用了。与此同时，子类只需要专注于自己该做的工作，LowercaseFileReader 以小写的方式读取文件内容，UppercaseFileReader 以大写的方式读取文件内容。
来看一下测试类 FileReaderTest：
1234567891011public class FileReaderTest {    public static void main(String[] args) throws URISyntaxException, IOException {        URL location &#x3D; FileReaderTest.class.getClassLoader().getResource(&quot;helloworld.txt&quot;);        Path path &#x3D; Paths.get(location.toURI());        BaseFileReader lowercaseFileReader &#x3D; new LowercaseFileReader(path);        BaseFileReader uppercaseFileReader &#x3D; new UppercaseFileReader(path);        System.out.println(lowercaseFileReader.readFile());        System.out.println(uppercaseFileReader.readFile());    }}
在项目的 resource 目录下建一个文本文件，名字叫 helloworld.txt，里面的内容就是“Hello World”。文件的具体位置如下图所示，我用的集成开发环境是 Intellij IDEA。

在 resource 目录下的文件可以通过 ClassLoader.getResource() 的方式获取到 URI 路径，然后就可以取到文本内容了。
输出结果如下所示：
12[hello world][HELLO WORLD]
04、抽象类总结
好了，对于抽象类我们简单总结一下：

抽象类不能被实例化。
抽象类应该至少有一个抽象方法，否则它没有任何意义。
抽象类中的抽象方法没有方法体。
抽象类的子类必须给出父类中的抽象方法的具体实现，除非该子类也是抽象类。

“完了吗？二哥”三妹似乎还沉浸在聆听教诲的快乐中。
“是滴，这次我们系统化的学习了抽象类，可以说面面俱到了。三妹你可以把代码敲一遍，加强了一些印象，电脑交给你了。”
3.11 Java接口“今天开始讲 Java 的接口。”我对三妹说，“对于面向对象编程来说，抽象是一个极具魅力的特征。如果一个程序员的抽象思维很差，那他在编程中就会遇到很多困难，无法把业务变成具体的代码。在 Java 中，可以通过两种形式来达到抽象的目的，一种上一篇的主角——抽象类，另外一种就是今天的主角——接口。”
“是呀是呀，让我们开始吧！”
01、定义接口
“接口是什么呀？”三妹顺着我的话题及时的插话到。
接口通过 interface 关键字来定义，它可以包含一些常量和方法，来看下面这个示例。
1234567891011121314public interface Electronic {    &#x2F;&#x2F; 常量    String LED &#x3D; &quot;LED&quot;;    &#x2F;&#x2F; 抽象方法    int getElectricityUse();    &#x2F;&#x2F; 静态方法    static boolean isEnergyEfficient(String electtronicType) {        return electtronicType.equals(LED);    }    &#x2F;&#x2F; 默认方法    default void printDescription() {        System.out.println(&quot;电子&quot;);    }}
来看一下这段代码反编译后的字节码。
12345678910111213public interface Electronic{    public abstract int getElectricityUse();    public static boolean isEnergyEfficient(String electtronicType)    {        return electtronicType.equals(&quot;LED&quot;);    }    public void printDescription()    {        System.out.println(&quot;\u7535\u5B50&quot;);    }    public static final String LED &#x3D; &quot;LED&quot;;}
发现没？接口中定义的所有变量或者方法，都会自动添加上 public 关键字。
接下来，我来一一解释下 Electronic 接口中的核心知识点。
1）接口中定义的变量会在编译的时候自动加上 public static final修饰符（注意看一下反编译后的字节码），也就是说上例中的 LED 变量其实就是一个常量。
Java 官方文档上有这样的声明：

Every field declaration in the body of an interface is implicitly public, static, and final.

换句话说，接口可以用来作为常量类使用，还能省略掉 public static final ，看似不错的一种选择，对吧？
不过，这种选择并不可取。因为接口的本意是对方法进行抽象，而常量接口会对子类中的变量造成命名空间上的“污染”。
2）没有使用 private、 default或者 static关键字修饰的方法是隐式抽象的，在编译的时候会自动加上 public abstract 修饰符。也就是说上例中的 getElectricityUse() 其实是一个抽象方法，没有方法体——这是定义接口的本意。
3）从 Java 8 开始，接口中允许有静态方法，比如说上例中的 isEnergyEfficient() 方法。
静态方法无法由（实现了该接口的）类的对象调用，它只能通过接口名来调用，比如说Electronic.isEnergyEfficient(“LED”) 。
接口中定义静态方法的目的是为了提供一种简单的机制，使我们不必创建对象就能调用方法，从而提高接口的竞争力。
4）接口中允许定义 方法也是从 Java 8 开始的，比如说上例中的 printDescription() 方法，它始终由一个代码块组成，为实现该接口而不覆盖该方法的类提供默认实现。既然要提供默认实现，就要有方法体，换句话说，默认方法后面不能直接使用“;”号来结束——编译器会报错。

“为什么要在接口中定义默认方法呢？”三妹好奇地问到。
允许在接口中定义默认方法的理由很充分，因为一个接口可能有多个实现类，这些类就必须实现接口中定义的抽象类，否则编译器就会报错。假如我们需要在所有的实现类中追加某个具体的方法，在没有 default方法的帮助下，我们就必须挨个对实现类进行修改。
由之前的例子我们就可以得出下面这些结论：

接口中允许定义变量
接口中允许定义抽象方法
接口中允许定义静态方法（Java 8 之后）
接口中允许定义默认方法（Java 8 之后）

除此之外，我们还应该知道：
1）接口不允许直接实例化，否则编译器会报错。

需要定义一个类去实现接口，见下例。
12345678910public class Computer implements Electronic {    public static void main(String[] args) {        new Computer();    }        @Override    public int getElectricityUse() {        return 0;    }}
然后再实例化。
1Electronic e &#x3D; new Computer();
2）接口可以是空的，既可以不定义变量，也可以不定义方法。最典型的例子就是 Serializable 接口，在java.io 包下。
12public interface Serializable {}
Serializable 接口用来为序列化的具体实现提供一个标记，也就是说，只要某个类实现了 Serializable 接口，那么它就可以用来序列化了。
3）不要在定义接口的时候使用 final 关键字，否则会报编译错误，因为接口就是为了让子类实现的，而final 阻止了这种行为。

4）接口的抽象方法不能是 private、protected 或者 final，否则编译器都会报错。

5）接口的变量是隐式 public static final（常量），所以其值无法改变。
02、接口的作用
“接口可以做什么呢？”三妹见缝插针，问的很及时。
第一，使某些实现类具有我们想要的功能，比如说，实现了 Cloneable 接口的类具有拷贝的功能，实现了Comparable 或者 Comparator 的类具有比较功能。
Cloneable 和 Serializable 一样，都属于标记型接口，它们内部都是空的。实现了 Cloneable 接口的类可以使用 Object.clone() 方法，否则会抛出 CloneNotSupportedException。
12345678910public class CloneableTest implements Cloneable {    @Override    protected Object clone() throws CloneNotSupportedException {        return super.clone();    }    public static void main(String[] args) throws CloneNotSupportedException {        CloneableTest c1 &#x3D; new CloneableTest();        CloneableTest c2 &#x3D; (CloneableTest) c1.clone();    }}
运行后没有报错。现在把 implements Cloneable 去掉。
12345678910public class CloneableTest {    @Override    protected Object clone() throws CloneNotSupportedException {        return super.clone();    }    public static void main(String[] args) throws CloneNotSupportedException {        CloneableTest c1 &#x3D; new CloneableTest();        CloneableTest c2 &#x3D; (CloneableTest) c1.clone();    }}
运行后抛出 CloneNotSupportedException：
12345Exception in thread &quot;main&quot; java.lang.CloneNotSupportedException: com.cmower.baeldung.interface1.CloneableTest    at java.base&#x2F;java.lang.Object.clone(Native Method)    at com.cmower.baeldung.interface1.CloneableTest.clone(CloneableTest.java:6)    at com.cmower.baeldung.interface1.CloneableTest.main(CloneableTest.java:11)
第二，Java 原则上只支持单一继承，但通过接口可以实现多重继承的目的。
如果有两个类共同继承（extends）一个父类，那么父类的方法就会被两个子类重写。然后，如果有一个新类同时继承了这两个子类，那么在调用重写方法的时候，编译器就不能识别要调用哪个类的方法了。这也正是著名的菱形问题，见下图。

简单解释下，ClassC 同时继承了 ClassA 和 ClassB，ClassC 的对象在调用 ClassA 和 ClassB 中重写的方法时，就不知道该调用 ClassA 的方法，还是 ClassB 的方法。
接口没有这方面的困܃。来定义两个接口，Fly 接口会飞，Run 接口会跑。
1234567public interface Fly {    void fly();}public interface Run {    void run();}
然后让 Pig 类同时实现这两个接口。
1234567891011public class Pig implements Fly,Run{    @Override    public void fly() {        System.out.println(&quot;会飞的猪&quot;);    }        @Override    public void run() {        System.out.println(&quot;会跑的猪&quot;);    }}
在某种形式上，接口实现了多重继承的目的：现实世界里，猪的确只会跑，但在雷军的眼里，站在风口的猪就会飞，这就需要赋予这只猪更多的能力，通过抽象类是无法实现的，只能通过接口。
第三，实现多态。
什么是多态呢？通俗的理解，就是同一个事件发生在不同的对象上会产生不同的结果，鼠标左键点击窗口上的 X 号可以关闭窗口，点击超链接却可以打开新的网页。
多态可以通过继承（ extends ）的关系实现，也可以通过接口的形式实现。
Shape 接口表示一个形状。
123public interface Shape {    String name();}
Circle 类实现了 Shape 接口，并重写了 name() 方法。
123456public class Circle implements Shape {    @Override    public String name() {        return &quot;圆&quot;;    }}
Square 类也实现了 Shape 接口，并重写了 name() 方法。
123456public class Square implements Shape {    @Override    public String name() {        return &quot;正方形&quot;;    }}
然后来看测试类。
12345678List&lt;Shape&gt; shapes &#x3D; new ArrayList&lt;&gt;();Shape circleShape &#x3D; new Circle();Shape squareShape &#x3D; new Square();shapes.add(circleShape);shapes.add(squareShape);for (Shape shape : shapes) {    System.out.println(shape.name());}
这就实现了多态，变量 circleShape、squareShape 的引用类型都是 Shape，但执行 shape.name() 方法的时候，Java 虚拟机知道该去调用 Circle 的 name() 方法还是 Square 的 name() 方法。
说一下多态存在的 3 个前提：

要有继承关系，比如说 Circle 和 Square 都实现了 Shape 接口。
子类要重写父类的方法，Circle 和 Square 都重写了 name() 方法。
父类引用指向子类对象，circleShape 和 squareShape 的类型都为 Shape，但前者指向的是 Circle对象，后者指向的是 Square 对象。

然后，我们来看一下测试结果：
12圆正方形
也就意味着，尽管在 for 循环中，shape 的类型都为 Shape，但在调用 name() 方法的时候，它知道 Circle对象应该调用 Circle 类的 name() 方法，Square 对象应该调用 Square 类的 name() 方法。
03、接口的三种模式
在编程领域，好的设计模式能够让我们的代码事半功倍。在使用接口的时候，经常会用到三种模式，分别是策略模式、适配器模式和工厂模式。
1）策略模式
策略模式的思想是，针对一组算法，将每一种算法封装到具有共同接口的实现类中，接口的设计者可以在不影响调用者的情况下对算法做出改变。示例如下：
12345678910111213141516171819202122232425262728293031323334&#x2F;&#x2F; 接口：教练interface Coach {    &#x2F;&#x2F; 方法：防守    void defend();}&#x2F;&#x2F; 何塞·穆里尼奥class Hesai implements Coach {    @Override    public void defend() {        System.out.println(&quot;防守赢得冠军&quot;);    }}&#x2F;&#x2F; 德普·瓜迪奥拉class Guatu implements Coach {    @Override    public void defend() {        System.out.println(&quot;进攻就是最好的防守&quot;);    }}public class Demo {    &#x2F;&#x2F; 参数为接口    public static void defend(Coach coach) {        coach.defend();    }        public static void main(String[] args) {        &#x2F;&#x2F; 为同一个方法传递不同的对象        defend(new Hesai());        defend(new Guatu());    }}
Demo.defend() 方法可以接受不同风格的 Coach，并根据所传递的参数对象的不同而产生不同的行为，这被称为“策略模式”。
2）适配器模式
适配器模式的思想是，针对调用者的需求对原有的接口进行转接。生活当中最常见的适配器就是HDMI（英语： High Definition Multimedia Interface ，中文：高清多媒体接口）线，可以同时发送音频和视频信号。适配器模式的示例如下：
123456789101112131415161718192021222324interface Coach {    void defend();    void attack();}&#x2F;&#x2F; 抽象类实现接口，并置空方法abstract class AdapterCoach implements Coach {    public void defend() {};    public void attack() {};}&#x2F;&#x2F; 新类继承适配器class Hesai extends AdapterCoach {    public void defend() {        System.out.println(&quot;防守赢得冠军&quot;);    }}public class Demo {    public static void main(String[] args) {        Coach coach &#x3D; new Hesai();        coach.defend();    }}
Coach 接口中定义了两个方法（ defend() 和 attack() ），如果类直接实现该接口的话，就需要对两个方法进行实现。
如果我们只需要对其中一个方法进行实现的话，就可以使用一个抽象类作为中间件，即适配器（AdapterCoach），用这个抽象类实现接口，并对抽象类中的方法置空（方法体只有一对花括号），这时候，新类就可以绕过接口，继承抽象类，我们就可以只对需要的方法进行覆盖，而不是接口中的所有方法。
3）工厂模式
所谓的工厂模式理解起来也不难，就是什么工厂生产什么，比如说宝马工厂生产宝马，奔驰工厂生产奔驰，A 级学院毕业 A 级教练，C 级学院毕业 C 级教练。示例如下：
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&#x2F;&#x2F; 教练interface Coach {    void command();}&#x2F;&#x2F; 教练学院interface CoachFactory {    Coach createCoach();}&#x2F;&#x2F; A级教练class ACoach implements Coach {    @Override    public void command() {        System.out.println(&quot;我是A级证书教练&quot;);    }    }&#x2F;&#x2F; A级教练学院class ACoachFactory implements CoachFactory {    @Override    public Coach createCoach() {        return new ACoach();    }    }&#x2F;&#x2F; C级教练class CCoach implements Coach {    @Override    public void command() {        System.out.println(&quot;我是C级证书教练&quot;);    }    }&#x2F;&#x2F; C级教练学院class CCoachFactory implements CoachFactory {    @Override    public Coach createCoach() {        return new CCoach();    }}public class Demo {    public static void create(CoachFactory factory) {        factory.createCoach().command();    }        public static void main(String[] args) {        &#x2F;&#x2F; 对于一支球队来说，需要什么样的教练就去找什么样的学院        &#x2F;&#x2F; 学院会介绍球队对应水平的教练。        create(new ACoachFactory());        create(new CCoachFactory());    }}
有两个接口，一个是 Coach（教练），可以 command() （指挥球队）；另外一个是 CoachFactory（教练学院），能 createCoach() （教出一名优秀的教练）。然后 ACoach 类实现 Coach 接口，ACoachFactory 类实现 CoachFactory 接口；CCoach 类实现 Coach 接口，CCoachFactory 类实现 CoachFactory 接口。当需要 A 级教练时，就去找 A 级教练学院；当需要 C 级教练时，就去找 C 级教练学院。
依次类推，我们还可以用 BCoach 类实现 Coach 接口，BCoachFactory 类实现 CoachFactory 接口，从而不断地丰富教练的梯队。
“怎么样三妹，一下子接收这么多知识点不容易吧？”
“其实还好啊，二哥你讲的这么细致，我都做好笔记 了，学习嘛，认真一点，效果就会好很多了。”
三妹这种积极乐观的态度真的让我感觉到“付出就会有收获。
04、抽象类和接口的区别
简单总结一下抽象类和接口的区别。
在 Java 中，通过关键字 abstract 定义的类叫做抽象类。Java 是一门面向对象的语言，因此所有的对象都是通过类来描述的；但反过来，并不是所有的类都是用来描述对象的，抽象类就是其中的一种。
以下示例展示了一个简单的抽象类：
12345&#x2F;&#x2F; 个人认为，一名教练必须攻守兼备abstract class Coach {    public abstract void defend();    public abstract void attack();}
我们知道，有抽象方法的类被称为抽象类，也就意味着抽象类中还能有不是抽象方法的方法。这样的类就不能算作纯粹的接口，尽管它也可以提供接口的功能——只能说抽象类是普通类与接口之间的一种中庸之道。
接口（英文：Interface），在 Java 中是一个抽象类型，是抽象方法的集合；接口通过关键字 interface来定义。接口与抽象类的不同之处在于：

抽象类可以有方法体的方法，但接口没有（Java 8 以前）。
接口中的成员变量隐式为 static final ，但抽象类不是的。
一个类可以实现多个接口，但只能继承一个抽象类。

以下示例展示了一个简单的接口：
123456&#x2F;&#x2F; 隐式的abstractinterface Coach {    &#x2F;&#x2F; 隐式的public    void defend();    void attack();}

接口是隐式抽象的，所以声明时没有必要使用 abstract 关键字；
接口的每个方法都是隐式抽象的，所以同样不需要使用 abstract 关键字；
接口中的方法都是隐式 public 的。

“哦，我理解了哥。那我再问一下，抽象类和接口有什么差别呢？”
“哇，三妹呀，你这个问题恰到好处，问到了点子上。”我不由得为三妹竖起了大拇指。
1）语法层面上

抽象类可以提供成员方法的实现细节，而接口中只能存在 public abstract 方法；
抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的；
接口中不能含有静态代码块，而抽象类可以有静态代码块；
一个类只能继承一个抽象类，而一个类却可以实现多个接口。

2）设计层面上
抽象类是对一种事物的抽象，即对类抽象，继承抽象类的子类和抽象类本身是一种 is-a 的关系。而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。
举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类 Airplane，将鸟设计为一个类 Bird，但是不能将 飞行 这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。
此时可以将 飞行 设计为一个接口 Fly，包含方法 fly()，然后 Airplane 和 Bird 分别根据自己的需要实现 Fly这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承 Airplane 即可，对于鸟也是类似的，不同种类的鸟直接继承 Bird 类即可。从这里可以看出，继承是一个 “是不是”的关系，而 接口 实现则是”有没有”的关系。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。
接口是对类的某种行为的一种抽象，接口和类之间并没有很强的关联关系，举个例子来说，所有的类都可以实现 Serializable 接口，从而具有序列化的功能，但不能说所有的类和 Serializable 之间是 is-a 的关系。
抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。什么是模板式设计？最简单例子，大家都用过 ppt 里面的模板，如果用模板 A 设计了 ppt B 和 ppt C，ppt B 和ppt C 公共的部分就是模板 A 了，如果它们的公共部分需要改动，则只需要改动模板 A 就可以了，不需要重新对 ppt B 和 ppt C 进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。
3.12 Java内部类“在 Java 中，可以将一个类定义在另外一个类里面或者一个方法里面，这样的类叫做内部类。”我放下手中的枸杞杯，对三妹说，“一般来说，内部类分为成员内部类、局部内部类、匿名内部类和静态内部类。”
1）成员内部类
成员内部类是最常见的内部类，看下面的代码：
1234567class Wanger {    int age &#x3D; 18;        class Wangxiaoer {        int age &#x3D; 81;    }}
看起来内部类 Wangxiaoer 就好像 Wanger 的一个成员，成员内部类可以无限制访问外部类的所有成员属性。
1234567891011121314public class Wanger {    int age &#x3D; 18;    private String name &#x3D; &quot;沉默&quot;;    static double money &#x3D; 1;        class Wangxiaoer {        int age &#x3D; 81;                public void print() {            System.out.println(name);            System.out.println(money);        }    }}
内部类可以随心所欲地访问外部类的成员，但外部类想要访问内部类的成员，就不那么容易了，必须先创建一个成员内部类的对象，再通过这个对象来访问：
1234567891011121314151617public class Wanger {    int age &#x3D; 18;    private String name &#x3D; &quot;沉默&quot;;    static double money &#x3D; 1;        public Wanger () {        new Wangxiaoer().print();    }        class Wangxiaoer {        int age &#x3D; 81;        public void print() {            System.out.println(name);            System.out.println(money);        }    }}
这也就意味着，如果想要在静态方法中访问成员内部类的时候，就必须先得创建一个外部类的对象，因为内部类是依附于外部类的。
123456789101112131415161718192021222324public class Wanger {    int age &#x3D; 18;    private String name &#x3D; &quot;沉默&quot;;    static double money &#x3D; 1;        public Wanger () {        new Wangxiaoer().print();    }        public static void main(String[] args) {        Wanger wanger &#x3D; new Wanger();        Wangxiaoer xiaoer &#x3D; wanger.new Wangxiaoer();        xiaoer.print();    }        class Wangxiaoer {        int age &#x3D; 81;                public void print() {            System.out.println(name);            System.out.println(money);        }    }}
这种创建内部类的方式在实际开发中并不常用，因为内部类和外部类紧紧地绑定在一起，使用起来非常不便。
2）局部内部类
局部内部类是定义在一个方法或者一个作用域里面的类，所以局部内部类的生命周期仅限于作用域内。
12345678public class Wangsan {    public Wangsan print() {        class Wangxiaosan extends Wangsan{            private int age &#x3D; 18;        }        return new Wangxiaosan();    }}
局部内部类就好像一个局部变量一样，它是不能被权限修饰符修饰的，比如说 public、protected、private和 static 等。

3）匿名内部类
匿名内部类是我们平常用得最多的，尤其是启动多线程的时候，会经常用到，并且 IDE 也会帮我们自动生成。
1234567891011public class ThreadDemo {    public static void main(String[] args) {        Thread t &#x3D; new Thread(new Runnable() {            @Override            public void run() {                System.out.println(Thread.currentThread().getName());            }        });        t.start();    }}
匿名内部类就好像一个方法的参数一样，用完就没了，以至于我们都不需要为它专门写一个构造方法，它的名字也是由系统自动命名的。仔细观察编译后的字节码文件也可以发现，匿名内部类连名字都不配拥有，哈哈，直接借用的外部类，然后 $1 就搞定了。

匿名内部类是唯一一种没有构造方法的类。就上面的写法来说，匿名内部类也不允许我们为其编写构造方法，因为它就像是直接通过 new 关键字创建出来的一个对象。
匿名内部类的作用主要是用来继承其他类或者实现接口，并不需要增加额外的方法，方便对继承的方法进行实现或者重写。
4）静态内部类
静态内部类和成员内部类类似，只是多了一个 static 关键字。
12345678910public class Wangsi {    static int age;    double money;        static class Wangxxiaosi {        public Wangxxiaosi (){            System.out.println(age);        }    }}
由于 static 关键字的存在，静态内部类是不允许访问外部类中非 static 的变量和方法的，这一点也非常好理解：你一个静态的内部类访问我非静态的成员变量干嘛？

“为什么要使用内部类呢？”三妹问。
三妹这个问题问的非常妙，是时候引经据典了。
在《Think in java》中有这样一句话：

使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。

在我们程序设计中有时候会存在一些使用接口很难解决的问题，这个时候我们可以利用内部类提供的、可以继承多个具体的或者抽象的类的能力来解决这些程序设计问题。可以这样说，接口只是解决了部分问题，而内部类使得多重继承的解决方案变得更加完整。
使用内部类还能够为我们带来如下特性：

内部类可以使用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。
在单个外部类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。
创建内部类对象的时刻并不依赖于外部类对象的创建。
内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。
内部类提供了更好的封装，除了该外围类，其他类都不能访问。

3.13 Java封装继承多态在谈 Java 面向对象的时候，不得不提到面向对象的三大特征：封装、继承、多态。三大特征紧密联系而又有区别，合理使用继承能大大减少重复代码，提高代码复用性。
**1）封装
“三妹，准备好了没，我们来讲 Java 封装，算是 Java 的三大特征之一，理清楚了，对以后的编程有较大的帮助。”我对三妹说。
“好的，哥，准备好了。”三妹一边听我说，一边迅速地打开了 XMind，看来一边学习一边总结思维导图这个高效的学习方式三妹已经牢记在心了。
封装从字面上来理解就是包装的意思，专业点就是信息隐藏，是指利用抽象将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。
数据被保护在类的内部，尽可能地隐藏内部的实现细节，只保留一些对外接口使之与外部发生联系。
其他对象只能通过已经授权的操作来与这个封装的对象进行交互。也就是说用户是无需知道对象内部的细节（当然也无从知道），但可以通过该对象对外的提供的接口来访问该对象。
使用封装有 4 大好处：

良好的封装能够减少耦合。
类内部的结构可以自由修改。
可以对成员进行更精确的控制。
隐藏信息，实现细节。

首先我们先来看两个类。
Husband.java
123456789101112131415161718192021222324252627282930313233343536373839404142public class Husband {        &#x2F;*     * 对属性的封装     * 一个人的姓名、性别、年龄、妻子都是这个人的私有属性     *&#x2F;    private String name ;    private String sex ;    private int age ;    private Wife wife;        &#x2F;*     * setter()、getter()是该对象对外开发的接口     *&#x2F;    public String getName() {        return name;    }        public void setName(String name) {        this.name &#x3D; name;    }        public String getSex() {        return sex;    }     public void setSex(String sex) {        this.sex &#x3D; sex;    }        public int getAge() {        return age;    }        public void setAge(int age) {        this.age &#x3D; age;    }        public void setWife(Wife wife) {        this.wife &#x3D; wife;    }}
Wife.java
12345678910111213141516171819202122232425262728293031323334public class Wife {    private String name;    private int age;    private String sex;    private Husband husband;        public String getName() {        return name;    }        public void setName(String name) {        this.name &#x3D; name;    }        public String getSex() {        return sex;    }        public void setSex(String sex) {        this.sex &#x3D; sex;    }        public void setAge(int age) {        this.age &#x3D; age;    }        public void setHusband(Husband husband) {        this.husband &#x3D; husband;    }        public Husband getHusband() {        return husband;    }}
可以看得出， Husband 类里面的 wife 属性是没有 getter() 的，同时 Wife 类的 age 属性也是没有getter() 方法的。至于理由我想三妹你是懂的。
没有哪个女人愿意别人知道她的年龄。
所以封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果不想被外界方法，我们大可不必提供方法给外界访问。
但是如果一个类没有提供给外界任何可以访问的方法，那么这个类也没有什么意义了。
比如我们将一个房子看做是一个对象，里面有漂亮的装饰，如沙发、电视剧、空调、茶桌等等都是该房子的私有属性，但是如果我们没有那些墙遮挡，是不是别人就会一览无余呢？没有一点儿隐私！
因为存在那个遮挡的墙，我们既能够有自己的隐私而且我们可以随意的更改里面的摆设而不会影响到外面的人。
但是如果没有门窗，一个包裹的严严实实的黑盒子，又有什么存在的意义呢？所以通过门窗别人也能够看到里面的风景。所以说门窗就是房子对象留给外界访问的接口。
通过这个我们还不能真正体会封装的好处。现在我们从程序的角度来分析封装带来的好处。如果我们不使用封装，那么该对象就没有 setter() 和 getter() ，那么 Husband 类应该这样写：
123456public class Husband {    public String name ;    public String sex ;    public int age ;    public Wife wife;}
我们应该这样来使用它：
1234Husband husband &#x3D; new Husband();husband.age &#x3D; 30;husband.name &#x3D; &quot;张三&quot;;husband.sex &#x3D; &quot;男&quot;;    &#x2F;&#x2F;貌似有点儿多余
但是哪天如果我们需要修改 Husband，例如将 age 修改为 String 类型的呢？你只有一处使用了这个类还好，如果你有几十个甚至上百个这样地方，你是不是要改到崩溃。如果使用了封装，我们完全可以不需要做任何修改，只需要稍微改变下 Husband 类的 setAge() 方法即可。
1234567891011121314151617181920212223public class Husband {        &#x2F;*     * 对属性的封装     * 一个人的姓名、性别、年龄、妻子都是这个人的私有属性     *&#x2F;    private String name ;    private String sex ;    private String age ;    &#x2F;* 改成 String类型的*&#x2F;    private Wife wife;        public String getAge() {        return age;    }        public void setAge(int age) {        &#x2F;&#x2F;转换即可        this.age &#x3D; String.valueOf(age);    }        &#x2F;** 省略其他属性的setter、getter **&#x2F;    }
其他的地方依然这样引用( husband.setAge(22) )保持不变。
到了这里我们确实可以看出，封装确实可以使我们更容易地修改类的内部实现，而无需修改使用了该类的代码。
我们再看这个好处：封装可以对成员变量进行更精确的控制。
还是那个 Husband，一般来说我们在引用这个对象的时候是不容易出错的，但是有时你迷糊了，写成了这样：
12Husband husband &#x3D; new Husband();husband.age &#x3D; 300;
也许你是因为粗心写成了这样，你发现了还好，如果没有发现那就麻烦大了，谁见过 300 岁的老妖怪啊！但是使用封装我们就可以避免这个问题，我们对 age 的访问入口做一些控制(setter)如：
123456789101112131415161718192021222324252627public class Husband {        &#x2F;*     * 对属性的封装     * 一个人的姓名、性别、年龄、妻子都是这个人的私有属性     *&#x2F;    private String name ;    private String sex ;    private int age ;    &#x2F;* 改成 String类型的*&#x2F;    private Wife wife;        public int getAge() {        return age;    }        public void setAge(int age) {        if(age &gt; 120){            System.out.println(&quot;ERROR：error age input....&quot;);    &#x2F;&#x2F;提示錯誤信息        }else{            this.age &#x3D; age;        }            }        &#x2F;** 省略其他属性的setter、getter **&#x2F;    }
上面都是对 setter 方法的控制，其实通过封装我们也能够对对象的出口做出很好的控制。例如性别在数据库中一般都是以 1、0 的方式来存储的，但是在前台我们又不能展示 1、0，这里我们只需要在 getter() 方法里面做一些转换即可。
12345678public String getSexName() {    if(&quot;0&quot;.equals(sex)){        sexName &#x3D; &quot;女&quot;;    }else if(&quot;1&quot;.equals(sex)){        sexName &#x3D; &quot;男&quot;;    }    return sexName;}
在使用的时候我们只需要使用 sexName 即可实现正确的性别显示。同理也可以用于针对不同的状态做出不同的操作。
“好了，关于封装我们就暂时就聊这么多吧。”我喝了一口普洱茶后，对三妹说。
“好的，哥，我懂了。”
2）继承
01、什么是继承
继承（英语：inheritance）是面向对象软件技术中的一个概念。它使得复用以前的代码非常容易。
Java 语言是非常典型的面向对象的语言，在 Java 语言中继承就是子类继承父类的属性和方法，使得子类对象（实例）具有父类的属性和方法，或子类从父类继承方法，使得子类具有父类相同的方法。
我们来举个例子：动物有很多种，是一个比较大的概念。在动物的种类中，我们熟悉的有猫(Cat)、狗(Dog)等动物，它们都有动物的一般特征（比如能够吃东西，能够发出声音），不过又在细节上有区别（不同动物的吃的不同，叫声不一样）。
在 Java 语言中实现 Cat 和 Dog 等类的时候，就需要继承 Animal 这个类。继承之后 Cat、Dog 等具体动物类就是子类，Animal 类就是父类。

02、为什么需要继承
三妹，你可能会问为什么需要继承？
如果仅仅只有两三个类，每个类的属性和方法很有限的情况下确实没必要实现继承，但事情并非如此，事实上一个系统中往往有很多个类并且有着很多相似之处，比如猫和狗同属动物，或者学生和老师同属人。各个类可能又有很多个相同的属性和方法，这样的话如果每个类都重新写不仅代码显得很乱，代码工作量也很大。
这时继承的优势就出来了：可以直接使用父类的属性和方法，自己也可以有自己新的属性和方法满足拓展，父类的方法如果自己有需求更改也可以重写。这样使用继承不仅大大的减少了代码量，也使得代码结构更加清晰可见。

所以这样从代码的层面上来看我们设计这个完整的 Animal 类是这样的：
123456789101112131415161718192021222324252627282930class Animal{    public int id;    public String name;    public int age;    public int weight;        public Animal(int id, String name, int age, int weight) {        this.id &#x3D; id;        this.name &#x3D; name;        this.age &#x3D; age;        this.weight &#x3D; weight;    }        &#x2F;&#x2F;这里省略get set方法    public void sayHello()    {        System.out.println(&quot;hello&quot;);    }        public void eat()    {        System.out.println(&quot;I&#39;m eating&quot;);    }        public void sing()    {        System.out.println(&quot;sing&quot;);    }}
而 Dog，Cat，Chicken 类可以这样设计：
123456789101112131415161718192021222324class Dog extends Animal&#x2F;&#x2F;继承animal{    public Dog(int id, String name, int age, int weight) {        super(id, name, age, weight);&#x2F;&#x2F;调用父类构造方法    }}class Cat extends Animal{    public Cat(int id, String name, int age, int weight) {        super(id, name, age, weight);&#x2F;&#x2F;调用父类构造方法    }}class Chicken extends Animal{    public Chicken(int id, String name, int age, int weight) {        super(id, name, age, weight);&#x2F;&#x2F;调用父类构造方法    }        &#x2F;&#x2F;鸡下蛋    public void layEggs()    {        System.out.println(&quot;我是老母鸡下蛋啦，咯哒咯！咯哒咯！&quot;);    }}
各自的类继承 Animal 后可以直接使用 Animal 类的属性和方法而不需要重复编写，各个类如果有自己的方法也可很容易地拓展。
03、继承的分类
继承分为单继承和多继承，Java 语言只支持类的单继承，但可以通过实现接口的方式达到多继承的目的。这个我们之前在讲接口的时候就提到过，这里我们再聊一下。




继承
定义
优缺点




单继承
一个子类只拥有一个父类
优点：在类层次结构上比较清晰缺点：结构的丰富度有时不能满足使用需求


多继承（Java 不支持，但可以用其它方式满足多继承使用需求）
一个子类拥有多个直接的父类
优点：子类的丰富度很高缺点：容易造成混乱




单继承
单继承，一个子类只有一个父类，如我们上面讲过的 Animal 类和它的子类。单继承在类层次结构上比较清晰，但缺点是结构的丰富度有时不能满足使用需求。
多继承
多继承，一个子类有多个直接的父类。这样做的好处是子类拥有所有父类的特征，子类的丰富度很高，但是缺点就是容易造成混乱。下图为一个混乱的例子。

Java 虽然不支持多继承，但是 Java 有三种实现多继承效果的方式，分别是内部类、多层继承和实现接口。
内部类可以继承一个与外部类无关的类，保证了内部类的独立性，正是基于这一点，可以达到多继承的效果。
多层继承：子类继承父类，父类如果还继承其他的类，那么这就叫多层继承。这样子类就会拥有所有被继承类的属性和方法。

实现接口无疑是满足多继承使用需求的最好方式，一个类可以实现多个接口满足自己在丰富性和复杂环境的使用需求。
类和接口相比，类就是一个实体，有属性和方法，而接口更倾向于一组方法。举个例子，就拿斗罗大陆的唐三来看，他存在的继承关系可能是这样的：

04、如何实现继承
extends 关键字
在 Java 中，类的继承是单一继承，也就是说一个子类只能拥有一个父类，所以extends只能继承一个类。其使用语法为：
1class 子类名 extends 父类名{}
例如 Dog 类继承 Animal 类，它是这样的：
12class Animal{} &#x2F;&#x2F;定义Animal类class Dog extends Animal{} &#x2F;&#x2F;Dog类继承Animal类
子类继承父类后，就拥有父类的非私有的属性和方法。如果不明白，请看这个案例，在 IDEA 下创建一个项目，创建一个 test 类做测试，分别创建 Animal 类和 Dog 类，Animal 作为父类写一个 sayHello()方法，Dog 类继承 Animal 类之后就可以调用 sayHello()方法。具体代码为：
12345678910111213141516class Animal {    public void  sayHello()&#x2F;&#x2F;父类的方法    {        System.out.println(&quot;hello,everybody&quot;);    }}class Dog extends Animal&#x2F;&#x2F;继承animal{ }public class test {    public static void main(String[] args) {       Dog dog&#x3D;new Dog();       dog.sayHello();    }}
点击运行的时候 Dog 子类可以直接使用 Animal 父类的方法。

implements 关键字
使用 implements 关键字可以变相使 Java 拥有多继承的特性，使用范围为类实现接口的情况，一个类可以实现多个接口(接口与接口之间用逗号分开)。
我们来看一个案例，创建一个 test2 类做测试，分别创建 doA 接口和 doB 接口，doA 接口声明 sayHello()方法，doB 接口声明 eat()方法，创建 Cat2 类实现 doA 和 doB 接口，并且在类中需要重写 sayHello()方法和eat()方法。具体代码为：
12345678910111213141516171819202122232425262728interface doA{     void sayHello();}interface doB{     void eat();    &#x2F;&#x2F;以下会报错 接口中的方法不能具体定义只能声明    &#x2F;&#x2F;public void eat(){System.out.println(&quot;eating&quot;);}}class Cat2 implements  doA,doB{    @Override&#x2F;&#x2F;必须重写接口内的方法    public void sayHello() {        System.out.println(&quot;hello!&quot;);    }    @Override    public void eat() {        System.out.println(&quot;I&#39;m eating&quot;);    }}public class test2 {    public static void main(String[] args) {        Cat2 cat&#x3D;new Cat2();        cat.sayHello();        cat.eat();    }}
Cat 类实现 doA 和 doB 接口的时候，需要实现其声明的方法，点击运行结果如下，这就是一个类实现接口的简单案例：

05、继承的特点
继承的主要内容就是子类继承父类，并重写父类的方法。使用子类的属性或方法时候，首先要创建一个对象，而对象通过构造方法去创建，在构造方法中我们可能会调用子父类的一些属性和方法，所以就需要提前掌握 this 和 super关键字。
创建完这个对象之后，再调用重写父类后的方法，注意重写和重载的区别。
this 和 super 关键字
后面会详细讲，这里先来简单了解一下。
this 和 super 关键字是继承中非常重要的知识点，分别表示当前对象的引用和父类对象的引用，两者有很大相似又有一些区别。
this 表示当前对象，是指向自己的引用。
123this.属性 &#x2F;&#x2F; 调用成员变量，要区别成员变量和局部变量this.() &#x2F;&#x2F; 调用本类的某个方法this() &#x2F;&#x2F; 表示调用本类构造方法
super 表示父类对象，是指向父类的引用。
123super.属性 &#x2F;&#x2F; 表示父类对象中的成员变量super.方法() &#x2F;&#x2F; 表示父类对象中定义的方法super() &#x2F;&#x2F; 表示调用父类构造方法
构造方法
构造方法是一种特殊的方法，它是一个与类同名的方法。在继承中构造方法是一种比较特殊的方法（比如不能继承），所以要了解和学习在继承中构造方法的规则和要求。
继承中的构造方法有以下几点需要注意：
父类的构造方法不能被继承：
因为构造方法语法是与类同名，而继承则不更改方法名，如果子类继承父类的构造方法，那明显与构造方法的语法冲突了。比如 Father 类的构造方法名为 Father()，Son 类如果继承 Father 类的构造方法 Father()，那就和构造方法定义：构造方法与类同名冲突了，所以在子类中不能继承父类的构造方法，但子类会调用父类的构造方法。
子类的构造过程必须调用其父类的构造方法：
Java 虚拟机构造子类对象前会先构造父类对象，父类对象构造完成之后再来构造子类特有的属性，这被称为内存叠加。而 Java 虚拟机构造父类对象会执行父类的构造方法，所以子类构造方法必须调用 super()即父类的构造方法。就比如一个简单的继承案例应该这么写：
1234567891011121314151617181920class A{    public String name;        public A() {&#x2F;&#x2F;无参构造    }        public A (String name){&#x2F;&#x2F;有参构造    }}class B extends A{    public B() {&#x2F;&#x2F;无参构造       super();    }        public B(String name) {&#x2F;&#x2F;有参构造      &#x2F;&#x2F;super();       super(name);    }}
如果子类的构造方法中没有显示地调用父类构造方法，则系统默认调用父类无参数的构造方法。
你可能有时候在写继承的时候子类并没有使用 super()调用，程序依然没问题，其实这样是为了节省代码，系统执行时会自动添加父类的无参构造方式，如果不信的话我们对上面的类稍作修改执行：

方法重写(Override)
方法重写也就是子类中出现和父类中一模一样的方法(包括返回值类型，方法名，参数列表)，它建立在继承的基础上。你可以理解为方法的外壳不变，但是核心内容重写。
在这里提供一个简单易懂的方法重写案例：
123456789101112class E1{    public void doA(int a){        System.out.println(&quot;这是父类的方法&quot;);    }}class E2 extends E1{    @Override    public void doA(int a) {        System.out.println(&quot;我重写父类方法，这是子类的方法&quot;);    }}
其中 @Override 注解显示声明该方法为注解方法，可以帮你检查重写方法的语法正确性，当然如果不加也是可以的，但建议加上。
方法重载(Overload)
如果有两个方法的方法名相同，但参数不一致，那么可以说一个方法是另一个方法的重载。
重载可以通常理解为完成同一个事情的方法名相同，但是参数列表不同其他条件也可能不同。一个简单的方法重载的例子，类 E3 中的 add()方法就是一个重载方法。
12345678910111213class E3{    public int add(int a,int b){        return a+b;    }        public double add(double a,double b) {        return a+b;    }        public int add(int a,int b,int c) {        return a+b+c;    }}
06、继承与修饰符
Java 修饰符的作用就是对类或类成员进行修饰或限制，每个修饰符都有自己的作用，而在继承中可能有些特殊修饰符使得被修饰的属性或方法不能被继承，或者继承需要一些其他的条件。
Java 语言提供了很多修饰符，修饰符用来定义类、方法或者变量，通常放在语句的最前端。主要分为以下两类：

访问权限修饰符，也就是 public、private、protected 等
非访问修饰符，也就是 static、final、abstract 等

访问修饰符
Java 子类重写继承的方法时，不可以降低方法的访问权限，子类继承父类的访问修饰符作用域不能比父类小，也就是更加开放，假如父类是 protected 修饰的，其子类只能是 protected 或者 public，绝对不能是default(默认的访问范围)或者 private。所以在继承中需要重写的方法不能使用 private 修饰词修饰。
如果还是不太清楚可以看几个小案例就很容易搞懂，写一个 A1 类中用四种修饰词实现四个方法，用子类 A2继承 A1，重写 A1 方法时候你就会发现父类私有方法不能重写，非私有方法重写使用的修饰符作用域不能变小(大于等于)。

正确的案例应该为：
1234567891011121314151617class A1 {    private void doA(){ }    void doB(){}&#x2F;&#x2F;default    protected void doC(){}    public void doD(){}}class A2 extends A1{    @Override    public void doB() { }&#x2F;&#x2F;继承子类重写的方法访问修饰符权限可扩大        @Override    protected void doC() { }&#x2F;&#x2F;继承子类重写的方法访问修饰符权限可和父类一致        @Override    public void doD() { }&#x2F;&#x2F;不可用protected或者default修饰}
还要注意的是，继承当中子类抛出的异常必须是父类抛出的异常或父类抛出异常的子异常。下面的一个案例四种方法测试可以发现子类方法的异常不可大于父类对应方法抛出异常的范围。

正确的案例应该为：
1234567891011121314151617181920212223class B1{    public void doA() throws Exception{}    public void doB() throws Exception{}    public void doC() throws IOException{}    public void doD() throws IOException{}}class B2 extends B1{    &#x2F;&#x2F;异常范围和父类可以一致    @Override    public void doA() throws Exception { }        &#x2F;&#x2F;异常范围可以比父类更小    @Override    public void doB() throws IOException { }        &#x2F;&#x2F;异常范围 不可以比父类范围更大    @Override    public void doC() throws IOException { }&#x2F;&#x2F;不可抛出Exception等比IOException更大的异常        @Override    public void doD() throws IOException { }}
非访问修饰符
访问修饰符用来控制访问权限，而非访问修饰符每个都有各自的作用，下面针对 static、final、abstract 修饰符进行介绍。
static 修饰符
static 翻译为“静态的”，能够与变量，方法和类一起使用，称为静态变量，静态方法(也称为类变量、类方法)。如果在一个类中使用 static 修饰变量或者方法的话，它们可以直接通过类访问，不需要创建一个类的对象来访问成员。
我们在设计类的时候可能会使用静态方法，有很多工具类比如 Math ， Arrays 等类里面就写了很多静态方法。
可以看以下的案例证明上述规则：

源代码为：
1234567891011121314151617class C1{    public  int a;    public C1(){}   &#x2F;&#x2F; public static C1(){}&#x2F;&#x2F; 构造方法不允许被声明为static    public static void doA() {}    public static void doB() {}}class C2 extends C1{    public static  void doC()&#x2F;&#x2F;静态方法中不存在当前对象，因而不能使用this和super。    {        &#x2F;&#x2F;System.out.println(super.a);    }        public static void doA(){}&#x2F;&#x2F;静态方法能被静态方法重写   &#x2F;&#x2F; public void doB(){}&#x2F;&#x2F;静态方法不能被非静态方法重写}
final 修饰符
final 变量：

final 表示”最后的、最终的”含义，变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显式指定初始值(即不能只声明)。final 修饰符通常和 static 修饰符一起使用来创建类常量。

final 方法：

父类中的 final 方法可以被子类继承，但是不能被子类重写。声明 final 方法的主要目的是防止该方法的内容被修改。

final 类：

final 类不能被继承，没有类能够继承 final 类的任何特性。

所以无论是变量、方法还是类被 final 修饰之后，都有代表最终、最后的意思。内容无法被修改。
abstract 修饰符
abstract 英文名为“抽象的”，主要用来修饰类和方法，称为抽象类和抽象方法。
抽象方法：有很多不同类的方法是相似的，但是具体内容又不太一样，所以我们只能抽取他的声明，没有具体的方法体，即抽象方法可以表达概念但无法具体实现。
抽象类：有抽象方法的类必须是抽象类，抽象类可以表达概念但是无法构造实体的类。

比如我们可以这样设计一个 People 抽象类以及一个抽象方法，在子类中具体完成：
123456789101112131415161718192021222324abstract class People{    public abstract void sayHello();&#x2F;&#x2F;抽象方法}class Chinese extends People{    @Override    public void sayHello() {&#x2F;&#x2F;实现抽象方法        System.out.println(&quot;你好&quot;);    }}class Japanese extends People{    @Override    public void sayHello() {&#x2F;&#x2F;实现抽象方法        System.out.println(&quot;口你七哇&quot;);    }}class American extends People{    @Override    public void sayHello() {&#x2F;&#x2F;实现抽象方法        System.out.println(&quot;hello&quot;);    }}
07、Object 类和转型
提到 Java 继承，不得不提及所有类的根类：Object(java.lang.Object)类，如果一个类没有显式声明它的父类（即没有写 extends xx），那么默认这个类的父类就是 Object 类，任何类都可以使用 Object 类的方法，创建的类也可和 Object 进行向上、向下转型，所以 Object 类是掌握和理解继承所必须的知识点。
Java 向上和向下转型在 Java 中运用很多，也是建立在继承的基础上，所以 Java 转型也是掌握和理解继承所必须的知识点。
Object 类概述

Object 是类层次结构的根类，所有的类都隐式的继承自 Object 类。
Java 中，所有的对象都拥有 Object 的默认方法。
Object 类有一个构造方法，并且是无参构造方法。

Object 是 Java 所有类的父类，是整个类继承结构的顶端，也是最抽象的一个类。
像 toString()、equals()、hashCode()、wait()、notify()、getClass()等都是 Object 的方法。你以后可能会经常碰到，但其中遇到更多的就是 toString()方法和 equals()方法，我们经常需要重写这两种方法满足我们的使用需求。
toString()方法表示返回该对象的字符串，由于各个对象构造不同所以需要重写，如果不重写的话默认返回 类名@hashCode 格式。
如果重写 toString()方法后直接调用 toString()方法就可以返回我们自定义的该类转成字符串类型的内容输出，而不需要每次都手动的拼凑成字符串内容输出，大大简化输出操作。
equals()方法主要比较两个对象是否相等，因为对象的相等不一定非要严格要求两个对象地址上的相同，有时内容上的相同我们就会认为它相等，比如 String 类就重写了euqals()方法，通过字符串的内容比较是否相等。

向上转型
向上转型 : 通过子类对象(小范围)实例化父类对象(大范围)，这种属于自动转换。用一张图就能很好地表示向上转型的逻辑：

父类引用变量指向子类对象后，只能使用父类已声明的方法，但方法如果被重写会执行子类的方法，如果方法未被重写那么将执行父类的方法。
向下转型
向下转型 : 通过父类对象(大范围)实例化子类对象(小范围)，在书写上父类对象需要加括号 () 强制转换为子类类型。但父类引用变量实际引用必须是子类对象才能成功转型，这里也用一张图就能很好表示向下转型的逻辑：

子类引用变量指向父类引用变量指向的对象后(一个 Son()对象)，就完成向下转型，就可以调用一些子类特有而父类没有的方法 。
在这里写一个向上转型和向下转型的案例：
123Object object&#x3D;new Integer(666);&#x2F;&#x2F;向上转型Integer i&#x3D;(Integer)object;&#x2F;&#x2F;向下转型Object-&gt;Integer，object的实质还是指向IntegerString str&#x3D;(String)object;&#x2F;&#x2F;错误的向下转型，虽然编译器不会报错但是运行会报错
08、子父类初始化顺序
在 Java 继承中，父子类初始化先后顺序为：

父类中静态成员变量和静态代码块
子类中静态成员变量和静态代码块
父类中普通成员变量和代码块，父类的构造方法
子类中普通成员变量和代码块，子类的构造方法

总的来说，就是静态&gt;非静态，父类&gt;子类，非构造方法&gt;构造方法。同一类别（例如普通变量和普通代码块）成员变量和代码块执行从前到后，需要注意逻辑。
这个也不难理解，静态变量也称类变量，可以看成一个全局变量，静态成员变量和静态代码块在类加载的时候就初始化，而非静态变量和代码块在对象创建的时候初始化。所以静态快于非静态初始化。
而在创建子类对象的时候需要先创建父类对象，所以父类优先于子类。
而在调用构造方法的时候，是对成员变量进行一些初始化操作，所以普通成员变量和代码块优于构造方法执行。
至于更深层次为什么这个顺序，就要更深入了解 JVM 执行流程啦。下面一个测试代码为：
123456789101112131415161718192021222324252627282930313233343536373839class Father{    public Father() {        System.out.println(++b1+&quot;父类构造方法&quot;);    }&#x2F;&#x2F;父类构造方法 第四        static int a1&#x3D;0;&#x2F;&#x2F;父类static 第一 注意顺序        static {        System.out.println(++a1+&quot;父类static&quot;);    }        int b1&#x3D;a1;&#x2F;&#x2F;父类成员变量和代码块 第三        {        System.out.println(++b1+&quot;父类代码块&quot;);    }}class Son extends Father{    public Son() {        System.out.println(++b2+&quot;子类构造方法&quot;);    }&#x2F;&#x2F;子类构造方法 第六        static {&#x2F;&#x2F;子类static第二步        System.out.println(++a1+&quot;子类static&quot;);    }        int b2&#x3D;b1;&#x2F;&#x2F;子类成员变量和代码块 第五        {        System.out.println(++b2 + &quot;子类代码块&quot;);    }}public class test9 {    public static void main(String[] args) {        Son son&#x3D;new Son();    }}
执行结果：

3）多态
Java 多态是指在面向对象编程中，同一个类的对象在不同情况下表现出不同的行为和状态。

子类可以继承父类的属性和方法，子类对象可以直接使用父类中的方法和变量。
子类可以对从父类继承的方法进行重新实现，使得子类对象调用这个方法时表现出不同的行为。
可以将子类对象赋给父类类型的变量，这样就可以通过父类类型的变量调用子类中重写的方法，实现多态。

“很枯燥，有没有？再具体的分析一下。”
01、多态是什么
在我刻板的印象里，西游记里的那段孙悟空和二郎神的精彩对战就能很好的解释“多态”这个词：一个孙悟空，能七十二变；一个二郎神，也能七十二变；他们都可以变成不同的形态，但只需要悄悄地喊一声“变”。Java的多态是什么呢？其实就是一种能力——同一个行为具有不同的表现形式；换句话说就是，执行一段代码，Java 在运行时能根据对象的不同产生不同的结果。和孙悟空和二郎神都只需要喊一声“变”，然后就变了，并且每次变得还不一样；一个道理。多态的前提条件有三个：子类继承父类子类覆盖父类的方法父类引用指向子类对象多态的一个简单应用，来看程序清单1-1：02、多态与后期绑定现在，我们来思考一个问题：程序清单1-1在执行 wanger.write() 时，由于编译器只有一个 Wanger 引用，它怎么知道究竟该调用父类 Wanger 的 write() 方法，还是子类 Wangxiaoer 的 write() 方法呢？答案是在运行时根据对象的类型进行后期绑定，编译器在编译阶段并不知道对象的类型，但是Java的方法调用机制能找到正确的方法体，然后执行出正确的结果。多态机制提供的一个重要的好处程序具有良好的扩展性。来看程序清单2-1：&#x2F;&#x2F;子类继承父类public class Wangxiaoer extends Wanger {public void write() { &#x2F;&#x2F; 子类覆盖父类方法System.out.println(“记住仇恨，表明我们要奋发图强的心智”);}public static void main(String[] args) {&#x2F;&#x2F; 父类引用指向子类对象Wanger[] wangers &#x3D; { new Wanger(), new Wangxiaoer() };for (Wanger wanger : wangers) {&#x2F;&#x2F; 对象是王二的时候输出：勿忘国耻&#x2F;&#x2F; 对象是王小二的时候输出：记住仇恨，表明我们要奋发图强的心智wanger.write();}}}class Wanger {public void write() {System.out.println(“勿忘国耻”);}}&#x2F;&#x2F;子类继承父类学Java，就认准二哥的Java进阶之路No. 306 &#x2F; 963在程序清单 2-1 中，我们在 Wanger 类中增加了 read() 方法，在 Wangxiaoer 类中增加了eat()方法，但这丝毫不会影响到 write() 方法的调用。write() 方法忽略了周围代码发生的变化，依然正常运行。这让我想起了金庸《倚天屠龙记》里九阳真经的口诀：“他强由他强，清风拂山岗；他横由他横，明月照大江。”多态的这个优秀的特性，让我们在修改代码的时候不必过于紧张，因为多态是一项让程序员“将改变的与未改变的分离开来”的重要特性。03、多态与构造方法在构造方法中调用多态方法，会产生一个奇妙的结果，我们来看程序清单3-1：public class Wangxiaoer extends Wanger {public void write() { &#x2F;&#x2F; 子类覆盖父类方法System.out.println(“记住仇恨，表明我们要奋发图强的心智”);}public void eat() {System.out.println(“我不喜欢读书，我就喜欢吃”);}public static void main(String[] args) {&#x2F;&#x2F; 父类引用指向子类对象Wanger[] wangers &#x3D; { new Wanger(), new Wangxiaoer() };for (Wanger wanger : wangers) {&#x2F;&#x2F; 对象是王二的时候输出：勿忘国耻&#x2F;&#x2F; 对象是王小二的时候输出：记住仇恨，表明我们要奋发图强的心智wanger.write();}}}class Wanger {public void write() {System.out.println(“勿忘国耻”);}public void read() {System.out.println(“每周读一本好书”);}}public class Wangxiaosan extends Wangsan {private int age &#x3D; 3;public Wangxiaosan(int age) {this.age &#x3D; age;System.out.println(“王小三的年龄：” + this.age);}public void write() { &#x2F;&#x2F; 子类覆盖父类方法System.out.println(“我小三上幼儿园的年龄是：” + this.age);}学Java，就认准二哥的Java进阶之路No. 307 &#x2F; 963从输出结果上看，是不是有点诧异？明明在创建 Wangxiaosan 对象的时候，年龄传递的是 4，但输出结果既不是“老子上幼儿园的年龄是 3 岁半”，也不是“我小三上幼儿园的年龄是：4”。为什么？因为在创建子类对象时，会先去调用父类的构造方法，而父类构造方法中又调用了被子类覆盖的多态方法，由于父类并不清楚子类对象中的属性值是什么，于是把int类型的属性暂时初始化为 0，然后再调用子类的构造方法（子类构造方法知道王小二的年龄是 4）。04、多态与向下转型向下转型是指将父类引用强转为子类类型；这是不安全的，因为有的时候，父类引用指向的是父类对象，向下转型就会抛出 ClassCastException，表示类型转换失败；但如果父类引用指向的是子类对象，那么向下转型就是成功的。来看程序清单4-1：public static void main(String[] args) {new Wangxiaosan(4);&#x2F;&#x2F; 上幼儿园之前&#x2F;&#x2F; 我小三上幼儿园的年龄是：0&#x2F;&#x2F; 上幼儿园之后&#x2F;&#x2F; 王小三的年龄：4}}class Wangsan {Wangsan () {System.out.println(“上幼儿园之前”);write();System.out.println(“上幼儿园之后”);}public void write() {System.out.println(“老子上幼儿园的年龄是3岁半”);}}public class Wangxiaosi extends Wangsi {public void write() {System.out.println(“记住仇恨，表明我们要奋发图强的心智”);}public void eat() {System.out.println(“我不喜欢读书，我就喜欢吃”);}public static void main(String[] args) {Wangsi[] wangsis &#x3D; { new Wangsi(), new Wangxiaosi() };&#x2F;&#x2F; wangsis[1]能够向下转型((Wangxiaosi) wangsis[1]).write();学Java，就认准二哥的Java进阶之路No. 308 &#x2F; 963“好了，三妹，到此为止，我们就将 Java 的三大特性，封装继承多态全部讲完了，希望你能重新把他们梳理一下。”“好的，二哥，遵命。”三妹顽皮地笑了。4）小结好啦，三妹，本次继承就介绍到这里啦，Java 面向对象三大特征之一继承——优秀的你已经掌握。封装：是对类的封装，封装是对类的属性和方法进行封装，只对外暴露方法而不暴露具体使用细节，所以我们一般设计类成员变量时候大多设为私有而通过一些 get、set 方法去读写。继承：子类继承父类，即“子承父业”，子类拥有父类除私有的所有属性和方法，自己还能在此基础上拓展自己新的属性和方法。主要目的是复用代码。多态：多态是同一个行为具有多个不同表现形式或形态的能力。即一个父类可能有若干子类，各子类实现父类方法有多种多样，调用父类方法时，父类引用变量指向不同子类实例而执行不同方法，这就是所谓父类方法是多态的。最后送你一张图捋一捋其中的关系吧。&#x2F;&#x2F; wangsis[0]不能向下转型((Wangxiaosi)wangsis[0]).write();}}class Wangsi {public void write() {System.out.println(“勿忘国耻”);}public void read() {System.out.println(“每周读一本好书”);}}学Java，就认准二哥的Java进阶之路No. 309 &#x2F; 963“好的，二哥，我来消化一下，今天内容真不少。你先去休息一下。”三妹回应到。参考链接：https:&#x2F;&#x2F;bbs.huaweicloud.com&#x2F;blogs&#x2F;271358，作者：bigsai，整理：沉默王二GitHub 上标星 7600+ 的开源知识库《二哥的 Java 进阶之路》第一版 PDF 终于来了！包括Java基础语法、数组&amp;字符串、OOP、集合框架、Java IO、异常处理、Java 新特性、网络编程、NIO、并发编程、JVM等等，共计 32 万余字，可以说是通俗易懂、风趣幽默……详情戳：太赞了，GitHub 上标星 7600+ 的 Java 教程微信搜 沉默王二 或۾描下方二维码关注二哥的原创公众号沉默王二，回复 222 即可免费领取。5.14 Java this和super关键字学Java，就认准二哥的Java进阶之路No. 310 &#x2F; 963“哥，被喊大舅子的感觉怎么样啊？”三妹不怀好意地对我说，她眼睛里充满着不屑。“说实话，这种感觉还不错。”我有点难为情的回答她，“不过，有一点令我感到些许失落。大家的焦点似乎都是你的颜值，完全忽略了我的盛世美颜啊！”“哥，你想啥呢，那是因为你文章写得好，不然谁认识我是谁啊！有你这样的哥哥，我还是挺自豪的。”三妹郑重其事地说，“话说今天咱学啥呢？”“三妹啊，你这句话说得我喜欢。今天来学习一下 Java 中的 this 关键字吧。”喝了一口农夫山泉后，我对三妹说。“this 关键字有很多种用法，其中最常用的一个是，它可以作为引用变量，指向当前对象。”我面带着朴实无华的微笑继续说，“除此之外， this 关键字还可以完成以下工作。”调用当前类的方法；this() 可以调用当前类的构造方法；this 可以作为参数在方法中传递；this 可以作为参数在构造方法中传递；this 可以作为方法的返回值，返回当前类的对象。01、 指向当前对象“三妹，来看下面这段代码。”话音刚落，我就在键盘上噼里啪啦一阵敲。“在上面的例子中，构造方法的参数名和实例变量名相同，由于没有使用 this 关键字，所以无法为实例变量赋值。”我抬起右手的食指，指着屏幕上的 name 和 age 对着三妹说。“来看一下程序的输出结果。”public class WithoutThisStudent {String name;int age;WithoutThisStudent(String name, int age) {name &#x3D; name;age &#x3D; age;}void out() {System.out.println(name+” “ + age);}public static void main(String[] args) {WithoutThisStudent s1 &#x3D; new WithoutThisStudent(“沉默王二”, 18);WithoutThisStudent s2 &#x3D; new WithoutThisStudent(“沉默王三”, 16);s1.out();s2.out();}}学Java，就认准二哥的Java进阶之路No. 311 &#x2F; 963学Java，就认准二哥的Java进阶之路null 0null 0“从结果中可以看得出来，尽管创建对象的时候传递了参数，但实例变量并没有赋值。这是因为如果构造方法中没有使用 this 关键字的话，name 和 age 指向的并不是实例变量而是参数本身。”我把脖子܀向右侧，看着三妹说。“那怎么解决这个问题呢？哥。”三妹着急地问。“如果参数名和实例变量名产生了冲突…..”我正准备给出答案，三妹打断了我。“难道用 this 吗？”三妹脱口而出。“哇，越来越棒了呀，你。”我感觉三妹在学习 Java 这条道路上逐渐有了自己主动思考的意愿。“是的，来看加上 this 关键字后的代码。”安静的屋子里又响起了一阵噼里啪啦的键盘声。public class WithThisStudent {String name;int age;WithThisStudent(String name, int age) {this.name &#x3D; name;this.age &#x3D; age;}void out() {System.out.println(name+” “ + age);}public static void main(String[] args) {WithThisStudent s1 &#x3D; new WithThisStudent(“沉默王二”, 18);WithThisStudent s2 &#x3D; new WithThisStudent(“沉默王三”, 16);s1.out();s2.out();}}“再来看一下程序的输出结果。”沉默王二 18沉默王三 16“这次，实例变量有值了，在构造方法中， this.xxx 指向的就是实例变量，而不再是参数本身了。”我慢吞吞地说着，“当然了，如果参数名和实例变量名不同的话，就不必使用 this 关键字，但我建议使用 this 关键字，这样的代码更有意义。”No. 312 &#x2F; 96302、调用当前类的方法“仔细听，三妹，看我敲键盘的速度是不是够快。”“仔细瞧，三妹，上面这段代码中没有见到 this 关键字吧？”我面带着神秘的微笑，准备给三妹变个魔术。“确实没有，哥，我确认过了。”“那接下来，神奇的事情就要发生了。”我突然感觉刘谦附身了。我快速的在 classes 目录下找到 InvokeCurrentClassMethod.class 文件，然后双击打开（IDEA 默认会使用FernFlower 打开字节码文件）。“瞪大眼睛仔细瞧，三妹， this 关键字是不是出现了？”“哇，真的呢，好神奇啊！”三妹为了配合我的演出，也是十二分的卖力。“我们可以在一个类中使用 this 关键字来调用另外一个方法，如果没有使用的话，编译器会自动帮我们加上。”我对自己深厚的编程功底充满自信，“在源代码中， method2() 在调用 method1() 的时候并没有使用this 关键字，但通过反编译后的字节码可以看得到。”public class InvokeCurrentClassMethod {void method1() {}void method2() {method1();}public static void main(String[] args) {new InvokeCurrentClassMethod().method1();}}public class InvokeCurrentClassMethod {public InvokeCurrentClassMethod() {}void method1() {}void method2() {this.method1();}public static void main(String[] args) {(new InvokeCurrentClassMethod()).method1();}}学Java，就认准二哥的Java进阶之路No. 313 &#x2F; 96303、调用当前类的构造方法“再来看下面这段代码。”“在有参构造方法 InvokeConstrutor(int count) 中，使用了 this() 来调用无参构造方法InvokeConstrutor() 。”这次，我换成了左手的食指，指着屏幕对三妹说，“ this() 可用于调用当前类的构造方法——构造方法可以重用了。”“来看一下输出结果。”“真的啊，无参构造方法也被调用了，所以程序输出了 hello。”三妹看到输出结果后不假思索地说。“也可以在无参构造方法中使用 this() 并传递参数来调用有参构造方法。”话音没落，我就在键盘上敲了起来，“来看下面这段代码。”“再来看一下程序的输出结果。”public class InvokeConstrutor {InvokeConstrutor() {System.out.println(“hello”);}InvokeConstrutor(int count) {this();System.out.println(count);}public static void main(String[] args) {InvokeConstrutor invokeConstrutor &#x3D; new InvokeConstrutor(10);}}hello10public class InvokeParamConstrutor {InvokeParamConstrutor() {this(10);System.out.println(“hello”);}InvokeParamConstrutor(int count) {System.out.println(count);}public static void main(String[] args) {InvokeParamConstrutor invokeConstrutor &#x3D; new InvokeParamConstrutor();}}学Java，就认准二哥的Java进阶之路No. 314 &#x2F; 963“不过，需要注意的是， this() 必须放在构造方法的第一行，否则就报错了。”04、作为参数在方法中传递“来看下面这段代码。”“ this 关键字可以作为参数在方法中传递，此时，它指向的是当前类的对象。”一不小心，半个小时过去了，我感到嗓子冒烟，于是赶紧又喝了一口水，润润嗓子后继续说道。“来看一下输出结果，你就明白了，三妹。”10hellopublic class ThisAsParam {void method1(ThisAsParam p) {System.out.println(p);}void method2() {method1(this);}public static void main(String[] args) {ThisAsParam thisAsParam &#x3D; new ThisAsParam();System.out.println(thisAsParam);thisAsParam.method2();}}com.itwanger.twentyseven.ThisAsParam@77459877com.itwanger.twentyseven.ThisAsParam@77459877学Java，就认准二哥的Java进阶之路No. 315 &#x2F; 963“ method2() 调用了 method1() ，并传递了参数 this， method1() 中打印了当前对象的字符串。 main()方法中打印了 thisAsParam 对象的字符串。从输出结果中可以看得出来，两者是同一个对象。”05、作为参数在构造方法中传递“继续来看代码。”“在构造方法 ThisAsConstrutorParam() 中，我们使用 this 关键字作为参数传递给了 Data 对象，它其实指向的就是 new ThisAsConstrutorParam() 这个对象。”“ this 关键字也可以作为参数在构造方法中传递，它指向的是当前类的对象。当我们需要在多个类中使用一个对象的时候，这非常有用。”“来看一下输出结果。”06、作为方法的返回值“需要休息会吗？三妹”“没事的，哥，我的注意力还是很集中的，你继续讲吧。”“好的，那来继续看代码。”public class ThisAsConstrutorParam {int count &#x3D; 10;ThisAsConstrutorParam() {Data data &#x3D; new Data(this);data.out();}public static void main(String[] args) {new ThisAsConstrutorParam();}}class Data {ThisAsConstrutorParam param;Data(ThisAsConstrutorParam param) {this.param &#x3D; param;}void out() {System.out.println(param.count);}}10学Java，就认准二哥的Java进阶之路No. 316 &#x2F; 963“ getThisAsMethodResult() 方法返回了 this 关键字，指向的就是 new ThisAsMethodResult() 这个对象，所以可以紧接着调用 out() 方法——达到了链式调用的目的，这也是 this 关键字非常经典的一种用法。”“链式调用的形式在 JavaScript 代码更加常见。”为了向三妹证实这一点，我打开了 jQuery 的源码。“原来这么多链式调用啊！”三妹感叹到。“是的。”我点点头，然后指着 getThisAsMethodResult() 方法的返回值对三妹说，“需要注意的是， this关键字作为方法的返回值的时候，方法的返回类型为类的类型。”“来看一下输出结果。”“那么，关于 this 关键字的介绍，就到此为止了。”我活动了一下僵硬的脖子后，对三妹说，“如果你学习劲头还可以的话，我们顺带把 super 关键字捎带着过一下，怎么样？”“不用了吧，听说 super 关键字更简单，我自己看看就行了，不用你讲了！”“不不不，三妹啊，你得假装听一下，不然我怎么向读者们交差。”“噢噢噢噢。”三妹意味深长地笑了。07、super 关键字“super 关键字的用法主要有三种。”指向父类对象；调用父类的方法；super() 可以调用父类的构造方法。“其实和 this 有些相似，只不过用意不大相同。”我端起水瓶，咕咚咕咚又喝了几大口，好渴。“每当创建一个子类对象的时候，也会隐式的创建父类对象，由 super 关键字引用。”“如果父类和子类拥有同样名称的字段，super 关键字可以用来访问父类的同名字段。”“来看下面这段代码。”public class ThisAsMethodResult {ThisAsMethodResult getThisAsMethodResult() {return this;}void out() {System.out.println(“hello”);}public static void main(String[] args) {new ThisAsMethodResult().getThisAsMethodResult().out();}}hello学Java，就认准二哥的Java进阶之路No. 317 &#x2F; 963学Java，就认准二哥的Java进阶之路public class ReferParentField {public static void main(String[] args) {new Dog().printColor();}}class Animal {String color &#x3D; “白色”;}class Dog extends Animal {String color &#x3D; “黑色”;void printColor() {System.out.println(color);System.out.println(super.color);}}“父类 Animal 中有一个名为 color 的字段，子类 Dog 中也有一个名为 color 的字段，子类的 printColor()方法中，通过 super 关键字可以访问父类的 color。”“来看一下输出结果。”黑色白色“当子类和父类的方法名相同时，可以使用 super 关键字来调用父类的方法。换句话说，super 关键字可以用于方法重写时访问到父类的方法。”public class ReferParentMethod {public static void main(String[] args) {new Dog().work();}}class Animal {void eat() {System.out.println(“吃…”);}}class Dog extends Animal {@Overridevoid eat() {System.out.println(“吃…”);}void bark() {System.out.println(“汪汪汪…”);}No. 318 &#x2F; 963学Java，就认准二哥的Java进阶之路void work() {super.eat();bark();}}“瞧，三妹。父类 Animal 和子类 Dog 中都有一个名为 eat() 的方法，通过 super.eat() 可以访问到父类的 eat() 方法。”等三妹在自我消化的时候，我在键盘上又敲完了一串代码。public class ReferParentConstructor {public static void main(String[] args) {new Dog();}}class Animal {Animal(){System.out.println(“动物来了”);}}class Dog extends Animal {Dog() {super();System.out.println(“狗狗来了”);}}“子类 Dog 的构造方法中，第一行代码为 super() ，它就是用来调用父类的构造方法的。”“来看一下输出结果。”动物来了狗狗来了“当然了，在默认情况下， super() 是可以省略的，编译器会主动去调用父类的构造方法。也就是说，子类即使不使用 super() 主动调用父类的构造方法，父类的构造方法仍然会先执行。”public class ReferParentConstructor {public static void main(String[] args) {new Dog();}}class Animal {Animal(){System.out.println(“动物来了”);No. 319 &#x2F; 963学Java，就认准二哥的Java进阶之路}}class Dog extends Animal {Dog() {System.out.println(“狗狗来了”);}}“输出结果和之前一样。”动物来了狗狗来了“ super() 也可以用来调用父类的有参构造方法，这样可以提高代码的可重用性。”class Person {int id;String name;Person(int id, String name) {this.id &#x3D; id;this.name &#x3D; name;}}class Emp extends Person {float salary;Emp(int id, String name, float salary) {super(id, name);this.salary &#x3D; salary;}void display() {System.out.println(id + “ “ + name + “ “ + salary);}}public class CallParentParamConstrutor {public static void main(String[] args) {new Emp(1, “沉默王二”, 20000f).display();}}“Emp 类继承了 Person 类，也就继承了 id 和 name 字段，当在 Emp 中新增了 salary 字段后，构造方法中就可以使用 super(id, name) 来调用父类的有参构造方法。”“来看一下输出结果。”No. 320 &#x2F; 963三妹点了点头，所有所思。GitHub 上标星 7600+ 的开源知识库《二哥的 Java 进阶之路》第一版 PDF 终于来了！包括Java基础语法、数组&amp;字符串、OOP、集合框架、Java IO、异常处理、Java 新特性、网络编程、NIO、并发编程、JVM等等，共计 32 万余字，可以说是通俗易懂、风趣幽默……详情戳：太赞了，GitHub 上标星 7600+ 的 Java 教程微信搜 沉默王二 或۾描下方二维码关注二哥的原创公众号沉默王二，回复 222 即可免费领取。5.15 Java static关键字“哥，你牙龈肿痛轻点没？周一的《教妹学 Java》（二哥的Java进阶之路前身）你都没有更新，偷懒了呀！”三妹关心地问我。“今天周四了，吃了三天的药，疼痛已经减轻不少，咱妈还给我打了电话，让我买点牛黄解毒片下下火。”我面带着微笑对三妹说，“学习可不能落下，今天我们来学 Java 中 static 关键字吧。”“static 是 Java 中比较难以理解的一个关键字，也是各大公司的面试官最喜欢问到的一个知识点之一。”我喝了一口咖啡继续说道。“既然是面试重点，那我可得好好学习下。”三妹连忙说。“static 关键字的作用可以用一句话来描述：‘方便在没有创建对象的情况下进行调用，包括变量和方法’。也就是说，只要类被加载了，就可以通过类名进行访问。”我扶了扶沉重眼镜，继续说到，“static 可以用来修饰类的成员变量，以及成员方法。我们一个个来看。”1 沉默王二 20000.0学Java，就认准二哥的Java进阶之路No. 321 &#x2F; 96301、静态变量“如果在声明变量的时候使用了 static 关键字，那么这个变量就被称为静态变量。静态变量只在类加载的时候获取一次内存空间，这使得静态变量很节省内存空间。”家里的暖气有点足，我跑去开了一点窗户后继续说道。“来考虑这样一个 Student 类。”话音刚落，我就在键盘上噼里啪啦一阵敲。这段代码敲完后，我对三妹说：“假设郑州大学录取了一万名新生，那么在创建一万个 Student 对象的时候，所有的字段（name、age 和 school）都会获取到一块内存。学生的姓名和年纪不尽相同，但都属于郑州大学，如果每创建一个对象，school 这个字段都要占用一块内存的话，就很浪费，对吧？三妹。”“因此，最好将 school 这个字段设置为 static，这样就只会占用一块内存，而不是一万块。”安静的房子里又响起了一阵噼里啪啦的键盘声。“瞧，三妹。s1 和 s2 这两个引用变量存放在栈区（stack），沉默王二+18 这个对象和沉默王三+16 这个对象存放在堆区（heap），school 这个静态变量存放在静态区。”“等等，哥，栈、堆、静态区？”三妹的脸上塞满了疑惑。“哦哦，别担心，三妹，画幅图你就全明白了。”说完我就打开 draw.io 这个网址，认真地画起了图。public class Student {String name;int age;String school &#x3D; “郑州大学”;}public class Student {String name;int age;static String school &#x3D; “郑州大学”;public Student(String name, int age) {this.name &#x3D; name;this.age &#x3D; age;}public static void main(String[] args) {Student s1 &#x3D; new Student(“沉默王二”, 18);Student s2 &#x3D; new Student(“沉默王三”, 16);}}学Java，就认准二哥的Java进阶之路No. 322 &#x2F; 963学Java，就认准二哥的Java进阶之路“现在，是不是一下子就明白了？”看着这幅漂亮的手绘图，我心里有点小开心。“哇，哥，惊艳了呀！”三妹也不忘拍马屁，给我了一个大大的赞。“好了，三妹，我们来看下面这串代码。”public class Counter {int count &#x3D; 0;Counter() {count++;System.out.println(count);}public static void main(String args[]) {Counter c1 &#x3D; new Counter();Counter c2 &#x3D; new Counter();Counter c3 &#x3D; new Counter();}}“我们创建一个成员变量 count，并且在构造函数中让它自增。因为成员变量会在创建对象的时候获取内存，因此每一个对象都会有一个 count 的副本， count 的值并不会随着对象的增多而递增。”我在侃侃而谈，而三妹似乎有些不太明白。No. 323 &#x2F; 963学Java，就认准二哥的Java进阶之路“没关系，三妹，你先盲猜一下，这段代码输出的结果是什么？”“按照你的逻辑，应该输出三个 1？是这样吗？”三妹眨眨眼，有点不太自信地回答。“哎呀，不错哟。”我在 IDEA 中点了一下运行按钮，程序跑了起来。111“每创建一个 Counter 对象，count 的值就从 0 自增到 1。三妹，想一下，如果 count 是静态的呢？”“我不知道啊。”“嗯，来看下面这段代码。”public class StaticCounter {static int count &#x3D; 0;StaticCounter() {count++;System.out.println(count);}public static void main(String args[]) {StaticCounter c1 &#x3D; new StaticCounter();StaticCounter c2 &#x3D; new StaticCounter();StaticCounter c3 &#x3D; new StaticCounter();}}“来看一下输出结果。”123No. 324 &#x2F; 963“简单解释一下哈，由于静态变量只会获取一次内存空间，所以任何对象对它的修改都会得到保留，所以每创建一个对象，count 的值就会加 1，所以最终的结果是 3，明白了吧？三妹。这就是静态变量和成员变量之间的差别。”“另外，需要注意的是，由于静态变量属于一个类，所以不要通过对象引用来访问，而应该直接通过类名来访问，否则编译器会发出警告。”02、静态方法“说完静态变量，我们来说静态方法。”说完，我准备点一支华子来抽，三妹阻止了我，她指一指烟盒上的「吸烟有害身体健康」，我笑了。“好吧。”我只好喝了一口咖啡继续说，“如果方法上加了 static 关键字，那么它就是一个静态方法。”“静态方法有以下这些特征。”静态方法属于这个类而不是这个类的对象；调用静态方法的时候不需要创建这个类的对象；静态方法可以访问静态变量。“来，继续上代码”public class StaticMethodStudent {String name;int age;static String school &#x3D; “郑州大学”;public StaticMethodStudent(String name, int age) {this.name &#x3D; name;this.age &#x3D; age;}static void change() {school &#x3D; “河南大学”;}void out() {System.out.println(name + “ “ + age + “ “ + school);}public static void main(String[] args) {StaticMethodStudent.change();StaticMethodStudent s1 &#x3D; new StaticMethodStudent(“沉默王二”, 18);StaticMethodStudent s2 &#x3D; new StaticMethodStudent(“沉默王三”, 16);学Java，就认准二哥的Java进阶之路No. 325 &#x2F; 963学Java，就认准二哥的Java进阶之路s1.out();s2.out();}}“仔细听，三妹。 change() 方法就是一个静态方法，所以它可以直接访问静态变量 school，把它的值更改为河南大学；并且，可以通过类名直接调用 change() 方法，就像 StaticMethodStudent.change() 这样。”“来看一下程序的输出结果吧。”沉默王二 18 河南大学沉默王三 16 河南大学“需要注意的是，静态方法不能访问非静态变量和调用非静态方法。你看，三妹，我稍微改动一下代码，编译器就会报错。”“先是在静态方法中访问非静态变量，编译器不允许。”“然后在静态方法中访问非静态方法，编译器同样不允许。”“关于静态方法的使用，这下清楚了吧，三妹？”看着三妹点点头，我欣慰地笑了。“哥，我想到了一个问题，为什么 main 方法是静态的啊？”没想到，三妹串联知识点的功力还是不错的。“如果 main 方法不是静态的，就意味着 Java 虚拟机在执行的时候需要先创建一个对象才能调用 main 方法，而 main 方法作为程序的入口，创建一个额外的对象显得非常多余。”我不假思索的回答令三妹感到非常的钦佩。“java.lang.Math 类的几乎所有方法都是静态的，可以直接通过类名来调用，不需要创建类的对象。”No. 326 &#x2F; 96303、静态代码块“三妹，站起来活动一下，我的脖子都有点僵硬了。”我们一起走到窗户边，映入眼帘的是从天而降的雪花。三妹和我都高兴坏了，迫不及待地打开窗口，伸出手去触摸雪花的温度，那种稍纵即逝的冰凉，真的舒服极了。“北国风光，千里冰封，万里雪飘。望长城内外，惟余莽莽；大河上下，顿失滔滔。山舞银蛇，原驰蜡象，欲与天公试比高。须晴日，看红装素裹，分外妖娆。。。。。。”三妹竟然情不自禁地朗诵起了《沁园春·雪》。确实令人欣喜，这是 2020 年洛阳的第一场雪，的确令人感到开心。片刻之后。“除了静态变量和静态方法，static 关键字还有一个重要的作用。”我心情愉悦地对三妹说，“用一个 static 关键字，外加一个大括号括起来的代码被称为静态代码块。”“就像下面这串代码。”“静态代码块通常用来初始化一些静态变量，它会优先于 main() 方法执行。”“来看一下程序的输出结果吧。”public class StaticBlock {static {System.out.println(“静态代码块”);}public static void main(String[] args) {System.out.println(“main 方法”);}}静态代码块main 方法学Java，就认准二哥的Java进阶之路No. 327 &#x2F; 963“二哥，既然静态代码块先于 main() 方法执行，那没有 main() 方法的 Java 类能执行成功吗？”三妹的脑回路越来越令我敬佩了。“Java 1.6 是可以的，但 Java 7 开始就无法执行了。”我胸有成竹地回答到。“在命令行中执行 java StaticBlockNoMain 的时候，会抛出 NoClassDefFoundError 的错误。”“三妹，来看下面这个例子。”“writes 是一个静态的 ArrayList，所以不太可能在声明的时候完成初始化，因此需要在静态代码块中完成初始化。”“静态代码块在初始集合的时候，真的非常有用。在实际的项目开发中，通常使用静态代码块来加载配置文件到内存当中。”04、静态内部类“三妹啊，除了以上只写，static 还有一个不太常用的功能——静态内部类。”“Java 允许我们在一个类中声明一个内部类，它提供了一种令人信服的方式，允许我们只在一个地方使用一些变量，使代码更具有条理性和可读性。”“常见的内部类有四种，成员内部类、局部内部类、匿名内部类和静态内部类，限于篇幅原因，前三种不在我们本次的讨论范围之内，以后有机会再细说。”public class StaticBlockNoMain {static {System.out.println(“静态代码块，没有 main”);}}public class StaticBlockDemo {public static List writes &#x3D; new ArrayList&lt;&gt;();static {writes.add(“沉默王二”);writes.add(“沉默王三”);writes.add(“沉默王四”);System.out.println(“第一块”);}static {writes.add(“沉默王五”);writes.add(“沉默王六”);System.out.println(“第二块”);}}学Java，就认准二哥的Java进阶之路No. 328 &#x2F; 963学Java，就认准二哥的Java进阶之路“来看下面这个例子。”三妹有点走神，我敲了敲她的脑袋后继续说。public class Singleton {private Singleton() {}private static class SingletonHolder {public static final Singleton instance &#x3D; new Singleton();}public static Singleton getInstance() {return SingletonHolder.instance;}}“三妹，打起精神，马上就结束了。”“哦哦，这段代码看起来很别致啊，哥。”“是的，三妹，这段代码在以后创建单例的时候还会见到。”“第一次加载 Singleton 类时并不会初始化 instance，只有第一次调用 getInstance() 方法时 Java 虚拟机才开始加载 SingletonHolder 并初始化 instance，这样不仅能确保线程安全，也能保证 Singleton 类的唯一性。不过，创建单例更优雅的一种方式是使用枚举，以后再讲给你听。”“需要注意的是。第一，静态内部类不能访问外部类的所有成员变量；第二，静态内部类可以访问外部类的所有静态变量，包括私有静态变量。第三，外部类不能声明为 static。”“三妹，你看，在 Singleton 类上加 static 后，编译器就提示错误了。”三妹点了点头，所有所思。GitHub 上标星 7600+ 的开源知识库《二哥的 Java 进阶之路》第一版 PDF 终于来了！包括Java基础语法、数组&amp;字符串、OOP、集合框架、Java IO、异常处理、Java 新特性、网络编程、NIO、并发编程、JVM等等，共计 32 万余字，可以说是通俗易懂、风趣幽默……详情戳：太赞了，GitHub 上标星 7600+ 的 Java 教程微信搜 沉默王二 或۾描下方二维码关注二哥的原创公众号沉默王二，回复 222 即可免费领取。No. 329 &#x2F; 9635.16 Java final关键字“哥，今天学什么呢？”“今天学一个重要的关键字——final。 ”我面带着朴实无华的微笑回答着她，“对了，三妹，你打算考研吗？”“还没想过，我今年才大一呢，到时候再说吧，你决定。”“好吧。”我摊摊手，表示很无辜，真的是所有的决定都交给我这个哥哥了，如果决定错了，锅得背上。01、final 变量“好了，我们先来看 final 修饰的变量吧！”“被 final 修饰的变量无法重新赋值。换句话说，final 变量一旦初始化，就无法更改。”“来看这行代码。”“当尝试将 age 的值修改为 30 的时候，编译器就生气了。”“再来看这段代码。”final int age &#x3D; 18;学Java，就认准二哥的Java进阶之路No. 330 &#x2F; 963学Java，就认准二哥的Java进阶之路public class Pig {private String name;public String getName() {return name;}public void setName(String name) {this.name &#x3D; name;}}“这是一个很普通的 Java 类，它有一个字段 name。”“然后，我们创建一个测试类，并声明一个 final 修饰的 Pig 对象。”final Pig pig &#x3D; new Pig();“如果尝试将 pig 重新赋值的话，编译器同样会生气。”“但我们仍然可以去修改 pig 对象的 name。”final Pig pig &#x3D; new Pig();pig.setName(“特立独行”);System.out.println(pig.getName()); &#x2F;&#x2F; 特立独行“另外，final 修饰的成员变量必须有一个默认值，否则编译器将会提醒没有初始化。”“final 和 static 一起修饰的成员变量叫做常量，常量名必须全部大写。”public class Pig {private final int age &#x3D; 1;public static final double PRICE &#x3D; 36.5;}“有时候，我们还会用 final 关键字来修饰参数，它意味着参数在方法体内不能被再修改。”“来看下面这段代码。”No. 331 &#x2F; 963“如果尝试去修改它的话，编译器会提示以下错误。”02、final 方法“被 final 修饰的方法不能被重写。如果我们在设计一个类的时候，认为某些方法不应该被重写，就应该把它设计成 final 的。”“Thread 类就是一个例子，它本身不是 final 的，这意味着我们可以扩展它，但它的 isAlive() 方法是final 的。”“需要注意的是，该方法是一个本地（native）方法，用于确认线程是否处于活跃状态。而本地方法是由操作系统决定的，因此重写该方法并不容易实现。”“来看这段代码。”“当我们想要重写该方法的话，就会出现编译错误。”public class ArgFinalTest {public void arg(final int age) {}public void arg1(final String name) {}}public class Thread implements Runnable {public final native boolean isAlive();}public class Actor {public final void show() {}}学Java，就认准二哥的Java进阶之路No. 332 &#x2F; 963“三妹，来问你一个问题吧。”正想趁三妹回答问题的时候喝口水。“你说吧，哥。”“一个类是 final 的，和一个类不是 final，但它所有的方法都是 final 的，考虑一下，它们之间有什么区别？”“我能想到的一点，就是前者不能被继承，也就是说方法无法被重写；后者呢，可以被继承，然后追加一些非final 的方法。”还没等我把水咽下去，三妹就回答好了，着实惊呆了我。“嗯嗯嗯，没毛病没毛病，进步很大啊！”“那必须啊，谁叫我是你妹呢。”03、final 类“如果一个类使用了 final 关键字修饰，那么它就无法被继承…..”“等等，哥，我知道，String 类就是一个 final 类。”还没等我说完，三妹就抢着说到。“说得没毛病。”“那三妹你知道为什么 String 类要设计成 final 吗？”“这个还真不知道。”三妹的表情透露出这种无奈。“原因大致有 3 个。”为了实现字符串常量池为了线程安全为了 HashCode 的不可变性“想了解更详细的原因，可以一会看看我之前写的这篇文章。”为什么 Java 字符串是不可变的？“任何尝试从 final 类继承的行为将会引发编译错误。来看这段代码。”public final class Stringimplements java.io.Serializable, Comparable, CharSequence,Constable, ConstantDesc {}学Java，就认准二哥的Java进阶之路No. 333 &#x2F; 963学Java，就认准二哥的Java进阶之路public final class Writer {private String name;public String getName() {return name;}public void setName(String name) {this.name &#x3D; name;}}“尝试去继承它，编译器会提示以下错误，Writer 类是 final 的，无法继承。”“不过，类是 final 的，并不意味着该类的对象是不可变的。”“来看这段代码。”Writer writer &#x3D; new Writer();writer.setName(“沉默王二”);System.out.println(writer.getName()); &#x2F;&#x2F; 沉默王二“Writer 的 name 字段的默认值是 null，但可以通过 settter 方法将其更改为沉默王二。也就是说，如果一个类只是 final 的，那么它并不是不可变的全部条件。”“关于不可变类，我们留到后面来细讲。”不可变类“把一个类设计成 final 的，有其安全方面的考虑，但不应该故意为之，因为把一个类定义成 final 的，意味着它没办法继承，假如这个类的一些方法存在一些问题的话，我们就无法通过重写的方式去修复它。”“三妹，final 关键字我们就学到这里吧，你一会再学习一下 Java 字符串为什么是不可变的和不可变类。”我揉一揉犯困的双眼，疲惫地给三妹说，“学完这两个知识点，你会对 final 的认知更清晰一些。”“好的，二哥，我这就去学习去。你去休息会。”我起身站到阳台上，看着窗外的车水马龙，不一会儿，就发起来呆。“好想去再看一场周杰伦的演唱会，不知道 2021 有没有这个机会。”我心里这样想着，天渐渐地暗了下来。GitHub 上标星 7600+ 的开源知识库《二哥的 Java 进阶之路》第一版 PDF 终于来了！包括Java基础语法、数组&amp;字符串、OOP、集合框架、Java IO、异常处理、Java 新特性、网络编程、NIO、并发编程、JVM等等，共计 32 万余字，可以说是通俗易懂、风趣幽默……详情戳：太赞了，GitHub 上标星 7600+ 的 Java 教程微信搜 沉默王二 或۾描下方二维码关注二哥的原创公众号沉默王二，回复 222 即可免费领取。No. 334 &#x2F; 9635.17 Java instanceof关键字“三妹，今天我们来过一个非常简单的知识点，instanceof关键字。”“用不着哥你来讲了，今天就换个形式，我来讲给你听。”三妹雄赳赳气昂昂地说。instanceof 关键字的用法其实很简单：用意也非常简单，判断对象是否符合指定的类型，结果要么是 true，要么是 false。在反序列化的时候，instanceof 操作符还是蛮常用的，因为这时候我们不太确定对象属不属于指定的类型，如果不进行判断的话，就容易抛出 ClassCastException 异常。我们来建这样一个简单的类 Round：然后新增一个扩展类 Ring：这时候，我们就可以通过 instanceof 来检查 Ring 对象是否属于 Round 类型。结果会输出 true，因为 Ring 继承了 Round，也就意味着 Ring 和 Round 符合 is-a 的关系，而 instanceof操作符正是基于类与类之间的继承关系，以及类与接口之间的实现关系的。(object) instanceof (type)class Round {}class Ring extends Round {}Ring ring &#x3D; new Ring();System.out.println(ring instanceof Round);学Java，就认准二哥的Java进阶之路No. 335 &#x2F; 963学Java，就认准二哥的Java进阶之路我们再来新建一个接口 Shape：interface Shape {}然后新建 Circle 类实现 Shape 接口并继承 Round 类：class Circle extends Round implements Shape {}如果对象是由该类创建的，那么 instanceof 的结果肯定为 true。Circle circle &#x3D; new Circle();System.out.println(circle instanceof Circle);这个肯定没毛病，instanceof 就是干这个活的，大家也很好理解。那如果类型是父类呢？System.out.println(circle instanceof Round);结果肯定还是 true，因为依然符合 is-a 的关系。那如果类型为接口呢？System.out.println(circle instanceof Shape);结果仍然为 true， 因为也符合 is-a 的关系。如果要比较的对象和要比较的类型之间没有关系，当然是不能使用 instanceof 进行比较的。为了验证这一点，我们来创建一个实现了 Shape 但与 Circle 无关的 Triangle 类：class Triangle implements Shape {}这时候，再使用 instanceof 进行比较的话，编译器就报错了。System.out.println(circle instanceof Triangle);错误信息如下所示：Inconvertible types; cannot cast ‘com.itwanger.twentyfour.instanceof1.Circle’ to‘com.itwanger.twentyfour.instanceof1.Triangle’意思就是类型不匹配，不能转换，我们使用 instanceof 比较的目的，也就是希望如果结果为 true 的时候能进行类型转换。但显然 Circle 不能转为 Triangle。编译器已经提前帮我们预知了，很聪明。Java 是一门面向对象的编程语言，也就意味着除了基本数据类型，所有的类都会隐式继承 Object 类。所以下面的结果肯定也会输出 true。No. 336 &#x2F; 963学Java，就认准二哥的Java进阶之路Thread thread &#x3D; new Thread();System.out.println(thread instanceof Object);“那如果对象为 null 呢？”我这时候插话了。“这个还真的是一个好问题啊。”三妹忍不住对我竖了一个大拇指。System.out.println(null instanceof Object);只有对象才会有 null 值，所以编译器是不会报错的，只不过，对于 null 来说，instanceof 的结果为 false。因为所有的对象都可以为 null，所以也不好确定 null 到底属于哪一个类。通常，我们是这样使用 instanceof 操作符的。&#x2F;&#x2F; 先判断类型if (obj instanceof String) {&#x2F;&#x2F; 然后强制转换String s &#x3D; (String) obj;&#x2F;&#x2F; 然后才能使用}先用 instanceof 进行类型判断，然后再把 obj 强制转换成我们期望的类型再进行使用。JDK 16 的时候，instanceof 模式匹配转了正，意味着使用 instanceof 的时候更便捷了。if (obj instanceof String s) {&#x2F;&#x2F; 如果类型匹配 直接使用 s}可以直接在 if 条件判断类型的时候添加一个变量，就不需要再强转和声明新的变量了。“哇，这样就简洁了呀！”为了配合三妹，我不仅惊叹到！“好了，关于 instanceof 操作符我们就先讲到这吧，难是一点都不难，希望哥也能够很好的掌握。”三妹笑嘻嘻地说，看来她很享受这个讲的过程嘛。GitHub 上标星 7600+ 的开源知识库《二哥的 Java 进阶之路》第一版 PDF 终于来了！包括Java基础语法、数组&amp;字符串、OOP、集合框架、Java IO、异常处理、Java 新特性、网络编程、NIO、并发编程、JVM等等，共计 32 万余字，可以说是通俗易懂、风趣幽默……详情戳：太赞了，GitHub 上标星 7600+ 的 Java 教程微信搜 沉默王二 或۾描下方二维码关注二哥的原创公众号沉默王二，回复 222 即可免费领取。No. 337 &#x2F; 9635.18 Java不可变对象“二哥，你能给我说说为什么 String 是 immutable 类（不可变对象）吗？我想研究它，想知道为什么它就不可变了，这种强烈的愿望就像想研究浩瀚的星空一样。但无奈自身功力有限，始终觉得雾里看花终隔一层。”三妹的这句话里满是彩虹屁的味道。“既然三妹你说话这么好听，那我们就开始吧！”我愉快的心情就好像吃了两罐蜂蜜一样（ ）。01、什么是不可变类一个类的对象在通过构造方法创建后如果状态不会再被改变，那么它就是一个不可变（immutable）类。它的所有成员变量的赋值仅在构造方法中完成，不会提供任何 setter 方法供外部类去修改。还记得《神雕侠侣》中小龙女的古墓吗？随着那一声巨响，仅有的通道就被无情地关闭了。别较真那个密道，我这么说只是为了打开你的想象力，让你对不可变类有一个更直观的印象。自从有了多线程，生产力就被无限地放大了，所有的程序员都爱它，因为强大的硬件能力被充分地利用了。但与此同时，所有的程序员都对它心生忌惮，因为一不小心，多线程就会把对象的状态变得混乱不堪。为了保护状态的原子性、可见性、有序性，我们程序员可以说是竭尽所能。其中，synchronized（同步）关键字是最简单最入门的一种解决方案。假如说类是不可变的，那么对象的状态就也是不可变的。这样的话，每次修改对象的状态，就会产生一个新的对象供不同的线程使用，我们程序员就不必再担心并发问题了。02、常见的不可变类提到不可变类，几乎所有的程序员第一个想到的，就是 String 类。那为什么 String 类要被设计成不可变的呢？学Java，就认准二哥的Java进阶之路No. 338 &#x2F; 9631）常量池的需要字符串常量池是 Java 堆内存中一个特殊的存储区域，当创建一个 String 对象时，假如此字符串在常量池中不存在，那么就创建一个；假如已经存，就不会再创建了，而是直接引用已经存在的对象。这样做能够减少JVM 的内存开销，提高效率。2）hashCode 需要因为字符串是不可变的，所以在它创建的时候，其 hashCode 就被缓存了，因此非常适合作为哈希值（比如说作为 HashMap 的键），多次调用只返回同一个值，来提高效率。3）线程安全就像之前说的那样，如果对象的状态是可变的，那么在多线程环境下，就很容易造成不可预期的结果。而String 是不可变的，就可以在多个线程之间共享，不需要同步处理。因此，当我们调用 String 类的任何方法（比如说 trim() 、 substring() 、 toLowerCase() ）时，总会返回一个新的对象，而不影响之前的值。虽然调用 substring() 方法对 cmower 进行了截取，但 cmower 的值没有改变。除了 String 类，包装器类 Integer、Long 等也是不可变类。03、手撸一个不可变类看懂一个不可变类也许容易，但要创建一个自定义的不可变类恐怕就有点难了。但知难而进是我们作为一名优秀的程序员不可或缺的品质，正因为不容易，我们才能真正地掌握它。接下来，就请和我一起，来自定义一个不可变类吧。一个不可变类，必须要满足以下 4 个条件：1）确保类是 final 的，不允许被其他类继承*。2）确保所有的成员变量（字段）是 final 的，这样的话，它们就只能在构造方法中初始化值，并且不会在随后被修改。3）不要提供任何 setter 方法。4）如果要修改类的状态，必须返回一个新的对象。按照以上条件，我们来自定义一个简单的不可变类 Writer。String cmower &#x3D; “沉默王二，一枚有趣的程序员”;cmower.substring(0,4);System.out.println(cmower);&#x2F;&#x2F; 沉默王二，一枚有趣的程序员public final class Writer {private final String name;private final int age;public Writer(String name, int age) {this.name &#x3D; name;this.age &#x3D; age;}学Java，就认准二哥的Java进阶之路No. 339 &#x2F; 963学Java，就认准二哥的Java进阶之路public int getAge() {return age;}public String getName() {return name;}}Writer 类是 final 的，name 和 age 也是 final 的，没有 setter 方法。OK，据说这个作者分享了很多博客，广受读者的喜爱，因此某某出版社找他写了一本书（Book）。Book 类是这样定义的：public class Book {private String name;private int price;public String getName() {return name;}public void setName(String name) {this.name &#x3D; name;}public int getPrice() {return price;}public void setPrice(int price) {this.price &#x3D; price;}@Overridepublic String toString() {return “Book{“ +“name&#x3D;’” + name + ‘\’’ +“, price&#x3D;” + price +‘}’;}}2 个字段，分别是 name 和 price，以及 getter 和 setter，重写后的 toString() 方法。然后，在 Writer类中追加一个可变对象字段 book。public final class Writer {private final String name;private final int age;private final Book book;No. 340 &#x2F; 963学Java，就认准二哥的Java进阶之路public Writer(String name, int age, Book book) {this.name &#x3D; name;this.age &#x3D; age;this.book &#x3D; book;}public int getAge() {return age;}public String getName() {return name;}public Book getBook() {return book;}}并在构造方法中追加了 Book 参数，以及 Book 的 getter 方法。完成以上工作后，我们来新建一个测试类，看看 Writer 类的状态是否真的不可变。public class WriterDemo {public static void main(String[] args) {Book book &#x3D; new Book();book.setName(“二哥的 Java 进阶之路”);book.setPrice(79);Writer writer &#x3D; new Writer(“沉默王二”,18, book);System.out.println(“定价：” + writer.getBook());writer.getBook().setPrice(59);System.out.println(“促销价：” + writer.getBook());}}程序输出的结果如下所示：定价：Book{name&#x3D;’二哥的 Java 进阶之路’, price&#x3D;79}促销价：Book{name&#x3D;’二哥的 Java 进阶之路’, price&#x3D;59}糟糕，Writer 类的不可变性被破坏了，价格发生了变化。为了解决这个问题，我们需要为不可变类的定义规则追加一条内容：如果一个不可变类中包含了可变类的对象，那么就需要确保返回的是可变对象的副本。也就是说，Writer 类中的 getBook() 方法应该修改为：No. 341 &#x2F; 963这样的话，构造方法初始化后的 Book 对象就不会再被修改了。此时，运行 WriterDemo，就会发现价格不再发生变化了。04、总结不可变类有很多优点，就像之前提到的 String 类那样，尤其是在多线程环境下，它非常的安全。尽管每次修改都会创建一个新的对象，增加了内存的消耗，但这个缺点相比它带来的优点，显然是微不足道的——无非就是捡了西瓜，丢了芝麻。“好了，三妹，你应该理解了吧？”“嗯，哥，你这本《Java 进阶之路》还没有出书吧？”三妹质疑道。“害，出版社都找过来要签合同了，我只好推脱说 GitHub 破 1 万 star 再考虑，先优化吧，后面看机会。”“哦哦，原来如此啊。”三妹释然道。GitHub 上标星 7600+ 的开源知识库《二哥的 Java 进阶之路》第一版 PDF 终于来了！包括Java基础语法、数组&amp;字符串、OOP、集合框架、Java IO、异常处理、Java 新特性、网络编程、NIO、并发编程、JVM等等，共计 32 万余字，可以说是通俗易懂、风趣幽默……详情戳：太赞了，GitHub 上标星 7600+ 的 Java 教程微信搜 沉默王二 或۾描下方二维码关注二哥的原创公众号沉默王二，回复 222 即可免费领取。public Book getBook() {Book clone &#x3D; new Book();clone.setPrice(this.book.getPrice());clone.setName(this.book.getName());return clone;}定价：Book{name&#x3D;’二哥的 Java 进阶之路’, price&#x3D;79}促销价：Book{name&#x3D;’二哥的 Java 进阶之路’, price&#x3D;79}学Java，就认准二哥的Java进阶之路No. 342 &#x2F; 9635.19 Java方法重写和方法重载入冬的夜，总是来得特别的早。我静静地站在阳台，目光所及之处，不过是若隐若现的钢筋混凝土，还有那毫无情调的灯光。“哥，别站在那发呆了。今天学啥啊，七点半我就要回学校了，留给你的时间不多了，你要抓紧哦。”三妹傲娇的声音一下子把我从游离的状态拉回到了现实。“今天要学习 Java 中的方法重载与方法重写。”我迅速地走到电脑前面，打开一份 Excel 文档，看了一下《教妹学 Java（二哥的 Java 进阶之路前身）》的进度，然后对三妹说。“如果一个类有多个名字相同但参数个数不同的方法，我们通常称这些方法为方法重载。 ”我面带着朴实无华的微笑继续说，“如果方法的功能是一样的，但参数不同，使用相同的名字可以提高程序的可读性。”“如果子类具有和父类一样的方法（参数相同、返回类型相同、方法名相同，但方法体可能不同），我们称之为方法重写。 方法重写用于提供父类已经声明的方法的特殊实现，是实现多态的基础条件。”“只不过，方法重载与方法重写在名字上很相似，就像是兄弟俩，导致初学者经常把它们俩搞混。”“方法重载的英文名叫 Overloading，方法重写的英文名叫 Overriding，因此，不仅中文名很相近，英文名之间也很相近，这就更容易让初学者搞混了。”“但两者其实是完全不同的！通过下面这张图，你就能看得一清二楚。”话音刚落，我就在 IDEA 中噼里啪啦地敲了起来。两段代码，分别是方法重写和方法重载。然后，把这两段代码截图到 draw.io（一个很漂亮的在线画图网站）上，加了一些文字说明。最后，打开 Photoscape X，把两张图片合并到了一起。学Java，就认准二哥的Java进阶之路No. 343 &#x2F; 96301、方法重载“三妹，你仔细听哦。”我缓了一口气后继续说道。“在 Java 中，有两种方式可以达到方法重载的目的。”“第一，改变参数的数目。来看下面这段代码。”public class OverloadingByParamNum {public static void main(String[] args) {System.out.println(Adder.add(10, 19));System.out.println(Adder.add(10, 19, 20));}}class Adder {static int add(int a, int b) {return a + b;}static int add(int a, int b, int c) {return a + b + c;}}学Java，就认准二哥的Java进阶之路No. 344 &#x2F; 963学Java，就认准二哥的Java进阶之路“Adder 类有两个方法，第一个 add() 方法有两个参数，在调用的时候可以传递两个参数；第二个 add()方法有三个参数，在调用的时候可以传递三个参数。”“二哥，这样的代码不会显得啰嗦吗？如果有四个参数的时候就再追加一个方法？”三妹突然提了一个很尖锐的问题。“那倒是，这个例子只是为了说明方法重载的一种类型。如果参数类型相同的话，Java 提供了可变参数的方式，就像下面这样。”static int add(int … args) {int sum &#x3D; 0;for ( int a: args) {sum +&#x3D; a;}return sum;}“第二，通过改变参数类型，也可以达到方法重载的目的。来看下面这段代码。”public class OverloadingByParamType {public static void main(String[] args) {System.out.println(Adder.add(10, 19));System.out.println(Adder.add(10.1, 19.2));}}class Adder {static int add(int a, int b) {return a + b;}static double add(double a, double b) {return a + b;}}“Adder 类有两个方法，第一个 add() 方法的参数类型为 int，第二个 add() 方法的参数类型为 double。”“二哥，改变参数的数目和类型都可以实现方法重载，为什么改变方法的返回值类型就不可以呢？”三妹很能抓住问题的重点嘛。“因为仅仅改变返回值类型的话，会把编译器搞懵逼的。”我略带调皮的口吻回答她。“编译时报错优于运行时报错，所以当两个方法的名字相同，参数个数和类型也相同的时候，虽然返回值类型不同，但依然会提示方法已经被定义的错误。”No. 345 &#x2F; 963学Java，就认准二哥的Java进阶之路“你想啊，三妹。我们在调用一个方法的时候，可以指定返回值类型，也可以不指定。当不指定的时候，直接指定 add(1, 2) 的时候，编译器就不知道该调用返回 int 的 add() 方法还是返回 double 的 add() 方法，产生了歧义。”“方法的返回值只是作为方法运行后的一个状态，它是保持方法的调用者和被调用者进行通信的一个纽带，但并不能作为某个方法的‘标识’。”“二哥，我想到了一个点， main() 方法可以重载吗？”“三妹，这是个好问题啊！答案是肯定的，毕竟 main() 方法也是个方法，只不过，Java 虚拟机在运行的时候只会调用带有 String 数组的那个 main() 方法。”public class OverloadingMain {public static void main(String[] args) {System.out.println(“String[] args”);}public static void main(String args) {System.out.println(“String args”);}public static void main() {System.out.println(“无参”);}}“第一个 main() 方法的参数形式为 String[] args ，是最标准的写法；第二个 main() 方法的参数形式为 String args ，少了中括号；第三个 main() 方法没有参数。”“来看一下程序的输出结果。”String[] args“从结果中，我们可以看得出，尽管 main() 方法可以重载，但程序只认标准写法。”“由于可以通过改变参数类型的方式实现方法重载，那么当传递的参数没有找到匹配的方法时，就会发生隐式的类型转换。”No. 346 &#x2F; 963学Java，就认准二哥的Java进阶之路“如上图所示，byte 可以向上转换为 short、int、long、float 和 double，short 可以向上转换为 int、long、float 和 double，char 可以向上转换为 int、long、float 和 double，依次类推。”“三妹，来看下面这个示例。”public class OverloadingTypePromotion {void sum(int a, long b) {System.out.println(a + b);}void sum(int a, int b, int c) {System.out.println(a + b + c);}public static void main(String args[]) {OverloadingTypePromotion obj &#x3D; new OverloadingTypePromotion();obj.sum(20, 20);obj.sum(20, 20, 20);No. 347 &#x2F; 963学Java，就认准二哥的Java进阶之路}}“执行 obj.sum(20, 20) 的时候，发现没有 sum(int a, int b) 的方法，所以此时第二个 20 向上转型为long，所以调用的是 sum(int a, long b) 的方法。”“再来看一个示例。”public class OverloadingTypePromotion1 {void sum(int a, int b) {System.out.println(“int”);}void sum(long a, long b) {System.out.println(“long”);}public static void main(String args[]) {OverloadingTypePromotion1 obj &#x3D; new OverloadingTypePromotion1();obj.sum(20, 20);}}“执行 obj.sum(20, 20) 的时候，发现有 sum(int a, int b) 的方法，所以就不会向上转型为 long，调用 sum(long a, long b) 。”“来看一下程序的输出结果。”int“继续来看示例。”public class OverloadingTypePromotion2 {void sum(long a, int b) {System.out.println(“long int”);}void sum(int a, long b) {System.out.println(“int long”);}public static void main(String args[]) {OverloadingTypePromotion2 obj &#x3D; new OverloadingTypePromotion2();obj.sum(20, 20);}}“二哥，我又想到一个问题。当有两个方法 sum(long a, int b) 和 sum(int a, long b) ，参数个数相同，参数类型相同，只不过位置不同的时候，会发生什么呢？”No. 348 &#x2F; 963“当通过 obj.sum(20, 20) 来调用 sum 方法的时候，编译器会提示错误。”“不明确，编译器会很为难，究竟是把第一个 20 从 int 转成 long 呢，还是把第二个 20 从 int 转成 long，智障了！所以，不能写这样让编译器左右为难的代码。”02、方法重写“三妹，累吗？我们稍微休息一下吧。”我把眼镜摘下来，放到桌子上，闭上了眼睛，开始胡思乱想起来。2000 年，周杰伦横空出世，让青黄不接的唱片行业为之一振，由此开启了新一代天王争霸的黄金时代。2020 年，杰伦胖了，也贪玩了，一年出一张单曲都变得可遇不可求。20 年前，程序员很稀有；20 年后，程序员内卷了。时间永远不会停下脚步，明年会不会好起来呢？“哥，醒醒，你就说休息一会，没说睡着啊。赶紧，我还有半个小时就要走了。”我戴上眼镜，对三妹继续说道：“在 Java 中，方法重写需要满足以下三个规则。”重写的方法必须和父类中的方法有着相同的名字；重写的方法必须和父类中的方法有着相同的参数；必须是 is-a 的关系（继承关系）。“来看下面这段代码。”“来看一下程序的输出结果。”public class Bike extends Vehicle {public static void main(String[] args) {Bike bike &#x3D; new Bike();bike.run();}}class Vehicle {void run() {System.out.println(“车辆在跑”);}}车辆在跑学Java，就认准二哥的Java进阶之路No. 349 &#x2F; 963“Bike is-a Vehicle，自行车是一种车，没错。Vehicle 类有一个 run() 的方法，也就是说车辆可以跑，Bike继承了 Vehicle，也可以跑。但如果 Bike 没有重写 run() 方法的话，自行车就只能是‘车辆在跑’，而不是‘自行车在跑’，对吧？”“如果有了方法重写，一切就好办了。”我把鼠标移动到 Bike 类的 run() 方法，对三妹说：“你看，在方法重写的时候，IDEA 会建议使用@Override 注解，显式的表示这是一个重写后的方法，尽管可以缺省。”“来看一下程序的输出结果。”“Bike 重写了 run() 方法，也就意味着，Bike 可以跑出自己的风格。”好，接下来说一下重写时应当遵守的 12 条规则，应当谨记哦。规则一：只能重写继承过来的方法。因为重写是在子类重新实现从父类继承过来的方法时发生的，所以只能重写继承过来的方法，这很好理解。这就意味着，只能重写那些被 public、protected 或者 default 修饰的方法，private 修饰的方法无法被重写。Animal 类有 move() 、 eat() 和 sleep() 三个方法：public class Bike extends Vehicle {@Overridevoid run() {System.out.println(“自行车在跑”);}public static void main(String[] args) {Bike bike &#x3D; new Bike();bike.run();}}class Vehicle {void run() {System.out.println(“车辆在跑”);}}自行车在跑public class Animal {public void move() { }protected void eat() { }void sleep(){ }}学Java，就认准二哥的Java进阶之路No. 350 &#x2F; 963Dog 类来重写这三个方法：OK，完全没有问题。但如果父类中的方法是 private 的，就行不通了。此时，Dog 类中的 move() 方法就不再是一个重写方法了，因为父类的 move() 方法是 private 的，对子类并不可见。规则二：final、static 的方法不能被重写。一个方法是 final 的就意味着它无法被子类继承到，所以就没办法重写。由于父类 Animal 中的 move() 是 final 的，所以子类在尝试重写该方法的时候就出现编译错误了！同样的，如果一个方法是 static 的，也不允许重写，因为静态方法可用于父类以及子类的所有实例。重写的目的在于根据对象的类型不同而表现出多态，而静态方法不需要创建对象就可以使用。没有了对象，重写所需要的“对象的类型”也就没有存在的意义了。public class Dog extends Animal {public void move() { }protected void eat() { }void sleep(){ }}public class Animal {private void move() { }}public class Dog extends Animal {public void move() { }}public class Animal {final void move() { }}public class Animal {final void move() { }}学Java，就认准二哥的Java进阶之路No. 351 &#x2F; 963规则三：重写的方法必须有相同的参数列表。Dog 类中的 eat() 方法保持了父类方法 eat() 的同一个调调，都有一个参数——String 类型的 food。一旦子类没有按照这个规则来，比如说增加了一个参数：这就不再是重写的范畴了，当然也不是重载的范畴，因为重载考虑的是同一个类。规则四：重写的方法必须返回相同的类型。父类没有返回类型：子类尝试返回 String：于是就编译出错了（返回类型不兼容）。public class Animal {void eat(String food) { }}public class Dog extends Animal {public void eat(String food) { }}public class Dog extends Animal {public void eat(String food, int amount) { }}public class Animal {void eat(String food) { }}public class Dog extends Animal {public String eat(String food) {return null;}}学Java，就认准二哥的Java进阶之路No. 352 &#x2F; 963规则五：重写的方法不能使用限制等级更严格的权限修饰符。可以这样来理解：如果被重写的方法是 default，那么重写的方法可以是 default、protected 或者 public。如果被重写的方法是 protected，那么重写的方法只能是 protected 或者 public。如果被重写的方法是 public， 那么重写的方法就只能是 public。举个例子，父类中的方法是 protected：子类中的方法可以是 public：如果子类中的方法用了更严格的权限修饰符，编译器就报错了。规则六：重写后的方法不能抛出比父类中更高级别的异常。举例来说，如果父类中的方法抛出的是 IOException，那么子类中重写的方法不能抛出 Exception，可以是IOException 的子类或者不抛出任何异常。这条规则只适用于可检查的异常。可检查（checked）异常必须在源代码中显式地进行捕获处理，不检查（unchecked）异常就是所谓的运行时异常，比如说 NullPointerException、ArrayIndexOutOfBoundsException 之类的，不会在编译器强制要求。父类抛出 IOException：子类抛出 FileNotFoundException 是可以满足重写的规则的，因为 FileNotFoundException 是 IOException的子类。如果子类抛出了一个新的异常，并且是一个 checked 异常：public class Animal {protected void eat() { }}public class Dog extends Animal {public void eat() { }}public class Animal {protected void eat() throws IOException { }}public class Dog extends Animal {public void eat() throws FileNotFoundException { }}学Java，就认准二哥的Java进阶之路No. 353 &#x2F; 963那编译器就会提示错误：但如果子类抛出的是一个 unchecked 异常，那就没有冲突：如果子类抛出的是一个更高级别的异常：编译器同样会提示错误，因为 Exception 是 IOException 的父类。规则七：可以在子类中通过 super 关键字来调用父类中被重写的方法。子类继承父类的方法而不是重新实现是很常见的一种做法，在这种情况下，可以按照下面的形式调用父类的方法：来看例子。子类重写了 eat() 方法，然后在子类的 eat() 方法中，可以在方法体的第一行通过 super.eat() 调用父类的方法，然后再增加属于自己的代码。public class Dog extends Animal {public void eat() throws FileNotFoundException, InterruptedException { }}Error:(9, 16) java: com.itwanger.overriding.Dog中的eat()无法覆盖com.itwanger.overriding.Animal中的eat()被覆盖的方法未抛出java.lang.InterruptedExceptionpublic class Dog extends Animal {public void eat() throws FileNotFoundException, IllegalArgumentException { }}public class Dog extends Animal {public void eat() throws Exception { }}Error:(9, 16) java: com.itwanger.overriding.Dog中的eat()无法覆盖com.itwanger.overriding.Animal中的eat()被覆盖的方法未抛出java.lang.Exceptionsuper.overriddenMethodName();public class Animal {protected void eat() { }}学Java，就认准二哥的Java进阶之路No. 354 &#x2F; 963规则八：构造方法不能被重写。因为构造方法很特殊，而且子类的构造方法不能和父类的构造方法同名（类名不同），所以构造方法和重写之间没有任何关系。规则九：如果一个类继承了抽象类，抽象类中的抽象方法必须在子类中被重写。先来看这样一个接口：接口中的方法默认都是抽象方法，通过反编译是可以看得到的：如果一个抽象类实现了 Animal 接口， move() 方法不是必须被重写的：但如果一个类继承了抽象类 AbstractDog，那么 Animal 接口中的 move() 方法和抽象类 AbstractDog 中的抽象方法 bark() 都必须被重写：public class Dog extends Animal {public void eat() {super.eat();&#x2F;&#x2F; Dog-eat}}public interface Animal {void move();}public interface Animal{public abstract void move();}public abstract class AbstractDog implements Animal {protected abstract void bark();}public class BullDog extends AbstractDog {public void move() {}protected void bark() {}}学Java，就认准二哥的Java进阶之路No. 355 &#x2F; 963规则十：synchronized 关键字对重写规则没有任何影响。synchronized 关键字用于在多线程环境中获取和释放监听对象，因此它对重写规则没有任何影响，这就意味着 synchronized 方法可以去重写一个非同步方法。规则十一：strictfp 关键字对重写规则没有任何影响。如果你想让浮点运算更加精确，而且不会因为硬件平台的不同导致执行的结果不一致的话，可以在方法上添加 strictfp 关键字，之前讲过。因此 strictfp 关键字和重写规则无关。03、总结“好了，三妹，我来简单做个总结。”我瞥了一眼电脑右上角的时钟，离三妹离开的时间不到 10 分钟了。“首先来说一下方法重载时的注意事项，‘两同一不同’。”“‘两同’：在同一个类，方法名相同。”“‘一不同’：参数不同。”“再来说一下方法重写时的注意事项，‘两同一小一大’。”“‘两同’：方法名相同，参数相同。”“‘一小’：子类方法声明的异常类型要比父类小一些或者相等。”“‘一大’：子类方法的访问权限应该比父类的更大或者相等。”“记住了吧？三妹。带上口罩，拿好手机，咱准备出门吧。”今天限号，没法开车送三妹去学校了。GitHub 上标星 7600+ 的开源知识库《二哥的 Java 进阶之路》第一版 PDF 终于来了！包括Java基础语法、数组&amp;字符串、OOP、集合框架、Java IO、异常处理、Java 新特性、网络编程、NIO、并发编程、JVM等等，共计 32 万余字，可以说是通俗易懂、风趣幽默……详情戳：太赞了，GitHub 上标星 7600+ 的 Java 教程微信搜 沉默王二 或۾描下方二维码关注二哥的原创公众号沉默王二，回复 222 即可免费领取。学Java，就认准二哥的Java进阶之路No. 356 &#x2F; 9635.20 Java注解“二哥，这节讲注解吗？”三妹问。“是的。”我说，“注解是 Java 中非常重要的一部分，但经常被忽视也是真的。之所以这么说是因为我们更倾向成为一名注解的使用者而不是创建者。 @Override 注解用过吧？方法重写的时候用到过。但你知道怎么自定义一个注解吗？”三妹毫不犹豫地摇摇头，摆摆手，不好意思地承认自己的确没有自定义过。“好吧，哥来告诉你吧。”注解（Annotation）是在 Java 1.5 时引入的概念，同 class 和 interface 一样，也属于一种类型。注解提供了一系列数据用来装饰程序代码（类、方法、字段等），但是注解并不是所装饰代码的一部分，它对代码的运行效果没有直接影响，由编译器决定该执行哪些操作。来看一段代码。学Java，就认准二哥的Java进阶之路No. 357 &#x2F; 963学Java，就认准二哥的Java进阶之路public class AutowiredTest {@Autowiredprivate String name;public static void main(String[] args) {System.out.println(“沉默王二，一枚有趣的程序员”);}}注意到 @Autowired 这个注解了吧？它本来是为 Spring（后面会讲）容器注入 Bean 的，现在被我无情地扔在了字段 name 的身上，但这段代码所在的项目中并没有启用 Spring，意味着 @Autowired 注解此时只是一个摆设。“既然只是个摆设，那你这个地方为什么还要用 @Autowired 呢？”三妹好奇地问。“傻呀你，就是给你举个例子，证明：注解对代码的运行效果没有直接影响，明白我的用意了吧？”我毫不客气地说。“哦。”三妹若有所思地说。“认真听哈，接下来给你讲讲注解的生命周期。”我瞅了瞅三妹，看她是否在专注的听，然后继续说，“注解的生命周期有 3 种策略，定义在 RetentionPolicy 枚举中。”1）SOURCE：在源文件中有效，被编译器丢弃。2）CLASS：在编译器生成的字节码文件中有效，但在运行时会被处理类文件的 JVM 丢弃。3）RUNTIME：在运行时有效。这也是注解生命周期中最常用的一种策略，它允许程序通过反射的方式访问注解，并根据注解的定义执行相应的代码。“然后我们来讲注解装饰的目标。”我看三妹还在线，就继续说。注解的目标定义了注解将适用于哪一种级别的 Java 代码上，有些注解只适用于方法，有些只适用于成员变量，有些只适用于类，有些则都适用。截止到 Java 9，注解的类型一共有 11 种，定义在 ElementType 枚举中。1）TYPE：用于类、接口、注解、枚举2）FIELD：用于字段（类的成员变量），或者枚举常量3）METHOD：用于方法4）PARAMETER：用于普通方法或者构造方法的参数5）CONSTRUCTOR：用于构造方法6）LOCAL_VARIABLE：用于变量7）ANNOTATION_TYPE：用于注解8）PACKAGE：用于包9）TYPE_PARAMETER：用于泛型参数10）TYPE_USE：用于声明语句、泛型或者强制转换语句中的类型11）MODULE：用于模块No. 358 &#x2F; 963学Java，就认准二哥的Java进阶之路“哥，你将这些我都记不住，能不能直接开撸注解呀！！！！！”三妹不耐烦了。“确实哈，说再多，都不如撸个注解来得让人心动。撸个什么样的注解呢？一个字段注解吧，它用来标记对象在序列化成 JSON 的时候要不要包含这个字段。”我笑着对三妹说，“怎么样？”“好呀！”“来看下面这段代码。”@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.FIELD)public @interface JsonField {public String value() default “”;}1）JsonField 注解的生命周期是 RUNTIME，也就是运行时有效。2）JsonField 注解装饰的目标是 FIELD，也就是针对字段的。3）创建注解需要用到 @interface 关键字。4）JsonField 注解有一个参数，名字为 value，类型为 String，默认值为一个空字符串。“为什么参数名要为 value 呢？有什么特殊的含义吗？”三妹问。“当然是有的，value 允许注解的使用者提供一个无需指定名字的参数。举个例子，我们可以在一个字段上使用 @JsonField(value &#x3D; “沉默王二”) ，也可以把 value &#x3D; 省略，变成 @JsonField(“沉默王二”) 。”我说。“那 default “” 有什么特殊含义吗？”三妹继续问。“当然也是有的，它允许我们在一个字段上直接使用 @JsonField ，而无需指定参数的名和值。”我回答说。“明白了，那 @JsonField 注解已经撸好了，是不是可以使用它了呀？”三妹激动地说。“嗯，假设有一个 Writer 类，他有 3 个字段，分别是 age、name 和 bookName，后 2 个是必须序列化的字段。就可以这样来用 @JsonField 注解。”我说。public class Writer {private int age;@JsonField(“writerName”)private String name;@JsonFieldprivate String bookName;public Writer(int age, String name, String bookName) {this.age &#x3D; age;this.name &#x3D; name;this.bookName &#x3D; bookName;No. 359 &#x2F; 963学Java，就认准二哥的Java进阶之路}&#x2F;&#x2F; getter &#x2F; setter@Overridepublic String toString() {return “Writer{“ +“age&#x3D;” + age +“, name&#x3D;’” + name + ‘\’’ +“, bookName&#x3D;’” + bookName + ‘\’’ +‘}’;}}1）name 上的 @JsonField 注解提供了显式的字符串值。2）bookName 上的 @JsonField 注解使用了缺省项。接下来，我们来编写序列化类 JsonSerializer，内容如下：public class JsonSerializer {public static String serialize(Object object) throws IllegalAccessException {Class&lt;?&gt; objectClass &#x3D; object.getClass();Map jsonElements &#x3D; new HashMap&lt;&gt;();for (Field field : objectClass.getDeclaredFields()) {field.setAccessible(true);if (field.isAnnotationPresent(JsonField.class)) {jsonElements.put(getSerializedKey(field), (String)field.get(object));}}return toJsonString(jsonElements);}private static String getSerializedKey(Field field) {String annotationValue &#x3D; field.getAnnotation(JsonField.class).value();if (annotationValue.isEmpty()) {return field.getName();} else {return annotationValue;}}private static String toJsonString(Map jsonMap) {String elementsString &#x3D; jsonMap.entrySet().stream().map(entry -&gt; “\”” + entry.getKey() + “\”:\”” + entry.getValue() +“\””).collect(Collectors.joining(“,”));return “{“ + elementsString + “}”;}}No. 360 &#x2F; 963学Java，就认准二哥的Java进阶之路“JsonSerializer 类的内容看起来似乎有点多啊，二哥，我有点看不懂。”三妹说。“不要怕，我一点点来解释，直到你搞明白为止。”1） serialize() 方法是用来序列化对象的，它接收一个 Object 类型的参数。objectClass.getDeclaredFields() 通过反射的方式获取对象声明的所有字段，然后进行 for 循环遍历。在 for 循环中，先通过 field.setAccessible(true) 将反射对象的可访问性设置为 true，供序列化使用（如果没有这个步骤的话，private 字段是无法获取的，会抛出 IllegalAccessException 异常）；再通过isAnnotationPresent() 判断字段是否装饰了 JsonField 注解，如果是的话，调用getSerializedKey() 方法，以及获取该对象上由此字段表示的值，并放入 jsonElements 中。2） getSerializedKey() 方法用来获取字段上注解的值，如果注解的值是空的，则返回字段名。3） toJsonString() 方法借助 Stream 流的方式返回格式化后的 JSON 字符串。Stream 流你还没有接触过，不过没关系，后面我再给你讲。“现在是不是豁然开朗了？”我问三妹，看到三妹点了点头，我继续说，“接下来，我们来写一个测试类JsonFieldTest。”public class JsonFieldTest {public static void main(String[] args) throws IllegalAccessException {Writer cmower &#x3D; new Writer(18,”沉默王二”,”Web全栈开发进阶之路”);System.out.println(JsonSerializer.serialize(cmower));}}程序输出结果如下：{“bookName”:”Web全栈开发进阶之路”,”writerName”:”沉默王二”}从结果上来看：1）Writer 类的 age 字段没有装饰 @JsonField 注解，所以没有序列化。2）Writer 类的 name 字段装饰了 @JsonField 注解，并且显示指定了字符串“writerName”，所以序列化后变成了 writerName。3）Writer 类的 bookName 字段装饰了 @JsonField 注解，但没有显式指定值，所以序列化后仍然是bookName。“怎么样，三妹，是不是也不是特别难？”我对三妹说。“撸个注解好像真没什么难度，但你接下来的那个 JsonSerializer 我还需要再消化一下。”三妹很认真地说。“嗯，你好好复习下，我看会《编译原理》。”说完我拿起桌子边上的一本书就走了。GitHub 上标星 7600+ 的开源知识库《二哥的 Java 进阶之路》第一版 PDF 终于来了！包括Java基础语法、数组&amp;字符串、OOP、集合框架、Java IO、异常处理、Java 新特性、网络编程、NIO、并发编程、JVM等等，共计 32 万余字，可以说是通俗易懂、风趣幽默……详情戳：太赞了，GitHub 上标星 7600+ 的 Java 教程微信搜 沉默王二 或۾描下方二维码关注二哥的原创公众号沉默王二，回复 222 即可免费领取。No. 361 &#x2F; 9635.21 Java枚举（enum）“今天我们来学习枚举吧，三妹！”我说，“同学让你去她家玩了两天，感觉怎么样呀？”“心情放松了不少。”三妹说，“可以开始学 Java 了，二哥。”“OK。”“枚举（enum），是 Java 1.5 时引入的关键字，它表示一种特殊类型的类，继承自 java.lang.Enum。”“我们来新建一个枚举 PlayerType。”“二哥，我没看到有继承关系呀！”“别着急，看一下反编译后的字节码，你就明白了。”public enum PlayerType {TENNIS,FOOTBALL,BASKETBALL}public final class PlayerType extends Enum{public static PlayerType[] values(){return (PlayerType[])$VALUES.clone();}public static PlayerType valueOf(String name){return (PlayerType)Enum.valueOf(com&#x2F;cmower&#x2F;baeldung&#x2F;enum1&#x2F;PlayerType, name);学Java，就认准二哥的Java进阶之路No. 362 &#x2F; 963学Java，就认准二哥的Java进阶之路}private PlayerType(String s, int i){super(s, i);}public static final PlayerType TENNIS;public static final PlayerType FOOTBALL;public static final PlayerType BASKETBALL;private static final PlayerType $VALUES[];static{TENNIS &#x3D; new PlayerType(“TENNIS”, 0);FOOTBALL &#x3D; new PlayerType(“FOOTBALL”, 1);BASKETBALL &#x3D; new PlayerType(“BASKETBALL”, 2);$VALUES &#x3D; (new PlayerType[] {TENNIS, FOOTBALL, BASKETBALL});}}“看到没？Java 编译器帮我们做了很多隐式的工作，不然手写一个枚举就没那么省心省事了。”要继承 Enum 类；要写构造方法；要声明静态变量和数组；要用 static 块来初始化静态变量和数组；要提供静态方法，比如说 values() 和 valueOf(String name) 。“确实，作为开发者，我们的代码量减少了，枚举看起来简洁明了。”三妹说。“既然枚举是一种特殊的类，那它其实是可以定义在一个类的内部的，这样它的作用域就可以限定于这个外部类中使用。”我说。public class Player {private PlayerType type;public enum PlayerType {TENNIS,FOOTBALL,BASKETBALL}public boolean isBasketballPlayer() {return getType() &#x3D;&#x3D; PlayerType.BASKETBALL;}public PlayerType getType() {return type;No. 363 &#x2F; 963学Java，就认准二哥的Java进阶之路}public void setType(PlayerType type) {this.type &#x3D; type;}}PlayerType 就相当于 Player 的内部类。由于枚举是 final 的，所以可以确保在 Java 虚拟机中仅有一个常量对象，基于这个原因，我们可以使用“&#x3D;&#x3D;”运算符来比较两个枚举是否相等，参照 isBasketballPlayer() 方法。“那为什么不使用 equals() 方法判断呢？”三妹问。if(player.getType().equals(Player.PlayerType.BASKETBALL)){};“我来给你解释下。”“&#x3D;&#x3D;”运算符比较的时候，如果两个对象都为 null，并不会发生 NullPointerException ，而 equals() 方法则会。另外， “&#x3D;&#x3D;”运算符会在编译时进行检查，如果两侧的类型不匹配，会提示错误，而 equals() 方法则不会。“枚举还可用于 switch 语句，和基本数据类型的用法一致。”我说。switch (playerType) {case TENNIS:return “网球运动员费德勒”;case FOOTBALL:return “足球运动员C罗”;case BASKETBALL:return “篮球运动员詹姆斯”;case UNKNOWN:throw new IllegalArgumentException(“未知”);default:throw new IllegalArgumentException(“运动员类型: “ + playerType);}“如果枚举中需要包含更多信息的话，可以为其添加一些字段，比如下面示例中的 name，此时需要为枚举添加一个带参的构造方法，这样就可以在定义枚举时添加对应的名称了。”我继续说。No. 364 &#x2F; 963学Java，就认准二哥的Java进阶之路public enum PlayerType {TENNIS(“网球”),FOOTBALL(“足球”),BASKETBALL(“篮球”);private String name;PlayerType(String name) {this.name &#x3D; name;}}“get 了吧，三妹？”“嗯，比较好理解。”“那接下来，我就来说点不一样的。”“来吧，我准备好了。”“EnumSet 是一个专门针对枚举类型的 Set 接口（后面会讲）的实现类，它是处理枚举类型数据的一把利器，非常高效。”我说，“从名字上就可以看得出，EnumSet 不仅和 Set 有关系，和枚举也有关系。”“因为 EnumSet 是一个抽象类，所以创建 EnumSet 时不能使用 new 关键字。不过，EnumSet 提供了很多有用的静态工厂方法。”“来看下面这个例子，我们使用 noneOf() 静态工厂方法创建了一个空的 PlayerType 类型的 EnumSet；使用 allOf() 静态工厂方法创建了一个包含所有 PlayerType 类型的 EnumSet。”public class EnumSetTest {public enum PlayerType {TENNIS,FOOTBALL,BASKETBALL}No. 365 &#x2F; 963学Java，就认准二哥的Java进阶之路public static void main(String[] args) {EnumSet enumSetNone &#x3D; EnumSet.noneOf(PlayerType.class);System.out.println(enumSetNone);EnumSet enumSetAll &#x3D; EnumSet.allOf(PlayerType.class);System.out.println(enumSetAll);}}“来看一下输出结果。”[][TENNIS, FOOTBALL, BASKETBALL]有了 EnumSet 后，就可以使用 Set 的一些方法了，见下图。“除了 EnumSet，还有 EnumMap，是一个专门针对枚举类型的 Map 接口的实现类，它可以将枚举常量作为键来使用。EnumMap 的效率比 HashMap 还要高，可以直接通过数组下标（枚举的 ordinal 值）访问到元素。”“和 EnumSet 不同，EnumMap 不是一个抽象类，所以创建 EnumMap 时可以使用 new 关键字。”EnumMap enumMap &#x3D; new EnumMap&lt;&gt;(PlayerType.class);有了 EnumMap 对象后就可以使用 Map 的一些方法了，见下图。No. 366 &#x2F; 963学Java，就认准二哥的Java进阶之路和 HashMap（后面会讲）的使用方法大致相同，来看下面的例子。EnumMap enumMap &#x3D; new EnumMap&lt;&gt;(PlayerType.class);enumMap.put(PlayerType.BASKETBALL,”篮球运动员”);enumMap.put(PlayerType.FOOTBALL,”足球运动员”);enumMap.put(PlayerType.TENNIS,”网球运动员”);System.out.println(enumMap);System.out.println(enumMap.get(PlayerType.BASKETBALL));System.out.println(enumMap.containsKey(PlayerType.BASKETBALL));System.out.println(enumMap.remove(PlayerType.BASKETBALL));“来看一下输出结果。”{TENNIS&#x3D;网球运动员, FOOTBALL&#x3D;足球运动员, BASKETBALL&#x3D;篮球运动员}篮球运动员true篮球运动员“除了以上这些，《Effective Java》这本书里还提到了一点，如果要实现单例的话，最好使用枚举的方式。”我说。“等等二哥，单例是什么？”三妹没等我往下说，就连忙问道。“单例（Singleton）用来保证一个类仅有一个对象，并提供一个访问它的全局访问点，在一个进程中。因为这个类只有一个对象，所以就不能再使用 new 关键字来创建新的对象了。”“Java 标准库有一些类就是单例，比如说 Runtime 这个类。”Runtime runtime &#x3D; Runtime.getRuntime();“Runtime 类可以用来获取 Java 程序运行时的环境。”“关于单例，懂了些吧？”我问三妹。“噢噢噢噢。”三妹点了点头。No. 367 &#x2F; 963学Java，就认准二哥的Java进阶之路“通常情况下，实现单例并非易事，来看下面这种写法。”public class Singleton {private volatile static Singleton singleton;private Singleton (){}public static Singleton getSingleton() {if (singleton &#x3D;&#x3D; null) {synchronized (Singleton.class) {if (singleton &#x3D;&#x3D; null) {singleton &#x3D; new Singleton();}}}return singleton;}}“要用到 volatile、synchronized 关键字等等，但枚举的出现，让代码量减少到极致。”public enum EasySingleton{INSTANCE;}“就这？”三妹睁大了眼睛。“对啊，枚举默认实现了 Serializable 接口，因此 Java 虚拟机可以保证该类为单例，这与传统的实现方式不大相同。传统方式中，我们必须确保单例在反序列化期间不能创建任何新实例。”我说。“好了，关于枚举就讲这么多吧，三妹，你把这些代码都手敲一遍吧！”“好勒，这就安排。二哥，你去休息吧。”“嗯嗯。”讲了这么多，必须跑去抽烟机那里安排一根华子了。GitHub 上标星 7600+ 的开源知识库《二哥的 Java 进阶之路》第一版 PDF 终于来了！包括Java基础语法、数组&amp;字符串、OOP、集合框架、Java IO、异常处理、Java 新特性、网络编程、NIO、并发编程、JVM等等，共计 32 万余字，可以说是通俗易懂、风趣幽默……详情戳：太赞了，GitHub 上标星 7600+ 的 Java 教程微信搜 沉默王二 或۾描下方二维码关注二哥的原创公众号沉默王二，回复 222 即可免费领取。No. 368 &#x2F; 963
4 Java 集合框架  4.1 List、Set、Map、队列，全面解析
</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-Java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">1.3 Java数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-Java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">1.4 Java数据类型转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-Java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%BC%93%E5%AD%98%E6%B1%A0"><span class="toc-text">1.5 Java基本数据类型缓存池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-Java%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">1.6 Java运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7-Java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="toc-text">1.7 Java流程控制语句</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E6%95%B0%E7%BB%84-amp-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">2 数组&amp;字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E6%8E%8C%E6%8F%A1Java%E6%95%B0%E7%BB%84"><span class="toc-text">2.1 掌握Java数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E6%8E%8C%E6%8F%A1Java%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-text">2.2 掌握Java二维数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E6%89%93%E5%8D%B0Java%E6%95%B0%E7%BB%84"><span class="toc-text">2.3 打印Java数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-String%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%8F%AF%E5%8F%98"><span class="toc-text">2.5 String为什么不可变</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-%E8%AF%A6%E8%A7%A3-String-intern-%E6%96%B9%E6%B3%95"><span class="toc-text">2.7 详解 String.intern() 方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-8-String%E3%80%81StringBuilder%E3%80%81StringBuffer"><span class="toc-text">2.8 String、StringBuilder、StringBuffer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-9-String%E7%9B%B8%E7%AD%89%E5%88%A4%E6%96%AD"><span class="toc-text">2.9 String相等判断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-10-String%E6%8B%BC%E6%8E%A5"><span class="toc-text">2.10 String拼接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-11-String%E6%8B%86%E5%88%86"><span class="toc-text">2.11 String拆分</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B"><span class="toc-text">3 面向对象编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-Java%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-text">3.1 Java中的类和对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-Java%E4%B8%AD%E7%9A%84%E5%8C%85"><span class="toc-text">3.2 Java中的包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-Java%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F"><span class="toc-text">3.3 Java中的变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-Java%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">3.4 Java中的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-Java%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-text">3.5 Java可变参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-Java-native%E6%96%B9%E6%B3%95"><span class="toc-text">3.6 Java native方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-Java%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-text">3.7 Java构造方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-8-Java%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">3.8 Java访问权限修饰符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-9-Java%E4%BB%A3%E7%A0%81%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9D%97"><span class="toc-text">3.9 Java代码初始化块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-10-Java%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-text">3.10 Java抽象类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-11-Java%E6%8E%A5%E5%8F%A3"><span class="toc-text">3.11 Java接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-12-Java%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">3.12 Java内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-13-Java%E5%B0%81%E8%A3%85%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81"><span class="toc-text">3.13 Java封装继承多态</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6"><span class="toc-text">4 Java 集合框架</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 By 鲸落</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">I wish you to become your own sun, no need to rely on who's light.</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async src="https://cdn1.tianli0.top/npm/vue@2.6.14/dist/vue.min.js"></script><script async src="https://cdn1.tianli0.top/npm/element-ui@2.15.6/lib/index.js"></script><script async src="https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script><script defer type="text/javascript" src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script defer src="https://cdn1.tianli0.top/gh/nextapps-de/winbox/dist/winbox.bundle.min.js"></script><script async src="//at.alicdn.com/t/c/font_4233300_xxm4hpxio1.js"></script><script async src="/js/fps.js"></script><script async src="https://cdn.wpon.cn/2022-sucai/Gold-ingot.js"></script><script defer data-pjax src="/js/cat.js"></script><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><canvas id="snow"></canvas><script defer src="/js/fomal.js"></script><script defer src="/js/cursor.js"></script><script defer src="/live2d-widget/autoload.js"></script><script async src="/js/title.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var qweather_key = 'b16a1fa0e63c46a4b8f28abfb06ae3fe';
  var gaud_map_key = 'e2b04289e870b005374ee030148d64fd&s=rsv3';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '113.34532,23.15624';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 190px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 160px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(http://p0.itc.cn/images03/20200525/332e1ea10c634cbfaf0dfc5b69d00a3c.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Docker/&quot;);" href="javascript:void(0);">Docker</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr">Docker</span></li><li class="categoryBar-list-item" style="background:url(http://p8.itc.cn/images03/20200525/377f4f7044fe49b0bb932f43ef4f4891.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Hexo魔改教程/&quot;);" href="javascript:void(0);">Hexo魔改教程</a><span class="categoryBar-list-count">12</span><span class="categoryBar-list-descr">Hexo魔改教程</span></li><li class="categoryBar-list-item" style="background:url(http://p8.itc.cn/images03/20200525/0ed549edde2c4d5eaecc2824e753ca74.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/面试题/&quot;);" href="javascript:void(0);">面试题</a><span class="categoryBar-list-count">10</span><span class="categoryBar-list-descr">MySQL</span></li><li class="categoryBar-list-item" style="background:url(http://p6.itc.cn/images03/20200525/8dedcdf6ace44a50a1deb6a9743821fe.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/MySQL/&quot;);" href="javascript:void(0);">MySQL</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr">面试题</span></li><li class="categoryBar-list-item" style="background:url(http://p8.itc.cn/images03/20200525/5f6cecf10ea04dec9a5d42bf9c4c3739.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/RabbitMQ/&quot;);" href="javascript:void(0);">RabbitMQ</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr">Redis</span></li><li class="categoryBar-list-item" style="background:url(http://p0.itc.cn/images03/20200525/332e1ea10c634cbfaf0dfc5b69d00a3c.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Redis/&quot;);" href="javascript:void(0);">Redis</a><span class="categoryBar-list-count">5</span><span class="categoryBar-list-descr">Java笔试编程真题</span></li><li class="categoryBar-list-item" style="background:url(http://p8.itc.cn/images03/20200525/377f4f7044fe49b0bb932f43ef4f4891.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/面渣笔记/&quot;);" href="javascript:void(0);">面渣笔记</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">Java数据结构与算法</span></li><li class="categoryBar-list-item" style="background:url(http://p8.itc.cn/images03/20200525/0ed549edde2c4d5eaecc2824e753ca74.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Kafka/&quot;);" href="javascript:void(0);">Kafka</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(http://p6.itc.cn/images03/20200525/8dedcdf6ace44a50a1deb6a9743821fe.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Java笔试编程真题/&quot;);" href="javascript:void(0);">Java笔试编程真题</a><span class="categoryBar-list-count">44</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/面试/&quot;);" href="javascript:void(0);">面试</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/设计模式/&quot;);" href="javascript:void(0);">设计模式</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Java数据结构与算法/&quot;);" href="javascript:void(0);">Java数据结构与算法</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v6.2.0" title=""><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.9.0" title=""><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="https://npm.elemecdn.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.js"></script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/1b4308aa.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-17</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/1b4308aa.html&quot;);" href="javascript:void(0);" alt="">美团校招笔试编程真题（2023.4.8）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/1b4308aa.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/a449f40d.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-22</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/a449f40d.html&quot;);" href="javascript:void(0);" alt="">美的校招笔试编程真题（2023.4.19）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/a449f40d.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/b2891dfd.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-14</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/b2891dfd.html&quot;);" href="javascript:void(0);" alt="">美团校招笔试编程真题（2023.3.11）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/b2891dfd.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/f53a714c.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/f53a714c.html&quot;);" href="javascript:void(0);" alt="">美团校招笔试编程真题（2023.4.29）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/f53a714c.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/7b50e04c.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/7b50e04c.html&quot;);" href="javascript:void(0);" alt="">美团校招笔试编程真题（2023.5.13）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/7b50e04c.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/9a879128.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/9a879128.html&quot;);" href="javascript:void(0);" alt="">美团校招笔试编程真题（2023.4.23）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/9a879128.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/f84cb424.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-17</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/f84cb424.html&quot;);" href="javascript:void(0);" alt="">美团校招笔试编程真题（2023.4.15）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/f84cb424.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/cf815277.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-15</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/cf815277.html&quot;);" href="javascript:void(0);" alt="">美团校招笔试编程真题（2023.3.18）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/cf815277.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/6482affa.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/6482affa.html&quot;);" href="javascript:void(0);" alt="">美团校招笔试编程真题及其解析（2023.3.25）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/6482affa.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/843d6f38.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/843d6f38.html&quot;);" href="javascript:void(0);" alt="">美团校招笔试编程真题及其解析（2023.3.4）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/843d6f38.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/f51f72fb.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-06</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/f51f72fb.html&quot;);" href="javascript:void(0);" alt="">美团2024届秋招笔试第二场编程真题（2023.8.19）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/f51f72fb.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/7a556a2f.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-14</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/7a556a2f.html&quot;);" href="javascript:void(0);" alt="">美团2024届秋招笔试编程真题（2023.9.9）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/7a556a2f.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/61f68248.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/61f68248.html&quot;);" href="javascript:void(0);" alt="">美团2024届秋招笔试第四场编程真题（2023.9.2）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/61f68248.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/5b7a3f2a.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-07</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/5b7a3f2a.html&quot;);" href="javascript:void(0);" alt="">美团2024届秋招笔试第三场编程真题（2023.8.26）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/5b7a3f2a.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/860131f4.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-04</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/860131f4.html&quot;);" href="javascript:void(0);" alt="">美团2024届秋招笔试第一场编程真题（2023.8.12）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/860131f4.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/f9fa8a74.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/f9fa8a74.html&quot;);" href="javascript:void(0);" alt="">科大讯飞校招笔试编程真题（2023.7.29）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/f9fa8a74.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/6da30861.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/6da30861.html&quot;);" href="javascript:void(0);" alt="">科大讯飞校招笔试编程真题（2023.7.8）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/6da30861.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/f766fbc2.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/f766fbc2.html&quot;);" href="javascript:void(0);" alt="">科大讯飞校招笔试编程真题（2023.8.31）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/f766fbc2.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/10ab47eb.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/10ab47eb.html&quot;);" href="javascript:void(0);" alt="">科大讯飞校招笔试编程真题（2023.7.1）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/10ab47eb.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2efb0d75.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2efb0d75.html&quot;);" href="javascript:void(0);" alt="">科大讯飞校招笔试编程真题（2023.7.22）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2efb0d75.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/815405c2.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/815405c2.html&quot;);" href="javascript:void(0);" alt="">科大讯飞校招笔试编程真题及其解析（2023.8.13）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/815405c2.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/7641fb6a.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/7641fb6a.html&quot;);" href="javascript:void(0);" alt="">科大讯飞校招笔试编程真题（2022.10.14）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/7641fb6a.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/52772af7.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/52772af7.html&quot;);" href="javascript:void(0);" alt="">科大讯飞校招笔试编程真题及其解析（2023.7.15）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/52772af7.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/a135cfaa.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/a135cfaa.html&quot;);" href="javascript:void(0);" alt="">携程校招笔试编程真题及其解析（2023.9.7）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/a135cfaa.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/b264b8b5.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-26</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/b264b8b5.html&quot;);" href="javascript:void(0);" alt="">携程校招笔试编程真题及其解析（2023.9.21）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/b264b8b5.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/c442a03f.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-26</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/c442a03f.html&quot;);" href="javascript:void(0);" alt="">携程校招笔试编程真题及其解析（2023.5.4）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/c442a03f.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/1b7134f2.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/1b7134f2.html&quot;);" href="javascript:void(0);" alt="">携程校招笔试编程真题及其解析（2023.4.15）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/1b7134f2.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/faa64596.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/faa64596.html&quot;);" href="javascript:void(0);" alt="">携程校招笔试编程真题及其解析（2023.5.25）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/faa64596.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/aeeccc.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/aeeccc.html&quot;);" href="javascript:void(0);" alt="">携程校招笔试编程真题及其解析（2023.3.7）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/aeeccc.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/d3a0cf14.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-26</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/d3a0cf14.html&quot;);" href="javascript:void(0);" alt="">携程校招笔试编程真题及其解析（2023.3.29）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/d3a0cf14.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/cc63a592.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/cc63a592.html&quot;);" href="javascript:void(0);" alt="">携程校招笔试编程真题及其解析（2023.3.16）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/cc63a592.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2ec06a90.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-23</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2ec06a90.html&quot;);" href="javascript:void(0);" alt="">恒生电子校招笔试编程真题（2023.9.22）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2ec06a90.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/acdf6806.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-27</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/acdf6806.html&quot;);" href="javascript:void(0);" alt="">微众银行校招笔试编程真题及其解析（2023.9.3）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/acdf6806.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/7520a94a.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-27</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/7520a94a.html&quot;);" href="javascript:void(0);" alt="">微众银行校招笔试编程真题及其解析（2023.9.13）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/7520a94a.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/ac4bafef.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-27</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/ac4bafef.html&quot;);" href="javascript:void(0);" alt="">微众银行校招笔试编程真题及其解析（2023.4.12）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/ac4bafef.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/5357b25a.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-27</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/5357b25a.html&quot;);" href="javascript:void(0);" alt="">微众银行校招笔试编程真题及其解析（2023.4.23）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/5357b25a.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/bad939ec.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-22</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/bad939ec.html&quot;);" href="javascript:void(0);" alt="">小红书校招笔试编程真题（2023.8.6）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/bad939ec.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/92b4cb69.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-22</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/92b4cb69.html&quot;);" href="javascript:void(0);" alt="">小红书校招笔试编程真题（2023.8.19）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/92b4cb69.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/4ce12134.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-22</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/4ce12134.html&quot;);" href="javascript:void(0);" alt="">小红书校招笔试编程真题（2023.7.23）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/4ce12134.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/9578e9c1.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-22</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/9578e9c1.html&quot;);" href="javascript:void(0);" alt="">小红书校招笔试编程真题（2023.4.9）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/9578e9c1.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/befb4d57.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-22</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/befb4d57.html&quot;);" href="javascript:void(0);" alt="">小红书校招笔试编程真题（2023.5.7）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/befb4d57.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/7d093ba9.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-22</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/7d093ba9.html&quot;);" href="javascript:void(0);" alt="">小红书校招笔试编程真题（2023.4.23）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/7d093ba9.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/8f70f515.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-22</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/8f70f515.html&quot;);" href="javascript:void(0);" alt="">小红书校招笔试编程真题（2023.3.26）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/8f70f515.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/7ec90956.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/7ec90956.html&quot;);" href="javascript:void(0);" alt="">Java进阶之路</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/7ec90956.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/3cbc845.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/3cbc845.html&quot;);" href="javascript:void(0);" alt="">Java数据结构与算法</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/3cbc845.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/f9c52cbb.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-19</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/f9c52cbb.html&quot;);" href="javascript:void(0);" alt="">设计模式面试篇-参考回答</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/f9c52cbb.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/eabb6106.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-12</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/eabb6106.html&quot;);" href="javascript:void(0);" alt="">消息中间件面试题-参考回答</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/eabb6106.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/27f853cc.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/27f853cc.html&quot;);" href="javascript:void(0);" alt="">框架篇面试题-参考回答</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/27f853cc.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/6ba374e2.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/6ba374e2.html&quot;);" href="javascript:void(0);" alt="">微服务面试篇-参考回答</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/6ba374e2.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/dbf9d5c9.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/dbf9d5c9.html&quot;);" href="javascript:void(0);" alt="">常见技术场景</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/dbf9d5c9.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/af15ea36.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/af15ea36.html&quot;);" href="javascript:void(0);" alt="">多线程相关面试题</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/af15ea36.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/258353ca.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/258353ca.html&quot;);" href="javascript:void(0);" alt="">kafka深入浅出，快速玩转分布式发布订阅消息系统</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/258353ca.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/6f83b1e4.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/6f83b1e4.html&quot;);" href="javascript:void(0);" alt="">Redis面试题-参考回答</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/6f83b1e4.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/37cf2cfd.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/37cf2cfd.html&quot;);" href="javascript:void(0);" alt="">Redis集群</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/37cf2cfd.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/d2ba1e3f.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/d2ba1e3f.html&quot;);" href="javascript:void(0);" alt="">Redis原理篇</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/d2ba1e3f.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/6bb2589.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-12</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/6bb2589.html&quot;);" href="javascript:void(0);" alt="">Rabbitmq消息中间件（二）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/6bb2589.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/6bb2589.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-12</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/6bb2589.html&quot;);" href="javascript:void(0);" alt="">Rabbitmq消息中间件（一）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/6bb2589.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/18ab1f25.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/18ab1f25.html&quot;);" href="javascript:void(0);" alt="">MySQL面试篇-参考回答</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/18ab1f25.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/11f76754.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/11f76754.html&quot;);" href="javascript:void(0);" alt="">MySQL进阶篇</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/11f76754.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/592cf81.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/592cf81.html&quot;);" href="javascript:void(0);" alt="">MySQL运维篇</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/592cf81.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/337fcc87.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/337fcc87.html&quot;);" href="javascript:void(0);" alt="">MySQL基础篇</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/337fcc87.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/b481a8d6.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/b481a8d6.html&quot;);" href="javascript:void(0);" alt="">Java集合相关面试题</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/b481a8d6.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/c218eb30.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/c218eb30.html&quot;);" href="javascript:void(0);" alt="">JVM相关面试题</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/c218eb30.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/be6d66dc.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/be6d66dc.html&quot;);" href="javascript:void(0);" alt="">Docker安装Canal</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/be6d66dc.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/7eb663f5.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/7eb663f5.html&quot;);" href="javascript:void(0);" alt="">Docker安装OpenResty</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/7eb663f5.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/a6573b44.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/a6573b44.html&quot;);" href="javascript:void(0);" alt="">Centos7安装Docker</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/a6573b44.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/d3404069.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/d3404069.html&quot;);" href="javascript:void(0);" alt="">Redis高级篇</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/d3404069.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/a6b15897.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/a6b15897.html&quot;);" href="javascript:void(0);" alt="">Redis实战篇</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/a6b15897.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/4604f75b.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-01</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/4604f75b.html&quot;);" href="javascript:void(0);" alt="">Redis基础篇</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/4604f75b.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '1s');
    arr[i].setAttribute('data-wow-offset', '100');
    arr[i].setAttribute('data-wow-iteration', '2');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>