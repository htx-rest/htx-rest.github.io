<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java进阶之路 | 鲸落</title><meta name="author" content="鲸落"><meta name="copyright" content="鲸落"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1 Java语法基础1.1 Java关键字和保留字1、abstract： 用于声明抽象类，以及抽象方法。 1234567891011abstract class Animal &amp;#123;    abstract void makeSound();    public void sleep() &amp;#123;        System.out.println(&quot;The animal is">
<meta property="og:type" content="article">
<meta property="og:title" content="Java进阶之路">
<meta property="og:url" content="https://htx-rest.github.io/posts/7ec90956.html">
<meta property="og:site_name" content="鲸落">
<meta property="og:description" content="1 Java语法基础1.1 Java关键字和保留字1、abstract： 用于声明抽象类，以及抽象方法。 1234567891011abstract class Animal &amp;#123;    abstract void makeSound();    public void sleep() &amp;#123;        System.out.println(&quot;The animal is">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg">
<meta property="article:published_time" content="2023-09-25T02:08:49.000Z">
<meta property="article:modified_time" content="2023-09-27T03:42:18.627Z">
<meta property="article:author" content="鲸落">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="面试">
<meta property="article:tag" content="基础知识">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg"><link rel="shortcut icon" href="/"><link rel="canonical" href="https://htx-rest.github.io/posts/7ec90956.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java进阶之路',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-27 11:42:18'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_4233300_xxm4hpxio1.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/element-ui@2.15.6/packages/theme-chalk/lib/index.css"><script src="https://npm.elemecdn.com/echarts@4.9.0/dist/echarts.min.js"></script><style id="themeColor"></style><style id="rightSide"></style><style id="transPercent"></style><style id="blurNum"></style><style id="settingStyle"></style><span id="fps"></span><style id="defineBg"></style><style id="menu_shadow"></style><div id="myscoll"></div><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://tuchuang.voooe.cn/images/2023/01/02/avatar.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">84</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">122</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-youhuawenzhang"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-guidang"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei"></i><span> 分类</span></a></li><li><a class="site-page child" href="javascript:randomPost();"><i class="fa-fw iconfont icon-wode-zuji-copy"></i><span> 随便逛逛</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-xiuxianyinpin"></i><span> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/life/music/"><i class="fa-fw iconfont icon-tool"></i><span> 八音盒</span></a></li><li><a class="site-page child" href="/life/movies/"><i class="fa-fw iconfont icon-dianying"></i><span> 影院</span></a></li><li><a class="site-page child" href="/life/games/"><i class="fa-fw iconfont icon-youxi"></i><span> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-baoxiang21"></i><span> 八宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/box/gallery/"><i class="fa-fw iconfont icon-hualang"></i><span> 画廊</span></a></li><li><a class="site-page child" href="/box/animation/"><i class="fa-fw iconfont icon-donghua"></i><span> 动画</span></a></li><li><a class="site-page child" href="/box/nav/"><i class="fa-fw iconfont icon-a-06-wangzhidaohang"></i><span> 网址导航</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-tubiaozhizuomoban1"></i><span> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/social/fcircle/"><i class="fa-fw iconfont icon-iconfontzhizuobiaozhunbduan36"></i><span> 朋友圈</span></a></li><li><a class="site-page child" href="/comments/"><i class="fa-fw iconfont icon-liuyanban"></i><span> 留言板</span></a></li><li><a class="site-page child" href="/social/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-a-06-wangzhidaohang"></i><span> 网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/site/census/"><i class="fa-fw iconfont icon-a-06-wangzhidaohang"></i><span> 网站统计</span></a></li><li><a class="site-page child" href="/site/echarts/"><i class="fa-fw iconfont icon-tongji"></i><span> 文章统计</span></a></li><li><a class="site-page child" href="/site/time/"><i class="fa-fw iconfont icon-shalou"></i><span> 旧时光</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-geren"></i><span> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/personal/bb/"><i class="fa-fw iconfont icon-icon_liuyan"></i><span> 唠叨</span></a></li><li><a class="site-page child" href="/personal/love/"><i class="fa-fw iconfont icon-valentine_-email-love-message-send"></i><span> 恋爱小屋</span></a></li><li><a class="site-page child" href="/personal/about/"><i class="fa-fw iconfont icon-icon-lark-logo-old"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="鲸落"><span class="site-name">鲸落</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-youhuawenzhang"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-guidang"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei"></i><span> 分类</span></a></li><li><a class="site-page child" href="javascript:randomPost();"><i class="fa-fw iconfont icon-wode-zuji-copy"></i><span> 随便逛逛</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-xiuxianyinpin"></i><span> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/life/music/"><i class="fa-fw iconfont icon-tool"></i><span> 八音盒</span></a></li><li><a class="site-page child" href="/life/movies/"><i class="fa-fw iconfont icon-dianying"></i><span> 影院</span></a></li><li><a class="site-page child" href="/life/games/"><i class="fa-fw iconfont icon-youxi"></i><span> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-baoxiang21"></i><span> 八宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/box/gallery/"><i class="fa-fw iconfont icon-hualang"></i><span> 画廊</span></a></li><li><a class="site-page child" href="/box/animation/"><i class="fa-fw iconfont icon-donghua"></i><span> 动画</span></a></li><li><a class="site-page child" href="/box/nav/"><i class="fa-fw iconfont icon-a-06-wangzhidaohang"></i><span> 网址导航</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-tubiaozhizuomoban1"></i><span> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/social/fcircle/"><i class="fa-fw iconfont icon-iconfontzhizuobiaozhunbduan36"></i><span> 朋友圈</span></a></li><li><a class="site-page child" href="/comments/"><i class="fa-fw iconfont icon-liuyanban"></i><span> 留言板</span></a></li><li><a class="site-page child" href="/social/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-a-06-wangzhidaohang"></i><span> 网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/site/census/"><i class="fa-fw iconfont icon-a-06-wangzhidaohang"></i><span> 网站统计</span></a></li><li><a class="site-page child" href="/site/echarts/"><i class="fa-fw iconfont icon-tongji"></i><span> 文章统计</span></a></li><li><a class="site-page child" href="/site/time/"><i class="fa-fw iconfont icon-shalou"></i><span> 旧时光</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-geren"></i><span> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/personal/bb/"><i class="fa-fw iconfont icon-icon_liuyan"></i><span> 唠叨</span></a></li><li><a class="site-page child" href="/personal/love/"><i class="fa-fw iconfont icon-valentine_-email-love-message-send"></i><span> 恋爱小屋</span></a></li><li><a class="site-page child" href="/personal/about/"><i class="fa-fw iconfont icon-icon-lark-logo-old"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java进阶之路</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-09-25T02:08:49.000Z" title="发表于 2023-09-25 10:08:49">2023-09-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-27T03:42:18.627Z" title="更新于 2023-09-27 11:42:18">2023-09-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E6%B8%A3%E7%AC%94%E8%AE%B0/">面渣笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">41.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>153分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java进阶之路"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="1-Java语法基础"><a href="#1-Java语法基础" class="headerlink" title="1 Java语法基础"></a>1 Java语法基础</h1><h2 id="1-1-Java关键字和保留字"><a href="#1-1-Java关键字和保留字" class="headerlink" title="1.1 Java关键字和保留字"></a>1.1 Java关键字和保留字</h2><p>1、<strong>abstract</strong>： 用于声明抽象类，以及抽象方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">abstract class Animal &#123;</span><br><span class="line">    abstract void makeSound();</span><br><span class="line">    public void sleep() &#123;</span><br><span class="line">        System.out.println(&quot;The animal is sleeping.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">    void makeSound() &#123;</span><br><span class="line">        System.out.println(&quot;The dog barks.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们创建了一个名为 Animal 的抽象类，其中包含一个抽象方法 makeSound() 和一个具体方法 sleep() 。</p>
<p>2、<strong>boolean</strong>： Java 中的一种基本数据类型，表示布尔值，即真（true）或假（false）。boolean 数据类型常用于判断条件、循环控制和逻辑运算等场景。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">boolean isStudent = true;</span><br><span class="line">if (isStudent) &#123;</span><br><span class="line">    System.out.println(&quot;This person is a student.&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    System.out.println(&quot;This person is not a student.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们定义了一个 boolean 变量：isStudent。通过 if 语句，我们可以根据这些变量的值进行不同的操作。</p>
<p>3、<strong>break</strong>： 用于跳出循环结构（如 for、while 和 do-while 循环）或 switch 语句。当遇到 break 语句时，程序将立即跳出当前循环或 switch 语句，继续执行紧跟在循环或 switch 语句后面的代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    if (i == 5) &#123;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;i: &quot; + i);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;Loop ended.&quot;);</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们使用 for 循环遍历 0 到 9 的整数。当 i 等于 5 时，我们使用 break 语句跳出循环。</p>
<p>4、<strong>byte</strong>： 用于表示一个 8 位（1 字节）有符号整数。它的值范围是 -128（-2^7）到 127（2^7 - 1）。由于 byte 类型占用的空间较小，它通常用于处理大量的数据，如文件读写、网络传输等场景，以节省内存空间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">byte minByte = -128;</span><br><span class="line">byte maxByte = 127;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们声明了三个 byte 类型的变量：minByte、maxByte，并分别赋予了不同的值。</p>
<p>5、<strong>case</strong>： 通常与 switch 语句一起使用。switch 语句允许根据某个变量的值来选择执行不同的代码块。在 switch 语句中，case 用于标识每个可能的值和对应的代码块。例子我们直接放到 switch 中一起讲。</p>
<p>6、<strong>catch</strong>： 用于捕获 try 语句中的异常。在 try 块中可能会抛出异常，而在 catch 块中可以捕获这些异常并进行处理。catch 块可以有多个，每个 catch 块可以捕获特定类型的异常。在 catch 块中，可以根据需要进行异常处理，例如输出错误信息、进行日志记录、恢复程序状态等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    int num = Integer.parseInt(&quot;abc&quot;);</span><br><span class="line">&#125; catch (NumberFormatException e) &#123;</span><br><span class="line">    System.out.println(&quot;Invalid number format&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个程序使用 try-catch 语句捕获 NumberFormatException 异常。在 try 块中，尝试将字符串 “abc” 转换为整数类型，由于这个字符串不是有效的数字格式，将会抛出 NumberFormatException 异常。在 catch 块中，捕获到了这个异常，并输出一条错误信息。</p>
<p>7、<strong>char</strong>： 用于声明一个字符类型的变量。char 类型的变量可以存储任意的 Unicode 字符，可以使用单引号将字符括起来来表示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char c = &#x27;A&#x27;;</span><br></pre></td></tr></table></figure>
<p>这个程序创建了一个 char 类型的变量 c，并将其赋值为大写字母 A。</p>
<p>8、<strong>class</strong>： 用于声明一个类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    public Person(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    public void sayHello() &#123;</span><br><span class="line">        System.out.println(&quot;Hello, my name is &quot; + name + &quot; and I am &quot; + age + &quot; </span><br><span class="line">years old.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>9、<strong>continue</strong>： 用于继续下一个循环，可以在指定条件下跳过其余代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 1; i &lt;= 10; i++) &#123;</span><br><span class="line">    if (i % 2 == 0) &#123;</span><br><span class="line">        continue;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>10、<strong>default</strong>： 用于指定 switch 语句中除去 case 条件之外的默认代码块。这个我们放到 switch 里一起演示。</p>
<p>11、<strong>do</strong>： 通常和 while 关键字配合使用，do 后紧跟循环体。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i = 1;</span><br><span class="line">do &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    i++;</span><br><span class="line">&#125; while (i &lt;= 10);</span><br></pre></td></tr></table></figure>
<p>do-while 循环与 while 循环类似，不同之处在于 do-while 循环会先执行循环体中的代码，然后再检查循环<br>条件。因此，do-while 循环至少会执行一次循环体中的代码。</p>
<p>12、<strong>double</strong>： 用于声明一个双精度浮点类型的变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">double a = 3.14;</span><br><span class="line">double b = 2.0;</span><br><span class="line">double c = a + b;</span><br></pre></td></tr></table></figure>
<p>13、<strong>else</strong>： 用于指示 if 语句中的备用分支。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int score = 75;</span><br><span class="line">if (score &gt;= 60) &#123;</span><br><span class="line">    System.out.println(&quot;及格了&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    System.out.println(&quot;挂科了&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>14、<strong>enum</strong>： 用于定义一组固定的常量（枚举）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public enum PlayerType &#123;</span><br><span class="line">    TENNIS,</span><br><span class="line">    FOOTBALL,</span><br><span class="line">    BASKETBALL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>15、<strong>extends</strong>： 用于指示一个类是从另一个类或接口继承的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        System.out.println(&quot;动物正在吃东西&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">    public void bark() &#123;</span><br><span class="line">        System.out.println(&quot;狗在汪汪叫&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ExtendsDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Dog dog = new Dog();</span><br><span class="line">        dog.eat();</span><br><span class="line">        dog.bark();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Animal 类中有一个 eat() 方法，输出字符串 “动物正在吃东西”。Dog 类继承自 Animal 类，并定义了一个 bark() 方法，输出字符串 “狗在汪汪叫”。</p>
<p>16、<strong>final</strong>： <strong>用于表示某个变量、方法或类是最终的，不能被修改或继承。</strong></p>
<ol>
<li><p>final 变量：表示一个常量，一旦被赋值，其值就不能再被修改。这在声明不可变的值时非常有用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final double PI = 3.14159265359;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>final 方法表示一个不能被子类重写的方法。这在设计类时，确保某个方法的实现不会被子类修改时非常有用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    final void makeSound() &#123;</span><br><span class="line">        System.out.println(&quot;动物发出声音.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">    // 错误: 无法覆盖来自 Animal 的 final 方法</span><br><span class="line">    // void makeSound() &#123;</span><br><span class="line">    //     System.out.println(&quot;狗吠叫.&quot;);</span><br><span class="line">    // &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Dog dog = new Dog();</span><br><span class="line">        dog.makeSound();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>final 类表示一个不能被继承的类。这在设计类时，确保其不会被其他类继承时非常有用。<strong>String 类就是<br>final 的</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">final class Animal &#123;</span><br><span class="line">    void makeSound() &#123;</span><br><span class="line">        System.out.println(&quot;动物发出声音.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 错误: 类型 Dog 无法继承 final 类 Animal</span><br><span class="line">// class Dog extends Animal &#123;</span><br><span class="line">//     void makeSound() &#123;</span><br><span class="line">//         System.out.println(&quot;狗吠叫.&quot;);</span><br><span class="line">//     &#125;</span><br><span class="line">// &#125;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Animal animal = new Animal();</span><br><span class="line">        animal.makeSound();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>17、<strong>finally</strong>： 和 try-catch 配合使用，表示无论是否处理异常，总是执行 finally 块中的代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    int x = 10 / 0;  // 抛出异常</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    System.out.println(&quot;发生了异常：&quot; + e.getMessage());</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    System.out.println(&quot;finally 块被执行&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>18、<strong>float</strong>： 表示单精度浮点数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float f1 = 3.14f;   // 注意要在数字后面加上 f 表示这是一个 float 类型</span><br><span class="line">float f2 = 1.23e-4f;   // 科学计数法表示小数</span><br></pre></td></tr></table></figure>
<p>在 Java 中，浮点数默认是 double 类型，如果要使用 float 类型的数据，需要在数字后面加上一个 f 或者 F，表示这是一个 float 类型的字面量。另外，也可以使用科学计数法表示浮点数，例如 1.23e-4 表示 0.000123。</p>
<p>19、<strong>for</strong>： 用于声明一个 for 循环，如果循环次数是固定的，建议使用 for 循环。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int[] arr = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">    System.out.println(&quot;arr[&quot; + i + &quot;] = &quot; + arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>20、<strong>if</strong>： 用于指定条件，如果条件为真，则执行对应代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int n = -3;</span><br><span class="line">if (n &gt; 0) &#123;</span><br><span class="line">    System.out.println(n + &quot; 是正数&quot;);</span><br><span class="line">&#125; else if (n &lt; 0) &#123;</span><br><span class="line">    System.out.println(n + &quot; 是负数&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    System.out.println(n + &quot; 是零&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>21、<strong>implements</strong>： 用于实现接口。</p>
<p>下面是一个实现了 Runnable 接口的类的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class MyThread implements Runnable &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        // 线程执行的代码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>22、<strong>import</strong>： 用于导入对应的类或者接口。例如，如果要使用 Java 标准库中的 ArrayList 类，可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br></pre></td></tr></table></figure>
<p>23、<strong>instanceof</strong>： <strong>用于判断对象是否属于某个类型（class）。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">例如，假设有一个 Person 类和一个 Student 类，Student 类继承自 Person 类，可以使用 instanceof </span><br><span class="line">运算符来判断一个对象是否为 Person 类或其子类的实例：</span><br><span class="line">Person p = new Student();</span><br><span class="line">if (p instanceof Person) &#123;</span><br><span class="line">    System.out.println(&quot;p is an instance of Person&quot;);</span><br><span class="line">&#125;</span><br><span class="line">if (p instanceof Student) &#123;</span><br><span class="line">    System.out.println(&quot;p is an instance of Student&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>24、<strong>int</strong>： 用于表示整数值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int x;           // 声明一个 int 类型的变量 x</span><br><span class="line">x = 10;          // 将整数值 10 赋给变量 x</span><br><span class="line">int y = 20;     // 声明并初始化一个 int 类型的变量 y，赋值为整数值 20</span><br></pre></td></tr></table></figure>
<p>25、<strong>interface</strong>： 用于声明接口。会定义一组方法的签名（即方法名、参数列表和返回值类型），但没有方法体。其他类可以实现接口，并提供方法的具体实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface MyInterface &#123;</span><br><span class="line">    void method1();</span><br><span class="line">    int method2(String param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>26、<strong>long</strong>： 用于表示长整数值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">long x;           // 声明一个 long 类型的变量 x</span><br><span class="line">x = 10000000000L; // 将长整数值 10000000000 赋给变量 x，需要在数字后面加上 L 或 l 表示这是一个 long 类型的值</span><br><span class="line">long y = 20000000000L; // 声明并初始化一个 long 类型的变量 y，赋值为长整数值 20000000000</span><br></pre></td></tr></table></figure>
<p>27、<strong>native</strong>： <strong>用于声明一个本地方法</strong>，本地方法是指在 Java 代码中声明但在本地代码（通常是 C 或 C++ 代<br>码）中实现的方法，它通常用于与操作系统或其他本地库进行交互。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public native void nativeMethod();</span><br></pre></td></tr></table></figure>
<p>28、<strong>new</strong>： 用于创建一个新的对象。</p>
<p>以下是使用 new 关键字创建对象实例的基本语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassName obj = new ClassName();</span><br></pre></td></tr></table></figure>
<p>以下是使用 new 关键字创建数组实例的基本语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[] arr = new int[10];</span><br></pre></td></tr></table></figure>
<p>29、<strong>null</strong>： 如果一个变量是空的（什么引用也没有指向），就可以将它赋值为 null，和空指针异常息息相关。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = null; // 声明一个字符串引用，初始化为 null</span><br><span class="line">MyClass obj = null; // 声明一个 MyClass 类型的引用，初始化为 null</span><br></pre></td></tr></table></figure>
<p>30、<strong>package</strong>： 用于声明类所在的包。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.example.mypackage;</span><br></pre></td></tr></table></figure>
<p>31、<strong>private</strong>： 一个访问权限修饰符，<strong>表示方法或变量只对当前类可见。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line">    private int x; // 私有属性 x，只能在当前类的内部访问</span><br><span class="line">    private void foo() &#123;</span><br><span class="line">        // 私有方法 foo，只能在当前类的内部调用</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，MyClass 类有一个私有属性 x 和一个私有方法 foo() 。这些成员只能在 MyClass 类的内部访问和调用，对其他类不可见。</p>
<p>32、<strong>protected</strong>： 一个访问权限修饰符，<strong>表示方法或变量对同一包内的类和所有子类可见。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.example.mypackage;</span><br><span class="line">public class MyBaseClass &#123;</span><br><span class="line">    protected int x; // 受保护的属性 x，可以被子类和同一包中的其他类访问</span><br><span class="line">    protected void foo() &#123;</span><br><span class="line">        // 受保护的方法 foo，可以被子类和同一包中的其他类调用</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">package com.example.mypackage;</span><br><span class="line">public class MySubClass extends MyBaseClass &#123;</span><br><span class="line">    public void bar() &#123;</span><br><span class="line">        x = 10; // 可以访问 MyBaseClass 中的受保护属性 x</span><br><span class="line">        foo(); // 可以调用 MyBaseClass 中的受保护方法 foo</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，MyBaseClass 类有一个受保护的属性 x 和一个受保护的方法 foo() 。这些成员可以被子类和同一包中的其他类访问和调用。MySubClass 类继承自 MyBaseClass 类，并可以访问和修改 MyBaseClass 中的受保护成员。</p>
<p>33、<strong>public</strong>： 一个访问权限修饰符，除了可以声明方法和变量（所有类可见），还可以声明类。 main() 方法必须声明为 public。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line">    public int x; // 公有属性 x，可以被任何类访问</span><br><span class="line">    public void foo() &#123;</span><br><span class="line">        // 公有方法 foo，可以被任何类调用</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，MyClass 类有一个公有属性 x 和一个公有方法 foo() 。这些成员可以被任何类访问和调用，无论这些类是否在同一个包中。</p>
<p>35、<strong>return</strong>： 用于从方法中返回一个值或终止方法的执行。return 语句可以将方法的计算结果返回给调用者，或者在方法执行到某个特定条件时提前结束方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public int add(int a, int b) &#123;</span><br><span class="line">    int sum = a + b;</span><br><span class="line">    return sum; // 返回 sum 的值，并结束方法的执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外，return 语句还可以用于提前结束方法的执行。例如，假设我们要编写一个方法，用于判断一个整数是否为偶数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static boolean isEven(int number) &#123;</span><br><span class="line">    if (number % 2 == 0) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们定义了一个名为 isEven 的方法，该方法接收一个整数参数 number。如果 number 是偶数，我们使用 return 语句提前返回 true。否则，方法执行将继续，最后返回 false。</p>
<p>36、<strong>short</strong>： 用于表示短整数，占用 2 个字节（16 位）的内存空间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">short x = 10; // 声明一个 short 类型的变量 x，赋值为 10</span><br><span class="line">short y = 20; // 声明一个 short 类型的变量 y，赋值为 20</span><br></pre></td></tr></table></figure>
<p>37、<strong>static</strong>： 表示该变量或方法是<strong>静态变量或静态方法。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line">    public static int x; // 静态变量 x，属于类的成员</span><br><span class="line">    public static void foo() &#123;</span><br><span class="line">        // 静态方法 foo，属于类的成员</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，MyClass 类有一个静态变量 x 和一个静态方法 foo() 。这些成员属于类的成员，可以通过类名直接访问，不需要创建对象。</p>
<p>38、<strong>strictfp（strict floating-point）</strong>： 并不常见，通常用于修饰一个方法，用于限制浮点数计算的精度和舍入行为。当你在类、接口或方法上使用 strictfp 时，该范围内的所有浮点数计算将遵循 IEEE 754 标准的规定，以确保跨平台的浮点数计算的一致性。</p>
<p>不同的硬件平台和 JVM 实现可能对浮点数计算的精度和舍入行为有差异，这可能导致在不同环境中运行相同的浮点数计算代码产生不同的结果。使用 strictfp 关键字可以确保在所有平台上获得相同的浮点数计算结果，避免计算结果的不一致问题。</p>
<p>但请注意，使用 strictfp 可能会对性能产生影响，因为可能需要更多的计算和转换来确保遵循 IEEE 754 标准。因此，在使用 strictfp 时，需要权衡精度和一致性与性能之间的关系。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public strictfp class MyClass &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        double a = 0.1;</span><br><span class="line">        double b = 0.2;</span><br><span class="line">        double result = a + b;</span><br><span class="line">        System.out.println(&quot;Result: &quot; + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Result: 0.30000000000000004</span><br></pre></td></tr></table></figure>
<p>在这个示例中，MyClass 类被声明为 strictfp，因此类中的所有浮点数计算都将遵循 IEEE 754 标准。</p>
<p>在大多数现代操作系统上，使用 strictfp 可能不会产生显著差异，因为大家都遵循 IEEE 754 标准，除非是一些较旧的硬件平台。</p>
<p>IEEE 754 标准（IEEE Standard for Floating-Point Arithmetic）是一个定义浮点数表示和运算的国际标准。由国际电气和电子工程师协会（IEEE）制定，首次发布于1985年。</p>
<p>IEEE 754 标准主要规定了以下几个方面：</p>
<p>浮点数表示：标准定义了两种浮点数格式，单精度（32位）和双精度（64位）。这两种格式分别由符号位、指数位和尾数位组成，用于表示浮点数的大小和精度。</p>
<p>四舍五入和舍入模式：标准定义了多种舍入模式，例如向最接近的数舍入（Round to Nearest, Ties to Even）、向零舍入（Round toward Zero）、向正无穷舍入（Round toward +∞）和向负无穷舍入（Round toward -∞）等。这些模式指导了浮点数计算过程中如何处理精度损失和舍入误差。</p>
<p>特殊值：标准定义了一些特殊的浮点数值，如正无穷（+∞）、负无穷（-∞）和非数值（NaN）。这些特殊值用于表示浮点数计算中可能出现的溢出、下溢和未定义结果等情况。</p>
<p>浮点数运算：标准规定了浮点数的基本运算（加、减、乘、除）和比较运算（等于、不等于、大于、小于、大于等于、小于等于）的行为和结果。这些运算需要遵循标准中规定的表示、舍入和特殊值处理规则。</p>
<p>来看示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Ieee754Demo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        float a = 0.1f;</span><br><span class="line">        float b = 0.2f;</span><br><span class="line">        float c = a + b;</span><br><span class="line">        System.out.println(&quot;a = &quot; + a);</span><br><span class="line">        System.out.println(&quot;b = &quot; + b);</span><br><span class="line">        System.out.println(&quot;c = a + b = &quot; + c);</span><br><span class="line">        double x = 1.0 / 0.0;</span><br><span class="line">        double y = -1.0 / 0.0;</span><br><span class="line">        double z = 0.0 / 0.0;</span><br><span class="line">        System.out.println(&quot;x = 1.0 / 0.0 = &quot; + x);</span><br><span class="line">        System.out.println(&quot;y = -1.0 / 0.0 = &quot; + y);</span><br><span class="line">        System.out.println(&quot;z = 0.0 / 0.0 = &quot; + z);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<p><img src="\assets\note\image-20230925103754023.png" alt="image-20230925103754023"></p>
<p>我们可以看到 IEEE 754 标准中的浮点数表示和运算：</p>
<ul>
<li>单精度浮点数的加法：变量 a 和 b 分别存储了 0.1 和 0.2，它们的和 c 等于 0.3。由于浮点数表示的精度限制，c 的实际值可能与理论值略有误差。</li>
<li>特殊值：变量 x、y 和 z 分别存储了正无穷（+∞）、负无穷（-∞）和非数值（NaN）。这些特殊值是由除法运算产生的，当被除数为 0 或结果无法表示时，会返回相应的特殊值。</li>
</ul>
<p>39、<strong>super</strong>： 可用于<strong>调用父类的方法或者字段。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    protected String name;</span><br><span class="line">    public Animal(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        System.out.println(name + &quot; is eating.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Dog extends Animal &#123;</span><br><span class="line">    public Dog(String name) &#123;</span><br><span class="line">        super(name); // 调用父类的构造方法</span><br><span class="line">    &#125;</span><br><span class="line">    public void bark() &#123;</span><br><span class="line">        System.out.println(name + &quot; is barking.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        super.eat(); // 调用父类的方法</span><br><span class="line">        System.out.println(name + &quot; is eating bones.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>40、<strong>switch</strong>： 用于根据某个变量的值选择执行不同的代码块。switch 语句通常与 case 和 default 一起使用。每个 case 子句表示一个可能的值和对应的代码块，而 default 子句用于处理不在 case 子句中的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int dayOfWeek = 3;</span><br><span class="line">        switch (dayOfWeek) &#123;</span><br><span class="line">            case 1:</span><br><span class="line">                System.out.println(&quot;Monday&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case 2:</span><br><span class="line">                System.out.println(&quot;Tuesday&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case 3:</span><br><span class="line">                System.out.println(&quot;Wednesday&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case 4:</span><br><span class="line">                System.out.println(&quot;Thursday&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case 5:</span><br><span class="line">                System.out.println(&quot;Friday&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case 6:</span><br><span class="line">                System.out.println(&quot;Saturday&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case 7:</span><br><span class="line">                System.out.println(&quot;Sunday&quot;);</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                System.out.println(&quot;Invalid day&quot;);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们定义了一个名为 dayOfWeek 的整数变量，并赋予了一个值。然后，我们使用 switch 语句根据 dayOfWeek 的值来输出对应的星期几。每个 case 子句表示 dayOfWeek 可能的值，后面紧跟着要执行的代码。使用 break 语句跳出 switch 语句，避免执行其他 case 子句的代码。如果 dayOfWeek 的值不在 case 子句中，default 子句将被执行。</p>
<p>41、<strong>synchronized</strong>： <strong>用于指定多线程代码中的同步方法、变量或者代码块。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line">    private int count;</span><br><span class="line">    public synchronized void increment() &#123;</span><br><span class="line">        count++; // 同步方法</span><br><span class="line">    &#125;</span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">        synchronized(this) &#123; // 同步代码块</span><br><span class="line">            // 执行一些需要同步的操作</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>42、<strong>this</strong>： <strong>可用于在方法或构造方法中引用当前对象。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line">    private int num;</span><br><span class="line">    public MyClass(int num) &#123;</span><br><span class="line">        this.num = num; // 使用 this 关键字引用当前对象的成员变量</span><br><span class="line">    &#125;</span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">        System.out.println(&quot;Doing something with &quot; + this.num); // 使用 this 关键字引</span><br><span class="line">用当前对象的成员变量</span><br><span class="line">    &#125;</span><br><span class="line">    public MyClass getThis() &#123;</span><br><span class="line">        return this; // 返回当前对象本身</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，MyClass 类有一个私有成员变量 num，并定义了一个构造方法、一个方法和一个返回当前对象的方法。在构造方法中，使用 this 关键字引用当前对象的成员变量，并将传入的参数赋值给该成员变量。在方法 doSomething() 中，使用 this 关键字引用当前对象的成员变量，并输出该成员变量的值。在方法 getThis() 中，直接返回当前对象本身。</p>
<p>43、<strong>throw</strong>： 主动抛出异常。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line">    public void doSomething(int num) throws Exception &#123;</span><br><span class="line">        if (num &lt; 0) &#123;</span><br><span class="line">            throw new Exception(&quot;num must be greater than zero&quot;); // 手动抛出异常</span><br><span class="line">        &#125;</span><br><span class="line">        // 执行一些操作</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>44、<strong>throws</strong>： 用于声明异常。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line">    public void doSomething(int num) throws Exception &#123;</span><br><span class="line">        if (num &lt; 0) &#123;</span><br><span class="line">            throw new Exception(&quot;num must be greater than zero&quot;); // 手动抛出异常</span><br><span class="line">        &#125;</span><br><span class="line">        // 执行一些操作</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>45、<strong>transient</strong>：  <strong>修饰的字段不会被序列化。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass implements Serializable &#123;</span><br><span class="line">    private int id;</span><br><span class="line">    private String name;</span><br><span class="line">    private transient String password;</span><br><span class="line">    public MyClass(int id, String name, String password) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.password = password;</span><br><span class="line">    &#125;</span><br><span class="line">    // 省略 getter 和 setter 方法</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;MyClass&#123;&quot; +</span><br><span class="line">                &quot;id=&quot; + id +</span><br><span class="line">                &quot;, name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, password=&#x27;&quot; + password + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，MyClass 类实现了 Serializable 接口，表示该类的对象可以被序列化。该类有三个成员变量，分别是 id、name 和 password。其中，password 成员变量被标记为 transient，表示在序列化过程中忽略这个成员变量。</p>
<p>45、<strong>try</strong>： 用于包裹要捕获异常的代码块。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    // 可能抛出异常的代码</span><br><span class="line">    int result = 1 / 0;</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    // 异常处理代码</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>46、<strong>void</strong>： 用于指定方法没有返回值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void doSomething() &#123;</span><br><span class="line">    // 方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>47、<strong>volatile</strong>： 保证不同线程对它修饰的变量进行操作时的<strong>可见性</strong>，即一个线程修改了某个变量的值，新值对其他线程来说是立即可见的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class MyThread extends Thread &#123;</span><br><span class="line">    private volatile boolean running = true;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (running) &#123;</span><br><span class="line">            // 线程执行的代码</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void stopThread() &#123;</span><br><span class="line">        running = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，MyThread 类继承了 Thread 类，重写了 run() 方法。MyThread 类有一个成员变量 running，被标记为 volatile，表示这个变量是共享的，可能会被多个线程同时访问。在 run() 方法中，使用 while 循环检查 running 变量的值，如果 running 为 true，就继续执行循环体中的代码。在另一个方法 stopThread() 中，将 running 变量的值设置为 false，表示需要停止线程。</p>
<p>48、<strong>while</strong>： 如果循环次数不固定，建议使用 while 循环。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i = 0;</span><br><span class="line">while (i &lt; 10) &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“除了这些关键字，Java 中还有两个非常特殊的保留字（goto 和 const），它们不能在程序中使用。”“goto 在 C语言中叫做‘无限跳转’语句，在 Java 中，不再使用 goto 语句，因为无限跳转会破坏程序结构。”Java 中确实可以使用标签（label）与 break 和 continue 语句结合来实现类似 goto 的跳转功能。以下是一个简单的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class LabelDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        outerLoop:</span><br><span class="line">        for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; 3; j++) &#123;</span><br><span class="line">                if (i == 1 &amp;&amp; j == 1) &#123;</span><br><span class="line">                    System.out.println(&quot;跳过 outerLoop 中的当前迭代&quot;);</span><br><span class="line">                    continue outerLoop;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;i: &quot; + i + &quot;, j: &quot; + j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;结束&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们使用了两层嵌套循环。外层循环有一个名为 outerLoop 的标签。当 i 等于 1 且 j 等于 1 时，我们使用 continue outerLoop 语句跳过外层循环中的当前迭代。这与 goto 的行为类似。</p>
<p>来看输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">i: 0, j: 0</span><br><span class="line">i: 0, j: 1</span><br><span class="line">i: 0, j: 2</span><br><span class="line">i: 1, j: 0</span><br><span class="line">跳过 outerLoop 中的当前迭代</span><br><span class="line">i: 2, j: 0</span><br><span class="line">i: 2, j: 1</span><br><span class="line">i: 2, j: 2</span><br><span class="line">结束</span><br></pre></td></tr></table></figure>
<p>尽管可以使用标签实现类似 goto 的跳转功能，但这种用法在 Java 中仍然较少见，因为过度使用可能导致代码难以理解和维护。通常建议尽可能使用其他控制结构（如 if、for 和 while 语句）来组织代码。</p>
<p>以下是一个使用 if 和 for 语句替代标签跳转的示例。在这个示例中，我们使用了一个布尔变量 skipIteration 来决定是否跳过外层循环的当前迭代：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class IfForDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">            boolean skipIteration = false;</span><br><span class="line">            for (int j = 0; j &lt; 3; j++) &#123;</span><br><span class="line">                if (i == 1 &amp;&amp; j == 1) &#123;</span><br><span class="line">                    System.out.println(&quot;跳过外层循环中的当前迭代&quot;);</span><br><span class="line">                    skipIteration = true;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;i: &quot; + i + &quot;, j: &quot; + j);</span><br><span class="line">            &#125;</span><br><span class="line">            if (skipIteration) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，当 i 等于 1 且 j 等于 1 时，我们将 skipIteration 设置为 true，然后使用 break 语句跳出内层<br>循环。在外层循环中，我们检查 skipIteration 变量的值，如果为 true，则跳过外层循环的当前迭代。</p>
<p>这个示例的输出结果与之前的示例相同：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">i: 0, j: 0</span><br><span class="line">i: 0, j: 1</span><br><span class="line">i: 0, j: 2</span><br><span class="line">i: 1, j: 0</span><br><span class="line">跳过外层循环中的当前迭代</span><br><span class="line">i: 2, j: 0</span><br><span class="line">i: 2, j: 1</span><br><span class="line">i: 2, j: 2</span><br></pre></td></tr></table></figure>
<p>“const 在 C语言中是声明常量的关键字，在 Java 中可以使用 public static final 三个关键字的组合来达到常量的效果。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Circle &#123;</span><br><span class="line">    public static final double PI = 3.14159;</span><br><span class="line">    public static double calculateArea(double radius) &#123;</span><br><span class="line">        return PI * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们使用 public static final 关键字组合定义了一个名为 PI 的常量。因为它是 public 的，所以其他类可以访问这个常量。因为它是 static 的，所以它与类关联，而不是类的实例。因为它是 final 的，所以它的值不能被更改。</p>
<h2 id="1-2-Java注释"><a href="#1-2-Java注释" class="headerlink" title="1.2 Java注释"></a>1.2 Java注释</h2><p><img src="\assets\note\image-20230925105319358.png" alt="image-20230925105319358"></p>
<p><strong>01、单行注释 </strong></p>
<p>单行注释通常用于解释方法内某单行代码的作用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void method() &#123;</span><br><span class="line">    int age = 18; // age 用于表示年龄</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但如果写在行尾的话，其实是不符合阿里巴巴的开发规约的。</p>
<p><img src="\assets\note\image-20230925105443224.png" alt="image-20230925105443224"></p>
<p>正确的单行注释如上图中所说，在被注释语句上方另起一行，使用 // 注释。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void method() &#123;</span><br><span class="line">    // age 用于表示年龄</span><br><span class="line">    int age = 18;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>02、多行注释 </strong></p>
<p>多行注释使用的频率其实并不高，通常用于解释一段代码的作用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">age 用于表示年纪</span><br><span class="line">name 用于表示姓名</span><br><span class="line">*/</span><br><span class="line">int age = 18;</span><br><span class="line">String name = &quot;沉默&quot;;</span><br></pre></td></tr></table></figure>
<p>以 /<em> 开始，以 </em>/ 结束，但不如用多个 // 来得痛快，因为 * 和 / 不在一起，敲起来麻烦。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// age 用于表示年纪</span><br><span class="line">// name 用于表示姓名</span><br><span class="line">int age = 18;</span><br><span class="line">String name = &quot;沉默&quot;;</span><br></pre></td></tr></table></figure>
<p><strong>03、文档注释 </strong></p>
<p>文档注释可用在三个地方，类、字段和方法，用来解释它们是干嘛的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 微信搜索「二哈进阶之路」</span><br><span class="line"> */</span><br><span class="line">public class Demo &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 姓名</span><br><span class="line">     */</span><br><span class="line">    private int age;</span><br><span class="line">    /**</span><br><span class="line">     * main 方法作为程序的入口</span><br><span class="line">     *</span><br><span class="line">     * @param args 参数</span><br><span class="line">     */</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS：在 Intellij IDEA 中，按下 /<em>* 后敲下回车键就可以自动添加文档注释的格式， </em>/ 是自动补全的。</p>
<p>接下来，我们来看看如何通过 javadoc 命令生成代码文档。</p>
<p>第一步，在该类文件上右键，找到「Open in Terminal」 可以打开命令行窗口。</p>
<p><img src="\assets\note\image-20230925105809280.png" alt="image-20230925105809280"></p>
<p>第二步，执行 javadoc 命令 javadoc Demo.java -encoding utf-8 。 -encoding utf-8 可以保证中文不发生乱码。</p>
<p><img src="\assets\note\image-20230925105924721.png" alt="image-20230925105924721"></p>
<p>第三步，执行 ls -l 命令就可以看到生成代码文档时产生的文件，主要是一些可以组成网页的 html、js 和 css 文件。</p>
<p><img src="\assets\note\image-20230925110002342.png" alt="image-20230925110002342"></p>
<p>第四步，执行 open index.html 命令可以通过默认的浏览器打开文档注释。</p>
<p><img src="\assets\note\image-20230925110036341.png" alt="image-20230925110036341"></p>
<p>点击「Demo」，可以查看到该类更具体的注释文档。</p>
<p><img src="\assets\note\image-20230925110131874.png" alt="image-20230925110131874"></p>
<p><strong>04、文档注释的注意事项 </strong></p>
<p>1） javadoc 命令只能为 public 和 protected 修饰的字段、方法和类生成文档。</p>
<p>default 和 private 修饰的字段和方法的注释将会被忽略掉。因为我们本来就不希望这些字段和方法暴露给调用者。</p>
<p>如果类不是 public 的话，javadoc 会执行失败。</p>
<p><img src="\assets\note\image-20230925110225972.png" alt="image-20230925110225972"></p>
<p>2）文档注释中可以嵌入一些 HTML 标记，比如说段落标记 <p> ，超链接标记 <a></a> 等等，但不要使用标题标记，比如说 <h1> ，因为 javadoc 会插入自己的标题，容易发生冲突。</p>
<p>3）文档注释中可以插入一些 @ 注解，比如说 @see 引用其他类， @version 版本号， @param 参数标识符， @author 作者标识符， @deprecated 已废弃标识符，等等。</p>
<p><strong>05、注释规约 </strong></p>
<p>1）类、字段、方法必须使用文档注释，不能使用单行注释和多行注释。因为注释文档在 IDE 编辑窗口中可以悬浮提示，提高编码效率。</p>
<p>比如说，在使用 String 类的时候，鼠标悬停在 String 上时可以得到以下提示。</p>
<p><img src="\assets\note\image-20230925110330201.png" alt="image-20230925110330201"></p>
<p>2）所有的抽象方法(包括接口中的方法)必须要用 Javadoc 注释、除了返回值、参数、 异常说明外，还必须指出该方法做什么事情，实现什么功能。</p>
<p>3）所有的类都必须添加创建者和创建日期。</p>
<p>Intellij IDEA 中可以在「File and Code Templates」中设置。</p>
<p><img src="\assets\note\image-20230925110443800.png" alt="image-20230925110443800"></p>
<p>语法如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 微信搜索「二哈进阶之路」</span><br><span class="line">* @author 二哈</span><br><span class="line">* @date $&#123;DATE&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p>设置好后，在新建一个类的时候就可以自动生成了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 微信搜索「二哈进阶之路」</span><br><span class="line"> *</span><br><span class="line"> * @author 二哈</span><br><span class="line"> * @date 2020/11/16</span><br><span class="line"> */</span><br><span class="line">public class Test &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4）所有的枚举类型字段必须要有注释，说明每个数据项的用途。</p>
<p>5）代码修改的同时，注释也要进行相应的修改。</p>
<p>“记住一点，注释是程序固有的一部分。”</p>
<ul>
<li>第一、注释要能够准确反映设计思想和代码逻辑;</li>
<li>第二、注释要能够描述业务含 义，使别的程序员能够迅速了解到代码背后的信息。</li>
</ul>
<p>完全没有注释的大段代码对于阅读者形同 天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路;注释也是给继任者看 的，使其能够快速接替自己的工作。</p>
<h2 id="1-3-Java数据类型"><a href="#1-3-Java数据类型" class="headerlink" title="1.3 Java数据类型"></a>1.3 Java数据类型</h2><p>Java 中的数据类型可分为 2 种：</p>
<p><strong>1）基本数据类型。</strong></p>
<p>基本数据类型是 Java 语言操作数据的基础，包括 boolean、char、byte、short、int、long、float 和 double，共 8 种。</p>
<p><strong>2）引用数据类型。</strong></p>
<p>除了基本数据类型以外的类型，都是所谓的引用类型。常见的有数组（对，没错，数组是引用类型，后面我们会讲）、class（也就是类），以及接口（指向的是实现接口的类的对象）。来个思维导图，感受下。</p>
<p><img src="\assets\note\image-20230925110840637.png" alt="image-20230925110840637"></p>
<p>变量可以分为局部变量、成员变量、静态变量。</p>
<p>当变量是局部变量的时候，必须得先初始化，否则编译器不允许你使用它。拿 int 来举例吧，看下图。</p>
<p><img src="\assets\note\image-20230925110931400.png" alt="image-20230925110931400"></p>
<p>当变量是成员变量或者静态变量时，可以不进行初始化，它们会有一个默认值，仍然以 int 为例，来看代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author 微信搜「二哈进阶之路」</span><br><span class="line"> */</span><br><span class="line">public class LocalVar &#123;</span><br><span class="line">    private int a;</span><br><span class="line">    static int b;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        LocalVar lv = new LocalVar();</span><br><span class="line">        System.out.println(lv.a);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>瞧见没，int 作为成员变量时或者静态变量时的默认值是 0。那不同的基本数据类型，是有不同的默认值和大小的，来个表格感受下。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">数据类型</th>
<th style="text-align:center">默认值</th>
<th style="text-align:center">大小</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">boolean</td>
<td style="text-align:center">false</td>
<td style="text-align:center">1 比特</td>
</tr>
<tr>
<td style="text-align:center">char</td>
<td style="text-align:center">‘\u0000’</td>
<td style="text-align:center">2 字节</td>
</tr>
<tr>
<td style="text-align:center">byte</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1 字节</td>
</tr>
<tr>
<td style="text-align:center">short</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2 字节</td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">0</td>
<td style="text-align:center">4 字节</td>
</tr>
<tr>
<td style="text-align:center">long</td>
<td style="text-align:center">0L</td>
<td style="text-align:center">8 字节</td>
</tr>
<tr>
<td style="text-align:center">float</td>
<td style="text-align:center">0.0f</td>
<td style="text-align:center">4 字节</td>
</tr>
<tr>
<td style="text-align:center">double</td>
<td style="text-align:center">0.0</td>
<td style="text-align:center">8 字节</td>
</tr>
</tbody>
</table>
</div>
<p><strong>01、比特和字节 </strong></p>
<p>比特币（Bitcoin）听说过吧？字节跳动（Byte Dance）听说过吧？这些名字当然不是乱起的，确实和比特、字节有关系。</p>
<p><strong>1）bit（比特） </strong></p>
<p>比特作为信息技术的最基本存储单位，非常小，但大名鼎鼎的比特币就是以此命名的，它的简写为小写字母“b”。</p>
<p>大家都知道，计算机是以二进制存储数据的，二进制的一位，就是 1 比特，也就是说，比特要么为 0 要么为 1。</p>
<p><strong>2）Byte（字节） </strong></p>
<p>通常来说，一个英文字符是一个字节，一个中文字符是两个字节。字节与比特的换算关系是：1 字节 = 8 比特。</p>
<p>在往上的单位就是 KB，并不是 1000 字节，因为计算机只认识二进制，因此是 2 的 10 次方，也就是 1024<br>个字节。（终于知道 1024 和程序员的关系了吧？狗头保命）</p>
<p><img src="\assets\note\image-20230925111850396.png" alt="image-20230925111850396"></p>
<p><strong>02、基本数据类型 </strong></p>
<p>接下来，我们再来详细地了解一下 8 种基本数据类型。</p>
<p><strong>1）布尔 </strong></p>
<p>布尔（boolean）仅用于存储两个值：true 和 false，也就是真和假，通常用于条件的判断。代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">boolean hasMoney = true;</span><br><span class="line">boolean hasGirlFriend = false;</span><br></pre></td></tr></table></figure>
<p><strong>2）byte </strong></p>
<p>一个字节可以表示 2^8 = 256 个不同的值。由于 byte 是有符号的，它的值可以是负数或正数，其取值范围是 -128 到 127（包括 -128 和 127）。</p>
<p>在网络传输、大文件读写时，为了节省空间，常用字节来作为数据的传输方式。代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">byte b; // 声明一个 byte 类型变量</span><br><span class="line">b = 10; // 将值 10 赋给变量 b</span><br><span class="line">byte c = -100; // 声明并初始化一个 byte 类型变量 c，赋值为 -100</span><br></pre></td></tr></table></figure>
<p><strong>3）short </strong></p>
<p>short 的取值范围在 -32,768 和 32,767 之间，包含 32,767。代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">short s; // 声明一个 short 类型变量</span><br><span class="line">s = 1000; // 将值 1000 赋给变量 s</span><br><span class="line">short t = -2000; // 声明并初始化一个 short 类型变量 t，赋值为 -2000</span><br></pre></td></tr></table></figure>
<p>实际开发中，short 比较少用，整型用 int 就 OK。</p>
<p><strong>4）int </strong></p>
<p>int 的取值范围在 -2,147,483,648（-2 ^ 31）和 2,147,483,647（2 ^ 31 -1）（含）之间。如果没有特殊需求，整型数据就用 int。代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int i; // 声明一个 int 类型变量</span><br><span class="line">i = 1000000; // 将值 1000000 赋给变量 i</span><br><span class="line">int j = -2000000; // 声明并初始化一个 int 类型变量 j，赋值为 -2000000</span><br></pre></td></tr></table></figure>
<p><strong>5）long </strong></p>
<p>long 的取值范围在 -9,223,372,036,854,775,808(-2^63) 和 9,223,372,036,854,775,807(2^63 -1)（含）之间。如果 int 存储不下，就用 long。代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">long l; // 声明一个 long 类型变量</span><br><span class="line">l = 100000000000L; // 将值 100000000000L 赋给变量 l（注意要加上 L 后缀）</span><br><span class="line">long m = -20000000000L; // 声明并初始化一个 long 类型变量 m，赋值为 -20000000000L</span><br></pre></td></tr></table></figure>
<p>为了和 int 作区分，long 型变量在声明的时候，末尾要带上大写的“L”。不用小写的“l”，是因为小写的“l”容易和数字“1”混淆。</p>
<p><strong>6）float </strong></p>
<p>float 是单精度的浮点数（单精度浮点数的有效数字大约为 6 到 7 位），32 位（4 字节），遵循 IEEE 754（二进制浮点数算术标准），取值范围为 1.4E-45 到 3.4E+38。float 不适合用于精确的数值，比如说金额。</p>
<p>代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">float f; // 声明一个 float 类型变量</span><br><span class="line">f = 3.14159f; // 将值 3.14159f 赋给变量 f（注意要加上 f 后缀）</span><br><span class="line">float g = -2.71828f; // 声明并初始化一个 float 类型变量 g，赋值为 -2.71828f</span><br></pre></td></tr></table></figure>
<p>为了和 double 作区分，float 型变量在声明的时候，末尾要带上小写的“f”。不需要使用大写的“F”，是因为小写的“f”很容易辨别。</p>
<p><strong>7）double </strong></p>
<p>double 是双精度浮点数（双精度浮点数的有效数字大约为 15 到 17 位），占 64 位（8 字节），也遵循 IEEE 754 标准，取值范围大约 ±4.9E-324 到 ±1.7976931348623157E308。double 同样不适合用于精确的数值，比如说金额。</p>
<p>代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double myDouble = 3.141592653589793;</span><br></pre></td></tr></table></figure>
<p>在进行金融计算或需要精确小数计算的场景中，可以使用 BigDecimal 类来避免浮点数舍入误差。</p>
<p>BigDecimal 可以表示一个任意大小且精度完全准确的浮点数。</p>
<blockquote>
<p>在实际开发中，如果不是特别大的金额（精确到 0.01 元，也就是一分钱），一般建议乘以 100 转成整型进行处理。</p>
</blockquote>
<p><strong>8）char </strong></p>
<p>char 用于表示 Unicode 字符，占 16 位（2 字节）的存储空间，取值范围为 0 到 65,535。</p>
<p>代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char letterA = &#x27;A&#x27;; // 用英文的单引号包裹住。</span><br></pre></td></tr></table></figure>
<p>注意，字符字面量应该用单引号（’’）包围，而不是双引号（””），因为<strong>双引号表示字符串字面量。</strong></p>
<p><strong>03、单精度和双精度 </strong></p>
<p>单精度（single-precision）和双精度（double-precision）是指两种不同精度的浮点数表示方法。单精度是这样的格式，1 位符号，8 位指数，23 位小数。</p>
<p><img src="\assets\note\image-20230925112500528.png" alt="image-20230925112500528"></p>
<p>单精度浮点数通常占用 32 位（4 字节）存储空间。数值范围大约是 ±1.4E-45 到 ±3.4028235E38，精度大约为 6 到 9 位有效数字。</p>
<p>双精度是这样的格式，1 位符号，11 位指数，52 为小数。</p>
<p><img src="\assets\note\image-20230925112546756.png" alt="image-20230925112546756"></p>
<p>双精度浮点数通常占用 64 位（8 字节）存储空间，数值范围大约是 ±4.9E-324 到 ±1.7976931348623157E308，精度大约为 15 到 17 位有效数字。</p>
<p>计算精度取决于小数位（尾数）。小数位越多，则能表示的数越大，那么计算精度则越高。</p>
<p>一个数由若干位数字组成，其中影响测量精度的数字称作有效数字，也称有效数位。有效数字指科学计算中用以表示一个浮点数精度的那些数字。一般地，指一个用小数形式表示的浮点数中，从第一个非零的数字算起的所有数字。如 1.24 和 0.00124 的有效数字都有 3 位。</p>
<p>以下是确定有效数字的一些基本规则：</p>
<ul>
<li>非零数字总是有效的。</li>
<li>位于两个非零数字之间的零是有效的。</li>
<li>对于小数，从左侧开始的第一个非零数字之前的零是无效的。</li>
<li>对于整数，从右侧开始的第一个非零数字之后的零是无效的。</li>
</ul>
<p>下面是一些示例，说明如何确定有效数字：</p>
<ul>
<li>1234：4 个有效数字（所有数字都是非零数字）</li>
<li>1002：4 个有效数字（零位于两个非零数字之间）</li>
<li>0.00234：3 个有效数字（从左侧开始的前两个零是无效的）</li>
<li>1200：2 个有效数字（从右侧开始的两个零是无效的）</li>
</ul>
<p><strong>04、int 和 char 类型互转 </strong></p>
<p>int 和 char 之间比较特殊，可以互转，也会在以后的学习当中经常遇到。</p>
<p>1）可以通过强制类型转换将整型 int 转换为字符 char。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int value_int = 65;</span><br><span class="line">char value_char  = (char) value_int;</span><br><span class="line">System.out.println(value_char);</span><br></pre></td></tr></table></figure>
<p>输出 A (其 ASCII 值可以通过整数 65 来表示)。</p>
<p>2）可以使用 Character.forDigit() 方法将整型 int 转换为字符 char，参数 radix 为基数，十进制为 10，十六进制为 16。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int radix = 10;</span><br><span class="line">int value_int = 6;</span><br><span class="line">char value_char = Character.forDigit(value_int , radix);</span><br><span class="line">System.out.println(value_char );</span><br></pre></td></tr></table></figure>
<p>Character 为 char 的包装器类型。我们随后会讲。</p>
<p>3）可以使用 int 的包装器类型 Integer 的 toString() 方法+String 的 charAt() 方法转成 char。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int value_int = 1;</span><br><span class="line">char value_char = Integer.toString(value_int).charAt(0);</span><br><span class="line">System.out.println(value_char );</span><br></pre></td></tr></table></figure>
<p>4）char 转 int</p>
<p>当然了，如果只是简单的 char 转 int，直接赋值就可以了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure>
<p>因为发生了自动类型转换，后面会细讲。</p>
<p><strong>05、包装器类型 </strong></p>
<p>包装器类型（Wrapper Types）是 Java 中的一种特殊类型，用于将基本数据类型（如 int、float、char 等）转换为对应的对象类型。</p>
<ul>
<li>Java 提供了以下包装器类型，与基本数据类型一一对应：</li>
<li>Byte（对应 byte）</li>
<li>Short（对应 short）</li>
<li>Integer（对应 int）</li>
<li>Long（对应 long）</li>
<li>Float（对应 float）</li>
<li>Double（对应 double）</li>
<li>Character（对应 char）</li>
<li>Boolean（对应 boolean）</li>
</ul>
<p>包装器类型允许我们使用基本数据类型提供的各种实用方法，并兼容需要对象类型的场景。例如，我们可以使用 Integer 类的 parseInt 方法将字符串转换为整数，或使用 Character 类的 isDigit 方法检查字符是否为数字，还有前面提到的 Character.forDigit() 方法。</p>
<p>下面是一个简单的示例，演示了如何使用包装器类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 使用 Integer 包装器类型</span><br><span class="line">Integer integerValue = new Integer(42);</span><br><span class="line">System.out.println(&quot;整数值: &quot; + integerValue);</span><br><span class="line">// 将字符串转换为整数</span><br><span class="line">String numberString = &quot;123&quot;;</span><br><span class="line">int parsedNumber = Integer.parseInt(numberString);</span><br><span class="line">System.out.println(&quot;整数值: &quot; + parsedNumber);</span><br><span class="line">// 使用 Character 包装器类型</span><br><span class="line">Character charValue = new Character(&#x27;A&#x27;);</span><br><span class="line">System.out.println(&quot;字符: &quot; + charValue);</span><br><span class="line">// 检查字符是否为数字</span><br><span class="line">char testChar = &#x27;9&#x27;;</span><br><span class="line">if (Character.isDigit(testChar)) &#123;</span><br><span class="line">System.out.println(&quot;字符是个数字.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的示例中，我们创建了一个 Integer 类型的对象 integerValue 并为其赋值 42。然后，我们将其值打印到控制台。</p>
<p>我们有一个包含数字的字符串 numberString。我们使用 Integer.parseInt() 方法将其转换为整数 parsedNumber。然后，我们将转换后的值打印到控制台。</p>
<p>我们有一个字符变量 testChar，并为其赋值字符 ‘9’。我们使用 Character.isDigit() 方法检查 testChar 是否为数字字符。如果是数字字符，我们将输出一条消息到控制台。</p>
<p>从 Java 5 开始，自动装箱（Autoboxing）和自动拆箱（Unboxing）机制允许我们在基本数据类型和包装器类型之间自动转换，无需显式地调用构造方法或转换方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer integerValue = 42; // 自动装箱，等同于 new Integer(42)</span><br><span class="line">int primitiveValue = integerValue; // 自动拆箱，等同于 integerValue.intValue()</span><br></pre></td></tr></table></figure>
<p><strong>06、引用数据类型 </strong></p>
<p>基本数据类型在作为成员变量和静态变量的时候有默认值，引用数据类型也有的（学完数组&amp;字符串，以及面向对象编程后会更加清楚，这里先简单过一下）。</p>
<p>String 是最典型的引用数据类型，所以我们就拿 String 类举例，看下面这段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author 微信搜「二哈进阶之路」</span><br><span class="line"> */</span><br><span class="line">public class LocalRef &#123;</span><br><span class="line">    private String a;</span><br><span class="line">    static String b;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        LocalRef lv = new LocalRef();</span><br><span class="line">        System.out.println(lv.a);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">null</span><br><span class="line">null</span><br></pre></td></tr></table></figure>
<p>null 在 Java 中是一个很神奇的存在，在你以后的程序生涯中，见它的次数不会少，尤其是伴随着令人烦恼的“空指针异常”，也就是所谓的 NullPointerException 。</p>
<p>也就是说，引用数据类型的默认值为 null，包括数组和接口。</p>
<p>那你是不是很好奇，为什么数组和接口也是引用数据类型啊？</p>
<p>先来看数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int [] arrays = &#123;1,2,3&#125;;</span><br><span class="line">System.out.println(arrays);</span><br></pre></td></tr></table></figure>
<p>arrays 是一个 int 类型的数组，对吧？打印结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[I@2d209079</span><br></pre></td></tr></table></figure>
<p>[I 表示数组是 int 类型的，@ 后面是十六进制的 hashCode——这样的打印结果太“人性化”了，一般人表示看不懂！为什么会这样显示呢？查看一下 java.lang.Object 类的 toString() 方法就明白了。</p>
<p><img src="\assets\note\image-20230925114234571.png" alt="image-20230925114234571"></p>
<p>数组虽然没有显式定义成一个类，但它的确是一个对象，继承了祖先类 Object 的所有方法。那为什么数组不单独定义一个类来表示呢？就像字符串 String 类那样呢？</p>
<p>一个合理的解释是 Java 将其隐藏了。假如真的存在一个 Array.java，我们也可以假想它真实的样子，它必须要定义一个容器来存放数组的元素，就像 String 类那样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final class String</span><br><span class="line">    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    /** The value is used for character storage. */</span><br><span class="line">    private final char value[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数组内部定义数组？没必要的！</p>
<p>再来看接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>
<p>List 是一个非常典型的接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public interface List&lt;E&gt; extends Collection&lt;E&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>而 ArrayList 是 List 接口的一个实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class="line">        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>对于接口类型的引用变量来说，你没法直接 new 一个：</p>
<p><img src="\assets\note\image-20230925114445179.png" alt="image-20230925114445179"></p>
<p>只能 new 一个实现它的类的对象——那自然接口也是引用数据类型了。</p>
<p>来看一下基本数据类型和引用数据类型之间最大的差别。</p>
<p>基本数据类型：</p>
<ul>
<li>变量名指向具体的数值。</li>
<li>基本数据类型存储在栈上。</li>
</ul>
<p>引用数据类型：</p>
<ul>
<li>变量名指向的是存储对象的内存地址，在栈上。</li>
<li>内存地址指向的对象存储在堆上。</li>
</ul>
<p><strong>07、堆和栈 </strong></p>
<p>堆是堆（heap），栈是栈（stack），如果看到“堆栈”的话，请不要怀疑自己，那是翻译的错，堆栈也是栈，反正我很不喜欢“堆栈”这种叫法，容易让新人掉坑里。</p>
<p>堆是在程序运行时在内存中申请的空间（可理解为动态的过程）；切记，不是在编译时；因此，Java 中的对象就放在这里，这样做的好处就是：</p>
<blockquote>
<p>当需要一个对象时，只需要通过 new 关键字写一行代码即可，当执行这行代码时，会自动在内存的“堆”区分配空间——这样就很灵活。</p>
</blockquote>
<p>栈，能够和处理器（CPU，也就是脑子）直接关联，因此访问速度更快。既然访问速度快，要好好利用啊！Java 就把对象的引用放在栈里。为什么呢？因为引用的使用频率高吗？</p>
<p>不是的，因为 Java 在编译程序时，必须明确的知道存储在栈里的东西的生命周期，否则就没法释放旧的内存来开辟新的内存空间存放引用——空间就那么大，前浪要把后浪拍死在沙滩上啊。</p>
<p>这么说就理解了吧？</p>
<p>用图来表示一下，左侧是栈，右侧是堆。</p>
<p><img src="\assets\note\image-20230925114753308.png" alt="image-20230925114753308"></p>
<p>这里再补充一些额外的知识点，能看懂就继续吸收，看不懂可以先去学下一节，以后再来补，没关系的。学习就是这样，可以跳过，可以温故。</p>
<p>举个例子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String a = new String(&quot;沉默&quot;)</span><br></pre></td></tr></table></figure>
<p>这段代码会先在堆里创建一个 沉默的字符串对象，然后再把对象的引用 a 放到栈里面。这里面还会涉及到字符串常量池，后面会讲。</p>
<p>那么对于这样一段代码，有基本数据类型的变量，有引用类型的变量，堆和栈都是如何存储他们的呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void test()</span><br><span class="line">&#123;</span><br><span class="line">    int i = 4;</span><br><span class="line">    int y = 2;</span><br><span class="line">    Object o1 = new Object();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我来画个图表示下。</p>
<p><img src="\assets\note\image-20230925114943142.png" alt="image-20230925114943142"></p>
<p><strong>08、小结 </strong></p>
<p>本文详细探讨了 Java 数据类型，包括比特与字节、基本数据类型、单精度与双精度、int 与 char 互转、包装器类型、引用数据类型以及堆与栈的内存模型。通过阅读本文，你将全面了解 Java 数据类型的概念与使用方法，为 Java 编程打下坚实基础。</p>
<h2 id="1-4-Java数据类型转换"><a href="#1-4-Java数据类型转换" class="headerlink" title="1.4 Java数据类型转换"></a>1.4 Java数据类型转换</h2><p>数据类型转换的目的是确保在表达式求值时，不同类型的数据能够相互兼容。</p>
<p><strong>01、自动类型转换 </strong></p>
<p>自动类型转换（自动类型提升）是 Java 编译器在不需要显式转换的情况下，将一种基本数据类型自动转换为另一种基本数据类型的过程。这种转换通常发生在表达式求值期间，当不同类型的数据需要相互兼容时。自动类型转换遵循以下规则：</p>
<ul>
<li>如果任何操作数是 double 类型，其他操作数将被转换为 double 类型。</li>
<li>否则，如果任何操作数是 float 类型，其他操作数将被转换为 float 类型。</li>
<li>否则，如果任何操作数是 long 类型，其他操作数将被转换为 long 类型。</li>
<li>否则，所有操作数将被转换为 int 类型。</li>
</ul>
<p>需要注意的是，自动类型转换只发生在兼容类型之间。例如，从较小的数据类型（如 int）到较大的数据类型（如 long 或 double）的转换是安全的，因为较大的数据类型可以容纳较小数据类型的所有可能值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">byte -&gt; short -&gt; int -&gt; long -&gt; float -&gt; double</span><br><span class="line">char -&gt; int -&gt; long -&gt; float -&gt; double</span><br></pre></td></tr></table></figure>
<p>下面是一个简单的示例，演示了自动类型转换：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int intValue = 5;</span><br><span class="line">double doubleValue = 2.5;</span><br><span class="line">// 自动类型转换：intValue 被转换为 double 类型</span><br><span class="line">double result = intValue * doubleValue;</span><br><span class="line">System.out.println(&quot;结果: &quot; + result); // 输出：结果: 12.5</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们有一个 int 类型的变量 intValue 和一个 double 类型的变量 doubleValue。当我们将它们相乘时，根据自动类型转换的规则，intValue 将被转换为 double 类型，以便将两个 double 类型的操作数相乘。最终结果将是一个 double 类型的值：12.5。</p>
<p>再来举个例子，顾客到超市购物，购买牙膏 2 盒，面巾纸 4 盒。其中牙膏的价格是 10.9 元，面巾纸的价格是 5.8 元，求商品总价格。实现代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">float price1 = 10.9f; // 定义牙膏的价格，单精度浮点型float</span><br><span class="line">double price2 = 5.8; // 定义面巾纸的价格，双精度浮点型double</span><br><span class="line">int num1 = 2; // 定义牙膏的数量，整型 int</span><br><span class="line">int num2 = 4; // 定义面巾纸的数量</span><br><span class="line">double res = price1 * num1 + price2 * num2; // 计算总价</span><br><span class="line">System.out.println(&quot;一共付给收银员&quot; + res + &quot;元&quot;); // 输出总价</span><br></pre></td></tr></table></figure>
<p>上述代码中首先定义了一个 float 类型的变量存储牙膏的价格，然后定义了一个 double 类型的变量存储面巾纸的价格，再定义两个 int 类型的变量存储物品的数量，最后进行了乘运算以及和运算之后，将结果储存在一个 double 类型的变量中进行输出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一共付给收银员44.99999923706055元</span><br></pre></td></tr></table></figure>
<p>从执行结果看出，float、int 和 double 三种数据类型参与运算，最后输出的结果为 double 类型的数据。这种转换一般称为“表达式中类型的自动提升”。</p>
<p>自动类型提升有好处，但它也会引起令人疑惑的编译错误。例如，下面看起来正确的程序却会引起问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">byte b = 50;</span><br><span class="line">b = b * 2; // Type mismatch: cannot convert from int to byte</span><br></pre></td></tr></table></figure>
<p>如上所示，第二行会报“类型不匹配：无法从int转换为byte”错误。</p>
<p>该程序试图将一个完全合法的 byte 型的值 50*2 存储给一个 byte 型的变量。但是当表达式求值的时候，操作数被自动的提升为 int 型，计算结果也被提升为 int 型。这样表达式的结果现在是 int 型，不强制转换它就不能被赋为 byte 型。</p>
<p>所以应该使用一个显示的强制类型转换，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">byte b = 50;</span><br><span class="line">b = (byte)(b*2);</span><br></pre></td></tr></table></figure>
<p>这样就能产生正确的值 100。</p>
<p>注意：char 类型比较特殊，char 自动转换成 int、long、float 和 double，但 byte 和 short 不能自动转换为 char，而且 char 也不能自动转换为 byte 或 short。</p>
<p><strong>02、强制类型转换 </strong></p>
<p>强制类型转换是 Java 中将一种数据类型显式转换为另一种数据类型的过程。与自动类型转换不同，强制类型转换需要程序员显式地指定要执行的转换。强制类型转换在以下情况中可能需要：</p>
<ul>
<li>将较大的数据类型转换为较小的数据类型。</li>
<li>将浮点数转换为整数。</li>
<li>将字符类型转换为数值类型。</li>
</ul>
<p>需要注意的是，强制类型转换可能会导致数据丢失或精度降低，因为目标类型可能无法容纳原始类型的所有可能值。因此，在进行强制类型转换时，需要确保转换后的值仍然在目标类型的范围内。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double -&gt; float -&gt; long -&gt; int -&gt; char -&gt; short -&gt; byte</span><br></pre></td></tr></table></figure>
<p>以下是一个简单的示例，演示了强制类型转换：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">double doubleValue = 42.8;</span><br><span class="line">// 强制类型转换：将 double 类型转换为 int 类型</span><br><span class="line">int intValue = (int) doubleValue;</span><br><span class="line">System.out.println(&quot;整数值: &quot; + intValue); // 输出：整数值: 42</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们有一个 double 类型的变量 doubleValue。我们希望将其转换为 int 类型的变量 intValue。为此，我们使用强制类型转换语法，即在要转换的变量之前加上目标类型的括号（如 (int)）。</p>
<p>需要注意的是，将 doubleValue 转换为 int 类型时，小数部分将被截断。因此，输出结果将是：Integer value: 42。在这种情况下，精度丢失是可以接受的，但在其他情况下，我们可能需要更加小心地处理类型转换以避免数据丢失。</p>
<p>顾客到超市购物，购买牙膏 2 盒，面巾纸 4 盒。其中牙膏的价格是 10.9 元，面巾纸的价格是 5.8 元，求商品总价格，在计算总价时采用 int 类型的数据进行存储。实现代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">float price1 = 10.9f;</span><br><span class="line">double price2 = 5.8;</span><br><span class="line">int num1 = 2;</span><br><span class="line">int num2 = 4;</span><br><span class="line">int res2 = (int) (price1 * num1 + price2 * num2);</span><br><span class="line">System.out.println(&quot;一共付给收银员&quot; + res2 + &quot;元&quot;);</span><br></pre></td></tr></table></figure>
<p>在上述实例中，有 double 类型、float 类型和 int 类型的数据参与运算，其运算结果默认为 double 类型，题目要求的结果为 int 类型，因为 int 类型的取值范围要小于 double 类型的取值范围，所以需要进行强制类型转换。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一共付给收银员44元</span><br></pre></td></tr></table></figure>
<h2 id="1-5-Java基本数据类型缓存池"><a href="#1-5-Java基本数据类型缓存池" class="headerlink" title="1.5 Java基本数据类型缓存池"></a>1.5 Java基本数据类型缓存池</h2><p>“考你一个问题哈： new Integer(18) 与 Integer.valueOf(18) 的区别是什么？”</p>
<p>new Integer(18) 每次都会新建一个对象;</p>
<p>Integer.valueOf(18) 会使⽤用缓存池中的对象，多次调用只会取同⼀一个对象的引用。</p>
<p>来看下面这段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Integer x = new Integer(18);</span><br><span class="line">Integer y = new Integer(18);</span><br><span class="line">System.out.println(x == y);</span><br><span class="line">Integer z = Integer.valueOf(18);</span><br><span class="line">Integer k = Integer.valueOf(18);</span><br><span class="line">System.out.println(z == k);</span><br><span class="line">Integer m = Integer.valueOf(300);</span><br><span class="line">Integer p = Integer.valueOf(300);</span><br><span class="line">System.out.println(m == p);</span><br></pre></td></tr></table></figure>
<p>来看一下输出结果吧：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure>
<p>“第一个 false，我知道原因，因为 new 出来的是不同的对象，地址不同。”“第二个和第三个我认为都应该是 true 啊，为什么第三个会输出 false 呢？这个我理解不了。”</p>
<p>“其实原因也很简单。”我胸有成竹地说。</p>
<p>基本数据类型的包装类除了 Float 和 Double 之外，其他六个包装器类（Byte、Short、Integer、Long、Character、Boolean）都有常量缓存池。</p>
<ul>
<li>Byte：-128~127，也就是所有的 byte 值</li>
<li>Short：-128~127</li>
<li>Long：-128~127</li>
<li>Character：\u0000 - \u007F</li>
<li>Boolean：true 和 false</li>
</ul>
<p>拿 Integer 来举例子，Integer 类内部中内置了 256 个 Integer 类型的缓存数据，当使用的数据范围在 -128~127 之间时，会直接返回常量池中数据的引用，而不是创建对象，超过这个范围时会创建新的对象。</p>
<p>18 在 -128~127 之间，300 不在。</p>
<p>来看一下 valueOf 方法的源码吧。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static Integer valueOf(int i) &#123;</span><br><span class="line">    if (i &gt;=IntegerCache.low &amp;&amp; i &lt;=IntegerCache.high)</span><br><span class="line">        return IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    return new Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“哦，原来是因为 Integer.IntegerCache 这个内部类的原因啊！”</p>
<p>“是滴。来看一下 IntegerCache 这个静态内部类的源码吧。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private static class IntegerCache &#123;</span><br><span class="line">    static final int low = -128;</span><br><span class="line">    static final int high;</span><br><span class="line">    static final Integer cache[];</span><br><span class="line">    static &#123;</span><br><span class="line">        // high value may be configured by property</span><br><span class="line">        int h = 127;</span><br><span class="line">        String integerCacheHighPropValue =</span><br><span class="line">                sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);</span><br><span class="line">        if (integerCacheHighPropValue != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                int i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, 127);</span><br><span class="line">                // Maximum array size is Integer.MAX_VALUE</span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -1);</span><br><span class="line">            &#125; catch( NumberFormatException nfe) &#123;</span><br><span class="line">                // If the property cannot be parsed into an int, ignore it.</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line">        cache = new Integer[(high - low) + 1];</span><br><span class="line">        int j = low;</span><br><span class="line">        for(int k = 0; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = new Integer(j++);</span><br><span class="line">        // range [-128, 127] must be interned (JLS7 5.1.7)</span><br><span class="line">        assert Integer.IntegerCache.high &gt;= 127;</span><br><span class="line">    &#125;</span><br><span class="line">    private IntegerCache() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>详细解释下：当我们通过 Integer.valueOf() 方法获取整数对象时，会先检查该整数是否在 IntegerCache 中，如果在，则返回缓存中的对象，否则创建一个新的对象并缓存起来。</p>
<p>需要注意的是，如果使用 new Integer() 创建对象，即使值在 -128 到 127 范围内，也不会被缓存，每次都会创建新的对象。因此，推荐使用 Integer.valueOf() 方法获取整数对象。</p>
<p>学习 static 关键字的时候，会详细解释静态代码块，你暂时先记住，<strong>静态代码块通常用来初始化一些静态变量，它会优先于 main() 方法执行</strong>。</p>
<p>在静态代码块中，low 为 -128，也就是缓存池的最小值；high 默认为 127，也就是缓存池的最大值，共计 256 个。</p>
<p>可以在 JVM 启动的时候，通过 -XX:AutoBoxCacheMax=NNN来设置缓存池的大小，当然了，不能无限大，最大到 Integer.MAX_VALUES - 129</p>
<p>之后，初始化 cache 数组的大小，然后遍历填充，下标从 0 开始。</p>
<p>“这段代码不难理解，难理解的是 assert Integer.IntegerCache.high &gt;= 127; ，这行代码是干嘛的呀？”</p>
<p>assert 是 Java 中的一个关键字，寓意是断言，为了方便调试程序，并不是发布程序的组成部分。</p>
<p>默认情况下，断言是关闭的，可以在命令行运行 Java 程序的时候加上 -ea 参数打开断言。</p>
<p>来看这段代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class AssertTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int high = 126;</span><br><span class="line">        assert high &gt;= 127;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设手动设置的缓存池大小为 126，显然不太符合缓存池的预期值 127，结果会输出什么呢？直接在 Intellij IDEA 中打开命令行终端，进入 classes 文件，执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/libexec/java_home -v 1.8 --exec java -ea com.itwanger.s51.AssertTest</span><br></pre></td></tr></table></figure>
<p>我用的 macOS 环境，装了好多个版本的 JDK，该命令可以切换到 JDK 8</p>
<p>也可以不指定 Java 版本直接执行（加上 -ea 参数）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -ea com.itwanger.s51.AssertTest</span><br></pre></td></tr></table></figure>
<p>“呀，报错了呀。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.AssertionError</span><br><span class="line">        at com.itwanger.s51.AssertTest.main(AssertTest.java:9)</span><br></pre></td></tr></table></figure>
<p>“是滴，因为 126 小于 127。”</p>
<p>“原来 assert 是这样用的啊，我明白了。”</p>
<p>在 Java 中，针对一些基本数据类型（如 Integer、Long、Boolean 等），Java 会在程序启动时创建一些常用的对象并缓存在内存中，以提高程序的性能和节省内存开销。这些常用对象被缓存在一个固定的范围内，超出这个范围的值会被重新创建新的对象。</p>
<p>使用数据类型缓存池可以有效提高程序的性能和节省内存开销，但需要注意的是，在特定的业务场景下，缓存池可能会带来一些问题，例如缓存池中的对象被不同的线程同时修改，导致数据错误等问题。因此，在实际开发中，需要根据具体的业务需求来决定是否使用数据类型缓存池。</p>
<h2 id="1-6-Java运算符"><a href="#1-6-Java运算符" class="headerlink" title="1.6 Java运算符"></a>1.6 Java运算符</h2><p>运算符在 Java 中占据着重要的位置，对程序的执行有着很大的帮助。除了常见的加减乘除，还有许多其他类型的运算符，来看下面这张思维导图。”</p>
<p><img src="\assets\note\image-20230925135407003.png" alt="image-20230925135407003"></p>
<p><strong>01、算术运算符 </strong></p>
<p>算术运算符除了最常见的加减乘除，还有一个取余的运算符，用于得到除法运算后的余数，来串代码感受下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int a = 10;</span><br><span class="line">int b = 5;</span><br><span class="line">System.out.println(a + b);//15</span><br><span class="line">System.out.println(a - b);//5</span><br><span class="line">System.out.println(a * b);//50</span><br><span class="line">System.out.println(a / b);//2</span><br><span class="line">System.out.println(a % b);//0</span><br><span class="line">b = 3;</span><br><span class="line">System.out.println(a + b);//13</span><br><span class="line">System.out.println(a - b);//7</span><br><span class="line">System.out.println(a * b);//30</span><br><span class="line">System.out.println(a / b);//3</span><br><span class="line">System.out.println(a % b);//1</span><br></pre></td></tr></table></figure>
<p>对于初学者来说，加法（+）、减法（-）、乘法（*）很好理解，但除法（/）和取余（%）会有一点点疑惑。在以往的认知里，10/3 是除不尽的，结果应该是 3.333333…，而不应该是 3。相应的，余数也不应该是 1。这是为什么呢？</p>
<p>因为数字在程序中可以分为两种，一种是整型，一种是浮点型（不清楚的同学可以回头看看数据类型那篇），整型和整型的运算结果就是整型，不会出现浮点型。否则，就会出现浮点型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int a = 10;</span><br><span class="line">float c = 3.0f;</span><br><span class="line">double d = 3.0;</span><br><span class="line">System.out.println(a / c); // 3.3333333</span><br><span class="line">System.out.println(a / d); // 3.3333333333333335</span><br><span class="line">System.out.println(a % c); // 1.0</span><br><span class="line">System.out.println(a % d); // 1.0</span><br></pre></td></tr></table></figure>
<p>需要注意的是，当浮点数除以 0 的时候，结果为 Infinity 或者 NaN。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(10.0 / 0.0); // Infinity</span><br><span class="line">System.out.println(0.0 / 0.0); // NaN</span><br></pre></td></tr></table></figure>
<p>Infinity 的中文意思是无穷大，NaN 的中文意思是这不是一个数字（Not a Number）。</p>
<p>当整数除以 0 的时候（ 10 / 0 ），会抛出异常：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.ArithmeticException: / by zero</span><br><span class="line">    at com.itwanger.eleven.ArithmeticOperator.main(ArithmeticOperator.java:32)</span><br></pre></td></tr></table></figure>
<p>所以整数在进行除法运算时，需要先判断除数是否为 0，以免程序抛出异常。</p>
<p>算术运算符中还有两种特殊的运算符，自增运算符（++）和自减运算符（—），它们也叫做一元运算符，只有一个操作数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int x = 10;</span><br><span class="line">System.out.println(x++);//10 (11)  </span><br><span class="line">System.out.println(++x);//12  </span><br><span class="line">System.out.println(x--);//12 (11)  </span><br><span class="line">System.out.println(--x);//10 </span><br></pre></td></tr></table></figure>
<p>一元运算符可以放在数字的前面或者后面，放在前面叫前自增（前自减），放在后面叫后自增（后自减）。</p>
<p>前自增和后自增是有区别的，拿 int y = ++x 这个表达式来说（x = 10），它可以拆分为 x = x+1 = 11; y = x = 11 ，所以表达式的结果为 x = 11, y = 11 。拿 int y = x++ 这个表达式来说（x = 10），它可以拆分为 y = x = 10; x = x+1 = 11 ，所以表达式的结果为 x = 11, y = 10 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int x = 10;</span><br><span class="line">int y = ++x;</span><br><span class="line">System.out.println(y + &quot; &quot; + x);// 11 11</span><br><span class="line">x = 10;</span><br><span class="line">y = x++;</span><br><span class="line">System.out.println(y + &quot; &quot; + x);// 10 11</span><br></pre></td></tr></table></figure>
<p>对于前自减和后自减来说，你可以自己试一把。</p>
<p><strong>02、关系运算符 </strong></p>
<p>关系运算符用来比较两个操作数，返回结果为 true 或者 false。</p>
<p><img src="\assets\note\image-20230926134500081.png" alt="image-20230926134500081"></p>
<p>来看示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int a = 10, b = 20;</span><br><span class="line">System.out.println(a == b); // false</span><br><span class="line">System.out.println(a != b); // true</span><br><span class="line">System.out.println(a &gt; b); // false</span><br><span class="line">System.out.println(a &lt; b); // true</span><br><span class="line">System.out.println(a &gt;= b); // false</span><br><span class="line">System.out.println(a &lt;= b); // true</span><br></pre></td></tr></table></figure>
<p><strong>03、位运算符 </strong></p>
<p>在学习位运算符之前，需要先学习一下二进制，因为位运算符操作的不是整型数值（int、long、short、char、byte）本身，而是整型数值对应的二进制。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Integer.toBinaryString(60)); // 111100</span><br><span class="line">System.out.println(Integer.toBinaryString(13)); // 1101</span><br></pre></td></tr></table></figure>
<p>从程序的输出结果可以看得出来，60 的二进制是 0011 1100（用 0 补到 8 位），13 的二进制是 0000 1101。</p>
<p>PS：现代的二进制记数系统由戈特弗里德·威廉·莱布尼茨于 1679 年设计。莱布尼茨是德意志哲学家、数学家，历史上少见的通才。</p>
<p><img src="\assets\note\image-20230926134711867.png" alt="image-20230926134711867"></p>
<p>来看示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int a = 60, b = 13;</span><br><span class="line">System.out.println(&quot;a 的二进制：&quot; + Integer.toBinaryString(a)); // 111100</span><br><span class="line">System.out.println(&quot;b 的二进制：&quot; + Integer.toBinaryString(b)); // 1101</span><br><span class="line">int c = a &amp; b;</span><br><span class="line">System.out.println(&quot;a &amp; b：&quot; + c + &quot;，二进制是：&quot; + Integer.toBinaryString(c));</span><br><span class="line">c = a | b;</span><br><span class="line">System.out.println(&quot;a | b：&quot; + c + &quot;，二进制是：&quot; + Integer.toBinaryString(c));</span><br><span class="line">c = a ^ b;</span><br><span class="line">System.out.println(&quot;a ^ b：&quot; + c + &quot;，二进制是：&quot; + Integer.toBinaryString(c));</span><br><span class="line">c = ~a;</span><br><span class="line">System.out.println(&quot;~a：&quot; + c + &quot;，二进制是：&quot; + Integer.toBinaryString(c));</span><br><span class="line">c = a &lt;&lt; 2;</span><br><span class="line">System.out.println(&quot;a &lt;&lt; 2：&quot; + c + &quot;，二进制是：&quot; + Integer.toBinaryString(c));</span><br><span class="line">c = a &gt;&gt; 2;</span><br><span class="line">System.out.println(&quot;a &gt;&gt; 2：&quot; + c + &quot;，二进制是：&quot; + Integer.toBinaryString(c));</span><br><span class="line">c = a &gt;&gt;&gt; 2;</span><br><span class="line">System.out.println(&quot;a &gt;&gt;&gt; 2：&quot; + c + &quot;，二进制是：&quot; + Integer.toBinaryString(c));</span><br></pre></td></tr></table></figure>
<p>对于初学者来说，位运算符无法从直观上去计算出结果，不像加减乘除那样。因为我们日常接触的都是十进制，位运算的时候需要先转成二进制，然后再计算出结果。</p>
<p>鉴于此，初学者在写代码的时候其实很少会用到位运算。对于编程高手来说，为了提高程序的性能，会在一些地方使用位运算。比如说，HashMap 在计算哈希值的时候：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果对位运算一点都不懂的话，遇到这样的源码就很吃力。所以说，虽然位运算用的少，但还是要懂。</p>
<p>1）按位左移运算符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(10&lt;&lt;2);//10*2^2=10*4=40  </span><br><span class="line">System.out.println(10&lt;&lt;3);//10*2^3=10*8=80  </span><br><span class="line">System.out.println(20&lt;&lt;2);//20*2^2=20*4=80  </span><br><span class="line">System.out.println(15&lt;&lt;4);//15*2^4=15*16=240 </span><br></pre></td></tr></table></figure>
<p>10&lt;&lt;2 等于 10 乘以 2 的 2 次方； 10&lt;&lt;3 等于 10 乘以 2 的 3 次方。</p>
<p>2）按位右移运算符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(10&gt;&gt;2);//10/2^2=10/4=2</span><br><span class="line">System.out.println(20&gt;&gt;2);//20/2^2=20/4=5</span><br><span class="line">System.out.println(20&gt;&gt;3);//20/2^3=20/8=2</span><br></pre></td></tr></table></figure>
<p>10&gt;&gt;2 等于 10 除以 2 的 2 次方； 20&gt;&gt;2 等于 20 除以 2 的 2 次方。</p>
<p><strong>04、逻辑运算符 </strong></p>
<p>逻辑与运算符（&amp;&amp;）：多个条件中只要有一个为 false 结果就为 false。</p>
<p>逻辑或运算符（||）：多个条件只要有一个为 true 结果就为 true。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a=10;</span><br><span class="line">int b=5;</span><br><span class="line">int c=20;</span><br><span class="line">System.out.println(a&lt;b&amp;&amp;a&lt;c);//false &amp;&amp; true = false</span><br><span class="line">System.out.println(a&gt;b||a&lt;c);//true || true = true</span><br></pre></td></tr></table></figure>
<p>逻辑非运算符（!）：用来反转条件的结果，如果条件为 true，则逻辑非运算符将得到 false。</p>
<p>单逻辑与运算符（&amp;）：很少用，因为不管第一个条件为 true 还是 false，依然会检查第二个。</p>
<p>单逻辑或运算符（|）：也会检查第二个条件。</p>
<p>也就是说，&amp; 和 | 性能不如 &amp;&amp; 和 ||，但用法一样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a=10;</span><br><span class="line">int b=5;</span><br><span class="line">int c=20;</span><br><span class="line">System.out.println(a&lt;b&amp;a&lt;c);//false &amp; true = false</span><br><span class="line">System.out.println(a&gt;b|a&lt;c);//true | true = true  </span><br></pre></td></tr></table></figure>
<p><strong>05、赋值运算符 </strong></p>
<p>赋值操作符恐怕是 Java 中使用最频繁的操作符了，它就是把操作符右侧的值赋值给左侧的变量。来看示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int a=10;</span><br><span class="line">int b=20;</span><br><span class="line">a+=4;//a=a+4 (a=10+4)  </span><br><span class="line">b-=4;//b=b-4 (b=20-4)  </span><br><span class="line">System.out.println(a);</span><br><span class="line">System.out.println(b);</span><br></pre></td></tr></table></figure>
<p>不过在进行数值的赋值时，需要小点心，比如说下面这种情况：</p>
<p><img src="\assets\note\image-20230926135245627.png" alt="image-20230926135245627"></p>
<p>编译器之所以提示错误，是因为 = 右侧的算术表达式默认为 int 类型，左侧是 short 类型的时候需要进行强转。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">short a = 10;</span><br><span class="line">short b = 10;</span><br><span class="line">//a+=b;//a=a+b internally so fine</span><br><span class="line">a = (short)(a + b);</span><br><span class="line">System.out.println(a);</span><br></pre></td></tr></table></figure>
<p>除此之外，还会有边界问题，比如说，两个非常大的 int 相乘，结果可能就超出了 int 的范围：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a = Integer.MAX_VALUE;</span><br><span class="line">int b = 10000;</span><br><span class="line">int c = a * b;</span><br><span class="line">System.out.println(c); // -10000</span><br></pre></td></tr></table></figure>
<p>程序输出的结果为 -10000，这个答案很明显不是我们想要的结果，虽然可以通过右侧表达式强转 long 的方法解决：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a = Integer.MAX_VALUE;</span><br><span class="line">int b = 10000;</span><br><span class="line">long c = (long)a * b;</span><br><span class="line">System.out.println(c); // 21474836470000</span><br></pre></td></tr></table></figure>
<p>但尽量不要这样做，结果非常大的时候，尽量提前使用相应的类型进行赋值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">long a = Integer.MAX_VALUE - 1;</span><br><span class="line">long b = 10000;</span><br><span class="line">long c = a * b;</span><br><span class="line">System.out.println(c); // 21474836460000</span><br></pre></td></tr></table></figure>
<p><strong>06、三元运算符 </strong></p>
<p>三元运算符用于替代 if-else，可以使用一行代码完成条件判断的要求。来看示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a=2;</span><br><span class="line">int b=5;</span><br><span class="line">int min=(a&lt;b)?a:b;</span><br><span class="line">System.out.println(min);</span><br></pre></td></tr></table></figure>
<p>如果 ? 前面的条件为 true，则结果为 : 前的值，否则为 : 后的值。</p>
<p><strong>07、小结 </strong></p>
<p>本文全面介绍了Java运算符，包括算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符等。通过阅读本文，您将了解到Java运算符的分类、用法和优先级，以及如何在实际开发中灵活运用各类运算符提高编程效率。</p>
<h2 id="1-7-Java流程控制语句"><a href="#1-7-Java流程控制语句" class="headerlink" title="1.7 Java流程控制语句"></a>1.7 Java流程控制语句</h2><p>“流程控制语句都有哪些呢？”</p>
<p>“比如说 if-else、switch、for、while、do-while、return、break、continue 等等，接下来，我们一个个来了解下。”</p>
<p><strong>01、if-else 相关</strong></p>
<p><img src="\assets\note\image-20230926135653439.png" alt="image-20230926135653439"></p>
<p>1）if 语句 </p>
<p>if 语句的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(布尔表达式)&#123;  </span><br><span class="line">// 如果条件为 true，则执行这块代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>画个流程图表示一下：</p>
<p><img src="\assets\note\image-20230926135814299.png" alt="image-20230926135814299"></p>
<p>来写个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int age = 20;</span><br><span class="line">if (age &lt; 30) &#123;</span><br><span class="line">    System.out.println(&quot;青春年华&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">青春年华</span><br></pre></td></tr></table></figure>
<p>2）if-else 语句 </p>
<p>if-else 语句的格式如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(布尔表达式)&#123;  </span><br><span class="line">// 条件为 true 时执行的代码块</span><br><span class="line">&#125;else&#123;  </span><br><span class="line">// 条件为 false  时执行的代码块</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>画个流程图表示一下：</p>
<p><img src="\assets\note\image-20230926135950470.png" alt="image-20230926135950470"></p>
<p>来写个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int age = 31;</span><br><span class="line">if (age &lt; 30) &#123;</span><br><span class="line">    System.out.println(&quot;青春年华&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    System.out.println(&quot;而立之年&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">而立之年</span><br></pre></td></tr></table></figure>
<p>除了这个例子之外，还有一个判断闰年（被 4 整除但不能被 100 整除或者被 400 整除）的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int year = 2020;</span><br><span class="line">if (((year % 4 == 0) &amp;&amp; (year % 100 != 0)) || (year % 400 == 0)) &#123;</span><br><span class="line">    System.out.println(&quot;闰年&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    System.out.println(&quot;普通年份&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">闰年</span><br></pre></td></tr></table></figure>
<p>如果执行语句比较简单的话，可以使用三元运算符来代替 if-else 语句，如果条件为 true，返回 ? 后面 : 前面的值；如果条件为 false，返回 : 后面的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int num = 13;</span><br><span class="line">String result = (num % 2 == 0) ? &quot;偶数&quot; : &quot;奇数&quot;;</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">奇数</span><br></pre></td></tr></table></figure>
<p>3）if-else-if 语句 </p>
<p>if-else-if 语句的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if(条件1)&#123;  </span><br><span class="line">// 条件1 为 true 时执行的代码</span><br><span class="line">&#125;else if(条件2)&#123;  </span><br><span class="line">// 条件2 为 true 时执行的代码</span><br><span class="line">&#125;  </span><br><span class="line">else if(条件3)&#123;  </span><br><span class="line">// 条件3 为 true 时执行的代码</span><br><span class="line">&#125;  </span><br><span class="line">...  </span><br><span class="line">else&#123;  </span><br><span class="line">// 以上条件均为 false 时执行的代码</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>画个流程图表示一下：</p>
<p><img src="\assets\note\image-20230926140244236.png" alt="image-20230926140244236"></p>
<p>来写个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int age = 31;</span><br><span class="line">if (age &lt; 30) &#123;</span><br><span class="line">    System.out.println(&quot;青春年华&quot;);</span><br><span class="line">&#125; else if (age &gt;= 30 &amp;&amp; age &lt; 40 ) &#123;</span><br><span class="line">    System.out.println(&quot;而立之年&quot;);</span><br><span class="line">&#125; else if (age &gt;= 40 &amp;&amp; age &lt; 50 ) &#123;</span><br><span class="line">    System.out.println(&quot;不惑之年&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    System.out.println(&quot;知天命&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">而立之年</span><br></pre></td></tr></table></figure>
<p>4）if 嵌套语句 </p>
<p>if 嵌套语句的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if(外侧条件)&#123;    </span><br><span class="line">     // 外侧条件为 true 时执行的代码 </span><br><span class="line">    if(内侧条件)&#123;  </span><br><span class="line">        // 内侧条件为 true 时执行的代码</span><br><span class="line">    &#125;    </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>画个流程图表示一下：</p>
<p><img src="\assets\note\image-20230926141351915.png" alt="image-20230926141351915"></p>
<p>来写个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int age = 20;</span><br><span class="line">boolean isGirl = true;</span><br><span class="line">if (age &gt;= 20) &#123;</span><br><span class="line">    if (isGirl) &#123;</span><br><span class="line">        System.out.println(&quot;女生法定结婚年龄&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">女生法定结婚年龄</span><br></pre></td></tr></table></figure>
<p><strong>02、switch 语句 </strong></p>
<p>switch 语句用来判断变量与多个值之间的相等性。变量的类型可以是 byte、short、int 或者 char，或者对应的包装器类型 Byte、Short、Integer、Character，以及字符串和枚举类型。</p>
<p>来看一下 switch 语句的格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">switch(变量) &#123;    </span><br><span class="line">case 可选值1:    </span><br><span class="line"> // 可选值1匹配后执行的代码;    </span><br><span class="line"> break;  // 该关键字是可选项</span><br><span class="line">case 可选值2:    </span><br><span class="line"> // 可选值2匹配后执行的代码;    </span><br><span class="line"> break;  // 该关键字是可选项</span><br><span class="line">......    </span><br><span class="line">    </span><br><span class="line">default: // 该关键字是可选项     </span><br><span class="line"> // 所有可选值都不匹配后执行的代码 </span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<ul>
<li>变量可以有 1 个或者 N 个值。</li>
<li>值类型必须和变量类型是一致的，并且值是确定的。</li>
<li>值必须是唯一的，不能重复，否则编译会出错。</li>
<li>break 关键字是可选的，如果没有，则执行下一个 case，如果有，则跳出 switch 语句。</li>
<li>default 关键字也是可选的。</li>
</ul>
<p>画个流程图：</p>
<p><img src="\assets\note\image-20230926141611240.png" alt="image-20230926141611240"></p>
<p>来个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int age = 20;</span><br><span class="line">switch (age) &#123;</span><br><span class="line">    case 20 :</span><br><span class="line">        System.out.println(&quot;上学&quot;);</span><br><span class="line">        break;</span><br><span class="line">    case 24 :</span><br><span class="line">        System.out.println(&quot;苏州工作&quot;);</span><br><span class="line">        break;</span><br><span class="line">    case 30 :</span><br><span class="line">        System.out.println(&quot;洛阳工作&quot;);</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        System.out.println(&quot;未知&quot;);</span><br><span class="line">        break; // 可省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">上学</span><br></pre></td></tr></table></figure>
<p>当两个值要执行的代码相同时，可以把要执行的代码写在下一个 case 语句中，而上一个 case 语句中什么也没有，来看一下示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">String name = &quot;沉默王二&quot;;</span><br><span class="line">switch (name) &#123;</span><br><span class="line">    case &quot;詹姆斯&quot;:</span><br><span class="line">        System.out.println(&quot;篮球运动员&quot;);</span><br><span class="line">        break;</span><br><span class="line">    case &quot;穆里尼奥&quot;:</span><br><span class="line">        System.out.println(&quot;足球教练&quot;);</span><br><span class="line">        break;</span><br><span class="line">    case &quot;沉默王二&quot;:</span><br><span class="line">    case &quot;沉默王三&quot;:</span><br><span class="line">        System.out.println(&quot;乒乓球爱好者&quot;);</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        throw new IllegalArgumentException(</span><br><span class="line">                &quot;名字没有匹配项&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">乒乓球爱好者</span><br></pre></td></tr></table></figure>
<p>枚举作为 switch 语句的变量也很常见，来看例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class SwitchEnumDemo &#123;</span><br><span class="line">    public enum PlayerTypes &#123;</span><br><span class="line">        TENNIS,</span><br><span class="line">        FOOTBALL,</span><br><span class="line">        BASKETBALL,</span><br><span class="line">        UNKNOWN</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(createPlayer(PlayerTypes.BASKETBALL));</span><br><span class="line">    &#125;</span><br><span class="line">    private static String createPlayer(PlayerTypes playerType) &#123;</span><br><span class="line">        switch (playerType) &#123;</span><br><span class="line">            case TENNIS:</span><br><span class="line">                return &quot;网球运动员费德勒&quot;;</span><br><span class="line">            case FOOTBALL:</span><br><span class="line">                return &quot;足球运动员C罗&quot;;</span><br><span class="line">            case BASKETBALL:</span><br><span class="line">                return &quot;篮球运动员詹姆斯&quot;;</span><br><span class="line">            case UNKNOWN:</span><br><span class="line">                throw new IllegalArgumentException(&quot;未知&quot;);</span><br><span class="line">            default:</span><br><span class="line">                throw new IllegalArgumentException(</span><br><span class="line">                        &quot;运动员类型: &quot; + playerType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">篮球运动员詹姆斯</span><br></pre></td></tr></table></figure>
<p><strong>03、for 循环</strong></p>
<p><img src="\assets\note\image-20230926141859323.png" alt="image-20230926141859323"></p>
<p>1）普通 for 循环 </p>
<p>普通的 for 循环可以分为 4 个部分：</p>
<p>1）初始变量：循环开始执行时的初始条件。</p>
<p>2）条件：循环每次执行时要判断的条件，如果为 true，就执行循环体；如果为 false，就跳出循环。当然了，条件是可选的，如果没有条件，则会一直循环。</p>
<p>3）循环体：循环每次要执行的代码块，直到条件变为 false。</p>
<p>4）自增/自减：初始变量变化的方式。</p>
<p>来看一下普通 for 循环的格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(初始变量;条件;自增/自减)&#123;  </span><br><span class="line">// 循环体</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>画个流程图：</p>
<p><img src="\assets\note\image-20230926142018436.png" alt="image-20230926142018436"></p>
<p>来个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">    System.out.println(&quot;沉默好美啊&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">沉默好美啊</span><br><span class="line">沉默好美啊</span><br><span class="line">沉默好美啊</span><br><span class="line">沉默好美啊</span><br><span class="line">沉默好美啊</span><br></pre></td></tr></table></figure>
<p>循环语句还可以嵌套呢，这样就可以打印出更好玩的呢</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">    for (int j = 0;j&lt;= i;j++) &#123;</span><br><span class="line">        System.out.print(&quot;❤&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印出什么玩意呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">❤</span><br><span class="line">❤❤</span><br><span class="line">❤❤❤</span><br><span class="line">❤❤❤❤</span><br><span class="line">❤❤❤❤❤</span><br></pre></td></tr></table></figure>
<p>2）for-each </p>
<p>for-each 循环通常用于遍历数组和集合，它的使用规则比普通的 for 循环还要简单，不需要初始变量，不需要条件，不需要下标来自增或者自减。来看一下语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(元素类型 元素 : 数组或集合)&#123;  </span><br><span class="line">// 要执行的代码</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>来看一下示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] strs = &#123;&quot;沉默&quot;, &quot;一枚有趣的程序员&quot;&#125;;</span><br><span class="line">for (String str : strs) &#123;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">沉默</span><br><span class="line">一枚有趣的程序员</span><br></pre></td></tr></table></figure>
<p>3）无限 for 循环 </p>
<p>“你想不想体验一下无限 for 循环的威力，也就是死循环。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(;;)&#123;</span><br><span class="line">    System.out.println(&quot;停不下来。。。。&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">停不下来。。。。</span><br><span class="line">停不下来。。。。</span><br><span class="line">停不下来。。。。</span><br><span class="line">停不下来。。。。</span><br></pre></td></tr></table></figure>
<p>一旦运行起来，就停不下来了，除非强制停止。</p>
<p><strong>04、while 循环 </strong></p>
<p>来看一下 while 循环的格式：</p>
<p><img src="\assets\note\image-20230926142456894.png" alt="image-20230926142456894"></p>
<p>来个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int i = 0;</span><br><span class="line">while (true) &#123;</span><br><span class="line">    System.out.println(&quot;沉默&quot;);</span><br><span class="line">    i++;</span><br><span class="line">    if (i == 5) &#123;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">沉默</span><br><span class="line">沉默</span><br><span class="line">沉默</span><br><span class="line">沉默</span><br><span class="line">沉默</span><br></pre></td></tr></table></figure>
<p>“你想不想体验一下无限 while 循环的威力，也就是死循环。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while (true) &#123;</span><br><span class="line">    System.out.println(&quot;停不下来。。。。&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">停不下来。。。。</span><br><span class="line">停不下来。。。。</span><br><span class="line">停不下来。。。。</span><br><span class="line">停不下来。。。。</span><br></pre></td></tr></table></figure>
<p>把 while 的条件设置为 true，并且循环体中没有 break 关键字的话，程序一旦运行起来，就根本停不下来了，除非强制停止。</p>
<p><strong>05、do-while 循环 </strong></p>
<p>来看一下 do-while 循环的格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">do&#123;  </span><br><span class="line">// 循环体</span><br><span class="line">&#125;while(提交);  </span><br></pre></td></tr></table></figure>
<p>画个流程图：</p>
<p><img src="\assets\note\image-20230926142727978.png" alt="image-20230926142727978"></p>
<p>来个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int i = 0;</span><br><span class="line">do &#123;</span><br><span class="line">    System.out.println(&quot;沉默&quot;);</span><br><span class="line">    i++;</span><br><span class="line">    if (i == 5) &#123;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; while (true);</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">沉默</span><br><span class="line">沉默</span><br><span class="line">沉默</span><br><span class="line">沉默</span><br><span class="line">沉默</span><br></pre></td></tr></table></figure>
<p>“你想不想体验一下无限 do-while 循环的威力……”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">    System.out.println(&quot;停不下来。。。。&quot;);</span><br><span class="line">&#125; while (true);</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">停不下来。。。。</span><br><span class="line">停不下来。。。。</span><br><span class="line">停不下来。。。。</span><br><span class="line">停不下来。。。。</span><br></pre></td></tr></table></figure>
<p>把 do-while 的条件设置为 true，并且循环体中没有 break 关键字的话，程序一旦运行起来，就根本停不下来了，除非强制停止。</p>
<p><img src="\assets\note\image-20230926155231166.png" alt="image-20230926155231166"></p>
<p><strong>06、break </strong></p>
<p>break 关键字通常用于中断循环或 switch 语句，它在指定条件下中断程序的当前流程。如果是内部循环，则仅中断内部循环。</p>
<p>可以将 break 关键字用于所有类型循环语句中，比如说 for 循环、while 循环，以及 do-while 循环。</p>
<p>来画个流程图感受一下：</p>
<p><img src="\assets\note\image-20230926155326551.png" alt="image-20230926155326551"></p>
<p>用在 for 循环中的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 1; i &lt;= 10; i++) &#123;</span><br><span class="line">    if (i == 5) &#123;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用在嵌套 for 循环中的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 1; i &lt;= 3; i++) &#123;</span><br><span class="line">    for (int j = 1; j &lt;= 3; j++) &#123;</span><br><span class="line">        if (i == 2 &amp;&amp; j == 2) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(i + &quot; &quot; + j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用在 while 循环中的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int i = 1;</span><br><span class="line">while (i &lt;= 10) &#123;</span><br><span class="line">    if (i == 5) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用在 do-while 循环中的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int j = 1;</span><br><span class="line">do &#123;</span><br><span class="line">    if (j == 5) &#123; </span><br><span class="line">        j++;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(j);</span><br><span class="line">    j++;</span><br><span class="line">&#125; while (j &lt;= 10);</span><br></pre></td></tr></table></figure>
<p>用在 switch 语句中的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">switch (age) &#123;</span><br><span class="line">    case 20 :</span><br><span class="line">        System.out.println(&quot;上学&quot;);</span><br><span class="line">        break;</span><br><span class="line">    case 24 :</span><br><span class="line">        System.out.println(&quot;苏州工作&quot;);</span><br><span class="line">        break;</span><br><span class="line">    case 30 :</span><br><span class="line">        System.out.println(&quot;洛阳工作&quot;);</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        System.out.println(&quot;未知&quot;);</span><br><span class="line">        break; // 可省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>07、continue </strong></p>
<p>当我们需要在 for 循环或者 （do）while 循环中立即跳转到下一个循环时，就可以使用 continue 关键字，通常用于跳过指定条件下的循环体，如果循环是嵌套的，仅跳过当前循环。</p>
<p>来个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 1; i &lt;= 10; i++) &#123;</span><br><span class="line">    if (i == 5) &#123;</span><br><span class="line">        // 使用 continue 关键字</span><br><span class="line">        continue;// 5 将会被跳过</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>再来个循环嵌套的例子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 1; i &lt;= 3; i++) &#123;</span><br><span class="line">    for (int j = 1; j &lt;= 3; j++) &#123;</span><br><span class="line">        if (i == 2 &amp;&amp; j == 2) &#123;</span><br><span class="line">            //  当i=2，j=2时跳过</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(i + &quot; &quot; + j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印出什么玩意呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 1</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 1</span><br><span class="line">2 3</span><br><span class="line">3 1</span><br><span class="line">3 2</span><br><span class="line">3 3</span><br></pre></td></tr></table></figure>
<p>“2 2” 没有输出，被跳过了。</p>
<p>再来看一下 while 循环时 continue 的使用示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int i = 1;</span><br><span class="line">while (i &lt;= 10) &#123;</span><br><span class="line">    if (i == 5) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        continue;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>注意：如果把 if 条件中的“i++”省略掉的话，程序就会进入死循环，一直在 continue。</p>
<p>最后，再来看一下 do-while 循环时 continue 的使用示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int i=1;</span><br><span class="line">do&#123;</span><br><span class="line">    if(i==5)&#123;</span><br><span class="line">        i++;</span><br><span class="line">        continue;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    i++;</span><br><span class="line">&#125;while(i&lt;=10);</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>注意：同样的，如果把 if 条件中的“i++”省略掉的话，程序就会进入死循环，一直在 continue。</p>
<p><strong>08、小结 </strong></p>
<p>本文全面讲解了Java流程控制语句，包括if、switch、while、for等结构。通过学习本文，你将了解到Java流程控制语句的基本概念、语法结构和使用场景，帮助你在实际编程过程中更加灵活地运用各类控制结构。</p>
<h1 id="2-数组-amp-字符串"><a href="#2-数组-amp-字符串" class="headerlink" title="2 数组&amp;字符串"></a>2 数组&amp;字符串</h1><h2 id="2-1-掌握Java数组"><a href="#2-1-掌握Java数组" class="headerlink" title="2.1 掌握Java数组"></a>2.1 掌握Java数组</h2><p>“ArrayList 的内部是用数组实现的”</p>
<p>“的确是的，看 ArrayList 的源码就一清二楚了。”我一边说，一边打开 Intellij IDEA，并找到了 ArrayList 的源码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The array buffer into which the elements of the ArrayList are stored.</span><br><span class="line"> * The capacity of the ArrayList is the length of this array buffer. Any</span><br><span class="line"> * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><br><span class="line"> * will be expanded to DEFAULT_CAPACITY when the first element is added.</span><br><span class="line"> */</span><br><span class="line">transient Object[] elementData; // non-private to simplify nested class access</span><br><span class="line">/**</span><br><span class="line"> * The size of the ArrayList (the number of elements it contains).</span><br><span class="line"> *</span><br><span class="line"> * @serial</span><br><span class="line"> */</span><br><span class="line">private int size;</span><br></pre></td></tr></table></figure>
<p>“瞧见没？ Object[] elementData 就是数组。”我指着显示屏上这串代码继续说。</p>
<p>数组是一个对象，它包含了一组固定数量的元素，并且这些元素的类型是相同的。数组会按照索引的方式将元素放在指定的位置上，意味着我们可以通过索引来访问这些元素。在 Java 中，索引是从 0 开始的。</p>
<p>“能说一下为什么索引从 0 开始吗？”</p>
<p>“哦，Java 是基于 C/C++ 语言实现的，而 C 语言的下标是从 0 开始的，所以 Java 就继承了这个良好的传统习惯。C语言有一个很重要概念，叫做指针，它实际上是一个偏移量，距离开始位置的偏移量，第一个元素就在开始的位置，它的偏移量就为 0，所以索引就为 0。”此刻，我很自信。</p>
<p>“此外，还有另外一种说法。早期的计算机资源比较匮乏，0 作为起始下标相比较于 1 作为起始下标，编译的效率更高。”</p>
<p>我们可以将数组理解为一个个整齐排列的单元格，每个单元格里面存放着一个元素。</p>
<p>数组元素的类型可以是基本数据类型（比如说 int、double），也可以是引用数据类型（比如说 String），包括自定义类型。</p>
<p>数组的声明方式分两种。</p>
<p>先来看第一种：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[] anArray;</span><br></pre></td></tr></table></figure>
<p>再来看第二种：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int anOtherArray[];</span><br></pre></td></tr></table></figure>
<p>不同之处就在于中括号的位置，是跟在类型关键字的后面，还是跟在变量的名称的后面。前一种的使用频率更高一些，像 ArrayList 的源码中就用了第一种方式。</p>
<p>同样的，数组的初始化方式也有多种，最常见的是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[] anArray = new int[10];</span><br></pre></td></tr></table></figure>
<p>看到了没？上面这行代码中使用了 new 关键字，这就意味着数组的确是一个对象，只有对象的创建才会用到 new 关键字，基本数据类型是不用的。然后，我们需要在方括号中指定数组的长度。</p>
<p>这时候，数组中的每个元素都会被初始化为默认值，int 类型的就为 0，Object 类型的就为 null。 不同数据类型的默认值不同。</p>
<p>另外，还可以使用大括号的方式，直接初始化数组中的元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int anOtherArray[] = new int[] &#123;1, 2, 3, 4, 5&#125;;</span><br></pre></td></tr></table></figure>
<p>这时候，数组的元素分别是 1、2、3、4、5，索引依次是 0、1、2、3、4，长度是 5。</p>
<p>“怎么访问数组呢？”</p>
<p>前面提到过，可以通过索引来访问数组的元素，就像下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">anArray[0] = 10;</span><br></pre></td></tr></table></figure>
<p>变量名，加上中括号，加上元素的索引，就可以访问到数组，通过“=”操作符可以对元素进行赋值。</p>
<p>如果索引的值超出了数组的界限，就会抛出 ArrayIndexOutOfBoundException 。</p>
<p>既然数组的索引是从 0 开始，那就是到数组的 length - 1 结束，不要使用超出这个范围内的索引访问数组，就不会抛出数组越界的异常了。 </p>
<p>当数组的元素非常多的时候，逐个访问数组就太辛苦了，所以需要通过遍历的方式。</p>
<p>第一种，使用 for 循环：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int anOtherArray[] = new int[] &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">for (int i = 0; i &lt; anOtherArray.length; i++) &#123;</span><br><span class="line">    System.out.println(anOtherArray[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 length 属性获取到数组的长度，然后从 0 开始遍历，就得到了数组的所有元素。</p>
<p>第二种，使用 for-each 循环：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (int element : anOtherArray) &#123;</span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不需要关心索引的话（意味着不需要修改数组的某个元素），使用 for-each 遍历更简洁一些。当然，也可以使用 while 和 do-while 循环。</p>
<p>在 Java 中，可变参数用于将任意数量的参数传递给方法，来看 varargsMethod() 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void varargsMethod(String... varargs) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>该方法可以接收任意数量的字符串参数，可以是 0 个或者 N 个，本质上，可变参数就是通过数组实现的。为了证明这一点，我们可以看一下反编译一后的字节码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class VarargsDemo</span><br><span class="line">&#123;</span><br><span class="line">    public VarargsDemo()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    transient void varargsMethod(String as[])</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，我们其实可以直接将数组作为参数传递给该方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VarargsDemo demo = new VarargsDemo();</span><br><span class="line">String[] anArray = new String[] &#123;&quot;沉默&quot;, &quot;一枚有趣的程序员&quot;&#125;;</span><br><span class="line">demo.varargsMethod(anArray);</span><br></pre></td></tr></table></figure>
<p>也可以直接传递多个字符串，通过逗号隔开的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">demo.varargsMethod(&quot;沉默&quot;, &quot;一枚有趣的程序员&quot;);</span><br></pre></td></tr></table></figure>
<p>在 Java 中，数组与 List 关系非常密切。List 封装了很多常用的方法，方便我们对集合进行一些操作，而如果直接操作数组的话，有很多不便，因为数组本身没有提供这些封装好的操作，所以有时候我们需要把数组转成 List。</p>
<p>“怎么转呢？”</p>
<p>最原始的方式，就是通过遍历数组的方式，一个个将数组添加到 List 中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int[] anArray = new int[] &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">List&lt;Integer&gt; aList = new ArrayList&lt;&gt;();</span><br><span class="line">for (int element : anArray) &#123;</span><br><span class="line">    aList.add(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更优雅的方式是通过 Arrays 类的 asList() 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; aList = Arrays.asList(anArray);</span><br></pre></td></tr></table></figure>
<p>不过需要注意的是，Arrays.asList 的参数需要是 Integer 数组，而 anArray 目前是 int 类型，我们需要换另外一种方式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; aList = Arrays.stream(anArray).boxed().collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<p>这又涉及到了 Java 流的知识，后面会讲到。</p>
<p>还有一个需要注意的是，Arrays.asList 方法返回的 ArrayList 并不是 java.util.ArrayList ，它其实是Arrays 类的一个内部类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class="line">        implements RandomAccess, java.io.Serializable&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>如果需要添加元素或者删除元素的话，需要把它转成 java.util.ArrayList 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new ArrayList&lt;&gt;(Arrays.asList(anArray));</span><br></pre></td></tr></table></figure>
<p>Java 8 新增了 Stream 流的概念，这就意味着我们也可以将数组转成 Stream 进行操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] anArray = new String[] &#123;&quot;沉默&quot;, &quot;一枚有趣的程序员&quot;, &quot;好好珍重他&quot;&#125;;</span><br><span class="line">Stream&lt;String&gt; aStream = Arrays.stream(anArray);</span><br></pre></td></tr></table></figure>
<p>如果想对数组进行排序的话，可以使用 Arrays 类提供的 sort() 方法。</p>
<ul>
<li>基本数据类型按照升序排列</li>
<li>实现了 Comparable 接口的对象按照 compareTo() 的排序</li>
</ul>
<p>来看第一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int[] anArray = new int[] &#123;5, 2, 1, 4, 8&#125;;</span><br><span class="line">Arrays.sort(anArray);</span><br></pre></td></tr></table></figure>
<p>排序后的结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 4, 5, 8]</span><br></pre></td></tr></table></figure>
<p>来看第二个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] yetAnotherArray = new String[] &#123;&quot;A&quot;, &quot;E&quot;, &quot;Z&quot;, &quot;B&quot;, &quot;C&quot;&#125;;</span><br><span class="line">Arrays.sort(yetAnotherArray, 1, 3,</span><br><span class="line">                Comparator.comparing(String::toString).reversed());</span><br></pre></td></tr></table></figure>
<p>只对 1-3 位置上的元素进行反序，所以结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[A, Z, E, B, C]</span><br></pre></td></tr></table></figure>
<p>有时候，我们需要从数组中查找某个具体的元素，最直接的方式就是通过遍历的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int[] anArray = new int[] &#123;5, 2, 1, 4, 8&#125;;</span><br><span class="line">for (int i = 0; i &lt; anArray.length; i++) &#123;</span><br><span class="line">    if (anArray[i] == 4) &#123;</span><br><span class="line">        System.out.println(&quot;找到了 &quot; + i);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上例中从数组中查询元素 4，找到后通过 break 关键字退出循环。</p>
<p>如果数组提前进行了排序，就可以使用二分查找法，这样效率就会更高一些。 Arrays.binarySearch() 方法可供我们使用，它需要传递一个数组，和要查找的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int[] anArray = new int[] &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">int index = Arrays.binarySearch(anArray, 4);</span><br></pre></td></tr></table></figure>
<h2 id="2-2-掌握Java二维数组"><a href="#2-2-掌握Java二维数组" class="headerlink" title="2.2 掌握Java二维数组"></a>2.2 掌握Java二维数组</h2><p><strong>01、什么是二维数组 </strong></p>
<p>二维数组是一种数据类型，可以存储多行和多列的数据。它由一系列的行和列组成，每个元素都可以通过一个行索引和列索引来访问。例如，一个3行4列的二维数组可以表示为以下形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array = [</span><br><span class="line">  [a, b, c, d],</span><br><span class="line">  [e, f, g, h],</span><br><span class="line">  [i, j, k, l]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>在这个例子中，第一行有4个元素，第二行有4个元素，第三行有4个元素，每个元素都有一个行索引和一个列索引。例如，元素 array[1][2] 是第2行第3列的元素，它的值是 g。</p>
<p>使用二维数组可以有效地存储和处理表格数据，如矩阵、图像、地图等等。</p>
<p><strong>02、创建二维数组 </strong></p>
<p>要在 Java 中创建二维数组，你必须指定要存储在数组中的数据类型，后跟两个方括号和数组的名称。</p>
<p>语法如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data_type[][] array_name;</span><br></pre></td></tr></table></figure>
<p>让我们看一个代码示例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[][] oddNumbers = &#123; &#123;1, 3, 5, 7&#125;, &#123;9, 11, 13, 15&#125; &#125;;</span><br></pre></td></tr></table></figure>
<p><strong>03、访问二维数组中的元素 </strong></p>
<p>我们可以使用两个方括号来访问二维中的元素。</p>
<p>第一个表示我们要从中访问元素的数组，而第二个表示我们要访问的元素索引。</p>
<p>让我们用一个例子来简化上面的解释：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int[][] oddNumbers = &#123; &#123;1, 3, 5, 7&#125;, &#123;9, 11, 13, 15&#125; &#125;;</span><br><span class="line">System.out.println(oddNumbers[0][0]);</span><br><span class="line">// 1</span><br></pre></td></tr></table></figure>
<p>在上面的示例中， oddNumbers 数组中有两个数组—— {1, 3, 5, 7} 和 {9, 11, 13, 15} 。</p>
<p>第一个数组—— {1, 3, 5, 7} ——用 0 表示。</p>
<p>第二个数组—— {9, 11, 13, 15} ——用 1 表示。</p>
<p>第一个数组是 0，第二个是 1，第三个是 2，依此类推。</p>
<p>因此，要访问第一个数组中的项目，我们将 0 分配给第一个方括号。由于我们试图访问数组中的第一项，我们将使用它的索引，即 0： oddNumbers[0][0] 。</p>
<p>让我们进一步分解它。</p>
<p>这是访问元素的代码： oddNumbers[?][?] 。</p>
<p>我在两个方括号中都加上了问号——随着进展填写它们。</p>
<p>假设我们要访问第二个数组中的元素，我们的代码将如下所示： oddNumbers[1][?] 。</p>
<p>现在我们要在第二个数组（ {9, 11, 13, 15} ）中尝试访问其中一个元素。就像一维数组一样，每个元素都有一个从零开始的索引。</p>
<p>因此，要访问第三个元素 13 ，我们将其索引号传递给第二个方括号： oddNumbers[1][2] 。</p>
<p>来看这样一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[][] oddNumbers = &#123; &#123;1, 3, 5, 7&#125;, &#123;9, 11, 13, 15&#125;, &#123;17, 19, 21, 23&#125; &#125;;</span><br></pre></td></tr></table></figure>
<p>我们的目标是访问第三个数组中的 21。访问方式仍然通过问号来表示： oddNumbers[?][?] 。</p>
<p>我们首先给第一个问号一个指向要访问的特定数组的值。</p>
<p>数组 0 =&gt; {1, 3, 5, 7}</p>
<p>数组 1 =&gt; {9, 11, 13, 15}</p>
<p>数组 2 =&gt; {17, 19, 21, 23}</p>
<p>我们要查找的数字在第三个数组中，所以是： oddNumbers[2][?] 。</p>
<p>第二个方括号的值将指向要访问的元素。为此，我们必须指定元素的索引。以下是该数组中的索引：</p>
<p>17 =&gt; 索引 0</p>
<p>19 =&gt; 索引 1</p>
<p>21 =&gt; 索引 2</p>
<p>23 =&gt; 索引 3</p>
<p>21 的索引为 2，因此我们可以将其添加到第二个方括号： oddNumbers[2][2] 。当你将其打印到控制台时，将会打印出 21。</p>
<p>代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int[][] oddNumbers = &#123; &#123;1, 3, 5, 7&#125;, &#123;9, 11, 13, 15&#125;, &#123;17, 19, 21, 23&#125; &#125;;</span><br><span class="line">System.out.println(oddNumbers[2][2]);</span><br><span class="line">// 21</span><br></pre></td></tr></table></figure>
<p>你可以使用嵌套循环，遍历二维数组中的所有项目。这是一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int[][] oddNumbers = &#123; &#123;1, 3, 5, 7&#125;, &#123;9, 11, 13, 15&#125;, &#123;17, 19, 21, 23&#125; &#125;;</span><br><span class="line">for(int i = 0; i &lt; oddNumbers.length; i++)&#123;</span><br><span class="line">    for(int j = 0; j &lt; oddNumbers[i].length; j++)&#123;</span><br><span class="line">        System.out.println(oddNumbers[i][j]);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line">// 1</span><br><span class="line">// 3</span><br><span class="line">// 5</span><br><span class="line">// 7</span><br><span class="line">// 9</span><br><span class="line">// 11</span><br><span class="line">// 13</span><br><span class="line">// 15</span><br><span class="line">// 17</span><br><span class="line">// 19</span><br><span class="line">// 21</span><br><span class="line">// 23</span><br></pre></td></tr></table></figure>
<p>上面的代码将会打印出 oddNumbers 数组中的所有项目。</p>
<p><strong>04、二维数组打印杨辉三角</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class YangHuiTriangle &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner input = new Scanner(System.in);</span><br><span class="line">        System.out.print(&quot;请输入要打印的行数：&quot;);</span><br><span class="line">        int n = input.nextInt();</span><br><span class="line">        printYangHuiTriangle(n);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void printYangHuiTriangle(int n) &#123;</span><br><span class="line">        int[][] triangle = new int[n][n];</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            // 每行的第一个和最后一个数字都是1</span><br><span class="line">            triangle[i][0] = 1;</span><br><span class="line">            triangle[i][i] = 1;</span><br><span class="line">            for (int j = 1; j &lt; i; j++) &#123;</span><br><span class="line">                // 其他数字是上一行的两个数字之和</span><br><span class="line">                triangle[i][j] = triangle[i - 1][j - 1] + triangle[i - 1][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 打印杨辉三角</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt;= i; j++) &#123;</span><br><span class="line">                System.out.print(triangle[i][j] + &quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“这段代码使用了一个二维数组来存储杨辉三角中的数字。首先，程序要求用户输入要打印的行数，然后调用 printYangHuiTriangle 方法来生成和打印杨辉三角。在 printYangHuiTriangle 方法中，程序使用了一个嵌套的 for 循环来计算杨辉三角中的每个数字，并将结果存储在二维数组 triangle 中。最后，程序再次使用循环来遍历数组并打印出杨辉三角中的数字。”</p>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">请输入要打印的行数：6</span><br><span class="line">1 </span><br><span class="line">1 1 </span><br><span class="line">1 2 1 </span><br><span class="line">1 3 3 1 </span><br><span class="line">1 4 6 4 1 </span><br><span class="line">1 5 10 10 5 1 </span><br></pre></td></tr></table></figure>
<h2 id="2-3-打印Java数组"><a href="#2-3-打印Java数组" class="headerlink" title="2.3 打印Java数组"></a>2.3 打印Java数组</h2><p>“数组也是一个对象，但 Java 中并未明确的定义这样一个类。”</p>
<p>“是的，因此数组也就没有机会覆盖 Object.toString() 方法。如果尝试直接打印数组的话，输出的结果并不是我们预期的结果。”</p>
<p>“那怎么打印数组呢？”</p>
<p>为什么不能直接打印数组</p>
<p>“首先，我们来看一下，为什么不能直接打印数组，直接打印的话，会出现什么问题。”</p>
<p>来看这样一个例子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String [] cmowers = &#123;&quot;沉默&quot;,&quot;一枚有趣的程序员&quot;&#125;;</span><br><span class="line">System.out.println(cmowers);</span><br></pre></td></tr></table></figure>
<p>程序打印的结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Ljava.lang.String;@3d075dc0</span><br></pre></td></tr></table></figure>
<p>[Ljava.lang.String; 表示字符串数组的 Class 名，@ 后面的是十六进制的 hashCode——这样的打印结果太“人性化”了，一般人表示看不懂！为什么会这样显示呢？查看一下 java.lang.Object 类的 toString() 方法就明白了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String [] cmowers = &#123;&quot;沉默&quot;,&quot;王二&quot;,&quot;一枚有趣的程序员&quot;&#125;;</span><br><span class="line">System.out.println(cmowers);</span><br></pre></td></tr></table></figure>
<p>再次证明，数组虽然没有显式定义成一个类，但它的确是一个对象，继承了祖先类 Object 的所有方法。</p>
<p>“那为什么数组不单独定义一个类来表示呢？就像字符串 String 类那样呢？”</p>
<p>“一个合理的说法是 Java 将其隐藏了。假如真的存在这么一个类，就叫 Array.java 吧，我们假想一下它真实的样子，必须得有一个容器来存放数组的每一个元素，就像 String 类那样。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final class String</span><br><span class="line">    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    /** The value is used for character storage. */</span><br><span class="line">    private final char value[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“最终还是要用类似一种数组的形式来存放数组的元素，对吧？这就变得很没有必要了，不妨就把数组当做是一个没有形体的对象吧！”</p>
<p><strong>stream 流打印 Java 数组 </strong></p>
<p>“我们来看第一种打印数组的方法，使用时髦一点的Stream 流。”</p>
<p>第一种形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList(cmowers).stream().forEach(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure>
<p>第二种形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(cmowers).forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>第三种形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.stream(cmowers).forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>打印的结果如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">沉默</span><br><span class="line">一枚有趣的程序员</span><br></pre></td></tr></table></figure>
<p>没错，这三种方式都可以轻松胜任本职工作，并且显得有点高大上，毕竟用到了 Stream，以及 lambda 表达式。</p>
<p><strong>for 循环打印 Java 数组 </strong></p>
<p>“当然了，也可以使用传统的方式，for 循环。甚至 for-each 也行。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(int i = 0; i &lt; cmowers.length; i++)&#123;</span><br><span class="line">    System.out.println(cmowers[i]);</span><br><span class="line">&#125;</span><br><span class="line">for (String s : cmowers) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Arrays 工具类打印 Java 数组 </strong></p>
<p>“当然没有了，我认为 Arrays.toString() 是打印数组的最佳方式，没有之一。”Arrays.toString() 可以将任意类型的数组转成字符串，包括基本类型数组和引用类型数组。该方法有多种重载形式。</p>
<p><img src="\assets\note\image-20230927095033931.png" alt="image-20230927095033931"></p>
<p>使用 Arrays.toString() 方法来打印数组再优雅不过了，就像，就像，就像蒙娜丽莎的微笑。</p>
<p><img src="\assets\note\image-20230927095116614.png" alt="image-20230927095116614"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String [] cmowers = &#123;&quot;沉默&quot;,&quot;一枚有趣的程序员&quot;&#125;;</span><br><span class="line">System.out.println(Arrays.toString(cmowers));</span><br></pre></td></tr></table></figure>
<p>程序打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[沉默, 一枚有趣的程序员]</span><br></pre></td></tr></table></figure>
<p>哇，打印格式不要太完美，不多不少！完全是我们预期的结果： [] 表明是一个数组， , 点和空格用来分割元素。</p>
<p><strong>Arrays工具类打印二维数组 </strong></p>
<p>“那如果我想打印二维数组呢？”</p>
<p>“可以使用 Arrays.deepToString() 方法。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[][] deepArray = new String[][] &#123;&#123;&quot;沉默&quot;&#125;, &#123;&quot;一枚有趣的程序员&quot;&#125;&#125;;</span><br><span class="line">System.out.println(Arrays.deepToString(deepArray));</span><br></pre></td></tr></table></figure>
<p>打印结果如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[沉默], [一枚有趣的程序员]]</span><br></pre></td></tr></table></figure>
<p><strong>POJO 的打印规约 </strong></p>
<p>“说到打印，哥给你提醒一点。阿里巴巴的 Java 开发手册上有这样一条规约，你看。”</p>
<p><img src="\assets\note\image-20230927095402737.png" alt="image-20230927095402737"></p>
<p>“什么是 POJO 呢，就是 Plain Ordinary Java Object 的缩写，一般在 Web 应用程序中建立一个数据库的映射对象时，我们称它为 POJO，这类对象不继承或不实现任何其它 Java 框架的类或接口。”</p>
<p>“对于这样的类，最好是重写一下它的 toString() 方法，方便查看这个对象到底包含了什么字段，好排查问题。”</p>
<p>“如果不重写的话，打印出来的 Java 对象就像直接打印数组的那样，一串谁也看不懂的字符序列。”</p>
<p>“可以借助 Intellij IDEA 生成重写的  toString() 方法，特别方便。”</p>
<p><strong>2.4 解读String类源码 </strong></p>
<p>String 类的声明 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final class String</span><br><span class="line">    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“第一，String 类是 final 的，意味着它不能被子类继承。”</p>
<p>“第二，String 类实现了 Serializable 接口，意味着它可以序列化。”</p>
<p>“第三，String 类实现了 Comparable 接口，意味着最好不要用‘==’来比较两个字符串是否相等，而应该用 compareTo() 方法去比较。”</p>
<p>因为 == 是用来比较两个对象的地址，这个在讲字符串比较的时候会详细讲。如果只是说比较字符串内容的话，可以使用 String 类的 equals 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object anObject) &#123;</span><br><span class="line">    if (this == anObject) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (anObject instanceof String) &#123;</span><br><span class="line">        String anotherString = (String) anObject;</span><br><span class="line">        int n = value.length;</span><br><span class="line">        if (n == anotherString.value.length) &#123;</span><br><span class="line">            char v1[] = value;</span><br><span class="line">            char v2[] = anotherString.value;</span><br><span class="line">            int i = 0;</span><br><span class="line">            while (n-- != 0) &#123;</span><br><span class="line">                if (v1[i] != v2[i])</span><br><span class="line">                    return false;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“第四，StringBuffer、StringBuilder 和 String 一样，都实现了 CharSequence 接口，所以它们仨属于近亲。由于 String 是不可变的，所以遇到字符串拼接的时候就可以考虑一下 String 的另外两个好兄弟，<strong>StringBuffer 和 StringBuilder，它俩是可变的。”</strong></p>
<p><strong>String 类的底层实现 </strong></p>
<p>“第五，Java 9 以前，String 是用 char 型数组实现的，之后改成了 byte 型数组实现，并增加了 coder 来表示编码。这样做的好处是在 Latin1 字符为主的程序里，可以把 String 占用的内存减少一半。当然，天下没有免费的午餐，这个改进在节省内存的同时引入了编码检测的开销。”</p>
<blockquote>
<p>Latin1（Latin-1）是一种单字节字符集（即每个字符只使用一个字节的编码方式），也称为ISO-8859-1（国际标准化组织8859-1），它包含了西欧语言中使用的所有字符，包括英语、法语、德语、西班牙语、葡萄牙语、意大利语等等。在Latin1编码中，每个字符使用一个8位（即一个字节）的编码，可以表示256种不同的字符，其中包括ASCII字符集中的所有字符，即0x00到0x7F，以及其他西欧语言中的特殊字符，例如é、ü、ñ等等。由于Latin1只使用一个字节表示一个字符，因此在存储和传输文本时具有较小的存储空间和较快的速度</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final class String</span><br><span class="line">    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    @Stable</span><br><span class="line">    private final byte[] value;</span><br><span class="line">    private final byte coder;</span><br><span class="line">    private int hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们来详细地说一下。</p>
<p>从 char[] 到 byte[] ，最主要的目的是节省字符串占用的内存空间。内存占用减少带来的另外一个好处，就是 GC 次数也会减少。</p>
<p>我们使用 jmap -histo:live pid | head -n 10 命令就可以查看到堆内对象示例的统计信息、查看 ClassLoader 的信息以及 finalizer 队列。</p>
<p>以我正在运行着的编程喵项目实例（基于 Java 8）来说，结果是这样的。</p>
<p><img src="\assets\note\image-20230927100036881.png" alt="image-20230927100036881"></p>
<p>其中 String 对象有 17638 个，占用了 423312 个字节的内存，排在第三位。</p>
<p>由于 Java 8 的 String 内部实现仍然是 char[] ，所以我们可以看到内存占用排在第 1 位的就是 char 数组。char[] 对象有 17673 个，占用了 1621352 个字节的内存，排在第一位。</p>
<p>那也就是说优化 String 节省内存空间是非常有必要的，如果是去优化一个使用频率没有 String 这么高的类，就没什么必要，对吧？</p>
<p>众所周知，char 类型的数据在 JVM 中是占用两个字节的，并且使用的是 UTF-8 编码，其值范围在 ‘\u0000’（0）和 ‘\uffff’（65,535）（包含）之间。</p>
<p>也就是说，使用 char[] 来表示 String 就会导致，即使 String 中的字符只用一个字节就能表示，也得占用两个字节。</p>
<blockquote>
<p>PS：在计算机中，单字节字符通常指的是一个字节（8位）可以表示的字符，而双字节字符则指需要两个字节（16位）才能表示的字符。单字节字符和双字节字符的定义是相对的，不同的编码方式对应的单字节和双字节字符集也不同。常见的单字节字符集有ASCII（美国信息交换标准代码）、ISO-8859（国际标准化组织标准编号8859）、GBK（汉字内码扩展规范）、GB2312（中国国家标准，现在已经被GBK取代），像拉丁字母、数字、标点符号、控制字符都是单字节字符。双字节字符集包括 Unicode、UTF-8、GB18030（中国国家标准），中文、日文、韩文、拉丁文扩展字符属于双字节字符。</p>
</blockquote>
<p>当然了，仅仅将 char[] 优化为 byte[] 是不够的，还要配合 Latin-1 的编码方式，该编码方式是用单个字节来表示字符的，这样就比 UTF-8 编码节省了更多的空间。</p>
<p>换句话说，对于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String name = &quot;jack&quot;;</span><br></pre></td></tr></table></figure>
<p>这样的，使用 Latin-1 编码，占用 4 个字节就够了。</p>
<p>但对于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String name = &quot;小二&quot;;</span><br></pre></td></tr></table></figure>
<p>这种，木的办法，只能使用 UTF16 来编码。</p>
<p>针对 JDK 9 的 String 源码里，为了区别编码方式，追加了一个 coder 字段来区分。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The identifier of the encoding used to encode the bytes in</span><br><span class="line"> * &#123;@code value&#125;. The supported values in this implementation are</span><br><span class="line"> *</span><br><span class="line"> * LATIN1</span><br><span class="line"> * UTF16</span><br><span class="line"> *</span><br><span class="line"> * @implNote This field is trusted by the VM, and is a subject to</span><br><span class="line"> * constant folding if String instance is constant. Overwriting this</span><br><span class="line"> * field after construction will cause problems.</span><br><span class="line"> */</span><br><span class="line">private final byte coder;</span><br></pre></td></tr></table></figure>
<p>Java 会根据字符串的内容自动设置为相应的编码，要么 Latin-1 要么 UTF16。</p>
<p>也就是说，从 char[] 到 byte[] ，<strong>中文是两个字节，纯英文是一个字节，在此之前呢，中文是两个字节，英文也是两个字节。</strong></p>
<p>在 UTF-8 中，0-127 号的字符用 1 个字节来表示，使用和 ASCII 相同的编码。只有 128 号及以上的字符才用 2 个、3 个或者 4 个字节来表示。</p>
<ul>
<li>如果只有一个字节，那么最高的比特位为 0；</li>
<li>如果有多个字节，那么第一个字节从最高位开始，连续有几个比特位的值为 1，就使用几个字节编码，剩下的字节均以 10 开头。</li>
</ul>
<p>具体的表现形式为：</p>
<ul>
<li>0xxxxxxx：一个字节；</li>
<li>110xxxxx 10xxxxxx：两个字节编码形式（开始两个 1）；</li>
<li>1110xxxx 10xxxxxx 10xxxxxx：三字节编码形式（开始三个 1）；</li>
<li>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx：四字节编码形式（开始四个 1）。</li>
</ul>
<p>也就是说，UTF-8 是变长的，那对于 String 这种有随机访问方法的类来说，就很不方便。所谓的随机访问，就是charAt、subString这种方法，随便指定一个数字，String要能给出结果。如果字符串中的每个字符占用的内存是不定长的，那么进行随机访问的时候，就需要从头开始数每个字符的长度，才能找到你想要的字符。</p>
<p>那你可能会问，UTF-16也是变长的呢？一个字符还可能占用 4 个字节呢？</p>
<p>的确，UTF-16 使用 2 个或者 4 个字节来存储字符。</p>
<ul>
<li>对于 Unicode 编号范围在 0 ~ FFFF 之间的字符，UTF-16 使用两个字节存储。</li>
<li>对于 Unicode 编号范围在 10000 ~ 10FFFF 之间的字符，UTF-16 使用四个字节存储，具体来说就是：将字符编号的所有比特位分成两部分，较高的一些比特位用一个值介于 D800~DBFF 之间的双字节存储，较低的一些比特位（剩下的比特位）用一个值介于 DC00~DFFF 之间的双字节存储。</li>
</ul>
<p>但是在 Java 中，一个字符（char）就是 2 个字节，占 4 个字节的字符，在 Java 里也是用两个 char 来存储的，而String的各种操作，都是以Java的字符（char）为单位的，charAt是取得第几个char，subString取的也是第几个到第几个char组成的子串，甚至length返回的都是char的个数。</p>
<p>所以UTF-16在Java的世界里，就可以视为一个定长的编码。</p>
<p><strong>String 类的 hashCode 方法 </strong></p>
<p>“第六，每一个字符串都会有一个 hash 值，这个哈希值在很大概率是不会重复的，因此 String 很适合来作为 HashMap 的键值。”</p>
<p>来看 String 类的 hashCode 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private int hash; // Cache the hash code for the string</span><br><span class="line">public int hashCode() &#123;</span><br><span class="line">    int h = hash;</span><br><span class="line">    if (h == 0 &amp;&amp; value.length &gt; 0) &#123;</span><br><span class="line">        char val[] = value;</span><br><span class="line">        for (int i = 0; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = 31 * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    return h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>hashCode 方法首先检查是否已经计算过哈希码，如果已经计算过，则直接返回缓存的哈希码。否则，方法将使用一个循环遍历字符串的所有字符，并使用一个乘法和加法的组合计算哈希码。这种计算方法被称为“31 倍哈希法”。计算完成后，将得到的哈希值存储在 hash 成员变量中，以便下次调用 hashCode 方法时直接返回该值，而不需要重新计算。这是一种缓存优化，称为“惰性计算”。</p>
<p>31倍哈希法（31-Hash）是一种简单有效的字符串哈希算法，常用于对字符串进行哈希处理。该算法的基本思想是将字符串中的每个字符乘以一个固定的质数31的幂次方，并将它们相加得到哈希值。具体地，假设字符串为s，长度为n，则31倍哈希值计算公式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">H(s) = (s[0] * 31^(n-1)) + (s[1] * 31^(n-2)) + ... + (s[n-1] * 31^0)</span><br></pre></td></tr></table></figure>
<p>其中，s[i]表示字符串s中第i个字符的ASCII码值， ^表示幂运算。31倍哈希法的优点在于简单易实现，计算速度快，同时也比较均匀地分布在哈希表中。</p>
<p>hashCode 方法，我们会在另外一个章节里详细讲。</p>
<p>我们可以通过以下方法模拟 String 的 hashCode 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class HashCodeExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String text = &quot;沉默王二&quot;;</span><br><span class="line">        int hashCode = computeHashCode(text);</span><br><span class="line">        System.out.println(&quot;字符串 \&quot;&quot; + text + &quot;\&quot; 的哈希码是: &quot; + hashCode);</span><br><span class="line">        System.out.println(&quot;String 的 hashCode &quot; + text.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">    public static int computeHashCode(String text) &#123;</span><br><span class="line">        int h = 0;</span><br><span class="line">        for (int i = 0; i &lt; text.length(); i++) &#123;</span><br><span class="line">            h = 31 * h + text.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看一下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">字符串 &quot;沉默&quot; 的哈希码是: 867758096</span><br><span class="line">String 的 hashCode 867758096</span><br></pre></td></tr></table></figure>
<p>结果是一样的，又学到了吧？</p>
<p><strong>String 类的 substring 方法 </strong></p>
<p>String 类中还有一个方法比较常用 substring，用来截取字符串的，来看源码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public String substring(int beginIndex) &#123;</span><br><span class="line">    if (beginIndex &lt; 0) &#123;</span><br><span class="line">        throw new StringIndexOutOfBoundsException(beginIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    int subLen = value.length - beginIndex;</span><br><span class="line">    if (subLen &lt; 0) &#123;</span><br><span class="line">        throw new StringIndexOutOfBoundsException(subLen);</span><br><span class="line">    &#125;</span><br><span class="line">    return (beginIndex == 0) ? this : new String(value, beginIndex, subLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>substring 方法首先检查参数的有效性，如果参数无效，则抛出 StringIndexOutOfBoundsException 异常。</p>
<p>接下来，方法根据参数计算子字符串的长度。如果子字符串长度小于零，抛出StringIndexOutOfBoundsException异常。</p>
<p>如果 beginIndex 为 0，且 endIndex 等于字符串的长度，说明子串与原字符串相同，因此直接返回原字符串。否则，使用 value 数组（原字符串的字符数组）的一部分创建一个新的 String 对象并返回。</p>
<p>下面是几个使用 substring 方法的示例：</p>
<p>①、提取字符串中的一段子串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;Hello, world!&quot;;</span><br><span class="line">String subStr = str.substring(7, 12);  // 从第7个字符（包括）提取到第12个字符（不包括）</span><br><span class="line">System.out.println(subStr);  // 输出 &quot;world&quot;</span><br></pre></td></tr></table></figure>
<p>②、提取字符串中的前缀或后缀：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;Hello, world!&quot;;</span><br><span class="line">String prefix = str.substring(0, 5);  // 提取前5个字符，即 &quot;Hello,&quot;</span><br><span class="line">String suffix = str.substring(7);     // 提取从第7个字符开始的所有字符，即 &quot;world!&quot;</span><br></pre></td></tr></table></figure>
<p>③、处理字符串中的空格和分隔符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;   Hello,   world!  &quot;;</span><br><span class="line">String trimmed = str.trim();                  // 去除字符串开头和结尾的空格</span><br><span class="line">String[] words = trimmed.split(&quot;\\s+&quot;);       // 将字符串按照空格分隔成单词数组</span><br><span class="line">String firstWord = words[0].substring(0, 1);  // 提取第一个单词的首字母</span><br><span class="line">System.out.println(firstWord);  </span><br></pre></td></tr></table></figure>
<p>④、处理字符串中的数字和符号：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;1234-5678-9012-3456&quot;;</span><br><span class="line">String[] parts = str.split(&quot;-&quot;);             // 将字符串按照连字符分隔成四个部分</span><br><span class="line">String last4Digits = parts[3].substring(1);  // 提取最后一个部分的后三位数字</span><br><span class="line">System.out.println(last4Digits);             // 输出 &quot;456&quot;</span><br></pre></td></tr></table></figure>
<p>总之，substring 方法可以根据需求灵活地提取字符串中的子串，为字符串处理提供了便利。</p>
<p><strong>String 类的 indexOf 方法 </strong></p>
<p>indexOf 方法用于查找一个子字符串在原字符串中第一次出现的位置，并返回该位置的索引。来看该方法的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 查找字符数组 target 在字符数组 source 中第一次出现的位置。</span><br><span class="line"> * sourceOffset 和 sourceCount 参数指定 source 数组中要搜索的范围，</span><br><span class="line"> * targetOffset 和 targetCount 参数指定 target 数组中要搜索的范围，</span><br><span class="line"> * fromIndex 参数指定开始搜索的位置。</span><br><span class="line"> * 如果找到了 target 数组，则返回它在 source 数组中的位置索引（从0开始），</span><br><span class="line"> * 否则返回-1。</span><br><span class="line"> */</span><br><span class="line">static int indexOf(char[] source, int sourceOffset, int sourceCount,</span><br><span class="line">        char[] target, int targetOffset, int targetCount,</span><br><span class="line">        int fromIndex) &#123;</span><br><span class="line">    // 如果开始搜索的位置已经超出 source 数组的范围，则直接返回-1（如果 target 数组为空，则返回 </span><br><span class="line">sourceCount）</span><br><span class="line">    if (fromIndex &gt;= sourceCount) &#123;</span><br><span class="line">        return (targetCount == 0 ? sourceCount : -1);</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果开始搜索的位置小于0，则从0开始搜索</span><br><span class="line">    if (fromIndex &lt; 0) &#123;</span><br><span class="line">        fromIndex = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果 target 数组为空，则直接返回开始搜索的位置</span><br><span class="line">    if (targetCount == 0) &#123;</span><br><span class="line">        return fromIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    // 查找 target 数组的第一个字符在 source 数组中的位置</span><br><span class="line">    char first = target[targetOffset];</span><br><span class="line">    int max = sourceOffset + (sourceCount - targetCount);</span><br><span class="line">    // 循环查找 target 数组在 source 数组中的位置</span><br><span class="line">    for (int i = sourceOffset + fromIndex; i &lt;= max; i++) &#123;</span><br><span class="line">        /* Look for first character. */</span><br><span class="line">        // 如果 source 数组中当前位置的字符不是 target 数组的第一个字符，则在 source 数组中继</span><br><span class="line">续查找 target 数组的第一个字符</span><br><span class="line">        if (source[i] != first) &#123;</span><br><span class="line">            while (++i &lt;= max &amp;&amp; source[i] != first);</span><br><span class="line">        &#125;</span><br><span class="line">        /* Found first character, now look at the rest of v2 */</span><br><span class="line">        // 如果在 source 数组中找到了 target 数组的第一个字符，则继续查找 target 数组的剩余部</span><br><span class="line">分是否匹配</span><br><span class="line">        if (i &lt;= max) &#123;</span><br><span class="line">            int j = i + 1;</span><br><span class="line">            int end = j + targetCount - 1;</span><br><span class="line">            for (int k = targetOffset + 1; j &lt; end &amp;&amp; source[j]</span><br><span class="line">                    == target[k]; j++, k++);</span><br><span class="line">            // 如果 target 数组全部匹配，则返回在 source 数组中的位置索引</span><br><span class="line">            if (j == end) &#123;</span><br><span class="line">                /* Found whole string. */</span><br><span class="line">                return i - sourceOffset;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 没有找到 target 数组，则返回-1</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看示例。</p>
<p>①、示例1：查找子字符串的位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;Hello, world!&quot;;</span><br><span class="line">int index = str.indexOf(&quot;world&quot;);  // 查找 &quot;world&quot; 子字符串在 str 中第一次出现的位置</span><br><span class="line">System.out.println(index);        // 输出 7</span><br></pre></td></tr></table></figure>
<p>②、示例2：查找字符串中某个字符的位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;Hello, world!&quot;;</span><br><span class="line">int index = str.indexOf(&quot;,&quot;);     // 查找逗号在 str 中第一次出现的位置</span><br><span class="line">System.out.println(index);        // 输出 5</span><br></pre></td></tr></table></figure>
<p>③、示例3：查找子字符串的位置（从指定位置开始查找）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;Hello, world!&quot;;</span><br><span class="line">int index = str.indexOf(&quot;l&quot;, 3);  // 从索引为3的位置开始查找 &quot;l&quot; 子字符串在 str 中第一次出现的位置</span><br><span class="line">System.out.println(index);        // 输出 3</span><br></pre></td></tr></table></figure>
<p>④、示例4：查找多个子字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;Hello, world!&quot;;</span><br><span class="line">int index1 = str.indexOf(&quot;o&quot;);    // 查找 &quot;o&quot; 子字符串在 str 中第一次出现的位置</span><br><span class="line">int index2 = str.indexOf(&quot;o&quot;, 5); // 从索引为5的位置开始查找 &quot;o&quot; 子字符串在 str 中第一次出现的位置</span><br><span class="line">System.out.println(index1);       // 输出 4</span><br><span class="line">System.out.println(index2);       // 输出 8</span><br></pre></td></tr></table></figure>
<p><strong>String 类的其他方法 </strong></p>
<p>比如说 length() 用于返回字符串长度。</p>
<p>比如说 isEmpty() 用于判断字符串是否为空。</p>
<p>比如说 charAt() 用于返回指定索引处的字符。</p>
<p>比如说 getBytes() 用于返回字符串的字节数组，可以指定编码方式，比如说：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String text = &quot;沉默&quot;;</span><br><span class="line">System.out.println(Arrays.toString(text.getBytes(StandardCharsets.UTF_8)));</span><br></pre></td></tr></table></figure>
<p>比如说 trim() 用于去除字符串两侧的空白字符，来看源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public String trim() &#123;</span><br><span class="line">    int len = value.length;</span><br><span class="line">    int st = 0;</span><br><span class="line">    char[] val = value;    /* avoid getfield opcode */</span><br><span class="line">    while ((st &lt; len) &amp;&amp; (val[st] &lt;= &#x27; &#x27;)) &#123;</span><br><span class="line">        st++;</span><br><span class="line">    &#125;</span><br><span class="line">    while ((st &lt; len) &amp;&amp; (val[len - 1] &lt;= &#x27; &#x27;)) &#123;</span><br><span class="line">        len--;</span><br><span class="line">    &#125;</span><br><span class="line">    return ((st &gt; 0) || (len &lt; value.length)) ? substring(st, len) : this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举例： “  沉默   “.trim() 会返回”沉默”</p>
<p>除此之外，还有 split、equals、join 等这些方法，我们后面会一一来细讲。</p>
<h2 id="2-5-String为什么不可变"><a href="#2-5-String为什么不可变" class="headerlink" title="2.5 String为什么不可变"></a>2.5 String为什么不可变</h2><p>String 可能是 Java 中使用频率最高的引用类型了，因此 String 类的设计者可以说是用心良苦。比如说 String 的不可变性。</p>
<p>String 类被 final 关键字修饰，所以它不会有子类，这就意味着没有子类可以重写它的方法，改变它的行为。</p>
<p>String 类的数据存储在 char[] 数组中，而这个数组也被 final 关键字修饰了，这就表示 String 对象是没法被修改的，只要初始化一次，值就确定了。</p>
<p>“为什么要这样设计呢？”</p>
<p>“我先简单来说下，能懂最好，不能懂后面再细说。”</p>
<p>第一，可以保证 String 对象的安全性，避免被篡改，毕竟像密码这种隐私信息一般就是用字符串存储的。</p>
<p>以下是一个简单的 Java 示例，演示了字符串的不可变性如何有助于保证 String 对象的安全性。在本例中，我们创建了一个简单的 User 类，该类使用 String 类型的字段存储用户名和密码。同时，我们使用一个静态方法 getUserCredentials 从外部获取用户凭据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">    private String username;</span><br><span class="line">    private String password;</span><br><span class="line">    public User(String username, String password) &#123;</span><br><span class="line">        this.username = username;</span><br><span class="line">        this.password = password;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getUsername() &#123;</span><br><span class="line">        return username;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getPassword() &#123;</span><br><span class="line">        return password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class StringSecurityExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String username = &quot;沉默&quot;;</span><br><span class="line">        String password = &quot;123456&quot;;</span><br><span class="line">        User user = new User(username, password);</span><br><span class="line">        // 获取用户凭据</span><br><span class="line">        String[] credentials = getUserCredentials(user);</span><br><span class="line">        // 尝试修改从 getUserCredentials 返回的用户名和密码字符串</span><br><span class="line">        credentials[0] = &quot;陈清扬&quot;;</span><br><span class="line">        credentials[1] = &quot;612311&quot;;</span><br><span class="line">        // 输出原始 User 对象中的用户名和密码</span><br><span class="line">        System.out.println(&quot;原始用户名: &quot; + user.getUsername()); // 输出 &quot;JohnDoe&quot;</span><br><span class="line">        System.out.println(&quot;原始密码: &quot; + user.getPassword()); // 输出 </span><br><span class="line">&quot;mySecurePassword&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    public static String[] getUserCredentials(User user) &#123;</span><br><span class="line">        String[] credentials = new String[2];</span><br><span class="line">        credentials[0] = user.getUsername();</span><br><span class="line">        credentials[1] = user.getPassword();</span><br><span class="line">        return credentials;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，尽管我们尝试修改 getUserCredentials 返回的字符串数组（即用户名和密码），但原始 User 对象中的用户名和密码保持不变。这证明了字符串的不可变性有助于保护 String 对象的安全性。</p>
<p>第二，保证哈希值不会频繁变更。毕竟要经常作为哈希表的键值，经常变更的话，哈希表的性能就会很差劲。</p>
<p>在 String 类中，哈希值是在第一次计算时缓存的，后续对该哈希值的请求将直接使用缓存值。这有助于提高哈希表等数据结构的性能。以下是一个简单的示例，演示了字符串的哈希值缓存机制：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String text1 = &quot;沉默&quot;;</span><br><span class="line">String text2 = &quot;沉默&quot;;</span><br><span class="line">// 计算字符串 text1 的哈希值，此时会进行计算并缓存哈希值</span><br><span class="line">int hashCode1 = text1.hashCode();</span><br><span class="line">System.out.println(&quot;第一次计算 text1 的哈希值: &quot; + hashCode1);</span><br><span class="line">// 再次计算字符串 text1 的哈希值，此时直接返回缓存的哈希值</span><br><span class="line">int hashCode1Cached = text1.hashCode();</span><br><span class="line">System.out.println(&quot;第二次计算: &quot; + hashCode1Cached);</span><br><span class="line">// 计算字符串 text2 的哈希值，由于字符串常量池的存在，实际上 text1 和 text2 指向同一个字符串对象</span><br><span class="line">// 所以这里直接返回缓存的哈希值</span><br><span class="line">int hashCode2 = text2.hashCode();</span><br><span class="line">System.out.println(&quot;text2 直接使用缓存: &quot; + hashCode2);</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们创建了两个具有相同内容的字符串 text1 和 text2。首次计算 text1 的哈希值时，会进行实际计算并缓存该值。当我们再次计算 text1 的哈希值或计算具有相同内容的 text2 的哈希值时，将直接返回缓存的哈希值，而不进行重新计算。</p>
<p>由于 String 对象是不可变的，其哈希值在创建后不会发生变化。这使得 String 类可以缓存哈希值，提高哈希表等数据结构的性能。如果 String 是可变的，那么在每次修改时都需要重新计算哈希值，这会降低性能。</p>
<p>第三，可以实现字符串常量池，Java 会将相同内容的字符串存储在字符串常量池中。这样，具有相同内容的字符串变量可以指向同一个 String 对象，节省内存空间。</p>
<p>“由于字符串的不可变性，String 类的一些方法实现最终都返回了新的字符串对象。”</p>
<p>“就拿 substring() 方法来说。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public String substring(int beginIndex) &#123;</span><br><span class="line">    if (beginIndex &lt; 0) &#123;</span><br><span class="line">        throw new StringIndexOutOfBoundsException(beginIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    int subLen = value.length - beginIndex;</span><br><span class="line">    if (subLen &lt; 0) &#123;</span><br><span class="line">        throw new StringIndexOutOfBoundsException(subLen);</span><br><span class="line">    &#125;</span><br><span class="line">    return (beginIndex == 0) ? this : new String(value, beginIndex, subLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>substring() 方法用于截取字符串，最终返回的都是 new 出来的新字符串对象。</p>
<p>“还有 concat() 方法。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public String concat(String str) &#123;</span><br><span class="line">    int olen = str.length();</span><br><span class="line">    if (olen == 0) &#123;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">    if (coder() == str.coder()) &#123;</span><br><span class="line">        byte[] val = this.value;</span><br><span class="line">        byte[] oval = str.value;</span><br><span class="line">        int len = val.length + oval.length;</span><br><span class="line">        byte[] buf = Arrays.copyOf(val, len);</span><br><span class="line">        System.arraycopy(oval, 0, buf, val.length, oval.length);</span><br><span class="line">        return new String(buf, coder);</span><br><span class="line">    &#125;</span><br><span class="line">    int len = length();</span><br><span class="line">    byte[] buf = StringUTF16.newBytesFor(len + olen);</span><br><span class="line">    getBytes(buf, 0, UTF16);</span><br><span class="line">    str.getBytes(buf, len, UTF16);</span><br><span class="line">    return new String(buf, UTF16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>concat() 方法用于拼接字符串，<strong>不管编码是否一致，最终也返回的是新的字符串对象。</strong></p>
<p>“ replace() 替换方法其实也一样，三妹，你可以自己一会看一下源码，也是返回新的字符串对象。”</p>
<p>“这就意味着，不管是截取、拼接，还是替换，都不是在原有的字符串上进行的，而是<strong>重新生成了新的字符串对象</strong>。也就是说，这些操作执行过后，<strong>原来的字符串对象并没有发生改变。”</strong></p>
<p>“String 对象一旦被创建后就固定不变了，对 String 对象的任何修改都不会影响到原来的字符串对象，都会生成新的字符串对象。”</p>
<p><strong>2.6 深入理解Java字符串常量池 </strong></p>
<p>“今天我们来学习一下字符串常量池，这是字符串中非常关键的一个知识点。”</p>
<p>new String(“二哥”)创建了几个对象 </p>
<p>“先从这道面试题开始吧！”</p>
<p>“这行代码创建了几个对象？”</p>
<p>“不就一个吗？”</p>
<p>“不，两个！”“使用 new 关键字创建一个字符串对象时，Java 虚拟机会先在字符串常量池中查找有没有‘二哥’这个字符串对象，如果有，就不会在字符串常量池中创建‘二哥’这个对象了，直接在堆中创建一个‘二哥’的字符串对象，然后将堆中这个‘二哥’的对象地址返回赋值给变量 s。”</p>
<p>“如果没有，先在字符串常量池中创建一个‘二哥’的字符串对象，然后再在堆中创建一个‘二哥’的字符串对象，然后将堆中这个‘二哥’的字符串对象地址返回赋值给变量 s。”</p>
<p>我画图表示一下，会更加清楚。</p>
<p><img src="\assets\note\image-20230927103252744.png" alt="image-20230927103252744"></p>
<p>在Java中，栈上存储的是基本数据类型的变量和对象的引用，而对象本身则存储在堆上。</p>
<p>对于这行代码 String s = new String(“二哥”); ，它创建了两个对象：一个是字符串对象 “二哥”，它被添加到了字符串常量池中，另一个是通过 new String() 构造函数创建的字符串对象 “二哥”，它被分配在堆内存中，同时引用变量 s 存储在栈上，它指向堆内存中的字符串对象 “二哥”。</p>
<p>“为什么要先在字符串常量池中创建对象，然后再在堆上创建呢？这样不就多此一举了？”</p>
<p>我回答，“是的。由于字符串的使用频率实在是太高了，所以 Java 虚拟机为了提高性能和减少内存开销，在创建字符串对象的时候进行了一些优化，特意为字符串开辟了一块空间——也就是字符串常量池。”</p>
<p><strong>字符串常量池的作用 </strong></p>
<p>通常情况下，我们会采用双引号的方式来创建字符串对象，而不是通过 new 关键字的方式，就像下面 这样，这样就不会多此一举：</p>
<p>当执行 String s = “三妹” 时，Java 虚拟机会先在字符串常量池中查找有没有“三妹”这个字符串对象，如果有，则不创建任何对象，直接将字符串常量池中这个“三妹”的对象地址返回，赋给变量 s；如果没有，在字符串常量池中创建“三妹”这个对象，然后将其地址返回，赋给变量 s。</p>
<p><img src="\assets\note\image-20230927103456823.png" alt="image-20230927103456823"></p>
<p>Java 虚拟机创建了一个字符串对象 “三妹”，它被添加到了字符串常量池中，同时引用变量 s 存储在栈上，它指向字符串常量池中的字符串对象 “三妹”。你看，是不是省了一步，比之前高效了。</p>
<p>““有了字符串常量池，就可以通过双引号的方式直接创建字符串对象，不用再通过 new 的方式在堆中创建对象了，对吧？”</p>
<p>“是滴。new 的方式始终会创建一个对象，不管字符串的内容是否已经存在，而双引号的方式会重复利用字符串常量池中已经存在的对象。”我说。</p>
<p>来看下面这个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = new String(&quot;二哥&quot;);</span><br><span class="line">String s1 = new String(&quot;二哥&quot;);</span><br></pre></td></tr></table></figure>
<p>按照我们之前的分析，这两行代码会创建三个对象，字符串常量池中一个，堆上两个。</p>
<p>再来看下面这个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = &quot;三妹&quot;;</span><br><span class="line">String s1 = &quot;三妹&quot;;</span><br></pre></td></tr></table></figure>
<p>这两行代码只会创建一个对象，就是字符串常量池中的那个。这样的话，性能肯定就提高了！</p>
<p><strong>字符串常量池在内存中的什么位置呢？ </strong></p>
<p>分为三个阶段。</p>
<p><strong>Java 7 之前 </strong></p>
<p>在 Java 7 之前，字符串常量池位于永久代（Permanent Generation）的内存区域中，主要用来存储一些字符串常量（静态数据的一种）。永久代是 Java 堆（Java Heap）的一部分，用于存储类信息、方法信息、常量池信息等静态数据。</p>
<p>而 Java 堆是 JVM 中存储对象实例和数组的内存区域，也就是说，永久代是 Java 堆的一个子区域。换句话说，永久代中存储的静态数据与堆中存储的对象实例和数组是分开的，它们有不同的生命周期和分配方式。</p>
<p>但是，永久代和堆的大小是相互影响的，因为它们都使用了 JVM 堆内存，因此它们的大小都受到 JVM 堆大小的限制。</p>
<p>于是，当我们创建一个字符串常量时，它会被储存在永久代的字符串常量池中。如果我们创建一个普通字符串对象，则它将被储存在堆中。如果字符串对象的内容是一个已经存在于字符串常量池中的字符串常量，那么这个对象会指向已经存在的字符串常量，而不是重新创建一个新的字符串对象。</p>
<p>画幅图，大概就是这个样子。</p>
<p><img src="\assets\note\image-20230927103826496.png" alt="image-20230927103826496"></p>
<p><strong>Java 7 </strong></p>
<p>需要注意的是，永久代的大小是有限的，并且很难准确地确定一个应用程序需要多少永久代空间。如果我们在应用程序中使用了大量的类、方法、常量等静态数据，就有可能导致永久代空间不足。这种情况下，JVM 就会抛出 OutOfMemoryError 错误。</p>
<p>因此，从 Java 7 开始，为了解决永久代空间不足的问题，将字符串常量池从永久代中移动到堆中。这个改变也是为了更好地支持动态语言的运行时特性。</p>
<p>再画幅图，大概就是这样子。</p>
<p><img src="\assets\note\image-20230927103920703.png" alt="image-20230927103920703"></p>
<p><strong>Java 8 </strong></p>
<p>到了 Java 8，永久代（PermGen）被取消，并由元空间（Metaspace）取代。元空间是一块本机内存区域，和 JVM 内存区域是分开的。不过，元空间的作用依然和之前的永久代一样，用于存储类信息、方法信息、常量池信息等静态数据。</p>
<p>与永久代不同，元空间具有一些优点，例如：</p>
<ul>
<li>它不会导致 OutOfMemoryError 错误，因为元空间的大小可以动态调整。</li>
<li>元空间使用本机内存，而不是 JVM 堆内存，这可以避免堆内存的碎片化问题。</li>
<li>元空间中的垃圾收集与堆中的垃圾收集是分离的，这可以避免应用程序在运行过程中因为进行类加载和卸载而频繁地触发 Full GC。</li>
</ul>
<p>再画幅图，对比来看一下，就会一目了然。</p>
<p><img src="\assets\note\image-20230927104032476.png" alt="image-20230927104032476"></p>
<p><strong>永久代、方法区、元空间 </strong></p>
<p>“能再简单给我解释一下方法区，永久代和元空间的概念吗？有点模糊。”</p>
<p>“可以呀。”</p>
<ul>
<li>方法区是 Java 虚拟机规范中的一个概念，就像是一个接口吧；</li>
<li>永久代是 HotSpot 虚拟机中对方法区的一个实现，就像是接口的实现类；</li>
<li>Java 8 的时候，移除了永久代，取而代之的是元空间，是方法区的另外一种实现，更灵活了。</li>
</ul>
<p>永久代是放在运行时数据区中的，所以它的大小受到 Java 虚拟机本身大小的限制，所以 Java 8 之前，会经常遇到 java.lang.OutOfMemoryError: PremGen Space 的异常，PremGen Space 就是方法区的意思；而元空间是直接放在内存中的，所以只受本机可用内存的限制。</p>
<h2 id="2-7-详解-String-intern-方法"><a href="#2-7-详解-String-intern-方法" class="headerlink" title="2.7 详解 String.intern() 方法"></a>2.7 详解 String.intern() 方法</h2><p>“看一下美团技术团队深入解析 String.intern() 文章”</p>
<p>要理解美团技术团队的这篇文章，你只需要记住这几点内容：</p>
<p>第一，使用双引号声明的字符串对象会保存在字符串常量池中。</p>
<p>第二，使用 new 关键字创建的字符串对象会先从字符串常量池中找，如果没找到就创建一个，然后再在堆中创建字符串对象；如果找到了，就直接在堆中创建字符串对象。</p>
<p>第三，针对没有使用双引号声明的字符串对象来说，就像下面代码中的 s1 那样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s1 = new String(&quot;二哥&quot;) + new String(&quot;三妹&quot;);</span><br></pre></td></tr></table></figure>
<p>如果想把 s1 的内容也放入字符串常量池的话，可以调用 intern() 方法来完成。</p>
<p>不过，需要注意的是，Java 7 的时候，字符串常量池从永久代中移动到了堆中，虽然此时永久代还没有完全被移除。Java 8 的时候，永久代被彻底移除。</p>
<p>这个变化也直接影响了  String.intern() 方法在执行时的策略，Java 7 之前，执行 String.intern() 方法的时候，不管对象在堆中是否已经创建，字符串常量池中仍然会创建一个内容完全相同的新对象； Java 7 之后呢，由于字符串常量池放在了堆中，执行 String.intern() 方法的时候，如果对象在堆中已经创建了，字符串常量池中就不需要再创建新的对象了，而是直接保存堆中对象的引用，也就节省了一部分的内存<br>空间。</p>
<p>“先来猜猜这段代码输出的结果吧。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1 = new String(&quot;二哥三妹&quot;);</span><br><span class="line">String s2 = s1.intern();</span><br><span class="line">System.out.println(s1 == s2);</span><br></pre></td></tr></table></figure>
<p>第一行代码，字符串常量池中会先创建一个“二哥三妹”的对象，然后堆中会再创建一个“二哥三妹”的对象，s1 引用的是堆中的对象。</p>
<p>第二行代码，对 s1 执行 intern() 方法，该方法会从字符串常量池中查找“二哥三妹”这个字符串是否存在，此时是存在的，所以 s2 引用的是字符串常量池中的对象。</p>
<p>也就意味着 s1 和 s2 的引用地址是不同的，一个来自堆，一个来自字符串常量池，所以输出的结果为 false。</p>
<p>“来看一下运行结果。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">false</span><br></pre></td></tr></table></figure>
<p>“我来画幅图，帮助你理解下。”</p>
<p><img src="\assets\note\image-20230927104641609.png" alt="image-20230927104641609"></p>
<p>“好，我们再来看下面这段代码。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1 = new String(&quot;二哥&quot;) + new String(&quot;三妹&quot;);</span><br><span class="line">String s2 = s1.intern();</span><br><span class="line">System.out.println(s1 == s2);</span><br></pre></td></tr></table></figure>
<p>“难道也输出 false ？”</p>
<p>“不，这段代码会输出 true。”</p>
<p>“为啥呀？”</p>
<p>第一行代码，会在字符串常量池中创建两个对象，一个是“二哥”，一个是“三妹”，然后在堆中会创建两个匿名对象“二哥”和“三妹”，最后还有一个“二哥三妹”的对象（稍后会解释），s1 引用的是堆中“二哥三妹”这个对象。</p>
<p>第二行代码，对 s1 执行 intern() 方法，该方法会从字符串常量池中查找“二哥三妹”这个对象是否存在，此时不存在的，但堆中已经存在了，所以字符串常量池中保存的是堆中这个“二哥三妹”对象的引用，也就是说，s2 和 s1 的引用地址是相同的，所以输出的结果为 true。</p>
<p>“来看一下运行结果。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure>
<p>“我再来画幅图，帮助你理解下。”</p>
<p><img src="\assets\note\image-20230927104855320.png" alt="image-20230927104855320"></p>
<p>“不过，我有一个疑惑，“二哥三妹”这个对象是什么时候创建的呢？”</p>
<p>“不错嘛，能抓住问题的关键。再来解释一下 String s1 = new String(“二哥”) + new String(“三妹”) 这行代码。”</p>
<ol>
<li>创建 “二哥” 字符串对象，存储在字符串常量池中。</li>
<li>创建 “三妹” 字符串对象，存储在字符串常量池中。</li>
<li>执行 new String(“二哥”) ，在堆上创建一个字符串对象，内容为 “二哥”。</li>
<li>执行 new String(“三妹”) ，在堆上创建一个字符串对象，内容为 “三妹”。</li>
<li>执行 new String(“二哥”) + new String(“三妹”) ，会创建一个 StringBuilder 对象，并将 “二哥” 和 “三妹” 追加到其中，然后调用 StringBuilder 对象的 toString() 方法，将其转换为一个新的字符串对象，内容为 “二哥三妹”。这个新的字符串对象存储在堆上。</li>
</ol>
<p>也就是说，当编译器遇到 + 号这个操作符的时候，会将 new String(“二哥”) + new String(“三妹”) 这行代码编译为以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new StringBuilder().append(&quot;二哥&quot;).append(&quot;三妹&quot;).toString();</span><br></pre></td></tr></table></figure>
<p>实际执行过程如下：</p>
<ul>
<li>创建一个 StringBuilder 对象。</li>
<li>在 StringBuilder 对象上调用 append(“二哥”)，将 “二哥” 追加到 StringBuilder 中。</li>
<li>在 StringBuilder 对象上调用 append(“三妹”)，将 “三妹” 追加到 StringBuilder 中。</li>
<li>在 StringBuilder 对象上调用 toString() 方法，将 StringBuilder 转换为一个新的字符串对象，内容为 “二哥三妹”。</li>
</ul>
<p>关于 StringBuilder，我们随后会详细地讲到。今天先了解到这。</p>
<p>不过需要注意的是，尽管 intern 可以确保所有具有相同内容的字符串共享相同的内存空间，但也不要烂用 intern，因为任何的缓存池都是有大小限制的，不能无缘无故就占用了相对稀缺的缓存空间，导致其他字符串没有坑位可占。</p>
<p>另外，字符串常量池本质上是一个固定大小的 StringTable，如果放进去的字符串过多，就会造成严重的哈希冲突，从而导致链表变长，链表变长也就意味着字符串常量池的性能会大幅下降，因为要一个一个找是需要花费时间的。</p>
<h2 id="2-8-String、StringBuilder、StringBuffer"><a href="#2-8-String、StringBuilder、StringBuffer" class="headerlink" title="2.8 String、StringBuilder、StringBuffer"></a>2.8 String、StringBuilder、StringBuffer</h2><p>“上一篇深入理解 String.intern() 讲到了 StringBuilder，这一节我们就来聊聊吧！”</p>
<p>由于字符串是不可变的，所以当遇到字符串拼接（尤其是使用 +号操作符）的时候，就需要考量性能的问题，你不能毫无顾虑地生产太多 String 对象，对珍贵的内存造成不必要的压力。</p>
<p>于是 Java 就设计了一个专门用来解决此问题的 StringBuffer 类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public final class StringBuffer extends AbstractStringBuilder implements </span><br><span class="line">Serializable, CharSequence &#123;</span><br><span class="line">    public StringBuffer() &#123;</span><br><span class="line">        super(16);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public synchronized StringBuffer append(String str) &#123;</span><br><span class="line">        super.append(str);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">    public synchronized String toString() &#123;</span><br><span class="line">        return new String(value, 0, count);</span><br><span class="line">    &#125;</span><br><span class="line">    // 其他方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过，由于 StringBuffer 操作字符串的方法加了 synchronized 关键字进行了同步，主要是考虑到多线程环境下的安全问题，所以执行效率会比较低。</p>
<p>于是 Java 就给 StringBuffer “生了个兄弟”，名叫 StringBuilder，说，“孩子，你别管线程安全了，你就在单线程环境下使用，这样效率会高得多，如果要在多线程环境下修改字符串，你到时候可以使用 ThreadLocal 来避免多线程冲突。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public final class StringBuilder extends AbstractStringBuilder</span><br><span class="line">    implements java.io.Serializable, CharSequence</span><br><span class="line">&#123;</span><br><span class="line">    // ...</span><br><span class="line">    public StringBuilder append(String str) &#123;</span><br><span class="line">        super.append(str);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        // Create a copy, don&#x27;t share the array</span><br><span class="line">        return new String(value, 0, count);</span><br><span class="line">    &#125;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了类名不同，方法没有加 synchronized，基本上完全一样。</p>
<p>实际开发中，StringBuilder 的使用频率也是远高于 StringBuffer，甚至可以这么说，StringBuilder 完全取代了 StringBuffer。</p>
<p>之前我们也曾聊过，Java 是一门解释型的编程语言，所以当编译器遇到 + 号这个操作符的时候，会将 new String(“二哥”) + new String(“三妹”) 这行代码编译为以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new StringBuilder().append(&quot;二哥&quot;).append(&quot;三妹&quot;).toString();</span><br></pre></td></tr></table></figure>
<p>这个过程是我们看不见的，但这正是 Java 的“智能”之处，它可以在编译的时候偷偷地帮我们做很多优化，这样既可以提高我们的开发效率（ + 号写起来比创建 StringBuilder 对象便捷得多），也不会影响 JVM 的执行效率。</p>
<p>当然了，如果我们使用 javap 反编译 new String(“二哥”) + new String(“三妹”) 的字节码的时候，也是能看出 StringBuilder 的影子的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">0: new           #2                  // class java/lang/StringBuilder</span><br><span class="line">3: dup</span><br><span class="line">4: invokespecial #3                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">7: new           #4                  // class java/lang/String</span><br><span class="line">10: dup</span><br><span class="line">11: ldc           #5                  // String 二哥</span><br><span class="line">13: invokespecial #6                  // Method java/lang/String.&quot;&lt;init&gt;&quot;:</span><br><span class="line">(Ljava/lang/String;)V</span><br><span class="line">16: invokevirtual #7                  // Method java/lang/StringBuilder.append:</span><br><span class="line">(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">19: new           #4                  // class java/lang/String</span><br><span class="line">22: dup</span><br><span class="line">23: ldc           #8                  // String 三妹</span><br><span class="line">25: invokespecial #6                  // Method java/lang/String.&quot;&lt;init&gt;&quot;:</span><br><span class="line">(Ljava/lang/String;)V</span><br><span class="line">28: invokevirtual #7                  // Method java/lang/StringBuilder.append:</span><br><span class="line">(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">31: invokevirtual #9                  // Method java/lang/StringBuilder.toString:</span><br><span class="line">()Ljava/lang/String;</span><br><span class="line">34: areturn</span><br></pre></td></tr></table></figure>
<p>可以看到 Java 编译器将字符串拼接操作（ + ）转换为了 StringBuilder 对象的 append 方法，然后再调用 StringBuilder 对象的 toString 方法返回拼接后的字符串。</p>
<p>来看一下 StringBuilder 的 toString 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public String toString() &#123;</span><br><span class="line">    return new String(value, 0, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>value 是一个 char 类型的数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The value is used for character storage.</span><br><span class="line"> */</span><br><span class="line">char[] value;</span><br></pre></td></tr></table></figure>
<p>在 StringBuilder 对象创建时，会为 value 分配一定的内存空间（初始容量 16），用于存储字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Constructs a string builder with no characters in it and an</span><br><span class="line"> * initial capacity of 16 characters.</span><br><span class="line"> */</span><br><span class="line">public StringBuilder() &#123;</span><br><span class="line">    super(16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>随着字符串的拼接，value 数组的长度会不断增加，因此在 StringBuilder 对象的实现中，value 数组的长度是可以<strong>动态扩展的，就像ArrayList那样。</strong></p>
<p>继续来看 StringBuilder 的 toString 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public String toString() &#123;</span><br><span class="line">    return new String(value, 0, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>value 用于存储 StringBuilder 对象中包含的字符序列。count 是一个 int 类型的变量，表示字符序列的长度。toString() 方法会调用 new String(value, 0, count) ，使用 value 数组中从 0 开始的前 count 个元素创建一个新的字符串对象，并将其返回。</p>
<p>再来看一下 append 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public StringBuilder append(String str) &#123;</span><br><span class="line">    super.append(str);</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上是调用了 AbstractStringBuilder 中的 append(String str) 方法。在 AbstractStringBuilder 中，append(String str) 方法会检查当前字符序列中的字符是否够用，如果不够用则会进行扩容，并将指定字符串追加到字符序列的末尾。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Appends the specified string to this character sequence.</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * The characters of the &#123;@code String&#125; argument are appended, in order,</span><br><span class="line"> * increasing the length of this sequence by the length of the argument.</span><br><span class="line"> * If &#123;@code str&#125; is &#123;@code null&#125;, then the four characters &#123;@code &quot;null&quot;&#125;</span><br><span class="line"> * are appended.</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * Let &lt;i&gt;n&lt;/i&gt; be the length of this character sequence just prior to</span><br><span class="line"> * execution of the &#123;@code append&#125; method. Then the character at index</span><br><span class="line"> * &lt;i&gt;k&lt;/i&gt; in this character sequence is equal to the character at index</span><br><span class="line"> * &lt;i&gt;k&lt;/i&gt; in the argument &#123;@code str&#125;, if &lt;i&gt;k&lt;/i&gt; is less than</span><br><span class="line"> * &lt;i&gt;n&lt;/i&gt;; otherwise, it is equal to the character at index</span><br><span class="line"> * &lt;i&gt;k-n&lt;/i&gt; in the argument &#123;@code str&#125;.</span><br><span class="line"> *</span><br><span class="line"> * @param   str   a string.</span><br><span class="line"> * @return  a reference to this object.</span><br><span class="line"> */</span><br><span class="line">public AbstractStringBuilder append(String str) &#123;</span><br><span class="line">    if (str == null)</span><br><span class="line">        return appendNull();</span><br><span class="line">    int len = str.length();</span><br><span class="line">    ensureCapacityInternal(count + len);</span><br><span class="line">    str.getChars(0, len, value, count);</span><br><span class="line">    count += len;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>append(String str) 方法将指定字符串追加到当前字符序列中。如果指定字符串为 null，则追加字符串 “null”；否则会检查指定字符串的长度，然后根据当前字符序列中的字符数和指定字符串的长度来判断是否需要扩容。</p>
<p>如果需要扩容，则会调用 ensureCapacityInternal(int minimumCapacity)方法进行扩容。扩容之后，将指定字符串的字符拷贝到字符序列中。</p>
<p>来看一下 ensureCapacityInternal 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private void ensureCapacityInternal(int minimumCapacity) &#123;</span><br><span class="line">    // overflow-conscious code</span><br><span class="line">    if (minimumCapacity - value.length &gt; 0)</span><br><span class="line">        expandCapacity(minimumCapacity);</span><br><span class="line">&#125;</span><br><span class="line">void expandCapacity(int minimumCapacity) &#123;</span><br><span class="line">    int newCapacity = value.length * 2 + 2;</span><br><span class="line">    if (newCapacity - minimumCapacity &lt; 0)</span><br><span class="line">        newCapacity = minimumCapacity;</span><br><span class="line">    if (newCapacity &lt; 0) &#123;</span><br><span class="line">        if (minimumCapacity &lt; 0) // overflow</span><br><span class="line">            throw new OutOfMemoryError();</span><br><span class="line">        newCapacity = Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    value = Arrays.copyOf(value, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ensureCapacityInternal(int minimumCapacity) 方法用于确保当前字符序列的容量至少等于指定的最小容量 minimumCapacity。如果当前容量小于指定的容量，就会为字符序列分配一个新的内部数组。新容量的计算方式如下：</p>
<ul>
<li>如果指定的最小容量大于当前容量，则新容量为两倍的旧容量加上 2；</li>
<li>如果指定的最小容量小于等于当前容量，则不会进行扩容，直接返回当前对象。</li>
</ul>
<p>在进行扩容之前， ensureCapacityInternal(int minimumCapacity) 方法会先检查当前字符序列的容量是否足够，如果不足就会调用 expandCapacity(int minimumCapacity) 方法进行扩容。</p>
<p>expandCapacity(int minimumCapacity) 方法首先计算出新容量，然后使用 Arrays.copyOf(char[] original, int newLength) 方法将原字符数组扩容到新容量的大小。</p>
<p>关于扩容，后面在讲ArrayList的时候会再次说明，今天就先聊到这吧。</p>
<h2 id="2-9-String相等判断"><a href="#2-9-String相等判断" class="headerlink" title="2.9 String相等判断"></a>2.9 String相等判断</h2><p>“如何比较两个字符串相等啊？”</p>
<p>“这个问题看似简单，却在 Stack Overflow 上有超过 370 万+的访问量。”我说，“这个问题也可以引申为 .equals() 和 ‘\==’ 操作符有什么区别。”</p>
<ul>
<li>“\==”操作符用于比较两个对象的地址是否相等。</li>
<li>.equals() 方法用于比较两个对象的内容是否相等。</li>
</ul>
<p>“我来举个不恰当又很恰当的例子，一看你就明白了。”</p>
<p>有一对双胞胎，姐姐叫阿丽塔，妹妹叫洛丽塔。我们普通人可能完全无法分辨谁是姐姐谁是妹妹，可她们的妈妈却可以轻而易举地辨认出。</p>
<p><img src="\assets\note\image-20230927110501241.png" alt="image-20230927110501241"></p>
<p>.equals() 就好像我们普通人，看见阿丽塔以为是洛丽塔，看见洛丽塔以为是阿丽塔，看起来一样就觉得她们是同一个人；“\==”操作符就好像她们的妈妈，要求更严格，观察更细致，一眼就能分辨出谁是姐姐谁是妹妹。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String alita = new String(&quot;小萝莉&quot;);</span><br><span class="line">String luolita = new String(&quot;小萝莉&quot;);</span><br><span class="line">System.out.println(alita.equals(luolita)); // true</span><br><span class="line">System.out.println(alita == luolita); // false</span><br></pre></td></tr></table></figure>
<p>就上面这段代码来说， .equals() 输出的结果为 true，而“\==”操作符输出的结果为 false——前者要求内容相等就可以，后者要求必须是同一个对象。</p>
<p>“之前已经学过了，Java 的所有类都默认地继承 Object 这个超类，该类有一个名为 .equals() 的方法。”一边说，我一边打开了 Object 类的源码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">    return (this == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你看，Object 类的 .equals() 方法默认采用的是“\==”操作符进行比较。假如子类没有重写该方法的话，那么“\==”操作符和 .equals() 方法的功效就完全一样——比较两个对象的内存地址是否相等。</p>
<p>但实际情况中，有不少类重写了 .equals() 方法，因为比较内存地址的要求比较严格，不太符合现实中所有的场景需求。拿 String 类来说，我们在比较字符串的时候，的确只想判断它们俩的内容是相等的就可以了，并不想比较它们俩是不是同一个对象。</p>
<p>况且，字符串有字符串常量池的概念，本身就推荐使用 String s = “字符串” 这种形式来创建字符串对象，而不是通过 new 关键字的方式，因为可以把字符串缓存在字符串常量池中，方便下次使用，不用遇到 new 就在堆上开辟一块新的空间。</p>
<p>“那就来看一下 String 类的 .equals() 方法的源码吧。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object anObject) &#123;</span><br><span class="line">    if (this == anObject) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (anObject instanceof String) &#123;</span><br><span class="line">        String aString = (String)anObject;</span><br><span class="line">        if (coder() == aString.coder()) &#123;</span><br><span class="line">            return isLatin1() ? StringLatin1.equals(value, aString.value)</span><br><span class="line">                    : StringUTF16.equals(value, aString.value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，如果两个字符串对象的可以“\==”，那就直接返回 true 了，因为这种情况下，字符串内容是必然相等的。否则就按照字符编码进行比较，分为 UTF16 和 Latin1，差别不是很大，就拿 Latin1 的来说吧。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@HotSpotIntrinsicCandidate</span><br><span class="line">public static boolean equals(byte[] value, byte[] other) &#123;</span><br><span class="line">    if (value.length == other.length) &#123;</span><br><span class="line">        for (int i = 0; i &lt; value.length; i++) &#123;</span><br><span class="line">            if (value[i] != other[i]) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 JDK 版本是 Java 17，也就是最新的 LTS（长期支持）版本。该版本中，String 类使用字节数组实现的，所以比较两个字符串的内容是否相等时，可以先比较字节数组的长度是否相等，不相等就直接返回 false；否则就遍历两个字符串的字节数组，只有有一个字节不相等，就返回 false。</p>
<p>这是 Java 8 中的 equals 方法源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object anObject) &#123;</span><br><span class="line">    // 判断是否为同一对象</span><br><span class="line">    if (this == anObject) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    // 判断对象是否为 String 类型</span><br><span class="line">    if (anObject instanceof String) &#123;</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        int n = value.length;</span><br><span class="line">        // 判断字符串长度是否相等</span><br><span class="line">        if (n == anotherString.value.length) &#123;</span><br><span class="line">            char v1[] = value;</span><br><span class="line">            char v2[] = anotherString.value;</span><br><span class="line">            int i = 0;</span><br><span class="line">            // 判断每个字符是否相等</span><br><span class="line">            while (n-- != 0) &#123;</span><br><span class="line">                if (v1[i] != v2[i])</span><br><span class="line">                    return false;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JDK 8 比 JDK 17 更容易懂一些：首先判断两个对象是否为同一个对象，如果是，则返回 true。接着，判断对象是否为 String 类型，如果不是，则返回 false。如果对象为 String 类型，则比较两个字符串的长度是否相等，如果长度不相等，则返回 false。如果长度相等，则逐个比较每个字符是否相等，如果都相等，则返回 true，否则返回 false。</p>
<p>“那出几道题考考你吧！”</p>
<p>第一题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new String(&quot;小萝莉&quot;).equals(&quot;小萝莉&quot;)</span><br></pre></td></tr></table></figure>
<p>“输出什么呢？”我问。</p>
<p>“ .equals() 比较的是两个字符串对象的内容是否相等，所以结果为 true。”</p>
<p>第二题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new String(&quot;小萝莉&quot;) == &quot;小萝莉&quot;</span><br></pre></td></tr></table></figure>
<p>“==操作符左侧的是在堆中创建的对象，右侧是在字符串常量池中的对象，尽管内容相同，但内存地址不同，所以返回 false。”</p>
<p>第三题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new String(&quot;小萝莉&quot;) == new String(&quot;小萝莉&quot;)</span><br></pre></td></tr></table></figure>
<p>“new 出来的对象肯定是完全不同的内存地址，所以返回 false。”</p>
<p>第四题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;小萝莉&quot; == &quot;小萝莉&quot;</span><br></pre></td></tr></table></figure>
<p>“字符串常量池中只会有一个相同内容的对象，所以返回 true。”</p>
<p>第五题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;小萝莉&quot; == &quot;小&quot; + &quot;萝莉&quot;</span><br></pre></td></tr></table></figure>
<p>“由于‘小’和‘萝莉’都在字符串常量池，所以编译器在遇到‘+’操作符的时候将其自动优化为“小萝莉”，所以返回 true。”</p>
<p>PS：至于为什么，查看这篇String、StringBuilder、StringBuffer</p>
<p>第六题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new String(&quot;小萝莉&quot;).intern() == &quot;小萝莉&quot;</span><br></pre></td></tr></table></figure>
<p>“ new String(“小萝莉”) 在执行的时候，会先在字符串常量池中创建对象，然后再在堆中创建对象；执行 intern() 方法的时候发现字符串常量池中已经有了‘小萝莉’这个对象，所以就直接返回字符串常量池中的对象引用了，那再与字符串常量池中的‘小萝莉’比较，当然会返回 true 了。”</p>
<p>PS：intern 方法我们之前已经深究过了。</p>
<p>“哥再给你补充一点。”</p>
<p>“如果要进行两个字符串对象的内容比较，除了 .equals() 方法，还有其他两个可选的方案。”</p>
<p>1） Objects.equals()</p>
<p>Objects.equals() 这个静态方法的优势在于不需要在调用之前判空。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static boolean equals(Object a, Object b) &#123;</span><br><span class="line">    return (a == b) || (a != null &amp;&amp; a.equals(b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果直接使用 a.equals(b) ，则需要在调用之前对 a 进行判空，否则可能会抛出空指针 java.lang.NullPointerException 。 Objects.equals() 用起来就完全没有这个担心。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Objects.equals(&quot;小萝莉&quot;, new String(&quot;小&quot; + &quot;萝莉&quot;)) // --&gt; true</span><br><span class="line">Objects.equals(null, new String(&quot;小&quot; + &quot;萝莉&quot;)); // --&gt; false</span><br><span class="line">Objects.equals(null, null) // --&gt; true</span><br><span class="line">String a = null;</span><br><span class="line">a.equals(new String(&quot;小&quot; + &quot;萝莉&quot;)); // throw exception</span><br></pre></td></tr></table></figure>
<p>2）String 类的 .contentEquals()</p>
<p>.contentEquals() 的优势在于可以将字符串与任何的字符序列（StringBuffer、StringBuilder、String、CharSequence）进行比较。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public boolean contentEquals(CharSequence cs) &#123;</span><br><span class="line">    // Argument is a StringBuffer, StringBuilder</span><br><span class="line">    if (cs instanceof AbstractStringBuilder) &#123;</span><br><span class="line">        if (cs instanceof StringBuffer) &#123;</span><br><span class="line">            synchronized(cs) &#123;</span><br><span class="line">                return nonSyncContentEquals((AbstractStringBuilder)cs);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return nonSyncContentEquals((AbstractStringBuilder)cs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // Argument is a String</span><br><span class="line">    if (cs instanceof String) &#123;</span><br><span class="line">        return equals(cs);</span><br><span class="line">    &#125;</span><br><span class="line">    // Argument is a generic CharSequence</span><br><span class="line">    int n = cs.length();</span><br><span class="line">    if (n != length()) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    byte[] val = this.value;</span><br><span class="line">    if (isLatin1()) &#123;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            if ((val[i] &amp; 0xff) != cs.charAt(i)) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (!StringUTF16.contentEquals(val, cs, n)) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从源码上可以看得出，如果 cs 是 StringBuffer，该方法还会进行同步，非常的智能化；如果是 String 的话，其实调用的还是 equals() 方法。当然了，这也就意味着使用该方法进行比较的时候，多出来了很多步骤，性能上有些损失。</p>
<p>同样来看一下 JDK 8 的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public boolean contentEquals(CharSequence cs) &#123;</span><br><span class="line">    // argument can be any CharSequence implementation</span><br><span class="line">    if (cs.length() != value.length) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    // Argument is a StringBuffer, StringBuilder or String</span><br><span class="line">    if (cs instanceof AbstractStringBuilder) &#123;</span><br><span class="line">        char v1[] = value;</span><br><span class="line">        char v2[] = ((AbstractStringBuilder)cs).getValue();</span><br><span class="line">        int i = 0;</span><br><span class="line">        int n = value.length;</span><br><span class="line">        while (n-- != 0) &#123;</span><br><span class="line">            if (v1[i] != v2[i])</span><br><span class="line">                return false;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    // Argument is a String</span><br><span class="line">    if (cs.equals(this))</span><br><span class="line">        return true;</span><br><span class="line">    // Argument is a non-String, non-AbstractStringBuilder CharSequence</span><br><span class="line">    char v1[] = value;</span><br><span class="line">    int i = 0;</span><br><span class="line">    int n = value.length;</span><br><span class="line">    while (n-- != 0) &#123;</span><br><span class="line">        if (v1[i] != cs.charAt(i))</span><br><span class="line">            return false;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   同样更容易理解一些：首先判断参数长度是否相等，不相等则返回 false。如果参数是 AbstractStringBuilder 的实例，则取出其 char 数组，遍历比较两个 char 数组的每个元素是否相等。如果参数是 String 的实例，则直接调用 equals 方法比较两个字符串是否相等。如果参数是其他实现了 CharSequence 接口的对象，则遍历比较两个对象的每个字符是否相等。    </p>
<h2 id="2-10-String拼接"><a href="#2-10-String拼接" class="headerlink" title="2.10 String拼接"></a>2.10 String拼接</h2><p>“《Java 开发手册》上有这么一段内容：循环体内，拼接字符串最好使用 StringBuilder 的 append() 方法，而不是 + 号操作符。这是为什么呀？”</p>
<p>“其实这个问题，我们之前已经聊过。”</p>
<p><strong>javap 探究+号操作符拼接字符串的本质 </strong></p>
<p>“+ 号操作符其实被 Java 在编译的时候重新解释了，换一种说法就是，+ 号操作符是一种语法糖，让字符串的拼接变得更简便了。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Demo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String chenmo = &quot;沉默&quot;;</span><br><span class="line">        String wanger = &quot;王二&quot;;</span><br><span class="line">        System.out.println(chenmo + wanger);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Java 8 的环境下，使用 javap -c Demo.class 反编译字节码后，可以看到以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Compiled from &quot;Demo.java&quot;</span><br><span class="line">class Demo &#123;</span><br><span class="line">  Demo();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: return</span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: ldc           #2                  // String 沉默</span><br><span class="line">       2: astore_1</span><br><span class="line">       3: ldc           #3                  // String 王二</span><br><span class="line">       5: astore_2</span><br><span class="line">       6: getstatic     #4                  // Field </span><br><span class="line">java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       9: new           #5                  // class java/lang/StringBuilder</span><br><span class="line">      12: dup</span><br><span class="line">      13: invokespecial #6                  // Method java/lang/StringBuilder.&quot;</span><br><span class="line">&lt;init&gt;&quot;:()V</span><br><span class="line">      16: aload_1</span><br><span class="line">      17: invokevirtual #7                  // Method </span><br><span class="line">java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      20: aload_2</span><br><span class="line">      21: invokevirtual #7                  // Method </span><br><span class="line">java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      24: invokevirtual #8                  // Method </span><br><span class="line">java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">      27: invokevirtual #9                  // Method java/io/PrintStream.println:</span><br><span class="line">(Ljava/lang/String;)V</span><br><span class="line">      30: return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“这里有一个 new 关键字，并且 class 类型为 java/lang/StringBuilder 。”我指着标号为 9 的那行说，“这意味着新建了一个 StringBuilder 的对象。”</p>
<p>“然后看标号为 17 的这行，是一个 invokevirtual 指令，用于调用对象的方法，也就是 StringBuilder 对象的 append() 方法。”</p>
<p>“也就意味着把 chenmo（”沉默”）这个字符串添加到 StringBuilder 对象中了。”</p>
<p>“再往下看，标号为 21 的这行，又调用了一次 append() 方法，意味着把 wanger（”王二”）这个字符串添加到 StringBuilder 对象中了。”</p>
<p>换成 Java 代码来表示的话，大概是这个样子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Demo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String chenmo = &quot;沉默&quot;;</span><br><span class="line">        String wanger = &quot;王二&quot;;</span><br><span class="line">        System.out.println((new StringBuilder(chenmo)).append(wanger).toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“哦，原来编译的时候把“+”号操作符替换成了 StringBuilder 的 append() 方法啊。”</p>
<p>“是的，不过到了 Java 9（不是长期支持版本，所以我会拿 Java 11 来演示），情况发生了一些改变，同样的代码，字节码指令完全不同了。”我说。</p>
<p>同样的代码，在 Java 11 的环境下，字节码指令是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Compiled from &quot;Demo.java&quot;</span><br><span class="line">public class com.itwanger.thirtyseven.Demo &#123;</span><br><span class="line">  public com.itwanger.thirtyseven.Demo();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: return</span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: ldc           #2                  // String</span><br><span class="line">       2: astore_1</span><br><span class="line">       3: iconst_0</span><br><span class="line">       4: istore_2</span><br><span class="line">       5: iload_2</span><br><span class="line">       6: bipush        10</span><br><span class="line">       8: if_icmpge     41</span><br><span class="line">      11: new           #3                  // class java/lang/String</span><br><span class="line">      14: dup</span><br><span class="line">      15: ldc           #4                  // String 沉默</span><br><span class="line">      17: invokespecial #5                  // Method java/lang/String.&quot;&lt;init&gt;&quot;:</span><br><span class="line">(Ljava/lang/String;)V</span><br><span class="line">      20: astore_3</span><br><span class="line">      21: ldc           #6                  // String 王二</span><br><span class="line">      23: astore        4</span><br><span class="line">      25: aload_1</span><br><span class="line">      26: aload_3</span><br><span class="line">      27: aload         4</span><br><span class="line">      29: invokedynamic #7,  0              // InvokeDynamic </span><br><span class="line">#0:makeConcatWithConstants:</span><br><span class="line">(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;</span><br><span class="line">      34: astore_1</span><br><span class="line">      35: iinc          2, 1</span><br><span class="line">      38: goto          5</span><br><span class="line">      41: return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看标号为 29 的这行，字节码指令为 invokedynamic ，该指令允许由应用级的代码来决定方法解析，所谓的应用级的代码其实是一个方法——被称为引导方法（Bootstrap Method），简称 BSM，BSM 会返回一个 CallSite（调用点） 对象，这个对象就和 invokedynamic 指令链接在一起。以后再执行这条 invokedynamic 指令时就不会创建新的 CallSite 对象。CallSite 其实就是一个 MethodHandle（方法句<br>柄）的 holder，指向一个调用点真正执行的方法——此时就是 StringConcatFactory.makeConcatWithConstants() 方法。</p>
<p>“好吧，总之就是 Java 9 以后，JDK 用了另外一种方法来动态解释 + 号操作符，具体的实现方式在字节码指令层面已经看不到了，所以我就以 Java 8 来继续讲解吧。”</p>
<p><strong>为什么要编译为 StringBuilder.append </strong></p>
<p>“再回到《Java 开发手册》上的那段内容：循环体内，拼接字符串最好使用 StringBuilder 的 append() 方法，而不是 + 号操作符。原因就在于循环体内如果用 + 号操作符的话，就会产生大量的 StringBuilder 对象，不仅占用了更多的内存空间，还会让 Java 虚拟机不停的进行垃圾回收，从而降低了程序的性能。”</p>
<p>更好的写法就是在循环的外部新建一个 StringBuilder 对象，然后使用 append() 方法将循环体内的字符串添加进来：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Demo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        for (int i = 1; i &lt; 10; i++) &#123;</span><br><span class="line">            String chenmo = &quot;沉默&quot;;</span><br><span class="line">            String wanger = &quot;王二&quot;;</span><br><span class="line">            sb.append(chenmo);</span><br><span class="line">            sb.append(wanger);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来做个小测试。</p>
<p>第一个，for 循环中使用”+”号操作符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String result = &quot;&quot;;</span><br><span class="line">for (int i = 0; i &lt; 100000; i++) &#123;</span><br><span class="line">    result += &quot;六六六&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二个，for 循环外部新建 StringBuilder，循环体内使用 append() 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder sb = new StringBuilder();</span><br><span class="line">for (int i = 0; i &lt; 100000; i++) &#123;</span><br><span class="line">    sb.append(&quot;六六六&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“这两个小测试分别会耗时多长时间呢？”</p>
<p>“哇，第一个小测试的执行时间是 6212 毫秒，第二个只用了不到 1 毫秒，差距也太大了吧！”</p>
<p>“是的，这下明白了原因吧？”我说。</p>
<p><strong>append方法源码解析 </strong></p>
<p>“好了，来看一下 StringBuilder 类的 append() 方法的源码吧！”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public StringBuilder append(String str) &#123;</span><br><span class="line">    super.append(str);</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这 3 行代码其实没啥看的。我们来看父类 AbstractStringBuilder 的 append() 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public AbstractStringBuilder append(String str) &#123;</span><br><span class="line">    if (str == null)</span><br><span class="line">        return appendNull();</span><br><span class="line">    int len = str.length();</span><br><span class="line">    ensureCapacityInternal(count + len);</span><br><span class="line">    str.getChars(0, len, value, count);</span><br><span class="line">    count += len;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1）判断拼接的字符串是不是 null，如果是，当做字符串“null”来处理。 appendNull() 方法的源码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private AbstractStringBuilder appendNull() &#123;</span><br><span class="line">    int c = count;</span><br><span class="line">    ensureCapacityInternal(c + 4);</span><br><span class="line">    final char[] value = this.value;</span><br><span class="line">    value[c++] = &#x27;n&#x27;;</span><br><span class="line">    value[c++] = &#x27;u&#x27;;</span><br><span class="line">    value[c++] = &#x27;l&#x27;;</span><br><span class="line">    value[c++] = &#x27;l&#x27;;</span><br><span class="line">    count = c;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2）获取字符串的长度。</p>
<p>3） ensureCapacityInternal() 方法的源码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private void ensureCapacityInternal(int minimumCapacity) &#123;</span><br><span class="line">    // overflow-conscious code</span><br><span class="line">    if (minimumCapacity - value.length &gt; 0) &#123;</span><br><span class="line">        value = Arrays.copyOf(value,</span><br><span class="line">                newCapacity(minimumCapacity));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于字符串内部是用数组实现的，所以需要先判断拼接后的字符数组长度是否超过当前数组的长度，如果超过，先对数组进行扩容，然后把原有的值复制到新的数组中。</p>
<p> 4）将拼接的字符串 str 复制到目标数组 value 中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.getChars(0, len, value, count)</span><br></pre></td></tr></table></figure>
<p>5）更新数组的长度 count。</p>
<p><strong>String.concat 拼接字符串 </strong></p>
<p>“除了可以使用 + 号操作符，StringBuilder 的 append() 方法，还有其他的字符串拼接方法吗？”</p>
<p>“有啊，比如说 String 类的 concat() 方法，有点像 StringBuilder 类的 append() 方法。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String chenmo = &quot;沉默&quot;;</span><br><span class="line">String wanger = &quot;王二&quot;;</span><br><span class="line">System.out.println(chenmo.concat(wanger));</span><br></pre></td></tr></table></figure>
<p>可以来看一下 concat() 方法的源码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public String concat(String str) &#123;</span><br><span class="line">    int otherLen = str.length();</span><br><span class="line">    if (otherLen == 0) &#123;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">    int len = value.length;</span><br><span class="line">    char buf[] = Arrays.copyOf(value, len + otherLen);</span><br><span class="line">    str.getChars(buf, len);</span><br><span class="line">    return new String(buf, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1）如果拼接的字符串的长度为 0，那么返回拼接前的字符串。</p>
<p>2）将原字符串的字符数组 value 复制到变量 buf 数组中。</p>
<p>3）把拼接的字符串 str 复制到字符数组 buf 中，并返回新的字符串对象。</p>
<p>我一行一行地解释着。</p>
<p>“和 + 号操作符相比， concat() 方法在遇到字符串为 null 的时候，会抛出 NullPointerException，而“+”号操作符会把 null 当做是“null”字符串来处理。”</p>
<p>如果拼接的字符串非常多， concat() 的效率就会下降，因为创建的字符串对象越来越多。</p>
<p>“还有吗？”</p>
<p>“有，当然有。”</p>
<p><strong>String.join 拼接字符串 </strong></p>
<p>String 类有一个静态方法 join() ，可以这样来使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String chenmo = &quot;沉默&quot;;</span><br><span class="line">String wanger = &quot;王二&quot;;</span><br><span class="line">String cmower = String.join(&quot;&quot;, chenmo, wanger);</span><br><span class="line">System.out.println(cmower);</span><br></pre></td></tr></table></figure>
<p>第一个参数为字符串连接符，比如说：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String message = String.join(&quot;-&quot;, &quot;王二&quot;, &quot;太特么&quot;, &quot;有趣了&quot;);</span><br></pre></td></tr></table></figure>
<p>输出结果为：王二-太特么-有趣了 。</p>
<p>来看一下 join 方法的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static String join(CharSequence delimiter, CharSequence... elements) &#123;</span><br><span class="line">    Objects.requireNonNull(delimiter);</span><br><span class="line">    Objects.requireNonNull(elements);</span><br><span class="line">    // Number of elements not likely worth Arrays.stream overhead.</span><br><span class="line">    StringJoiner joiner = new StringJoiner(delimiter);</span><br><span class="line">    for (CharSequence cs: elements) &#123;</span><br><span class="line">        joiner.add(cs);</span><br><span class="line">    &#125;</span><br><span class="line">    return joiner.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>里面新建了一个叫 StringJoiner 的对象，然后通过 for-each 循环把可变参数添加了进来，最后调用 toString() 方法返回 String。</p>
<p><strong>StringUtils.join 拼接字符串 </strong></p>
<p>“实际的工作中， org.apache.commons.lang3.StringUtils 的 join() 方法也经常用来进行字符串拼接。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String chenmo = &quot;沉默&quot;;</span><br><span class="line">String wanger = &quot;王二&quot;;</span><br><span class="line">StringUtils.join(chenmo, wanger);</span><br></pre></td></tr></table></figure>
<p>该方法不用担心 NullPointerException。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StringUtils.join(null)            = null</span><br><span class="line">StringUtils.join([])              = &quot;&quot;</span><br><span class="line">StringUtils.join([null])          = &quot;&quot;</span><br><span class="line">StringUtils.join([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]) = &quot;abc&quot;</span><br><span class="line">StringUtils.join([null, &quot;&quot;, &quot;a&quot;]) = &quot;a&quot;</span><br></pre></td></tr></table></figure>
<p>来看一下源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static String join(final Object[] array, String separator, final int </span><br><span class="line">startIndex, final int endIndex) &#123;</span><br><span class="line">    if (array == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    if (separator == null) &#123;</span><br><span class="line">        separator = EMPTY;</span><br><span class="line">    &#125;</span><br><span class="line">    final StringBuilder buf = new StringBuilder(noOfItems * 16);</span><br><span class="line">    for (int i = startIndex; i &lt; endIndex; i++) &#123;</span><br><span class="line">        if (i &gt; startIndex) &#123;</span><br><span class="line">            buf.append(separator);</span><br><span class="line">        &#125;</span><br><span class="line">        if (array[i] != null) &#123;</span><br><span class="line">            buf.append(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return buf.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部使用的仍然是 StringBuilder。</p>
<p>“好了，关于字符串拼接的知识点我们就讲到这吧。注意 Java 9 以后，对 + 号操作符的解释和之前发生了变化，字节码指令已经不同了，等后面你学了字节码指令后我们再详细地讲一次。”</p>
<h2 id="2-11-String拆分"><a href="#2-11-String拆分" class="headerlink" title="2.11 String拆分"></a>2.11 String拆分</h2><p>“哥，我感觉字符串拆分没什么可讲的呀，直接上 String 类的 split() 方法不就可以了！”三妹毫不客气地说。</p>
<p>“假如你真的这么觉得，那可要注意了，事情远没这么简单。”我微笑着说。</p>
<p>假如现在有这样一串字符序列“沉默王二，一枚有趣的程序员”，需要按照中文逗号“，”进行拆分，这意味着第一串字符序列为逗号前面的“沉默王二”，第二串字符序列为逗号后面的“一枚有趣的程序员”。</p>
<p>“这不等于没说吗？哥！”还没等我说，三妹就打断了我。</p>
<p>“别着急嘛，等哥说完。”我依然保持着微笑继续说，“在拆分之前，要先进行检查，判断一下这串字符是否包含逗号，否则应该抛出异常。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String cmower = &quot;沉默王二，一枚有趣的程序员&quot;;</span><br><span class="line">        if (cmower.contains(&quot;，&quot;)) &#123;</span><br><span class="line">            String [] parts = cmower.split(&quot;，&quot;);</span><br><span class="line">            System.out.println(&quot;第一部分：&quot; + parts[0] +&quot; 第二部分：&quot; + parts[1]);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;当前字符串没有包含逗号&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“三妹你看，这段代码挺严谨的吧？”我说，“来看一下程序的输出结果。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第一部分：沉默王二 第二部分：一枚有趣的程序员</span><br></pre></td></tr></table></figure>
<p>“的确和预期完全一致。”三妹说。</p>
<p>“这是建立在字符串是确定的情况下，最重要的是分隔符是确定的。否则，麻烦就来了。”我说，“大约有 12 种英文特殊符号，如果直接拿这些特殊符号替换上面代码中的分隔符（中文逗号），这段程序在运行的时候就会出现以下提到的错误。”</p>
<ul>
<li>反斜杠 \ （ArrayIndexOutOfBoundsException）</li>
<li>插入符号 ^ （同上）</li>
<li>美元符号 $ （同上）</li>
<li>逗点 . （同上）</li>
<li>竖线 | （正常，没有出错）</li>
<li>问号 ? （PatternSyntaxException）</li>
<li>星号 * （同上）</li>
<li>加号 + （同上）</li>
<li>左小括号或者右小括号 () （同上）</li>
<li>左方括号或者右方括号 [] （同上）</li>
<li>左大括号或者右大括号 {} （同上）</li>
</ul>
<p>“那遇到这些特殊符号该怎么办呢？”三妹问。</p>
<p>“用正则表达式。”我说，“正则表达式是一组由字母和符号组成的特殊文本，它可以用来从文本中找出满足你想要的格式的句子。”</p>
<p>我在 GitHub 上找打了一个开源的正则表达式学习文档，非常详细。一开始写正则表达式的时候难免会感觉到非常生疏，你可以查看一下这份文档。记不住没关系，遇到就查。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/cdoco/learn-regex-zh">https://github.com/cdoco/learn-regex-zh</a></p>
</blockquote>
<p>除了这份文档，还有一份：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/cdoco/common-regex">https://github.com/cdoco/common-regex</a></p>
</blockquote>
<p>作者收集了一些在平时项目开发中经常用到的正则表达式，可以直接拿来用。</p>
<p>“哥，你真周到。”三妹笑着说。</p>
<p>“好了，来用英文逗点 . 替换一下分隔符。”我说。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String cmower = &quot;沉默王二.一枚有趣的程序员&quot;;</span><br><span class="line">if (cmower.contains(&quot;.&quot;)) &#123;</span><br><span class="line">    String [] parts = cmower.split(&quot;\\.&quot;);</span><br><span class="line">    System.out.println(&quot;第一部分：&quot; + parts[0] +&quot; 第二部分：&quot; + parts[1]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于英文逗点属于特殊符号，所以在使用 split() 方法的时候，就需要使用正则表达式 \. 而不能直接使用 . 。</p>
<p>“为什么用两个反斜杠呢？”三妹问。</p>
<p>“因为反斜杠本身就是一个特殊字符，需要用反斜杠来转义。”我说。</p>
<p>当然了，你也可以使用 [] 来包裹住英文逗点“.”， [] 也是一个正则表达式，用来匹配方括号中包含的任意字符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmower.split(&quot;[.]&quot;);</span><br></pre></td></tr></table></figure>
<p>除此之外， 还可以使用 Pattern 类的 quote() 方法来包裹英文逗点“.”，该方法会返回一个使用 \Q\E 包裹的字符串。</p>
<p><img src="\assets\note\image-20230927113429819.png" alt="image-20230927113429819"></p>
<p>来看示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String [] parts = cmower.split(Pattern.quote(&quot;.&quot;));</span><br></pre></td></tr></table></figure>
<p>当 split() 方法的参数是正则表达式的时候，方法最终会执行下面这行代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return Pattern.compile(regex).split(this, limit);</span><br></pre></td></tr></table></figure>
<p>也就意味着，拆分字符串有了新的选择，可以不使用 String 类的 split() 方法，直接用下面的方式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class TestPatternSplit &#123;</span><br><span class="line">    private static Pattern twopart = Pattern.compile(&quot;\\.&quot;);</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String [] parts = twopart.split(&quot;沉默王二.一枚有趣的程序员&quot;);</span><br><span class="line">        System.out.println(&quot;第一部分：&quot; + parts[0] +&quot; 第二部分：&quot; + parts[1]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“为什么要把 Pattern 表达式声明称 static 的呢？”三妹问。</p>
<p>“由于模式是确定的，通过 static 的预编译功能可以提高程序的效率。”我说，“除此之外，还可以使用 Pattern 配合 Matcher 类进行字符串拆分，这样做的好处是可以对要拆分的字符串进行一些严格的限制，来看这段示例代码。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class TestPatternMatch &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 使用预编译功能，提高效率</span><br><span class="line">     */</span><br><span class="line">    private static Pattern twopart = Pattern.compile(&quot;(.+)\\.(.+)&quot;);</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        checkString(&quot;沉默王二.一枚有趣的程序员&quot;);</span><br><span class="line">        checkString(&quot;沉默王二.&quot;);</span><br><span class="line">        checkString(&quot;.一枚有趣的程序员&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    private static void checkString(String str) &#123;</span><br><span class="line">        Matcher m = twopart.matcher(str);</span><br><span class="line">        if (m.matches()) &#123;</span><br><span class="line">            System.out.println(&quot;第一部分：&quot; + m.group(1) + &quot; 第二部分：&quot; + m.group(2));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;不匹配&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正则表达式 (.+)\.(.+) 的意思是，不仅要把字符串按照英文标点的方式拆成两部分，并且英文逗点的前后要有内容。</p>
<p>来看一下程序的输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一部分：沉默王二 第二部分：一枚有趣的程序员</span><br><span class="line">不匹配</span><br><span class="line">不匹配</span><br></pre></td></tr></table></figure>
<p>不过，使用 Matcher 来匹配一些简单的字符串时相对比较沉重一些，使用 String 类的 split() 仍然是首选，因为该方法还有其他一些牛逼的功能。比如说，如果你想把分隔符包裹在拆分后的字符串的第一部分，可以这样做：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String cmower = &quot;沉默王二，一枚有趣的程序员&quot;;</span><br><span class="line">if (cmower.contains(&quot;，&quot;)) &#123;</span><br><span class="line">    String [] parts = cmower.split(&quot;(?&lt;=，)&quot;);</span><br><span class="line">    System.out.println(&quot;第一部分：&quot; + parts[0] +&quot; 第二部分：&quot; + parts[1]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出的结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第一部分：沉默王二， 第二部分：一枚有趣的程序员</span><br></pre></td></tr></table></figure>
<p>可以看到分隔符“，”包裹在了第一部分，如果希望包裹在第二部分，可以这样做：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String [] parts = cmower.split(&quot;(?=，)&quot;);</span><br></pre></td></tr></table></figure>
<p>“ ?&lt;= 和 ?= 是什么东东啊？”三妹好奇地问。</p>
<p>“它其实是正则表达式中的断言模式。”我说，“你有时间的话，可以看看前面我推荐的两份开源文档。”</p>
<p><img src="\assets\note\image-20230927114020912.png" alt="image-20230927114020912"></p>
<p>“ split() 方法可以传递 2 个参数，第一个为分隔符，第二个为拆分的字符串个数。”我说。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String cmower = &quot;沉默王二，一枚有趣的程序员，宠爱他&quot;;</span><br><span class="line">if (cmower.contains(&quot;，&quot;)) &#123;</span><br><span class="line">    String [] parts = cmower.split(&quot;，&quot;, 2);</span><br><span class="line">    System.out.println(&quot;第一部分：&quot; + parts[0] +&quot; 第二部分：&quot; + parts[1]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进入 debug 模式的话，可以看到以下内容：</p>
<p><img src="\assets\note\image-20230927114123803.png" alt="image-20230927114123803"></p>
<p>也就是说，传递 2 个参数的时候，会直接调用 substring() 进行截取，第二个分隔符后的就不再拆分了。</p>
<p>来看一下程序输出的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第一部分：沉默王二 第二部分：一枚有趣的程序员，宠爱他</span><br></pre></td></tr></table></figure>
<p>“没想到啊，这个字符串拆分还挺讲究的呀！”三妹感慨地说。</p>
<p>“是的，其实字符串拆分在实际的工作当中还是挺经常用的。前端经常会按照规则传递一长串字符序列到后端，后端就需要按照规则把字符串拆分再做处理。”我说。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://htx-rest.github.io">鲸落</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://htx-rest.github.io/posts/7ec90956.html">https://htx-rest.github.io/posts/7ec90956.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://htx-rest.github.io" target="_blank">鲸落</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a><a class="post-meta__tags" href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">基础知识</a></div><div class="post_share"><div class="social-share" data-image="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/assets/weplay.png" target="_blank"><img class="post-qr-code-img" src="/assets/weplay.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/assets/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/assets/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/aeeccc.html" title="携程校招笔试编程真题及其解析（2023.3.7）"><img class="cover" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">携程校招笔试编程真题及其解析（2023.3.7）</div></div></a></div><div class="next-post pull-right"><a href="/posts/815405c2.html" title="科大讯飞校招笔试编程真题及其解析（2023.8.13）"><img class="cover" src="https://source.fomal.cc/img/default_cover_14.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">科大讯飞校招笔试编程真题及其解析（2023.8.13）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/8f70f515.html" title="小红书校招笔试编程真题（2023.3.26）"><img class="cover" src="https://img2.baidu.com/it/u=595920241,2439700946&fm=253&fmt=auto&app=120&f=JPEG?w=1422&h=800" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2023-09-24</div><div class="title">小红书校招笔试编程真题（2023.3.26）</div></div></a></div><div><a href="/posts/9578e9c1.html" title="小红书校招笔试编程真题（2023.4.9）"><img class="cover" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2023-09-24</div><div class="title">小红书校招笔试编程真题（2023.4.9）</div></div></a></div><div><a href="/posts/7d093ba9.html" title="小红书校招笔试编程真题（2023.4.23）"><img class="cover" src="https://img2.baidu.com/it/u=595920241,2439700946&fm=253&fmt=auto&app=120&f=JPEG?w=1422&h=800" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2023-09-24</div><div class="title">小红书校招笔试编程真题（2023.4.23）</div></div></a></div><div><a href="/posts/befb4d57.html" title="小红书校招笔试编程真题（2023.5.7）"><img class="cover" src="https://img2.baidu.com/it/u=595920241,2439700946&fm=253&fmt=auto&app=120&f=JPEG?w=1422&h=800" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2023-09-24</div><div class="title">小红书校招笔试编程真题（2023.5.7）</div></div></a></div><div><a href="/posts/4ce12134.html" title="小红书校招笔试编程真题（2023.7.23）"><img class="cover" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2023-09-24</div><div class="title">小红书校招笔试编程真题（2023.7.23）</div></div></a></div><div><a href="/posts/92b4cb69.html" title="小红书校招笔试编程真题（2023.8.19）"><img class="cover" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2023-09-24</div><div class="title">小红书校招笔试编程真题（2023.8.19）</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://tuchuang.voooe.cn/images/2023/01/02/avatar.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">鲸落</div><div class="author-info__description">随波不逐流</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">84</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">122</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/htx-rest"><i class="fab fa-github"></i><span>前往小窝</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="/assets/wenxin.jpg" target="_blank" title="微信"><i class="iconfont icon-weixin" style="color: #24292e;"></i></a><a class="social-icon" href="/assets/weixingongzhonghao.jpg" target="_blank" title="微信公众号"><i class="iconfont icon-weixingongzhonghao" style="color: #24292e;"></i></a><a class="social-icon" href="https://res.abeim.cn/api/qq/?qq=1656855152" target="_blank" title="QQ"><i class="iconfont icon-QQ" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:1656855152@qq.com" target="_blank" title="QQ邮箱"><i class="iconfont icon-youxiang" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">摸鱼中！！！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-Java%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80"><span class="toc-text">1 Java语法基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-Java%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C%E4%BF%9D%E7%95%99%E5%AD%97"><span class="toc-text">1.1 Java关键字和保留字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-Java%E6%B3%A8%E9%87%8A"><span class="toc-text">1.2 Java注释</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text"> ，因为 javadoc 会插入自己的标题，容易发生冲突。
3）文档注释中可以插入一些 @ 注解，比如说 @see 引用其他类， @version 版本号， @param 参数标识符， @author 作者标识符， @deprecated 已废弃标识符，等等。
05、注释规约 
1）类、字段、方法必须使用文档注释，不能使用单行注释和多行注释。因为注释文档在 IDE 编辑窗口中可以悬浮提示，提高编码效率。
比如说，在使用 String 类的时候，鼠标悬停在 String 上时可以得到以下提示。

2）所有的抽象方法(包括接口中的方法)必须要用 Javadoc 注释、除了返回值、参数、 异常说明外，还必须指出该方法做什么事情，实现什么功能。
3）所有的类都必须添加创建者和创建日期。
Intellij IDEA 中可以在「File and Code Templates」中设置。

语法如下所示：
12345&#x2F;*** 微信搜索「二哈进阶之路」* @author 二哈* @date ${DATE}*&#x2F;
设置好后，在新建一个类的时候就可以自动生成了。
12345678&#x2F;** * 微信搜索「二哈进阶之路」 * * @author 二哈 * @date 2020&#x2F;11&#x2F;16 *&#x2F;public class Test {}
4）所有的枚举类型字段必须要有注释，说明每个数据项的用途。
5）代码修改的同时，注释也要进行相应的修改。
“记住一点，注释是程序固有的一部分。”

第一、注释要能够准确反映设计思想和代码逻辑;
第二、注释要能够描述业务含 义，使别的程序员能够迅速了解到代码背后的信息。

完全没有注释的大段代码对于阅读者形同 天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路;注释也是给继任者看 的，使其能够快速接替自己的工作。
1.3 Java数据类型Java 中的数据类型可分为 2 种：
1）基本数据类型。
基本数据类型是 Java 语言操作数据的基础，包括 boolean、char、byte、short、int、long、float 和 double，共 8 种。
2）引用数据类型。
除了基本数据类型以外的类型，都是所谓的引用类型。常见的有数组（对，没错，数组是引用类型，后面我们会讲）、class（也就是类），以及接口（指向的是实现接口的类的对象）。来个思维导图，感受下。

变量可以分为局部变量、成员变量、静态变量。
当变量是局部变量的时候，必须得先初始化，否则编译器不允许你使用它。拿 int 来举例吧，看下图。

当变量是成员变量或者静态变量时，可以不进行初始化，它们会有一个默认值，仍然以 int 为例，来看代码：
123456789101112&#x2F;** * @author 微信搜「二哈进阶之路」 *&#x2F;public class LocalVar {    private int a;    static int b;    public static void main(String[] args) {        LocalVar lv &#x3D; new LocalVar();        System.out.println(lv.a);        System.out.println(b);    }}
来看输出结果：
1200
瞧见没，int 作为成员变量时或者静态变量时的默认值是 0。那不同的基本数据类型，是有不同的默认值和大小的，来个表格感受下。




数据类型
默认值
大小




boolean
false
1 比特


char
‘\u0000’
2 字节


byte
0
1 字节


short
0
2 字节


int
0
4 字节


long
0L
8 字节


float
0.0f
4 字节


double
0.0
8 字节




01、比特和字节 
比特币（Bitcoin）听说过吧？字节跳动（Byte Dance）听说过吧？这些名字当然不是乱起的，确实和比特、字节有关系。
1）bit（比特） 
比特作为信息技术的最基本存储单位，非常小，但大名鼎鼎的比特币就是以此命名的，它的简写为小写字母“b”。
大家都知道，计算机是以二进制存储数据的，二进制的一位，就是 1 比特，也就是说，比特要么为 0 要么为 1。
2）Byte（字节） 
通常来说，一个英文字符是一个字节，一个中文字符是两个字节。字节与比特的换算关系是：1 字节 &#x3D; 8 比特。
在往上的单位就是 KB，并不是 1000 字节，因为计算机只认识二进制，因此是 2 的 10 次方，也就是 1024个字节。（终于知道 1024 和程序员的关系了吧？狗头保命）

02、基本数据类型 
接下来，我们再来详细地了解一下 8 种基本数据类型。
1）布尔 
布尔（boolean）仅用于存储两个值：true 和 false，也就是真和假，通常用于条件的判断。代码示例：
12boolean hasMoney &#x3D; true;boolean hasGirlFriend &#x3D; false;
2）byte 
一个字节可以表示 2^8 &#x3D; 256 个不同的值。由于 byte 是有符号的，它的值可以是负数或正数，其取值范围是 -128 到 127（包括 -128 和 127）。
在网络传输、大文件读写时，为了节省空间，常用字节来作为数据的传输方式。代码示例：
123byte b; &#x2F;&#x2F; 声明一个 byte 类型变量b &#x3D; 10; &#x2F;&#x2F; 将值 10 赋给变量 bbyte c &#x3D; -100; &#x2F;&#x2F; 声明并初始化一个 byte 类型变量 c，赋值为 -100
3）short 
short 的取值范围在 -32,768 和 32,767 之间，包含 32,767。代码示例：
123short s; &#x2F;&#x2F; 声明一个 short 类型变量s &#x3D; 1000; &#x2F;&#x2F; 将值 1000 赋给变量 sshort t &#x3D; -2000; &#x2F;&#x2F; 声明并初始化一个 short 类型变量 t，赋值为 -2000
实际开发中，short 比较少用，整型用 int 就 OK。
4）int 
int 的取值范围在 -2,147,483,648（-2 ^ 31）和 2,147,483,647（2 ^ 31 -1）（含）之间。如果没有特殊需求，整型数据就用 int。代码示例：
123int i; &#x2F;&#x2F; 声明一个 int 类型变量i &#x3D; 1000000; &#x2F;&#x2F; 将值 1000000 赋给变量 iint j &#x3D; -2000000; &#x2F;&#x2F; 声明并初始化一个 int 类型变量 j，赋值为 -2000000
5）long 
long 的取值范围在 -9,223,372,036,854,775,808(-2^63) 和 9,223,372,036,854,775,807(2^63 -1)（含）之间。如果 int 存储不下，就用 long。代码示例：
123long l; &#x2F;&#x2F; 声明一个 long 类型变量l &#x3D; 100000000000L; &#x2F;&#x2F; 将值 100000000000L 赋给变量 l（注意要加上 L 后缀）long m &#x3D; -20000000000L; &#x2F;&#x2F; 声明并初始化一个 long 类型变量 m，赋值为 -20000000000L
为了和 int 作区分，long 型变量在声明的时候，末尾要带上大写的“L”。不用小写的“l”，是因为小写的“l”容易和数字“1”混淆。
6）float 
float 是单精度的浮点数（单精度浮点数的有效数字大约为 6 到 7 位），32 位（4 字节），遵循 IEEE 754（二进制浮点数算术标准），取值范围为 1.4E-45 到 3.4E+38。float 不适合用于精确的数值，比如说金额。
代码示例：
123float f; &#x2F;&#x2F; 声明一个 float 类型变量f &#x3D; 3.14159f; &#x2F;&#x2F; 将值 3.14159f 赋给变量 f（注意要加上 f 后缀）float g &#x3D; -2.71828f; &#x2F;&#x2F; 声明并初始化一个 float 类型变量 g，赋值为 -2.71828f
为了和 double 作区分，float 型变量在声明的时候，末尾要带上小写的“f”。不需要使用大写的“F”，是因为小写的“f”很容易辨别。
7）double 
double 是双精度浮点数（双精度浮点数的有效数字大约为 15 到 17 位），占 64 位（8 字节），也遵循 IEEE 754 标准，取值范围大约 ±4.9E-324 到 ±1.7976931348623157E308。double 同样不适合用于精确的数值，比如说金额。
代码示例：
1double myDouble &#x3D; 3.141592653589793;
在进行金融计算或需要精确小数计算的场景中，可以使用 BigDecimal 类来避免浮点数舍入误差。
BigDecimal 可以表示一个任意大小且精度完全准确的浮点数。

在实际开发中，如果不是特别大的金额（精确到 0.01 元，也就是一分钱），一般建议乘以 100 转成整型进行处理。

8）char 
char 用于表示 Unicode 字符，占 16 位（2 字节）的存储空间，取值范围为 0 到 65,535。
代码示例：
1char letterA &#x3D; &#39;A&#39;; &#x2F;&#x2F; 用英文的单引号包裹住。
注意，字符字面量应该用单引号（’’）包围，而不是双引号（””），因为双引号表示字符串字面量。
03、单精度和双精度 
单精度（single-precision）和双精度（double-precision）是指两种不同精度的浮点数表示方法。单精度是这样的格式，1 位符号，8 位指数，23 位小数。

单精度浮点数通常占用 32 位（4 字节）存储空间。数值范围大约是 ±1.4E-45 到 ±3.4028235E38，精度大约为 6 到 9 位有效数字。
双精度是这样的格式，1 位符号，11 位指数，52 为小数。

双精度浮点数通常占用 64 位（8 字节）存储空间，数值范围大约是 ±4.9E-324 到 ±1.7976931348623157E308，精度大约为 15 到 17 位有效数字。
计算精度取决于小数位（尾数）。小数位越多，则能表示的数越大，那么计算精度则越高。
一个数由若干位数字组成，其中影响测量精度的数字称作有效数字，也称有效数位。有效数字指科学计算中用以表示一个浮点数精度的那些数字。一般地，指一个用小数形式表示的浮点数中，从第一个非零的数字算起的所有数字。如 1.24 和 0.00124 的有效数字都有 3 位。
以下是确定有效数字的一些基本规则：

非零数字总是有效的。
位于两个非零数字之间的零是有效的。
对于小数，从左侧开始的第一个非零数字之前的零是无效的。
对于整数，从右侧开始的第一个非零数字之后的零是无效的。

下面是一些示例，说明如何确定有效数字：

1234：4 个有效数字（所有数字都是非零数字）
1002：4 个有效数字（零位于两个非零数字之间）
0.00234：3 个有效数字（从左侧开始的前两个零是无效的）
1200：2 个有效数字（从右侧开始的两个零是无效的）

04、int 和 char 类型互转 
int 和 char 之间比较特殊，可以互转，也会在以后的学习当中经常遇到。
1）可以通过强制类型转换将整型 int 转换为字符 char。
123int value_int &#x3D; 65;char value_char  &#x3D; (char) value_int;System.out.println(value_char);
输出 A (其 ASCII 值可以通过整数 65 来表示)。
2）可以使用 Character.forDigit() 方法将整型 int 转换为字符 char，参数 radix 为基数，十进制为 10，十六进制为 16。
1234int radix &#x3D; 10;int value_int &#x3D; 6;char value_char &#x3D; Character.forDigit(value_int , radix);System.out.println(value_char );
Character 为 char 的包装器类型。我们随后会讲。
3）可以使用 int 的包装器类型 Integer 的 toString() 方法+String 的 charAt() 方法转成 char。
123int value_int &#x3D; 1;char value_char &#x3D; Integer.toString(value_int).charAt(0);System.out.println(value_char );
4）char 转 int
当然了，如果只是简单的 char 转 int，直接赋值就可以了。
1int a &#x3D; &#39;a&#39;;
因为发生了自动类型转换，后面会细讲。
05、包装器类型 
包装器类型（Wrapper Types）是 Java 中的一种特殊类型，用于将基本数据类型（如 int、float、char 等）转换为对应的对象类型。

Java 提供了以下包装器类型，与基本数据类型一一对应：
Byte（对应 byte）
Short（对应 short）
Integer（对应 int）
Long（对应 long）
Float（对应 float）
Double（对应 double）
Character（对应 char）
Boolean（对应 boolean）

包装器类型允许我们使用基本数据类型提供的各种实用方法，并兼容需要对象类型的场景。例如，我们可以使用 Integer 类的 parseInt 方法将字符串转换为整数，或使用 Character 类的 isDigit 方法检查字符是否为数字，还有前面提到的 Character.forDigit() 方法。
下面是一个简单的示例，演示了如何使用包装器类型：
123456789101112131415&#x2F;&#x2F; 使用 Integer 包装器类型Integer integerValue &#x3D; new Integer(42);System.out.println(&quot;整数值: &quot; + integerValue);&#x2F;&#x2F; 将字符串转换为整数String numberString &#x3D; &quot;123&quot;;int parsedNumber &#x3D; Integer.parseInt(numberString);System.out.println(&quot;整数值: &quot; + parsedNumber);&#x2F;&#x2F; 使用 Character 包装器类型Character charValue &#x3D; new Character(&#39;A&#39;);System.out.println(&quot;字符: &quot; + charValue);&#x2F;&#x2F; 检查字符是否为数字char testChar &#x3D; &#39;9&#39;;if (Character.isDigit(testChar)) {System.out.println(&quot;字符是个数字.&quot;);}
上面的示例中，我们创建了一个 Integer 类型的对象 integerValue 并为其赋值 42。然后，我们将其值打印到控制台。
我们有一个包含数字的字符串 numberString。我们使用 Integer.parseInt() 方法将其转换为整数 parsedNumber。然后，我们将转换后的值打印到控制台。
我们有一个字符变量 testChar，并为其赋值字符 ‘9’。我们使用 Character.isDigit() 方法检查 testChar 是否为数字字符。如果是数字字符，我们将输出一条消息到控制台。
从 Java 5 开始，自动装箱（Autoboxing）和自动拆箱（Unboxing）机制允许我们在基本数据类型和包装器类型之间自动转换，无需显式地调用构造方法或转换方法。
12Integer integerValue &#x3D; 42; &#x2F;&#x2F; 自动装箱，等同于 new Integer(42)int primitiveValue &#x3D; integerValue; &#x2F;&#x2F; 自动拆箱，等同于 integerValue.intValue()
06、引用数据类型 
基本数据类型在作为成员变量和静态变量的时候有默认值，引用数据类型也有的（学完数组&amp;字符串，以及面向对象编程后会更加清楚，这里先简单过一下）。
String 是最典型的引用数据类型，所以我们就拿 String 类举例，看下面这段代码：
123456789101112&#x2F;** * @author 微信搜「二哈进阶之路」 *&#x2F;public class LocalRef {    private String a;    static String b;    public static void main(String[] args) {        LocalRef lv &#x3D; new LocalRef();        System.out.println(lv.a);        System.out.println(b);    }}
输出结果如下所示：
12nullnull
null 在 Java 中是一个很神奇的存在，在你以后的程序生涯中，见它的次数不会少，尤其是伴随着令人烦恼的“空指针异常”，也就是所谓的 NullPointerException 。
也就是说，引用数据类型的默认值为 null，包括数组和接口。
那你是不是很好奇，为什么数组和接口也是引用数据类型啊？
先来看数组：
12int [] arrays &#x3D; {1,2,3};System.out.println(arrays);
arrays 是一个 int 类型的数组，对吧？打印结果如下所示：
1[I@2d209079
[I 表示数组是 int 类型的，@ 后面是十六进制的 hashCode——这样的打印结果太“人性化”了，一般人表示看不懂！为什么会这样显示呢？查看一下 java.lang.Object 类的 toString() 方法就明白了。

数组虽然没有显式定义成一个类，但它的确是一个对象，继承了祖先类 Object 的所有方法。那为什么数组不单独定义一个类来表示呢？就像字符串 String 类那样呢？
一个合理的解释是 Java 将其隐藏了。假如真的存在一个 Array.java，我们也可以假想它真实的样子，它必须要定义一个容器来存放数组的元素，就像 String 类那样。
12345public final class String    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {    &#x2F;** The value is used for character storage. *&#x2F;    private final char value[];}
数组内部定义数组？没必要的！
再来看接口：
12List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();System.out.println(list);
List 是一个非常典型的接口：
1public interface List&lt;E&gt; extends Collection&lt;E&gt; {}
而 ArrayList 是 List 接口的一个实现：
123public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable{}
对于接口类型的引用变量来说，你没法直接 new 一个：

只能 new 一个实现它的类的对象——那自然接口也是引用数据类型了。
来看一下基本数据类型和引用数据类型之间最大的差别。
基本数据类型：

变量名指向具体的数值。
基本数据类型存储在栈上。

引用数据类型：

变量名指向的是存储对象的内存地址，在栈上。
内存地址指向的对象存储在堆上。

07、堆和栈 
堆是堆（heap），栈是栈（stack），如果看到“堆栈”的话，请不要怀疑自己，那是翻译的错，堆栈也是栈，反正我很不喜欢“堆栈”这种叫法，容易让新人掉坑里。
堆是在程序运行时在内存中申请的空间（可理解为动态的过程）；切记，不是在编译时；因此，Java 中的对象就放在这里，这样做的好处就是：

当需要一个对象时，只需要通过 new 关键字写一行代码即可，当执行这行代码时，会自动在内存的“堆”区分配空间——这样就很灵活。

栈，能够和处理器（CPU，也就是脑子）直接关联，因此访问速度更快。既然访问速度快，要好好利用啊！Java 就把对象的引用放在栈里。为什么呢？因为引用的使用频率高吗？
不是的，因为 Java 在编译程序时，必须明确的知道存储在栈里的东西的生命周期，否则就没法释放旧的内存来开辟新的内存空间存放引用——空间就那么大，前浪要把后浪拍死在沙滩上啊。
这么说就理解了吧？
用图来表示一下，左侧是栈，右侧是堆。

这里再补充一些额外的知识点，能看懂就继续吸收，看不懂可以先去学下一节，以后再来补，没关系的。学习就是这样，可以跳过，可以温故。
举个例子。
1String a &#x3D; new String(&quot;沉默&quot;)
这段代码会先在堆里创建一个 沉默的字符串对象，然后再把对象的引用 a 放到栈里面。这里面还会涉及到字符串常量池，后面会讲。
那么对于这样一段代码，有基本数据类型的变量，有引用类型的变量，堆和栈都是如何存储他们的呢？
123456public void test(){    int i &#x3D; 4;    int y &#x3D; 2;    Object o1 &#x3D; new Object();}
我来画个图表示下。

08、小结 
本文详细探讨了 Java 数据类型，包括比特与字节、基本数据类型、单精度与双精度、int 与 char 互转、包装器类型、引用数据类型以及堆与栈的内存模型。通过阅读本文，你将全面了解 Java 数据类型的概念与使用方法，为 Java 编程打下坚实基础。
1.4 Java数据类型转换数据类型转换的目的是确保在表达式求值时，不同类型的数据能够相互兼容。
01、自动类型转换 
自动类型转换（自动类型提升）是 Java 编译器在不需要显式转换的情况下，将一种基本数据类型自动转换为另一种基本数据类型的过程。这种转换通常发生在表达式求值期间，当不同类型的数据需要相互兼容时。自动类型转换遵循以下规则：

如果任何操作数是 double 类型，其他操作数将被转换为 double 类型。
否则，如果任何操作数是 float 类型，其他操作数将被转换为 float 类型。
否则，如果任何操作数是 long 类型，其他操作数将被转换为 long 类型。
否则，所有操作数将被转换为 int 类型。

需要注意的是，自动类型转换只发生在兼容类型之间。例如，从较小的数据类型（如 int）到较大的数据类型（如 long 或 double）的转换是安全的，因为较大的数据类型可以容纳较小数据类型的所有可能值。
12byte -&gt; short -&gt; int -&gt; long -&gt; float -&gt; doublechar -&gt; int -&gt; long -&gt; float -&gt; double
下面是一个简单的示例，演示了自动类型转换：
12345int intValue &#x3D; 5;double doubleValue &#x3D; 2.5;&#x2F;&#x2F; 自动类型转换：intValue 被转换为 double 类型double result &#x3D; intValue * doubleValue;System.out.println(&quot;结果: &quot; + result); &#x2F;&#x2F; 输出：结果: 12.5
在这个示例中，我们有一个 int 类型的变量 intValue 和一个 double 类型的变量 doubleValue。当我们将它们相乘时，根据自动类型转换的规则，intValue 将被转换为 double 类型，以便将两个 double 类型的操作数相乘。最终结果将是一个 double 类型的值：12.5。
再来举个例子，顾客到超市购物，购买牙膏 2 盒，面巾纸 4 盒。其中牙膏的价格是 10.9 元，面巾纸的价格是 5.8 元，求商品总价格。实现代码如下：
123456float price1 &#x3D; 10.9f; &#x2F;&#x2F; 定义牙膏的价格，单精度浮点型floatdouble price2 &#x3D; 5.8; &#x2F;&#x2F; 定义面巾纸的价格，双精度浮点型doubleint num1 &#x3D; 2; &#x2F;&#x2F; 定义牙膏的数量，整型 intint num2 &#x3D; 4; &#x2F;&#x2F; 定义面巾纸的数量double res &#x3D; price1 * num1 + price2 * num2; &#x2F;&#x2F; 计算总价System.out.println(&quot;一共付给收银员&quot; + res + &quot;元&quot;); &#x2F;&#x2F; 输出总价
上述代码中首先定义了一个 float 类型的变量存储牙膏的价格，然后定义了一个 double 类型的变量存储面巾纸的价格，再定义两个 int 类型的变量存储物品的数量，最后进行了乘运算以及和运算之后，将结果储存在一个 double 类型的变量中进行输出。
1一共付给收银员44.99999923706055元
从执行结果看出，float、int 和 double 三种数据类型参与运算，最后输出的结果为 double 类型的数据。这种转换一般称为“表达式中类型的自动提升”。
自动类型提升有好处，但它也会引起令人疑惑的编译错误。例如，下面看起来正确的程序却会引起问题：
12byte b &#x3D; 50;b &#x3D; b * 2; &#x2F;&#x2F; Type mismatch: cannot convert from int to byte
如上所示，第二行会报“类型不匹配：无法从int转换为byte”错误。
该程序试图将一个完全合法的 byte 型的值 50*2 存储给一个 byte 型的变量。但是当表达式求值的时候，操作数被自动的提升为 int 型，计算结果也被提升为 int 型。这样表达式的结果现在是 int 型，不强制转换它就不能被赋为 byte 型。
所以应该使用一个显示的强制类型转换，例如：
12byte b &#x3D; 50;b &#x3D; (byte)(b*2);
这样就能产生正确的值 100。
注意：char 类型比较特殊，char 自动转换成 int、long、float 和 double，但 byte 和 short 不能自动转换为 char，而且 char 也不能自动转换为 byte 或 short。
02、强制类型转换 
强制类型转换是 Java 中将一种数据类型显式转换为另一种数据类型的过程。与自动类型转换不同，强制类型转换需要程序员显式地指定要执行的转换。强制类型转换在以下情况中可能需要：

将较大的数据类型转换为较小的数据类型。
将浮点数转换为整数。
将字符类型转换为数值类型。

需要注意的是，强制类型转换可能会导致数据丢失或精度降低，因为目标类型可能无法容纳原始类型的所有可能值。因此，在进行强制类型转换时，需要确保转换后的值仍然在目标类型的范围内。
1double -&gt; float -&gt; long -&gt; int -&gt; char -&gt; short -&gt; byte
以下是一个简单的示例，演示了强制类型转换：
1234double doubleValue &#x3D; 42.8;&#x2F;&#x2F; 强制类型转换：将 double 类型转换为 int 类型int intValue &#x3D; (int) doubleValue;System.out.println(&quot;整数值: &quot; + intValue); &#x2F;&#x2F; 输出：整数值: 42
在这个示例中，我们有一个 double 类型的变量 doubleValue。我们希望将其转换为 int 类型的变量 intValue。为此，我们使用强制类型转换语法，即在要转换的变量之前加上目标类型的括号（如 (int)）。
需要注意的是，将 doubleValue 转换为 int 类型时，小数部分将被截断。因此，输出结果将是：Integer value: 42。在这种情况下，精度丢失是可以接受的，但在其他情况下，我们可能需要更加小心地处理类型转换以避免数据丢失。
顾客到超市购物，购买牙膏 2 盒，面巾纸 4 盒。其中牙膏的价格是 10.9 元，面巾纸的价格是 5.8 元，求商品总价格，在计算总价时采用 int 类型的数据进行存储。实现代码如下：
123456float price1 &#x3D; 10.9f;double price2 &#x3D; 5.8;int num1 &#x3D; 2;int num2 &#x3D; 4;int res2 &#x3D; (int) (price1 * num1 + price2 * num2);System.out.println(&quot;一共付给收银员&quot; + res2 + &quot;元&quot;);
在上述实例中，有 double 类型、float 类型和 int 类型的数据参与运算，其运算结果默认为 double 类型，题目要求的结果为 int 类型，因为 int 类型的取值范围要小于 double 类型的取值范围，所以需要进行强制类型转换。
1一共付给收银员44元
1.5 Java基本数据类型缓存池“考你一个问题哈： new Integer(18) 与 Integer.valueOf(18) 的区别是什么？”
new Integer(18) 每次都会新建一个对象;
Integer.valueOf(18) 会使⽤用缓存池中的对象，多次调用只会取同⼀一个对象的引用。
来看下面这段代码：
123456789Integer x &#x3D; new Integer(18);Integer y &#x3D; new Integer(18);System.out.println(x &#x3D;&#x3D; y);Integer z &#x3D; Integer.valueOf(18);Integer k &#x3D; Integer.valueOf(18);System.out.println(z &#x3D;&#x3D; k);Integer m &#x3D; Integer.valueOf(300);Integer p &#x3D; Integer.valueOf(300);System.out.println(m &#x3D;&#x3D; p);
来看一下输出结果吧：
123falsetruefalse
“第一个 false，我知道原因，因为 new 出来的是不同的对象，地址不同。”“第二个和第三个我认为都应该是 true 啊，为什么第三个会输出 false 呢？这个我理解不了。”
“其实原因也很简单。”我胸有成竹地说。
基本数据类型的包装类除了 Float 和 Double 之外，其他六个包装器类（Byte、Short、Integer、Long、Character、Boolean）都有常量缓存池。

Byte：-128~127，也就是所有的 byte 值
Short：-128~127
Long：-128~127
Character：\u0000 - \u007F
Boolean：true 和 false

拿 Integer 来举例子，Integer 类内部中内置了 256 个 Integer 类型的缓存数据，当使用的数据范围在 -128~127 之间时，会直接返回常量池中数据的引用，而不是创建对象，超过这个范围时会创建新的对象。
18 在 -128~127 之间，300 不在。
来看一下 valueOf 方法的源码吧。
12345public static Integer valueOf(int i) {    if (i &gt;&#x3D;IntegerCache.low &amp;&amp; i &lt;&#x3D;IntegerCache.high)        return IntegerCache.cache[i + (-IntegerCache.low)];    return new Integer(i);}
“哦，原来是因为 Integer.IntegerCache 这个内部类的原因啊！”
“是滴。来看一下 IntegerCache 这个静态内部类的源码吧。”
1234567891011121314151617181920212223242526272829private static class IntegerCache {    static final int low &#x3D; -128;    static final int high;    static final Integer cache[];    static {        &#x2F;&#x2F; high value may be configured by property        int h &#x3D; 127;        String integerCacheHighPropValue &#x3D;                sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);        if (integerCacheHighPropValue !&#x3D; null) {            try {                int i &#x3D; parseInt(integerCacheHighPropValue);                i &#x3D; Math.max(i, 127);                &#x2F;&#x2F; Maximum array size is Integer.MAX_VALUE                h &#x3D; Math.min(i, Integer.MAX_VALUE - (-low) -1);            } catch( NumberFormatException nfe) {                &#x2F;&#x2F; If the property cannot be parsed into an int, ignore it.            }        }        high &#x3D; h;        cache &#x3D; new Integer[(high - low) + 1];        int j &#x3D; low;        for(int k &#x3D; 0; k &lt; cache.length; k++)            cache[k] &#x3D; new Integer(j++);        &#x2F;&#x2F; range [-128, 127] must be interned (JLS7 5.1.7)        assert Integer.IntegerCache.high &gt;&#x3D; 127;    }    private IntegerCache() {}}
详细解释下：当我们通过 Integer.valueOf() 方法获取整数对象时，会先检查该整数是否在 IntegerCache 中，如果在，则返回缓存中的对象，否则创建一个新的对象并缓存起来。
需要注意的是，如果使用 new Integer() 创建对象，即使值在 -128 到 127 范围内，也不会被缓存，每次都会创建新的对象。因此，推荐使用 Integer.valueOf() 方法获取整数对象。
学习 static 关键字的时候，会详细解释静态代码块，你暂时先记住，静态代码块通常用来初始化一些静态变量，它会优先于 main() 方法执行。
在静态代码块中，low 为 -128，也就是缓存池的最小值；high 默认为 127，也就是缓存池的最大值，共计 256 个。
可以在 JVM 启动的时候，通过 -XX:AutoBoxCacheMax&#x3D;NNN来设置缓存池的大小，当然了，不能无限大，最大到 Integer.MAX_VALUES - 129
之后，初始化 cache 数组的大小，然后遍历填充，下标从 0 开始。
“这段代码不难理解，难理解的是 assert Integer.IntegerCache.high &gt;&#x3D; 127; ，这行代码是干嘛的呀？”
assert 是 Java 中的一个关键字，寓意是断言，为了方便调试程序，并不是发布程序的组成部分。
默认情况下，断言是关闭的，可以在命令行运行 Java 程序的时候加上 -ea 参数打开断言。
来看这段代码。
123456public class AssertTest {    public static void main(String[] args) {        int high &#x3D; 126;        assert high &gt;&#x3D; 127;    }}
假设手动设置的缓存池大小为 126，显然不太符合缓存池的预期值 127，结果会输出什么呢？直接在 Intellij IDEA 中打开命令行终端，进入 classes 文件，执行：
1&#x2F;usr&#x2F;libexec&#x2F;java_home -v 1.8 --exec java -ea com.itwanger.s51.AssertTest
我用的 macOS 环境，装了好多个版本的 JDK，该命令可以切换到 JDK 8
也可以不指定 Java 版本直接执行（加上 -ea 参数）：
1java -ea com.itwanger.s51.AssertTest
“呀，报错了呀。”
12Exception in thread &quot;main&quot; java.lang.AssertionError        at com.itwanger.s51.AssertTest.main(AssertTest.java:9)
“是滴，因为 126 小于 127。”
“原来 assert 是这样用的啊，我明白了。”
在 Java 中，针对一些基本数据类型（如 Integer、Long、Boolean 等），Java 会在程序启动时创建一些常用的对象并缓存在内存中，以提高程序的性能和节省内存开销。这些常用对象被缓存在一个固定的范围内，超出这个范围的值会被重新创建新的对象。
使用数据类型缓存池可以有效提高程序的性能和节省内存开销，但需要注意的是，在特定的业务场景下，缓存池可能会带来一些问题，例如缓存池中的对象被不同的线程同时修改，导致数据错误等问题。因此，在实际开发中，需要根据具体的业务需求来决定是否使用数据类型缓存池。
1.6 Java运算符运算符在 Java 中占据着重要的位置，对程序的执行有着很大的帮助。除了常见的加减乘除，还有许多其他类型的运算符，来看下面这张思维导图。”

01、算术运算符 
算术运算符除了最常见的加减乘除，还有一个取余的运算符，用于得到除法运算后的余数，来串代码感受下。
12345678910111213int a &#x3D; 10;int b &#x3D; 5;System.out.println(a + b);&#x2F;&#x2F;15System.out.println(a - b);&#x2F;&#x2F;5System.out.println(a * b);&#x2F;&#x2F;50System.out.println(a &#x2F; b);&#x2F;&#x2F;2System.out.println(a % b);&#x2F;&#x2F;0b &#x3D; 3;System.out.println(a + b);&#x2F;&#x2F;13System.out.println(a - b);&#x2F;&#x2F;7System.out.println(a * b);&#x2F;&#x2F;30System.out.println(a &#x2F; b);&#x2F;&#x2F;3System.out.println(a % b);&#x2F;&#x2F;1
对于初学者来说，加法（+）、减法（-）、乘法（*）很好理解，但除法（&#x2F;）和取余（%）会有一点点疑惑。在以往的认知里，10&#x2F;3 是除不尽的，结果应该是 3.333333…，而不应该是 3。相应的，余数也不应该是 1。这是为什么呢？
因为数字在程序中可以分为两种，一种是整型，一种是浮点型（不清楚的同学可以回头看看数据类型那篇），整型和整型的运算结果就是整型，不会出现浮点型。否则，就会出现浮点型。
1234567int a &#x3D; 10;float c &#x3D; 3.0f;double d &#x3D; 3.0;System.out.println(a &#x2F; c); &#x2F;&#x2F; 3.3333333System.out.println(a &#x2F; d); &#x2F;&#x2F; 3.3333333333333335System.out.println(a % c); &#x2F;&#x2F; 1.0System.out.println(a % d); &#x2F;&#x2F; 1.0
需要注意的是，当浮点数除以 0 的时候，结果为 Infinity 或者 NaN。
12System.out.println(10.0 &#x2F; 0.0); &#x2F;&#x2F; InfinitySystem.out.println(0.0 &#x2F; 0.0); &#x2F;&#x2F; NaN
Infinity 的中文意思是无穷大，NaN 的中文意思是这不是一个数字（Not a Number）。
当整数除以 0 的时候（ 10 &#x2F; 0 ），会抛出异常：
12Exception in thread &quot;main&quot; java.lang.ArithmeticException: &#x2F; by zero    at com.itwanger.eleven.ArithmeticOperator.main(ArithmeticOperator.java:32)
所以整数在进行除法运算时，需要先判断除数是否为 0，以免程序抛出异常。
算术运算符中还有两种特殊的运算符，自增运算符（++）和自减运算符（—），它们也叫做一元运算符，只有一个操作数。
12345int x &#x3D; 10;System.out.println(x++);&#x2F;&#x2F;10 (11)  System.out.println(++x);&#x2F;&#x2F;12  System.out.println(x--);&#x2F;&#x2F;12 (11)  System.out.println(--x);&#x2F;&#x2F;10 
一元运算符可以放在数字的前面或者后面，放在前面叫前自增（前自减），放在后面叫后自增（后自减）。
前自增和后自增是有区别的，拿 int y &#x3D; ++x 这个表达式来说（x &#x3D; 10），它可以拆分为 x &#x3D; x+1 &#x3D; 11; y &#x3D; x &#x3D; 11 ，所以表达式的结果为 x &#x3D; 11, y &#x3D; 11 。拿 int y &#x3D; x++ 这个表达式来说（x &#x3D; 10），它可以拆分为 y &#x3D; x &#x3D; 10; x &#x3D; x+1 &#x3D; 11 ，所以表达式的结果为 x &#x3D; 11, y &#x3D; 10 。
123456int x &#x3D; 10;int y &#x3D; ++x;System.out.println(y + &quot; &quot; + x);&#x2F;&#x2F; 11 11x &#x3D; 10;y &#x3D; x++;System.out.println(y + &quot; &quot; + x);&#x2F;&#x2F; 10 11
对于前自减和后自减来说，你可以自己试一把。
02、关系运算符 
关系运算符用来比较两个操作数，返回结果为 true 或者 false。

来看示例：
1234567int a &#x3D; 10, b &#x3D; 20;System.out.println(a &#x3D;&#x3D; b); &#x2F;&#x2F; falseSystem.out.println(a !&#x3D; b); &#x2F;&#x2F; trueSystem.out.println(a &gt; b); &#x2F;&#x2F; falseSystem.out.println(a &lt; b); &#x2F;&#x2F; trueSystem.out.println(a &gt;&#x3D; b); &#x2F;&#x2F; falseSystem.out.println(a &lt;&#x3D; b); &#x2F;&#x2F; true
03、位运算符 
在学习位运算符之前，需要先学习一下二进制，因为位运算符操作的不是整型数值（int、long、short、char、byte）本身，而是整型数值对应的二进制。
12System.out.println(Integer.toBinaryString(60)); &#x2F;&#x2F; 111100System.out.println(Integer.toBinaryString(13)); &#x2F;&#x2F; 1101
从程序的输出结果可以看得出来，60 的二进制是 0011 1100（用 0 补到 8 位），13 的二进制是 0000 1101。
PS：现代的二进制记数系统由戈特弗里德·威廉·莱布尼茨于 1679 年设计。莱布尼茨是德意志哲学家、数学家，历史上少见的通才。

来看示例：
1234567891011121314151617int a &#x3D; 60, b &#x3D; 13;System.out.println(&quot;a 的二进制：&quot; + Integer.toBinaryString(a)); &#x2F;&#x2F; 111100System.out.println(&quot;b 的二进制：&quot; + Integer.toBinaryString(b)); &#x2F;&#x2F; 1101int c &#x3D; a &amp; b;System.out.println(&quot;a &amp; b：&quot; + c + &quot;，二进制是：&quot; + Integer.toBinaryString(c));c &#x3D; a | b;System.out.println(&quot;a | b：&quot; + c + &quot;，二进制是：&quot; + Integer.toBinaryString(c));c &#x3D; a ^ b;System.out.println(&quot;a ^ b：&quot; + c + &quot;，二进制是：&quot; + Integer.toBinaryString(c));c &#x3D; ~a;System.out.println(&quot;~a：&quot; + c + &quot;，二进制是：&quot; + Integer.toBinaryString(c));c &#x3D; a &lt;&lt; 2;System.out.println(&quot;a &lt;&lt; 2：&quot; + c + &quot;，二进制是：&quot; + Integer.toBinaryString(c));c &#x3D; a &gt;&gt; 2;System.out.println(&quot;a &gt;&gt; 2：&quot; + c + &quot;，二进制是：&quot; + Integer.toBinaryString(c));c &#x3D; a &gt;&gt;&gt; 2;System.out.println(&quot;a &gt;&gt;&gt; 2：&quot; + c + &quot;，二进制是：&quot; + Integer.toBinaryString(c));
对于初学者来说，位运算符无法从直观上去计算出结果，不像加减乘除那样。因为我们日常接触的都是十进制，位运算的时候需要先转成二进制，然后再计算出结果。
鉴于此，初学者在写代码的时候其实很少会用到位运算。对于编程高手来说，为了提高程序的性能，会在一些地方使用位运算。比如说，HashMap 在计算哈希值的时候：
1234static final int hash(Object key) {    int h;    return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);}
如果对位运算一点都不懂的话，遇到这样的源码就很吃力。所以说，虽然位运算用的少，但还是要懂。
1）按位左移运算符：
1234System.out.println(10&lt;&lt;2);&#x2F;&#x2F;10*2^2&#x3D;10*4&#x3D;40  System.out.println(10&lt;&lt;3);&#x2F;&#x2F;10*2^3&#x3D;10*8&#x3D;80  System.out.println(20&lt;&lt;2);&#x2F;&#x2F;20*2^2&#x3D;20*4&#x3D;80  System.out.println(15&lt;&lt;4);&#x2F;&#x2F;15*2^4&#x3D;15*16&#x3D;240 
10&lt;&lt;2 等于 10 乘以 2 的 2 次方； 10&lt;&lt;3 等于 10 乘以 2 的 3 次方。
2）按位右移运算符：
123System.out.println(10&gt;&gt;2);&#x2F;&#x2F;10&#x2F;2^2&#x3D;10&#x2F;4&#x3D;2System.out.println(20&gt;&gt;2);&#x2F;&#x2F;20&#x2F;2^2&#x3D;20&#x2F;4&#x3D;5System.out.println(20&gt;&gt;3);&#x2F;&#x2F;20&#x2F;2^3&#x3D;20&#x2F;8&#x3D;2
10&gt;&gt;2 等于 10 除以 2 的 2 次方； 20&gt;&gt;2 等于 20 除以 2 的 2 次方。
04、逻辑运算符 
逻辑与运算符（&amp;&amp;）：多个条件中只要有一个为 false 结果就为 false。
逻辑或运算符（||）：多个条件只要有一个为 true 结果就为 true。
12345int a&#x3D;10;int b&#x3D;5;int c&#x3D;20;System.out.println(a&lt;b&amp;&amp;a&lt;c);&#x2F;&#x2F;false &amp;&amp; true &#x3D; falseSystem.out.println(a&gt;b||a&lt;c);&#x2F;&#x2F;true || true &#x3D; true
逻辑非运算符（!）：用来反转条件的结果，如果条件为 true，则逻辑非运算符将得到 false。
单逻辑与运算符（&amp;）：很少用，因为不管第一个条件为 true 还是 false，依然会检查第二个。
单逻辑或运算符（|）：也会检查第二个条件。
也就是说，&amp; 和 | 性能不如 &amp;&amp; 和 ||，但用法一样：
12345int a&#x3D;10;int b&#x3D;5;int c&#x3D;20;System.out.println(a&lt;b&amp;a&lt;c);&#x2F;&#x2F;false &amp; true &#x3D; falseSystem.out.println(a&gt;b|a&lt;c);&#x2F;&#x2F;true | true &#x3D; true  
05、赋值运算符 
赋值操作符恐怕是 Java 中使用最频繁的操作符了，它就是把操作符右侧的值赋值给左侧的变量。来看示例：
123456int a&#x3D;10;int b&#x3D;20;a+&#x3D;4;&#x2F;&#x2F;a&#x3D;a+4 (a&#x3D;10+4)  b-&#x3D;4;&#x2F;&#x2F;b&#x3D;b-4 (b&#x3D;20-4)  System.out.println(a);System.out.println(b);
不过在进行数值的赋值时，需要小点心，比如说下面这种情况：

编译器之所以提示错误，是因为 &#x3D; 右侧的算术表达式默认为 int 类型，左侧是 short 类型的时候需要进行强转。
12345short a &#x3D; 10;short b &#x3D; 10;&#x2F;&#x2F;a+&#x3D;b;&#x2F;&#x2F;a&#x3D;a+b internally so finea &#x3D; (short)(a + b);System.out.println(a);
除此之外，还会有边界问题，比如说，两个非常大的 int 相乘，结果可能就超出了 int 的范围：
1234int a &#x3D; Integer.MAX_VALUE;int b &#x3D; 10000;int c &#x3D; a * b;System.out.println(c); &#x2F;&#x2F; -10000
程序输出的结果为 -10000，这个答案很明显不是我们想要的结果，虽然可以通过右侧表达式强转 long 的方法解决：
1234int a &#x3D; Integer.MAX_VALUE;int b &#x3D; 10000;long c &#x3D; (long)a * b;System.out.println(c); &#x2F;&#x2F; 21474836470000
但尽量不要这样做，结果非常大的时候，尽量提前使用相应的类型进行赋值。
1234long a &#x3D; Integer.MAX_VALUE - 1;long b &#x3D; 10000;long c &#x3D; a * b;System.out.println(c); &#x2F;&#x2F; 21474836460000
06、三元运算符 
三元运算符用于替代 if-else，可以使用一行代码完成条件判断的要求。来看示例：
1234int a&#x3D;2;int b&#x3D;5;int min&#x3D;(a&lt;b)?a:b;System.out.println(min);
如果 ? 前面的条件为 true，则结果为 : 前的值，否则为 : 后的值。
07、小结 
本文全面介绍了Java运算符，包括算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符等。通过阅读本文，您将了解到Java运算符的分类、用法和优先级，以及如何在实际开发中灵活运用各类运算符提高编程效率。
1.7 Java流程控制语句“流程控制语句都有哪些呢？”
“比如说 if-else、switch、for、while、do-while、return、break、continue 等等，接下来，我们一个个来了解下。”
01、if-else 相关

1）if 语句 
if 语句的格式如下：
123if(布尔表达式){  &#x2F;&#x2F; 如果条件为 true，则执行这块代码}
画个流程图表示一下：

来写个示例：
1234int age &#x3D; 20;if (age &lt; 30) {    System.out.println(&quot;青春年华&quot;);}
输出：
1青春年华
2）if-else 语句 
if-else 语句的格式如下:
12345if(布尔表达式){  &#x2F;&#x2F; 条件为 true 时执行的代码块}else{  &#x2F;&#x2F; 条件为 false  时执行的代码块} 
画个流程图表示一下：

来写个示例：
123456int age &#x3D; 31;if (age &lt; 30) {    System.out.println(&quot;青春年华&quot;);} else {    System.out.println(&quot;而立之年&quot;);}
输出：
1而立之年
除了这个例子之外，还有一个判断闰年（被 4 整除但不能被 100 整除或者被 400 整除）的例子：
123456int year &#x3D; 2020;if (((year % 4 &#x3D;&#x3D; 0) &amp;&amp; (year % 100 !&#x3D; 0)) || (year % 400 &#x3D;&#x3D; 0)) {    System.out.println(&quot;闰年&quot;);} else {    System.out.println(&quot;普通年份&quot;);}
输出：
1闰年
如果执行语句比较简单的话，可以使用三元运算符来代替 if-else 语句，如果条件为 true，返回 ? 后面 : 前面的值；如果条件为 false，返回 : 后面的值。
123int num &#x3D; 13;String result &#x3D; (num % 2 &#x3D;&#x3D; 0) ? &quot;偶数&quot; : &quot;奇数&quot;;System.out.println(result);
输出：
1奇数
3）if-else-if 语句 
if-else-if 语句的格式如下：
123456789101112if(条件1){  &#x2F;&#x2F; 条件1 为 true 时执行的代码}else if(条件2){  &#x2F;&#x2F; 条件2 为 true 时执行的代码}  else if(条件3){  &#x2F;&#x2F; 条件3 为 true 时执行的代码}  ...  else{  &#x2F;&#x2F; 以上条件均为 false 时执行的代码} 
画个流程图表示一下：

来写个示例：
12345678910int age &#x3D; 31;if (age &lt; 30) {    System.out.println(&quot;青春年华&quot;);} else if (age &gt;&#x3D; 30 &amp;&amp; age &lt; 40 ) {    System.out.println(&quot;而立之年&quot;);} else if (age &gt;&#x3D; 40 &amp;&amp; age &lt; 50 ) {    System.out.println(&quot;不惑之年&quot;);} else {    System.out.println(&quot;知天命&quot;);}
输出：
1而立之年
4）if 嵌套语句 
if 嵌套语句的格式如下：
123456if(外侧条件){         &#x2F;&#x2F; 外侧条件为 true 时执行的代码     if(内侧条件){          &#x2F;&#x2F; 内侧条件为 true 时执行的代码    }    } 
画个流程图表示一下：

来写个示例：
1234567int age &#x3D; 20;boolean isGirl &#x3D; true;if (age &gt;&#x3D; 20) {    if (isGirl) {        System.out.println(&quot;女生法定结婚年龄&quot;);    }}
输出：
1女生法定结婚年龄
02、switch 语句 
switch 语句用来判断变量与多个值之间的相等性。变量的类型可以是 byte、short、int 或者 char，或者对应的包装器类型 Byte、Short、Integer、Character，以及字符串和枚举类型。
来看一下 switch 语句的格式：
123456789101112switch(变量) {    case 可选值1:     &#x2F;&#x2F; 可选值1匹配后执行的代码;     break;  &#x2F;&#x2F; 该关键字是可选项case 可选值2:     &#x2F;&#x2F; 可选值2匹配后执行的代码;     break;  &#x2F;&#x2F; 该关键字是可选项......        default: &#x2F;&#x2F; 该关键字是可选项      &#x2F;&#x2F; 所有可选值都不匹配后执行的代码 }    

变量可以有 1 个或者 N 个值。
值类型必须和变量类型是一致的，并且值是确定的。
值必须是唯一的，不能重复，否则编译会出错。
break 关键字是可选的，如果没有，则执行下一个 case，如果有，则跳出 switch 语句。
default 关键字也是可选的。

画个流程图：

来个示例：
123456789101112131415int age &#x3D; 20;switch (age) {    case 20 :        System.out.println(&quot;上学&quot;);        break;    case 24 :        System.out.println(&quot;苏州工作&quot;);        break;    case 30 :        System.out.println(&quot;洛阳工作&quot;);        break;    default:        System.out.println(&quot;未知&quot;);        break; &#x2F;&#x2F; 可省略}
输出：
1上学
当两个值要执行的代码相同时，可以把要执行的代码写在下一个 case 语句中，而上一个 case 语句中什么也没有，来看一下示例：
12345678910111213141516String name &#x3D; &quot;沉默王二&quot;;switch (name) {    case &quot;詹姆斯&quot;:        System.out.println(&quot;篮球运动员&quot;);        break;    case &quot;穆里尼奥&quot;:        System.out.println(&quot;足球教练&quot;);        break;    case &quot;沉默王二&quot;:    case &quot;沉默王三&quot;:        System.out.println(&quot;乒乓球爱好者&quot;);        break;    default:        throw new IllegalArgumentException(                &quot;名字没有匹配项&quot;);}
输出：
1乒乓球爱好者
枚举作为 switch 语句的变量也很常见，来看例子：
1234567891011121314151617181920212223242526public class SwitchEnumDemo {    public enum PlayerTypes {        TENNIS,        FOOTBALL,        BASKETBALL,        UNKNOWN    }    public static void main(String[] args) {        System.out.println(createPlayer(PlayerTypes.BASKETBALL));    }    private static String createPlayer(PlayerTypes playerType) {        switch (playerType) {            case TENNIS:                return &quot;网球运动员费德勒&quot;;            case FOOTBALL:                return &quot;足球运动员C罗&quot;;            case BASKETBALL:                return &quot;篮球运动员詹姆斯&quot;;            case UNKNOWN:                throw new IllegalArgumentException(&quot;未知&quot;);            default:                throw new IllegalArgumentException(                        &quot;运动员类型: &quot; + playerType);        }    }}
输出：
1篮球运动员詹姆斯
03、for 循环

1）普通 for 循环 
普通的 for 循环可以分为 4 个部分：
1）初始变量：循环开始执行时的初始条件。
2）条件：循环每次执行时要判断的条件，如果为 true，就执行循环体；如果为 false，就跳出循环。当然了，条件是可选的，如果没有条件，则会一直循环。
3）循环体：循环每次要执行的代码块，直到条件变为 false。
4）自增&#x2F;自减：初始变量变化的方式。
来看一下普通 for 循环的格式：
123for(初始变量;条件;自增&#x2F;自减){  &#x2F;&#x2F; 循环体} 
画个流程图：

来个示例：
123for (int i &#x3D; 0; i &lt; 5; i++) {    System.out.println(&quot;沉默好美啊&quot;);}
输出：
12345沉默好美啊沉默好美啊沉默好美啊沉默好美啊沉默好美啊
循环语句还可以嵌套呢，这样就可以打印出更好玩的呢
123456for (int i &#x3D; 0; i &lt; 5; i++) {    for (int j &#x3D; 0;j&lt;&#x3D; i;j++) {        System.out.print(&quot;❤&quot;);    }    System.out.println();}
打印出什么玩意呢？
12345❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤
2）for-each 
for-each 循环通常用于遍历数组和集合，它的使用规则比普通的 for 循环还要简单，不需要初始变量，不需要条件，不需要下标来自增或者自减。来看一下语法：
123for(元素类型 元素 : 数组或集合){  &#x2F;&#x2F; 要执行的代码}  
来看一下示例：
1234String[] strs &#x3D; {&quot;沉默&quot;, &quot;一枚有趣的程序员&quot;};for (String str : strs) {    System.out.println(str);}
输出：
12沉默一枚有趣的程序员
3）无限 for 循环 
“你想不想体验一下无限 for 循环的威力，也就是死循环。”
123for(;;){    System.out.println(&quot;停不下来。。。。&quot;);}
输出：
1234停不下来。。。。停不下来。。。。停不下来。。。。停不下来。。。。
一旦运行起来，就停不下来了，除非强制停止。
04、while 循环 
来看一下 while 循环的格式：

来个示例：
12345678int i &#x3D; 0;while (true) {    System.out.println(&quot;沉默&quot;);    i++;    if (i &#x3D;&#x3D; 5) {        break;    }}
输出：
12345沉默沉默沉默沉默沉默
“你想不想体验一下无限 while 循环的威力，也就是死循环。”
123while (true) {    System.out.println(&quot;停不下来。。。。&quot;);}
输出：
1234停不下来。。。。停不下来。。。。停不下来。。。。停不下来。。。。
把 while 的条件设置为 true，并且循环体中没有 break 关键字的话，程序一旦运行起来，就根本停不下来了，除非强制停止。
05、do-while 循环 
来看一下 do-while 循环的格式：
123do{  &#x2F;&#x2F; 循环体}while(提交);  
画个流程图：

来个示例：
12345678int i &#x3D; 0;do {    System.out.println(&quot;沉默&quot;);    i++;    if (i &#x3D;&#x3D; 5) {        break;    }} while (true);
输出：
12345沉默沉默沉默沉默沉默
“你想不想体验一下无限 do-while 循环的威力……”
123do {    System.out.println(&quot;停不下来。。。。&quot;);} while (true);
输出：
1234停不下来。。。。停不下来。。。。停不下来。。。。停不下来。。。。
把 do-while 的条件设置为 true，并且循环体中没有 break 关键字的话，程序一旦运行起来，就根本停不下来了，除非强制停止。

06、break 
break 关键字通常用于中断循环或 switch 语句，它在指定条件下中断程序的当前流程。如果是内部循环，则仅中断内部循环。
可以将 break 关键字用于所有类型循环语句中，比如说 for 循环、while 循环，以及 do-while 循环。
来画个流程图感受一下：

用在 for 循环中的示例：
123456for (int i &#x3D; 1; i &lt;&#x3D; 10; i++) {    if (i &#x3D;&#x3D; 5) {        break;    }    System.out.println(i);}
用在嵌套 for 循环中的示例：
12345678for (int i &#x3D; 1; i &lt;&#x3D; 3; i++) {    for (int j &#x3D; 1; j &lt;&#x3D; 3; j++) {        if (i &#x3D;&#x3D; 2 &amp;&amp; j &#x3D;&#x3D; 2) {            break;        }        System.out.println(i + &quot; &quot; + j);    }}
用在 while 循环中的示例：
123456789int i &#x3D; 1;while (i &lt;&#x3D; 10) {    if (i &#x3D;&#x3D; 5) {        i++;        break;    }    System.out.println(i);    i++;}
用在 do-while 循环中的示例：
123456789int j &#x3D; 1;do {    if (j &#x3D;&#x3D; 5) {         j++;        break;    }    System.out.println(j);    j++;} while (j &lt;&#x3D; 10);
用在 switch 语句中的示例：
1234567891011121314switch (age) {    case 20 :        System.out.println(&quot;上学&quot;);        break;    case 24 :        System.out.println(&quot;苏州工作&quot;);        break;    case 30 :        System.out.println(&quot;洛阳工作&quot;);        break;    default:        System.out.println(&quot;未知&quot;);        break; &#x2F;&#x2F; 可省略}
07、continue 
当我们需要在 for 循环或者 （do）while 循环中立即跳转到下一个循环时，就可以使用 continue 关键字，通常用于跳过指定条件下的循环体，如果循环是嵌套的，仅跳过当前循环。
来个示例：
1234567for (int i &#x3D; 1; i &lt;&#x3D; 10; i++) {    if (i &#x3D;&#x3D; 5) {        &#x2F;&#x2F; 使用 continue 关键字        continue;&#x2F;&#x2F; 5 将会被跳过    }    System.out.println(i);}
输出：
1234567891234678910
再来个循环嵌套的例子。
123456789for (int i &#x3D; 1; i &lt;&#x3D; 3; i++) {    for (int j &#x3D; 1; j &lt;&#x3D; 3; j++) {        if (i &#x3D;&#x3D; 2 &amp;&amp; j &#x3D;&#x3D; 2) {            &#x2F;&#x2F;  当i&#x3D;2，j&#x3D;2时跳过            continue;        }        System.out.println(i + &quot; &quot; + j);    }}
打印出什么玩意呢？
123456781 11 21 32 12 33 13 23 3
“2 2” 没有输出，被跳过了。
再来看一下 while 循环时 continue 的使用示例：
123456789int i &#x3D; 1;while (i &lt;&#x3D; 10) {    if (i &#x3D;&#x3D; 5) {        i++;        continue;    }    System.out.println(i);    i++;}
输出：
1234567891234678910
注意：如果把 if 条件中的“i++”省略掉的话，程序就会进入死循环，一直在 continue。
最后，再来看一下 do-while 循环时 continue 的使用示例：
123456789int i&#x3D;1;do{    if(i&#x3D;&#x3D;5){        i++;        continue;    }    System.out.println(i);    i++;}while(i&lt;&#x3D;10);
输出：
1234567891234678910
注意：同样的，如果把 if 条件中的“i++”省略掉的话，程序就会进入死循环，一直在 continue。
08、小结 
本文全面讲解了Java流程控制语句，包括if、switch、while、for等结构。通过学习本文，你将了解到Java流程控制语句的基本概念、语法结构和使用场景，帮助你在实际编程过程中更加灵活地运用各类控制结构。
2 数组&amp;字符串2.1 掌握Java数组“ArrayList 的内部是用数组实现的”
“的确是的，看 ArrayList 的源码就一清二楚了。”我一边说，一边打开 Intellij IDEA，并找到了 ArrayList 的源码。
12345678910111213&#x2F;** * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData &#x3D;&#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA * will be expanded to DEFAULT_CAPACITY when the first element is added. *&#x2F;transient Object[] elementData; &#x2F;&#x2F; non-private to simplify nested class access&#x2F;** * The size of the ArrayList (the number of elements it contains). * * @serial *&#x2F;private int size;
“瞧见没？ Object[] elementData 就是数组。”我指着显示屏上这串代码继续说。
数组是一个对象，它包含了一组固定数量的元素，并且这些元素的类型是相同的。数组会按照索引的方式将元素放在指定的位置上，意味着我们可以通过索引来访问这些元素。在 Java 中，索引是从 0 开始的。
“能说一下为什么索引从 0 开始吗？”
“哦，Java 是基于 C&#x2F;C++ 语言实现的，而 C 语言的下标是从 0 开始的，所以 Java 就继承了这个良好的传统习惯。C语言有一个很重要概念，叫做指针，它实际上是一个偏移量，距离开始位置的偏移量，第一个元素就在开始的位置，它的偏移量就为 0，所以索引就为 0。”此刻，我很自信。
“此外，还有另外一种说法。早期的计算机资源比较匮乏，0 作为起始下标相比较于 1 作为起始下标，编译的效率更高。”
我们可以将数组理解为一个个整齐排列的单元格，每个单元格里面存放着一个元素。
数组元素的类型可以是基本数据类型（比如说 int、double），也可以是引用数据类型（比如说 String），包括自定义类型。
数组的声明方式分两种。
先来看第一种：
1int[] anArray;
再来看第二种：
1int anOtherArray[];
不同之处就在于中括号的位置，是跟在类型关键字的后面，还是跟在变量的名称的后面。前一种的使用频率更高一些，像 ArrayList 的源码中就用了第一种方式。
同样的，数组的初始化方式也有多种，最常见的是：
1int[] anArray &#x3D; new int[10];
看到了没？上面这行代码中使用了 new 关键字，这就意味着数组的确是一个对象，只有对象的创建才会用到 new 关键字，基本数据类型是不用的。然后，我们需要在方括号中指定数组的长度。
这时候，数组中的每个元素都会被初始化为默认值，int 类型的就为 0，Object 类型的就为 null。 不同数据类型的默认值不同。
另外，还可以使用大括号的方式，直接初始化数组中的元素：
1int anOtherArray[] &#x3D; new int[] {1, 2, 3, 4, 5};
这时候，数组的元素分别是 1、2、3、4、5，索引依次是 0、1、2、3、4，长度是 5。
“怎么访问数组呢？”
前面提到过，可以通过索引来访问数组的元素，就像下面这样：
1anArray[0] &#x3D; 10;
变量名，加上中括号，加上元素的索引，就可以访问到数组，通过“&#x3D;”操作符可以对元素进行赋值。
如果索引的值超出了数组的界限，就会抛出 ArrayIndexOutOfBoundException 。
既然数组的索引是从 0 开始，那就是到数组的 length - 1 结束，不要使用超出这个范围内的索引访问数组，就不会抛出数组越界的异常了。 
当数组的元素非常多的时候，逐个访问数组就太辛苦了，所以需要通过遍历的方式。
第一种，使用 for 循环：
1234int anOtherArray[] &#x3D; new int[] {1, 2, 3, 4, 5};for (int i &#x3D; 0; i &lt; anOtherArray.length; i++) {    System.out.println(anOtherArray[i]);}
通过 length 属性获取到数组的长度，然后从 0 开始遍历，就得到了数组的所有元素。
第二种，使用 for-each 循环：
123for (int element : anOtherArray) {    System.out.println(element);}
如果不需要关心索引的话（意味着不需要修改数组的某个元素），使用 for-each 遍历更简洁一些。当然，也可以使用 while 和 do-while 循环。
在 Java 中，可变参数用于将任意数量的参数传递给方法，来看 varargsMethod() 方法：
1void varargsMethod(String... varargs) {}
该方法可以接收任意数量的字符串参数，可以是 0 个或者 N 个，本质上，可变参数就是通过数组实现的。为了证明这一点，我们可以看一下反编译一后的字节码：
123456789public class VarargsDemo{    public VarargsDemo()    {    }    transient void varargsMethod(String as[])    {    }}
所以，我们其实可以直接将数组作为参数传递给该方法：
123VarargsDemo demo &#x3D; new VarargsDemo();String[] anArray &#x3D; new String[] {&quot;沉默&quot;, &quot;一枚有趣的程序员&quot;};demo.varargsMethod(anArray);
也可以直接传递多个字符串，通过逗号隔开的方式：
1demo.varargsMethod(&quot;沉默&quot;, &quot;一枚有趣的程序员&quot;);
在 Java 中，数组与 List 关系非常密切。List 封装了很多常用的方法，方便我们对集合进行一些操作，而如果直接操作数组的话，有很多不便，因为数组本身没有提供这些封装好的操作，所以有时候我们需要把数组转成 List。
“怎么转呢？”
最原始的方式，就是通过遍历数组的方式，一个个将数组添加到 List 中。
12345int[] anArray &#x3D; new int[] {1, 2, 3, 4, 5};List&lt;Integer&gt; aList &#x3D; new ArrayList&lt;&gt;();for (int element : anArray) {    aList.add(element);}
更优雅的方式是通过 Arrays 类的 asList() 方法：
1List&lt;Integer&gt; aList &#x3D; Arrays.asList(anArray);
不过需要注意的是，Arrays.asList 的参数需要是 Integer 数组，而 anArray 目前是 int 类型，我们需要换另外一种方式。
1List&lt;Integer&gt; aList &#x3D; Arrays.stream(anArray).boxed().collect(Collectors.toList());
这又涉及到了 Java 流的知识，后面会讲到。
还有一个需要注意的是，Arrays.asList 方法返回的 ArrayList 并不是 java.util.ArrayList ，它其实是Arrays 类的一个内部类：
12private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;        implements RandomAccess, java.io.Serializable{}
如果需要添加元素或者删除元素的话，需要把它转成 java.util.ArrayList 。
1new ArrayList&lt;&gt;(Arrays.asList(anArray));
Java 8 新增了 Stream 流的概念，这就意味着我们也可以将数组转成 Stream 进行操作。
12String[] anArray &#x3D; new String[] {&quot;沉默&quot;, &quot;一枚有趣的程序员&quot;, &quot;好好珍重他&quot;};Stream&lt;String&gt; aStream &#x3D; Arrays.stream(anArray);
如果想对数组进行排序的话，可以使用 Arrays 类提供的 sort() 方法。

基本数据类型按照升序排列
实现了 Comparable 接口的对象按照 compareTo() 的排序

来看第一个例子：
12int[] anArray &#x3D; new int[] {5, 2, 1, 4, 8};Arrays.sort(anArray);
排序后的结果如下所示：
1[1, 2, 4, 5, 8]
来看第二个例子：
123String[] yetAnotherArray &#x3D; new String[] {&quot;A&quot;, &quot;E&quot;, &quot;Z&quot;, &quot;B&quot;, &quot;C&quot;};Arrays.sort(yetAnotherArray, 1, 3,                Comparator.comparing(String::toString).reversed());
只对 1-3 位置上的元素进行反序，所以结果如下所示：
1[A, Z, E, B, C]
有时候，我们需要从数组中查找某个具体的元素，最直接的方式就是通过遍历的方式：
1234567int[] anArray &#x3D; new int[] {5, 2, 1, 4, 8};for (int i &#x3D; 0; i &lt; anArray.length; i++) {    if (anArray[i] &#x3D;&#x3D; 4) {        System.out.println(&quot;找到了 &quot; + i);        break;    }}
上例中从数组中查询元素 4，找到后通过 break 关键字退出循环。
如果数组提前进行了排序，就可以使用二分查找法，这样效率就会更高一些。 Arrays.binarySearch() 方法可供我们使用，它需要传递一个数组，和要查找的元素。
12int[] anArray &#x3D; new int[] {1, 2, 3, 4, 5};int index &#x3D; Arrays.binarySearch(anArray, 4);
2.2 掌握Java二维数组01、什么是二维数组 
二维数组是一种数据类型，可以存储多行和多列的数据。它由一系列的行和列组成，每个元素都可以通过一个行索引和列索引来访问。例如，一个3行4列的二维数组可以表示为以下形式：
12345array &#x3D; [  [a, b, c, d],  [e, f, g, h],  [i, j, k, l]]
在这个例子中，第一行有4个元素，第二行有4个元素，第三行有4个元素，每个元素都有一个行索引和一个列索引。例如，元素 array[1][2] 是第2行第3列的元素，它的值是 g。
使用二维数组可以有效地存储和处理表格数据，如矩阵、图像、地图等等。
02、创建二维数组 
要在 Java 中创建二维数组，你必须指定要存储在数组中的数据类型，后跟两个方括号和数组的名称。
语法如下所示：
1data_type[][] array_name;
让我们看一个代码示例。
1int[][] oddNumbers &#x3D; { {1, 3, 5, 7}, {9, 11, 13, 15} };
03、访问二维数组中的元素 
我们可以使用两个方括号来访问二维中的元素。
第一个表示我们要从中访问元素的数组，而第二个表示我们要访问的元素索引。
让我们用一个例子来简化上面的解释：
123int[][] oddNumbers &#x3D; { {1, 3, 5, 7}, {9, 11, 13, 15} };System.out.println(oddNumbers[0][0]);&#x2F;&#x2F; 1
在上面的示例中， oddNumbers 数组中有两个数组—— {1, 3, 5, 7} 和 {9, 11, 13, 15} 。
第一个数组—— {1, 3, 5, 7} ——用 0 表示。
第二个数组—— {9, 11, 13, 15} ——用 1 表示。
第一个数组是 0，第二个是 1，第三个是 2，依此类推。
因此，要访问第一个数组中的项目，我们将 0 分配给第一个方括号。由于我们试图访问数组中的第一项，我们将使用它的索引，即 0： oddNumbers[0][0] 。
让我们进一步分解它。
这是访问元素的代码： oddNumbers[?][?] 。
我在两个方括号中都加上了问号——随着进展填写它们。
假设我们要访问第二个数组中的元素，我们的代码将如下所示： oddNumbers[1][?] 。
现在我们要在第二个数组（ {9, 11, 13, 15} ）中尝试访问其中一个元素。就像一维数组一样，每个元素都有一个从零开始的索引。
因此，要访问第三个元素 13 ，我们将其索引号传递给第二个方括号： oddNumbers[1][2] 。
来看这样一个例子：
1int[][] oddNumbers &#x3D; { {1, 3, 5, 7}, {9, 11, 13, 15}, {17, 19, 21, 23} };
我们的目标是访问第三个数组中的 21。访问方式仍然通过问号来表示： oddNumbers[?][?] 。
我们首先给第一个问号一个指向要访问的特定数组的值。
数组 0 &#x3D;&gt; {1, 3, 5, 7}
数组 1 &#x3D;&gt; {9, 11, 13, 15}
数组 2 &#x3D;&gt; {17, 19, 21, 23}
我们要查找的数字在第三个数组中，所以是： oddNumbers[2][?] 。
第二个方括号的值将指向要访问的元素。为此，我们必须指定元素的索引。以下是该数组中的索引：
17 &#x3D;&gt; 索引 0
19 &#x3D;&gt; 索引 1
21 &#x3D;&gt; 索引 2
23 &#x3D;&gt; 索引 3
21 的索引为 2，因此我们可以将其添加到第二个方括号： oddNumbers[2][2] 。当你将其打印到控制台时，将会打印出 21。
代码如下所示：
123int[][] oddNumbers &#x3D; { {1, 3, 5, 7}, {9, 11, 13, 15}, {17, 19, 21, 23} };System.out.println(oddNumbers[2][2]);&#x2F;&#x2F; 21
你可以使用嵌套循环，遍历二维数组中的所有项目。这是一个例子：
123456789101112131415161718int[][] oddNumbers &#x3D; { {1, 3, 5, 7}, {9, 11, 13, 15}, {17, 19, 21, 23} };for(int i &#x3D; 0; i &lt; oddNumbers.length; i++){    for(int j &#x3D; 0; j &lt; oddNumbers[i].length; j++){        System.out.println(oddNumbers[i][j]);    }   }&#x2F;&#x2F; 1&#x2F;&#x2F; 3&#x2F;&#x2F; 5&#x2F;&#x2F; 7&#x2F;&#x2F; 9&#x2F;&#x2F; 11&#x2F;&#x2F; 13&#x2F;&#x2F; 15&#x2F;&#x2F; 17&#x2F;&#x2F; 19&#x2F;&#x2F; 21&#x2F;&#x2F; 23
上面的代码将会打印出 oddNumbers 数组中的所有项目。
04、二维数组打印杨辉三角
12345678910111213141516171819202122232425262728import java.util.Scanner;public class YangHuiTriangle {    public static void main(String[] args) {        Scanner input &#x3D; new Scanner(System.in);        System.out.print(&quot;请输入要打印的行数：&quot;);        int n &#x3D; input.nextInt();        printYangHuiTriangle(n);    }    public static void printYangHuiTriangle(int n) {        int[][] triangle &#x3D; new int[n][n];        for (int i &#x3D; 0; i &lt; n; i++) {            &#x2F;&#x2F; 每行的第一个和最后一个数字都是1            triangle[i][0] &#x3D; 1;            triangle[i][i] &#x3D; 1;            for (int j &#x3D; 1; j &lt; i; j++) {                &#x2F;&#x2F; 其他数字是上一行的两个数字之和                triangle[i][j] &#x3D; triangle[i - 1][j - 1] + triangle[i - 1][j];            }        }        &#x2F;&#x2F; 打印杨辉三角        for (int i &#x3D; 0; i &lt; n; i++) {            for (int j &#x3D; 0; j &lt;&#x3D; i; j++) {                System.out.print(triangle[i][j] + &quot; &quot;);            }            System.out.println();        }    }}
“这段代码使用了一个二维数组来存储杨辉三角中的数字。首先，程序要求用户输入要打印的行数，然后调用 printYangHuiTriangle 方法来生成和打印杨辉三角。在 printYangHuiTriangle 方法中，程序使用了一个嵌套的 for 循环来计算杨辉三角中的每个数字，并将结果存储在二维数组 triangle 中。最后，程序再次使用循环来遍历数组并打印出杨辉三角中的数字。”
输出：
1234567请输入要打印的行数：61 1 1 1 2 1 1 3 3 1 1 4 6 4 1 1 5 10 10 5 1 
2.3 打印Java数组“数组也是一个对象，但 Java 中并未明确的定义这样一个类。”
“是的，因此数组也就没有机会覆盖 Object.toString() 方法。如果尝试直接打印数组的话，输出的结果并不是我们预期的结果。”
“那怎么打印数组呢？”
为什么不能直接打印数组
“首先，我们来看一下，为什么不能直接打印数组，直接打印的话，会出现什么问题。”
来看这样一个例子。
12String [] cmowers &#x3D; {&quot;沉默&quot;,&quot;一枚有趣的程序员&quot;};System.out.println(cmowers);
程序打印的结果是：
1[Ljava.lang.String;@3d075dc0
[Ljava.lang.String; 表示字符串数组的 Class 名，@ 后面的是十六进制的 hashCode——这样的打印结果太“人性化”了，一般人表示看不懂！为什么会这样显示呢？查看一下 java.lang.Object 类的 toString() 方法就明白了。
12String [] cmowers &#x3D; {&quot;沉默&quot;,&quot;王二&quot;,&quot;一枚有趣的程序员&quot;};System.out.println(cmowers);
再次证明，数组虽然没有显式定义成一个类，但它的确是一个对象，继承了祖先类 Object 的所有方法。
“那为什么数组不单独定义一个类来表示呢？就像字符串 String 类那样呢？”
“一个合理的说法是 Java 将其隐藏了。假如真的存在这么一个类，就叫 Array.java 吧，我们假想一下它真实的样子，必须得有一个容器来存放数组的每一个元素，就像 String 类那样。”
12345public final class String    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {    &#x2F;** The value is used for character storage. *&#x2F;    private final char value[];}
“最终还是要用类似一种数组的形式来存放数组的元素，对吧？这就变得很没有必要了，不妨就把数组当做是一个没有形体的对象吧！”
stream 流打印 Java 数组 
“我们来看第一种打印数组的方法，使用时髦一点的Stream 流。”
第一种形式：
1Arrays.asList(cmowers).stream().forEach(s -&gt; System.out.println(s));
第二种形式：
1Stream.of(cmowers).forEach(System.out::println);
第三种形式：
1Arrays.stream(cmowers).forEach(System.out::println);
打印的结果如下所示。
12沉默一枚有趣的程序员
没错，这三种方式都可以轻松胜任本职工作，并且显得有点高大上，毕竟用到了 Stream，以及 lambda 表达式。
for 循环打印 Java 数组 
“当然了，也可以使用传统的方式，for 循环。甚至 for-each 也行。”
123456for(int i &#x3D; 0; i &lt; cmowers.length; i++){    System.out.println(cmowers[i]);}for (String s : cmowers) {    System.out.println(s);}
Arrays 工具类打印 Java 数组 
“当然没有了，我认为 Arrays.toString() 是打印数组的最佳方式，没有之一。”Arrays.toString() 可以将任意类型的数组转成字符串，包括基本类型数组和引用类型数组。该方法有多种重载形式。

使用 Arrays.toString() 方法来打印数组再优雅不过了，就像，就像，就像蒙娜丽莎的微笑。

12String [] cmowers &#x3D; {&quot;沉默&quot;,&quot;一枚有趣的程序员&quot;};System.out.println(Arrays.toString(cmowers));
程序打印结果：
1[沉默, 一枚有趣的程序员]
哇，打印格式不要太完美，不多不少！完全是我们预期的结果： [] 表明是一个数组， , 点和空格用来分割元素。
Arrays工具类打印二维数组 
“那如果我想打印二维数组呢？”
“可以使用 Arrays.deepToString() 方法。”
12String[][] deepArray &#x3D; new String[][] {{&quot;沉默&quot;}, {&quot;一枚有趣的程序员&quot;}};System.out.println(Arrays.deepToString(deepArray));
打印结果如下所示。
1[[沉默], [一枚有趣的程序员]]
POJO 的打印规约 
“说到打印，哥给你提醒一点。阿里巴巴的 Java 开发手册上有这样一条规约，你看。”

“什么是 POJO 呢，就是 Plain Ordinary Java Object 的缩写，一般在 Web 应用程序中建立一个数据库的映射对象时，我们称它为 POJO，这类对象不继承或不实现任何其它 Java 框架的类或接口。”
“对于这样的类，最好是重写一下它的 toString() 方法，方便查看这个对象到底包含了什么字段，好排查问题。”
“如果不重写的话，打印出来的 Java 对象就像直接打印数组的那样，一串谁也看不懂的字符序列。”
“可以借助 Intellij IDEA 生成重写的  toString() 方法，特别方便。”
2.4 解读String类源码 
String 类的声明 
123public final class String    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {}
“第一，String 类是 final 的，意味着它不能被子类继承。”
“第二，String 类实现了 Serializable 接口，意味着它可以序列化。”
“第三，String 类实现了 Comparable 接口，意味着最好不要用‘&#x3D;&#x3D;’来比较两个字符串是否相等，而应该用 compareTo() 方法去比较。”
因为 &#x3D;&#x3D; 是用来比较两个对象的地址，这个在讲字符串比较的时候会详细讲。如果只是说比较字符串内容的话，可以使用 String 类的 equals 方法：
123456789101112131415161718192021public boolean equals(Object anObject) {    if (this &#x3D;&#x3D; anObject) {        return true;    }    if (anObject instanceof String) {        String anotherString &#x3D; (String) anObject;        int n &#x3D; value.length;        if (n &#x3D;&#x3D; anotherString.value.length) {            char v1[] &#x3D; value;            char v2[] &#x3D; anotherString.value;            int i &#x3D; 0;            while (n-- !&#x3D; 0) {                if (v1[i] !&#x3D; v2[i])                    return false;                i++;            }            return true;        }    }    return false;}
“第四，StringBuffer、StringBuilder 和 String 一样，都实现了 CharSequence 接口，所以它们仨属于近亲。由于 String 是不可变的，所以遇到字符串拼接的时候就可以考虑一下 String 的另外两个好兄弟，StringBuffer 和 StringBuilder，它俩是可变的。”
String 类的底层实现 
“第五，Java 9 以前，String 是用 char 型数组实现的，之后改成了 byte 型数组实现，并增加了 coder 来表示编码。这样做的好处是在 Latin1 字符为主的程序里，可以把 String 占用的内存减少一半。当然，天下没有免费的午餐，这个改进在节省内存的同时引入了编码检测的开销。”

Latin1（Latin-1）是一种单字节字符集（即每个字符只使用一个字节的编码方式），也称为ISO-8859-1（国际标准化组织8859-1），它包含了西欧语言中使用的所有字符，包括英语、法语、德语、西班牙语、葡萄牙语、意大利语等等。在Latin1编码中，每个字符使用一个8位（即一个字节）的编码，可以表示256种不同的字符，其中包括ASCII字符集中的所有字符，即0x00到0x7F，以及其他西欧语言中的特殊字符，例如é、ü、ñ等等。由于Latin1只使用一个字节表示一个字符，因此在存储和传输文本时具有较小的存储空间和较快的速度

1234567public final class String    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {    @Stable    private final byte[] value;    private final byte coder;    private int hash;}
接下来，我们来详细地说一下。
从 char[] 到 byte[] ，最主要的目的是节省字符串占用的内存空间。内存占用减少带来的另外一个好处，就是 GC 次数也会减少。
我们使用 jmap -histo:live pid | head -n 10 命令就可以查看到堆内对象示例的统计信息、查看 ClassLoader 的信息以及 finalizer 队列。
以我正在运行着的编程喵项目实例（基于 Java 8）来说，结果是这样的。

其中 String 对象有 17638 个，占用了 423312 个字节的内存，排在第三位。
由于 Java 8 的 String 内部实现仍然是 char[] ，所以我们可以看到内存占用排在第 1 位的就是 char 数组。char[] 对象有 17673 个，占用了 1621352 个字节的内存，排在第一位。
那也就是说优化 String 节省内存空间是非常有必要的，如果是去优化一个使用频率没有 String 这么高的类，就没什么必要，对吧？
众所周知，char 类型的数据在 JVM 中是占用两个字节的，并且使用的是 UTF-8 编码，其值范围在 ‘\u0000’（0）和 ‘\uffff’（65,535）（包含）之间。
也就是说，使用 char[] 来表示 String 就会导致，即使 String 中的字符只用一个字节就能表示，也得占用两个字节。

PS：在计算机中，单字节字符通常指的是一个字节（8位）可以表示的字符，而双字节字符则指需要两个字节（16位）才能表示的字符。单字节字符和双字节字符的定义是相对的，不同的编码方式对应的单字节和双字节字符集也不同。常见的单字节字符集有ASCII（美国信息交换标准代码）、ISO-8859（国际标准化组织标准编号8859）、GBK（汉字内码扩展规范）、GB2312（中国国家标准，现在已经被GBK取代），像拉丁字母、数字、标点符号、控制字符都是单字节字符。双字节字符集包括 Unicode、UTF-8、GB18030（中国国家标准），中文、日文、韩文、拉丁文扩展字符属于双字节字符。

当然了，仅仅将 char[] 优化为 byte[] 是不够的，还要配合 Latin-1 的编码方式，该编码方式是用单个字节来表示字符的，这样就比 UTF-8 编码节省了更多的空间。
换句话说，对于：
1String name &#x3D; &quot;jack&quot;;
这样的，使用 Latin-1 编码，占用 4 个字节就够了。
但对于：
1String name &#x3D; &quot;小二&quot;;
这种，木的办法，只能使用 UTF16 来编码。
针对 JDK 9 的 String 源码里，为了区别编码方式，追加了一个 coder 字段来区分。
123456789101112&#x2F;** * The identifier of the encoding used to encode the bytes in * {@code value}. The supported values in this implementation are * * LATIN1 * UTF16 * * @implNote This field is trusted by the VM, and is a subject to * constant folding if String instance is constant. Overwriting this * field after construction will cause problems. *&#x2F;private final byte coder;
Java 会根据字符串的内容自动设置为相应的编码，要么 Latin-1 要么 UTF16。
也就是说，从 char[] 到 byte[] ，中文是两个字节，纯英文是一个字节，在此之前呢，中文是两个字节，英文也是两个字节。
在 UTF-8 中，0-127 号的字符用 1 个字节来表示，使用和 ASCII 相同的编码。只有 128 号及以上的字符才用 2 个、3 个或者 4 个字节来表示。

如果只有一个字节，那么最高的比特位为 0；
如果有多个字节，那么第一个字节从最高位开始，连续有几个比特位的值为 1，就使用几个字节编码，剩下的字节均以 10 开头。

具体的表现形式为：

0xxxxxxx：一个字节；
110xxxxx 10xxxxxx：两个字节编码形式（开始两个 1）；
1110xxxx 10xxxxxx 10xxxxxx：三字节编码形式（开始三个 1）；
11110xxx 10xxxxxx 10xxxxxx 10xxxxxx：四字节编码形式（开始四个 1）。

也就是说，UTF-8 是变长的，那对于 String 这种有随机访问方法的类来说，就很不方便。所谓的随机访问，就是charAt、subString这种方法，随便指定一个数字，String要能给出结果。如果字符串中的每个字符占用的内存是不定长的，那么进行随机访问的时候，就需要从头开始数每个字符的长度，才能找到你想要的字符。
那你可能会问，UTF-16也是变长的呢？一个字符还可能占用 4 个字节呢？
的确，UTF-16 使用 2 个或者 4 个字节来存储字符。

对于 Unicode 编号范围在 0 ~ FFFF 之间的字符，UTF-16 使用两个字节存储。
对于 Unicode 编号范围在 10000 ~ 10FFFF 之间的字符，UTF-16 使用四个字节存储，具体来说就是：将字符编号的所有比特位分成两部分，较高的一些比特位用一个值介于 D800~DBFF 之间的双字节存储，较低的一些比特位（剩下的比特位）用一个值介于 DC00~DFFF 之间的双字节存储。

但是在 Java 中，一个字符（char）就是 2 个字节，占 4 个字节的字符，在 Java 里也是用两个 char 来存储的，而String的各种操作，都是以Java的字符（char）为单位的，charAt是取得第几个char，subString取的也是第几个到第几个char组成的子串，甚至length返回的都是char的个数。
所以UTF-16在Java的世界里，就可以视为一个定长的编码。
String 类的 hashCode 方法 
“第六，每一个字符串都会有一个 hash 值，这个哈希值在很大概率是不会重复的，因此 String 很适合来作为 HashMap 的键值。”
来看 String 类的 hashCode 方法。
123456789101112private int hash; &#x2F;&#x2F; Cache the hash code for the stringpublic int hashCode() {    int h &#x3D; hash;    if (h &#x3D;&#x3D; 0 &amp;&amp; value.length &gt; 0) {        char val[] &#x3D; value;        for (int i &#x3D; 0; i &lt; value.length; i++) {            h &#x3D; 31 * h + val[i];        }        hash &#x3D; h;    }    return h;}
hashCode 方法首先检查是否已经计算过哈希码，如果已经计算过，则直接返回缓存的哈希码。否则，方法将使用一个循环遍历字符串的所有字符，并使用一个乘法和加法的组合计算哈希码。这种计算方法被称为“31 倍哈希法”。计算完成后，将得到的哈希值存储在 hash 成员变量中，以便下次调用 hashCode 方法时直接返回该值，而不需要重新计算。这是一种缓存优化，称为“惰性计算”。
31倍哈希法（31-Hash）是一种简单有效的字符串哈希算法，常用于对字符串进行哈希处理。该算法的基本思想是将字符串中的每个字符乘以一个固定的质数31的幂次方，并将它们相加得到哈希值。具体地，假设字符串为s，长度为n，则31倍哈希值计算公式如下：
1H(s) &#x3D; (s[0] * 31^(n-1)) + (s[1] * 31^(n-2)) + ... + (s[n-1] * 31^0)
其中，s[i]表示字符串s中第i个字符的ASCII码值， ^表示幂运算。31倍哈希法的优点在于简单易实现，计算速度快，同时也比较均匀地分布在哈希表中。
hashCode 方法，我们会在另外一个章节里详细讲。
我们可以通过以下方法模拟 String 的 hashCode 方法：
123456789101112131415public class HashCodeExample {    public static void main(String[] args) {        String text &#x3D; &quot;沉默王二&quot;;        int hashCode &#x3D; computeHashCode(text);        System.out.println(&quot;字符串 \&quot;&quot; + text + &quot;\&quot; 的哈希码是: &quot; + hashCode);        System.out.println(&quot;String 的 hashCode &quot; + text.hashCode());    }    public static int computeHashCode(String text) {        int h &#x3D; 0;        for (int i &#x3D; 0; i &lt; text.length(); i++) {            h &#x3D; 31 * h + text.charAt(i);        }        return h;    }}
看一下结果：
12字符串 &quot;沉默&quot; 的哈希码是: 867758096String 的 hashCode 867758096
结果是一样的，又学到了吧？
String 类的 substring 方法 
String 类中还有一个方法比较常用 substring，用来截取字符串的，来看源码。
12345678910public String substring(int beginIndex) {    if (beginIndex &lt; 0) {        throw new StringIndexOutOfBoundsException(beginIndex);    }    int subLen &#x3D; value.length - beginIndex;    if (subLen &lt; 0) {        throw new StringIndexOutOfBoundsException(subLen);    }    return (beginIndex &#x3D;&#x3D; 0) ? this : new String(value, beginIndex, subLen);}
substring 方法首先检查参数的有效性，如果参数无效，则抛出 StringIndexOutOfBoundsException 异常。
接下来，方法根据参数计算子字符串的长度。如果子字符串长度小于零，抛出StringIndexOutOfBoundsException异常。
如果 beginIndex 为 0，且 endIndex 等于字符串的长度，说明子串与原字符串相同，因此直接返回原字符串。否则，使用 value 数组（原字符串的字符数组）的一部分创建一个新的 String 对象并返回。
下面是几个使用 substring 方法的示例：
①、提取字符串中的一段子串：
123String str &#x3D; &quot;Hello, world!&quot;;String subStr &#x3D; str.substring(7, 12);  &#x2F;&#x2F; 从第7个字符（包括）提取到第12个字符（不包括）System.out.println(subStr);  &#x2F;&#x2F; 输出 &quot;world&quot;
②、提取字符串中的前缀或后缀：
123String str &#x3D; &quot;Hello, world!&quot;;String prefix &#x3D; str.substring(0, 5);  &#x2F;&#x2F; 提取前5个字符，即 &quot;Hello,&quot;String suffix &#x3D; str.substring(7);     &#x2F;&#x2F; 提取从第7个字符开始的所有字符，即 &quot;world!&quot;
③、处理字符串中的空格和分隔符：
12345String str &#x3D; &quot;   Hello,   world!  &quot;;String trimmed &#x3D; str.trim();                  &#x2F;&#x2F; 去除字符串开头和结尾的空格String[] words &#x3D; trimmed.split(&quot;\\s+&quot;);       &#x2F;&#x2F; 将字符串按照空格分隔成单词数组String firstWord &#x3D; words[0].substring(0, 1);  &#x2F;&#x2F; 提取第一个单词的首字母System.out.println(firstWord);  
④、处理字符串中的数字和符号：
1234String str &#x3D; &quot;1234-5678-9012-3456&quot;;String[] parts &#x3D; str.split(&quot;-&quot;);             &#x2F;&#x2F; 将字符串按照连字符分隔成四个部分String last4Digits &#x3D; parts[3].substring(1);  &#x2F;&#x2F; 提取最后一个部分的后三位数字System.out.println(last4Digits);             &#x2F;&#x2F; 输出 &quot;456&quot;
总之，substring 方法可以根据需求灵活地提取字符串中的子串，为字符串处理提供了便利。
String 类的 indexOf 方法 
indexOf 方法用于查找一个子字符串在原字符串中第一次出现的位置，并返回该位置的索引。来看该方法的源码：
1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&#x2F;* * 查找字符数组 target 在字符数组 source 中第一次出现的位置。 * sourceOffset 和 sourceCount 参数指定 source 数组中要搜索的范围， * targetOffset 和 targetCount 参数指定 target 数组中要搜索的范围， * fromIndex 参数指定开始搜索的位置。 * 如果找到了 target 数组，则返回它在 source 数组中的位置索引（从0开始）， * 否则返回-1。 *&#x2F;static int indexOf(char[] source, int sourceOffset, int sourceCount,        char[] target, int targetOffset, int targetCount,        int fromIndex) {    &#x2F;&#x2F; 如果开始搜索的位置已经超出 source 数组的范围，则直接返回-1（如果 target 数组为空，则返回 sourceCount）    if (fromIndex &gt;&#x3D; sourceCount) {        return (targetCount &#x3D;&#x3D; 0 ? sourceCount : -1);    }    &#x2F;&#x2F; 如果开始搜索的位置小于0，则从0开始搜索    if (fromIndex &lt; 0) {        fromIndex &#x3D; 0;    }    &#x2F;&#x2F; 如果 target 数组为空，则直接返回开始搜索的位置    if (targetCount &#x3D;&#x3D; 0) {        return fromIndex;    }    &#x2F;&#x2F; 查找 target 数组的第一个字符在 source 数组中的位置    char first &#x3D; target[targetOffset];    int max &#x3D; sourceOffset + (sourceCount - targetCount);    &#x2F;&#x2F; 循环查找 target 数组在 source 数组中的位置    for (int i &#x3D; sourceOffset + fromIndex; i &lt;&#x3D; max; i++) {        &#x2F;* Look for first character. *&#x2F;        &#x2F;&#x2F; 如果 source 数组中当前位置的字符不是 target 数组的第一个字符，则在 source 数组中继续查找 target 数组的第一个字符        if (source[i] !&#x3D; first) {            while (++i &lt;&#x3D; max &amp;&amp; source[i] !&#x3D; first);        }        &#x2F;* Found first character, now look at the rest of v2 *&#x2F;        &#x2F;&#x2F; 如果在 source 数组中找到了 target 数组的第一个字符，则继续查找 target 数组的剩余部分是否匹配        if (i &lt;&#x3D; max) {            int j &#x3D; i + 1;            int end &#x3D; j + targetCount - 1;            for (int k &#x3D; targetOffset + 1; j &lt; end &amp;&amp; source[j]                    &#x3D;&#x3D; target[k]; j++, k++);            &#x2F;&#x2F; 如果 target 数组全部匹配，则返回在 source 数组中的位置索引            if (j &#x3D;&#x3D; end) {                &#x2F;* Found whole string. *&#x2F;                return i - sourceOffset;            }        }    }    &#x2F;&#x2F; 没有找到 target 数组，则返回-1    return -1;}
来看示例。
①、示例1：查找子字符串的位置
123String str &#x3D; &quot;Hello, world!&quot;;int index &#x3D; str.indexOf(&quot;world&quot;);  &#x2F;&#x2F; 查找 &quot;world&quot; 子字符串在 str 中第一次出现的位置System.out.println(index);        &#x2F;&#x2F; 输出 7
②、示例2：查找字符串中某个字符的位置
123String str &#x3D; &quot;Hello, world!&quot;;int index &#x3D; str.indexOf(&quot;,&quot;);     &#x2F;&#x2F; 查找逗号在 str 中第一次出现的位置System.out.println(index);        &#x2F;&#x2F; 输出 5
③、示例3：查找子字符串的位置（从指定位置开始查找）
123String str &#x3D; &quot;Hello, world!&quot;;int index &#x3D; str.indexOf(&quot;l&quot;, 3);  &#x2F;&#x2F; 从索引为3的位置开始查找 &quot;l&quot; 子字符串在 str 中第一次出现的位置System.out.println(index);        &#x2F;&#x2F; 输出 3
④、示例4：查找多个子字符串
12345String str &#x3D; &quot;Hello, world!&quot;;int index1 &#x3D; str.indexOf(&quot;o&quot;);    &#x2F;&#x2F; 查找 &quot;o&quot; 子字符串在 str 中第一次出现的位置int index2 &#x3D; str.indexOf(&quot;o&quot;, 5); &#x2F;&#x2F; 从索引为5的位置开始查找 &quot;o&quot; 子字符串在 str 中第一次出现的位置System.out.println(index1);       &#x2F;&#x2F; 输出 4System.out.println(index2);       &#x2F;&#x2F; 输出 8
String 类的其他方法 
比如说 length() 用于返回字符串长度。
比如说 isEmpty() 用于判断字符串是否为空。
比如说 charAt() 用于返回指定索引处的字符。
比如说 getBytes() 用于返回字符串的字节数组，可以指定编码方式，比如说：
12String text &#x3D; &quot;沉默&quot;;System.out.println(Arrays.toString(text.getBytes(StandardCharsets.UTF_8)));
比如说 trim() 用于去除字符串两侧的空白字符，来看源码：
123456789101112public String trim() {    int len &#x3D; value.length;    int st &#x3D; 0;    char[] val &#x3D; value;    &#x2F;* avoid getfield opcode *&#x2F;    while ((st &lt; len) &amp;&amp; (val[st] &lt;&#x3D; &#39; &#39;)) {        st++;    }    while ((st &lt; len) &amp;&amp; (val[len - 1] &lt;&#x3D; &#39; &#39;)) {        len--;    }    return ((st &gt; 0) || (len &lt; value.length)) ? substring(st, len) : this;}
举例： “  沉默   “.trim() 会返回”沉默”
除此之外，还有 split、equals、join 等这些方法，我们后面会一一来细讲。
2.5 String为什么不可变String 可能是 Java 中使用频率最高的引用类型了，因此 String 类的设计者可以说是用心良苦。比如说 String 的不可变性。
String 类被 final 关键字修饰，所以它不会有子类，这就意味着没有子类可以重写它的方法，改变它的行为。
String 类的数据存储在 char[] 数组中，而这个数组也被 final 关键字修饰了，这就表示 String 对象是没法被修改的，只要初始化一次，值就确定了。
“为什么要这样设计呢？”
“我先简单来说下，能懂最好，不能懂后面再细说。”
第一，可以保证 String 对象的安全性，避免被篡改，毕竟像密码这种隐私信息一般就是用字符串存储的。
以下是一个简单的 Java 示例，演示了字符串的不可变性如何有助于保证 String 对象的安全性。在本例中，我们创建了一个简单的 User 类，该类使用 String 类型的字段存储用户名和密码。同时，我们使用一个静态方法 getUserCredentials 从外部获取用户凭据。
123456789101112131415161718192021222324252627282930313233343536class User {    private String username;    private String password;    public User(String username, String password) {        this.username &#x3D; username;        this.password &#x3D; password;    }    public String getUsername() {        return username;    }    public String getPassword() {        return password;    }}public class StringSecurityExample {    public static void main(String[] args) {        String username &#x3D; &quot;沉默&quot;;        String password &#x3D; &quot;123456&quot;;        User user &#x3D; new User(username, password);        &#x2F;&#x2F; 获取用户凭据        String[] credentials &#x3D; getUserCredentials(user);        &#x2F;&#x2F; 尝试修改从 getUserCredentials 返回的用户名和密码字符串        credentials[0] &#x3D; &quot;陈清扬&quot;;        credentials[1] &#x3D; &quot;612311&quot;;        &#x2F;&#x2F; 输出原始 User 对象中的用户名和密码        System.out.println(&quot;原始用户名: &quot; + user.getUsername()); &#x2F;&#x2F; 输出 &quot;JohnDoe&quot;        System.out.println(&quot;原始密码: &quot; + user.getPassword()); &#x2F;&#x2F; 输出 &quot;mySecurePassword&quot;    }    public static String[] getUserCredentials(User user) {        String[] credentials &#x3D; new String[2];        credentials[0] &#x3D; user.getUsername();        credentials[1] &#x3D; user.getPassword();        return credentials;    }}
在这个示例中，尽管我们尝试修改 getUserCredentials 返回的字符串数组（即用户名和密码），但原始 User 对象中的用户名和密码保持不变。这证明了字符串的不可变性有助于保护 String 对象的安全性。
第二，保证哈希值不会频繁变更。毕竟要经常作为哈希表的键值，经常变更的话，哈希表的性能就会很差劲。
在 String 类中，哈希值是在第一次计算时缓存的，后续对该哈希值的请求将直接使用缓存值。这有助于提高哈希表等数据结构的性能。以下是一个简单的示例，演示了字符串的哈希值缓存机制：
123456789101112String text1 &#x3D; &quot;沉默&quot;;String text2 &#x3D; &quot;沉默&quot;;&#x2F;&#x2F; 计算字符串 text1 的哈希值，此时会进行计算并缓存哈希值int hashCode1 &#x3D; text1.hashCode();System.out.println(&quot;第一次计算 text1 的哈希值: &quot; + hashCode1);&#x2F;&#x2F; 再次计算字符串 text1 的哈希值，此时直接返回缓存的哈希值int hashCode1Cached &#x3D; text1.hashCode();System.out.println(&quot;第二次计算: &quot; + hashCode1Cached);&#x2F;&#x2F; 计算字符串 text2 的哈希值，由于字符串常量池的存在，实际上 text1 和 text2 指向同一个字符串对象&#x2F;&#x2F; 所以这里直接返回缓存的哈希值int hashCode2 &#x3D; text2.hashCode();System.out.println(&quot;text2 直接使用缓存: &quot; + hashCode2);
在这个示例中，我们创建了两个具有相同内容的字符串 text1 和 text2。首次计算 text1 的哈希值时，会进行实际计算并缓存该值。当我们再次计算 text1 的哈希值或计算具有相同内容的 text2 的哈希值时，将直接返回缓存的哈希值，而不进行重新计算。
由于 String 对象是不可变的，其哈希值在创建后不会发生变化。这使得 String 类可以缓存哈希值，提高哈希表等数据结构的性能。如果 String 是可变的，那么在每次修改时都需要重新计算哈希值，这会降低性能。
第三，可以实现字符串常量池，Java 会将相同内容的字符串存储在字符串常量池中。这样，具有相同内容的字符串变量可以指向同一个 String 对象，节省内存空间。
“由于字符串的不可变性，String 类的一些方法实现最终都返回了新的字符串对象。”
“就拿 substring() 方法来说。”
12345678910public String substring(int beginIndex) {    if (beginIndex &lt; 0) {        throw new StringIndexOutOfBoundsException(beginIndex);    }    int subLen &#x3D; value.length - beginIndex;    if (subLen &lt; 0) {        throw new StringIndexOutOfBoundsException(subLen);    }    return (beginIndex &#x3D;&#x3D; 0) ? this : new String(value, beginIndex, subLen);}
substring() 方法用于截取字符串，最终返回的都是 new 出来的新字符串对象。
“还有 concat() 方法。”
12345678910111213141516171819public String concat(String str) {    int olen &#x3D; str.length();    if (olen &#x3D;&#x3D; 0) {        return this;    }    if (coder() &#x3D;&#x3D; str.coder()) {        byte[] val &#x3D; this.value;        byte[] oval &#x3D; str.value;        int len &#x3D; val.length + oval.length;        byte[] buf &#x3D; Arrays.copyOf(val, len);        System.arraycopy(oval, 0, buf, val.length, oval.length);        return new String(buf, coder);    }    int len &#x3D; length();    byte[] buf &#x3D; StringUTF16.newBytesFor(len + olen);    getBytes(buf, 0, UTF16);    str.getBytes(buf, len, UTF16);    return new String(buf, UTF16);}
concat() 方法用于拼接字符串，不管编码是否一致，最终也返回的是新的字符串对象。
“ replace() 替换方法其实也一样，三妹，你可以自己一会看一下源码，也是返回新的字符串对象。”
“这就意味着，不管是截取、拼接，还是替换，都不是在原有的字符串上进行的，而是重新生成了新的字符串对象。也就是说，这些操作执行过后，原来的字符串对象并没有发生改变。”
“String 对象一旦被创建后就固定不变了，对 String 对象的任何修改都不会影响到原来的字符串对象，都会生成新的字符串对象。”
2.6 深入理解Java字符串常量池 
“今天我们来学习一下字符串常量池，这是字符串中非常关键的一个知识点。”
new String(“二哥”)创建了几个对象 
“先从这道面试题开始吧！”
“这行代码创建了几个对象？”
“不就一个吗？”
“不，两个！”“使用 new 关键字创建一个字符串对象时，Java 虚拟机会先在字符串常量池中查找有没有‘二哥’这个字符串对象，如果有，就不会在字符串常量池中创建‘二哥’这个对象了，直接在堆中创建一个‘二哥’的字符串对象，然后将堆中这个‘二哥’的对象地址返回赋值给变量 s。”
“如果没有，先在字符串常量池中创建一个‘二哥’的字符串对象，然后再在堆中创建一个‘二哥’的字符串对象，然后将堆中这个‘二哥’的字符串对象地址返回赋值给变量 s。”
我画图表示一下，会更加清楚。

在Java中，栈上存储的是基本数据类型的变量和对象的引用，而对象本身则存储在堆上。
对于这行代码 String s &#x3D; new String(“二哥”); ，它创建了两个对象：一个是字符串对象 “二哥”，它被添加到了字符串常量池中，另一个是通过 new String() 构造函数创建的字符串对象 “二哥”，它被分配在堆内存中，同时引用变量 s 存储在栈上，它指向堆内存中的字符串对象 “二哥”。
“为什么要先在字符串常量池中创建对象，然后再在堆上创建呢？这样不就多此一举了？”
我回答，“是的。由于字符串的使用频率实在是太高了，所以 Java 虚拟机为了提高性能和减少内存开销，在创建字符串对象的时候进行了一些优化，特意为字符串开辟了一块空间——也就是字符串常量池。”
字符串常量池的作用 
通常情况下，我们会采用双引号的方式来创建字符串对象，而不是通过 new 关键字的方式，就像下面 这样，这样就不会多此一举：
当执行 String s &#x3D; “三妹” 时，Java 虚拟机会先在字符串常量池中查找有没有“三妹”这个字符串对象，如果有，则不创建任何对象，直接将字符串常量池中这个“三妹”的对象地址返回，赋给变量 s；如果没有，在字符串常量池中创建“三妹”这个对象，然后将其地址返回，赋给变量 s。

Java 虚拟机创建了一个字符串对象 “三妹”，它被添加到了字符串常量池中，同时引用变量 s 存储在栈上，它指向字符串常量池中的字符串对象 “三妹”。你看，是不是省了一步，比之前高效了。
““有了字符串常量池，就可以通过双引号的方式直接创建字符串对象，不用再通过 new 的方式在堆中创建对象了，对吧？”
“是滴。new 的方式始终会创建一个对象，不管字符串的内容是否已经存在，而双引号的方式会重复利用字符串常量池中已经存在的对象。”我说。
来看下面这个例子：
12String s &#x3D; new String(&quot;二哥&quot;);String s1 &#x3D; new String(&quot;二哥&quot;);
按照我们之前的分析，这两行代码会创建三个对象，字符串常量池中一个，堆上两个。
再来看下面这个例子：
12String s &#x3D; &quot;三妹&quot;;String s1 &#x3D; &quot;三妹&quot;;
这两行代码只会创建一个对象，就是字符串常量池中的那个。这样的话，性能肯定就提高了！
字符串常量池在内存中的什么位置呢？ 
分为三个阶段。
Java 7 之前 
在 Java 7 之前，字符串常量池位于永久代（Permanent Generation）的内存区域中，主要用来存储一些字符串常量（静态数据的一种）。永久代是 Java 堆（Java Heap）的一部分，用于存储类信息、方法信息、常量池信息等静态数据。
而 Java 堆是 JVM 中存储对象实例和数组的内存区域，也就是说，永久代是 Java 堆的一个子区域。换句话说，永久代中存储的静态数据与堆中存储的对象实例和数组是分开的，它们有不同的生命周期和分配方式。
但是，永久代和堆的大小是相互影响的，因为它们都使用了 JVM 堆内存，因此它们的大小都受到 JVM 堆大小的限制。
于是，当我们创建一个字符串常量时，它会被储存在永久代的字符串常量池中。如果我们创建一个普通字符串对象，则它将被储存在堆中。如果字符串对象的内容是一个已经存在于字符串常量池中的字符串常量，那么这个对象会指向已经存在的字符串常量，而不是重新创建一个新的字符串对象。
画幅图，大概就是这个样子。

Java 7 
需要注意的是，永久代的大小是有限的，并且很难准确地确定一个应用程序需要多少永久代空间。如果我们在应用程序中使用了大量的类、方法、常量等静态数据，就有可能导致永久代空间不足。这种情况下，JVM 就会抛出 OutOfMemoryError 错误。
因此，从 Java 7 开始，为了解决永久代空间不足的问题，将字符串常量池从永久代中移动到堆中。这个改变也是为了更好地支持动态语言的运行时特性。
再画幅图，大概就是这样子。

Java 8 
到了 Java 8，永久代（PermGen）被取消，并由元空间（Metaspace）取代。元空间是一块本机内存区域，和 JVM 内存区域是分开的。不过，元空间的作用依然和之前的永久代一样，用于存储类信息、方法信息、常量池信息等静态数据。
与永久代不同，元空间具有一些优点，例如：

它不会导致 OutOfMemoryError 错误，因为元空间的大小可以动态调整。
元空间使用本机内存，而不是 JVM 堆内存，这可以避免堆内存的碎片化问题。
元空间中的垃圾收集与堆中的垃圾收集是分离的，这可以避免应用程序在运行过程中因为进行类加载和卸载而频繁地触发 Full GC。

再画幅图，对比来看一下，就会一目了然。

永久代、方法区、元空间 
“能再简单给我解释一下方法区，永久代和元空间的概念吗？有点模糊。”
“可以呀。”

方法区是 Java 虚拟机规范中的一个概念，就像是一个接口吧；
永久代是 HotSpot 虚拟机中对方法区的一个实现，就像是接口的实现类；
Java 8 的时候，移除了永久代，取而代之的是元空间，是方法区的另外一种实现，更灵活了。

永久代是放在运行时数据区中的，所以它的大小受到 Java 虚拟机本身大小的限制，所以 Java 8 之前，会经常遇到 java.lang.OutOfMemoryError: PremGen Space 的异常，PremGen Space 就是方法区的意思；而元空间是直接放在内存中的，所以只受本机可用内存的限制。
2.7 详解 String.intern() 方法“看一下美团技术团队深入解析 String.intern() 文章”
要理解美团技术团队的这篇文章，你只需要记住这几点内容：
第一，使用双引号声明的字符串对象会保存在字符串常量池中。
第二，使用 new 关键字创建的字符串对象会先从字符串常量池中找，如果没找到就创建一个，然后再在堆中创建字符串对象；如果找到了，就直接在堆中创建字符串对象。
第三，针对没有使用双引号声明的字符串对象来说，就像下面代码中的 s1 那样：
1String s1 &#x3D; new String(&quot;二哥&quot;) + new String(&quot;三妹&quot;);
如果想把 s1 的内容也放入字符串常量池的话，可以调用 intern() 方法来完成。
不过，需要注意的是，Java 7 的时候，字符串常量池从永久代中移动到了堆中，虽然此时永久代还没有完全被移除。Java 8 的时候，永久代被彻底移除。
这个变化也直接影响了  String.intern() 方法在执行时的策略，Java 7 之前，执行 String.intern() 方法的时候，不管对象在堆中是否已经创建，字符串常量池中仍然会创建一个内容完全相同的新对象； Java 7 之后呢，由于字符串常量池放在了堆中，执行 String.intern() 方法的时候，如果对象在堆中已经创建了，字符串常量池中就不需要再创建新的对象了，而是直接保存堆中对象的引用，也就节省了一部分的内存空间。
“先来猜猜这段代码输出的结果吧。”
123String s1 &#x3D; new String(&quot;二哥三妹&quot;);String s2 &#x3D; s1.intern();System.out.println(s1 &#x3D;&#x3D; s2);
第一行代码，字符串常量池中会先创建一个“二哥三妹”的对象，然后堆中会再创建一个“二哥三妹”的对象，s1 引用的是堆中的对象。
第二行代码，对 s1 执行 intern() 方法，该方法会从字符串常量池中查找“二哥三妹”这个字符串是否存在，此时是存在的，所以 s2 引用的是字符串常量池中的对象。
也就意味着 s1 和 s2 的引用地址是不同的，一个来自堆，一个来自字符串常量池，所以输出的结果为 false。
“来看一下运行结果。”
1false
“我来画幅图，帮助你理解下。”

“好，我们再来看下面这段代码。”
123String s1 &#x3D; new String(&quot;二哥&quot;) + new String(&quot;三妹&quot;);String s2 &#x3D; s1.intern();System.out.println(s1 &#x3D;&#x3D; s2);
“难道也输出 false ？”
“不，这段代码会输出 true。”
“为啥呀？”
第一行代码，会在字符串常量池中创建两个对象，一个是“二哥”，一个是“三妹”，然后在堆中会创建两个匿名对象“二哥”和“三妹”，最后还有一个“二哥三妹”的对象（稍后会解释），s1 引用的是堆中“二哥三妹”这个对象。
第二行代码，对 s1 执行 intern() 方法，该方法会从字符串常量池中查找“二哥三妹”这个对象是否存在，此时不存在的，但堆中已经存在了，所以字符串常量池中保存的是堆中这个“二哥三妹”对象的引用，也就是说，s2 和 s1 的引用地址是相同的，所以输出的结果为 true。
“来看一下运行结果。”
1true
“我再来画幅图，帮助你理解下。”

“不过，我有一个疑惑，“二哥三妹”这个对象是什么时候创建的呢？”
“不错嘛，能抓住问题的关键。再来解释一下 String s1 &#x3D; new String(“二哥”) + new String(“三妹”) 这行代码。”

创建 “二哥” 字符串对象，存储在字符串常量池中。
创建 “三妹” 字符串对象，存储在字符串常量池中。
执行 new String(“二哥”) ，在堆上创建一个字符串对象，内容为 “二哥”。
执行 new String(“三妹”) ，在堆上创建一个字符串对象，内容为 “三妹”。
执行 new String(“二哥”) + new String(“三妹”) ，会创建一个 StringBuilder 对象，并将 “二哥” 和 “三妹” 追加到其中，然后调用 StringBuilder 对象的 toString() 方法，将其转换为一个新的字符串对象，内容为 “二哥三妹”。这个新的字符串对象存储在堆上。

也就是说，当编译器遇到 + 号这个操作符的时候，会将 new String(“二哥”) + new String(“三妹”) 这行代码编译为以下代码：
1new StringBuilder().append(&quot;二哥&quot;).append(&quot;三妹&quot;).toString();
实际执行过程如下：

创建一个 StringBuilder 对象。
在 StringBuilder 对象上调用 append(“二哥”)，将 “二哥” 追加到 StringBuilder 中。
在 StringBuilder 对象上调用 append(“三妹”)，将 “三妹” 追加到 StringBuilder 中。
在 StringBuilder 对象上调用 toString() 方法，将 StringBuilder 转换为一个新的字符串对象，内容为 “二哥三妹”。

关于 StringBuilder，我们随后会详细地讲到。今天先了解到这。
不过需要注意的是，尽管 intern 可以确保所有具有相同内容的字符串共享相同的内存空间，但也不要烂用 intern，因为任何的缓存池都是有大小限制的，不能无缘无故就占用了相对稀缺的缓存空间，导致其他字符串没有坑位可占。
另外，字符串常量池本质上是一个固定大小的 StringTable，如果放进去的字符串过多，就会造成严重的哈希冲突，从而导致链表变长，链表变长也就意味着字符串常量池的性能会大幅下降，因为要一个一个找是需要花费时间的。
2.8 String、StringBuilder、StringBuffer“上一篇深入理解 String.intern() 讲到了 StringBuilder，这一节我们就来聊聊吧！”
由于字符串是不可变的，所以当遇到字符串拼接（尤其是使用 +号操作符）的时候，就需要考量性能的问题，你不能毫无顾虑地生产太多 String 对象，对珍贵的内存造成不必要的压力。
于是 Java 就设计了一个专门用来解决此问题的 StringBuffer 类。
123456789101112131415public final class StringBuffer extends AbstractStringBuilder implements Serializable, CharSequence {    public StringBuffer() {        super(16);    }        public synchronized StringBuffer append(String str) {        super.append(str);        return this;    }    public synchronized String toString() {        return new String(value, 0, count);    }    &#x2F;&#x2F; 其他方法}
不过，由于 StringBuffer 操作字符串的方法加了 synchronized 关键字进行了同步，主要是考虑到多线程环境下的安全问题，所以执行效率会比较低。
于是 Java 就给 StringBuffer “生了个兄弟”，名叫 StringBuilder，说，“孩子，你别管线程安全了，你就在单线程环境下使用，这样效率会高得多，如果要在多线程环境下修改字符串，你到时候可以使用 ThreadLocal 来避免多线程冲突。”
1234567891011121314public final class StringBuilder extends AbstractStringBuilder    implements java.io.Serializable, CharSequence{    &#x2F;&#x2F; ...    public StringBuilder append(String str) {        super.append(str);        return this;    }    public String toString() {        &#x2F;&#x2F; Create a copy, don&#39;t share the array        return new String(value, 0, count);    }    &#x2F;&#x2F; ...}
除了类名不同，方法没有加 synchronized，基本上完全一样。
实际开发中，StringBuilder 的使用频率也是远高于 StringBuffer，甚至可以这么说，StringBuilder 完全取代了 StringBuffer。
之前我们也曾聊过，Java 是一门解释型的编程语言，所以当编译器遇到 + 号这个操作符的时候，会将 new String(“二哥”) + new String(“三妹”) 这行代码编译为以下代码：
1new StringBuilder().append(&quot;二哥&quot;).append(&quot;三妹&quot;).toString();
这个过程是我们看不见的，但这正是 Java 的“智能”之处，它可以在编译的时候偷偷地帮我们做很多优化，这样既可以提高我们的开发效率（ + 号写起来比创建 StringBuilder 对象便捷得多），也不会影响 JVM 的执行效率。
当然了，如果我们使用 javap 反编译 new String(“二哥”) + new String(“三妹”) 的字节码的时候，也是能看出 StringBuilder 的影子的。
12345678910111213141516171819200: new           #2                  &#x2F;&#x2F; class java&#x2F;lang&#x2F;StringBuilder3: dup4: invokespecial #3                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.&quot;&lt;init&gt;&quot;:()V7: new           #4                  &#x2F;&#x2F; class java&#x2F;lang&#x2F;String10: dup11: ldc           #5                  &#x2F;&#x2F; String 二哥13: invokespecial #6                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;String.&quot;&lt;init&gt;&quot;:(Ljava&#x2F;lang&#x2F;String;)V16: invokevirtual #7                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;19: new           #4                  &#x2F;&#x2F; class java&#x2F;lang&#x2F;String22: dup23: ldc           #8                  &#x2F;&#x2F; String 三妹25: invokespecial #6                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;String.&quot;&lt;init&gt;&quot;:(Ljava&#x2F;lang&#x2F;String;)V28: invokevirtual #7                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;31: invokevirtual #9                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.toString:()Ljava&#x2F;lang&#x2F;String;34: areturn
可以看到 Java 编译器将字符串拼接操作（ + ）转换为了 StringBuilder 对象的 append 方法，然后再调用 StringBuilder 对象的 toString 方法返回拼接后的字符串。
来看一下 StringBuilder 的 toString 方法：
123public String toString() {    return new String(value, 0, count);}
value 是一个 char 类型的数组：
1234&#x2F;** * The value is used for character storage. *&#x2F;char[] value;
在 StringBuilder 对象创建时，会为 value 分配一定的内存空间（初始容量 16），用于存储字符串。
1234567&#x2F;** * Constructs a string builder with no characters in it and an * initial capacity of 16 characters. *&#x2F;public StringBuilder() {    super(16);}
随着字符串的拼接，value 数组的长度会不断增加，因此在 StringBuilder 对象的实现中，value 数组的长度是可以动态扩展的，就像ArrayList那样。
继续来看 StringBuilder 的 toString 方法：
123public String toString() {    return new String(value, 0, count);}
value 用于存储 StringBuilder 对象中包含的字符序列。count 是一个 int 类型的变量，表示字符序列的长度。toString() 方法会调用 new String(value, 0, count) ，使用 value 数组中从 0 开始的前 count 个元素创建一个新的字符串对象，并将其返回。
再来看一下 append 方法：
1234public StringBuilder append(String str) {    super.append(str);    return this;}
实际上是调用了 AbstractStringBuilder 中的 append(String str) 方法。在 AbstractStringBuilder 中，append(String str) 方法会检查当前字符序列中的字符是否够用，如果不够用则会进行扩容，并将指定字符串追加到字符序列的末尾。
123456789101112131415161718192021222324252627&#x2F;** * Appends the specified string to this character sequence. * &lt;p&gt; * The characters of the {@code String} argument are appended, in order, * increasing the length of this sequence by the length of the argument. * If {@code str} is {@code null}, then the four characters {@code &quot;null&quot;} * are appended. * &lt;p&gt; * Let &lt;i&gt;n&lt;&#x2F;i&gt; be the length of this character sequence just prior to * execution of the {@code append} method. Then the character at index * &lt;i&gt;k&lt;&#x2F;i&gt; in this character sequence is equal to the character at index * &lt;i&gt;k&lt;&#x2F;i&gt; in the argument {@code str}, if &lt;i&gt;k&lt;&#x2F;i&gt; is less than * &lt;i&gt;n&lt;&#x2F;i&gt;; otherwise, it is equal to the character at index * &lt;i&gt;k-n&lt;&#x2F;i&gt; in the argument {@code str}. * * @param   str   a string. * @return  a reference to this object. *&#x2F;public AbstractStringBuilder append(String str) {    if (str &#x3D;&#x3D; null)        return appendNull();    int len &#x3D; str.length();    ensureCapacityInternal(count + len);    str.getChars(0, len, value, count);    count +&#x3D; len;    return this;}
append(String str) 方法将指定字符串追加到当前字符序列中。如果指定字符串为 null，则追加字符串 “null”；否则会检查指定字符串的长度，然后根据当前字符序列中的字符数和指定字符串的长度来判断是否需要扩容。
如果需要扩容，则会调用 ensureCapacityInternal(int minimumCapacity)方法进行扩容。扩容之后，将指定字符串的字符拷贝到字符序列中。
来看一下 ensureCapacityInternal 方法：
12345678910111213141516private void ensureCapacityInternal(int minimumCapacity) {    &#x2F;&#x2F; overflow-conscious code    if (minimumCapacity - value.length &gt; 0)        expandCapacity(minimumCapacity);}void expandCapacity(int minimumCapacity) {    int newCapacity &#x3D; value.length * 2 + 2;    if (newCapacity - minimumCapacity &lt; 0)        newCapacity &#x3D; minimumCapacity;    if (newCapacity &lt; 0) {        if (minimumCapacity &lt; 0) &#x2F;&#x2F; overflow            throw new OutOfMemoryError();        newCapacity &#x3D; Integer.MAX_VALUE;    }    value &#x3D; Arrays.copyOf(value, newCapacity);}
ensureCapacityInternal(int minimumCapacity) 方法用于确保当前字符序列的容量至少等于指定的最小容量 minimumCapacity。如果当前容量小于指定的容量，就会为字符序列分配一个新的内部数组。新容量的计算方式如下：

如果指定的最小容量大于当前容量，则新容量为两倍的旧容量加上 2；
如果指定的最小容量小于等于当前容量，则不会进行扩容，直接返回当前对象。

在进行扩容之前， ensureCapacityInternal(int minimumCapacity) 方法会先检查当前字符序列的容量是否足够，如果不足就会调用 expandCapacity(int minimumCapacity) 方法进行扩容。
expandCapacity(int minimumCapacity) 方法首先计算出新容量，然后使用 Arrays.copyOf(char[] original, int newLength) 方法将原字符数组扩容到新容量的大小。
关于扩容，后面在讲ArrayList的时候会再次说明，今天就先聊到这吧。
2.9 String相等判断“如何比较两个字符串相等啊？”
“这个问题看似简单，却在 Stack Overflow 上有超过 370 万+的访问量。”我说，“这个问题也可以引申为 .equals() 和 ‘\&#x3D;&#x3D;’ 操作符有什么区别。”

“\&#x3D;&#x3D;”操作符用于比较两个对象的地址是否相等。
.equals() 方法用于比较两个对象的内容是否相等。

“我来举个不恰当又很恰当的例子，一看你就明白了。”
有一对双胞胎，姐姐叫阿丽塔，妹妹叫洛丽塔。我们普通人可能完全无法分辨谁是姐姐谁是妹妹，可她们的妈妈却可以轻而易举地辨认出。

.equals() 就好像我们普通人，看见阿丽塔以为是洛丽塔，看见洛丽塔以为是阿丽塔，看起来一样就觉得她们是同一个人；“\&#x3D;&#x3D;”操作符就好像她们的妈妈，要求更严格，观察更细致，一眼就能分辨出谁是姐姐谁是妹妹。
1234String alita &#x3D; new String(&quot;小萝莉&quot;);String luolita &#x3D; new String(&quot;小萝莉&quot;);System.out.println(alita.equals(luolita)); &#x2F;&#x2F; trueSystem.out.println(alita &#x3D;&#x3D; luolita); &#x2F;&#x2F; false
就上面这段代码来说， .equals() 输出的结果为 true，而“\&#x3D;&#x3D;”操作符输出的结果为 false——前者要求内容相等就可以，后者要求必须是同一个对象。
“之前已经学过了，Java 的所有类都默认地继承 Object 这个超类，该类有一个名为 .equals() 的方法。”一边说，我一边打开了 Object 类的源码。
123public boolean equals(Object obj) {    return (this &#x3D;&#x3D; obj);}
你看，Object 类的 .equals() 方法默认采用的是“\&#x3D;&#x3D;”操作符进行比较。假如子类没有重写该方法的话，那么“\&#x3D;&#x3D;”操作符和 .equals() 方法的功效就完全一样——比较两个对象的内存地址是否相等。
但实际情况中，有不少类重写了 .equals() 方法，因为比较内存地址的要求比较严格，不太符合现实中所有的场景需求。拿 String 类来说，我们在比较字符串的时候，的确只想判断它们俩的内容是相等的就可以了，并不想比较它们俩是不是同一个对象。
况且，字符串有字符串常量池的概念，本身就推荐使用 String s &#x3D; “字符串” 这种形式来创建字符串对象，而不是通过 new 关键字的方式，因为可以把字符串缓存在字符串常量池中，方便下次使用，不用遇到 new 就在堆上开辟一块新的空间。
“那就来看一下 String 类的 .equals() 方法的源码吧。”
12345678910111213public boolean equals(Object anObject) {    if (this &#x3D;&#x3D; anObject) {        return true;    }    if (anObject instanceof String) {        String aString &#x3D; (String)anObject;        if (coder() &#x3D;&#x3D; aString.coder()) {            return isLatin1() ? StringLatin1.equals(value, aString.value)                    : StringUTF16.equals(value, aString.value);        }    }    return false;}
首先，如果两个字符串对象的可以“\&#x3D;&#x3D;”，那就直接返回 true 了，因为这种情况下，字符串内容是必然相等的。否则就按照字符编码进行比较，分为 UTF16 和 Latin1，差别不是很大，就拿 Latin1 的来说吧。
123456789101112@HotSpotIntrinsicCandidatepublic static boolean equals(byte[] value, byte[] other) {    if (value.length &#x3D;&#x3D; other.length) {        for (int i &#x3D; 0; i &lt; value.length; i++) {            if (value[i] !&#x3D; other[i]) {                return false;            }        }        return true;    }    return false;}
这个 JDK 版本是 Java 17，也就是最新的 LTS（长期支持）版本。该版本中，String 类使用字节数组实现的，所以比较两个字符串的内容是否相等时，可以先比较字节数组的长度是否相等，不相等就直接返回 false；否则就遍历两个字符串的字节数组，只有有一个字节不相等，就返回 false。
这是 Java 8 中的 equals 方法源码：
12345678910111213141516171819202122232425public boolean equals(Object anObject) {    &#x2F;&#x2F; 判断是否为同一对象    if (this &#x3D;&#x3D; anObject) {        return true;    }    &#x2F;&#x2F; 判断对象是否为 String 类型    if (anObject instanceof String) {        String anotherString &#x3D; (String)anObject;        int n &#x3D; value.length;        &#x2F;&#x2F; 判断字符串长度是否相等        if (n &#x3D;&#x3D; anotherString.value.length) {            char v1[] &#x3D; value;            char v2[] &#x3D; anotherString.value;            int i &#x3D; 0;            &#x2F;&#x2F; 判断每个字符是否相等            while (n-- !&#x3D; 0) {                if (v1[i] !&#x3D; v2[i])                    return false;                i++;            }            return true;        }    }    return false;}
JDK 8 比 JDK 17 更容易懂一些：首先判断两个对象是否为同一个对象，如果是，则返回 true。接着，判断对象是否为 String 类型，如果不是，则返回 false。如果对象为 String 类型，则比较两个字符串的长度是否相等，如果长度不相等，则返回 false。如果长度相等，则逐个比较每个字符是否相等，如果都相等，则返回 true，否则返回 false。
“那出几道题考考你吧！”
第一题：
1new String(&quot;小萝莉&quot;).equals(&quot;小萝莉&quot;)
“输出什么呢？”我问。
“ .equals() 比较的是两个字符串对象的内容是否相等，所以结果为 true。”
第二题：
1new String(&quot;小萝莉&quot;) &#x3D;&#x3D; &quot;小萝莉&quot;
“&#x3D;&#x3D;操作符左侧的是在堆中创建的对象，右侧是在字符串常量池中的对象，尽管内容相同，但内存地址不同，所以返回 false。”
第三题：
1new String(&quot;小萝莉&quot;) &#x3D;&#x3D; new String(&quot;小萝莉&quot;)
“new 出来的对象肯定是完全不同的内存地址，所以返回 false。”
第四题：
1&quot;小萝莉&quot; &#x3D;&#x3D; &quot;小萝莉&quot;
“字符串常量池中只会有一个相同内容的对象，所以返回 true。”
第五题：
1&quot;小萝莉&quot; &#x3D;&#x3D; &quot;小&quot; + &quot;萝莉&quot;
“由于‘小’和‘萝莉’都在字符串常量池，所以编译器在遇到‘+’操作符的时候将其自动优化为“小萝莉”，所以返回 true。”
PS：至于为什么，查看这篇String、StringBuilder、StringBuffer
第六题：
1new String(&quot;小萝莉&quot;).intern() &#x3D;&#x3D; &quot;小萝莉&quot;
“ new String(“小萝莉”) 在执行的时候，会先在字符串常量池中创建对象，然后再在堆中创建对象；执行 intern() 方法的时候发现字符串常量池中已经有了‘小萝莉’这个对象，所以就直接返回字符串常量池中的对象引用了，那再与字符串常量池中的‘小萝莉’比较，当然会返回 true 了。”
PS：intern 方法我们之前已经深究过了。
“哥再给你补充一点。”
“如果要进行两个字符串对象的内容比较，除了 .equals() 方法，还有其他两个可选的方案。”
1） Objects.equals()
Objects.equals() 这个静态方法的优势在于不需要在调用之前判空。
123public static boolean equals(Object a, Object b) {    return (a &#x3D;&#x3D; b) || (a !&#x3D; null &amp;&amp; a.equals(b));}
如果直接使用 a.equals(b) ，则需要在调用之前对 a 进行判空，否则可能会抛出空指针 java.lang.NullPointerException 。 Objects.equals() 用起来就完全没有这个担心。
12345Objects.equals(&quot;小萝莉&quot;, new String(&quot;小&quot; + &quot;萝莉&quot;)) &#x2F;&#x2F; --&gt; trueObjects.equals(null, new String(&quot;小&quot; + &quot;萝莉&quot;)); &#x2F;&#x2F; --&gt; falseObjects.equals(null, null) &#x2F;&#x2F; --&gt; trueString a &#x3D; null;a.equals(new String(&quot;小&quot; + &quot;萝莉&quot;)); &#x2F;&#x2F; throw exception
2）String 类的 .contentEquals()
.contentEquals() 的优势在于可以将字符串与任何的字符序列（StringBuffer、StringBuilder、String、CharSequence）进行比较。
12345678910111213141516171819202122232425262728293031323334public boolean contentEquals(CharSequence cs) {    &#x2F;&#x2F; Argument is a StringBuffer, StringBuilder    if (cs instanceof AbstractStringBuilder) {        if (cs instanceof StringBuffer) {            synchronized(cs) {                return nonSyncContentEquals((AbstractStringBuilder)cs);            }        } else {            return nonSyncContentEquals((AbstractStringBuilder)cs);        }    }    &#x2F;&#x2F; Argument is a String    if (cs instanceof String) {        return equals(cs);    }    &#x2F;&#x2F; Argument is a generic CharSequence    int n &#x3D; cs.length();    if (n !&#x3D; length()) {        return false;    }    byte[] val &#x3D; this.value;    if (isLatin1()) {        for (int i &#x3D; 0; i &lt; n; i++) {            if ((val[i] &amp; 0xff) !&#x3D; cs.charAt(i)) {                return false;            }        }    } else {        if (!StringUTF16.contentEquals(val, cs, n)) {            return false;        }    }    return true;}
从源码上可以看得出，如果 cs 是 StringBuffer，该方法还会进行同步，非常的智能化；如果是 String 的话，其实调用的还是 equals() 方法。当然了，这也就意味着使用该方法进行比较的时候，多出来了很多步骤，性能上有些损失。
同样来看一下 JDK 8 的源码：
1234567891011121314151617181920212223242526272829303132public boolean contentEquals(CharSequence cs) {    &#x2F;&#x2F; argument can be any CharSequence implementation    if (cs.length() !&#x3D; value.length) {        return false;    }    &#x2F;&#x2F; Argument is a StringBuffer, StringBuilder or String    if (cs instanceof AbstractStringBuilder) {        char v1[] &#x3D; value;        char v2[] &#x3D; ((AbstractStringBuilder)cs).getValue();        int i &#x3D; 0;        int n &#x3D; value.length;        while (n-- !&#x3D; 0) {            if (v1[i] !&#x3D; v2[i])                return false;            i++;        }        return true;    }    &#x2F;&#x2F; Argument is a String    if (cs.equals(this))        return true;    &#x2F;&#x2F; Argument is a non-String, non-AbstractStringBuilder CharSequence    char v1[] &#x3D; value;    int i &#x3D; 0;    int n &#x3D; value.length;    while (n-- !&#x3D; 0) {        if (v1[i] !&#x3D; cs.charAt(i))            return false;        i++;    }    return true;}
   同样更容易理解一些：首先判断参数长度是否相等，不相等则返回 false。如果参数是 AbstractStringBuilder 的实例，则取出其 char 数组，遍历比较两个 char 数组的每个元素是否相等。如果参数是 String 的实例，则直接调用 equals 方法比较两个字符串是否相等。如果参数是其他实现了 CharSequence 接口的对象，则遍历比较两个对象的每个字符是否相等。    
2.10 String拼接“《Java 开发手册》上有这么一段内容：循环体内，拼接字符串最好使用 StringBuilder 的 append() 方法，而不是 + 号操作符。这是为什么呀？”
“其实这个问题，我们之前已经聊过。”
javap 探究+号操作符拼接字符串的本质 
“+ 号操作符其实被 Java 在编译的时候重新解释了，换一种说法就是，+ 号操作符是一种语法糖，让字符串的拼接变得更简便了。”
1234567class Demo {    public static void main(String[] args) {        String chenmo &#x3D; &quot;沉默&quot;;        String wanger &#x3D; &quot;王二&quot;;        System.out.println(chenmo + wanger);    }}
在 Java 8 的环境下，使用 javap -c Demo.class 反编译字节码后，可以看到以下内容：
12345678910111213141516171819202122232425262728293031Compiled from &quot;Demo.java&quot;class Demo {  Demo();    Code:       0: aload_0       1: invokespecial #1                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V       4: return  public static void main(java.lang.String[]);    Code:       0: ldc           #2                  &#x2F;&#x2F; String 沉默       2: astore_1       3: ldc           #3                  &#x2F;&#x2F; String 王二       5: astore_2       6: getstatic     #4                  &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;       9: new           #5                  &#x2F;&#x2F; class java&#x2F;lang&#x2F;StringBuilder      12: dup      13: invokespecial #6                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.&quot;&lt;init&gt;&quot;:()V      16: aload_1      17: invokevirtual #7                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;      20: aload_2      21: invokevirtual #7                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;      24: invokevirtual #8                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.toString:()Ljava&#x2F;lang&#x2F;String;      27: invokevirtual #9                  &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.println:(Ljava&#x2F;lang&#x2F;String;)V      30: return}
“这里有一个 new 关键字，并且 class 类型为 java&#x2F;lang&#x2F;StringBuilder 。”我指着标号为 9 的那行说，“这意味着新建了一个 StringBuilder 的对象。”
“然后看标号为 17 的这行，是一个 invokevirtual 指令，用于调用对象的方法，也就是 StringBuilder 对象的 append() 方法。”
“也就意味着把 chenmo（”沉默”）这个字符串添加到 StringBuilder 对象中了。”
“再往下看，标号为 21 的这行，又调用了一次 append() 方法，意味着把 wanger（”王二”）这个字符串添加到 StringBuilder 对象中了。”
换成 Java 代码来表示的话，大概是这个样子：
1234567class Demo {    public static void main(String[] args) {        String chenmo &#x3D; &quot;沉默&quot;;        String wanger &#x3D; &quot;王二&quot;;        System.out.println((new StringBuilder(chenmo)).append(wanger).toString());    }}
“哦，原来编译的时候把“+”号操作符替换成了 StringBuilder 的 append() 方法啊。”
“是的，不过到了 Java 9（不是长期支持版本，所以我会拿 Java 11 来演示），情况发生了一些改变，同样的代码，字节码指令完全不同了。”我说。
同样的代码，在 Java 11 的环境下，字节码指令是这样的：
1234567891011121314151617181920212223242526272829303132333435Compiled from &quot;Demo.java&quot;public class com.itwanger.thirtyseven.Demo {  public com.itwanger.thirtyseven.Demo();    Code:       0: aload_0       1: invokespecial #1                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V       4: return  public static void main(java.lang.String[]);    Code:       0: ldc           #2                  &#x2F;&#x2F; String       2: astore_1       3: iconst_0       4: istore_2       5: iload_2       6: bipush        10       8: if_icmpge     41      11: new           #3                  &#x2F;&#x2F; class java&#x2F;lang&#x2F;String      14: dup      15: ldc           #4                  &#x2F;&#x2F; String 沉默      17: invokespecial #5                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;String.&quot;&lt;init&gt;&quot;:(Ljava&#x2F;lang&#x2F;String;)V      20: astore_3      21: ldc           #6                  &#x2F;&#x2F; String 王二      23: astore        4      25: aload_1      26: aload_3      27: aload         4      29: invokedynamic #7,  0              &#x2F;&#x2F; InvokeDynamic #0:makeConcatWithConstants:(Ljava&#x2F;lang&#x2F;String;Ljava&#x2F;lang&#x2F;String;Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;String;      34: astore_1      35: iinc          2, 1      38: goto          5      41: return}
看标号为 29 的这行，字节码指令为 invokedynamic ，该指令允许由应用级的代码来决定方法解析，所谓的应用级的代码其实是一个方法——被称为引导方法（Bootstrap Method），简称 BSM，BSM 会返回一个 CallSite（调用点） 对象，这个对象就和 invokedynamic 指令链接在一起。以后再执行这条 invokedynamic 指令时就不会创建新的 CallSite 对象。CallSite 其实就是一个 MethodHandle（方法句柄）的 holder，指向一个调用点真正执行的方法——此时就是 StringConcatFactory.makeConcatWithConstants() 方法。
“好吧，总之就是 Java 9 以后，JDK 用了另外一种方法来动态解释 + 号操作符，具体的实现方式在字节码指令层面已经看不到了，所以我就以 Java 8 来继续讲解吧。”
为什么要编译为 StringBuilder.append 
“再回到《Java 开发手册》上的那段内容：循环体内，拼接字符串最好使用 StringBuilder 的 append() 方法，而不是 + 号操作符。原因就在于循环体内如果用 + 号操作符的话，就会产生大量的 StringBuilder 对象，不仅占用了更多的内存空间，还会让 Java 虚拟机不停的进行垃圾回收，从而降低了程序的性能。”
更好的写法就是在循环的外部新建一个 StringBuilder 对象，然后使用 append() 方法将循环体内的字符串添加进来：
123456789101112class Demo {    public static void main(String[] args) {        StringBuilder sb &#x3D; new StringBuilder();        for (int i &#x3D; 1; i &lt; 10; i++) {            String chenmo &#x3D; &quot;沉默&quot;;            String wanger &#x3D; &quot;王二&quot;;            sb.append(chenmo);            sb.append(wanger);        }        System.out.println(sb);    }}
来做个小测试。
第一个，for 循环中使用”+”号操作符。
1234String result &#x3D; &quot;&quot;;for (int i &#x3D; 0; i &lt; 100000; i++) {    result +&#x3D; &quot;六六六&quot;;}
第二个，for 循环外部新建 StringBuilder，循环体内使用 append() 方法。
1234StringBuilder sb &#x3D; new StringBuilder();for (int i &#x3D; 0; i &lt; 100000; i++) {    sb.append(&quot;六六六&quot;);}
“这两个小测试分别会耗时多长时间呢？”
“哇，第一个小测试的执行时间是 6212 毫秒，第二个只用了不到 1 毫秒，差距也太大了吧！”
“是的，这下明白了原因吧？”我说。
append方法源码解析 
“好了，来看一下 StringBuilder 类的 append() 方法的源码吧！”
1234public StringBuilder append(String str) {    super.append(str);    return this;}
这 3 行代码其实没啥看的。我们来看父类 AbstractStringBuilder 的 append() 方法：
123456789public AbstractStringBuilder append(String str) {    if (str &#x3D;&#x3D; null)        return appendNull();    int len &#x3D; str.length();    ensureCapacityInternal(count + len);    str.getChars(0, len, value, count);    count +&#x3D; len;    return this;}
1）判断拼接的字符串是不是 null，如果是，当做字符串“null”来处理。 appendNull() 方法的源码如下：
1234567891011private AbstractStringBuilder appendNull() {    int c &#x3D; count;    ensureCapacityInternal(c + 4);    final char[] value &#x3D; this.value;    value[c++] &#x3D; &#39;n&#39;;    value[c++] &#x3D; &#39;u&#39;;    value[c++] &#x3D; &#39;l&#39;;    value[c++] &#x3D; &#39;l&#39;;    count &#x3D; c;    return this;}
2）获取字符串的长度。
3） ensureCapacityInternal() 方法的源码如下：
1234567private void ensureCapacityInternal(int minimumCapacity) {    &#x2F;&#x2F; overflow-conscious code    if (minimumCapacity - value.length &gt; 0) {        value &#x3D; Arrays.copyOf(value,                newCapacity(minimumCapacity));    }}
由于字符串内部是用数组实现的，所以需要先判断拼接后的字符数组长度是否超过当前数组的长度，如果超过，先对数组进行扩容，然后把原有的值复制到新的数组中。
 4）将拼接的字符串 str 复制到目标数组 value 中。
1str.getChars(0, len, value, count)
5）更新数组的长度 count。
String.concat 拼接字符串 
“除了可以使用 + 号操作符，StringBuilder 的 append() 方法，还有其他的字符串拼接方法吗？”
“有啊，比如说 String 类的 concat() 方法，有点像 StringBuilder 类的 append() 方法。”
123String chenmo &#x3D; &quot;沉默&quot;;String wanger &#x3D; &quot;王二&quot;;System.out.println(chenmo.concat(wanger));
可以来看一下 concat() 方法的源码。
12345678910public String concat(String str) {    int otherLen &#x3D; str.length();    if (otherLen &#x3D;&#x3D; 0) {        return this;    }    int len &#x3D; value.length;    char buf[] &#x3D; Arrays.copyOf(value, len + otherLen);    str.getChars(buf, len);    return new String(buf, true);}
1）如果拼接的字符串的长度为 0，那么返回拼接前的字符串。
2）将原字符串的字符数组 value 复制到变量 buf 数组中。
3）把拼接的字符串 str 复制到字符数组 buf 中，并返回新的字符串对象。
我一行一行地解释着。
“和 + 号操作符相比， concat() 方法在遇到字符串为 null 的时候，会抛出 NullPointerException，而“+”号操作符会把 null 当做是“null”字符串来处理。”
如果拼接的字符串非常多， concat() 的效率就会下降，因为创建的字符串对象越来越多。
“还有吗？”
“有，当然有。”
String.join 拼接字符串 
String 类有一个静态方法 join() ，可以这样来使用。
1234String chenmo &#x3D; &quot;沉默&quot;;String wanger &#x3D; &quot;王二&quot;;String cmower &#x3D; String.join(&quot;&quot;, chenmo, wanger);System.out.println(cmower);
第一个参数为字符串连接符，比如说：
1String message &#x3D; String.join(&quot;-&quot;, &quot;王二&quot;, &quot;太特么&quot;, &quot;有趣了&quot;);
输出结果为：王二-太特么-有趣了 。
来看一下 join 方法的源码：
12345678910public static String join(CharSequence delimiter, CharSequence... elements) {    Objects.requireNonNull(delimiter);    Objects.requireNonNull(elements);    &#x2F;&#x2F; Number of elements not likely worth Arrays.stream overhead.    StringJoiner joiner &#x3D; new StringJoiner(delimiter);    for (CharSequence cs: elements) {        joiner.add(cs);    }    return joiner.toString();}
里面新建了一个叫 StringJoiner 的对象，然后通过 for-each 循环把可变参数添加了进来，最后调用 toString() 方法返回 String。
StringUtils.join 拼接字符串 
“实际的工作中， org.apache.commons.lang3.StringUtils 的 join() 方法也经常用来进行字符串拼接。”
123String chenmo &#x3D; &quot;沉默&quot;;String wanger &#x3D; &quot;王二&quot;;StringUtils.join(chenmo, wanger);
该方法不用担心 NullPointerException。
12345StringUtils.join(null)            &#x3D; nullStringUtils.join([])              &#x3D; &quot;&quot;StringUtils.join([null])          &#x3D; &quot;&quot;StringUtils.join([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]) &#x3D; &quot;abc&quot;StringUtils.join([null, &quot;&quot;, &quot;a&quot;]) &#x3D; &quot;a&quot;
来看一下源码：
12345678910111213141516171819public static String join(final Object[] array, String separator, final int startIndex, final int endIndex) {    if (array &#x3D;&#x3D; null) {        return null;    }    if (separator &#x3D;&#x3D; null) {        separator &#x3D; EMPTY;    }    final StringBuilder buf &#x3D; new StringBuilder(noOfItems * 16);    for (int i &#x3D; startIndex; i &lt; endIndex; i++) {        if (i &gt; startIndex) {            buf.append(separator);        }        if (array[i] !&#x3D; null) {            buf.append(array[i]);        }    }    return buf.toString();}
内部使用的仍然是 StringBuilder。
“好了，关于字符串拼接的知识点我们就讲到这吧。注意 Java 9 以后，对 + 号操作符的解释和之前发生了变化，字节码指令已经不同了，等后面你学了字节码指令后我们再详细地讲一次。”
2.11 String拆分“哥，我感觉字符串拆分没什么可讲的呀，直接上 String 类的 split() 方法不就可以了！”三妹毫不客气地说。
“假如你真的这么觉得，那可要注意了，事情远没这么简单。”我微笑着说。
假如现在有这样一串字符序列“沉默王二，一枚有趣的程序员”，需要按照中文逗号“，”进行拆分，这意味着第一串字符序列为逗号前面的“沉默王二”，第二串字符序列为逗号后面的“一枚有趣的程序员”。
“这不等于没说吗？哥！”还没等我说，三妹就打断了我。
“别着急嘛，等哥说完。”我依然保持着微笑继续说，“在拆分之前，要先进行检查，判断一下这串字符是否包含逗号，否则应该抛出异常。”
1234567891011public class Test {    public static void main(String[] args) {        String cmower &#x3D; &quot;沉默王二，一枚有趣的程序员&quot;;        if (cmower.contains(&quot;，&quot;)) {            String [] parts &#x3D; cmower.split(&quot;，&quot;);            System.out.println(&quot;第一部分：&quot; + parts[0] +&quot; 第二部分：&quot; + parts[1]);        } else {            throw new IllegalArgumentException(&quot;当前字符串没有包含逗号&quot;);        }    }}
“三妹你看，这段代码挺严谨的吧？”我说，“来看一下程序的输出结果。”
1第一部分：沉默王二 第二部分：一枚有趣的程序员
“的确和预期完全一致。”三妹说。
“这是建立在字符串是确定的情况下，最重要的是分隔符是确定的。否则，麻烦就来了。”我说，“大约有 12 种英文特殊符号，如果直接拿这些特殊符号替换上面代码中的分隔符（中文逗号），这段程序在运行的时候就会出现以下提到的错误。”

反斜杠 \ （ArrayIndexOutOfBoundsException）
插入符号 ^ （同上）
美元符号 $ （同上）
逗点 . （同上）
竖线 | （正常，没有出错）
问号 ? （PatternSyntaxException）
星号 * （同上）
加号 + （同上）
左小括号或者右小括号 () （同上）
左方括号或者右方括号 [] （同上）
左大括号或者右大括号 {} （同上）

“那遇到这些特殊符号该怎么办呢？”三妹问。
“用正则表达式。”我说，“正则表达式是一组由字母和符号组成的特殊文本，它可以用来从文本中找出满足你想要的格式的句子。”
我在 GitHub 上找打了一个开源的正则表达式学习文档，非常详细。一开始写正则表达式的时候难免会感觉到非常生疏，你可以查看一下这份文档。记不住没关系，遇到就查。

https:&#x2F;&#x2F;github.com&#x2F;cdoco&#x2F;learn-regex-zh

除了这份文档，还有一份：

https:&#x2F;&#x2F;github.com&#x2F;cdoco&#x2F;common-regex

作者收集了一些在平时项目开发中经常用到的正则表达式，可以直接拿来用。
“哥，你真周到。”三妹笑着说。
“好了，来用英文逗点 . 替换一下分隔符。”我说。
12345String cmower &#x3D; &quot;沉默王二.一枚有趣的程序员&quot;;if (cmower.contains(&quot;.&quot;)) {    String [] parts &#x3D; cmower.split(&quot;\\.&quot;);    System.out.println(&quot;第一部分：&quot; + parts[0] +&quot; 第二部分：&quot; + parts[1]);}
由于英文逗点属于特殊符号，所以在使用 split() 方法的时候，就需要使用正则表达式 \. 而不能直接使用 . 。
“为什么用两个反斜杠呢？”三妹问。
“因为反斜杠本身就是一个特殊字符，需要用反斜杠来转义。”我说。
当然了，你也可以使用 [] 来包裹住英文逗点“.”， [] 也是一个正则表达式，用来匹配方括号中包含的任意字符。
1cmower.split(&quot;[.]&quot;);
除此之外， 还可以使用 Pattern 类的 quote() 方法来包裹英文逗点“.”，该方法会返回一个使用 \Q\E 包裹的字符串。

来看示例：
1String [] parts &#x3D; cmower.split(Pattern.quote(&quot;.&quot;));
当 split() 方法的参数是正则表达式的时候，方法最终会执行下面这行代码：
1return Pattern.compile(regex).split(this, limit);
也就意味着，拆分字符串有了新的选择，可以不使用 String 类的 split() 方法，直接用下面的方式。
1234567public class TestPatternSplit {    private static Pattern twopart &#x3D; Pattern.compile(&quot;\\.&quot;);    public static void main(String[] args) {        String [] parts &#x3D; twopart.split(&quot;沉默王二.一枚有趣的程序员&quot;);        System.out.println(&quot;第一部分：&quot; + parts[0] +&quot; 第二部分：&quot; + parts[1]);    }}
“为什么要把 Pattern 表达式声明称 static 的呢？”三妹问。
“由于模式是确定的，通过 static 的预编译功能可以提高程序的效率。”我说，“除此之外，还可以使用 Pattern 配合 Matcher 类进行字符串拆分，这样做的好处是可以对要拆分的字符串进行一些严格的限制，来看这段示例代码。”
12345678910111213141516171819public class TestPatternMatch {    &#x2F;**     * 使用预编译功能，提高效率     *&#x2F;    private static Pattern twopart &#x3D; Pattern.compile(&quot;(.+)\\.(.+)&quot;);    public static void main(String[] args) {        checkString(&quot;沉默王二.一枚有趣的程序员&quot;);        checkString(&quot;沉默王二.&quot;);        checkString(&quot;.一枚有趣的程序员&quot;);    }    private static void checkString(String str) {        Matcher m &#x3D; twopart.matcher(str);        if (m.matches()) {            System.out.println(&quot;第一部分：&quot; + m.group(1) + &quot; 第二部分：&quot; + m.group(2));        } else {            System.out.println(&quot;不匹配&quot;);        }    }}
正则表达式 (.+)\.(.+) 的意思是，不仅要把字符串按照英文标点的方式拆成两部分，并且英文逗点的前后要有内容。
来看一下程序的输出结果：
123第一部分：沉默王二 第二部分：一枚有趣的程序员不匹配不匹配
不过，使用 Matcher 来匹配一些简单的字符串时相对比较沉重一些，使用 String 类的 split() 仍然是首选，因为该方法还有其他一些牛逼的功能。比如说，如果你想把分隔符包裹在拆分后的字符串的第一部分，可以这样做：
12345String cmower &#x3D; &quot;沉默王二，一枚有趣的程序员&quot;;if (cmower.contains(&quot;，&quot;)) {    String [] parts &#x3D; cmower.split(&quot;(?&lt;&#x3D;，)&quot;);    System.out.println(&quot;第一部分：&quot; + parts[0] +&quot; 第二部分：&quot; + parts[1]);}
程序输出的结果如下所示：
1第一部分：沉默王二， 第二部分：一枚有趣的程序员
可以看到分隔符“，”包裹在了第一部分，如果希望包裹在第二部分，可以这样做：
1String [] parts &#x3D; cmower.split(&quot;(?&#x3D;，)&quot;);
“ ?&lt;&#x3D; 和 ?&#x3D; 是什么东东啊？”三妹好奇地问。
“它其实是正则表达式中的断言模式。”我说，“你有时间的话，可以看看前面我推荐的两份开源文档。”

“ split() 方法可以传递 2 个参数，第一个为分隔符，第二个为拆分的字符串个数。”我说。
12345String cmower &#x3D; &quot;沉默王二，一枚有趣的程序员，宠爱他&quot;;if (cmower.contains(&quot;，&quot;)) {    String [] parts &#x3D; cmower.split(&quot;，&quot;, 2);    System.out.println(&quot;第一部分：&quot; + parts[0] +&quot; 第二部分：&quot; + parts[1]);}
进入 debug 模式的话，可以看到以下内容：

也就是说，传递 2 个参数的时候，会直接调用 substring() 进行截取，第二个分隔符后的就不再拆分了。
来看一下程序输出的结果：
1第一部分：沉默王二 第二部分：一枚有趣的程序员，宠爱他
“没想到啊，这个字符串拆分还挺讲究的呀！”三妹感慨地说。
“是的，其实字符串拆分在实际的工作当中还是挺经常用的。前端经常会按照规则传递一长串字符序列到后端，后端就需要按照规则把字符串拆分再做处理。”我说。
</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-Java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">1.3 Java数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-Java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">1.4 Java数据类型转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-Java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%BC%93%E5%AD%98%E6%B1%A0"><span class="toc-text">1.5 Java基本数据类型缓存池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-Java%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">1.6 Java运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7-Java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="toc-text">1.7 Java流程控制语句</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E6%95%B0%E7%BB%84-amp-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">2 数组&amp;字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E6%8E%8C%E6%8F%A1Java%E6%95%B0%E7%BB%84"><span class="toc-text">2.1 掌握Java数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E6%8E%8C%E6%8F%A1Java%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-text">2.2 掌握Java二维数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E6%89%93%E5%8D%B0Java%E6%95%B0%E7%BB%84"><span class="toc-text">2.3 打印Java数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-String%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%8F%AF%E5%8F%98"><span class="toc-text">2.5 String为什么不可变</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-%E8%AF%A6%E8%A7%A3-String-intern-%E6%96%B9%E6%B3%95"><span class="toc-text">2.7 详解 String.intern() 方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-8-String%E3%80%81StringBuilder%E3%80%81StringBuffer"><span class="toc-text">2.8 String、StringBuilder、StringBuffer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-9-String%E7%9B%B8%E7%AD%89%E5%88%A4%E6%96%AD"><span class="toc-text">2.9 String相等判断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-10-String%E6%8B%BC%E6%8E%A5"><span class="toc-text">2.10 String拼接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-11-String%E6%8B%86%E5%88%86"><span class="toc-text">2.11 String拆分</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 By 鲸落</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">I wish you to become your own sun, no need to rely on who's light.</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async src="https://cdn1.tianli0.top/npm/vue@2.6.14/dist/vue.min.js"></script><script async src="https://cdn1.tianli0.top/npm/element-ui@2.15.6/lib/index.js"></script><script async src="https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script><script defer type="text/javascript" src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script defer src="https://cdn1.tianli0.top/gh/nextapps-de/winbox/dist/winbox.bundle.min.js"></script><script async src="//at.alicdn.com/t/c/font_4233300_xxm4hpxio1.js"></script><script async src="/js/fps.js"></script><script async src="https://cdn.wpon.cn/2022-sucai/Gold-ingot.js"></script><script defer data-pjax src="/js/cat.js"></script><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><canvas id="snow"></canvas><script defer src="/js/fomal.js"></script><script defer src="/js/cursor.js"></script><script defer src="/live2d-widget/autoload.js"></script><script async src="/js/title.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 190px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 160px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(http://p0.itc.cn/images03/20200525/332e1ea10c634cbfaf0dfc5b69d00a3c.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Docker/&quot;);" href="javascript:void(0);">Docker</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr">Docker</span></li><li class="categoryBar-list-item" style="background:url(http://p8.itc.cn/images03/20200525/377f4f7044fe49b0bb932f43ef4f4891.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Hexo魔改教程/&quot;);" href="javascript:void(0);">Hexo魔改教程</a><span class="categoryBar-list-count">12</span><span class="categoryBar-list-descr">Hexo魔改教程</span></li><li class="categoryBar-list-item" style="background:url(http://p8.itc.cn/images03/20200525/0ed549edde2c4d5eaecc2824e753ca74.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/面试题/&quot;);" href="javascript:void(0);">面试题</a><span class="categoryBar-list-count">10</span><span class="categoryBar-list-descr">MySQL</span></li><li class="categoryBar-list-item" style="background:url(http://p6.itc.cn/images03/20200525/8dedcdf6ace44a50a1deb6a9743821fe.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/面渣笔记/&quot;);" href="javascript:void(0);">面渣笔记</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">面试题</span></li><li class="categoryBar-list-item" style="background:url(http://p8.itc.cn/images03/20200525/5f6cecf10ea04dec9a5d42bf9c4c3739.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/MySQL/&quot;);" href="javascript:void(0);">MySQL</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr">Redis</span></li><li class="categoryBar-list-item" style="background:url(http://p0.itc.cn/images03/20200525/332e1ea10c634cbfaf0dfc5b69d00a3c.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/RabbitMQ/&quot;);" href="javascript:void(0);">RabbitMQ</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr">Java笔试编程真题</span></li><li class="categoryBar-list-item" style="background:url(http://p8.itc.cn/images03/20200525/377f4f7044fe49b0bb932f43ef4f4891.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Redis/&quot;);" href="javascript:void(0);">Redis</a><span class="categoryBar-list-count">5</span><span class="categoryBar-list-descr">Java数据结构与算法</span></li><li class="categoryBar-list-item" style="background:url(http://p8.itc.cn/images03/20200525/0ed549edde2c4d5eaecc2824e753ca74.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Kafka/&quot;);" href="javascript:void(0);">Kafka</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(http://p6.itc.cn/images03/20200525/8dedcdf6ace44a50a1deb6a9743821fe.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Java笔试编程真题/&quot;);" href="javascript:void(0);">Java笔试编程真题</a><span class="categoryBar-list-count">44</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/面试/&quot;);" href="javascript:void(0);">面试</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/设计模式/&quot;);" href="javascript:void(0);">设计模式</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Java数据结构与算法/&quot;);" href="javascript:void(0);">Java数据结构与算法</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var qweather_key = 'b16a1fa0e63c46a4b8f28abfb06ae3fe';
  var gaud_map_key = 'e2b04289e870b005374ee030148d64fd&s=rsv3';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '113.34532,23.15624';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v6.2.0" title=""><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.9.0" title=""><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="https://npm.elemecdn.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.js"></script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/1b4308aa.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-17</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/1b4308aa.html&quot;);" href="javascript:void(0);" alt="">美团校招笔试编程真题（2023.4.8）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/1b4308aa.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/a449f40d.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-22</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/a449f40d.html&quot;);" href="javascript:void(0);" alt="">美的校招笔试编程真题（2023.4.19）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/a449f40d.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/b2891dfd.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-14</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/b2891dfd.html&quot;);" href="javascript:void(0);" alt="">美团校招笔试编程真题（2023.3.11）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/b2891dfd.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/7b50e04c.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/7b50e04c.html&quot;);" href="javascript:void(0);" alt="">美团校招笔试编程真题（2023.5.13）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/7b50e04c.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/f53a714c.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/f53a714c.html&quot;);" href="javascript:void(0);" alt="">美团校招笔试编程真题（2023.4.29）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/f53a714c.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/9a879128.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/9a879128.html&quot;);" href="javascript:void(0);" alt="">美团校招笔试编程真题（2023.4.23）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/9a879128.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/f84cb424.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-17</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/f84cb424.html&quot;);" href="javascript:void(0);" alt="">美团校招笔试编程真题（2023.4.15）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/f84cb424.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/cf815277.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-15</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/cf815277.html&quot;);" href="javascript:void(0);" alt="">美团校招笔试编程真题（2023.3.18）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/cf815277.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/843d6f38.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/843d6f38.html&quot;);" href="javascript:void(0);" alt="">美团校招笔试编程真题及其解析（2023.3.4）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/843d6f38.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/7a556a2f.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-14</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/7a556a2f.html&quot;);" href="javascript:void(0);" alt="">美团2024届秋招笔试编程真题（2023.9.9）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/7a556a2f.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/f51f72fb.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-06</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/f51f72fb.html&quot;);" href="javascript:void(0);" alt="">美团2024届秋招笔试第二场编程真题（2023.8.19）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/f51f72fb.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/6482affa.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/6482affa.html&quot;);" href="javascript:void(0);" alt="">美团校招笔试编程真题及其解析（2023.3.25）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/6482affa.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/61f68248.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/61f68248.html&quot;);" href="javascript:void(0);" alt="">美团2024届秋招笔试第四场编程真题（2023.9.2）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/61f68248.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/5b7a3f2a.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-07</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/5b7a3f2a.html&quot;);" href="javascript:void(0);" alt="">美团2024届秋招笔试第三场编程真题（2023.8.26）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/5b7a3f2a.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/860131f4.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-04</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/860131f4.html&quot;);" href="javascript:void(0);" alt="">美团2024届秋招笔试第一场编程真题（2023.8.12）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/860131f4.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/f766fbc2.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/f766fbc2.html&quot;);" href="javascript:void(0);" alt="">科大讯飞校招笔试编程真题（2023.8.31）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/f766fbc2.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/6da30861.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/6da30861.html&quot;);" href="javascript:void(0);" alt="">科大讯飞校招笔试编程真题（2023.7.8）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/6da30861.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/f9fa8a74.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/f9fa8a74.html&quot;);" href="javascript:void(0);" alt="">科大讯飞校招笔试编程真题（2023.7.29）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/f9fa8a74.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/10ab47eb.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/10ab47eb.html&quot;);" href="javascript:void(0);" alt="">科大讯飞校招笔试编程真题（2023.7.1）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/10ab47eb.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/7641fb6a.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/7641fb6a.html&quot;);" href="javascript:void(0);" alt="">科大讯飞校招笔试编程真题（2022.10.14）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/7641fb6a.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2efb0d75.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2efb0d75.html&quot;);" href="javascript:void(0);" alt="">科大讯飞校招笔试编程真题（2023.7.22）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2efb0d75.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/815405c2.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/815405c2.html&quot;);" href="javascript:void(0);" alt="">科大讯飞校招笔试编程真题及其解析（2023.8.13）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/815405c2.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/52772af7.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/52772af7.html&quot;);" href="javascript:void(0);" alt="">科大讯飞校招笔试编程真题及其解析（2023.7.15）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/52772af7.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/a135cfaa.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/a135cfaa.html&quot;);" href="javascript:void(0);" alt="">携程校招笔试编程真题及其解析（2023.9.7）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/a135cfaa.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/c442a03f.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-26</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/c442a03f.html&quot;);" href="javascript:void(0);" alt="">携程校招笔试编程真题及其解析（2023.5.4）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/c442a03f.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/b264b8b5.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-26</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/b264b8b5.html&quot;);" href="javascript:void(0);" alt="">携程校招笔试编程真题及其解析（2023.9.21）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/b264b8b5.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/1b7134f2.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/1b7134f2.html&quot;);" href="javascript:void(0);" alt="">携程校招笔试编程真题及其解析（2023.4.15）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/1b7134f2.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/faa64596.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/faa64596.html&quot;);" href="javascript:void(0);" alt="">携程校招笔试编程真题及其解析（2023.5.25）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/faa64596.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/aeeccc.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/aeeccc.html&quot;);" href="javascript:void(0);" alt="">携程校招笔试编程真题及其解析（2023.3.7）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/aeeccc.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/d3a0cf14.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-26</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/d3a0cf14.html&quot;);" href="javascript:void(0);" alt="">携程校招笔试编程真题及其解析（2023.3.29）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/d3a0cf14.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/cc63a592.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/cc63a592.html&quot;);" href="javascript:void(0);" alt="">携程校招笔试编程真题及其解析（2023.3.16）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/cc63a592.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2ec06a90.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-23</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2ec06a90.html&quot;);" href="javascript:void(0);" alt="">恒生电子校招笔试编程真题（2023.9.22）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2ec06a90.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/acdf6806.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-27</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/acdf6806.html&quot;);" href="javascript:void(0);" alt="">微众银行校招笔试编程真题及其解析（2023.9.3）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/acdf6806.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/7520a94a.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-27</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/7520a94a.html&quot;);" href="javascript:void(0);" alt="">微众银行校招笔试编程真题及其解析（2023.9.13）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/7520a94a.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/ac4bafef.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-27</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/ac4bafef.html&quot;);" href="javascript:void(0);" alt="">微众银行校招笔试编程真题及其解析（2023.4.12）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/ac4bafef.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/5357b25a.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-27</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/5357b25a.html&quot;);" href="javascript:void(0);" alt="">微众银行校招笔试编程真题及其解析（2023.4.23）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/5357b25a.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/bad939ec.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-22</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/bad939ec.html&quot;);" href="javascript:void(0);" alt="">小红书校招笔试编程真题（2023.8.6）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/bad939ec.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/92b4cb69.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-22</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/92b4cb69.html&quot;);" href="javascript:void(0);" alt="">小红书校招笔试编程真题（2023.8.19）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/92b4cb69.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/4ce12134.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-22</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/4ce12134.html&quot;);" href="javascript:void(0);" alt="">小红书校招笔试编程真题（2023.7.23）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/4ce12134.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/befb4d57.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-22</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/befb4d57.html&quot;);" href="javascript:void(0);" alt="">小红书校招笔试编程真题（2023.5.7）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/befb4d57.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/7d093ba9.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-22</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/7d093ba9.html&quot;);" href="javascript:void(0);" alt="">小红书校招笔试编程真题（2023.4.23）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/7d093ba9.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/9578e9c1.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-22</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/9578e9c1.html&quot;);" href="javascript:void(0);" alt="">小红书校招笔试编程真题（2023.4.9）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/9578e9c1.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/8f70f515.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-22</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/8f70f515.html&quot;);" href="javascript:void(0);" alt="">小红书校招笔试编程真题（2023.3.26）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/8f70f515.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/7ec90956.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/7ec90956.html&quot;);" href="javascript:void(0);" alt="">Java进阶之路</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/7ec90956.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/3cbc845.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/3cbc845.html&quot;);" href="javascript:void(0);" alt="">Java数据结构与算法</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/3cbc845.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/f9c52cbb.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-19</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/f9c52cbb.html&quot;);" href="javascript:void(0);" alt="">设计模式面试篇-参考回答</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/f9c52cbb.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/eabb6106.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-12</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/eabb6106.html&quot;);" href="javascript:void(0);" alt="">消息中间件面试题-参考回答</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/eabb6106.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/27f853cc.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/27f853cc.html&quot;);" href="javascript:void(0);" alt="">框架篇面试题-参考回答</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/27f853cc.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/6ba374e2.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/6ba374e2.html&quot;);" href="javascript:void(0);" alt="">微服务面试篇-参考回答</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/6ba374e2.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/dbf9d5c9.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/dbf9d5c9.html&quot;);" href="javascript:void(0);" alt="">常见技术场景</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/dbf9d5c9.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/af15ea36.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/af15ea36.html&quot;);" href="javascript:void(0);" alt="">多线程相关面试题</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/af15ea36.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/258353ca.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/258353ca.html&quot;);" href="javascript:void(0);" alt="">kafka深入浅出，快速玩转分布式发布订阅消息系统</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/258353ca.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/6f83b1e4.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/6f83b1e4.html&quot;);" href="javascript:void(0);" alt="">Redis面试题-参考回答</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/6f83b1e4.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/37cf2cfd.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/37cf2cfd.html&quot;);" href="javascript:void(0);" alt="">Redis集群</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/37cf2cfd.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/d2ba1e3f.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/d2ba1e3f.html&quot;);" href="javascript:void(0);" alt="">Redis原理篇</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/d2ba1e3f.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/6bb2589.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-12</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/6bb2589.html&quot;);" href="javascript:void(0);" alt="">Rabbitmq消息中间件（二）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/6bb2589.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/18ab1f25.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/18ab1f25.html&quot;);" href="javascript:void(0);" alt="">MySQL面试篇-参考回答</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/18ab1f25.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/6bb2589.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-12</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/6bb2589.html&quot;);" href="javascript:void(0);" alt="">Rabbitmq消息中间件（一）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/6bb2589.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/337fcc87.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/337fcc87.html&quot;);" href="javascript:void(0);" alt="">MySQL基础篇</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/337fcc87.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/11f76754.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/11f76754.html&quot;);" href="javascript:void(0);" alt="">MySQL进阶篇</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/11f76754.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/592cf81.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/592cf81.html&quot;);" href="javascript:void(0);" alt="">MySQL运维篇</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/592cf81.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/b481a8d6.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/b481a8d6.html&quot;);" href="javascript:void(0);" alt="">Java集合相关面试题</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/b481a8d6.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/c218eb30.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/c218eb30.html&quot;);" href="javascript:void(0);" alt="">JVM相关面试题</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/c218eb30.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/be6d66dc.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/be6d66dc.html&quot;);" href="javascript:void(0);" alt="">Docker安装Canal</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/be6d66dc.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/7eb663f5.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/7eb663f5.html&quot;);" href="javascript:void(0);" alt="">Docker安装OpenResty</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/7eb663f5.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/a6573b44.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/a6573b44.html&quot;);" href="javascript:void(0);" alt="">Centos7安装Docker</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/a6573b44.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/d3404069.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/d3404069.html&quot;);" href="javascript:void(0);" alt="">Redis高级篇</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/d3404069.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/a6b15897.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/a6b15897.html&quot;);" href="javascript:void(0);" alt="">Redis实战篇</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/a6b15897.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/4604f75b.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-01</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/4604f75b.html&quot;);" href="javascript:void(0);" alt="">Redis基础篇</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/4604f75b.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '1s');
    arr[i].setAttribute('data-wow-offset', '100');
    arr[i].setAttribute('data-wow-iteration', '2');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --></body></html>