<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java进阶之路 | 鲸落</title><meta name="author" content="鲸落"><meta name="copyright" content="鲸落"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1 Java语法基础1.1 Java关键字和保留字1、abstract： 用于声明抽象类，以及抽象方法。 1234567891011abstract class Animal &amp;#123;    abstract void makeSound();    public void sleep() &amp;#123;        System.out.println(&quot;The animal is">
<meta property="og:type" content="article">
<meta property="og:title" content="Java进阶之路">
<meta property="og:url" content="https://htx-rest.github.io/posts/7ec90956.html">
<meta property="og:site_name" content="鲸落">
<meta property="og:description" content="1 Java语法基础1.1 Java关键字和保留字1、abstract： 用于声明抽象类，以及抽象方法。 1234567891011abstract class Animal &amp;#123;    abstract void makeSound();    public void sleep() &amp;#123;        System.out.println(&quot;The animal is">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img0.baidu.com/it/u=4155835667,974645702&fm=253&fmt=auto&app=138&f=PNG?w=889&h=500">
<meta property="article:published_time" content="2023-09-25T02:08:49.000Z">
<meta property="article:modified_time" content="2023-10-13T11:32:58.918Z">
<meta property="article:author" content="鲸落">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="面试">
<meta property="article:tag" content="基础知识">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img0.baidu.com/it/u=4155835667,974645702&fm=253&fmt=auto&app=138&f=PNG?w=889&h=500"><link rel="shortcut icon" href="/"><link rel="canonical" href="https://htx-rest.github.io/posts/7ec90956.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java进阶之路',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-10-13 19:32:58'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_4233300_xxm4hpxio1.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/element-ui@2.15.6/packages/theme-chalk/lib/index.css"><script src="https://npm.elemecdn.com/echarts@4.9.0/dist/echarts.min.js"></script><style id="themeColor"></style><style id="rightSide"></style><style id="transPercent"></style><style id="blurNum"></style><style id="settingStyle"></style><span id="fps"></span><style id="defineBg"></style><style id="menu_shadow"></style><div id="myscoll"></div><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://tuchuang.voooe.cn/images/2023/01/02/avatar.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">92</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">125</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-youhuawenzhang"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-guidang"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei"></i><span> 分类</span></a></li><li><a class="site-page child" href="javascript:randomPost();"><i class="fa-fw iconfont icon-wode-zuji-copy"></i><span> 随便逛逛</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-xiuxianyinpin"></i><span> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/life/music/"><i class="fa-fw iconfont icon-tool"></i><span> 八音盒</span></a></li><li><a class="site-page child" href="/life/movies/"><i class="fa-fw iconfont icon-dianying"></i><span> 影院</span></a></li><li><a class="site-page child" href="/life/games/"><i class="fa-fw iconfont icon-youxi"></i><span> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-baoxiang21"></i><span> 八宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/box/gallery/"><i class="fa-fw iconfont icon-hualang"></i><span> 画廊</span></a></li><li><a class="site-page child" href="/box/animation/"><i class="fa-fw iconfont icon-donghua"></i><span> 动画</span></a></li><li><a class="site-page child" href="/box/nav/"><i class="fa-fw iconfont icon-a-06-wangzhidaohang"></i><span> 网址导航</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-tubiaozhizuomoban1"></i><span> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/social/fcircle/"><i class="fa-fw iconfont icon-iconfontzhizuobiaozhunbduan36"></i><span> 朋友圈</span></a></li><li><a class="site-page child" href="/comments/"><i class="fa-fw iconfont icon-liuyanban"></i><span> 留言板</span></a></li><li><a class="site-page child" href="/social/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-a-06-wangzhidaohang"></i><span> 网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/site/census/"><i class="fa-fw iconfont icon-a-06-wangzhidaohang"></i><span> 网站统计</span></a></li><li><a class="site-page child" href="/site/echarts/"><i class="fa-fw iconfont icon-tongji"></i><span> 文章统计</span></a></li><li><a class="site-page child" href="/site/time/"><i class="fa-fw iconfont icon-shalou"></i><span> 旧时光</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-geren"></i><span> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/personal/bb/"><i class="fa-fw iconfont icon-icon_liuyan"></i><span> 唠叨</span></a></li><li><a class="site-page child" href="/personal/love/"><i class="fa-fw iconfont icon-valentine_-email-love-message-send"></i><span> 恋爱小屋</span></a></li><li><a class="site-page child" href="/personal/about/"><i class="fa-fw iconfont icon-icon-lark-logo-old"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500')"><nav id="nav"><span id="blog-info"><a href="/" title="鲸落"><span class="site-name">鲸落</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-youhuawenzhang"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-guidang"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei"></i><span> 分类</span></a></li><li><a class="site-page child" href="javascript:randomPost();"><i class="fa-fw iconfont icon-wode-zuji-copy"></i><span> 随便逛逛</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-xiuxianyinpin"></i><span> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/life/music/"><i class="fa-fw iconfont icon-tool"></i><span> 八音盒</span></a></li><li><a class="site-page child" href="/life/movies/"><i class="fa-fw iconfont icon-dianying"></i><span> 影院</span></a></li><li><a class="site-page child" href="/life/games/"><i class="fa-fw iconfont icon-youxi"></i><span> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-baoxiang21"></i><span> 八宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/box/gallery/"><i class="fa-fw iconfont icon-hualang"></i><span> 画廊</span></a></li><li><a class="site-page child" href="/box/animation/"><i class="fa-fw iconfont icon-donghua"></i><span> 动画</span></a></li><li><a class="site-page child" href="/box/nav/"><i class="fa-fw iconfont icon-a-06-wangzhidaohang"></i><span> 网址导航</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-tubiaozhizuomoban1"></i><span> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/social/fcircle/"><i class="fa-fw iconfont icon-iconfontzhizuobiaozhunbduan36"></i><span> 朋友圈</span></a></li><li><a class="site-page child" href="/comments/"><i class="fa-fw iconfont icon-liuyanban"></i><span> 留言板</span></a></li><li><a class="site-page child" href="/social/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-a-06-wangzhidaohang"></i><span> 网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/site/census/"><i class="fa-fw iconfont icon-a-06-wangzhidaohang"></i><span> 网站统计</span></a></li><li><a class="site-page child" href="/site/echarts/"><i class="fa-fw iconfont icon-tongji"></i><span> 文章统计</span></a></li><li><a class="site-page child" href="/site/time/"><i class="fa-fw iconfont icon-shalou"></i><span> 旧时光</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-geren"></i><span> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/personal/bb/"><i class="fa-fw iconfont icon-icon_liuyan"></i><span> 唠叨</span></a></li><li><a class="site-page child" href="/personal/love/"><i class="fa-fw iconfont icon-valentine_-email-love-message-send"></i><span> 恋爱小屋</span></a></li><li><a class="site-page child" href="/personal/about/"><i class="fa-fw iconfont icon-icon-lark-logo-old"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java进阶之路</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-09-25T02:08:49.000Z" title="发表于 2023-09-25 10:08:49">2023-09-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-10-13T11:32:58.918Z" title="更新于 2023-10-13 19:32:58">2023-10-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E6%B8%A3%E7%AC%94%E8%AE%B0/">面渣笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">295.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>1075分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java进阶之路"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="1-Java语法基础"><a href="#1-Java语法基础" class="headerlink" title="1 Java语法基础"></a>1 Java语法基础</h1><h2 id="1-1-Java关键字和保留字"><a href="#1-1-Java关键字和保留字" class="headerlink" title="1.1 Java关键字和保留字"></a>1.1 Java关键字和保留字</h2><p>1、<strong>abstract</strong>： 用于声明抽象类，以及抽象方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">abstract class Animal &#123;</span><br><span class="line">    abstract void makeSound();</span><br><span class="line">    public void sleep() &#123;</span><br><span class="line">        System.out.println(&quot;The animal is sleeping.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">    void makeSound() &#123;</span><br><span class="line">        System.out.println(&quot;The dog barks.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们创建了一个名为 Animal 的抽象类，其中包含一个抽象方法 makeSound() 和一个具体方法 sleep() 。</p>
<p>2、<strong>boolean</strong>： Java 中的一种基本数据类型，表示布尔值，即真（true）或假（false）。boolean 数据类型常用于判断条件、循环控制和逻辑运算等场景。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">boolean isStudent = true;</span><br><span class="line">if (isStudent) &#123;</span><br><span class="line">    System.out.println(&quot;This person is a student.&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    System.out.println(&quot;This person is not a student.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们定义了一个 boolean 变量：isStudent。通过 if 语句，我们可以根据这些变量的值进行不同的操作。</p>
<p>3、<strong>break</strong>： 用于跳出循环结构（如 for、while 和 do-while 循环）或 switch 语句。当遇到 break 语句时，程序将立即跳出当前循环或 switch 语句，继续执行紧跟在循环或 switch 语句后面的代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    if (i == 5) &#123;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;i: &quot; + i);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;Loop ended.&quot;);</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们使用 for 循环遍历 0 到 9 的整数。当 i 等于 5 时，我们使用 break 语句跳出循环。</p>
<p>4、<strong>byte</strong>： 用于表示一个 8 位（1 字节）有符号整数。它的值范围是 -128（-2^7）到 127（2^7 - 1）。由于 byte 类型占用的空间较小，它通常用于处理大量的数据，如文件读写、网络传输等场景，以节省内存空间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">byte minByte = -128;</span><br><span class="line">byte maxByte = 127;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们声明了三个 byte 类型的变量：minByte、maxByte，并分别赋予了不同的值。</p>
<p>5、<strong>case</strong>： 通常与 switch 语句一起使用。switch 语句允许根据某个变量的值来选择执行不同的代码块。在 switch 语句中，case 用于标识每个可能的值和对应的代码块。例子我们直接放到 switch 中一起讲。</p>
<p>6、<strong>catch</strong>： 用于捕获 try 语句中的异常。在 try 块中可能会抛出异常，而在 catch 块中可以捕获这些异常并进行处理。catch 块可以有多个，每个 catch 块可以捕获特定类型的异常。在 catch 块中，可以根据需要进行异常处理，例如输出错误信息、进行日志记录、恢复程序状态等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    int num = Integer.parseInt(&quot;abc&quot;);</span><br><span class="line">&#125; catch (NumberFormatException e) &#123;</span><br><span class="line">    System.out.println(&quot;Invalid number format&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个程序使用 try-catch 语句捕获 NumberFormatException 异常。在 try 块中，尝试将字符串 “abc” 转换为整数类型，由于这个字符串不是有效的数字格式，将会抛出 NumberFormatException 异常。在 catch 块中，捕获到了这个异常，并输出一条错误信息。</p>
<p>7、<strong>char</strong>： 用于声明一个字符类型的变量。char 类型的变量可以存储任意的 Unicode 字符，可以使用单引号将字符括起来来表示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char c = &#x27;A&#x27;;</span><br></pre></td></tr></table></figure>
<p>这个程序创建了一个 char 类型的变量 c，并将其赋值为大写字母 A。</p>
<p>8、<strong>class</strong>： 用于声明一个类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    public Person(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    public void sayHello() &#123;</span><br><span class="line">        System.out.println(&quot;Hello, my name is &quot; + name + &quot; and I am &quot; + age + &quot; </span><br><span class="line">years old.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>9、<strong>continue</strong>： 用于继续下一个循环，可以在指定条件下跳过其余代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 1; i &lt;= 10; i++) &#123;</span><br><span class="line">    if (i % 2 == 0) &#123;</span><br><span class="line">        continue;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>10、<strong>default</strong>： 用于指定 switch 语句中除去 case 条件之外的默认代码块。这个我们放到 switch 里一起演示。</p>
<p>11、<strong>do</strong>： 通常和 while 关键字配合使用，do 后紧跟循环体。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i = 1;</span><br><span class="line">do &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    i++;</span><br><span class="line">&#125; while (i &lt;= 10);</span><br></pre></td></tr></table></figure>
<p>do-while 循环与 while 循环类似，不同之处在于 do-while 循环会先执行循环体中的代码，然后再检查循环<br>条件。因此，do-while 循环至少会执行一次循环体中的代码。</p>
<p>12、<strong>double</strong>： 用于声明一个双精度浮点类型的变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">double a = 3.14;</span><br><span class="line">double b = 2.0;</span><br><span class="line">double c = a + b;</span><br></pre></td></tr></table></figure>
<p>13、<strong>else</strong>： 用于指示 if 语句中的备用分支。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int score = 75;</span><br><span class="line">if (score &gt;= 60) &#123;</span><br><span class="line">    System.out.println(&quot;及格了&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    System.out.println(&quot;挂科了&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>14、<strong>enum</strong>： 用于定义一组固定的常量（枚举）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public enum PlayerType &#123;</span><br><span class="line">    TENNIS,</span><br><span class="line">    FOOTBALL,</span><br><span class="line">    BASKETBALL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>15、<strong>extends</strong>： 用于指示一个类是从另一个类或接口继承的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        System.out.println(&quot;动物正在吃东西&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">    public void bark() &#123;</span><br><span class="line">        System.out.println(&quot;狗在汪汪叫&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ExtendsDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Dog dog = new Dog();</span><br><span class="line">        dog.eat();</span><br><span class="line">        dog.bark();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Animal 类中有一个 eat() 方法，输出字符串 “动物正在吃东西”。Dog 类继承自 Animal 类，并定义了一个 bark() 方法，输出字符串 “狗在汪汪叫”。</p>
<p>16、<strong>final</strong>： <strong>用于表示某个变量、方法或类是最终的，不能被修改或继承。</strong></p>
<ol>
<li><p>final 变量：表示一个常量，一旦被赋值，其值就不能再被修改。这在声明不可变的值时非常有用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final double PI = 3.14159265359;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>final 方法表示一个不能被子类重写的方法。这在设计类时，确保某个方法的实现不会被子类修改时非常有用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    final void makeSound() &#123;</span><br><span class="line">        System.out.println(&quot;动物发出声音.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">    // 错误: 无法覆盖来自 Animal 的 final 方法</span><br><span class="line">    // void makeSound() &#123;</span><br><span class="line">    //     System.out.println(&quot;狗吠叫.&quot;);</span><br><span class="line">    // &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Dog dog = new Dog();</span><br><span class="line">        dog.makeSound();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>final 类表示一个不能被继承的类。这在设计类时，确保其不会被其他类继承时非常有用。<strong>String 类就是<br>final 的</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">final class Animal &#123;</span><br><span class="line">    void makeSound() &#123;</span><br><span class="line">        System.out.println(&quot;动物发出声音.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 错误: 类型 Dog 无法继承 final 类 Animal</span><br><span class="line">// class Dog extends Animal &#123;</span><br><span class="line">//     void makeSound() &#123;</span><br><span class="line">//         System.out.println(&quot;狗吠叫.&quot;);</span><br><span class="line">//     &#125;</span><br><span class="line">// &#125;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Animal animal = new Animal();</span><br><span class="line">        animal.makeSound();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>17、<strong>finally</strong>： 和 try-catch 配合使用，表示无论是否处理异常，总是执行 finally 块中的代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    int x = 10 / 0;  // 抛出异常</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    System.out.println(&quot;发生了异常：&quot; + e.getMessage());</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    System.out.println(&quot;finally 块被执行&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>18、<strong>float</strong>： 表示单精度浮点数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float f1 = 3.14f;   // 注意要在数字后面加上 f 表示这是一个 float 类型</span><br><span class="line">float f2 = 1.23e-4f;   // 科学计数法表示小数</span><br></pre></td></tr></table></figure>
<p>在 Java 中，浮点数默认是 double 类型，如果要使用 float 类型的数据，需要在数字后面加上一个 f 或者 F，表示这是一个 float 类型的字面量。另外，也可以使用科学计数法表示浮点数，例如 1.23e-4 表示 0.000123。</p>
<p>19、<strong>for</strong>： 用于声明一个 for 循环，如果循环次数是固定的，建议使用 for 循环。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int[] arr = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">    System.out.println(&quot;arr[&quot; + i + &quot;] = &quot; + arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>20、<strong>if</strong>： 用于指定条件，如果条件为真，则执行对应代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int n = -3;</span><br><span class="line">if (n &gt; 0) &#123;</span><br><span class="line">    System.out.println(n + &quot; 是正数&quot;);</span><br><span class="line">&#125; else if (n &lt; 0) &#123;</span><br><span class="line">    System.out.println(n + &quot; 是负数&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    System.out.println(n + &quot; 是零&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>21、<strong>implements</strong>： 用于实现接口。</p>
<p>下面是一个实现了 Runnable 接口的类的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class MyThread implements Runnable &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        // 线程执行的代码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>22、<strong>import</strong>： 用于导入对应的类或者接口。例如，如果要使用 Java 标准库中的 ArrayList 类，可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br></pre></td></tr></table></figure>
<p>23、<strong>instanceof</strong>： <strong>用于判断对象是否属于某个类型（class）。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">例如，假设有一个 Person 类和一个 Student 类，Student 类继承自 Person 类，可以使用 instanceof </span><br><span class="line">运算符来判断一个对象是否为 Person 类或其子类的实例：</span><br><span class="line">Person p = new Student();</span><br><span class="line">if (p instanceof Person) &#123;</span><br><span class="line">    System.out.println(&quot;p is an instance of Person&quot;);</span><br><span class="line">&#125;</span><br><span class="line">if (p instanceof Student) &#123;</span><br><span class="line">    System.out.println(&quot;p is an instance of Student&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>24、<strong>int</strong>： 用于表示整数值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int x;           // 声明一个 int 类型的变量 x</span><br><span class="line">x = 10;          // 将整数值 10 赋给变量 x</span><br><span class="line">int y = 20;     // 声明并初始化一个 int 类型的变量 y，赋值为整数值 20</span><br></pre></td></tr></table></figure>
<p>25、<strong>interface</strong>： 用于声明接口。会定义一组方法的签名（即方法名、参数列表和返回值类型），但没有方法体。其他类可以实现接口，并提供方法的具体实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface MyInterface &#123;</span><br><span class="line">    void method1();</span><br><span class="line">    int method2(String param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>26、<strong>long</strong>： 用于表示长整数值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">long x;           // 声明一个 long 类型的变量 x</span><br><span class="line">x = 10000000000L; // 将长整数值 10000000000 赋给变量 x，需要在数字后面加上 L 或 l 表示这是一个 long 类型的值</span><br><span class="line">long y = 20000000000L; // 声明并初始化一个 long 类型的变量 y，赋值为长整数值 20000000000</span><br></pre></td></tr></table></figure>
<p>27、<strong>native</strong>： <strong>用于声明一个本地方法</strong>，本地方法是指在 Java 代码中声明但在本地代码（通常是 C 或 C++ 代<br>码）中实现的方法，它通常用于与操作系统或其他本地库进行交互。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public native void nativeMethod();</span><br></pre></td></tr></table></figure>
<p>28、<strong>new</strong>： 用于创建一个新的对象。</p>
<p>以下是使用 new 关键字创建对象实例的基本语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassName obj = new ClassName();</span><br></pre></td></tr></table></figure>
<p>以下是使用 new 关键字创建数组实例的基本语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[] arr = new int[10];</span><br></pre></td></tr></table></figure>
<p>29、<strong>null</strong>： 如果一个变量是空的（什么引用也没有指向），就可以将它赋值为 null，和空指针异常息息相关。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = null; // 声明一个字符串引用，初始化为 null</span><br><span class="line">MyClass obj = null; // 声明一个 MyClass 类型的引用，初始化为 null</span><br></pre></td></tr></table></figure>
<p>30、<strong>package</strong>： 用于声明类所在的包。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.example.mypackage;</span><br></pre></td></tr></table></figure>
<p>31、<strong>private</strong>： 一个访问权限修饰符，<strong>表示方法或变量只对当前类可见。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line">    private int x; // 私有属性 x，只能在当前类的内部访问</span><br><span class="line">    private void foo() &#123;</span><br><span class="line">        // 私有方法 foo，只能在当前类的内部调用</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，MyClass 类有一个私有属性 x 和一个私有方法 foo() 。这些成员只能在 MyClass 类的内部访问和调用，对其他类不可见。</p>
<p>32、<strong>protected</strong>： 一个访问权限修饰符，<strong>表示方法或变量对同一包内的类和所有子类可见。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.example.mypackage;</span><br><span class="line">public class MyBaseClass &#123;</span><br><span class="line">    protected int x; // 受保护的属性 x，可以被子类和同一包中的其他类访问</span><br><span class="line">    protected void foo() &#123;</span><br><span class="line">        // 受保护的方法 foo，可以被子类和同一包中的其他类调用</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">package com.example.mypackage;</span><br><span class="line">public class MySubClass extends MyBaseClass &#123;</span><br><span class="line">    public void bar() &#123;</span><br><span class="line">        x = 10; // 可以访问 MyBaseClass 中的受保护属性 x</span><br><span class="line">        foo(); // 可以调用 MyBaseClass 中的受保护方法 foo</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，MyBaseClass 类有一个受保护的属性 x 和一个受保护的方法 foo() 。这些成员可以被子类和同一包中的其他类访问和调用。MySubClass 类继承自 MyBaseClass 类，并可以访问和修改 MyBaseClass 中的受保护成员。</p>
<p>33、<strong>public</strong>： 一个访问权限修饰符，除了可以声明方法和变量（所有类可见），还可以声明类。 main() 方法必须声明为 public。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line">    public int x; // 公有属性 x，可以被任何类访问</span><br><span class="line">    public void foo() &#123;</span><br><span class="line">        // 公有方法 foo，可以被任何类调用</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，MyClass 类有一个公有属性 x 和一个公有方法 foo() 。这些成员可以被任何类访问和调用，无论这些类是否在同一个包中。</p>
<p>35、<strong>return</strong>： 用于从方法中返回一个值或终止方法的执行。return 语句可以将方法的计算结果返回给调用者，或者在方法执行到某个特定条件时提前结束方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public int add(int a, int b) &#123;</span><br><span class="line">    int sum = a + b;</span><br><span class="line">    return sum; // 返回 sum 的值，并结束方法的执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外，return 语句还可以用于提前结束方法的执行。例如，假设我们要编写一个方法，用于判断一个整数是否为偶数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static boolean isEven(int number) &#123;</span><br><span class="line">    if (number % 2 == 0) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们定义了一个名为 isEven 的方法，该方法接收一个整数参数 number。如果 number 是偶数，我们使用 return 语句提前返回 true。否则，方法执行将继续，最后返回 false。</p>
<p>36、<strong>short</strong>： 用于表示短整数，占用 2 个字节（16 位）的内存空间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">short x = 10; // 声明一个 short 类型的变量 x，赋值为 10</span><br><span class="line">short y = 20; // 声明一个 short 类型的变量 y，赋值为 20</span><br></pre></td></tr></table></figure>
<p>37、<strong>static</strong>： 表示该变量或方法是<strong>静态变量或静态方法。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line">    public static int x; // 静态变量 x，属于类的成员</span><br><span class="line">    public static void foo() &#123;</span><br><span class="line">        // 静态方法 foo，属于类的成员</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，MyClass 类有一个静态变量 x 和一个静态方法 foo() 。这些成员属于类的成员，可以通过类名直接访问，不需要创建对象。</p>
<p>38、<strong>strictfp（strict floating-point）</strong>： 并不常见，通常用于修饰一个方法，用于限制浮点数计算的精度和舍入行为。当你在类、接口或方法上使用 strictfp 时，该范围内的所有浮点数计算将遵循 IEEE 754 标准的规定，以确保跨平台的浮点数计算的一致性。</p>
<p>不同的硬件平台和 JVM 实现可能对浮点数计算的精度和舍入行为有差异，这可能导致在不同环境中运行相同的浮点数计算代码产生不同的结果。使用 strictfp 关键字可以确保在所有平台上获得相同的浮点数计算结果，避免计算结果的不一致问题。</p>
<p>但请注意，使用 strictfp 可能会对性能产生影响，因为可能需要更多的计算和转换来确保遵循 IEEE 754 标准。因此，在使用 strictfp 时，需要权衡精度和一致性与性能之间的关系。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public strictfp class MyClass &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        double a = 0.1;</span><br><span class="line">        double b = 0.2;</span><br><span class="line">        double result = a + b;</span><br><span class="line">        System.out.println(&quot;Result: &quot; + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Result: 0.30000000000000004</span><br></pre></td></tr></table></figure>
<p>在这个示例中，MyClass 类被声明为 strictfp，因此类中的所有浮点数计算都将遵循 IEEE 754 标准。</p>
<p>在大多数现代操作系统上，使用 strictfp 可能不会产生显著差异，因为大家都遵循 IEEE 754 标准，除非是一些较旧的硬件平台。</p>
<p>IEEE 754 标准（IEEE Standard for Floating-Point Arithmetic）是一个定义浮点数表示和运算的国际标准。由国际电气和电子工程师协会（IEEE）制定，首次发布于1985年。</p>
<p>IEEE 754 标准主要规定了以下几个方面：</p>
<p>浮点数表示：标准定义了两种浮点数格式，单精度（32位）和双精度（64位）。这两种格式分别由符号位、指数位和尾数位组成，用于表示浮点数的大小和精度。</p>
<p>四舍五入和舍入模式：标准定义了多种舍入模式，例如向最接近的数舍入（Round to Nearest, Ties to Even）、向零舍入（Round toward Zero）、向正无穷舍入（Round toward +∞）和向负无穷舍入（Round toward -∞）等。这些模式指导了浮点数计算过程中如何处理精度损失和舍入误差。</p>
<p>特殊值：标准定义了一些特殊的浮点数值，如正无穷（+∞）、负无穷（-∞）和非数值（NaN）。这些特殊值用于表示浮点数计算中可能出现的溢出、下溢和未定义结果等情况。</p>
<p>浮点数运算：标准规定了浮点数的基本运算（加、减、乘、除）和比较运算（等于、不等于、大于、小于、大于等于、小于等于）的行为和结果。这些运算需要遵循标准中规定的表示、舍入和特殊值处理规则。</p>
<p>来看示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Ieee754Demo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        float a = 0.1f;</span><br><span class="line">        float b = 0.2f;</span><br><span class="line">        float c = a + b;</span><br><span class="line">        System.out.println(&quot;a = &quot; + a);</span><br><span class="line">        System.out.println(&quot;b = &quot; + b);</span><br><span class="line">        System.out.println(&quot;c = a + b = &quot; + c);</span><br><span class="line">        double x = 1.0 / 0.0;</span><br><span class="line">        double y = -1.0 / 0.0;</span><br><span class="line">        double z = 0.0 / 0.0;</span><br><span class="line">        System.out.println(&quot;x = 1.0 / 0.0 = &quot; + x);</span><br><span class="line">        System.out.println(&quot;y = -1.0 / 0.0 = &quot; + y);</span><br><span class="line">        System.out.println(&quot;z = 0.0 / 0.0 = &quot; + z);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<p><img src="\assets\note\image-20230925103754023.png" alt="image-20230925103754023"></p>
<p>我们可以看到 IEEE 754 标准中的浮点数表示和运算：</p>
<ul>
<li>单精度浮点数的加法：变量 a 和 b 分别存储了 0.1 和 0.2，它们的和 c 等于 0.3。由于浮点数表示的精度限制，c 的实际值可能与理论值略有误差。</li>
<li>特殊值：变量 x、y 和 z 分别存储了正无穷（+∞）、负无穷（-∞）和非数值（NaN）。这些特殊值是由除法运算产生的，当被除数为 0 或结果无法表示时，会返回相应的特殊值。</li>
</ul>
<p>39、<strong>super</strong>： 可用于<strong>调用父类的方法或者字段。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    protected String name;</span><br><span class="line">    public Animal(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        System.out.println(name + &quot; is eating.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Dog extends Animal &#123;</span><br><span class="line">    public Dog(String name) &#123;</span><br><span class="line">        super(name); // 调用父类的构造方法</span><br><span class="line">    &#125;</span><br><span class="line">    public void bark() &#123;</span><br><span class="line">        System.out.println(name + &quot; is barking.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        super.eat(); // 调用父类的方法</span><br><span class="line">        System.out.println(name + &quot; is eating bones.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>40、<strong>switch</strong>： 用于根据某个变量的值选择执行不同的代码块。switch 语句通常与 case 和 default 一起使用。每个 case 子句表示一个可能的值和对应的代码块，而 default 子句用于处理不在 case 子句中的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int dayOfWeek = 3;</span><br><span class="line">        switch (dayOfWeek) &#123;</span><br><span class="line">            case 1:</span><br><span class="line">                System.out.println(&quot;Monday&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case 2:</span><br><span class="line">                System.out.println(&quot;Tuesday&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case 3:</span><br><span class="line">                System.out.println(&quot;Wednesday&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case 4:</span><br><span class="line">                System.out.println(&quot;Thursday&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case 5:</span><br><span class="line">                System.out.println(&quot;Friday&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case 6:</span><br><span class="line">                System.out.println(&quot;Saturday&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case 7:</span><br><span class="line">                System.out.println(&quot;Sunday&quot;);</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                System.out.println(&quot;Invalid day&quot;);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们定义了一个名为 dayOfWeek 的整数变量，并赋予了一个值。然后，我们使用 switch 语句根据 dayOfWeek 的值来输出对应的星期几。每个 case 子句表示 dayOfWeek 可能的值，后面紧跟着要执行的代码。使用 break 语句跳出 switch 语句，避免执行其他 case 子句的代码。如果 dayOfWeek 的值不在 case 子句中，default 子句将被执行。</p>
<p>41、<strong>synchronized</strong>： <strong>用于指定多线程代码中的同步方法、变量或者代码块。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line">    private int count;</span><br><span class="line">    public synchronized void increment() &#123;</span><br><span class="line">        count++; // 同步方法</span><br><span class="line">    &#125;</span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">        synchronized(this) &#123; // 同步代码块</span><br><span class="line">            // 执行一些需要同步的操作</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>42、<strong>this</strong>： <strong>可用于在方法或构造方法中引用当前对象。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line">    private int num;</span><br><span class="line">    public MyClass(int num) &#123;</span><br><span class="line">        this.num = num; // 使用 this 关键字引用当前对象的成员变量</span><br><span class="line">    &#125;</span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">        System.out.println(&quot;Doing something with &quot; + this.num); // 使用 this 关键字引</span><br><span class="line">用当前对象的成员变量</span><br><span class="line">    &#125;</span><br><span class="line">    public MyClass getThis() &#123;</span><br><span class="line">        return this; // 返回当前对象本身</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，MyClass 类有一个私有成员变量 num，并定义了一个构造方法、一个方法和一个返回当前对象的方法。在构造方法中，使用 this 关键字引用当前对象的成员变量，并将传入的参数赋值给该成员变量。在方法 doSomething() 中，使用 this 关键字引用当前对象的成员变量，并输出该成员变量的值。在方法 getThis() 中，直接返回当前对象本身。</p>
<p>43、<strong>throw</strong>： 主动抛出异常。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line">    public void doSomething(int num) throws Exception &#123;</span><br><span class="line">        if (num &lt; 0) &#123;</span><br><span class="line">            throw new Exception(&quot;num must be greater than zero&quot;); // 手动抛出异常</span><br><span class="line">        &#125;</span><br><span class="line">        // 执行一些操作</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>44、<strong>throws</strong>： 用于声明异常。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line">    public void doSomething(int num) throws Exception &#123;</span><br><span class="line">        if (num &lt; 0) &#123;</span><br><span class="line">            throw new Exception(&quot;num must be greater than zero&quot;); // 手动抛出异常</span><br><span class="line">        &#125;</span><br><span class="line">        // 执行一些操作</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>45、<strong>transient</strong>：  <strong>修饰的字段不会被序列化。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass implements Serializable &#123;</span><br><span class="line">    private int id;</span><br><span class="line">    private String name;</span><br><span class="line">    private transient String password;</span><br><span class="line">    public MyClass(int id, String name, String password) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.password = password;</span><br><span class="line">    &#125;</span><br><span class="line">    // 省略 getter 和 setter 方法</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;MyClass&#123;&quot; +</span><br><span class="line">                &quot;id=&quot; + id +</span><br><span class="line">                &quot;, name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, password=&#x27;&quot; + password + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，MyClass 类实现了 Serializable 接口，表示该类的对象可以被序列化。该类有三个成员变量，分别是 id、name 和 password。其中，password 成员变量被标记为 transient，表示在序列化过程中忽略这个成员变量。</p>
<p>45、<strong>try</strong>： 用于包裹要捕获异常的代码块。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    // 可能抛出异常的代码</span><br><span class="line">    int result = 1 / 0;</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    // 异常处理代码</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>46、<strong>void</strong>： 用于指定方法没有返回值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void doSomething() &#123;</span><br><span class="line">    // 方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>47、<strong>volatile</strong>： 保证不同线程对它修饰的变量进行操作时的<strong>可见性</strong>，即一个线程修改了某个变量的值，新值对其他线程来说是立即可见的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class MyThread extends Thread &#123;</span><br><span class="line">    private volatile boolean running = true;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (running) &#123;</span><br><span class="line">            // 线程执行的代码</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void stopThread() &#123;</span><br><span class="line">        running = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，MyThread 类继承了 Thread 类，重写了 run() 方法。MyThread 类有一个成员变量 running，被标记为 volatile，表示这个变量是共享的，可能会被多个线程同时访问。在 run() 方法中，使用 while 循环检查 running 变量的值，如果 running 为 true，就继续执行循环体中的代码。在另一个方法 stopThread() 中，将 running 变量的值设置为 false，表示需要停止线程。</p>
<p>48、<strong>while</strong>： 如果循环次数不固定，建议使用 while 循环。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i = 0;</span><br><span class="line">while (i &lt; 10) &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“除了这些关键字，Java 中还有两个非常特殊的保留字（goto 和 const），它们不能在程序中使用。”“goto 在 C语言中叫做‘无限跳转’语句，在 Java 中，不再使用 goto 语句，因为无限跳转会破坏程序结构。”Java 中确实可以使用标签（label）与 break 和 continue 语句结合来实现类似 goto 的跳转功能。以下是一个简单的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class LabelDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        outerLoop:</span><br><span class="line">        for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; 3; j++) &#123;</span><br><span class="line">                if (i == 1 &amp;&amp; j == 1) &#123;</span><br><span class="line">                    System.out.println(&quot;跳过 outerLoop 中的当前迭代&quot;);</span><br><span class="line">                    continue outerLoop;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;i: &quot; + i + &quot;, j: &quot; + j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;结束&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们使用了两层嵌套循环。外层循环有一个名为 outerLoop 的标签。当 i 等于 1 且 j 等于 1 时，我们使用 continue outerLoop 语句跳过外层循环中的当前迭代。这与 goto 的行为类似。</p>
<p>来看输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">i: 0, j: 0</span><br><span class="line">i: 0, j: 1</span><br><span class="line">i: 0, j: 2</span><br><span class="line">i: 1, j: 0</span><br><span class="line">跳过 outerLoop 中的当前迭代</span><br><span class="line">i: 2, j: 0</span><br><span class="line">i: 2, j: 1</span><br><span class="line">i: 2, j: 2</span><br><span class="line">结束</span><br></pre></td></tr></table></figure>
<p>尽管可以使用标签实现类似 goto 的跳转功能，但这种用法在 Java 中仍然较少见，因为过度使用可能导致代码难以理解和维护。通常建议尽可能使用其他控制结构（如 if、for 和 while 语句）来组织代码。</p>
<p>以下是一个使用 if 和 for 语句替代标签跳转的示例。在这个示例中，我们使用了一个布尔变量 skipIteration 来决定是否跳过外层循环的当前迭代：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class IfForDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">            boolean skipIteration = false;</span><br><span class="line">            for (int j = 0; j &lt; 3; j++) &#123;</span><br><span class="line">                if (i == 1 &amp;&amp; j == 1) &#123;</span><br><span class="line">                    System.out.println(&quot;跳过外层循环中的当前迭代&quot;);</span><br><span class="line">                    skipIteration = true;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;i: &quot; + i + &quot;, j: &quot; + j);</span><br><span class="line">            &#125;</span><br><span class="line">            if (skipIteration) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，当 i 等于 1 且 j 等于 1 时，我们将 skipIteration 设置为 true，然后使用 break 语句跳出内层<br>循环。在外层循环中，我们检查 skipIteration 变量的值，如果为 true，则跳过外层循环的当前迭代。</p>
<p>这个示例的输出结果与之前的示例相同：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">i: 0, j: 0</span><br><span class="line">i: 0, j: 1</span><br><span class="line">i: 0, j: 2</span><br><span class="line">i: 1, j: 0</span><br><span class="line">跳过外层循环中的当前迭代</span><br><span class="line">i: 2, j: 0</span><br><span class="line">i: 2, j: 1</span><br><span class="line">i: 2, j: 2</span><br></pre></td></tr></table></figure>
<p>“const 在 C语言中是声明常量的关键字，在 Java 中可以使用 public static final 三个关键字的组合来达到常量的效果。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Circle &#123;</span><br><span class="line">    public static final double PI = 3.14159;</span><br><span class="line">    public static double calculateArea(double radius) &#123;</span><br><span class="line">        return PI * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们使用 public static final 关键字组合定义了一个名为 PI 的常量。因为它是 public 的，所以其他类可以访问这个常量。因为它是 static 的，所以它与类关联，而不是类的实例。因为它是 final 的，所以它的值不能被更改。</p>
<h2 id="1-2-Java注释"><a href="#1-2-Java注释" class="headerlink" title="1.2 Java注释"></a>1.2 Java注释</h2><p><img src="\assets\note\image-20230925105319358.png" alt="image-20230925105319358"></p>
<p><strong>01、单行注释 </strong></p>
<p>单行注释通常用于解释方法内某单行代码的作用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void method() &#123;</span><br><span class="line">    int age = 18; // age 用于表示年龄</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但如果写在行尾的话，其实是不符合阿里巴巴的开发规约的。</p>
<p><img src="\assets\note\image-20230925105443224.png" alt="image-20230925105443224"></p>
<p>正确的单行注释如上图中所说，在被注释语句上方另起一行，使用 // 注释。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void method() &#123;</span><br><span class="line">    // age 用于表示年龄</span><br><span class="line">    int age = 18;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>02、多行注释 </strong></p>
<p>多行注释使用的频率其实并不高，通常用于解释一段代码的作用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">age 用于表示年纪</span><br><span class="line">name 用于表示姓名</span><br><span class="line">*/</span><br><span class="line">int age = 18;</span><br><span class="line">String name = &quot;沉默&quot;;</span><br></pre></td></tr></table></figure>
<p>以 /<em> 开始，以 </em>/ 结束，但不如用多个 // 来得痛快，因为 * 和 / 不在一起，敲起来麻烦。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// age 用于表示年纪</span><br><span class="line">// name 用于表示姓名</span><br><span class="line">int age = 18;</span><br><span class="line">String name = &quot;沉默&quot;;</span><br></pre></td></tr></table></figure>
<p><strong>03、文档注释 </strong></p>
<p>文档注释可用在三个地方，类、字段和方法，用来解释它们是干嘛的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 微信搜索「二哈进阶之路」</span><br><span class="line"> */</span><br><span class="line">public class Demo &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 姓名</span><br><span class="line">     */</span><br><span class="line">    private int age;</span><br><span class="line">    /**</span><br><span class="line">     * main 方法作为程序的入口</span><br><span class="line">     *</span><br><span class="line">     * @param args 参数</span><br><span class="line">     */</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS：在 Intellij IDEA 中，按下 /<em>* 后敲下回车键就可以自动添加文档注释的格式， </em>/ 是自动补全的。</p>
<p>接下来，我们来看看如何通过 javadoc 命令生成代码文档。</p>
<p>第一步，在该类文件上右键，找到「Open in Terminal」 可以打开命令行窗口。</p>
<p><img src="\assets\note\image-20230925105809280.png" alt="image-20230925105809280"></p>
<p>第二步，执行 javadoc 命令 javadoc Demo.java -encoding utf-8 。 -encoding utf-8 可以保证中文不发生乱码。</p>
<p><img src="\assets\note\image-20230925105924721.png" alt="image-20230925105924721"></p>
<p>第三步，执行 ls -l 命令就可以看到生成代码文档时产生的文件，主要是一些可以组成网页的 html、js 和 css 文件。</p>
<p><img src="\assets\note\image-20230925110002342.png" alt="image-20230925110002342"></p>
<p>第四步，执行 open index.html 命令可以通过默认的浏览器打开文档注释。</p>
<p><img src="\assets\note\image-20230925110036341.png" alt="image-20230925110036341"></p>
<p>点击「Demo」，可以查看到该类更具体的注释文档。</p>
<p><img src="\assets\note\image-20230925110131874.png" alt="image-20230925110131874"></p>
<p><strong>04、文档注释的注意事项 </strong></p>
<p>1） javadoc 命令只能为 public 和 protected 修饰的字段、方法和类生成文档。</p>
<p>default 和 private 修饰的字段和方法的注释将会被忽略掉。因为我们本来就不希望这些字段和方法暴露给调用者。</p>
<p>如果类不是 public 的话，javadoc 会执行失败。</p>
<p><img src="\assets\note\image-20230925110225972.png" alt="image-20230925110225972"></p>
<p>2）文档注释中可以嵌入一些 HTML 标记，比如说段落标记 <p> ，超链接标记 <a></a> 等等，但不要使用标题标记，比如说 <h1> ，因为 javadoc 会插入自己的标题，容易发生冲突。</p>
<p>3）文档注释中可以插入一些 @ 注解，比如说 @see 引用其他类， @version 版本号， @param 参数标识符， @author 作者标识符， @deprecated 已废弃标识符，等等。</p>
<p><strong>05、注释规约 </strong></p>
<p>1）类、字段、方法必须使用文档注释，不能使用单行注释和多行注释。因为注释文档在 IDE 编辑窗口中可以悬浮提示，提高编码效率。</p>
<p>比如说，在使用 String 类的时候，鼠标悬停在 String 上时可以得到以下提示。</p>
<p><img src="\assets\note\image-20230925110330201.png" alt="image-20230925110330201"></p>
<p>2）所有的抽象方法(包括接口中的方法)必须要用 Javadoc 注释、除了返回值、参数、 异常说明外，还必须指出该方法做什么事情，实现什么功能。</p>
<p>3）所有的类都必须添加创建者和创建日期。</p>
<p>Intellij IDEA 中可以在「File and Code Templates」中设置。</p>
<p><img src="\assets\note\image-20230925110443800.png" alt="image-20230925110443800"></p>
<p>语法如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 微信搜索「二哈进阶之路」</span><br><span class="line">* @author 二哈</span><br><span class="line">* @date $&#123;DATE&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p>设置好后，在新建一个类的时候就可以自动生成了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 微信搜索「二哈进阶之路」</span><br><span class="line"> *</span><br><span class="line"> * @author 二哈</span><br><span class="line"> * @date 2020/11/16</span><br><span class="line"> */</span><br><span class="line">public class Test &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4）所有的枚举类型字段必须要有注释，说明每个数据项的用途。</p>
<p>5）代码修改的同时，注释也要进行相应的修改。</p>
<p>“记住一点，注释是程序固有的一部分。”</p>
<ul>
<li>第一、注释要能够准确反映设计思想和代码逻辑;</li>
<li>第二、注释要能够描述业务含 义，使别的程序员能够迅速了解到代码背后的信息。</li>
</ul>
<p>完全没有注释的大段代码对于阅读者形同 天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路;注释也是给继任者看 的，使其能够快速接替自己的工作。</p>
<h2 id="1-3-Java数据类型"><a href="#1-3-Java数据类型" class="headerlink" title="1.3 Java数据类型"></a>1.3 Java数据类型</h2><p>Java 中的数据类型可分为 2 种：</p>
<p><strong>1）基本数据类型。</strong></p>
<p>基本数据类型是 Java 语言操作数据的基础，包括 boolean、char、byte、short、int、long、float 和 double，共 8 种。</p>
<p><strong>2）引用数据类型。</strong></p>
<p>除了基本数据类型以外的类型，都是所谓的引用类型。常见的有数组（对，没错，数组是引用类型，后面我们会讲）、class（也就是类），以及接口（指向的是实现接口的类的对象）。来个思维导图，感受下。</p>
<p><img src="\assets\note\image-20230925110840637.png" alt="image-20230925110840637"></p>
<p>变量可以分为局部变量、成员变量、静态变量。</p>
<p>当变量是局部变量的时候，必须得先初始化，否则编译器不允许你使用它。拿 int 来举例吧，看下图。</p>
<p><img src="\assets\note\image-20230925110931400.png" alt="image-20230925110931400"></p>
<p>当变量是成员变量或者静态变量时，可以不进行初始化，它们会有一个默认值，仍然以 int 为例，来看代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author 微信搜「二哈进阶之路」</span><br><span class="line"> */</span><br><span class="line">public class LocalVar &#123;</span><br><span class="line">    private int a;</span><br><span class="line">    static int b;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        LocalVar lv = new LocalVar();</span><br><span class="line">        System.out.println(lv.a);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>瞧见没，int 作为成员变量时或者静态变量时的默认值是 0。那不同的基本数据类型，是有不同的默认值和大小的，来个表格感受下。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">数据类型</th>
<th style="text-align:center">默认值</th>
<th style="text-align:center">大小</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">boolean</td>
<td style="text-align:center">false</td>
<td style="text-align:center">1 比特</td>
</tr>
<tr>
<td style="text-align:center">char</td>
<td style="text-align:center">‘\u0000’</td>
<td style="text-align:center">2 字节</td>
</tr>
<tr>
<td style="text-align:center">byte</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1 字节</td>
</tr>
<tr>
<td style="text-align:center">short</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2 字节</td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">0</td>
<td style="text-align:center">4 字节</td>
</tr>
<tr>
<td style="text-align:center">long</td>
<td style="text-align:center">0L</td>
<td style="text-align:center">8 字节</td>
</tr>
<tr>
<td style="text-align:center">float</td>
<td style="text-align:center">0.0f</td>
<td style="text-align:center">4 字节</td>
</tr>
<tr>
<td style="text-align:center">double</td>
<td style="text-align:center">0.0</td>
<td style="text-align:center">8 字节</td>
</tr>
</tbody>
</table>
</div>
<p><strong>01、比特和字节 </strong></p>
<p>比特币（Bitcoin）听说过吧？字节跳动（Byte Dance）听说过吧？这些名字当然不是乱起的，确实和比特、字节有关系。</p>
<p><strong>1）bit（比特） </strong></p>
<p>比特作为信息技术的最基本存储单位，非常小，但大名鼎鼎的比特币就是以此命名的，它的简写为小写字母“b”。</p>
<p>大家都知道，计算机是以二进制存储数据的，二进制的一位，就是 1 比特，也就是说，比特要么为 0 要么为 1。</p>
<p><strong>2）Byte（字节） </strong></p>
<p>通常来说，一个英文字符是一个字节，一个中文字符是两个字节。字节与比特的换算关系是：1 字节 = 8 比特。</p>
<p>在往上的单位就是 KB，并不是 1000 字节，因为计算机只认识二进制，因此是 2 的 10 次方，也就是 1024<br>个字节。（终于知道 1024 和程序员的关系了吧？狗头保命）</p>
<p><img src="\assets\note\image-20230925111850396.png" alt="image-20230925111850396"></p>
<p><strong>02、基本数据类型 </strong></p>
<p>接下来，我们再来详细地了解一下 8 种基本数据类型。</p>
<p><strong>1）布尔 </strong></p>
<p>布尔（boolean）仅用于存储两个值：true 和 false，也就是真和假，通常用于条件的判断。代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">boolean hasMoney = true;</span><br><span class="line">boolean hasGirlFriend = false;</span><br></pre></td></tr></table></figure>
<p><strong>2）byte </strong></p>
<p>一个字节可以表示 2^8 = 256 个不同的值。由于 byte 是有符号的，它的值可以是负数或正数，其取值范围是 -128 到 127（包括 -128 和 127）。</p>
<p>在网络传输、大文件读写时，为了节省空间，常用字节来作为数据的传输方式。代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">byte b; // 声明一个 byte 类型变量</span><br><span class="line">b = 10; // 将值 10 赋给变量 b</span><br><span class="line">byte c = -100; // 声明并初始化一个 byte 类型变量 c，赋值为 -100</span><br></pre></td></tr></table></figure>
<p><strong>3）short </strong></p>
<p>short 的取值范围在 -32,768 和 32,767 之间，包含 32,767。代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">short s; // 声明一个 short 类型变量</span><br><span class="line">s = 1000; // 将值 1000 赋给变量 s</span><br><span class="line">short t = -2000; // 声明并初始化一个 short 类型变量 t，赋值为 -2000</span><br></pre></td></tr></table></figure>
<p>实际开发中，short 比较少用，整型用 int 就 OK。</p>
<p><strong>4）int </strong></p>
<p>int 的取值范围在 -2,147,483,648（-2 ^ 31）和 2,147,483,647（2 ^ 31 -1）（含）之间。如果没有特殊需求，整型数据就用 int。代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int i; // 声明一个 int 类型变量</span><br><span class="line">i = 1000000; // 将值 1000000 赋给变量 i</span><br><span class="line">int j = -2000000; // 声明并初始化一个 int 类型变量 j，赋值为 -2000000</span><br></pre></td></tr></table></figure>
<p><strong>5）long </strong></p>
<p>long 的取值范围在 -9,223,372,036,854,775,808(-2^63) 和 9,223,372,036,854,775,807(2^63 -1)（含）之间。如果 int 存储不下，就用 long。代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">long l; // 声明一个 long 类型变量</span><br><span class="line">l = 100000000000L; // 将值 100000000000L 赋给变量 l（注意要加上 L 后缀）</span><br><span class="line">long m = -20000000000L; // 声明并初始化一个 long 类型变量 m，赋值为 -20000000000L</span><br></pre></td></tr></table></figure>
<p>为了和 int 作区分，long 型变量在声明的时候，末尾要带上大写的“L”。不用小写的“l”，是因为小写的“l”容易和数字“1”混淆。</p>
<p><strong>6）float </strong></p>
<p>float 是单精度的浮点数（单精度浮点数的有效数字大约为 6 到 7 位），32 位（4 字节），遵循 IEEE 754（二进制浮点数算术标准），取值范围为 1.4E-45 到 3.4E+38。float 不适合用于精确的数值，比如说金额。</p>
<p>代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">float f; // 声明一个 float 类型变量</span><br><span class="line">f = 3.14159f; // 将值 3.14159f 赋给变量 f（注意要加上 f 后缀）</span><br><span class="line">float g = -2.71828f; // 声明并初始化一个 float 类型变量 g，赋值为 -2.71828f</span><br></pre></td></tr></table></figure>
<p>为了和 double 作区分，float 型变量在声明的时候，末尾要带上小写的“f”。不需要使用大写的“F”，是因为小写的“f”很容易辨别。</p>
<p><strong>7）double </strong></p>
<p>double 是双精度浮点数（双精度浮点数的有效数字大约为 15 到 17 位），占 64 位（8 字节），也遵循 IEEE 754 标准，取值范围大约 ±4.9E-324 到 ±1.7976931348623157E308。double 同样不适合用于精确的数值，比如说金额。</p>
<p>代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double myDouble = 3.141592653589793;</span><br></pre></td></tr></table></figure>
<p>在进行金融计算或需要精确小数计算的场景中，可以使用 BigDecimal 类来避免浮点数舍入误差。</p>
<p>BigDecimal 可以表示一个任意大小且精度完全准确的浮点数。</p>
<blockquote>
<p>在实际开发中，如果不是特别大的金额（精确到 0.01 元，也就是一分钱），一般建议乘以 100 转成整型进行处理。</p>
</blockquote>
<p><strong>8）char </strong></p>
<p>char 用于表示 Unicode 字符，占 16 位（2 字节）的存储空间，取值范围为 0 到 65,535。</p>
<p>代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char letterA = &#x27;A&#x27;; // 用英文的单引号包裹住。</span><br></pre></td></tr></table></figure>
<p>注意，字符字面量应该用单引号（’’）包围，而不是双引号（””），因为<strong>双引号表示字符串字面量。</strong></p>
<p><strong>03、单精度和双精度 </strong></p>
<p>单精度（single-precision）和双精度（double-precision）是指两种不同精度的浮点数表示方法。单精度是这样的格式，1 位符号，8 位指数，23 位小数。</p>
<p><img src="\assets\note\image-20230925112500528.png" alt="image-20230925112500528"></p>
<p>单精度浮点数通常占用 32 位（4 字节）存储空间。数值范围大约是 ±1.4E-45 到 ±3.4028235E38，精度大约为 6 到 9 位有效数字。</p>
<p>双精度是这样的格式，1 位符号，11 位指数，52 为小数。</p>
<p><img src="\assets\note\image-20230925112546756.png" alt="image-20230925112546756"></p>
<p>双精度浮点数通常占用 64 位（8 字节）存储空间，数值范围大约是 ±4.9E-324 到 ±1.7976931348623157E308，精度大约为 15 到 17 位有效数字。</p>
<p>计算精度取决于小数位（尾数）。小数位越多，则能表示的数越大，那么计算精度则越高。</p>
<p>一个数由若干位数字组成，其中影响测量精度的数字称作有效数字，也称有效数位。有效数字指科学计算中用以表示一个浮点数精度的那些数字。一般地，指一个用小数形式表示的浮点数中，从第一个非零的数字算起的所有数字。如 1.24 和 0.00124 的有效数字都有 3 位。</p>
<p>以下是确定有效数字的一些基本规则：</p>
<ul>
<li>非零数字总是有效的。</li>
<li>位于两个非零数字之间的零是有效的。</li>
<li>对于小数，从左侧开始的第一个非零数字之前的零是无效的。</li>
<li>对于整数，从右侧开始的第一个非零数字之后的零是无效的。</li>
</ul>
<p>下面是一些示例，说明如何确定有效数字：</p>
<ul>
<li>1234：4 个有效数字（所有数字都是非零数字）</li>
<li>1002：4 个有效数字（零位于两个非零数字之间）</li>
<li>0.00234：3 个有效数字（从左侧开始的前两个零是无效的）</li>
<li>1200：2 个有效数字（从右侧开始的两个零是无效的）</li>
</ul>
<p><strong>04、int 和 char 类型互转 </strong></p>
<p>int 和 char 之间比较特殊，可以互转，也会在以后的学习当中经常遇到。</p>
<p>1）可以通过强制类型转换将整型 int 转换为字符 char。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int value_int = 65;</span><br><span class="line">char value_char  = (char) value_int;</span><br><span class="line">System.out.println(value_char);</span><br></pre></td></tr></table></figure>
<p>输出 A (其 ASCII 值可以通过整数 65 来表示)。</p>
<p>2）可以使用 Character.forDigit() 方法将整型 int 转换为字符 char，参数 radix 为基数，十进制为 10，十六进制为 16。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int radix = 10;</span><br><span class="line">int value_int = 6;</span><br><span class="line">char value_char = Character.forDigit(value_int , radix);</span><br><span class="line">System.out.println(value_char );</span><br></pre></td></tr></table></figure>
<p>Character 为 char 的包装器类型。我们随后会讲。</p>
<p>3）可以使用 int 的包装器类型 Integer 的 toString() 方法+String 的 charAt() 方法转成 char。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int value_int = 1;</span><br><span class="line">char value_char = Integer.toString(value_int).charAt(0);</span><br><span class="line">System.out.println(value_char );</span><br></pre></td></tr></table></figure>
<p>4）char 转 int</p>
<p>当然了，如果只是简单的 char 转 int，直接赋值就可以了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure>
<p>因为发生了自动类型转换，后面会细讲。</p>
<p><strong>05、包装器类型 </strong></p>
<p>包装器类型（Wrapper Types）是 Java 中的一种特殊类型，用于将基本数据类型（如 int、float、char 等）转换为对应的对象类型。</p>
<ul>
<li>Java 提供了以下包装器类型，与基本数据类型一一对应：</li>
<li>Byte（对应 byte）</li>
<li>Short（对应 short）</li>
<li>Integer（对应 int）</li>
<li>Long（对应 long）</li>
<li>Float（对应 float）</li>
<li>Double（对应 double）</li>
<li>Character（对应 char）</li>
<li>Boolean（对应 boolean）</li>
</ul>
<p>包装器类型允许我们使用基本数据类型提供的各种实用方法，并兼容需要对象类型的场景。例如，我们可以使用 Integer 类的 parseInt 方法将字符串转换为整数，或使用 Character 类的 isDigit 方法检查字符是否为数字，还有前面提到的 Character.forDigit() 方法。</p>
<p>下面是一个简单的示例，演示了如何使用包装器类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 使用 Integer 包装器类型</span><br><span class="line">Integer integerValue = new Integer(42);</span><br><span class="line">System.out.println(&quot;整数值: &quot; + integerValue);</span><br><span class="line">// 将字符串转换为整数</span><br><span class="line">String numberString = &quot;123&quot;;</span><br><span class="line">int parsedNumber = Integer.parseInt(numberString);</span><br><span class="line">System.out.println(&quot;整数值: &quot; + parsedNumber);</span><br><span class="line">// 使用 Character 包装器类型</span><br><span class="line">Character charValue = new Character(&#x27;A&#x27;);</span><br><span class="line">System.out.println(&quot;字符: &quot; + charValue);</span><br><span class="line">// 检查字符是否为数字</span><br><span class="line">char testChar = &#x27;9&#x27;;</span><br><span class="line">if (Character.isDigit(testChar)) &#123;</span><br><span class="line">System.out.println(&quot;字符是个数字.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的示例中，我们创建了一个 Integer 类型的对象 integerValue 并为其赋值 42。然后，我们将其值打印到控制台。</p>
<p>我们有一个包含数字的字符串 numberString。我们使用 Integer.parseInt() 方法将其转换为整数 parsedNumber。然后，我们将转换后的值打印到控制台。</p>
<p>我们有一个字符变量 testChar，并为其赋值字符 ‘9’。我们使用 Character.isDigit() 方法检查 testChar 是否为数字字符。如果是数字字符，我们将输出一条消息到控制台。</p>
<p>从 Java 5 开始，自动装箱（Autoboxing）和自动拆箱（Unboxing）机制允许我们在基本数据类型和包装器类型之间自动转换，无需显式地调用构造方法或转换方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer integerValue = 42; // 自动装箱，等同于 new Integer(42)</span><br><span class="line">int primitiveValue = integerValue; // 自动拆箱，等同于 integerValue.intValue()</span><br></pre></td></tr></table></figure>
<p><strong>06、引用数据类型 </strong></p>
<p>基本数据类型在作为成员变量和静态变量的时候有默认值，引用数据类型也有的（学完数组&amp;字符串，以及面向对象编程后会更加清楚，这里先简单过一下）。</p>
<p>String 是最典型的引用数据类型，所以我们就拿 String 类举例，看下面这段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author 微信搜「二哈进阶之路」</span><br><span class="line"> */</span><br><span class="line">public class LocalRef &#123;</span><br><span class="line">    private String a;</span><br><span class="line">    static String b;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        LocalRef lv = new LocalRef();</span><br><span class="line">        System.out.println(lv.a);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">null</span><br><span class="line">null</span><br></pre></td></tr></table></figure>
<p>null 在 Java 中是一个很神奇的存在，在你以后的程序生涯中，见它的次数不会少，尤其是伴随着令人烦恼的“空指针异常”，也就是所谓的 NullPointerException 。</p>
<p>也就是说，引用数据类型的默认值为 null，包括数组和接口。</p>
<p>那你是不是很好奇，为什么数组和接口也是引用数据类型啊？</p>
<p>先来看数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int [] arrays = &#123;1,2,3&#125;;</span><br><span class="line">System.out.println(arrays);</span><br></pre></td></tr></table></figure>
<p>arrays 是一个 int 类型的数组，对吧？打印结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[I@2d209079</span><br></pre></td></tr></table></figure>
<p>[I 表示数组是 int 类型的，@ 后面是十六进制的 hashCode——这样的打印结果太“人性化”了，一般人表示看不懂！为什么会这样显示呢？查看一下 java.lang.Object 类的 toString() 方法就明白了。</p>
<p><img src="\assets\note\image-20230925114234571.png" alt="image-20230925114234571"></p>
<p>数组虽然没有显式定义成一个类，但它的确是一个对象，继承了祖先类 Object 的所有方法。那为什么数组不单独定义一个类来表示呢？就像字符串 String 类那样呢？</p>
<p>一个合理的解释是 Java 将其隐藏了。假如真的存在一个 Array.java，我们也可以假想它真实的样子，它必须要定义一个容器来存放数组的元素，就像 String 类那样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final class String</span><br><span class="line">    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    /** The value is used for character storage. */</span><br><span class="line">    private final char value[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数组内部定义数组？没必要的！</p>
<p>再来看接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>
<p>List 是一个非常典型的接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public interface List&lt;E&gt; extends Collection&lt;E&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>而 ArrayList 是 List 接口的一个实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class="line">        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>对于接口类型的引用变量来说，你没法直接 new 一个：</p>
<p><img src="\assets\note\image-20230925114445179.png" alt="image-20230925114445179"></p>
<p>只能 new 一个实现它的类的对象——那自然接口也是引用数据类型了。</p>
<p>来看一下基本数据类型和引用数据类型之间最大的差别。</p>
<p>基本数据类型：</p>
<ul>
<li>变量名指向具体的数值。</li>
<li>基本数据类型存储在栈上。</li>
</ul>
<p>引用数据类型：</p>
<ul>
<li>变量名指向的是存储对象的内存地址，在栈上。</li>
<li>内存地址指向的对象存储在堆上。</li>
</ul>
<p><strong>07、堆和栈 </strong></p>
<p>堆是堆（heap），栈是栈（stack），如果看到“堆栈”的话，请不要怀疑自己，那是翻译的错，堆栈也是栈，反正我很不喜欢“堆栈”这种叫法，容易让新人掉坑里。</p>
<p>堆是在程序运行时在内存中申请的空间（可理解为动态的过程）；切记，不是在编译时；因此，Java 中的对象就放在这里，这样做的好处就是：</p>
<blockquote>
<p>当需要一个对象时，只需要通过 new 关键字写一行代码即可，当执行这行代码时，会自动在内存的“堆”区分配空间——这样就很灵活。</p>
</blockquote>
<p>栈，能够和处理器（CPU，也就是脑子）直接关联，因此访问速度更快。既然访问速度快，要好好利用啊！Java 就把对象的引用放在栈里。为什么呢？因为引用的使用频率高吗？</p>
<p>不是的，因为 Java 在编译程序时，必须明确的知道存储在栈里的东西的生命周期，否则就没法释放旧的内存来开辟新的内存空间存放引用——空间就那么大，前浪要把后浪拍死在沙滩上啊。</p>
<p>这么说就理解了吧？</p>
<p>用图来表示一下，左侧是栈，右侧是堆。</p>
<p><img src="\assets\note\image-20230925114753308.png" alt="image-20230925114753308"></p>
<p>这里再补充一些额外的知识点，能看懂就继续吸收，看不懂可以先去学下一节，以后再来补，没关系的。学习就是这样，可以跳过，可以温故。</p>
<p>举个例子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String a = new String(&quot;沉默&quot;)</span><br></pre></td></tr></table></figure>
<p>这段代码会先在堆里创建一个 沉默的字符串对象，然后再把对象的引用 a 放到栈里面。这里面还会涉及到字符串常量池，后面会讲。</p>
<p>那么对于这样一段代码，有基本数据类型的变量，有引用类型的变量，堆和栈都是如何存储他们的呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void test()</span><br><span class="line">&#123;</span><br><span class="line">    int i = 4;</span><br><span class="line">    int y = 2;</span><br><span class="line">    Object o1 = new Object();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我来画个图表示下。</p>
<p><img src="\assets\note\image-20230925114943142.png" alt="image-20230925114943142"></p>
<p><strong>08、小结 </strong></p>
<p>本文详细探讨了 Java 数据类型，包括比特与字节、基本数据类型、单精度与双精度、int 与 char 互转、包装器类型、引用数据类型以及堆与栈的内存模型。通过阅读本文，你将全面了解 Java 数据类型的概念与使用方法，为 Java 编程打下坚实基础。</p>
<h2 id="1-4-Java数据类型转换"><a href="#1-4-Java数据类型转换" class="headerlink" title="1.4 Java数据类型转换"></a>1.4 Java数据类型转换</h2><p>数据类型转换的目的是确保在表达式求值时，不同类型的数据能够相互兼容。</p>
<p><strong>01、自动类型转换 </strong></p>
<p>自动类型转换（自动类型提升）是 Java 编译器在不需要显式转换的情况下，将一种基本数据类型自动转换为另一种基本数据类型的过程。这种转换通常发生在表达式求值期间，当不同类型的数据需要相互兼容时。自动类型转换遵循以下规则：</p>
<ul>
<li>如果任何操作数是 double 类型，其他操作数将被转换为 double 类型。</li>
<li>否则，如果任何操作数是 float 类型，其他操作数将被转换为 float 类型。</li>
<li>否则，如果任何操作数是 long 类型，其他操作数将被转换为 long 类型。</li>
<li>否则，所有操作数将被转换为 int 类型。</li>
</ul>
<p>需要注意的是，自动类型转换只发生在兼容类型之间。例如，从较小的数据类型（如 int）到较大的数据类型（如 long 或 double）的转换是安全的，因为较大的数据类型可以容纳较小数据类型的所有可能值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">byte -&gt; short -&gt; int -&gt; long -&gt; float -&gt; double</span><br><span class="line">char -&gt; int -&gt; long -&gt; float -&gt; double</span><br></pre></td></tr></table></figure>
<p>下面是一个简单的示例，演示了自动类型转换：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int intValue = 5;</span><br><span class="line">double doubleValue = 2.5;</span><br><span class="line">// 自动类型转换：intValue 被转换为 double 类型</span><br><span class="line">double result = intValue * doubleValue;</span><br><span class="line">System.out.println(&quot;结果: &quot; + result); // 输出：结果: 12.5</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们有一个 int 类型的变量 intValue 和一个 double 类型的变量 doubleValue。当我们将它们相乘时，根据自动类型转换的规则，intValue 将被转换为 double 类型，以便将两个 double 类型的操作数相乘。最终结果将是一个 double 类型的值：12.5。</p>
<p>再来举个例子，顾客到超市购物，购买牙膏 2 盒，面巾纸 4 盒。其中牙膏的价格是 10.9 元，面巾纸的价格是 5.8 元，求商品总价格。实现代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">float price1 = 10.9f; // 定义牙膏的价格，单精度浮点型float</span><br><span class="line">double price2 = 5.8; // 定义面巾纸的价格，双精度浮点型double</span><br><span class="line">int num1 = 2; // 定义牙膏的数量，整型 int</span><br><span class="line">int num2 = 4; // 定义面巾纸的数量</span><br><span class="line">double res = price1 * num1 + price2 * num2; // 计算总价</span><br><span class="line">System.out.println(&quot;一共付给收银员&quot; + res + &quot;元&quot;); // 输出总价</span><br></pre></td></tr></table></figure>
<p>上述代码中首先定义了一个 float 类型的变量存储牙膏的价格，然后定义了一个 double 类型的变量存储面巾纸的价格，再定义两个 int 类型的变量存储物品的数量，最后进行了乘运算以及和运算之后，将结果储存在一个 double 类型的变量中进行输出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一共付给收银员44.99999923706055元</span><br></pre></td></tr></table></figure>
<p>从执行结果看出，float、int 和 double 三种数据类型参与运算，最后输出的结果为 double 类型的数据。这种转换一般称为“表达式中类型的自动提升”。</p>
<p>自动类型提升有好处，但它也会引起令人疑惑的编译错误。例如，下面看起来正确的程序却会引起问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">byte b = 50;</span><br><span class="line">b = b * 2; // Type mismatch: cannot convert from int to byte</span><br></pre></td></tr></table></figure>
<p>如上所示，第二行会报“类型不匹配：无法从int转换为byte”错误。</p>
<p>该程序试图将一个完全合法的 byte 型的值 50*2 存储给一个 byte 型的变量。但是当表达式求值的时候，操作数被自动的提升为 int 型，计算结果也被提升为 int 型。这样表达式的结果现在是 int 型，不强制转换它就不能被赋为 byte 型。</p>
<p>所以应该使用一个显示的强制类型转换，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">byte b = 50;</span><br><span class="line">b = (byte)(b*2);</span><br></pre></td></tr></table></figure>
<p>这样就能产生正确的值 100。</p>
<p>注意：char 类型比较特殊，char 自动转换成 int、long、float 和 double，但 byte 和 short 不能自动转换为 char，而且 char 也不能自动转换为 byte 或 short。</p>
<p><strong>02、强制类型转换 </strong></p>
<p>强制类型转换是 Java 中将一种数据类型显式转换为另一种数据类型的过程。与自动类型转换不同，强制类型转换需要程序员显式地指定要执行的转换。强制类型转换在以下情况中可能需要：</p>
<ul>
<li>将较大的数据类型转换为较小的数据类型。</li>
<li>将浮点数转换为整数。</li>
<li>将字符类型转换为数值类型。</li>
</ul>
<p>需要注意的是，强制类型转换可能会导致数据丢失或精度降低，因为目标类型可能无法容纳原始类型的所有可能值。因此，在进行强制类型转换时，需要确保转换后的值仍然在目标类型的范围内。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double -&gt; float -&gt; long -&gt; int -&gt; char -&gt; short -&gt; byte</span><br></pre></td></tr></table></figure>
<p>以下是一个简单的示例，演示了强制类型转换：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">double doubleValue = 42.8;</span><br><span class="line">// 强制类型转换：将 double 类型转换为 int 类型</span><br><span class="line">int intValue = (int) doubleValue;</span><br><span class="line">System.out.println(&quot;整数值: &quot; + intValue); // 输出：整数值: 42</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们有一个 double 类型的变量 doubleValue。我们希望将其转换为 int 类型的变量 intValue。为此，我们使用强制类型转换语法，即在要转换的变量之前加上目标类型的括号（如 (int)）。</p>
<p>需要注意的是，将 doubleValue 转换为 int 类型时，小数部分将被截断。因此，输出结果将是：Integer value: 42。在这种情况下，精度丢失是可以接受的，但在其他情况下，我们可能需要更加小心地处理类型转换以避免数据丢失。</p>
<p>顾客到超市购物，购买牙膏 2 盒，面巾纸 4 盒。其中牙膏的价格是 10.9 元，面巾纸的价格是 5.8 元，求商品总价格，在计算总价时采用 int 类型的数据进行存储。实现代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">float price1 = 10.9f;</span><br><span class="line">double price2 = 5.8;</span><br><span class="line">int num1 = 2;</span><br><span class="line">int num2 = 4;</span><br><span class="line">int res2 = (int) (price1 * num1 + price2 * num2);</span><br><span class="line">System.out.println(&quot;一共付给收银员&quot; + res2 + &quot;元&quot;);</span><br></pre></td></tr></table></figure>
<p>在上述实例中，有 double 类型、float 类型和 int 类型的数据参与运算，其运算结果默认为 double 类型，题目要求的结果为 int 类型，因为 int 类型的取值范围要小于 double 类型的取值范围，所以需要进行强制类型转换。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一共付给收银员44元</span><br></pre></td></tr></table></figure>
<h2 id="1-5-Java基本数据类型缓存池"><a href="#1-5-Java基本数据类型缓存池" class="headerlink" title="1.5 Java基本数据类型缓存池"></a>1.5 Java基本数据类型缓存池</h2><p>“考你一个问题哈： new Integer(18) 与 Integer.valueOf(18) 的区别是什么？”</p>
<p>new Integer(18) 每次都会新建一个对象;</p>
<p>Integer.valueOf(18) 会使⽤用缓存池中的对象，多次调用只会取同⼀一个对象的引用。</p>
<p>来看下面这段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Integer x = new Integer(18);</span><br><span class="line">Integer y = new Integer(18);</span><br><span class="line">System.out.println(x == y);</span><br><span class="line">Integer z = Integer.valueOf(18);</span><br><span class="line">Integer k = Integer.valueOf(18);</span><br><span class="line">System.out.println(z == k);</span><br><span class="line">Integer m = Integer.valueOf(300);</span><br><span class="line">Integer p = Integer.valueOf(300);</span><br><span class="line">System.out.println(m == p);</span><br></pre></td></tr></table></figure>
<p>来看一下输出结果吧：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure>
<p>“第一个 false，我知道原因，因为 new 出来的是不同的对象，地址不同。”“第二个和第三个我认为都应该是 true 啊，为什么第三个会输出 false 呢？这个我理解不了。”</p>
<p>“其实原因也很简单。”我胸有成竹地说。</p>
<p>基本数据类型的包装类除了 Float 和 Double 之外，其他六个包装器类（Byte、Short、Integer、Long、Character、Boolean）都有常量缓存池。</p>
<ul>
<li>Byte：-128~127，也就是所有的 byte 值</li>
<li>Short：-128~127</li>
<li>Long：-128~127</li>
<li>Character：\u0000 - \u007F</li>
<li>Boolean：true 和 false</li>
</ul>
<p>拿 Integer 来举例子，Integer 类内部中内置了 256 个 Integer 类型的缓存数据，当使用的数据范围在 -128~127 之间时，会直接返回常量池中数据的引用，而不是创建对象，超过这个范围时会创建新的对象。</p>
<p>18 在 -128~127 之间，300 不在。</p>
<p>来看一下 valueOf 方法的源码吧。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static Integer valueOf(int i) &#123;</span><br><span class="line">    if (i &gt;=IntegerCache.low &amp;&amp; i &lt;=IntegerCache.high)</span><br><span class="line">        return IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    return new Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“哦，原来是因为 Integer.IntegerCache 这个内部类的原因啊！”</p>
<p>“是滴。来看一下 IntegerCache 这个静态内部类的源码吧。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private static class IntegerCache &#123;</span><br><span class="line">    static final int low = -128;</span><br><span class="line">    static final int high;</span><br><span class="line">    static final Integer cache[];</span><br><span class="line">    static &#123;</span><br><span class="line">        // high value may be configured by property</span><br><span class="line">        int h = 127;</span><br><span class="line">        String integerCacheHighPropValue =</span><br><span class="line">                sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);</span><br><span class="line">        if (integerCacheHighPropValue != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                int i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, 127);</span><br><span class="line">                // Maximum array size is Integer.MAX_VALUE</span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -1);</span><br><span class="line">            &#125; catch( NumberFormatException nfe) &#123;</span><br><span class="line">                // If the property cannot be parsed into an int, ignore it.</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line">        cache = new Integer[(high - low) + 1];</span><br><span class="line">        int j = low;</span><br><span class="line">        for(int k = 0; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = new Integer(j++);</span><br><span class="line">        // range [-128, 127] must be interned (JLS7 5.1.7)</span><br><span class="line">        assert Integer.IntegerCache.high &gt;= 127;</span><br><span class="line">    &#125;</span><br><span class="line">    private IntegerCache() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>详细解释下：当我们通过 Integer.valueOf() 方法获取整数对象时，会先检查该整数是否在 IntegerCache 中，如果在，则返回缓存中的对象，否则创建一个新的对象并缓存起来。</p>
<p>需要注意的是，如果使用 new Integer() 创建对象，即使值在 -128 到 127 范围内，也不会被缓存，每次都会创建新的对象。因此，推荐使用 Integer.valueOf() 方法获取整数对象。</p>
<p>学习 static 关键字的时候，会详细解释静态代码块，你暂时先记住，<strong>静态代码块通常用来初始化一些静态变量，它会优先于 main() 方法执行</strong>。</p>
<p>在静态代码块中，low 为 -128，也就是缓存池的最小值；high 默认为 127，也就是缓存池的最大值，共计 256 个。</p>
<p>可以在 JVM 启动的时候，通过 -XX:AutoBoxCacheMax=NNN来设置缓存池的大小，当然了，不能无限大，最大到 Integer.MAX_VALUES - 129</p>
<p>之后，初始化 cache 数组的大小，然后遍历填充，下标从 0 开始。</p>
<p>“这段代码不难理解，难理解的是 assert Integer.IntegerCache.high &gt;= 127; ，这行代码是干嘛的呀？”</p>
<p>assert 是 Java 中的一个关键字，寓意是断言，为了方便调试程序，并不是发布程序的组成部分。</p>
<p>默认情况下，断言是关闭的，可以在命令行运行 Java 程序的时候加上 -ea 参数打开断言。</p>
<p>来看这段代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class AssertTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int high = 126;</span><br><span class="line">        assert high &gt;= 127;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设手动设置的缓存池大小为 126，显然不太符合缓存池的预期值 127，结果会输出什么呢？直接在 Intellij IDEA 中打开命令行终端，进入 classes 文件，执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/libexec/java_home -v 1.8 --exec java -ea com.itwanger.s51.AssertTest</span><br></pre></td></tr></table></figure>
<p>我用的 macOS 环境，装了好多个版本的 JDK，该命令可以切换到 JDK 8</p>
<p>也可以不指定 Java 版本直接执行（加上 -ea 参数）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -ea com.itwanger.s51.AssertTest</span><br></pre></td></tr></table></figure>
<p>“呀，报错了呀。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.AssertionError</span><br><span class="line">        at com.itwanger.s51.AssertTest.main(AssertTest.java:9)</span><br></pre></td></tr></table></figure>
<p>“是滴，因为 126 小于 127。”</p>
<p>“原来 assert 是这样用的啊，我明白了。”</p>
<p>在 Java 中，针对一些基本数据类型（如 Integer、Long、Boolean 等），Java 会在程序启动时创建一些常用的对象并缓存在内存中，以提高程序的性能和节省内存开销。这些常用对象被缓存在一个固定的范围内，超出这个范围的值会被重新创建新的对象。</p>
<p>使用数据类型缓存池可以有效提高程序的性能和节省内存开销，但需要注意的是，在特定的业务场景下，缓存池可能会带来一些问题，例如缓存池中的对象被不同的线程同时修改，导致数据错误等问题。因此，在实际开发中，需要根据具体的业务需求来决定是否使用数据类型缓存池。</p>
<h2 id="1-6-Java运算符"><a href="#1-6-Java运算符" class="headerlink" title="1.6 Java运算符"></a>1.6 Java运算符</h2><p>运算符在 Java 中占据着重要的位置，对程序的执行有着很大的帮助。除了常见的加减乘除，还有许多其他类型的运算符，来看下面这张思维导图。”</p>
<p><img src="\assets\note\image-20230925135407003.png" alt="image-20230925135407003"></p>
<p><strong>01、算术运算符 </strong></p>
<p>算术运算符除了最常见的加减乘除，还有一个取余的运算符，用于得到除法运算后的余数，来串代码感受下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int a = 10;</span><br><span class="line">int b = 5;</span><br><span class="line">System.out.println(a + b);//15</span><br><span class="line">System.out.println(a - b);//5</span><br><span class="line">System.out.println(a * b);//50</span><br><span class="line">System.out.println(a / b);//2</span><br><span class="line">System.out.println(a % b);//0</span><br><span class="line">b = 3;</span><br><span class="line">System.out.println(a + b);//13</span><br><span class="line">System.out.println(a - b);//7</span><br><span class="line">System.out.println(a * b);//30</span><br><span class="line">System.out.println(a / b);//3</span><br><span class="line">System.out.println(a % b);//1</span><br></pre></td></tr></table></figure>
<p>对于初学者来说，加法（+）、减法（-）、乘法（*）很好理解，但除法（/）和取余（%）会有一点点疑惑。在以往的认知里，10/3 是除不尽的，结果应该是 3.333333…，而不应该是 3。相应的，余数也不应该是 1。这是为什么呢？</p>
<p>因为数字在程序中可以分为两种，一种是整型，一种是浮点型（不清楚的同学可以回头看看数据类型那篇），整型和整型的运算结果就是整型，不会出现浮点型。否则，就会出现浮点型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int a = 10;</span><br><span class="line">float c = 3.0f;</span><br><span class="line">double d = 3.0;</span><br><span class="line">System.out.println(a / c); // 3.3333333</span><br><span class="line">System.out.println(a / d); // 3.3333333333333335</span><br><span class="line">System.out.println(a % c); // 1.0</span><br><span class="line">System.out.println(a % d); // 1.0</span><br></pre></td></tr></table></figure>
<p>需要注意的是，当浮点数除以 0 的时候，结果为 Infinity 或者 NaN。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(10.0 / 0.0); // Infinity</span><br><span class="line">System.out.println(0.0 / 0.0); // NaN</span><br></pre></td></tr></table></figure>
<p>Infinity 的中文意思是无穷大，NaN 的中文意思是这不是一个数字（Not a Number）。</p>
<p>当整数除以 0 的时候（ 10 / 0 ），会抛出异常：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.ArithmeticException: / by zero</span><br><span class="line">    at com.itwanger.eleven.ArithmeticOperator.main(ArithmeticOperator.java:32)</span><br></pre></td></tr></table></figure>
<p>所以整数在进行除法运算时，需要先判断除数是否为 0，以免程序抛出异常。</p>
<p>算术运算符中还有两种特殊的运算符，自增运算符（++）和自减运算符（—），它们也叫做一元运算符，只有一个操作数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int x = 10;</span><br><span class="line">System.out.println(x++);//10 (11)  </span><br><span class="line">System.out.println(++x);//12  </span><br><span class="line">System.out.println(x--);//12 (11)  </span><br><span class="line">System.out.println(--x);//10 </span><br></pre></td></tr></table></figure>
<p>一元运算符可以放在数字的前面或者后面，放在前面叫前自增（前自减），放在后面叫后自增（后自减）。</p>
<p>前自增和后自增是有区别的，拿 int y = ++x 这个表达式来说（x = 10），它可以拆分为 x = x+1 = 11; y = x = 11 ，所以表达式的结果为 x = 11, y = 11 。拿 int y = x++ 这个表达式来说（x = 10），它可以拆分为 y = x = 10; x = x+1 = 11 ，所以表达式的结果为 x = 11, y = 10 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int x = 10;</span><br><span class="line">int y = ++x;</span><br><span class="line">System.out.println(y + &quot; &quot; + x);// 11 11</span><br><span class="line">x = 10;</span><br><span class="line">y = x++;</span><br><span class="line">System.out.println(y + &quot; &quot; + x);// 10 11</span><br></pre></td></tr></table></figure>
<p>对于前自减和后自减来说，你可以自己试一把。</p>
<p><strong>02、关系运算符 </strong></p>
<p>关系运算符用来比较两个操作数，返回结果为 true 或者 false。</p>
<p><img src="\assets\note\image-20230926134500081.png" alt="image-20230926134500081"></p>
<p>来看示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int a = 10, b = 20;</span><br><span class="line">System.out.println(a == b); // false</span><br><span class="line">System.out.println(a != b); // true</span><br><span class="line">System.out.println(a &gt; b); // false</span><br><span class="line">System.out.println(a &lt; b); // true</span><br><span class="line">System.out.println(a &gt;= b); // false</span><br><span class="line">System.out.println(a &lt;= b); // true</span><br></pre></td></tr></table></figure>
<p><strong>03、位运算符 </strong></p>
<p>在学习位运算符之前，需要先学习一下二进制，因为位运算符操作的不是整型数值（int、long、short、char、byte）本身，而是整型数值对应的二进制。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Integer.toBinaryString(60)); // 111100</span><br><span class="line">System.out.println(Integer.toBinaryString(13)); // 1101</span><br></pre></td></tr></table></figure>
<p>从程序的输出结果可以看得出来，60 的二进制是 0011 1100（用 0 补到 8 位），13 的二进制是 0000 1101。</p>
<p>PS：现代的二进制记数系统由戈特弗里德·威廉·莱布尼茨于 1679 年设计。莱布尼茨是德意志哲学家、数学家，历史上少见的通才。</p>
<p><img src="\assets\note\image-20230926134711867.png" alt="image-20230926134711867"></p>
<p>来看示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int a = 60, b = 13;</span><br><span class="line">System.out.println(&quot;a 的二进制：&quot; + Integer.toBinaryString(a)); // 111100</span><br><span class="line">System.out.println(&quot;b 的二进制：&quot; + Integer.toBinaryString(b)); // 1101</span><br><span class="line">int c = a &amp; b;</span><br><span class="line">System.out.println(&quot;a &amp; b：&quot; + c + &quot;，二进制是：&quot; + Integer.toBinaryString(c));</span><br><span class="line">c = a | b;</span><br><span class="line">System.out.println(&quot;a | b：&quot; + c + &quot;，二进制是：&quot; + Integer.toBinaryString(c));</span><br><span class="line">c = a ^ b;</span><br><span class="line">System.out.println(&quot;a ^ b：&quot; + c + &quot;，二进制是：&quot; + Integer.toBinaryString(c));</span><br><span class="line">c = ~a;</span><br><span class="line">System.out.println(&quot;~a：&quot; + c + &quot;，二进制是：&quot; + Integer.toBinaryString(c));</span><br><span class="line">c = a &lt;&lt; 2;</span><br><span class="line">System.out.println(&quot;a &lt;&lt; 2：&quot; + c + &quot;，二进制是：&quot; + Integer.toBinaryString(c));</span><br><span class="line">c = a &gt;&gt; 2;</span><br><span class="line">System.out.println(&quot;a &gt;&gt; 2：&quot; + c + &quot;，二进制是：&quot; + Integer.toBinaryString(c));</span><br><span class="line">c = a &gt;&gt;&gt; 2;</span><br><span class="line">System.out.println(&quot;a &gt;&gt;&gt; 2：&quot; + c + &quot;，二进制是：&quot; + Integer.toBinaryString(c));</span><br></pre></td></tr></table></figure>
<p>对于初学者来说，位运算符无法从直观上去计算出结果，不像加减乘除那样。因为我们日常接触的都是十进制，位运算的时候需要先转成二进制，然后再计算出结果。</p>
<p>鉴于此，初学者在写代码的时候其实很少会用到位运算。对于编程高手来说，为了提高程序的性能，会在一些地方使用位运算。比如说，HashMap 在计算哈希值的时候：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果对位运算一点都不懂的话，遇到这样的源码就很吃力。所以说，虽然位运算用的少，但还是要懂。</p>
<p>1）按位左移运算符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(10&lt;&lt;2);//10*2^2=10*4=40  </span><br><span class="line">System.out.println(10&lt;&lt;3);//10*2^3=10*8=80  </span><br><span class="line">System.out.println(20&lt;&lt;2);//20*2^2=20*4=80  </span><br><span class="line">System.out.println(15&lt;&lt;4);//15*2^4=15*16=240 </span><br></pre></td></tr></table></figure>
<p>10&lt;&lt;2 等于 10 乘以 2 的 2 次方； 10&lt;&lt;3 等于 10 乘以 2 的 3 次方。</p>
<p>2）按位右移运算符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(10&gt;&gt;2);//10/2^2=10/4=2</span><br><span class="line">System.out.println(20&gt;&gt;2);//20/2^2=20/4=5</span><br><span class="line">System.out.println(20&gt;&gt;3);//20/2^3=20/8=2</span><br></pre></td></tr></table></figure>
<p>10&gt;&gt;2 等于 10 除以 2 的 2 次方； 20&gt;&gt;2 等于 20 除以 2 的 2 次方。</p>
<p><strong>04、逻辑运算符 </strong></p>
<p>逻辑与运算符（&amp;&amp;）：多个条件中只要有一个为 false 结果就为 false。</p>
<p>逻辑或运算符（||）：多个条件只要有一个为 true 结果就为 true。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a=10;</span><br><span class="line">int b=5;</span><br><span class="line">int c=20;</span><br><span class="line">System.out.println(a&lt;b&amp;&amp;a&lt;c);//false &amp;&amp; true = false</span><br><span class="line">System.out.println(a&gt;b||a&lt;c);//true || true = true</span><br></pre></td></tr></table></figure>
<p>逻辑非运算符（!）：用来反转条件的结果，如果条件为 true，则逻辑非运算符将得到 false。</p>
<p>单逻辑与运算符（&amp;）：很少用，因为不管第一个条件为 true 还是 false，依然会检查第二个。</p>
<p>单逻辑或运算符（|）：也会检查第二个条件。</p>
<p>也就是说，&amp; 和 | 性能不如 &amp;&amp; 和 ||，但用法一样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a=10;</span><br><span class="line">int b=5;</span><br><span class="line">int c=20;</span><br><span class="line">System.out.println(a&lt;b&amp;a&lt;c);//false &amp; true = false</span><br><span class="line">System.out.println(a&gt;b|a&lt;c);//true | true = true  </span><br></pre></td></tr></table></figure>
<p><strong>05、赋值运算符 </strong></p>
<p>赋值操作符恐怕是 Java 中使用最频繁的操作符了，它就是把操作符右侧的值赋值给左侧的变量。来看示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int a=10;</span><br><span class="line">int b=20;</span><br><span class="line">a+=4;//a=a+4 (a=10+4)  </span><br><span class="line">b-=4;//b=b-4 (b=20-4)  </span><br><span class="line">System.out.println(a);</span><br><span class="line">System.out.println(b);</span><br></pre></td></tr></table></figure>
<p>不过在进行数值的赋值时，需要小点心，比如说下面这种情况：</p>
<p><img src="\assets\note\image-20230926135245627.png" alt="image-20230926135245627"></p>
<p>编译器之所以提示错误，是因为 = 右侧的算术表达式默认为 int 类型，左侧是 short 类型的时候需要进行强转。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">short a = 10;</span><br><span class="line">short b = 10;</span><br><span class="line">//a+=b;//a=a+b internally so fine</span><br><span class="line">a = (short)(a + b);</span><br><span class="line">System.out.println(a);</span><br></pre></td></tr></table></figure>
<p>除此之外，还会有边界问题，比如说，两个非常大的 int 相乘，结果可能就超出了 int 的范围：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a = Integer.MAX_VALUE;</span><br><span class="line">int b = 10000;</span><br><span class="line">int c = a * b;</span><br><span class="line">System.out.println(c); // -10000</span><br></pre></td></tr></table></figure>
<p>程序输出的结果为 -10000，这个答案很明显不是我们想要的结果，虽然可以通过右侧表达式强转 long 的方法解决：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a = Integer.MAX_VALUE;</span><br><span class="line">int b = 10000;</span><br><span class="line">long c = (long)a * b;</span><br><span class="line">System.out.println(c); // 21474836470000</span><br></pre></td></tr></table></figure>
<p>但尽量不要这样做，结果非常大的时候，尽量提前使用相应的类型进行赋值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">long a = Integer.MAX_VALUE - 1;</span><br><span class="line">long b = 10000;</span><br><span class="line">long c = a * b;</span><br><span class="line">System.out.println(c); // 21474836460000</span><br></pre></td></tr></table></figure>
<p><strong>06、三元运算符 </strong></p>
<p>三元运算符用于替代 if-else，可以使用一行代码完成条件判断的要求。来看示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a=2;</span><br><span class="line">int b=5;</span><br><span class="line">int min=(a&lt;b)?a:b;</span><br><span class="line">System.out.println(min);</span><br></pre></td></tr></table></figure>
<p>如果 ? 前面的条件为 true，则结果为 : 前的值，否则为 : 后的值。</p>
<p><strong>07、小结 </strong></p>
<p>本文全面介绍了Java运算符，包括算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符等。通过阅读本文，您将了解到Java运算符的分类、用法和优先级，以及如何在实际开发中灵活运用各类运算符提高编程效率。</p>
<h2 id="1-7-Java流程控制语句"><a href="#1-7-Java流程控制语句" class="headerlink" title="1.7 Java流程控制语句"></a>1.7 Java流程控制语句</h2><p>“流程控制语句都有哪些呢？”</p>
<p>“比如说 if-else、switch、for、while、do-while、return、break、continue 等等，接下来，我们一个个来了解下。”</p>
<p><strong>01、if-else 相关</strong></p>
<p><img src="\assets\note\image-20230926135653439.png" alt="image-20230926135653439"></p>
<p>1）if 语句 </p>
<p>if 语句的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(布尔表达式)&#123;  </span><br><span class="line">// 如果条件为 true，则执行这块代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>画个流程图表示一下：</p>
<p><img src="\assets\note\image-20230926135814299.png" alt="image-20230926135814299"></p>
<p>来写个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int age = 20;</span><br><span class="line">if (age &lt; 30) &#123;</span><br><span class="line">    System.out.println(&quot;青春年华&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">青春年华</span><br></pre></td></tr></table></figure>
<p>2）if-else 语句 </p>
<p>if-else 语句的格式如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(布尔表达式)&#123;  </span><br><span class="line">// 条件为 true 时执行的代码块</span><br><span class="line">&#125;else&#123;  </span><br><span class="line">// 条件为 false  时执行的代码块</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>画个流程图表示一下：</p>
<p><img src="\assets\note\image-20230926135950470.png" alt="image-20230926135950470"></p>
<p>来写个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int age = 31;</span><br><span class="line">if (age &lt; 30) &#123;</span><br><span class="line">    System.out.println(&quot;青春年华&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    System.out.println(&quot;而立之年&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">而立之年</span><br></pre></td></tr></table></figure>
<p>除了这个例子之外，还有一个判断闰年（被 4 整除但不能被 100 整除或者被 400 整除）的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int year = 2020;</span><br><span class="line">if (((year % 4 == 0) &amp;&amp; (year % 100 != 0)) || (year % 400 == 0)) &#123;</span><br><span class="line">    System.out.println(&quot;闰年&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    System.out.println(&quot;普通年份&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">闰年</span><br></pre></td></tr></table></figure>
<p>如果执行语句比较简单的话，可以使用三元运算符来代替 if-else 语句，如果条件为 true，返回 ? 后面 : 前面的值；如果条件为 false，返回 : 后面的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int num = 13;</span><br><span class="line">String result = (num % 2 == 0) ? &quot;偶数&quot; : &quot;奇数&quot;;</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">奇数</span><br></pre></td></tr></table></figure>
<p>3）if-else-if 语句 </p>
<p>if-else-if 语句的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if(条件1)&#123;  </span><br><span class="line">// 条件1 为 true 时执行的代码</span><br><span class="line">&#125;else if(条件2)&#123;  </span><br><span class="line">// 条件2 为 true 时执行的代码</span><br><span class="line">&#125;  </span><br><span class="line">else if(条件3)&#123;  </span><br><span class="line">// 条件3 为 true 时执行的代码</span><br><span class="line">&#125;  </span><br><span class="line">...  </span><br><span class="line">else&#123;  </span><br><span class="line">// 以上条件均为 false 时执行的代码</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>画个流程图表示一下：</p>
<p><img src="\assets\note\image-20230926140244236.png" alt="image-20230926140244236"></p>
<p>来写个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int age = 31;</span><br><span class="line">if (age &lt; 30) &#123;</span><br><span class="line">    System.out.println(&quot;青春年华&quot;);</span><br><span class="line">&#125; else if (age &gt;= 30 &amp;&amp; age &lt; 40 ) &#123;</span><br><span class="line">    System.out.println(&quot;而立之年&quot;);</span><br><span class="line">&#125; else if (age &gt;= 40 &amp;&amp; age &lt; 50 ) &#123;</span><br><span class="line">    System.out.println(&quot;不惑之年&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    System.out.println(&quot;知天命&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">而立之年</span><br></pre></td></tr></table></figure>
<p>4）if 嵌套语句 </p>
<p>if 嵌套语句的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if(外侧条件)&#123;    </span><br><span class="line">     // 外侧条件为 true 时执行的代码 </span><br><span class="line">    if(内侧条件)&#123;  </span><br><span class="line">        // 内侧条件为 true 时执行的代码</span><br><span class="line">    &#125;    </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>画个流程图表示一下：</p>
<p><img src="\assets\note\image-20230926141351915.png" alt="image-20230926141351915"></p>
<p>来写个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int age = 20;</span><br><span class="line">boolean isGirl = true;</span><br><span class="line">if (age &gt;= 20) &#123;</span><br><span class="line">    if (isGirl) &#123;</span><br><span class="line">        System.out.println(&quot;女生法定结婚年龄&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">女生法定结婚年龄</span><br></pre></td></tr></table></figure>
<p><strong>02、switch 语句 </strong></p>
<p>switch 语句用来判断变量与多个值之间的相等性。变量的类型可以是 byte、short、int 或者 char，或者对应的包装器类型 Byte、Short、Integer、Character，以及字符串和枚举类型。</p>
<p>来看一下 switch 语句的格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">switch(变量) &#123;    </span><br><span class="line">case 可选值1:    </span><br><span class="line"> // 可选值1匹配后执行的代码;    </span><br><span class="line"> break;  // 该关键字是可选项</span><br><span class="line">case 可选值2:    </span><br><span class="line"> // 可选值2匹配后执行的代码;    </span><br><span class="line"> break;  // 该关键字是可选项</span><br><span class="line">......    </span><br><span class="line">    </span><br><span class="line">default: // 该关键字是可选项     </span><br><span class="line"> // 所有可选值都不匹配后执行的代码 </span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<ul>
<li>变量可以有 1 个或者 N 个值。</li>
<li>值类型必须和变量类型是一致的，并且值是确定的。</li>
<li>值必须是唯一的，不能重复，否则编译会出错。</li>
<li>break 关键字是可选的，如果没有，则执行下一个 case，如果有，则跳出 switch 语句。</li>
<li>default 关键字也是可选的。</li>
</ul>
<p>画个流程图：</p>
<p><img src="\assets\note\image-20230926141611240.png" alt="image-20230926141611240"></p>
<p>来个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int age = 20;</span><br><span class="line">switch (age) &#123;</span><br><span class="line">    case 20 :</span><br><span class="line">        System.out.println(&quot;上学&quot;);</span><br><span class="line">        break;</span><br><span class="line">    case 24 :</span><br><span class="line">        System.out.println(&quot;苏州工作&quot;);</span><br><span class="line">        break;</span><br><span class="line">    case 30 :</span><br><span class="line">        System.out.println(&quot;洛阳工作&quot;);</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        System.out.println(&quot;未知&quot;);</span><br><span class="line">        break; // 可省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">上学</span><br></pre></td></tr></table></figure>
<p>当两个值要执行的代码相同时，可以把要执行的代码写在下一个 case 语句中，而上一个 case 语句中什么也没有，来看一下示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">String name = &quot;沉默王二&quot;;</span><br><span class="line">switch (name) &#123;</span><br><span class="line">    case &quot;詹姆斯&quot;:</span><br><span class="line">        System.out.println(&quot;篮球运动员&quot;);</span><br><span class="line">        break;</span><br><span class="line">    case &quot;穆里尼奥&quot;:</span><br><span class="line">        System.out.println(&quot;足球教练&quot;);</span><br><span class="line">        break;</span><br><span class="line">    case &quot;沉默王二&quot;:</span><br><span class="line">    case &quot;沉默王三&quot;:</span><br><span class="line">        System.out.println(&quot;乒乓球爱好者&quot;);</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        throw new IllegalArgumentException(</span><br><span class="line">                &quot;名字没有匹配项&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">乒乓球爱好者</span><br></pre></td></tr></table></figure>
<p>枚举作为 switch 语句的变量也很常见，来看例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class SwitchEnumDemo &#123;</span><br><span class="line">    public enum PlayerTypes &#123;</span><br><span class="line">        TENNIS,</span><br><span class="line">        FOOTBALL,</span><br><span class="line">        BASKETBALL,</span><br><span class="line">        UNKNOWN</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(createPlayer(PlayerTypes.BASKETBALL));</span><br><span class="line">    &#125;</span><br><span class="line">    private static String createPlayer(PlayerTypes playerType) &#123;</span><br><span class="line">        switch (playerType) &#123;</span><br><span class="line">            case TENNIS:</span><br><span class="line">                return &quot;网球运动员费德勒&quot;;</span><br><span class="line">            case FOOTBALL:</span><br><span class="line">                return &quot;足球运动员C罗&quot;;</span><br><span class="line">            case BASKETBALL:</span><br><span class="line">                return &quot;篮球运动员詹姆斯&quot;;</span><br><span class="line">            case UNKNOWN:</span><br><span class="line">                throw new IllegalArgumentException(&quot;未知&quot;);</span><br><span class="line">            default:</span><br><span class="line">                throw new IllegalArgumentException(</span><br><span class="line">                        &quot;运动员类型: &quot; + playerType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">篮球运动员詹姆斯</span><br></pre></td></tr></table></figure>
<p><strong>03、for 循环</strong></p>
<p><img src="\assets\note\image-20230926141859323.png" alt="image-20230926141859323"></p>
<p>1）普通 for 循环 </p>
<p>普通的 for 循环可以分为 4 个部分：</p>
<p>1）初始变量：循环开始执行时的初始条件。</p>
<p>2）条件：循环每次执行时要判断的条件，如果为 true，就执行循环体；如果为 false，就跳出循环。当然了，条件是可选的，如果没有条件，则会一直循环。</p>
<p>3）循环体：循环每次要执行的代码块，直到条件变为 false。</p>
<p>4）自增/自减：初始变量变化的方式。</p>
<p>来看一下普通 for 循环的格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(初始变量;条件;自增/自减)&#123;  </span><br><span class="line">// 循环体</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>画个流程图：</p>
<p><img src="\assets\note\image-20230926142018436.png" alt="image-20230926142018436"></p>
<p>来个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">    System.out.println(&quot;沉默好美啊&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">沉默好美啊</span><br><span class="line">沉默好美啊</span><br><span class="line">沉默好美啊</span><br><span class="line">沉默好美啊</span><br><span class="line">沉默好美啊</span><br></pre></td></tr></table></figure>
<p>循环语句还可以嵌套呢，这样就可以打印出更好玩的呢</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">    for (int j = 0;j&lt;= i;j++) &#123;</span><br><span class="line">        System.out.print(&quot;❤&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印出什么玩意呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">❤</span><br><span class="line">❤❤</span><br><span class="line">❤❤❤</span><br><span class="line">❤❤❤❤</span><br><span class="line">❤❤❤❤❤</span><br></pre></td></tr></table></figure>
<p>2）for-each </p>
<p>for-each 循环通常用于遍历数组和集合，它的使用规则比普通的 for 循环还要简单，不需要初始变量，不需要条件，不需要下标来自增或者自减。来看一下语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(元素类型 元素 : 数组或集合)&#123;  </span><br><span class="line">// 要执行的代码</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>来看一下示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] strs = &#123;&quot;沉默&quot;, &quot;一枚有趣的程序员&quot;&#125;;</span><br><span class="line">for (String str : strs) &#123;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">沉默</span><br><span class="line">一枚有趣的程序员</span><br></pre></td></tr></table></figure>
<p>3）无限 for 循环 </p>
<p>“你想不想体验一下无限 for 循环的威力，也就是死循环。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(;;)&#123;</span><br><span class="line">    System.out.println(&quot;停不下来。。。。&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">停不下来。。。。</span><br><span class="line">停不下来。。。。</span><br><span class="line">停不下来。。。。</span><br><span class="line">停不下来。。。。</span><br></pre></td></tr></table></figure>
<p>一旦运行起来，就停不下来了，除非强制停止。</p>
<p><strong>04、while 循环 </strong></p>
<p>来看一下 while 循环的格式：</p>
<p><img src="\assets\note\image-20230926142456894.png" alt="image-20230926142456894"></p>
<p>来个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int i = 0;</span><br><span class="line">while (true) &#123;</span><br><span class="line">    System.out.println(&quot;沉默&quot;);</span><br><span class="line">    i++;</span><br><span class="line">    if (i == 5) &#123;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">沉默</span><br><span class="line">沉默</span><br><span class="line">沉默</span><br><span class="line">沉默</span><br><span class="line">沉默</span><br></pre></td></tr></table></figure>
<p>“你想不想体验一下无限 while 循环的威力，也就是死循环。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while (true) &#123;</span><br><span class="line">    System.out.println(&quot;停不下来。。。。&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">停不下来。。。。</span><br><span class="line">停不下来。。。。</span><br><span class="line">停不下来。。。。</span><br><span class="line">停不下来。。。。</span><br></pre></td></tr></table></figure>
<p>把 while 的条件设置为 true，并且循环体中没有 break 关键字的话，程序一旦运行起来，就根本停不下来了，除非强制停止。</p>
<p><strong>05、do-while 循环 </strong></p>
<p>来看一下 do-while 循环的格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">do&#123;  </span><br><span class="line">// 循环体</span><br><span class="line">&#125;while(提交);  </span><br></pre></td></tr></table></figure>
<p>画个流程图：</p>
<p><img src="\assets\note\image-20230926142727978.png" alt="image-20230926142727978"></p>
<p>来个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int i = 0;</span><br><span class="line">do &#123;</span><br><span class="line">    System.out.println(&quot;沉默&quot;);</span><br><span class="line">    i++;</span><br><span class="line">    if (i == 5) &#123;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; while (true);</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">沉默</span><br><span class="line">沉默</span><br><span class="line">沉默</span><br><span class="line">沉默</span><br><span class="line">沉默</span><br></pre></td></tr></table></figure>
<p>“你想不想体验一下无限 do-while 循环的威力……”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">    System.out.println(&quot;停不下来。。。。&quot;);</span><br><span class="line">&#125; while (true);</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">停不下来。。。。</span><br><span class="line">停不下来。。。。</span><br><span class="line">停不下来。。。。</span><br><span class="line">停不下来。。。。</span><br></pre></td></tr></table></figure>
<p>把 do-while 的条件设置为 true，并且循环体中没有 break 关键字的话，程序一旦运行起来，就根本停不下来了，除非强制停止。</p>
<p><img src="\assets\note\image-20230926155231166.png" alt="image-20230926155231166"></p>
<p><strong>06、break </strong></p>
<p>break 关键字通常用于中断循环或 switch 语句，它在指定条件下中断程序的当前流程。如果是内部循环，则仅中断内部循环。</p>
<p>可以将 break 关键字用于所有类型循环语句中，比如说 for 循环、while 循环，以及 do-while 循环。</p>
<p>来画个流程图感受一下：</p>
<p><img src="\assets\note\image-20230926155326551.png" alt="image-20230926155326551"></p>
<p>用在 for 循环中的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 1; i &lt;= 10; i++) &#123;</span><br><span class="line">    if (i == 5) &#123;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用在嵌套 for 循环中的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 1; i &lt;= 3; i++) &#123;</span><br><span class="line">    for (int j = 1; j &lt;= 3; j++) &#123;</span><br><span class="line">        if (i == 2 &amp;&amp; j == 2) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(i + &quot; &quot; + j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用在 while 循环中的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int i = 1;</span><br><span class="line">while (i &lt;= 10) &#123;</span><br><span class="line">    if (i == 5) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用在 do-while 循环中的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int j = 1;</span><br><span class="line">do &#123;</span><br><span class="line">    if (j == 5) &#123; </span><br><span class="line">        j++;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(j);</span><br><span class="line">    j++;</span><br><span class="line">&#125; while (j &lt;= 10);</span><br></pre></td></tr></table></figure>
<p>用在 switch 语句中的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">switch (age) &#123;</span><br><span class="line">    case 20 :</span><br><span class="line">        System.out.println(&quot;上学&quot;);</span><br><span class="line">        break;</span><br><span class="line">    case 24 :</span><br><span class="line">        System.out.println(&quot;苏州工作&quot;);</span><br><span class="line">        break;</span><br><span class="line">    case 30 :</span><br><span class="line">        System.out.println(&quot;洛阳工作&quot;);</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        System.out.println(&quot;未知&quot;);</span><br><span class="line">        break; // 可省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>07、continue </strong></p>
<p>当我们需要在 for 循环或者 （do）while 循环中立即跳转到下一个循环时，就可以使用 continue 关键字，通常用于跳过指定条件下的循环体，如果循环是嵌套的，仅跳过当前循环。</p>
<p>来个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 1; i &lt;= 10; i++) &#123;</span><br><span class="line">    if (i == 5) &#123;</span><br><span class="line">        // 使用 continue 关键字</span><br><span class="line">        continue;// 5 将会被跳过</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>再来个循环嵌套的例子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 1; i &lt;= 3; i++) &#123;</span><br><span class="line">    for (int j = 1; j &lt;= 3; j++) &#123;</span><br><span class="line">        if (i == 2 &amp;&amp; j == 2) &#123;</span><br><span class="line">            //  当i=2，j=2时跳过</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(i + &quot; &quot; + j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印出什么玩意呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 1</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 1</span><br><span class="line">2 3</span><br><span class="line">3 1</span><br><span class="line">3 2</span><br><span class="line">3 3</span><br></pre></td></tr></table></figure>
<p>“2 2” 没有输出，被跳过了。</p>
<p>再来看一下 while 循环时 continue 的使用示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int i = 1;</span><br><span class="line">while (i &lt;= 10) &#123;</span><br><span class="line">    if (i == 5) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        continue;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>注意：如果把 if 条件中的“i++”省略掉的话，程序就会进入死循环，一直在 continue。</p>
<p>最后，再来看一下 do-while 循环时 continue 的使用示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int i=1;</span><br><span class="line">do&#123;</span><br><span class="line">    if(i==5)&#123;</span><br><span class="line">        i++;</span><br><span class="line">        continue;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    i++;</span><br><span class="line">&#125;while(i&lt;=10);</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>注意：同样的，如果把 if 条件中的“i++”省略掉的话，程序就会进入死循环，一直在 continue。</p>
<p><strong>08、小结 </strong></p>
<p>本文全面讲解了Java流程控制语句，包括if、switch、while、for等结构。通过学习本文，你将了解到Java流程控制语句的基本概念、语法结构和使用场景，帮助你在实际编程过程中更加灵活地运用各类控制结构。</p>
<h1 id="2-数组-amp-字符串"><a href="#2-数组-amp-字符串" class="headerlink" title="2 数组&amp;字符串"></a>2 数组&amp;字符串</h1><h2 id="2-1-掌握Java数组"><a href="#2-1-掌握Java数组" class="headerlink" title="2.1 掌握Java数组"></a>2.1 掌握Java数组</h2><p>“ArrayList 的内部是用数组实现的”</p>
<p>“的确是的，看 ArrayList 的源码就一清二楚了。”我一边说，一边打开 Intellij IDEA，并找到了 ArrayList 的源码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The array buffer into which the elements of the ArrayList are stored.</span><br><span class="line"> * The capacity of the ArrayList is the length of this array buffer. Any</span><br><span class="line"> * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><br><span class="line"> * will be expanded to DEFAULT_CAPACITY when the first element is added.</span><br><span class="line"> */</span><br><span class="line">transient Object[] elementData; // non-private to simplify nested class access</span><br><span class="line">/**</span><br><span class="line"> * The size of the ArrayList (the number of elements it contains).</span><br><span class="line"> *</span><br><span class="line"> * @serial</span><br><span class="line"> */</span><br><span class="line">private int size;</span><br></pre></td></tr></table></figure>
<p>“瞧见没？ Object[] elementData 就是数组。”我指着显示屏上这串代码继续说。</p>
<p>数组是一个对象，它包含了一组固定数量的元素，并且这些元素的类型是相同的。数组会按照索引的方式将元素放在指定的位置上，意味着我们可以通过索引来访问这些元素。在 Java 中，索引是从 0 开始的。</p>
<p>“能说一下为什么索引从 0 开始吗？”</p>
<p>“哦，Java 是基于 C/C++ 语言实现的，而 C 语言的下标是从 0 开始的，所以 Java 就继承了这个良好的传统习惯。C语言有一个很重要概念，叫做指针，它实际上是一个偏移量，距离开始位置的偏移量，第一个元素就在开始的位置，它的偏移量就为 0，所以索引就为 0。”此刻，我很自信。</p>
<p>“此外，还有另外一种说法。早期的计算机资源比较匮乏，0 作为起始下标相比较于 1 作为起始下标，编译的效率更高。”</p>
<p>我们可以将数组理解为一个个整齐排列的单元格，每个单元格里面存放着一个元素。</p>
<p>数组元素的类型可以是基本数据类型（比如说 int、double），也可以是引用数据类型（比如说 String），包括自定义类型。</p>
<p>数组的声明方式分两种。</p>
<p>先来看第一种：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[] anArray;</span><br></pre></td></tr></table></figure>
<p>再来看第二种：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int anOtherArray[];</span><br></pre></td></tr></table></figure>
<p>不同之处就在于中括号的位置，是跟在类型关键字的后面，还是跟在变量的名称的后面。前一种的使用频率更高一些，像 ArrayList 的源码中就用了第一种方式。</p>
<p>同样的，数组的初始化方式也有多种，最常见的是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[] anArray = new int[10];</span><br></pre></td></tr></table></figure>
<p>看到了没？上面这行代码中使用了 new 关键字，这就意味着数组的确是一个对象，只有对象的创建才会用到 new 关键字，基本数据类型是不用的。然后，我们需要在方括号中指定数组的长度。</p>
<p>这时候，数组中的每个元素都会被初始化为默认值，int 类型的就为 0，Object 类型的就为 null。 不同数据类型的默认值不同。</p>
<p>另外，还可以使用大括号的方式，直接初始化数组中的元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int anOtherArray[] = new int[] &#123;1, 2, 3, 4, 5&#125;;</span><br></pre></td></tr></table></figure>
<p>这时候，数组的元素分别是 1、2、3、4、5，索引依次是 0、1、2、3、4，长度是 5。</p>
<p>“怎么访问数组呢？”</p>
<p>前面提到过，可以通过索引来访问数组的元素，就像下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">anArray[0] = 10;</span><br></pre></td></tr></table></figure>
<p>变量名，加上中括号，加上元素的索引，就可以访问到数组，通过“=”操作符可以对元素进行赋值。</p>
<p>如果索引的值超出了数组的界限，就会抛出 ArrayIndexOutOfBoundException 。</p>
<p>既然数组的索引是从 0 开始，那就是到数组的 length - 1 结束，不要使用超出这个范围内的索引访问数组，就不会抛出数组越界的异常了。 </p>
<p>当数组的元素非常多的时候，逐个访问数组就太辛苦了，所以需要通过遍历的方式。</p>
<p>第一种，使用 for 循环：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int anOtherArray[] = new int[] &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">for (int i = 0; i &lt; anOtherArray.length; i++) &#123;</span><br><span class="line">    System.out.println(anOtherArray[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 length 属性获取到数组的长度，然后从 0 开始遍历，就得到了数组的所有元素。</p>
<p>第二种，使用 for-each 循环：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (int element : anOtherArray) &#123;</span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不需要关心索引的话（意味着不需要修改数组的某个元素），使用 for-each 遍历更简洁一些。当然，也可以使用 while 和 do-while 循环。</p>
<p>在 Java 中，可变参数用于将任意数量的参数传递给方法，来看 varargsMethod() 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void varargsMethod(String... varargs) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>该方法可以接收任意数量的字符串参数，可以是 0 个或者 N 个，本质上，可变参数就是通过数组实现的。为了证明这一点，我们可以看一下反编译一后的字节码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class VarargsDemo</span><br><span class="line">&#123;</span><br><span class="line">    public VarargsDemo()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    transient void varargsMethod(String as[])</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，我们其实可以直接将数组作为参数传递给该方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VarargsDemo demo = new VarargsDemo();</span><br><span class="line">String[] anArray = new String[] &#123;&quot;沉默&quot;, &quot;一枚有趣的程序员&quot;&#125;;</span><br><span class="line">demo.varargsMethod(anArray);</span><br></pre></td></tr></table></figure>
<p>也可以直接传递多个字符串，通过逗号隔开的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">demo.varargsMethod(&quot;沉默&quot;, &quot;一枚有趣的程序员&quot;);</span><br></pre></td></tr></table></figure>
<p>在 Java 中，数组与 List 关系非常密切。List 封装了很多常用的方法，方便我们对集合进行一些操作，而如果直接操作数组的话，有很多不便，因为数组本身没有提供这些封装好的操作，所以有时候我们需要把数组转成 List。</p>
<p>“怎么转呢？”</p>
<p>最原始的方式，就是通过遍历数组的方式，一个个将数组添加到 List 中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int[] anArray = new int[] &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">List&lt;Integer&gt; aList = new ArrayList&lt;&gt;();</span><br><span class="line">for (int element : anArray) &#123;</span><br><span class="line">    aList.add(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更优雅的方式是通过 Arrays 类的 asList() 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; aList = Arrays.asList(anArray);</span><br></pre></td></tr></table></figure>
<p>不过需要注意的是，Arrays.asList 的参数需要是 Integer 数组，而 anArray 目前是 int 类型，我们需要换另外一种方式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; aList = Arrays.stream(anArray).boxed().collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<p>这又涉及到了 Java 流的知识，后面会讲到。</p>
<p>还有一个需要注意的是，Arrays.asList 方法返回的 ArrayList 并不是 java.util.ArrayList ，它其实是Arrays 类的一个内部类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class="line">        implements RandomAccess, java.io.Serializable&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>如果需要添加元素或者删除元素的话，需要把它转成 java.util.ArrayList 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new ArrayList&lt;&gt;(Arrays.asList(anArray));</span><br></pre></td></tr></table></figure>
<p>Java 8 新增了 Stream 流的概念，这就意味着我们也可以将数组转成 Stream 进行操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] anArray = new String[] &#123;&quot;沉默&quot;, &quot;一枚有趣的程序员&quot;, &quot;好好珍重他&quot;&#125;;</span><br><span class="line">Stream&lt;String&gt; aStream = Arrays.stream(anArray);</span><br></pre></td></tr></table></figure>
<p>如果想对数组进行排序的话，可以使用 Arrays 类提供的 sort() 方法。</p>
<ul>
<li>基本数据类型按照升序排列</li>
<li>实现了 Comparable 接口的对象按照 compareTo() 的排序</li>
</ul>
<p>来看第一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int[] anArray = new int[] &#123;5, 2, 1, 4, 8&#125;;</span><br><span class="line">Arrays.sort(anArray);</span><br></pre></td></tr></table></figure>
<p>排序后的结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 4, 5, 8]</span><br></pre></td></tr></table></figure>
<p>来看第二个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] yetAnotherArray = new String[] &#123;&quot;A&quot;, &quot;E&quot;, &quot;Z&quot;, &quot;B&quot;, &quot;C&quot;&#125;;</span><br><span class="line">Arrays.sort(yetAnotherArray, 1, 3,</span><br><span class="line">                Comparator.comparing(String::toString).reversed());</span><br></pre></td></tr></table></figure>
<p>只对 1-3 位置上的元素进行反序，所以结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[A, Z, E, B, C]</span><br></pre></td></tr></table></figure>
<p>有时候，我们需要从数组中查找某个具体的元素，最直接的方式就是通过遍历的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int[] anArray = new int[] &#123;5, 2, 1, 4, 8&#125;;</span><br><span class="line">for (int i = 0; i &lt; anArray.length; i++) &#123;</span><br><span class="line">    if (anArray[i] == 4) &#123;</span><br><span class="line">        System.out.println(&quot;找到了 &quot; + i);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上例中从数组中查询元素 4，找到后通过 break 关键字退出循环。</p>
<p>如果数组提前进行了排序，就可以使用二分查找法，这样效率就会更高一些。 Arrays.binarySearch() 方法可供我们使用，它需要传递一个数组，和要查找的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int[] anArray = new int[] &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">int index = Arrays.binarySearch(anArray, 4);</span><br></pre></td></tr></table></figure>
<h2 id="2-2-掌握Java二维数组"><a href="#2-2-掌握Java二维数组" class="headerlink" title="2.2 掌握Java二维数组"></a>2.2 掌握Java二维数组</h2><p><strong>01、什么是二维数组 </strong></p>
<p>二维数组是一种数据类型，可以存储多行和多列的数据。它由一系列的行和列组成，每个元素都可以通过一个行索引和列索引来访问。例如，一个3行4列的二维数组可以表示为以下形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array = [</span><br><span class="line">  [a, b, c, d],</span><br><span class="line">  [e, f, g, h],</span><br><span class="line">  [i, j, k, l]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>在这个例子中，第一行有4个元素，第二行有4个元素，第三行有4个元素，每个元素都有一个行索引和一个列索引。例如，元素 array[1][2] 是第2行第3列的元素，它的值是 g。</p>
<p>使用二维数组可以有效地存储和处理表格数据，如矩阵、图像、地图等等。</p>
<p><strong>02、创建二维数组 </strong></p>
<p>要在 Java 中创建二维数组，你必须指定要存储在数组中的数据类型，后跟两个方括号和数组的名称。</p>
<p>语法如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data_type[][] array_name;</span><br></pre></td></tr></table></figure>
<p>让我们看一个代码示例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[][] oddNumbers = &#123; &#123;1, 3, 5, 7&#125;, &#123;9, 11, 13, 15&#125; &#125;;</span><br></pre></td></tr></table></figure>
<p><strong>03、访问二维数组中的元素 </strong></p>
<p>我们可以使用两个方括号来访问二维中的元素。</p>
<p>第一个表示我们要从中访问元素的数组，而第二个表示我们要访问的元素索引。</p>
<p>让我们用一个例子来简化上面的解释：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int[][] oddNumbers = &#123; &#123;1, 3, 5, 7&#125;, &#123;9, 11, 13, 15&#125; &#125;;</span><br><span class="line">System.out.println(oddNumbers[0][0]);</span><br><span class="line">// 1</span><br></pre></td></tr></table></figure>
<p>在上面的示例中， oddNumbers 数组中有两个数组—— {1, 3, 5, 7} 和 {9, 11, 13, 15} 。</p>
<p>第一个数组—— {1, 3, 5, 7} ——用 0 表示。</p>
<p>第二个数组—— {9, 11, 13, 15} ——用 1 表示。</p>
<p>第一个数组是 0，第二个是 1，第三个是 2，依此类推。</p>
<p>因此，要访问第一个数组中的项目，我们将 0 分配给第一个方括号。由于我们试图访问数组中的第一项，我们将使用它的索引，即 0： oddNumbers[0][0] 。</p>
<p>让我们进一步分解它。</p>
<p>这是访问元素的代码： oddNumbers[?][?] 。</p>
<p>我在两个方括号中都加上了问号——随着进展填写它们。</p>
<p>假设我们要访问第二个数组中的元素，我们的代码将如下所示： oddNumbers[1][?] 。</p>
<p>现在我们要在第二个数组（ {9, 11, 13, 15} ）中尝试访问其中一个元素。就像一维数组一样，每个元素都有一个从零开始的索引。</p>
<p>因此，要访问第三个元素 13 ，我们将其索引号传递给第二个方括号： oddNumbers[1][2] 。</p>
<p>来看这样一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[][] oddNumbers = &#123; &#123;1, 3, 5, 7&#125;, &#123;9, 11, 13, 15&#125;, &#123;17, 19, 21, 23&#125; &#125;;</span><br></pre></td></tr></table></figure>
<p>我们的目标是访问第三个数组中的 21。访问方式仍然通过问号来表示： oddNumbers[?][?] 。</p>
<p>我们首先给第一个问号一个指向要访问的特定数组的值。</p>
<p>数组 0 =&gt; {1, 3, 5, 7}</p>
<p>数组 1 =&gt; {9, 11, 13, 15}</p>
<p>数组 2 =&gt; {17, 19, 21, 23}</p>
<p>我们要查找的数字在第三个数组中，所以是： oddNumbers[2][?] 。</p>
<p>第二个方括号的值将指向要访问的元素。为此，我们必须指定元素的索引。以下是该数组中的索引：</p>
<p>17 =&gt; 索引 0</p>
<p>19 =&gt; 索引 1</p>
<p>21 =&gt; 索引 2</p>
<p>23 =&gt; 索引 3</p>
<p>21 的索引为 2，因此我们可以将其添加到第二个方括号： oddNumbers[2][2] 。当你将其打印到控制台时，将会打印出 21。</p>
<p>代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int[][] oddNumbers = &#123; &#123;1, 3, 5, 7&#125;, &#123;9, 11, 13, 15&#125;, &#123;17, 19, 21, 23&#125; &#125;;</span><br><span class="line">System.out.println(oddNumbers[2][2]);</span><br><span class="line">// 21</span><br></pre></td></tr></table></figure>
<p>你可以使用嵌套循环，遍历二维数组中的所有项目。这是一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int[][] oddNumbers = &#123; &#123;1, 3, 5, 7&#125;, &#123;9, 11, 13, 15&#125;, &#123;17, 19, 21, 23&#125; &#125;;</span><br><span class="line">for(int i = 0; i &lt; oddNumbers.length; i++)&#123;</span><br><span class="line">    for(int j = 0; j &lt; oddNumbers[i].length; j++)&#123;</span><br><span class="line">        System.out.println(oddNumbers[i][j]);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line">// 1</span><br><span class="line">// 3</span><br><span class="line">// 5</span><br><span class="line">// 7</span><br><span class="line">// 9</span><br><span class="line">// 11</span><br><span class="line">// 13</span><br><span class="line">// 15</span><br><span class="line">// 17</span><br><span class="line">// 19</span><br><span class="line">// 21</span><br><span class="line">// 23</span><br></pre></td></tr></table></figure>
<p>上面的代码将会打印出 oddNumbers 数组中的所有项目。</p>
<p><strong>04、二维数组打印杨辉三角</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line">public class YangHuiTriangle &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner input = new Scanner(System.in);</span><br><span class="line">        System.out.print(&quot;请输入要打印的行数：&quot;);</span><br><span class="line">        int n = input.nextInt();</span><br><span class="line">        printYangHuiTriangle(n);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void printYangHuiTriangle(int n) &#123;</span><br><span class="line">        int[][] triangle = new int[n][n];</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            // 每行的第一个和最后一个数字都是1</span><br><span class="line">            triangle[i][0] = 1;</span><br><span class="line">            triangle[i][i] = 1;</span><br><span class="line">            for (int j = 1; j &lt; i; j++) &#123;</span><br><span class="line">                // 其他数字是上一行的两个数字之和</span><br><span class="line">                triangle[i][j] = triangle[i - 1][j - 1] + triangle[i - 1][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 打印杨辉三角</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt;= i; j++) &#123;</span><br><span class="line">                System.out.print(triangle[i][j] + &quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“这段代码使用了一个二维数组来存储杨辉三角中的数字。首先，程序要求用户输入要打印的行数，然后调用 printYangHuiTriangle 方法来生成和打印杨辉三角。在 printYangHuiTriangle 方法中，程序使用了一个嵌套的 for 循环来计算杨辉三角中的每个数字，并将结果存储在二维数组 triangle 中。最后，程序再次使用循环来遍历数组并打印出杨辉三角中的数字。”</p>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">请输入要打印的行数：6</span><br><span class="line">1 </span><br><span class="line">1 1 </span><br><span class="line">1 2 1 </span><br><span class="line">1 3 3 1 </span><br><span class="line">1 4 6 4 1 </span><br><span class="line">1 5 10 10 5 1 </span><br></pre></td></tr></table></figure>
<h2 id="2-3-打印Java数组"><a href="#2-3-打印Java数组" class="headerlink" title="2.3 打印Java数组"></a>2.3 打印Java数组</h2><p>“数组也是一个对象，但 Java 中并未明确的定义这样一个类。”</p>
<p>“是的，因此数组也就没有机会覆盖 Object.toString() 方法。如果尝试直接打印数组的话，输出的结果并不是我们预期的结果。”</p>
<p>“那怎么打印数组呢？”</p>
<p>为什么不能直接打印数组</p>
<p>“首先，我们来看一下，为什么不能直接打印数组，直接打印的话，会出现什么问题。”</p>
<p>来看这样一个例子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String [] cmowers = &#123;&quot;沉默&quot;,&quot;一枚有趣的程序员&quot;&#125;;</span><br><span class="line">System.out.println(cmowers);</span><br></pre></td></tr></table></figure>
<p>程序打印的结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Ljava.lang.String;@3d075dc0</span><br></pre></td></tr></table></figure>
<p>[Ljava.lang.String; 表示字符串数组的 Class 名，@ 后面的是十六进制的 hashCode——这样的打印结果太“人性化”了，一般人表示看不懂！为什么会这样显示呢？查看一下 java.lang.Object 类的 toString() 方法就明白了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String [] cmowers = &#123;&quot;沉默&quot;,&quot;王二&quot;,&quot;一枚有趣的程序员&quot;&#125;;</span><br><span class="line">System.out.println(cmowers);</span><br></pre></td></tr></table></figure>
<p>再次证明，数组虽然没有显式定义成一个类，但它的确是一个对象，继承了祖先类 Object 的所有方法。</p>
<p>“那为什么数组不单独定义一个类来表示呢？就像字符串 String 类那样呢？”</p>
<p>“一个合理的说法是 Java 将其隐藏了。假如真的存在这么一个类，就叫 Array.java 吧，我们假想一下它真实的样子，必须得有一个容器来存放数组的每一个元素，就像 String 类那样。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final class String</span><br><span class="line">    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    /** The value is used for character storage. */</span><br><span class="line">    private final char value[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“最终还是要用类似一种数组的形式来存放数组的元素，对吧？这就变得很没有必要了，不妨就把数组当做是一个没有形体的对象吧！”</p>
<p><strong>stream 流打印 Java 数组 </strong></p>
<p>“我们来看第一种打印数组的方法，使用时髦一点的Stream 流。”</p>
<p>第一种形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList(cmowers).stream().forEach(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure>
<p>第二种形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(cmowers).forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>第三种形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.stream(cmowers).forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>打印的结果如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">沉默</span><br><span class="line">一枚有趣的程序员</span><br></pre></td></tr></table></figure>
<p>没错，这三种方式都可以轻松胜任本职工作，并且显得有点高大上，毕竟用到了 Stream，以及 lambda 表达式。</p>
<p><strong>for 循环打印 Java 数组 </strong></p>
<p>“当然了，也可以使用传统的方式，for 循环。甚至 for-each 也行。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(int i = 0; i &lt; cmowers.length; i++)&#123;</span><br><span class="line">    System.out.println(cmowers[i]);</span><br><span class="line">&#125;</span><br><span class="line">for (String s : cmowers) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Arrays 工具类打印 Java 数组 </strong></p>
<p>“当然没有了，我认为 Arrays.toString() 是打印数组的最佳方式，没有之一。”Arrays.toString() 可以将任意类型的数组转成字符串，包括基本类型数组和引用类型数组。该方法有多种重载形式。</p>
<p><img src="\assets\note\image-20230927095033931.png" alt="image-20230927095033931"></p>
<p>使用 Arrays.toString() 方法来打印数组再优雅不过了，就像，就像，就像蒙娜丽莎的微笑。</p>
<p><img src="\assets\note\image-20230927095116614.png" alt="image-20230927095116614"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String [] cmowers = &#123;&quot;沉默&quot;,&quot;一枚有趣的程序员&quot;&#125;;</span><br><span class="line">System.out.println(Arrays.toString(cmowers));</span><br></pre></td></tr></table></figure>
<p>程序打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[沉默, 一枚有趣的程序员]</span><br></pre></td></tr></table></figure>
<p>哇，打印格式不要太完美，不多不少！完全是我们预期的结果： [] 表明是一个数组， , 点和空格用来分割元素。</p>
<p><strong>Arrays工具类打印二维数组 </strong></p>
<p>“那如果我想打印二维数组呢？”</p>
<p>“可以使用 Arrays.deepToString() 方法。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[][] deepArray = new String[][] &#123;&#123;&quot;沉默&quot;&#125;, &#123;&quot;一枚有趣的程序员&quot;&#125;&#125;;</span><br><span class="line">System.out.println(Arrays.deepToString(deepArray));</span><br></pre></td></tr></table></figure>
<p>打印结果如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[沉默], [一枚有趣的程序员]]</span><br></pre></td></tr></table></figure>
<p><strong>POJO 的打印规约 </strong></p>
<p>“说到打印，哥给你提醒一点。阿里巴巴的 Java 开发手册上有这样一条规约，你看。”</p>
<p><img src="\assets\note\image-20230927095402737.png" alt="image-20230927095402737"></p>
<p>“什么是 POJO 呢，就是 Plain Ordinary Java Object 的缩写，一般在 Web 应用程序中建立一个数据库的映射对象时，我们称它为 POJO，这类对象不继承或不实现任何其它 Java 框架的类或接口。”</p>
<p>“对于这样的类，最好是重写一下它的 toString() 方法，方便查看这个对象到底包含了什么字段，好排查问题。”</p>
<p>“如果不重写的话，打印出来的 Java 对象就像直接打印数组的那样，一串谁也看不懂的字符序列。”</p>
<p>“可以借助 Intellij IDEA 生成重写的  toString() 方法，特别方便。”</p>
<p><strong>2.4 解读String类源码 </strong></p>
<p>String 类的声明 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final class String</span><br><span class="line">    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“第一，String 类是 final 的，意味着它不能被子类继承。”</p>
<p>“第二，String 类实现了 Serializable 接口，意味着它可以序列化。”</p>
<p>“第三，String 类实现了 Comparable 接口，意味着最好不要用‘==’来比较两个字符串是否相等，而应该用 compareTo() 方法去比较。”</p>
<p>因为 == 是用来比较两个对象的地址，这个在讲字符串比较的时候会详细讲。如果只是说比较字符串内容的话，可以使用 String 类的 equals 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object anObject) &#123;</span><br><span class="line">    if (this == anObject) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (anObject instanceof String) &#123;</span><br><span class="line">        String anotherString = (String) anObject;</span><br><span class="line">        int n = value.length;</span><br><span class="line">        if (n == anotherString.value.length) &#123;</span><br><span class="line">            char v1[] = value;</span><br><span class="line">            char v2[] = anotherString.value;</span><br><span class="line">            int i = 0;</span><br><span class="line">            while (n-- != 0) &#123;</span><br><span class="line">                if (v1[i] != v2[i])</span><br><span class="line">                    return false;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“第四，StringBuffer、StringBuilder 和 String 一样，都实现了 CharSequence 接口，所以它们仨属于近亲。由于 String 是不可变的，所以遇到字符串拼接的时候就可以考虑一下 String 的另外两个好兄弟，<strong>StringBuffer 和 StringBuilder，它俩是可变的。”</strong></p>
<p><strong>String 类的底层实现 </strong></p>
<p>“第五，Java 9 以前，String 是用 char 型数组实现的，之后改成了 byte 型数组实现，并增加了 coder 来表示编码。这样做的好处是在 Latin1 字符为主的程序里，可以把 String 占用的内存减少一半。当然，天下没有免费的午餐，这个改进在节省内存的同时引入了编码检测的开销。”</p>
<blockquote>
<p>Latin1（Latin-1）是一种单字节字符集（即每个字符只使用一个字节的编码方式），也称为ISO-8859-1（国际标准化组织8859-1），它包含了西欧语言中使用的所有字符，包括英语、法语、德语、西班牙语、葡萄牙语、意大利语等等。在Latin1编码中，每个字符使用一个8位（即一个字节）的编码，可以表示256种不同的字符，其中包括ASCII字符集中的所有字符，即0x00到0x7F，以及其他西欧语言中的特殊字符，例如é、ü、ñ等等。由于Latin1只使用一个字节表示一个字符，因此在存储和传输文本时具有较小的存储空间和较快的速度</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final class String</span><br><span class="line">    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    @Stable</span><br><span class="line">    private final byte[] value;</span><br><span class="line">    private final byte coder;</span><br><span class="line">    private int hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们来详细地说一下。</p>
<p>从 char[] 到 byte[] ，最主要的目的是节省字符串占用的内存空间。内存占用减少带来的另外一个好处，就是 GC 次数也会减少。</p>
<p>我们使用 jmap -histo:live pid | head -n 10 命令就可以查看到堆内对象示例的统计信息、查看 ClassLoader 的信息以及 finalizer 队列。</p>
<p>以我正在运行着的编程喵项目实例（基于 Java 8）来说，结果是这样的。</p>
<p><img src="\assets\note\image-20230927100036881.png" alt="image-20230927100036881"></p>
<p>其中 String 对象有 17638 个，占用了 423312 个字节的内存，排在第三位。</p>
<p>由于 Java 8 的 String 内部实现仍然是 char[] ，所以我们可以看到内存占用排在第 1 位的就是 char 数组。char[] 对象有 17673 个，占用了 1621352 个字节的内存，排在第一位。</p>
<p>那也就是说优化 String 节省内存空间是非常有必要的，如果是去优化一个使用频率没有 String 这么高的类，就没什么必要，对吧？</p>
<p>众所周知，char 类型的数据在 JVM 中是占用两个字节的，并且使用的是 UTF-8 编码，其值范围在 ‘\u0000’（0）和 ‘\uffff’（65,535）（包含）之间。</p>
<p>也就是说，使用 char[] 来表示 String 就会导致，即使 String 中的字符只用一个字节就能表示，也得占用两个字节。</p>
<blockquote>
<p>PS：在计算机中，单字节字符通常指的是一个字节（8位）可以表示的字符，而双字节字符则指需要两个字节（16位）才能表示的字符。单字节字符和双字节字符的定义是相对的，不同的编码方式对应的单字节和双字节字符集也不同。常见的单字节字符集有ASCII（美国信息交换标准代码）、ISO-8859（国际标准化组织标准编号8859）、GBK（汉字内码扩展规范）、GB2312（中国国家标准，现在已经被GBK取代），像拉丁字母、数字、标点符号、控制字符都是单字节字符。双字节字符集包括 Unicode、UTF-8、GB18030（中国国家标准），中文、日文、韩文、拉丁文扩展字符属于双字节字符。</p>
</blockquote>
<p>当然了，仅仅将 char[] 优化为 byte[] 是不够的，还要配合 Latin-1 的编码方式，该编码方式是用单个字节来表示字符的，这样就比 UTF-8 编码节省了更多的空间。</p>
<p>换句话说，对于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String name = &quot;jack&quot;;</span><br></pre></td></tr></table></figure>
<p>这样的，使用 Latin-1 编码，占用 4 个字节就够了。</p>
<p>但对于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String name = &quot;小二&quot;;</span><br></pre></td></tr></table></figure>
<p>这种，木的办法，只能使用 UTF16 来编码。</p>
<p>针对 JDK 9 的 String 源码里，为了区别编码方式，追加了一个 coder 字段来区分。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The identifier of the encoding used to encode the bytes in</span><br><span class="line"> * &#123;@code value&#125;. The supported values in this implementation are</span><br><span class="line"> *</span><br><span class="line"> * LATIN1</span><br><span class="line"> * UTF16</span><br><span class="line"> *</span><br><span class="line"> * @implNote This field is trusted by the VM, and is a subject to</span><br><span class="line"> * constant folding if String instance is constant. Overwriting this</span><br><span class="line"> * field after construction will cause problems.</span><br><span class="line"> */</span><br><span class="line">private final byte coder;</span><br></pre></td></tr></table></figure>
<p>Java 会根据字符串的内容自动设置为相应的编码，要么 Latin-1 要么 UTF16。</p>
<p>也就是说，从 char[] 到 byte[] ，<strong>中文是两个字节，纯英文是一个字节，在此之前呢，中文是两个字节，英文也是两个字节。</strong></p>
<p>在 UTF-8 中，0-127 号的字符用 1 个字节来表示，使用和 ASCII 相同的编码。只有 128 号及以上的字符才用 2 个、3 个或者 4 个字节来表示。</p>
<ul>
<li>如果只有一个字节，那么最高的比特位为 0；</li>
<li>如果有多个字节，那么第一个字节从最高位开始，连续有几个比特位的值为 1，就使用几个字节编码，剩下的字节均以 10 开头。</li>
</ul>
<p>具体的表现形式为：</p>
<ul>
<li>0xxxxxxx：一个字节；</li>
<li>110xxxxx 10xxxxxx：两个字节编码形式（开始两个 1）；</li>
<li>1110xxxx 10xxxxxx 10xxxxxx：三字节编码形式（开始三个 1）；</li>
<li>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx：四字节编码形式（开始四个 1）。</li>
</ul>
<p>也就是说，UTF-8 是变长的，那对于 String 这种有随机访问方法的类来说，就很不方便。所谓的随机访问，就是charAt、subString这种方法，随便指定一个数字，String要能给出结果。如果字符串中的每个字符占用的内存是不定长的，那么进行随机访问的时候，就需要从头开始数每个字符的长度，才能找到你想要的字符。</p>
<p>那你可能会问，UTF-16也是变长的呢？一个字符还可能占用 4 个字节呢？</p>
<p>的确，UTF-16 使用 2 个或者 4 个字节来存储字符。</p>
<ul>
<li>对于 Unicode 编号范围在 0 ~ FFFF 之间的字符，UTF-16 使用两个字节存储。</li>
<li>对于 Unicode 编号范围在 10000 ~ 10FFFF 之间的字符，UTF-16 使用四个字节存储，具体来说就是：将字符编号的所有比特位分成两部分，较高的一些比特位用一个值介于 D800~DBFF 之间的双字节存储，较低的一些比特位（剩下的比特位）用一个值介于 DC00~DFFF 之间的双字节存储。</li>
</ul>
<p>但是在 Java 中，一个字符（char）就是 2 个字节，占 4 个字节的字符，在 Java 里也是用两个 char 来存储的，而String的各种操作，都是以Java的字符（char）为单位的，charAt是取得第几个char，subString取的也是第几个到第几个char组成的子串，甚至length返回的都是char的个数。</p>
<p>所以UTF-16在Java的世界里，就可以视为一个定长的编码。</p>
<p><strong>String 类的 hashCode 方法 </strong></p>
<p>“第六，每一个字符串都会有一个 hash 值，这个哈希值在很大概率是不会重复的，因此 String 很适合来作为 HashMap 的键值。”</p>
<p>来看 String 类的 hashCode 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private int hash; // Cache the hash code for the string</span><br><span class="line">public int hashCode() &#123;</span><br><span class="line">    int h = hash;</span><br><span class="line">    if (h == 0 &amp;&amp; value.length &gt; 0) &#123;</span><br><span class="line">        char val[] = value;</span><br><span class="line">        for (int i = 0; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = 31 * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    return h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>hashCode 方法首先检查是否已经计算过哈希码，如果已经计算过，则直接返回缓存的哈希码。否则，方法将使用一个循环遍历字符串的所有字符，并使用一个乘法和加法的组合计算哈希码。这种计算方法被称为“31 倍哈希法”。计算完成后，将得到的哈希值存储在 hash 成员变量中，以便下次调用 hashCode 方法时直接返回该值，而不需要重新计算。这是一种缓存优化，称为“惰性计算”。</p>
<p>31倍哈希法（31-Hash）是一种简单有效的字符串哈希算法，常用于对字符串进行哈希处理。该算法的基本思想是将字符串中的每个字符乘以一个固定的质数31的幂次方，并将它们相加得到哈希值。具体地，假设字符串为s，长度为n，则31倍哈希值计算公式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">H(s) = (s[0] * 31^(n-1)) + (s[1] * 31^(n-2)) + ... + (s[n-1] * 31^0)</span><br></pre></td></tr></table></figure>
<p>其中，s[i]表示字符串s中第i个字符的ASCII码值， ^表示幂运算。31倍哈希法的优点在于简单易实现，计算速度快，同时也比较均匀地分布在哈希表中。</p>
<p>hashCode 方法，我们会在另外一个章节里详细讲。</p>
<p>我们可以通过以下方法模拟 String 的 hashCode 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class HashCodeExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String text = &quot;沉默王二&quot;;</span><br><span class="line">        int hashCode = computeHashCode(text);</span><br><span class="line">        System.out.println(&quot;字符串 \&quot;&quot; + text + &quot;\&quot; 的哈希码是: &quot; + hashCode);</span><br><span class="line">        System.out.println(&quot;String 的 hashCode &quot; + text.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">    public static int computeHashCode(String text) &#123;</span><br><span class="line">        int h = 0;</span><br><span class="line">        for (int i = 0; i &lt; text.length(); i++) &#123;</span><br><span class="line">            h = 31 * h + text.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看一下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">字符串 &quot;沉默&quot; 的哈希码是: 867758096</span><br><span class="line">String 的 hashCode 867758096</span><br></pre></td></tr></table></figure>
<p>结果是一样的，又学到了吧？</p>
<p><strong>String 类的 substring 方法 </strong></p>
<p>String 类中还有一个方法比较常用 substring，用来截取字符串的，来看源码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public String substring(int beginIndex) &#123;</span><br><span class="line">    if (beginIndex &lt; 0) &#123;</span><br><span class="line">        throw new StringIndexOutOfBoundsException(beginIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    int subLen = value.length - beginIndex;</span><br><span class="line">    if (subLen &lt; 0) &#123;</span><br><span class="line">        throw new StringIndexOutOfBoundsException(subLen);</span><br><span class="line">    &#125;</span><br><span class="line">    return (beginIndex == 0) ? this : new String(value, beginIndex, subLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>substring 方法首先检查参数的有效性，如果参数无效，则抛出 StringIndexOutOfBoundsException 异常。</p>
<p>接下来，方法根据参数计算子字符串的长度。如果子字符串长度小于零，抛出StringIndexOutOfBoundsException异常。</p>
<p>如果 beginIndex 为 0，且 endIndex 等于字符串的长度，说明子串与原字符串相同，因此直接返回原字符串。否则，使用 value 数组（原字符串的字符数组）的一部分创建一个新的 String 对象并返回。</p>
<p>下面是几个使用 substring 方法的示例：</p>
<p>①、提取字符串中的一段子串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;Hello, world!&quot;;</span><br><span class="line">String subStr = str.substring(7, 12);  // 从第7个字符（包括）提取到第12个字符（不包括）</span><br><span class="line">System.out.println(subStr);  // 输出 &quot;world&quot;</span><br></pre></td></tr></table></figure>
<p>②、提取字符串中的前缀或后缀：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;Hello, world!&quot;;</span><br><span class="line">String prefix = str.substring(0, 5);  // 提取前5个字符，即 &quot;Hello,&quot;</span><br><span class="line">String suffix = str.substring(7);     // 提取从第7个字符开始的所有字符，即 &quot;world!&quot;</span><br></pre></td></tr></table></figure>
<p>③、处理字符串中的空格和分隔符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;   Hello,   world!  &quot;;</span><br><span class="line">String trimmed = str.trim();                  // 去除字符串开头和结尾的空格</span><br><span class="line">String[] words = trimmed.split(&quot;\\s+&quot;);       // 将字符串按照空格分隔成单词数组</span><br><span class="line">String firstWord = words[0].substring(0, 1);  // 提取第一个单词的首字母</span><br><span class="line">System.out.println(firstWord);  </span><br></pre></td></tr></table></figure>
<p>④、处理字符串中的数字和符号：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;1234-5678-9012-3456&quot;;</span><br><span class="line">String[] parts = str.split(&quot;-&quot;);             // 将字符串按照连字符分隔成四个部分</span><br><span class="line">String last4Digits = parts[3].substring(1);  // 提取最后一个部分的后三位数字</span><br><span class="line">System.out.println(last4Digits);             // 输出 &quot;456&quot;</span><br></pre></td></tr></table></figure>
<p>总之，substring 方法可以根据需求灵活地提取字符串中的子串，为字符串处理提供了便利。</p>
<p><strong>String 类的 indexOf 方法 </strong></p>
<p>indexOf 方法用于查找一个子字符串在原字符串中第一次出现的位置，并返回该位置的索引。来看该方法的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 查找字符数组 target 在字符数组 source 中第一次出现的位置。</span><br><span class="line"> * sourceOffset 和 sourceCount 参数指定 source 数组中要搜索的范围，</span><br><span class="line"> * targetOffset 和 targetCount 参数指定 target 数组中要搜索的范围，</span><br><span class="line"> * fromIndex 参数指定开始搜索的位置。</span><br><span class="line"> * 如果找到了 target 数组，则返回它在 source 数组中的位置索引（从0开始），</span><br><span class="line"> * 否则返回-1。</span><br><span class="line"> */</span><br><span class="line">static int indexOf(char[] source, int sourceOffset, int sourceCount,</span><br><span class="line">        char[] target, int targetOffset, int targetCount,</span><br><span class="line">        int fromIndex) &#123;</span><br><span class="line">    // 如果开始搜索的位置已经超出 source 数组的范围，则直接返回-1（如果 target 数组为空，则返回 </span><br><span class="line">sourceCount）</span><br><span class="line">    if (fromIndex &gt;= sourceCount) &#123;</span><br><span class="line">        return (targetCount == 0 ? sourceCount : -1);</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果开始搜索的位置小于0，则从0开始搜索</span><br><span class="line">    if (fromIndex &lt; 0) &#123;</span><br><span class="line">        fromIndex = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果 target 数组为空，则直接返回开始搜索的位置</span><br><span class="line">    if (targetCount == 0) &#123;</span><br><span class="line">        return fromIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    // 查找 target 数组的第一个字符在 source 数组中的位置</span><br><span class="line">    char first = target[targetOffset];</span><br><span class="line">    int max = sourceOffset + (sourceCount - targetCount);</span><br><span class="line">    // 循环查找 target 数组在 source 数组中的位置</span><br><span class="line">    for (int i = sourceOffset + fromIndex; i &lt;= max; i++) &#123;</span><br><span class="line">        /* Look for first character. */</span><br><span class="line">        // 如果 source 数组中当前位置的字符不是 target 数组的第一个字符，则在 source 数组中继</span><br><span class="line">续查找 target 数组的第一个字符</span><br><span class="line">        if (source[i] != first) &#123;</span><br><span class="line">            while (++i &lt;= max &amp;&amp; source[i] != first);</span><br><span class="line">        &#125;</span><br><span class="line">        /* Found first character, now look at the rest of v2 */</span><br><span class="line">        // 如果在 source 数组中找到了 target 数组的第一个字符，则继续查找 target 数组的剩余部</span><br><span class="line">分是否匹配</span><br><span class="line">        if (i &lt;= max) &#123;</span><br><span class="line">            int j = i + 1;</span><br><span class="line">            int end = j + targetCount - 1;</span><br><span class="line">            for (int k = targetOffset + 1; j &lt; end &amp;&amp; source[j]</span><br><span class="line">                    == target[k]; j++, k++);</span><br><span class="line">            // 如果 target 数组全部匹配，则返回在 source 数组中的位置索引</span><br><span class="line">            if (j == end) &#123;</span><br><span class="line">                /* Found whole string. */</span><br><span class="line">                return i - sourceOffset;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 没有找到 target 数组，则返回-1</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看示例。</p>
<p>①、示例1：查找子字符串的位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;Hello, world!&quot;;</span><br><span class="line">int index = str.indexOf(&quot;world&quot;);  // 查找 &quot;world&quot; 子字符串在 str 中第一次出现的位置</span><br><span class="line">System.out.println(index);        // 输出 7</span><br></pre></td></tr></table></figure>
<p>②、示例2：查找字符串中某个字符的位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;Hello, world!&quot;;</span><br><span class="line">int index = str.indexOf(&quot;,&quot;);     // 查找逗号在 str 中第一次出现的位置</span><br><span class="line">System.out.println(index);        // 输出 5</span><br></pre></td></tr></table></figure>
<p>③、示例3：查找子字符串的位置（从指定位置开始查找）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;Hello, world!&quot;;</span><br><span class="line">int index = str.indexOf(&quot;l&quot;, 3);  // 从索引为3的位置开始查找 &quot;l&quot; 子字符串在 str 中第一次出现的位置</span><br><span class="line">System.out.println(index);        // 输出 3</span><br></pre></td></tr></table></figure>
<p>④、示例4：查找多个子字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;Hello, world!&quot;;</span><br><span class="line">int index1 = str.indexOf(&quot;o&quot;);    // 查找 &quot;o&quot; 子字符串在 str 中第一次出现的位置</span><br><span class="line">int index2 = str.indexOf(&quot;o&quot;, 5); // 从索引为5的位置开始查找 &quot;o&quot; 子字符串在 str 中第一次出现的位置</span><br><span class="line">System.out.println(index1);       // 输出 4</span><br><span class="line">System.out.println(index2);       // 输出 8</span><br></pre></td></tr></table></figure>
<p><strong>String 类的其他方法 </strong></p>
<p>比如说 length() 用于返回字符串长度。</p>
<p>比如说 isEmpty() 用于判断字符串是否为空。</p>
<p>比如说 charAt() 用于返回指定索引处的字符。</p>
<p>比如说 getBytes() 用于返回字符串的字节数组，可以指定编码方式，比如说：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String text = &quot;沉默&quot;;</span><br><span class="line">System.out.println(Arrays.toString(text.getBytes(StandardCharsets.UTF_8)));</span><br></pre></td></tr></table></figure>
<p>比如说 trim() 用于去除字符串两侧的空白字符，来看源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public String trim() &#123;</span><br><span class="line">    int len = value.length;</span><br><span class="line">    int st = 0;</span><br><span class="line">    char[] val = value;    /* avoid getfield opcode */</span><br><span class="line">    while ((st &lt; len) &amp;&amp; (val[st] &lt;= &#x27; &#x27;)) &#123;</span><br><span class="line">        st++;</span><br><span class="line">    &#125;</span><br><span class="line">    while ((st &lt; len) &amp;&amp; (val[len - 1] &lt;= &#x27; &#x27;)) &#123;</span><br><span class="line">        len--;</span><br><span class="line">    &#125;</span><br><span class="line">    return ((st &gt; 0) || (len &lt; value.length)) ? substring(st, len) : this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举例： “  沉默   “.trim() 会返回”沉默”</p>
<p>除此之外，还有 split、equals、join 等这些方法，我们后面会一一来细讲。</p>
<h2 id="2-5-String为什么不可变"><a href="#2-5-String为什么不可变" class="headerlink" title="2.5 String为什么不可变"></a>2.5 String为什么不可变</h2><p>String 可能是 Java 中使用频率最高的引用类型了，因此 String 类的设计者可以说是用心良苦。比如说 String 的不可变性。</p>
<p>String 类被 final 关键字修饰，所以它不会有子类，这就意味着没有子类可以重写它的方法，改变它的行为。</p>
<p>String 类的数据存储在 char[] 数组中，而这个数组也被 final 关键字修饰了，这就表示 String 对象是没法被修改的，只要初始化一次，值就确定了。</p>
<p>“为什么要这样设计呢？”</p>
<p>“我先简单来说下，能懂最好，不能懂后面再细说。”</p>
<p>第一，可以保证 String 对象的安全性，避免被篡改，毕竟像密码这种隐私信息一般就是用字符串存储的。</p>
<p>以下是一个简单的 Java 示例，演示了字符串的不可变性如何有助于保证 String 对象的安全性。在本例中，我们创建了一个简单的 User 类，该类使用 String 类型的字段存储用户名和密码。同时，我们使用一个静态方法 getUserCredentials 从外部获取用户凭据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">    private String username;</span><br><span class="line">    private String password;</span><br><span class="line">    public User(String username, String password) &#123;</span><br><span class="line">        this.username = username;</span><br><span class="line">        this.password = password;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getUsername() &#123;</span><br><span class="line">        return username;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getPassword() &#123;</span><br><span class="line">        return password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class StringSecurityExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String username = &quot;沉默&quot;;</span><br><span class="line">        String password = &quot;123456&quot;;</span><br><span class="line">        User user = new User(username, password);</span><br><span class="line">        // 获取用户凭据</span><br><span class="line">        String[] credentials = getUserCredentials(user);</span><br><span class="line">        // 尝试修改从 getUserCredentials 返回的用户名和密码字符串</span><br><span class="line">        credentials[0] = &quot;陈清扬&quot;;</span><br><span class="line">        credentials[1] = &quot;612311&quot;;</span><br><span class="line">        // 输出原始 User 对象中的用户名和密码</span><br><span class="line">        System.out.println(&quot;原始用户名: &quot; + user.getUsername()); // 输出 &quot;JohnDoe&quot;</span><br><span class="line">        System.out.println(&quot;原始密码: &quot; + user.getPassword()); // 输出 </span><br><span class="line">&quot;mySecurePassword&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    public static String[] getUserCredentials(User user) &#123;</span><br><span class="line">        String[] credentials = new String[2];</span><br><span class="line">        credentials[0] = user.getUsername();</span><br><span class="line">        credentials[1] = user.getPassword();</span><br><span class="line">        return credentials;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，尽管我们尝试修改 getUserCredentials 返回的字符串数组（即用户名和密码），但原始 User 对象中的用户名和密码保持不变。这证明了字符串的不可变性有助于保护 String 对象的安全性。</p>
<p>第二，保证哈希值不会频繁变更。毕竟要经常作为哈希表的键值，经常变更的话，哈希表的性能就会很差劲。</p>
<p>在 String 类中，哈希值是在第一次计算时缓存的，后续对该哈希值的请求将直接使用缓存值。这有助于提高哈希表等数据结构的性能。以下是一个简单的示例，演示了字符串的哈希值缓存机制：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String text1 = &quot;沉默&quot;;</span><br><span class="line">String text2 = &quot;沉默&quot;;</span><br><span class="line">// 计算字符串 text1 的哈希值，此时会进行计算并缓存哈希值</span><br><span class="line">int hashCode1 = text1.hashCode();</span><br><span class="line">System.out.println(&quot;第一次计算 text1 的哈希值: &quot; + hashCode1);</span><br><span class="line">// 再次计算字符串 text1 的哈希值，此时直接返回缓存的哈希值</span><br><span class="line">int hashCode1Cached = text1.hashCode();</span><br><span class="line">System.out.println(&quot;第二次计算: &quot; + hashCode1Cached);</span><br><span class="line">// 计算字符串 text2 的哈希值，由于字符串常量池的存在，实际上 text1 和 text2 指向同一个字符串对象</span><br><span class="line">// 所以这里直接返回缓存的哈希值</span><br><span class="line">int hashCode2 = text2.hashCode();</span><br><span class="line">System.out.println(&quot;text2 直接使用缓存: &quot; + hashCode2);</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们创建了两个具有相同内容的字符串 text1 和 text2。首次计算 text1 的哈希值时，会进行实际计算并缓存该值。当我们再次计算 text1 的哈希值或计算具有相同内容的 text2 的哈希值时，将直接返回缓存的哈希值，而不进行重新计算。</p>
<p>由于 String 对象是不可变的，其哈希值在创建后不会发生变化。这使得 String 类可以缓存哈希值，提高哈希表等数据结构的性能。如果 String 是可变的，那么在每次修改时都需要重新计算哈希值，这会降低性能。</p>
<p>第三，可以实现字符串常量池，Java 会将相同内容的字符串存储在字符串常量池中。这样，具有相同内容的字符串变量可以指向同一个 String 对象，节省内存空间。</p>
<p>“由于字符串的不可变性，String 类的一些方法实现最终都返回了新的字符串对象。”</p>
<p>“就拿 substring() 方法来说。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public String substring(int beginIndex) &#123;</span><br><span class="line">    if (beginIndex &lt; 0) &#123;</span><br><span class="line">        throw new StringIndexOutOfBoundsException(beginIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    int subLen = value.length - beginIndex;</span><br><span class="line">    if (subLen &lt; 0) &#123;</span><br><span class="line">        throw new StringIndexOutOfBoundsException(subLen);</span><br><span class="line">    &#125;</span><br><span class="line">    return (beginIndex == 0) ? this : new String(value, beginIndex, subLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>substring() 方法用于截取字符串，最终返回的都是 new 出来的新字符串对象。</p>
<p>“还有 concat() 方法。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public String concat(String str) &#123;</span><br><span class="line">    int olen = str.length();</span><br><span class="line">    if (olen == 0) &#123;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">    if (coder() == str.coder()) &#123;</span><br><span class="line">        byte[] val = this.value;</span><br><span class="line">        byte[] oval = str.value;</span><br><span class="line">        int len = val.length + oval.length;</span><br><span class="line">        byte[] buf = Arrays.copyOf(val, len);</span><br><span class="line">        System.arraycopy(oval, 0, buf, val.length, oval.length);</span><br><span class="line">        return new String(buf, coder);</span><br><span class="line">    &#125;</span><br><span class="line">    int len = length();</span><br><span class="line">    byte[] buf = StringUTF16.newBytesFor(len + olen);</span><br><span class="line">    getBytes(buf, 0, UTF16);</span><br><span class="line">    str.getBytes(buf, len, UTF16);</span><br><span class="line">    return new String(buf, UTF16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>concat() 方法用于拼接字符串，<strong>不管编码是否一致，最终也返回的是新的字符串对象。</strong></p>
<p>“ replace() 替换方法其实也一样，三妹，你可以自己一会看一下源码，也是返回新的字符串对象。”</p>
<p>“这就意味着，不管是截取、拼接，还是替换，都不是在原有的字符串上进行的，而是<strong>重新生成了新的字符串对象</strong>。也就是说，这些操作执行过后，<strong>原来的字符串对象并没有发生改变。”</strong></p>
<p>“String 对象一旦被创建后就固定不变了，对 String 对象的任何修改都不会影响到原来的字符串对象，都会生成新的字符串对象。”</p>
<p><strong>2.6 深入理解Java字符串常量池 </strong></p>
<p>“今天我们来学习一下字符串常量池，这是字符串中非常关键的一个知识点。”</p>
<p>new String(“二哥”)创建了几个对象 </p>
<p>“先从这道面试题开始吧！”</p>
<p>“这行代码创建了几个对象？”</p>
<p>“不就一个吗？”</p>
<p>“不，两个！”“使用 new 关键字创建一个字符串对象时，Java 虚拟机会先在字符串常量池中查找有没有‘二哥’这个字符串对象，如果有，就不会在字符串常量池中创建‘二哥’这个对象了，直接在堆中创建一个‘二哥’的字符串对象，然后将堆中这个‘二哥’的对象地址返回赋值给变量 s。”</p>
<p>“如果没有，先在字符串常量池中创建一个‘二哥’的字符串对象，然后再在堆中创建一个‘二哥’的字符串对象，然后将堆中这个‘二哥’的字符串对象地址返回赋值给变量 s。”</p>
<p>我画图表示一下，会更加清楚。</p>
<p><img src="\assets\note\image-20230927103252744.png" alt="image-20230927103252744"></p>
<p>在Java中，栈上存储的是基本数据类型的变量和对象的引用，而对象本身则存储在堆上。</p>
<p>对于这行代码 String s = new String(“二哥”); ，它创建了两个对象：一个是字符串对象 “二哥”，它被添加到了字符串常量池中，另一个是通过 new String() 构造函数创建的字符串对象 “二哥”，它被分配在堆内存中，同时引用变量 s 存储在栈上，它指向堆内存中的字符串对象 “二哥”。</p>
<p>“为什么要先在字符串常量池中创建对象，然后再在堆上创建呢？这样不就多此一举了？”</p>
<p>我回答，“是的。由于字符串的使用频率实在是太高了，所以 Java 虚拟机为了提高性能和减少内存开销，在创建字符串对象的时候进行了一些优化，特意为字符串开辟了一块空间——也就是字符串常量池。”</p>
<p><strong>字符串常量池的作用 </strong></p>
<p>通常情况下，我们会采用双引号的方式来创建字符串对象，而不是通过 new 关键字的方式，就像下面 这样，这样就不会多此一举：</p>
<p>当执行 String s = “三妹” 时，Java 虚拟机会先在字符串常量池中查找有没有“三妹”这个字符串对象，如果有，则不创建任何对象，直接将字符串常量池中这个“三妹”的对象地址返回，赋给变量 s；如果没有，在字符串常量池中创建“三妹”这个对象，然后将其地址返回，赋给变量 s。</p>
<p><img src="\assets\note\image-20230927103456823.png" alt="image-20230927103456823"></p>
<p>Java 虚拟机创建了一个字符串对象 “三妹”，它被添加到了字符串常量池中，同时引用变量 s 存储在栈上，它指向字符串常量池中的字符串对象 “三妹”。你看，是不是省了一步，比之前高效了。</p>
<p>““有了字符串常量池，就可以通过双引号的方式直接创建字符串对象，不用再通过 new 的方式在堆中创建对象了，对吧？”</p>
<p>“是滴。new 的方式始终会创建一个对象，不管字符串的内容是否已经存在，而双引号的方式会重复利用字符串常量池中已经存在的对象。”我说。</p>
<p>来看下面这个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = new String(&quot;二哥&quot;);</span><br><span class="line">String s1 = new String(&quot;二哥&quot;);</span><br></pre></td></tr></table></figure>
<p>按照我们之前的分析，这两行代码会创建三个对象，字符串常量池中一个，堆上两个。</p>
<p>再来看下面这个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = &quot;三妹&quot;;</span><br><span class="line">String s1 = &quot;三妹&quot;;</span><br></pre></td></tr></table></figure>
<p>这两行代码只会创建一个对象，就是字符串常量池中的那个。这样的话，性能肯定就提高了！</p>
<p><strong>字符串常量池在内存中的什么位置呢？ </strong></p>
<p>分为三个阶段。</p>
<p><strong>Java 7 之前 </strong></p>
<p>在 Java 7 之前，字符串常量池位于永久代（Permanent Generation）的内存区域中，主要用来存储一些字符串常量（静态数据的一种）。永久代是 Java 堆（Java Heap）的一部分，用于存储类信息、方法信息、常量池信息等静态数据。</p>
<p>而 Java 堆是 JVM 中存储对象实例和数组的内存区域，也就是说，永久代是 Java 堆的一个子区域。换句话说，永久代中存储的静态数据与堆中存储的对象实例和数组是分开的，它们有不同的生命周期和分配方式。</p>
<p>但是，永久代和堆的大小是相互影响的，因为它们都使用了 JVM 堆内存，因此它们的大小都受到 JVM 堆大小的限制。</p>
<p>于是，当我们创建一个字符串常量时，它会被储存在永久代的字符串常量池中。如果我们创建一个普通字符串对象，则它将被储存在堆中。如果字符串对象的内容是一个已经存在于字符串常量池中的字符串常量，那么这个对象会指向已经存在的字符串常量，而不是重新创建一个新的字符串对象。</p>
<p>画幅图，大概就是这个样子。</p>
<p><img src="\assets\note\image-20230927103826496.png" alt="image-20230927103826496"></p>
<p><strong>Java 7 </strong></p>
<p>需要注意的是，永久代的大小是有限的，并且很难准确地确定一个应用程序需要多少永久代空间。如果我们在应用程序中使用了大量的类、方法、常量等静态数据，就有可能导致永久代空间不足。这种情况下，JVM 就会抛出 OutOfMemoryError 错误。</p>
<p>因此，从 Java 7 开始，为了解决永久代空间不足的问题，将字符串常量池从永久代中移动到堆中。这个改变也是为了更好地支持动态语言的运行时特性。</p>
<p>再画幅图，大概就是这样子。</p>
<p><img src="\assets\note\image-20230927103920703.png" alt="image-20230927103920703"></p>
<p><strong>Java 8 </strong></p>
<p>到了 Java 8，永久代（PermGen）被取消，并由元空间（Metaspace）取代。元空间是一块本机内存区域，和 JVM 内存区域是分开的。不过，元空间的作用依然和之前的永久代一样，用于存储类信息、方法信息、常量池信息等静态数据。</p>
<p>与永久代不同，元空间具有一些优点，例如：</p>
<ul>
<li>它不会导致 OutOfMemoryError 错误，因为元空间的大小可以动态调整。</li>
<li>元空间使用本机内存，而不是 JVM 堆内存，这可以避免堆内存的碎片化问题。</li>
<li>元空间中的垃圾收集与堆中的垃圾收集是分离的，这可以避免应用程序在运行过程中因为进行类加载和卸载而频繁地触发 Full GC。</li>
</ul>
<p>再画幅图，对比来看一下，就会一目了然。</p>
<p><img src="\assets\note\image-20230927104032476.png" alt="image-20230927104032476"></p>
<p><strong>永久代、方法区、元空间 </strong></p>
<p>“能再简单给我解释一下方法区，永久代和元空间的概念吗？有点模糊。”</p>
<p>“可以呀。”</p>
<ul>
<li>方法区是 Java 虚拟机规范中的一个概念，就像是一个接口吧；</li>
<li>永久代是 HotSpot 虚拟机中对方法区的一个实现，就像是接口的实现类；</li>
<li>Java 8 的时候，移除了永久代，取而代之的是元空间，是方法区的另外一种实现，更灵活了。</li>
</ul>
<p>永久代是放在运行时数据区中的，所以它的大小受到 Java 虚拟机本身大小的限制，所以 Java 8 之前，会经常遇到 java.lang.OutOfMemoryError: PremGen Space 的异常，PremGen Space 就是方法区的意思；而元空间是直接放在内存中的，所以只受本机可用内存的限制。</p>
<h2 id="2-7-详解-String-intern-方法"><a href="#2-7-详解-String-intern-方法" class="headerlink" title="2.7 详解 String.intern() 方法"></a>2.7 详解 String.intern() 方法</h2><p>“看一下美团技术团队深入解析 String.intern() 文章”</p>
<p>要理解美团技术团队的这篇文章，你只需要记住这几点内容：</p>
<p>第一，使用双引号声明的字符串对象会保存在字符串常量池中。</p>
<p>第二，使用 new 关键字创建的字符串对象会先从字符串常量池中找，如果没找到就创建一个，然后再在堆中创建字符串对象；如果找到了，就直接在堆中创建字符串对象。</p>
<p>第三，针对没有使用双引号声明的字符串对象来说，就像下面代码中的 s1 那样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s1 = new String(&quot;二哥&quot;) + new String(&quot;三妹&quot;);</span><br></pre></td></tr></table></figure>
<p>如果想把 s1 的内容也放入字符串常量池的话，可以调用 intern() 方法来完成。</p>
<p>不过，需要注意的是，Java 7 的时候，字符串常量池从永久代中移动到了堆中，虽然此时永久代还没有完全被移除。Java 8 的时候，永久代被彻底移除。</p>
<p>这个变化也直接影响了  String.intern() 方法在执行时的策略，Java 7 之前，执行 String.intern() 方法的时候，不管对象在堆中是否已经创建，字符串常量池中仍然会创建一个内容完全相同的新对象； Java 7 之后呢，由于字符串常量池放在了堆中，执行 String.intern() 方法的时候，如果对象在堆中已经创建了，字符串常量池中就不需要再创建新的对象了，而是直接保存堆中对象的引用，也就节省了一部分的内存<br>空间。</p>
<p>“先来猜猜这段代码输出的结果吧。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1 = new String(&quot;二哥三妹&quot;);</span><br><span class="line">String s2 = s1.intern();</span><br><span class="line">System.out.println(s1 == s2);</span><br></pre></td></tr></table></figure>
<p>第一行代码，字符串常量池中会先创建一个“二哥三妹”的对象，然后堆中会再创建一个“二哥三妹”的对象，s1 引用的是堆中的对象。</p>
<p>第二行代码，对 s1 执行 intern() 方法，该方法会从字符串常量池中查找“二哥三妹”这个字符串是否存在，此时是存在的，所以 s2 引用的是字符串常量池中的对象。</p>
<p>也就意味着 s1 和 s2 的引用地址是不同的，一个来自堆，一个来自字符串常量池，所以输出的结果为 false。</p>
<p>“来看一下运行结果。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">false</span><br></pre></td></tr></table></figure>
<p>“我来画幅图，帮助你理解下。”</p>
<p><img src="\assets\note\image-20230927104641609.png" alt="image-20230927104641609"></p>
<p>“好，我们再来看下面这段代码。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1 = new String(&quot;二哥&quot;) + new String(&quot;三妹&quot;);</span><br><span class="line">String s2 = s1.intern();</span><br><span class="line">System.out.println(s1 == s2);</span><br></pre></td></tr></table></figure>
<p>“难道也输出 false ？”</p>
<p>“不，这段代码会输出 true。”</p>
<p>“为啥呀？”</p>
<p>第一行代码，会在字符串常量池中创建两个对象，一个是“二哥”，一个是“三妹”，然后在堆中会创建两个匿名对象“二哥”和“三妹”，最后还有一个“二哥三妹”的对象（稍后会解释），s1 引用的是堆中“二哥三妹”这个对象。</p>
<p>第二行代码，对 s1 执行 intern() 方法，该方法会从字符串常量池中查找“二哥三妹”这个对象是否存在，此时不存在的，但堆中已经存在了，所以字符串常量池中保存的是堆中这个“二哥三妹”对象的引用，也就是说，s2 和 s1 的引用地址是相同的，所以输出的结果为 true。</p>
<p>“来看一下运行结果。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure>
<p>“我再来画幅图，帮助你理解下。”</p>
<p><img src="\assets\note\image-20230927104855320.png" alt="image-20230927104855320"></p>
<p>“不过，我有一个疑惑，“二哥三妹”这个对象是什么时候创建的呢？”</p>
<p>“不错嘛，能抓住问题的关键。再来解释一下 String s1 = new String(“二哥”) + new String(“三妹”) 这行代码。”</p>
<ol>
<li>创建 “二哥” 字符串对象，存储在字符串常量池中。</li>
<li>创建 “三妹” 字符串对象，存储在字符串常量池中。</li>
<li>执行 new String(“二哥”) ，在堆上创建一个字符串对象，内容为 “二哥”。</li>
<li>执行 new String(“三妹”) ，在堆上创建一个字符串对象，内容为 “三妹”。</li>
<li>执行 new String(“二哥”) + new String(“三妹”) ，会创建一个 StringBuilder 对象，并将 “二哥” 和 “三妹” 追加到其中，然后调用 StringBuilder 对象的 toString() 方法，将其转换为一个新的字符串对象，内容为 “二哥三妹”。这个新的字符串对象存储在堆上。</li>
</ol>
<p>也就是说，当编译器遇到 + 号这个操作符的时候，会将 new String(“二哥”) + new String(“三妹”) 这行代码编译为以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new StringBuilder().append(&quot;二哥&quot;).append(&quot;三妹&quot;).toString();</span><br></pre></td></tr></table></figure>
<p>实际执行过程如下：</p>
<ul>
<li>创建一个 StringBuilder 对象。</li>
<li>在 StringBuilder 对象上调用 append(“二哥”)，将 “二哥” 追加到 StringBuilder 中。</li>
<li>在 StringBuilder 对象上调用 append(“三妹”)，将 “三妹” 追加到 StringBuilder 中。</li>
<li>在 StringBuilder 对象上调用 toString() 方法，将 StringBuilder 转换为一个新的字符串对象，内容为 “二哥三妹”。</li>
</ul>
<p>关于 StringBuilder，我们随后会详细地讲到。今天先了解到这。</p>
<p>不过需要注意的是，尽管 intern 可以确保所有具有相同内容的字符串共享相同的内存空间，但也不要烂用 intern，因为任何的缓存池都是有大小限制的，不能无缘无故就占用了相对稀缺的缓存空间，导致其他字符串没有坑位可占。</p>
<p>另外，字符串常量池本质上是一个固定大小的 StringTable，如果放进去的字符串过多，就会造成严重的哈希冲突，从而导致链表变长，链表变长也就意味着字符串常量池的性能会大幅下降，因为要一个一个找是需要花费时间的。</p>
<h2 id="2-8-String、StringBuilder、StringBuffer"><a href="#2-8-String、StringBuilder、StringBuffer" class="headerlink" title="2.8 String、StringBuilder、StringBuffer"></a>2.8 String、StringBuilder、StringBuffer</h2><p>“上一篇深入理解 String.intern() 讲到了 StringBuilder，这一节我们就来聊聊吧！”</p>
<p>由于字符串是不可变的，所以当遇到字符串拼接（尤其是使用 +号操作符）的时候，就需要考量性能的问题，你不能毫无顾虑地生产太多 String 对象，对珍贵的内存造成不必要的压力。</p>
<p>于是 Java 就设计了一个专门用来解决此问题的 StringBuffer 类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public final class StringBuffer extends AbstractStringBuilder implements </span><br><span class="line">Serializable, CharSequence &#123;</span><br><span class="line">    public StringBuffer() &#123;</span><br><span class="line">        super(16);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public synchronized StringBuffer append(String str) &#123;</span><br><span class="line">        super.append(str);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">    public synchronized String toString() &#123;</span><br><span class="line">        return new String(value, 0, count);</span><br><span class="line">    &#125;</span><br><span class="line">    // 其他方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过，由于 StringBuffer 操作字符串的方法加了 synchronized 关键字进行了同步，主要是考虑到多线程环境下的安全问题，所以执行效率会比较低。</p>
<p>于是 Java 就给 StringBuffer “生了个兄弟”，名叫 StringBuilder，说，“孩子，你别管线程安全了，你就在单线程环境下使用，这样效率会高得多，如果要在多线程环境下修改字符串，你到时候可以使用 ThreadLocal 来避免多线程冲突。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public final class StringBuilder extends AbstractStringBuilder</span><br><span class="line">    implements java.io.Serializable, CharSequence</span><br><span class="line">&#123;</span><br><span class="line">    // ...</span><br><span class="line">    public StringBuilder append(String str) &#123;</span><br><span class="line">        super.append(str);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        // Create a copy, don&#x27;t share the array</span><br><span class="line">        return new String(value, 0, count);</span><br><span class="line">    &#125;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了类名不同，方法没有加 synchronized，基本上完全一样。</p>
<p>实际开发中，StringBuilder 的使用频率也是远高于 StringBuffer，甚至可以这么说，StringBuilder 完全取代了 StringBuffer。</p>
<p>之前我们也曾聊过，Java 是一门解释型的编程语言，所以当编译器遇到 + 号这个操作符的时候，会将 new String(“二哥”) + new String(“三妹”) 这行代码编译为以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new StringBuilder().append(&quot;二哥&quot;).append(&quot;三妹&quot;).toString();</span><br></pre></td></tr></table></figure>
<p>这个过程是我们看不见的，但这正是 Java 的“智能”之处，它可以在编译的时候偷偷地帮我们做很多优化，这样既可以提高我们的开发效率（ + 号写起来比创建 StringBuilder 对象便捷得多），也不会影响 JVM 的执行效率。</p>
<p>当然了，如果我们使用 javap 反编译 new String(“二哥”) + new String(“三妹”) 的字节码的时候，也是能看出 StringBuilder 的影子的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">0: new           #2                  // class java/lang/StringBuilder</span><br><span class="line">3: dup</span><br><span class="line">4: invokespecial #3                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">7: new           #4                  // class java/lang/String</span><br><span class="line">10: dup</span><br><span class="line">11: ldc           #5                  // String 二哥</span><br><span class="line">13: invokespecial #6                  // Method java/lang/String.&quot;&lt;init&gt;&quot;:</span><br><span class="line">(Ljava/lang/String;)V</span><br><span class="line">16: invokevirtual #7                  // Method java/lang/StringBuilder.append:</span><br><span class="line">(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">19: new           #4                  // class java/lang/String</span><br><span class="line">22: dup</span><br><span class="line">23: ldc           #8                  // String 三妹</span><br><span class="line">25: invokespecial #6                  // Method java/lang/String.&quot;&lt;init&gt;&quot;:</span><br><span class="line">(Ljava/lang/String;)V</span><br><span class="line">28: invokevirtual #7                  // Method java/lang/StringBuilder.append:</span><br><span class="line">(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">31: invokevirtual #9                  // Method java/lang/StringBuilder.toString:</span><br><span class="line">()Ljava/lang/String;</span><br><span class="line">34: areturn</span><br></pre></td></tr></table></figure>
<p>可以看到 Java 编译器将字符串拼接操作（ + ）转换为了 StringBuilder 对象的 append 方法，然后再调用 StringBuilder 对象的 toString 方法返回拼接后的字符串。</p>
<p>来看一下 StringBuilder 的 toString 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public String toString() &#123;</span><br><span class="line">    return new String(value, 0, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>value 是一个 char 类型的数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The value is used for character storage.</span><br><span class="line"> */</span><br><span class="line">char[] value;</span><br></pre></td></tr></table></figure>
<p>在 StringBuilder 对象创建时，会为 value 分配一定的内存空间（初始容量 16），用于存储字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Constructs a string builder with no characters in it and an</span><br><span class="line"> * initial capacity of 16 characters.</span><br><span class="line"> */</span><br><span class="line">public StringBuilder() &#123;</span><br><span class="line">    super(16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>随着字符串的拼接，value 数组的长度会不断增加，因此在 StringBuilder 对象的实现中，value 数组的长度是可以<strong>动态扩展的，就像ArrayList那样。</strong></p>
<p>继续来看 StringBuilder 的 toString 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public String toString() &#123;</span><br><span class="line">    return new String(value, 0, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>value 用于存储 StringBuilder 对象中包含的字符序列。count 是一个 int 类型的变量，表示字符序列的长度。toString() 方法会调用 new String(value, 0, count) ，使用 value 数组中从 0 开始的前 count 个元素创建一个新的字符串对象，并将其返回。</p>
<p>再来看一下 append 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public StringBuilder append(String str) &#123;</span><br><span class="line">    super.append(str);</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上是调用了 AbstractStringBuilder 中的 append(String str) 方法。在 AbstractStringBuilder 中，append(String str) 方法会检查当前字符序列中的字符是否够用，如果不够用则会进行扩容，并将指定字符串追加到字符序列的末尾。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Appends the specified string to this character sequence.</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * The characters of the &#123;@code String&#125; argument are appended, in order,</span><br><span class="line"> * increasing the length of this sequence by the length of the argument.</span><br><span class="line"> * If &#123;@code str&#125; is &#123;@code null&#125;, then the four characters &#123;@code &quot;null&quot;&#125;</span><br><span class="line"> * are appended.</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * Let &lt;i&gt;n&lt;/i&gt; be the length of this character sequence just prior to</span><br><span class="line"> * execution of the &#123;@code append&#125; method. Then the character at index</span><br><span class="line"> * &lt;i&gt;k&lt;/i&gt; in this character sequence is equal to the character at index</span><br><span class="line"> * &lt;i&gt;k&lt;/i&gt; in the argument &#123;@code str&#125;, if &lt;i&gt;k&lt;/i&gt; is less than</span><br><span class="line"> * &lt;i&gt;n&lt;/i&gt;; otherwise, it is equal to the character at index</span><br><span class="line"> * &lt;i&gt;k-n&lt;/i&gt; in the argument &#123;@code str&#125;.</span><br><span class="line"> *</span><br><span class="line"> * @param   str   a string.</span><br><span class="line"> * @return  a reference to this object.</span><br><span class="line"> */</span><br><span class="line">public AbstractStringBuilder append(String str) &#123;</span><br><span class="line">    if (str == null)</span><br><span class="line">        return appendNull();</span><br><span class="line">    int len = str.length();</span><br><span class="line">    ensureCapacityInternal(count + len);</span><br><span class="line">    str.getChars(0, len, value, count);</span><br><span class="line">    count += len;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>append(String str) 方法将指定字符串追加到当前字符序列中。如果指定字符串为 null，则追加字符串 “null”；否则会检查指定字符串的长度，然后根据当前字符序列中的字符数和指定字符串的长度来判断是否需要扩容。</p>
<p>如果需要扩容，则会调用 ensureCapacityInternal(int minimumCapacity)方法进行扩容。扩容之后，将指定字符串的字符拷贝到字符序列中。</p>
<p>来看一下 ensureCapacityInternal 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private void ensureCapacityInternal(int minimumCapacity) &#123;</span><br><span class="line">    // overflow-conscious code</span><br><span class="line">    if (minimumCapacity - value.length &gt; 0)</span><br><span class="line">        expandCapacity(minimumCapacity);</span><br><span class="line">&#125;</span><br><span class="line">void expandCapacity(int minimumCapacity) &#123;</span><br><span class="line">    int newCapacity = value.length * 2 + 2;</span><br><span class="line">    if (newCapacity - minimumCapacity &lt; 0)</span><br><span class="line">        newCapacity = minimumCapacity;</span><br><span class="line">    if (newCapacity &lt; 0) &#123;</span><br><span class="line">        if (minimumCapacity &lt; 0) // overflow</span><br><span class="line">            throw new OutOfMemoryError();</span><br><span class="line">        newCapacity = Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    value = Arrays.copyOf(value, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ensureCapacityInternal(int minimumCapacity) 方法用于确保当前字符序列的容量至少等于指定的最小容量 minimumCapacity。如果当前容量小于指定的容量，就会为字符序列分配一个新的内部数组。新容量的计算方式如下：</p>
<ul>
<li>如果指定的最小容量大于当前容量，则新容量为两倍的旧容量加上 2；</li>
<li>如果指定的最小容量小于等于当前容量，则不会进行扩容，直接返回当前对象。</li>
</ul>
<p>在进行扩容之前， ensureCapacityInternal(int minimumCapacity) 方法会先检查当前字符序列的容量是否足够，如果不足就会调用 expandCapacity(int minimumCapacity) 方法进行扩容。</p>
<p>expandCapacity(int minimumCapacity) 方法首先计算出新容量，然后使用 Arrays.copyOf(char[] original, int newLength) 方法将原字符数组扩容到新容量的大小。</p>
<p>关于扩容，后面在讲ArrayList的时候会再次说明，今天就先聊到这吧。</p>
<h2 id="2-9-String相等判断"><a href="#2-9-String相等判断" class="headerlink" title="2.9 String相等判断"></a>2.9 String相等判断</h2><p>“如何比较两个字符串相等啊？”</p>
<p>“这个问题看似简单，却在 Stack Overflow 上有超过 370 万+的访问量。”我说，“这个问题也可以引申为 .equals() 和 ‘\==’ 操作符有什么区别。”</p>
<ul>
<li>“\==”操作符用于比较两个对象的地址是否相等。</li>
<li>.equals() 方法用于比较两个对象的内容是否相等。</li>
</ul>
<p>“我来举个不恰当又很恰当的例子，一看你就明白了。”</p>
<p>有一对双胞胎，姐姐叫阿丽塔，妹妹叫洛丽塔。我们普通人可能完全无法分辨谁是姐姐谁是妹妹，可她们的妈妈却可以轻而易举地辨认出。</p>
<p><img src="\assets\note\image-20230927110501241.png" alt="image-20230927110501241"></p>
<p>.equals() 就好像我们普通人，看见阿丽塔以为是洛丽塔，看见洛丽塔以为是阿丽塔，看起来一样就觉得她们是同一个人；“\==”操作符就好像她们的妈妈，要求更严格，观察更细致，一眼就能分辨出谁是姐姐谁是妹妹。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String alita = new String(&quot;小萝莉&quot;);</span><br><span class="line">String luolita = new String(&quot;小萝莉&quot;);</span><br><span class="line">System.out.println(alita.equals(luolita)); // true</span><br><span class="line">System.out.println(alita == luolita); // false</span><br></pre></td></tr></table></figure>
<p>就上面这段代码来说， .equals() 输出的结果为 true，而“\==”操作符输出的结果为 false——前者要求内容相等就可以，后者要求必须是同一个对象。</p>
<p>“之前已经学过了，Java 的所有类都默认地继承 Object 这个超类，该类有一个名为 .equals() 的方法。”一边说，我一边打开了 Object 类的源码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">    return (this == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你看，Object 类的 .equals() 方法默认采用的是“\==”操作符进行比较。假如子类没有重写该方法的话，那么“\==”操作符和 .equals() 方法的功效就完全一样——比较两个对象的内存地址是否相等。</p>
<p>但实际情况中，有不少类重写了 .equals() 方法，因为比较内存地址的要求比较严格，不太符合现实中所有的场景需求。拿 String 类来说，我们在比较字符串的时候，的确只想判断它们俩的内容是相等的就可以了，并不想比较它们俩是不是同一个对象。</p>
<p>况且，字符串有字符串常量池的概念，本身就推荐使用 String s = “字符串” 这种形式来创建字符串对象，而不是通过 new 关键字的方式，因为可以把字符串缓存在字符串常量池中，方便下次使用，不用遇到 new 就在堆上开辟一块新的空间。</p>
<p>“那就来看一下 String 类的 .equals() 方法的源码吧。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object anObject) &#123;</span><br><span class="line">    if (this == anObject) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (anObject instanceof String) &#123;</span><br><span class="line">        String aString = (String)anObject;</span><br><span class="line">        if (coder() == aString.coder()) &#123;</span><br><span class="line">            return isLatin1() ? StringLatin1.equals(value, aString.value)</span><br><span class="line">                    : StringUTF16.equals(value, aString.value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，如果两个字符串对象的可以“\==”，那就直接返回 true 了，因为这种情况下，字符串内容是必然相等的。否则就按照字符编码进行比较，分为 UTF16 和 Latin1，差别不是很大，就拿 Latin1 的来说吧。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@HotSpotIntrinsicCandidate</span><br><span class="line">public static boolean equals(byte[] value, byte[] other) &#123;</span><br><span class="line">    if (value.length == other.length) &#123;</span><br><span class="line">        for (int i = 0; i &lt; value.length; i++) &#123;</span><br><span class="line">            if (value[i] != other[i]) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 JDK 版本是 Java 17，也就是最新的 LTS（长期支持）版本。该版本中，String 类使用字节数组实现的，所以比较两个字符串的内容是否相等时，可以先比较字节数组的长度是否相等，不相等就直接返回 false；否则就遍历两个字符串的字节数组，只有有一个字节不相等，就返回 false。</p>
<p>这是 Java 8 中的 equals 方法源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object anObject) &#123;</span><br><span class="line">    // 判断是否为同一对象</span><br><span class="line">    if (this == anObject) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    // 判断对象是否为 String 类型</span><br><span class="line">    if (anObject instanceof String) &#123;</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        int n = value.length;</span><br><span class="line">        // 判断字符串长度是否相等</span><br><span class="line">        if (n == anotherString.value.length) &#123;</span><br><span class="line">            char v1[] = value;</span><br><span class="line">            char v2[] = anotherString.value;</span><br><span class="line">            int i = 0;</span><br><span class="line">            // 判断每个字符是否相等</span><br><span class="line">            while (n-- != 0) &#123;</span><br><span class="line">                if (v1[i] != v2[i])</span><br><span class="line">                    return false;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JDK 8 比 JDK 17 更容易懂一些：首先判断两个对象是否为同一个对象，如果是，则返回 true。接着，判断对象是否为 String 类型，如果不是，则返回 false。如果对象为 String 类型，则比较两个字符串的长度是否相等，如果长度不相等，则返回 false。如果长度相等，则逐个比较每个字符是否相等，如果都相等，则返回 true，否则返回 false。</p>
<p>“那出几道题考考你吧！”</p>
<p>第一题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new String(&quot;小萝莉&quot;).equals(&quot;小萝莉&quot;)</span><br></pre></td></tr></table></figure>
<p>“输出什么呢？”我问。</p>
<p>“ .equals() 比较的是两个字符串对象的内容是否相等，所以结果为 true。”</p>
<p>第二题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new String(&quot;小萝莉&quot;) == &quot;小萝莉&quot;</span><br></pre></td></tr></table></figure>
<p>“==操作符左侧的是在堆中创建的对象，右侧是在字符串常量池中的对象，尽管内容相同，但内存地址不同，所以返回 false。”</p>
<p>第三题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new String(&quot;小萝莉&quot;) == new String(&quot;小萝莉&quot;)</span><br></pre></td></tr></table></figure>
<p>“new 出来的对象肯定是完全不同的内存地址，所以返回 false。”</p>
<p>第四题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;小萝莉&quot; == &quot;小萝莉&quot;</span><br></pre></td></tr></table></figure>
<p>“字符串常量池中只会有一个相同内容的对象，所以返回 true。”</p>
<p>第五题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;小萝莉&quot; == &quot;小&quot; + &quot;萝莉&quot;</span><br></pre></td></tr></table></figure>
<p>“由于‘小’和‘萝莉’都在字符串常量池，所以编译器在遇到‘+’操作符的时候将其自动优化为“小萝莉”，所以返回 true。”</p>
<p>PS：至于为什么，查看这篇String、StringBuilder、StringBuffer</p>
<p>第六题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new String(&quot;小萝莉&quot;).intern() == &quot;小萝莉&quot;</span><br></pre></td></tr></table></figure>
<p>“ new String(“小萝莉”) 在执行的时候，会先在字符串常量池中创建对象，然后再在堆中创建对象；执行 intern() 方法的时候发现字符串常量池中已经有了‘小萝莉’这个对象，所以就直接返回字符串常量池中的对象引用了，那再与字符串常量池中的‘小萝莉’比较，当然会返回 true 了。”</p>
<p>PS：intern 方法我们之前已经深究过了。</p>
<p>“哥再给你补充一点。”</p>
<p>“如果要进行两个字符串对象的内容比较，除了 .equals() 方法，还有其他两个可选的方案。”</p>
<p>1） Objects.equals()</p>
<p>Objects.equals() 这个静态方法的优势在于不需要在调用之前判空。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static boolean equals(Object a, Object b) &#123;</span><br><span class="line">    return (a == b) || (a != null &amp;&amp; a.equals(b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果直接使用 a.equals(b) ，则需要在调用之前对 a 进行判空，否则可能会抛出空指针 java.lang.NullPointerException 。 Objects.equals() 用起来就完全没有这个担心。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Objects.equals(&quot;小萝莉&quot;, new String(&quot;小&quot; + &quot;萝莉&quot;)) // --&gt; true</span><br><span class="line">Objects.equals(null, new String(&quot;小&quot; + &quot;萝莉&quot;)); // --&gt; false</span><br><span class="line">Objects.equals(null, null) // --&gt; true</span><br><span class="line">String a = null;</span><br><span class="line">a.equals(new String(&quot;小&quot; + &quot;萝莉&quot;)); // throw exception</span><br></pre></td></tr></table></figure>
<p>2）String 类的 .contentEquals()</p>
<p>.contentEquals() 的优势在于可以将字符串与任何的字符序列（StringBuffer、StringBuilder、String、CharSequence）进行比较。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public boolean contentEquals(CharSequence cs) &#123;</span><br><span class="line">    // Argument is a StringBuffer, StringBuilder</span><br><span class="line">    if (cs instanceof AbstractStringBuilder) &#123;</span><br><span class="line">        if (cs instanceof StringBuffer) &#123;</span><br><span class="line">            synchronized(cs) &#123;</span><br><span class="line">                return nonSyncContentEquals((AbstractStringBuilder)cs);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return nonSyncContentEquals((AbstractStringBuilder)cs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // Argument is a String</span><br><span class="line">    if (cs instanceof String) &#123;</span><br><span class="line">        return equals(cs);</span><br><span class="line">    &#125;</span><br><span class="line">    // Argument is a generic CharSequence</span><br><span class="line">    int n = cs.length();</span><br><span class="line">    if (n != length()) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    byte[] val = this.value;</span><br><span class="line">    if (isLatin1()) &#123;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            if ((val[i] &amp; 0xff) != cs.charAt(i)) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (!StringUTF16.contentEquals(val, cs, n)) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从源码上可以看得出，如果 cs 是 StringBuffer，该方法还会进行同步，非常的智能化；如果是 String 的话，其实调用的还是 equals() 方法。当然了，这也就意味着使用该方法进行比较的时候，多出来了很多步骤，性能上有些损失。</p>
<p>同样来看一下 JDK 8 的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public boolean contentEquals(CharSequence cs) &#123;</span><br><span class="line">    // argument can be any CharSequence implementation</span><br><span class="line">    if (cs.length() != value.length) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    // Argument is a StringBuffer, StringBuilder or String</span><br><span class="line">    if (cs instanceof AbstractStringBuilder) &#123;</span><br><span class="line">        char v1[] = value;</span><br><span class="line">        char v2[] = ((AbstractStringBuilder)cs).getValue();</span><br><span class="line">        int i = 0;</span><br><span class="line">        int n = value.length;</span><br><span class="line">        while (n-- != 0) &#123;</span><br><span class="line">            if (v1[i] != v2[i])</span><br><span class="line">                return false;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    // Argument is a String</span><br><span class="line">    if (cs.equals(this))</span><br><span class="line">        return true;</span><br><span class="line">    // Argument is a non-String, non-AbstractStringBuilder CharSequence</span><br><span class="line">    char v1[] = value;</span><br><span class="line">    int i = 0;</span><br><span class="line">    int n = value.length;</span><br><span class="line">    while (n-- != 0) &#123;</span><br><span class="line">        if (v1[i] != cs.charAt(i))</span><br><span class="line">            return false;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   同样更容易理解一些：首先判断参数长度是否相等，不相等则返回 false。如果参数是 AbstractStringBuilder 的实例，则取出其 char 数组，遍历比较两个 char 数组的每个元素是否相等。如果参数是 String 的实例，则直接调用 equals 方法比较两个字符串是否相等。如果参数是其他实现了 CharSequence 接口的对象，则遍历比较两个对象的每个字符是否相等。    </p>
<h2 id="2-10-String拼接"><a href="#2-10-String拼接" class="headerlink" title="2.10 String拼接"></a>2.10 String拼接</h2><p>“《Java 开发手册》上有这么一段内容：循环体内，拼接字符串最好使用 StringBuilder 的 append() 方法，而不是 + 号操作符。这是为什么呀？”</p>
<p>“其实这个问题，我们之前已经聊过。”</p>
<p><strong>javap 探究+号操作符拼接字符串的本质 </strong></p>
<p>“+ 号操作符其实被 Java 在编译的时候重新解释了，换一种说法就是，+ 号操作符是一种语法糖，让字符串的拼接变得更简便了。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Demo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String chenmo = &quot;沉默&quot;;</span><br><span class="line">        String wanger = &quot;王二&quot;;</span><br><span class="line">        System.out.println(chenmo + wanger);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Java 8 的环境下，使用 javap -c Demo.class 反编译字节码后，可以看到以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Compiled from &quot;Demo.java&quot;</span><br><span class="line">class Demo &#123;</span><br><span class="line">  Demo();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: return</span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: ldc           #2                  // String 沉默</span><br><span class="line">       2: astore_1</span><br><span class="line">       3: ldc           #3                  // String 王二</span><br><span class="line">       5: astore_2</span><br><span class="line">       6: getstatic     #4                  // Field </span><br><span class="line">java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       9: new           #5                  // class java/lang/StringBuilder</span><br><span class="line">      12: dup</span><br><span class="line">      13: invokespecial #6                  // Method java/lang/StringBuilder.&quot;</span><br><span class="line">&lt;init&gt;&quot;:()V</span><br><span class="line">      16: aload_1</span><br><span class="line">      17: invokevirtual #7                  // Method </span><br><span class="line">java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      20: aload_2</span><br><span class="line">      21: invokevirtual #7                  // Method </span><br><span class="line">java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      24: invokevirtual #8                  // Method </span><br><span class="line">java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">      27: invokevirtual #9                  // Method java/io/PrintStream.println:</span><br><span class="line">(Ljava/lang/String;)V</span><br><span class="line">      30: return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“这里有一个 new 关键字，并且 class 类型为 java/lang/StringBuilder 。”我指着标号为 9 的那行说，“这意味着新建了一个 StringBuilder 的对象。”</p>
<p>“然后看标号为 17 的这行，是一个 invokevirtual 指令，用于调用对象的方法，也就是 StringBuilder 对象的 append() 方法。”</p>
<p>“也就意味着把 chenmo（”沉默”）这个字符串添加到 StringBuilder 对象中了。”</p>
<p>“再往下看，标号为 21 的这行，又调用了一次 append() 方法，意味着把 wanger（”王二”）这个字符串添加到 StringBuilder 对象中了。”</p>
<p>换成 Java 代码来表示的话，大概是这个样子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Demo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String chenmo = &quot;沉默&quot;;</span><br><span class="line">        String wanger = &quot;王二&quot;;</span><br><span class="line">        System.out.println((new StringBuilder(chenmo)).append(wanger).toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“哦，原来编译的时候把“+”号操作符替换成了 StringBuilder 的 append() 方法啊。”</p>
<p>“是的，不过到了 Java 9（不是长期支持版本，所以我会拿 Java 11 来演示），情况发生了一些改变，同样的代码，字节码指令完全不同了。”我说。</p>
<p>同样的代码，在 Java 11 的环境下，字节码指令是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Compiled from &quot;Demo.java&quot;</span><br><span class="line">public class com.itwanger.thirtyseven.Demo &#123;</span><br><span class="line">  public com.itwanger.thirtyseven.Demo();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: return</span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: ldc           #2                  // String</span><br><span class="line">       2: astore_1</span><br><span class="line">       3: iconst_0</span><br><span class="line">       4: istore_2</span><br><span class="line">       5: iload_2</span><br><span class="line">       6: bipush        10</span><br><span class="line">       8: if_icmpge     41</span><br><span class="line">      11: new           #3                  // class java/lang/String</span><br><span class="line">      14: dup</span><br><span class="line">      15: ldc           #4                  // String 沉默</span><br><span class="line">      17: invokespecial #5                  // Method java/lang/String.&quot;&lt;init&gt;&quot;:</span><br><span class="line">(Ljava/lang/String;)V</span><br><span class="line">      20: astore_3</span><br><span class="line">      21: ldc           #6                  // String 王二</span><br><span class="line">      23: astore        4</span><br><span class="line">      25: aload_1</span><br><span class="line">      26: aload_3</span><br><span class="line">      27: aload         4</span><br><span class="line">      29: invokedynamic #7,  0              // InvokeDynamic </span><br><span class="line">#0:makeConcatWithConstants:</span><br><span class="line">(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;</span><br><span class="line">      34: astore_1</span><br><span class="line">      35: iinc          2, 1</span><br><span class="line">      38: goto          5</span><br><span class="line">      41: return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看标号为 29 的这行，字节码指令为 invokedynamic ，该指令允许由应用级的代码来决定方法解析，所谓的应用级的代码其实是一个方法——被称为引导方法（Bootstrap Method），简称 BSM，BSM 会返回一个 CallSite（调用点） 对象，这个对象就和 invokedynamic 指令链接在一起。以后再执行这条 invokedynamic 指令时就不会创建新的 CallSite 对象。CallSite 其实就是一个 MethodHandle（方法句<br>柄）的 holder，指向一个调用点真正执行的方法——此时就是 StringConcatFactory.makeConcatWithConstants() 方法。</p>
<p>“好吧，总之就是 Java 9 以后，JDK 用了另外一种方法来动态解释 + 号操作符，具体的实现方式在字节码指令层面已经看不到了，所以我就以 Java 8 来继续讲解吧。”</p>
<p><strong>为什么要编译为 StringBuilder.append </strong></p>
<p>“再回到《Java 开发手册》上的那段内容：循环体内，拼接字符串最好使用 StringBuilder 的 append() 方法，而不是 + 号操作符。原因就在于循环体内如果用 + 号操作符的话，就会产生大量的 StringBuilder 对象，不仅占用了更多的内存空间，还会让 Java 虚拟机不停的进行垃圾回收，从而降低了程序的性能。”</p>
<p>更好的写法就是在循环的外部新建一个 StringBuilder 对象，然后使用 append() 方法将循环体内的字符串添加进来：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Demo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        for (int i = 1; i &lt; 10; i++) &#123;</span><br><span class="line">            String chenmo = &quot;沉默&quot;;</span><br><span class="line">            String wanger = &quot;王二&quot;;</span><br><span class="line">            sb.append(chenmo);</span><br><span class="line">            sb.append(wanger);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来做个小测试。</p>
<p>第一个，for 循环中使用”+”号操作符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String result = &quot;&quot;;</span><br><span class="line">for (int i = 0; i &lt; 100000; i++) &#123;</span><br><span class="line">    result += &quot;六六六&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二个，for 循环外部新建 StringBuilder，循环体内使用 append() 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder sb = new StringBuilder();</span><br><span class="line">for (int i = 0; i &lt; 100000; i++) &#123;</span><br><span class="line">    sb.append(&quot;六六六&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“这两个小测试分别会耗时多长时间呢？”</p>
<p>“哇，第一个小测试的执行时间是 6212 毫秒，第二个只用了不到 1 毫秒，差距也太大了吧！”</p>
<p>“是的，这下明白了原因吧？”我说。</p>
<p><strong>append方法源码解析 </strong></p>
<p>“好了，来看一下 StringBuilder 类的 append() 方法的源码吧！”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public StringBuilder append(String str) &#123;</span><br><span class="line">    super.append(str);</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这 3 行代码其实没啥看的。我们来看父类 AbstractStringBuilder 的 append() 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public AbstractStringBuilder append(String str) &#123;</span><br><span class="line">    if (str == null)</span><br><span class="line">        return appendNull();</span><br><span class="line">    int len = str.length();</span><br><span class="line">    ensureCapacityInternal(count + len);</span><br><span class="line">    str.getChars(0, len, value, count);</span><br><span class="line">    count += len;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1）判断拼接的字符串是不是 null，如果是，当做字符串“null”来处理。 appendNull() 方法的源码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private AbstractStringBuilder appendNull() &#123;</span><br><span class="line">    int c = count;</span><br><span class="line">    ensureCapacityInternal(c + 4);</span><br><span class="line">    final char[] value = this.value;</span><br><span class="line">    value[c++] = &#x27;n&#x27;;</span><br><span class="line">    value[c++] = &#x27;u&#x27;;</span><br><span class="line">    value[c++] = &#x27;l&#x27;;</span><br><span class="line">    value[c++] = &#x27;l&#x27;;</span><br><span class="line">    count = c;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2）获取字符串的长度。</p>
<p>3） ensureCapacityInternal() 方法的源码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private void ensureCapacityInternal(int minimumCapacity) &#123;</span><br><span class="line">    // overflow-conscious code</span><br><span class="line">    if (minimumCapacity - value.length &gt; 0) &#123;</span><br><span class="line">        value = Arrays.copyOf(value,</span><br><span class="line">                newCapacity(minimumCapacity));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于字符串内部是用数组实现的，所以需要先判断拼接后的字符数组长度是否超过当前数组的长度，如果超过，先对数组进行扩容，然后把原有的值复制到新的数组中。</p>
<p> 4）将拼接的字符串 str 复制到目标数组 value 中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.getChars(0, len, value, count)</span><br></pre></td></tr></table></figure>
<p>5）更新数组的长度 count。</p>
<p><strong>String.concat 拼接字符串 </strong></p>
<p>“除了可以使用 + 号操作符，StringBuilder 的 append() 方法，还有其他的字符串拼接方法吗？”</p>
<p>“有啊，比如说 String 类的 concat() 方法，有点像 StringBuilder 类的 append() 方法。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String chenmo = &quot;沉默&quot;;</span><br><span class="line">String wanger = &quot;王二&quot;;</span><br><span class="line">System.out.println(chenmo.concat(wanger));</span><br></pre></td></tr></table></figure>
<p>可以来看一下 concat() 方法的源码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public String concat(String str) &#123;</span><br><span class="line">    int otherLen = str.length();</span><br><span class="line">    if (otherLen == 0) &#123;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">    int len = value.length;</span><br><span class="line">    char buf[] = Arrays.copyOf(value, len + otherLen);</span><br><span class="line">    str.getChars(buf, len);</span><br><span class="line">    return new String(buf, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1）如果拼接的字符串的长度为 0，那么返回拼接前的字符串。</p>
<p>2）将原字符串的字符数组 value 复制到变量 buf 数组中。</p>
<p>3）把拼接的字符串 str 复制到字符数组 buf 中，并返回新的字符串对象。</p>
<p>我一行一行地解释着。</p>
<p>“和 + 号操作符相比， concat() 方法在遇到字符串为 null 的时候，会抛出 NullPointerException，而“+”号操作符会把 null 当做是“null”字符串来处理。”</p>
<p>如果拼接的字符串非常多， concat() 的效率就会下降，因为创建的字符串对象越来越多。</p>
<p>“还有吗？”</p>
<p>“有，当然有。”</p>
<p><strong>String.join 拼接字符串 </strong></p>
<p>String 类有一个静态方法 join() ，可以这样来使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String chenmo = &quot;沉默&quot;;</span><br><span class="line">String wanger = &quot;王二&quot;;</span><br><span class="line">String cmower = String.join(&quot;&quot;, chenmo, wanger);</span><br><span class="line">System.out.println(cmower);</span><br></pre></td></tr></table></figure>
<p>第一个参数为字符串连接符，比如说：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String message = String.join(&quot;-&quot;, &quot;王二&quot;, &quot;太特么&quot;, &quot;有趣了&quot;);</span><br></pre></td></tr></table></figure>
<p>输出结果为：王二-太特么-有趣了 。</p>
<p>来看一下 join 方法的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static String join(CharSequence delimiter, CharSequence... elements) &#123;</span><br><span class="line">    Objects.requireNonNull(delimiter);</span><br><span class="line">    Objects.requireNonNull(elements);</span><br><span class="line">    // Number of elements not likely worth Arrays.stream overhead.</span><br><span class="line">    StringJoiner joiner = new StringJoiner(delimiter);</span><br><span class="line">    for (CharSequence cs: elements) &#123;</span><br><span class="line">        joiner.add(cs);</span><br><span class="line">    &#125;</span><br><span class="line">    return joiner.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>里面新建了一个叫 StringJoiner 的对象，然后通过 for-each 循环把可变参数添加了进来，最后调用 toString() 方法返回 String。</p>
<p><strong>StringUtils.join 拼接字符串 </strong></p>
<p>“实际的工作中， org.apache.commons.lang3.StringUtils 的 join() 方法也经常用来进行字符串拼接。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String chenmo = &quot;沉默&quot;;</span><br><span class="line">String wanger = &quot;王二&quot;;</span><br><span class="line">StringUtils.join(chenmo, wanger);</span><br></pre></td></tr></table></figure>
<p>该方法不用担心 NullPointerException。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StringUtils.join(null)            = null</span><br><span class="line">StringUtils.join([])              = &quot;&quot;</span><br><span class="line">StringUtils.join([null])          = &quot;&quot;</span><br><span class="line">StringUtils.join([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]) = &quot;abc&quot;</span><br><span class="line">StringUtils.join([null, &quot;&quot;, &quot;a&quot;]) = &quot;a&quot;</span><br></pre></td></tr></table></figure>
<p>来看一下源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static String join(final Object[] array, String separator, final int </span><br><span class="line">startIndex, final int endIndex) &#123;</span><br><span class="line">    if (array == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    if (separator == null) &#123;</span><br><span class="line">        separator = EMPTY;</span><br><span class="line">    &#125;</span><br><span class="line">    final StringBuilder buf = new StringBuilder(noOfItems * 16);</span><br><span class="line">    for (int i = startIndex; i &lt; endIndex; i++) &#123;</span><br><span class="line">        if (i &gt; startIndex) &#123;</span><br><span class="line">            buf.append(separator);</span><br><span class="line">        &#125;</span><br><span class="line">        if (array[i] != null) &#123;</span><br><span class="line">            buf.append(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return buf.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部使用的仍然是 StringBuilder。</p>
<p>“好了，关于字符串拼接的知识点我们就讲到这吧。注意 Java 9 以后，对 + 号操作符的解释和之前发生了变化，字节码指令已经不同了，等后面你学了字节码指令后我们再详细地讲一次。”</p>
<h2 id="2-11-String拆分"><a href="#2-11-String拆分" class="headerlink" title="2.11 String拆分"></a>2.11 String拆分</h2><p>“哥，我感觉字符串拆分没什么可讲的呀，直接上 String 类的 split() 方法不就可以了！”三妹毫不客气地说。</p>
<p>“假如你真的这么觉得，那可要注意了，事情远没这么简单。”我微笑着说。</p>
<p>假如现在有这样一串字符序列“沉默王二，一枚有趣的程序员”，需要按照中文逗号“，”进行拆分，这意味着第一串字符序列为逗号前面的“沉默王二”，第二串字符序列为逗号后面的“一枚有趣的程序员”。</p>
<p>“这不等于没说吗？哥！”还没等我说，三妹就打断了我。</p>
<p>“别着急嘛，等哥说完。”我依然保持着微笑继续说，“在拆分之前，要先进行检查，判断一下这串字符是否包含逗号，否则应该抛出异常。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String cmower = &quot;沉默王二，一枚有趣的程序员&quot;;</span><br><span class="line">        if (cmower.contains(&quot;，&quot;)) &#123;</span><br><span class="line">            String [] parts = cmower.split(&quot;，&quot;);</span><br><span class="line">            System.out.println(&quot;第一部分：&quot; + parts[0] +&quot; 第二部分：&quot; + parts[1]);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;当前字符串没有包含逗号&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“三妹你看，这段代码挺严谨的吧？”我说，“来看一下程序的输出结果。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第一部分：沉默王二 第二部分：一枚有趣的程序员</span><br></pre></td></tr></table></figure>
<p>“的确和预期完全一致。”三妹说。</p>
<p>“这是建立在字符串是确定的情况下，最重要的是分隔符是确定的。否则，麻烦就来了。”我说，“大约有 12 种英文特殊符号，如果直接拿这些特殊符号替换上面代码中的分隔符（中文逗号），这段程序在运行的时候就会出现以下提到的错误。”</p>
<ul>
<li>反斜杠 \ （ArrayIndexOutOfBoundsException）</li>
<li>插入符号 ^ （同上）</li>
<li>美元符号 $ （同上）</li>
<li>逗点 . （同上）</li>
<li>竖线 | （正常，没有出错）</li>
<li>问号 ? （PatternSyntaxException）</li>
<li>星号 * （同上）</li>
<li>加号 + （同上）</li>
<li>左小括号或者右小括号 () （同上）</li>
<li>左方括号或者右方括号 [] （同上）</li>
<li>左大括号或者右大括号 {} （同上）</li>
</ul>
<p>“那遇到这些特殊符号该怎么办呢？”三妹问。</p>
<p>“用正则表达式。”我说，“正则表达式是一组由字母和符号组成的特殊文本，它可以用来从文本中找出满足你想要的格式的句子。”</p>
<p>我在 GitHub 上找打了一个开源的正则表达式学习文档，非常详细。一开始写正则表达式的时候难免会感觉到非常生疏，你可以查看一下这份文档。记不住没关系，遇到就查。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/cdoco/learn-regex-zh">https://github.com/cdoco/learn-regex-zh</a></p>
</blockquote>
<p>除了这份文档，还有一份：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/cdoco/common-regex">https://github.com/cdoco/common-regex</a></p>
</blockquote>
<p>作者收集了一些在平时项目开发中经常用到的正则表达式，可以直接拿来用。</p>
<p>“哥，你真周到。”三妹笑着说。</p>
<p>“好了，来用英文逗点 . 替换一下分隔符。”我说。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String cmower = &quot;沉默王二.一枚有趣的程序员&quot;;</span><br><span class="line">if (cmower.contains(&quot;.&quot;)) &#123;</span><br><span class="line">    String [] parts = cmower.split(&quot;\\.&quot;);</span><br><span class="line">    System.out.println(&quot;第一部分：&quot; + parts[0] +&quot; 第二部分：&quot; + parts[1]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于英文逗点属于特殊符号，所以在使用 split() 方法的时候，就需要使用正则表达式 \. 而不能直接使用 . 。</p>
<p>“为什么用两个反斜杠呢？”三妹问。</p>
<p>“因为反斜杠本身就是一个特殊字符，需要用反斜杠来转义。”我说。</p>
<p>当然了，你也可以使用 [] 来包裹住英文逗点“.”， [] 也是一个正则表达式，用来匹配方括号中包含的任意字符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmower.split(&quot;[.]&quot;);</span><br></pre></td></tr></table></figure>
<p>除此之外， 还可以使用 Pattern 类的 quote() 方法来包裹英文逗点“.”，该方法会返回一个使用 \Q\E 包裹的字符串。</p>
<p><img src="\assets\note\image-20230927113429819.png" alt="image-20230927113429819"></p>
<p>来看示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String [] parts = cmower.split(Pattern.quote(&quot;.&quot;));</span><br></pre></td></tr></table></figure>
<p>当 split() 方法的参数是正则表达式的时候，方法最终会执行下面这行代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return Pattern.compile(regex).split(this, limit);</span><br></pre></td></tr></table></figure>
<p>也就意味着，拆分字符串有了新的选择，可以不使用 String 类的 split() 方法，直接用下面的方式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class TestPatternSplit &#123;</span><br><span class="line">    private static Pattern twopart = Pattern.compile(&quot;\\.&quot;);</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String [] parts = twopart.split(&quot;沉默王二.一枚有趣的程序员&quot;);</span><br><span class="line">        System.out.println(&quot;第一部分：&quot; + parts[0] +&quot; 第二部分：&quot; + parts[1]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“为什么要把 Pattern 表达式声明称 static 的呢？”三妹问。</p>
<p>“由于模式是确定的，通过 static 的预编译功能可以提高程序的效率。”我说，“除此之外，还可以使用 Pattern 配合 Matcher 类进行字符串拆分，这样做的好处是可以对要拆分的字符串进行一些严格的限制，来看这段示例代码。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class TestPatternMatch &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 使用预编译功能，提高效率</span><br><span class="line">     */</span><br><span class="line">    private static Pattern twopart = Pattern.compile(&quot;(.+)\\.(.+)&quot;);</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        checkString(&quot;沉默王二.一枚有趣的程序员&quot;);</span><br><span class="line">        checkString(&quot;沉默王二.&quot;);</span><br><span class="line">        checkString(&quot;.一枚有趣的程序员&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    private static void checkString(String str) &#123;</span><br><span class="line">        Matcher m = twopart.matcher(str);</span><br><span class="line">        if (m.matches()) &#123;</span><br><span class="line">            System.out.println(&quot;第一部分：&quot; + m.group(1) + &quot; 第二部分：&quot; + m.group(2));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;不匹配&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正则表达式 (.+)\.(.+) 的意思是，不仅要把字符串按照英文标点的方式拆成两部分，并且英文逗点的前后要有内容。</p>
<p>来看一下程序的输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一部分：沉默王二 第二部分：一枚有趣的程序员</span><br><span class="line">不匹配</span><br><span class="line">不匹配</span><br></pre></td></tr></table></figure>
<p>不过，使用 Matcher 来匹配一些简单的字符串时相对比较沉重一些，使用 String 类的 split() 仍然是首选，因为该方法还有其他一些牛逼的功能。比如说，如果你想把分隔符包裹在拆分后的字符串的第一部分，可以这样做：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String cmower = &quot;沉默王二，一枚有趣的程序员&quot;;</span><br><span class="line">if (cmower.contains(&quot;，&quot;)) &#123;</span><br><span class="line">    String [] parts = cmower.split(&quot;(?&lt;=，)&quot;);</span><br><span class="line">    System.out.println(&quot;第一部分：&quot; + parts[0] +&quot; 第二部分：&quot; + parts[1]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出的结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第一部分：沉默王二， 第二部分：一枚有趣的程序员</span><br></pre></td></tr></table></figure>
<p>可以看到分隔符“，”包裹在了第一部分，如果希望包裹在第二部分，可以这样做：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String [] parts = cmower.split(&quot;(?=，)&quot;);</span><br></pre></td></tr></table></figure>
<p>“ ?&lt;= 和 ?= 是什么东东啊？”三妹好奇地问。</p>
<p>“它其实是正则表达式中的断言模式。”我说，“你有时间的话，可以看看前面我推荐的两份开源文档。”</p>
<p><img src="\assets\note\image-20230927114020912.png" alt="image-20230927114020912"></p>
<p>“ split() 方法可以传递 2 个参数，第一个为分隔符，第二个为拆分的字符串个数。”我说。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String cmower = &quot;沉默王二，一枚有趣的程序员，宠爱他&quot;;</span><br><span class="line">if (cmower.contains(&quot;，&quot;)) &#123;</span><br><span class="line">    String [] parts = cmower.split(&quot;，&quot;, 2);</span><br><span class="line">    System.out.println(&quot;第一部分：&quot; + parts[0] +&quot; 第二部分：&quot; + parts[1]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进入 debug 模式的话，可以看到以下内容：</p>
<p><img src="\assets\note\image-20230927114123803.png" alt="image-20230927114123803"></p>
<p>也就是说，传递 2 个参数的时候，会直接调用 substring() 进行截取，第二个分隔符后的就不再拆分了。</p>
<p>来看一下程序输出的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第一部分：沉默王二 第二部分：一枚有趣的程序员，宠爱他</span><br></pre></td></tr></table></figure>
<p>“没想到啊，这个字符串拆分还挺讲究的呀！”三妹感慨地说。</p>
<p>“是的，其实字符串拆分在实际的工作当中还是挺经常用的。前端经常会按照规则传递一长串字符序列到后端，后端就需要按照规则把字符串拆分再做处理。”我说。</p>
<h1 id="3-面向对象编程"><a href="#3-面向对象编程" class="headerlink" title="3 面向对象编程"></a>3 面向对象编程</h1><h2 id="3-1-Java中的类和对象"><a href="#3-1-Java中的类和对象" class="headerlink" title="3.1 Java中的类和对象"></a>3.1 Java中的类和对象</h2><p>“二哥，那天我在图书馆复习《Java进阶之路》的时候，刚好碰见一个学长，他问我有没有‘对象’，我说还没有啊。结果你猜他说什么，‘要不要我给你 new 一个啊？’我当时就懵了，new 是啥意思啊，二哥？”三妹满是疑惑的问我。</p>
<p>“哈哈，三妹，你学长还挺幽默啊。new 是 Java 中的一个关键字，用来把类变成对象。”我笑着对三妹说，“对象和类是 Java 中最基本的两个概念，可以说撑起了面向对象编程（OOP）的一片天。”</p>
<p><strong>01、面向过程和面向对象</strong></p>
<p>三妹是不是要问，什么是 OOP？</p>
<p>OOP 的英文全称是 Object Oriented Programming，要理解它的话，就要先理解面向对象，要想理解面向对象的话，就要先理解面向过程，因为一开始没有面向对象的编程语言，都是面向过程。</p>
<p>举个简单点的例子来区分一下面向过程和面向对象</p>
<p>有一天，你想吃小碗汤了，怎么办呢？有两个选择：</p>
<p>1）自己买食材，豆腐皮啊、肉啊、蒜苔啊等等，自己动手做。</p>
<p>2）到饭店去，只需要对老板喊一声，“来份小碗汤。”</p>
<p>第一种就是面向过程，第二种就是面向对象。</p>
<p>面向过程有什么劣势呢？假如你买了小碗汤的食材，临了又想吃宫保鸡丁了，你是不是还得重新买食材？</p>
<p>面向对象有什么优势呢？假如你不想吃小碗汤了，你只需要对老板说，“我那个小碗汤如果没做的话，换成宫保鸡丁吧！”</p>
<p>面向过程是流程化的，一步一步，上一步做完了，再做下一步。</p>
<p>面向对象是模块化的，我做我的，你做你的，我需要你做的话，我就告诉你一声。我不需要知道你到底怎么做，只看功劳不看苦劳。</p>
<p>不过，如果追到底的话，面向对象的底层其实还是面向过程，只不过把面向过程进行了抽象化，封装成了类，方便我们的调用。</p>
<p><strong>02、类</strong></p>
<p>对象可以是现实中看得见的任何物体，比如说，一只特立独行的猪；也可以是想象中的任何虚拟物体，比如说能七十二变的孙悟空。</p>
<p>Java 通过类（class）来定义这些物体，这些物体有什么状态，通过字段来定义，比如说比如说猪的颜色是纯色还是花色；这些物体有什么行为，通过方法来定义，比如说猪会吃，会睡觉。</p>
<p>来，定义一个简单的类给你看看。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 微信搜索「二哈进阶之路」</span><br><span class="line"> */</span><br><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private int sex;</span><br><span class="line">    private void eat() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    private void sleep() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    private void dadoudou() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个类可以包含：</p>
<ul>
<li>字段（Filed）</li>
<li>方法（Method）</li>
<li>构造方法（Constructor）</li>
</ul>
<p>在 Person 类中，字段有 3 个，分别是 name、age 和 sex，它们也称为成员变量——在类内部但在方法外部，方法内部的叫临时变量。</p>
<p>成员变量有时候也叫做实例变量，在编译时不占用内存空间，在运行时获取内存，也就是说，只有在对象实例化（ new Person() ）后，字段才会获取到内存，这也正是它被称作“实例”变量的原因。</p>
<p>方法有 3 个，分别是 eat() 、 sleep() 和 dadoudou() ，表示 Person 这个对象可以做什么，也就是吃饭睡觉打豆豆。</p>
<p>那三妹是不是要问，“怎么没有构造方法呢？”</p>
<p>的确在 Person 类的源码文件（.java）中没看到，但在反编译后的字节码文件（.class）中是可以看得到的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">// Source code recreated from a .class file by IntelliJ IDEA</span><br><span class="line">// (powered by Fernflower decompiler)</span><br><span class="line">//</span><br><span class="line">package com.itwanger.twentythree;</span><br><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private int sex;</span><br><span class="line">    public Person() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    private void eat() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    private void sleep() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    private void dadoudou() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>public Person(){} 就是默认的构造方法，因为是空的构造方法（方法体中没有内容），所以可以缺省。</p>
<p>Java 聪明就聪明在这，有些很死板的代码不需要开发人员添加，它会偷偷地做了。</p>
<p><strong>03、new 一个对象</strong></p>
<p>创建 Java 对象时，需要用到 new 关键字。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person person = new Person();</span><br></pre></td></tr></table></figure>
<p>这行代码就通过 Person 类创建了一个 Person 对象。所有对象在创建的时候都会在堆内存中分配空间。</p>
<p>创建对象的时候，需要一个 main() 方法作为入口， main() 方法可以在当前类中，也可以在另外一个类中。</p>
<p>第一种： main() 方法直接放在 Person 类中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private int sex;</span><br><span class="line">    private void eat() &#123;&#125;</span><br><span class="line">    private void sleep() &#123;&#125;</span><br><span class="line">    private void dadoudou() &#123;&#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person person = new Person();</span><br><span class="line">        System.out.println(person.name);</span><br><span class="line">        System.out.println(person.age);</span><br><span class="line">        System.out.println(person.sex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">null</span><br><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>第二种： main() 方法不在 Person 类中，而在另外一个类中。</p>
<p><img src="\assets\note\image-20230927211518119.png" alt="image-20230927211518119"></p>
<p>实际开发中，我们通常不在当前类中直接创建对象并使用它，而是放在使用对象的类中，比如说上图中的PersonTest 类。</p>
<p>可以把 PersonTest 类和 Person 类放在两个文件中，也可以放在一个文件（命名为 PersonTest.java）中，就像下面这样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author 微信搜「二哈进阶之路」</span><br><span class="line"> */</span><br><span class="line">public class PersonTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person person = new Person();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private int sex;</span><br><span class="line">    private void eat() &#123;&#125;</span><br><span class="line">    private void sleep() &#123;&#125;</span><br><span class="line">    private void dadoudou() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>04、初始化对象</strong></p>
<p>在之前的例子中，程序输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">null</span><br><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>为什么会有这样的输出结果呢？因为 Person 对象没有初始化，因此输出了 String 的默认值 null，int 的默认值 0。</p>
<p>那怎么初始化 Person 对象（对字段赋值）呢？</p>
<p><strong>第一种：通过对象的引用变量。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private int sex;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person person = new Person();</span><br><span class="line">        person.name = &quot;沉默王二&quot;;</span><br><span class="line">        person.age = 18;</span><br><span class="line">        person.sex = 1;</span><br><span class="line">        </span><br><span class="line">        System.out.println(person.name);</span><br><span class="line">        System.out.println(person.age);</span><br><span class="line">        System.out.println(person.sex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>person 被称为对象 Person 的引用变量，见下图：</p>
<p><img src="\assets\note\image-20230927211924036.png" alt="image-20230927211924036"></p>
<p>通过对象的引用变量，可以直接对字段进行初始化（ person.name = “沉默” ），所以以上代码输出结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">沉默</span><br><span class="line">18</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p><strong>第二种：通过方法初始化。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private int sex;</span><br><span class="line">    public void initialize(String n, int a, int s) &#123;</span><br><span class="line">        name = n;</span><br><span class="line">        age = a;</span><br><span class="line">        sex = s;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person person = new Person();</span><br><span class="line">        person.initialize(&quot;沉默王二&quot;,18,1);</span><br><span class="line">        System.out.println(person.name);</span><br><span class="line">        System.out.println(person.age);</span><br><span class="line">        System.out.println(person.sex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Person 类中新增方法 initialize() ，然后在新建对象后传参进行初始化（ person.initialize(“沉默”, 18, 1) ）。</p>
<p><strong>第三种：通过构造方法初始化。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private int sex;</span><br><span class="line">    public Person(String name, int age, int sex) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person person = new Person(&quot;沉默王二&quot;, 18, 1);</span><br><span class="line">        System.out.println(person.name);</span><br><span class="line">        System.out.println(person.age);</span><br><span class="line">        System.out.println(person.sex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这也是最标准的一种做法，直接在 new 的时候把参数传递过去。</p>
<p>补充一点知识，匿名对象。匿名对象意味着没有引用变量，它只能在创建的时候被使用一次。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Person();</span><br></pre></td></tr></table></figure>
<p>可以直接通过匿名对象调用方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Person().initialize(&quot;沉默王二&quot;, 18, 1);</span><br></pre></td></tr></table></figure>
<p><strong>05、关于对象</strong></p>
<p><strong>1）抽象的历程</strong></p>
<p>所有编程语言都是一种抽象，甚至可以说，我们能够解决的问题的复杂程度取决于抽象的类型和质量。</p>
<p>Smalltalk 是历史上第一门获得成功的面向对象语言，也为 Java 提供了灵感。它有 5 个基本特征：</p>
<ul>
<li>万物皆对象。</li>
<li>一段程序实际上就是多个对象通过发送消息的方式来告诉彼此该做什么。</li>
<li>通过组合的方式，可以将多个对象封装成其他更为基础的对象。</li>
<li>对象是通过类实例化的。</li>
<li>同一类型的对象可以接收相同的消息。</li>
</ul>
<p>总结一句话就是：</p>
<blockquote>
<p>状态+行为+标识=对象，每个对象在内存中都会有一个唯一的地址。</p>
</blockquote>
<p><strong>2）对象具有接口</strong></p>
<p>所有的对象，都可以被归为一类，并且同一类对象拥有一些共同的行为和特征。在 Java 中，class 关键字用来定义一个类型。</p>
<p>创建抽象数据类型是面向对象编程的一个基本概念。你可以创建某种类型的变量，Java 中称之为对象或者实例，然后你就可以操作这些变量，Java 中称之为发送消息或者发送请求，最后对象决定自己该怎么做。</p>
<p>类描述了一系列具有相同特征和行为的对象，从宽泛的概念上来说，类其实就是一种自定义的数据类型。</p>
<p>一旦创建了一个类，就可以用它创建任意多个对象。面向对象编程语言遇到的最大一个挑战就是，如何把现实/虚拟的元素抽象为 Java 中的对象。</p>
<p>对象能够接收什么样的请求是由它的接口定义的。具体是怎么做到的，就由它的实现方法来实现。</p>
<p><strong>3）访问权限修饰符</strong></p>
<p>类的创建者有时候也被称为 API 提供者，对应的，类的使用者就被称为 API 调用者。</p>
<p>JDK 就给我们提供了 Java 的基础实现，JDK 的作者也就是基础 API 的提供者（Java 多线程部分的作者 Doug Lea 是被 Java 程序员敬佩的一个大佬），我们这些 Java 语言的使用者，说白了就是 JDK 的调用者。</p>
<p><img src="\assets\note\image-20230927213040360.png" alt="image-20230927213040360"></p>
<p>当然了，假如我们也提供了新的类给其他调用者，我们也就成为了新的创建者。</p>
<p>API 创建者在创建新的类的时候，只暴露必要的接口，而隐藏其他所有不必要的信息，之所以要这么做，是因为如果这些信息对调用者是不可见的，那么创建者就可以随意修改隐藏的信息，而不用担心对调用者的影响。</p>
<p>这里就必须要讲到 Java 的权限修饰符。</p>
<p>访问权限修饰符的第一个作用是，防止类的调用者接触到他们不该接触的内部实现；第二个作用是，让类的创建者可以轻松修改内部机制而不用担心影响到调用者的使用。</p>
<ul>
<li>public</li>
<li>private</li>
<li>protected</li>
</ul>
<p>还有一种“默认”的权限修饰符，是缺省的，它修饰的类可以访问同一个包下面的其他类。</p>
<p><strong>4）组合</strong></p>
<p>我们可以把一个创建好的类作为另外一个类的成员变量来使用，利用已有的类组成成一个新的类，被称为“复用”，组合代表的关系是 has-a 的关系。</p>
<p><strong>5）继承</strong></p>
<p>继承是 Java 中非常重要的一个概念，子类继承父类，也就拥有了父类中 protected 和 public 修饰的方法和字段，同时，子类还可以扩展一些自己的方法和字段，也可以重写继承过来方法。</p>
<p>常见的例子，就是形状可以有子类圆形、方形、三角形，它们的基础接口是相同的，比如说都有一个draw() 的方法，子类可以继承这个方法实现自己的绘制方法。</p>
<p>如果子类只是重写了父类的方法，那么它们之间的关系就是 is-a 的关系，但如果子类增加了新的方法，那么它们之间的关系就变成了 is-like-a 的关系。</p>
<p>6）多态</p>
<p>比如说有一个父类Shape</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Shape &#123;</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        System.out.println(&quot;形状&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类Circle</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Circle extends Shape&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        System.out.println(&quot;圆形&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类Line</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Line extends Shape &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        System.out.println(&quot;线&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Shape shape1 = new Line();</span><br><span class="line">        shape1.draw();</span><br><span class="line">        Shape shape2 = new Circle();</span><br><span class="line">        shape2.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">线</span><br><span class="line">圆形</span><br></pre></td></tr></table></figure>
<p>在测试类中，shape1 的类型为 Shape，shape2 的类型也为 Shape，但调用 draw() 方法后，却能自动调用子类 Line 和 Circle 的 draw() 方法，这是为什么呢？</p>
<p>其实就是 Java 中的多态。</p>
<p><strong>06、小结</strong></p>
<p>“怎么样，三妹，是不是对 Java 有了更深入更清晰的理解？”终于讲完了，我深呼了一口气，好舒畅啊！</p>
<p>“是的，哥，感觉 Java 也就那么回事嘛。”哎呀，三妹有点狂了起来，“万物皆对象，除了基本数据类型。”</p>
<p>“哇，三妹，你可以啊，都会自己梳理总结了。”我倍感欣慰，觉得果然是劳有所获，你讲的认真，听众就能理解和 get，满足了。</p>
<h2 id="3-2-Java中的包"><a href="#3-2-Java中的包" class="headerlink" title="3.2 Java中的包"></a>3.2 Java中的包</h2><p>“三妹，这一节，我们简单过一下 Java 中的包，也就是 package，这个一点就透，很好掌握。”我放下手中的雪碧，翻开笔记本，点开《Java 进阶之路》，找到这篇「Java 中的包」，开始滔滔不绝起来。</p>
<p>“二哥，你等一下。”让我打开思维导图做一下笔记 。</p>
<p><strong>关于包</strong></p>
<p>在前面的代码中，我们把类和接口命名为 Person 、 Student 、 Hello 等简单的名字。</p>
<p>在团队开发中，如果小明写了一个 Person 类，小红也写了一个 Person 类，现在，小白既想用小明的Person ，也想用小红的 Person ，怎么办？</p>
<p>如果小军写了一个 Arrays 类，恰好 JDK 也自带了一个 Arrays 类，如何解决类名冲突？</p>
<p>在 Java 中，我们使用 package 来解决名字冲突。</p>
<p>Java 定义了一种名字空间，称之为包： package 。一个类总是属于某个包，类名（比如 Person ）只是一个简写，真正的完整类名是 包名.类名 。</p>
<p>例如：</p>
<p>小明的 Person 类存放在包 ming 下面，因此，完整类名是 ming.Person ；</p>
<p>小红的 Person 类存放在包 hong 下面，因此，完整类名是 hong.Person ；</p>
<p>小军的 Arrays 类存放在包 mr.jun 下面，因此，完整类名是 mr.jun.Arrays ；</p>
<p>JDK 的 Arrays 类存放在包 java.util 下面，因此，完整类名是 java.util.Arrays 。</p>
<p>在定义 class 的时候，我们需要在第一行声明这个 class 属于哪个包。</p>
<p>小明的 Person.java 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">package ming; // 申明包名ming</span><br><span class="line">public class Person &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>小军的 Arrays.java 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">package mr.jun; // 申明包名mr.jun</span><br><span class="line">public class Arrays &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Java 虚拟机执行的时候，JVM 只看完整类名，因此，只要包名不同，类就不同。</p>
<p>包可以是多层结构，用 . 隔开。例如： java.util 。</p>
<blockquote>
<p>要特别注意：包没有父子关系。java.util和java.util.zip是不同的包，两者没有任何继承关系。</p>
</blockquote>
<p>没有定义包名的 class ，它使用的是默认包，非常容易引起名字冲突，因此，不推荐不写包名的做法。</p>
<p>我们还需要按照包结构把上面的 Java 文件组织起来。假设以 package_sample 作为根目录， src 作为源码目录，那么所有文件结构就是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package_sample</span><br><span class="line">└─ src</span><br><span class="line">    ├─ hong</span><br><span class="line">    │  └─ Person.java</span><br><span class="line">    │  ming</span><br><span class="line">    │  └─ Person.java</span><br><span class="line">    └─ mr</span><br><span class="line">       └─ jun</span><br><span class="line">          └─ Arrays.java</span><br></pre></td></tr></table></figure>
<p>即所有 Java 文件对应的目录层次要和包的层次一致。</p>
<p>编译后的 .class 文件也需要按照包结构存放。如果使用 IDE，把编译后的 .class 文件放到 bin 目录下，那么，编译的文件结构就是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package_sample</span><br><span class="line">└─ bin</span><br><span class="line">   ├─ hong</span><br><span class="line">   │  └─ Person.class</span><br><span class="line">   │  ming</span><br><span class="line">   │  └─ Person.class</span><br><span class="line">   └─ mr</span><br><span class="line">      └─ jun</span><br><span class="line">         └─ Arrays.class</span><br></pre></td></tr></table></figure>
<p>编译的命令相对比较复杂，我们需要在 src 目录下执行 javac 命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -d ../bin ming/Person.java hong/Person.java mr/jun/Arrays.java</span><br></pre></td></tr></table></figure>
<p>在 IDE 中，会自动根据包结构编译所有 Java 源码，所以不必担心使用命令行编译的复杂命令。</p>
<p><strong>包的作用域</strong></p>
<p>位于同一个包的类，可以访问包作用域的字段和方法。</p>
<p>不用 public 、 protected 、 private 修饰的字段和方法就是包作用域。例如， Person 类定义在 hello 包</p>
<p>下面：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package hello;</span><br><span class="line">public class Person &#123;</span><br><span class="line">    // 包作用域:</span><br><span class="line">    void hello() &#123;</span><br><span class="line">        System.out.println(&quot;Hello!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Main 类也定义在 hello 包下面，就可以直接访问 Person 类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package hello;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person p = new Person();</span><br><span class="line">        p.hello(); // 可以调用，因为Main和Person在同一个包</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>导入包</strong></p>
<p>在一个 class 中，我们总会引用其他的 class 。例如，小明的 ming.Person 类，如果要引用小军的mr.jun.Arrays 类，他有三种写法：</p>
<p>第一种，直接写出完整类名，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Person.java</span><br><span class="line">package ming;</span><br><span class="line">public class Person &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        mr.jun.Arrays arrays = new mr.jun.Arrays();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很显然，每次都要写完整的类名比较痛苦。</p>
<p>因此，第二种写法是用 import 语句，导入小军的 Arrays ，然后写简单类名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/ Person.java</span><br><span class="line">package ming;</span><br><span class="line">// 导入完整类名:</span><br><span class="line">import mr.jun.Arrays;</span><br><span class="line">public class Person &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        Arrays arrays = new Arrays();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在写 import 的时候，可以使用 * ，表示把这个包下面的所有 class 都导入进来（但不包括子包的class ）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Person.java</span><br><span class="line">package ming;</span><br><span class="line">// 导入mr.jun包的所有class:</span><br><span class="line">import mr.jun.*;</span><br><span class="line">public class Person &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        Arrays arrays = new Arrays();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们一般不推荐这种写法，因为在导入了多个包后，很难看出 Arrays 类属于哪个包。</p>
<p>还有一种 import static 的语法，它可以导入一个类的静态字段和静态方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package main;</span><br><span class="line">// 导入System类的所有静态字段和静态方法:</span><br><span class="line">import static java.lang.System.*;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 相当于调用System.out.println(…)</span><br><span class="line">        out.println(&quot;Hello, world!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>import static 很少使用。</p>
<p>Java 编译器最终编译出的 .class 文件只使用 完整类名，因此，在代码中，当编译器遇到一个 class 名称时：</p>
<ul>
<li>如果是完整类名，就直接根据完整类名查找这个 class ；</li>
<li><p>如果是简单类名，按下面的顺序依次查找：</p>
<ul>
<li><p>查找当前 package 是否存在这个 class ；</p>
</li>
<li><p>查找 import 的包是否包含这个 class ；</p>
</li>
<li><p>查找 java.lang 包是否包含这个 class 。</p>
</li>
</ul>
</li>
</ul>
<p>如果按照上面的规则还无法确定类名，则编译报错。</p>
<p>我们来看一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// Main.java</span><br><span class="line">package test;</span><br><span class="line">import java.text.Format;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        java.util.List list; // ok，使用完整类名 -&gt; java.util.List</span><br><span class="line">        Format format = null; // ok，使用import的类 -&gt; java.text.Format</span><br><span class="line">        String s = &quot;hi&quot;; // ok，使用java.lang包的String -&gt; java.lang.String</span><br><span class="line">        System.out.println(s); // ok，使用java.lang包的System -&gt; java.lang.System</span><br><span class="line">        MessageFormat mf = null; // 编译错误：无法找到MessageFormat: MessageFormat </span><br><span class="line">cannot be resolved to a type</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，编写 class 的时候，编译器会自动帮我们做两个 import 动作：</p>
<ul>
<li>默认自动 import 当前 package 的其他 class ；</li>
<li>默认自动 import java.lang.* 。</li>
</ul>
<blockquote>
<p>注意：自动导入的是java.lang包，但类似java.lang.reflect这些包仍需要手动导入。</p>
</blockquote>
<p>如果有两个 class 名称相同，例如， mr.jun.Arrays 和 java.util.Arrays ，那么只能 import 其中一个，另一个必须写完整类名。</p>
<p><strong>包的最佳实践</strong></p>
<p>为了避免名字冲突，我们需要确定唯一的包名。推荐的做法是使用倒置的域名来确保唯一性。例如：</p>
<ul>
<li>org.apache</li>
<li>org.apache.commons.log</li>
<li>com.tobebetterjavaer.sample</li>
</ul>
<p>子包就可以根据功能自行命名。</p>
<p>要注意不要和 java.lang 包的类重名，即自己的类不要使用这些名字：</p>
<ul>
<li>String</li>
<li>System</li>
<li>Runtime</li>
<li>…</li>
</ul>
<p>要注意也不要和 JDK 常用类重名：</p>
<ul>
<li>java.util.List</li>
<li>java.text.Format</li>
<li>java.math.BigInteger</li>
<li>…</li>
</ul>
<p><strong>小结</strong></p>
<p>Java 内建的 package 机制是为了避免 class 命名冲突；</p>
<p>JDK 的核心类使用 java.lang 包，编译器会自动导入；</p>
<p>JDK 的其它常用类定义在 java.util.<em> ， java.math.</em> ， java.text.* ，……；</p>
<p>包名推荐使用倒置的域名，例如 org.apache 。</p>
<h2 id="3-3-Java中的变量"><a href="#3-3-Java中的变量" class="headerlink" title="3.3 Java中的变量"></a>3.3 Java中的变量</h2><p>“二哥，听说 Java 变量在以后的日子里经常用，能不能提前给我透露透露？”三妹咪了一口麦香可可奶茶后对我说。</p>
<p>“三妹啊，搬个凳子坐我旁边，听二哥来给你慢慢说啊。”</p>
<p>Java 变量就好像一个容器，可以保存程序在运行过程中的值，它在声明的时候会定义对应的数据类型（Java分为两种数据类型：基本数据类型和引用数据类型）。变量按照作用域的范围又可分为三种类型：局部变量，成员变量和静态变量。</p>
<p>比如说， int data = 88; ，其中 data 就是一个变量，它的值为 88，类型为整型（int）。</p>
<p><strong>01、局部变量</strong></p>
<ul>
<li>在方法体内声明的变量被称为局部变量，该变量只能在该方法内使用，类中的其他方法并不知道该变量。来看下面这个示例：</li>
<li>其中 a、b、c 就是局部变量，它们只能在当前这个 main 方法中使用。</li>
<li>声明局部变量时的注意事项：</li>
<li>局部变量声明在方法、构造方法或者语句块中。</li>
<li>局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，将会被销毁。</li>
<li>访问修饰符不能用于局部变量。</li>
<li>局部变量只在声明它的方法、构造方法或者语句块中可见。</li>
<li>局部变量是在栈上分配的。</li>
<li>局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。</li>
</ul>
<p><strong>02、成员变量</strong></p>
<p>在类内部但在方法体外声明的变量称为成员变量，或者实例变量，或者字段。之所以称为实例变量，是因为该变量只能通过类的实例（对象）来访问。来看下面这个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class InstanceVariable &#123;</span><br><span class="line">    int data = 88;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        InstanceVariable iv = new InstanceVariable();</span><br><span class="line">        System.out.println(iv.data); // 88</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 iv 是一个变量，它是一个引用类型的变量。 new 关键字可以创建一个类的实例（也称为对象），通过“=”操作符赋值给 iv 这个变量，iv 就成了这个对象的引用，通过 iv.data 就可以访问成员变量了。</p>
<ul>
<li>声明成员变量时的注意事项：</li>
<li>成员变量声明在一个类中，但在方法、构造方法和语句块之外。</li>
<li>当一个对象被实例化之后，每个成员变量的值就跟着确定。</li>
<li>成员变量在对象创建的时候创建，在对象被销毁的时候销毁。</li>
<li>成员变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息。</li>
<li>成员变量可以声明在使用前或者使用后。</li>
<li>访问修饰符可以修饰成员变量。</li>
<li>成员变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把成员变量设为私有。通过使用访问修饰符可以使成员变量对子类可见；成员变量具有默认值。数值型变量的默认值是 0，布尔型变量的默认值是 false，引用类型变量的默认值是 null。变量的值可以在声明时指定，也可以在构造方法中指定。</li>
</ul>
<p><strong>03、静态变量</strong></p>
<p>通过 static 关键字声明的变量被称为静态变量（类变量），它可以直接被类访问，来看下面这个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class StaticVariable &#123;</span><br><span class="line">    static int data = 99;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(StaticVariable.data); // 99</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 data 就是静态变量，通过 类名.静态变量 就可以访问了，不需要创建类的实例。</p>
<p>声明静态变量时的注意事项：</p>
<ul>
<li>静态变量在类中以 static 关键字声明，但必须在方法构造方法和语句块之外。</li>
<li>无论一个类创建了多少个对象，类只拥有静态变量的一份拷贝。</li>
<li>静态变量除了被声明为常量外很少使用。</li>
<li>静态变量储存在静态存储区。</li>
<li>静态变量在程序开始时创建，在程序结束时销毁。</li>
<li>与成员变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为 public 类型。</li>
<li>静态变量的默认值和实例变量相似。</li>
<li>静态变量还可以在静态语句块中初始化。</li>
</ul>
<p><strong>04、常量</strong></p>
<p>在 Java 中，有些数据的值是不会发生改变的，这些数据被叫做常量——使用 final 关键字修饰的成员变量。</p>
<p>常量的值一旦给定就无法改变！</p>
<p>常量在程序运行过程中主要有 2 个作用：</p>
<ul>
<li>代表常数，便于修改（例如：圆周率的值， final double PI = 3.14 ）</li>
<li>增强程序的可读性（例如：常量 UP、DOWN 用来代表上和下， final int UP = 0 ）</li>
</ul>
<p>Java 要求常量名必须大写。来看下面这个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class FinalVariable &#123;</span><br><span class="line">    final String CHEN = &quot;沉&quot;;</span><br><span class="line">    static final String MO = &quot;默&quot;;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        FinalVariable fv = new FinalVariable();</span><br><span class="line">        System.out.println(fv.CHEN);</span><br><span class="line">        System.out.println(MO);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“好了，三妹，关于 Java 变量就先说这么多吧，你是不是已经清楚了？”转动了一下僵硬的脖子后，我对三妹说。</p>
<p>“是啊，二哥，我想以后还会再见到它们吧？”</p>
<p>“那见的次数可就多了，就好像你每天眨眼的次数一样多。”</p>
<h2 id="3-4-Java中的方法"><a href="#3-4-Java中的方法" class="headerlink" title="3.4 Java中的方法"></a>3.4 Java中的方法</h2><p>“二哥，这一节我们学什么呢？”三妹满是期待的问我。</p>
<p>“这一节我们来了解一下 Java 中的方法——什么是方法？如何声明方法？方法有哪几种？什么是实例方法？</p>
<p>什么是静态方法？什么是抽象方法？什么是本地方法？”我笑着对三妹说，“我开始了啊，你要注意力集中啊。”</p>
<p><strong>01、Java中的方法是什么？</strong></p>
<p>方法用来实现代码的可重用性，我们编写一次方法，并多次使用它。通过增加或者删除方法中的一部分代码，就可以提高整体代码的可读性。</p>
<p>只有方法被调用时，它才会执行。Java 中最有名的方法当属 main() 方法，这是程序的入口。</p>
<p><strong>02、如何声明方法？</strong></p>
<p>方法的声明反映了方法的一些信息，比如说可见性、返回类型、方法名和参数。如下图所示。</p>
<p><img src="\assets\note\image-20230927220335052.png" alt="image-20230927220335052"></p>
<p><strong>访问权限</strong>：它指定了方法的可见性。Java 提供了四种访问权限修饰符：</p>
<ul>
<li>public：该方法可以被所有类访问。</li>
<li>private：该方法只能在定义它的类中访问。</li>
<li>protected：该方法可以被同一个包中的类，或者不同包中的子类访问。</li>
<li>default：如果一个方法没有使用任何访问权限修饰符，那么它是 package-private 的，意味着该方法只能被同一个包中的类可见。</li>
</ul>
<p><strong>返回类型</strong>：方法返回的数据类型，可以是基本数据类型、对象和集合，如果不需要返回数据，则使用 void 关键字。</p>
<p><strong>方法名</strong>：方法名最好反应出方法的功能，比如，我们要创建一个将两个数字相减的方法，那么方法名最好是subtract。</p>
<p>方法名最好是一个动词，并且以小写字母开头。如果方法名包含两个以上单词，那么第一个单词最好是动词，然后是形容词或者名词，并且要以驼峰式的命名方式命名。比如：</p>
<ul>
<li>一个单词的方法名： sum()</li>
<li>多个单词的方法名： stringComparision()</li>
</ul>
<p>一个方法可能与同一个类中的另外一个方法同名，这被称为方法重载。</p>
<p><strong>参数</strong>：参数被放在一个圆括号内，如果有多个参数，可以使用逗号隔开。参数包含两个部分，参数类型和参数名。如果方法没有参数，圆括号是空的。</p>
<p><strong>方法签名</strong>：每一个方法都有一个签名，包括方法名和参数。</p>
<p><strong>方法体</strong>：方法体放在一对花括号内，把一些代码放在一起，用来执行特定的任务。</p>
<p><strong>03、方法有哪几种？</strong></p>
<p>方法可以分为两种，一种叫标准类库方法，一种叫用户自定义方法。</p>
<p><strong>1）预先定义方法</strong></p>
<p>Java 提供了大量预先定义好的方法供我们调用，也称为标准类库方法，或者内置方法。比如说 String 类的length() 、 equals() 、 compare() 方法，以及我们在初学 Java 阶段最常用的 println() 方法，用来在控制台打印信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class PredefinedMethodDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;沉默王二，一枚有趣的程序员&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们使用了两个预先定义的方法， main() 方法是程序运行的入口， println() 方法是PrintStream 类的一个方法。这些方法已经提前定义好了，所以我们可以直接使用它们。</p>
<p>我们可以通过集成开发工具查看预先定义方法的方法签名，当我们把鼠标停留在 println() 方法上面时，就会显示下图中的内容：</p>
<p><img src="\assets\note\image-20230927220656781.png" alt="image-20230927220656781"></p>
<p>println() 方法的访问权限修饰符是 public，返回类型为 void，方法名为 println，参数为 String x ，以及 Javadoc（方法是干嘛的）。</p>
<p>预先定义方法让编程变得简单了起来，我们只需要在实现某些功能的时候直接调用这些方法即可，不需要重新编写。</p>
<p>Java 的一个非常大的优势，就是，JDK 的设计者（开发者）为我们提供了大量的标准类库方法，这对于初学编程的新手来说极其友好；不仅如此，GitHub/码云上也有大量可以直接拿到生产环境下使用的第三方类库，比如说 hutool 啊、Apache 包啊、一线大厂或者顶级开发大佬贡献的类库，比如说 Druid、Gson 等等。</p>
<p>但如果你想从一个初级开发者（俗称调包侠）晋升为一名优秀的 Java 工程师，那就需要深入研究这些源码，并掌握，最好是能自己写出来这些源码，最起码能自定义一些源码，以便为我们所用。</p>
<p><strong>2）用户自定义方法</strong></p>
<p>当预先定义方法无法满足我们的要求时，就需要自定义一些方法，比如说，我们来定义这样一个方法，用来检查数字是偶数还是奇数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void findEvenOdd(int num) &#123;</span><br><span class="line">    if (num % 2 == 0) &#123;</span><br><span class="line">        System.out.println(num + &quot; 是偶数&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        System.out.println(num + &quot; 是奇数&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法名叫做 findEvenOdd ，访问权限修饰符是 public，并且是静态的（static），返回类型是 void，参数有一个整型（int）的 num。方法体中有一个 if else 语句，如果 num 可以被 2 整除，那么就打印这个数字是偶数，否则就打印这个数字是奇数。</p>
<p>方法被定义好后，如何被调用呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class EvenOddDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        findEvenOdd(10);</span><br><span class="line">        findEvenOdd(11);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void findEvenOdd(int num) &#123;</span><br><span class="line">        if (num % 2 == 0) &#123;</span><br><span class="line">            System.out.println(num + &quot; 是偶数&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(num + &quot; 是奇数&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main() 方法是程序的入口，并且是静态的，那么就可以直接调用同样是静态方法的 findEvenOdd() 。</p>
<p>当一个方法被 static 关键字修饰时，它就是一个静态方法。换句话说，静态方法是属于类的，不属于类实例的（不需要通过 new 关键字创建对象来调用，直接通过类名就可以调用）。</p>
<p><strong>04、什么是实例方法？</strong></p>
<p>没有使用 static 关键字修饰，但在类中声明的方法被称为实例方法，在调用实例方法之前，必须创建类的对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class InstanceMethodExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        InstanceMethodExample instanceMethodExample = new InstanceMethodExample();</span><br><span class="line">        System.out.println(instanceMethodExample.add(1, 2));</span><br><span class="line">    &#125;</span><br><span class="line">    public int add(int a, int b) &#123;</span><br><span class="line">        return a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>add() 方法是一个实例方法，需要创建 InstanceMethodExample 对象来访问。</p>
<p>实例方法有两种特殊类型：</p>
<ul>
<li>getter 方法</li>
<li>setter 方法</li>
</ul>
<p>getter 方法用来获取私有变量（private 修饰的字段）的值，setter 方法用来设置私有变量的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private int sex;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getSex() &#123;</span><br><span class="line">        return sex;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setSex(int sex) &#123;</span><br><span class="line">        this.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getter 方法以 get 开头，setter 方法以 set 开头。</p>
<p><strong>05、什么是静态方法？</strong></p>
<p>相应的，有 static 关键字修饰的方法就叫做静态方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class StaticMethodExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(add(1,2));</span><br><span class="line">    &#125;</span><br><span class="line">    public static int add(int a, int b) &#123;</span><br><span class="line">        return a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>StaticMethodExample 类中，mian 和 add 方法都是静态方法，不同的是，main 方法是程序的入口。当我们调用静态方法的时候，就不需要 new 出来类的对象，就可以直接调用静态方法了，一些工具类的方法都是静态方法，比如说 hutool 工具类库，里面有大量的静态方法可以直接调用。</p>
<blockquote>
<p>Hutool 的目标是使用一个工具方法代替一段复杂代码，从而最大限度的避免“复制粘贴”代码的问题，彻底改变我们写代码的方式。</p>
</blockquote>
<p>以计算 MD5 为例：</p>
<ul>
<li>【以前】打开搜索引擎 -&gt; 搜“Java MD5 加密” -&gt; 打开某篇博客-&gt; 复制粘贴 -&gt; 改改好用</li>
<li>【现在】引入 Hutool -&gt; SecureUtil.md5()</li>
</ul>
<p>Hutool 的存在就是为了减少代码搜索成本，避免网络上参差不齐的代码出现导致的 bug。</p>
<p><strong>06、什么是抽象方法？</strong></p>
<p>没有方法体的方法被称为抽象方法，它总是在抽象类中声明。这意味着如果类有抽象方法的话，这个类就必须是抽象的。可以使用 atstract 关键字创建抽象方法和抽象类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abstract class AbstractDemo &#123;</span><br><span class="line">    abstract void display();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当一个类继承了抽象类后，就必须重写抽象方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class MyAbstractDemo extends AbstractDemo &#123;</span><br><span class="line">    @Override</span><br><span class="line">    void display() &#123;</span><br><span class="line">        System.out.println(&quot;重写了抽象方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyAbstractDemo myAbstractDemo = new MyAbstractDemo();</span><br><span class="line">        myAbstractDemo.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">重写了抽象方法</span><br></pre></td></tr></table></figure>
<p>“关于方法，我们就讲到这里吧，学会了类/变量/方法，基本上就可以做一个入门级的 Java 程序员了。”我面露微笑，继续对三妹说，“继续加油吧！”</p>
<p>“好的，谢谢二哥你的细心帮助。”</p>
<h2 id="3-5-Java可变参数"><a href="#3-5-Java可变参数" class="headerlink" title="3.5 Java可变参数"></a>3.5 Java可变参数</h2><p>为了让铁粉们能白票到阿里云的服务器，我当了整整两天的客服，真正体验到了什么叫做“为人民群众谋福利”的不易和辛酸。正在我眼睛红肿打算要休息之际，三妹跑过来问：“Java 的可变参数究竟是怎么一回事？”</p>
<p>我一下子又清醒了，我爱 Java，我爱传道解惑，也享受三妹的赞许（ ）。</p>
<p>可变参数是 Java 1.5 的时候引入的功能，它允许方法使用任意多个、类型相同（ is-a ）的值作为参数。就像下面这样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    print(&quot;沉&quot;);</span><br><span class="line">    print(&quot;沉&quot;, &quot;默&quot;);</span><br><span class="line">    print(&quot;沉&quot;, &quot;默&quot;, &quot;王&quot;);</span><br><span class="line">    print(&quot;沉&quot;, &quot;默&quot;, &quot;王&quot;, &quot;二&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public static void print(String... strs) &#123;</span><br><span class="line">    for (String s : strs)</span><br><span class="line">        System.out.print(s);</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态方法 print() 就使用了可变参数，所以 print(“沉”) 可以， print(“沉”, “默”) 也可以，甚至 3个、 4 个或者更多个字符串都可以作为参数传递给 print() 方法。</p>
<p>说到可变参数，我想起来阿里巴巴开发手册上有这样一条规约。</p>
<p><img src="\assets\note\image-20230927221603351.png" alt="image-20230927221603351"></p>
<p>意思就是尽量不要使用可变参数，如果要用的话，可变参数必须要在参数列表的最后一位。既然坑位有限，只能在最后，那么可变参数就只能有一个（悠着点，悠着点）。如果可变参数不在最后一位，IDE 就会提示对应的错误，如下图所示。</p>
<p><img src="\assets\note\image-20230927221705144.png" alt="image-20230927221705144"></p>
<p>可变参数看起来就像是个语法糖，它背后究竟隐藏了什么呢？让我们来一探究竟，在追求真理这条路上我们要执着。</p>
<p>其实也很简单。<strong>当使用可变参数的时候，实际上是先创建了一个数组，该数组的大小就是可变参数的个数，然后将参数放入数组当中，再将数组传递给被调用的方法。</strong></p>
<p>这就是为什么可以使用数组作为参数来调用带有可变参数的方法的根本原因。代码如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    print(new String[]&#123;&quot;沉&quot;&#125;);</span><br><span class="line">    print(new String[]&#123;&quot;沉&quot;, &quot;默&quot;&#125;);</span><br><span class="line">    print(new String[]&#123;&quot;沉&quot;, &quot;默&quot;, &quot;王&quot;&#125;);</span><br><span class="line">    print(new String[]&#123;&quot;沉&quot;, &quot;默&quot;, &quot;王&quot;, &quot;二&quot;&#125;);</span><br><span class="line">&#125;</span><br><span class="line">public static void print(String... strs) &#123;</span><br><span class="line">    for (String s : strs)</span><br><span class="line">        System.out.print(s);</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那如果方法的参数是一个数组，然后像使用可变参数那样去调用方法的时候，能行得通吗？</p>
<p>“三妹，给你留个思考题：一般什么时候使用可变参数呢？”</p>
<p>可变参数，可变参数，顾名思义，当一个方法需要处理任意多个相同类型的对象时，就可以定义可变参数。</p>
<p>Java 中有一个很好的例子，就是 String 类的 format() 方法，就像下面这样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(String.format(&quot;年纪是: %d&quot;, 18));</span><br><span class="line">System.out.println(String.format(&quot;年纪是: %d 名字是: %s&quot;, 18, &quot;沉默王二&quot;));</span><br></pre></td></tr></table></figure>
<p>%d 表示将整数格式化为 10 进制整数， %s 表示输出字符串。</p>
<p>如果不使用可变参数，那需要格式化的参数就必须使用“+”号操作符拼接起来了。麻烦也就惹上身了。</p>
<p>在实际的项目代码中，slf4j 的日志输出就经常要用到可变参数（log4j 就没法使用可变参数，日志中需要记录多个参数时就痛苦不堪了）。就像下面这样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line">logger.debug(&quot;名字是&#123;&#125;&quot;, mem.getName());</span><br><span class="line">logger.debug(&quot;名字是&#123;&#125;，年纪是&#123;&#125;&quot;, mem.getName(), mem.getAge());</span><br></pre></td></tr></table></figure>
<p>查看源码就可以发现， debug() 方法使用了可变参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public void debug(String format, Object... arguments);</span><br></pre></td></tr></table></figure>
<p>“那在使用可变参数的时候有什么注意事项吗？”三妹问。</p>
<p>有的。我们要避免重载带有可变参数的方法——这样很容易让编译器陷入自我怀疑中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    print(null);</span><br><span class="line">&#125;</span><br><span class="line">public static void print(String... strs) &#123;</span><br><span class="line">    for (String a : strs)</span><br><span class="line">        System.out.print(a);</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">public static void print(Integer... ints) &#123;</span><br><span class="line">    for (Integer i : ints)</span><br><span class="line">        System.out.print(i);</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候，编译器完全不知道该调用哪个 print() 方法， print(String… strs) 还是print(Integer… ints) ，傻傻分不清。</p>
<p><img src="\assets\note\image-20230927221944053.png" alt="image-20230927221944053"></p>
<p>假如真的需要重载带有可变参数的方法，就必须在调用方法的时候给出明确的指示，不要让编译器去猜。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String [] strs = null;</span><br><span class="line">    print(strs);</span><br><span class="line">    Integer [] ints = null;</span><br><span class="line">    print(ints);</span><br><span class="line">&#125;</span><br><span class="line">public static void print(String... strs) &#123;</span><br><span class="line">&#125;</span><br><span class="line">public static void print(Integer... ints) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码是可以编译通过的。因为编译器知道参数是 String 类型还是 Integer 类型，只不过为了运行时不抛出 NullPointerException ，两个 print() 方法的内部要做好判空操作。</p>
<p>“好了，关于可变参数，我们就先讲到这里吧。三妹，你都理解了吧？”</p>
<p>“嗯嗯，不难，我理解了，哥。”三妹最近的学习状态真不错，能看得出来，她有在认真地做笔记 。</p>
<h2 id="3-6-Java-native方法"><a href="#3-6-Java-native方法" class="headerlink" title="3.6 Java native方法"></a>3.6 Java native方法</h2><p>“三妹，之前我们学习了 Java 中的基本方法，其实 Java 还有一种方法，本地方法，或者叫 native 方法，它与之前的方法有很大的不同。”我放下手中的手机，扭过脸来对三妹说。</p>
<p>“听起来挺有意思的。”三妹很期待。</p>
<p>“我会教你用 C语言实现一个 native 方法。”我继续说到，“C语言是另外一种编程语言，让我们开始吧”</p>
<p>类似 Thread 类中的 private native start0() 方法；</p>
<p>又或者 Object.class 类中的 getClass() 方法、hashCode()方法、clone() 方法，其中方法签名如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final native Class&lt;?&gt; getClass();</span><br><span class="line">public native int hashCode();</span><br><span class="line">protected native Object clone() throws CloneNotSupportedException;</span><br></pre></td></tr></table></figure>
<p>也就是用【native】关键词修饰的方法，多数情况下不需要用 Java 语言实现。</p>
<p>“二哥，为什么要用 native 来修饰方法呢，这样做有什么用？”三妹很乖，但这个问题也问的很掷地有声。</p>
<p>“好的，三妹，我们一步步来扒拉”。</p>
<p><strong>1、JNI：Java Native Interface</strong></p>
<p>在介绍 native 之前，我们先了解什么是 JNI。</p>
<p>一般情况下，我们完全可以使用 Java 语言编写程序，但某些情况下，Java 可能满足不了需求，或者不能更好的满足需求，比如：</p>
<p>①、标准的 Java 类库不支持。</p>
<p>②、我们已经用另一种语言，比如说 C/C++ 编写了一个类库，如何用 Java 代码调用呢？</p>
<p>③、某些运行次数特别多的方法，为了加快性能，需要用更接近硬件的语言（比如汇编）编写。</p>
<p>上面这三种需求，说到底就是如何用 Java 代码调用不同语言编写的代码。那么 JNI 应运而生了。</p>
<p>从 Java 1.1 开始，Java Native Interface (JNI)标准就成为 Java 平台的一部分，它允许 Java 代码和其他语言编写的代码进行交互。</p>
<p>JNI 一开始是为了本地已编译语言，尤其是 C 和 C++而设计的，但是它并不妨碍你使用其他语言，只要调用约定受支持就可以了。使用 Java 与本地已编译的代码交互，通常会丧失平台可移植性，但是，有些情况下这样做是可以接受的，甚至是必须的，比如，使用一些旧的库，与硬件、操作系统进行交互，或者为了提高程序的性能。JNI 标准至少保证本地代码能工作能在任何 Java 虚拟机实现下。</p>
<p><img src="\assets\note\image-20230927222301852.png" alt="image-20230927222301852"></p>
<p>通过 JNI，我们就可以通过 Java 程序（代码）调用到操作系统相关的技术实现的库函数，从而与其他技术和系统交互；同时其他技术和系统也可以通过 JNI 提供的相应原生接口调用 Java 应用系统内部实现的功能。</p>
<p>“二哥，等一下，Java 不是跨平台的吗？如果用 JNI，那么程序不就失去了跨平台的优点？”不得不说，三妹这个问题起到好处。</p>
<p>“确实是这样的。”我掐灭了中指和无名指之间的烟头，继续娓娓道来。</p>
<p>JNI 的缺点：</p>
<p>①、程序不再跨平台。要想跨平台，必须在不同的系统环境下重新编译本地语言部分。</p>
<p>②、程序不再是绝对安全的，本地代码的不当使用可能导致整个程序崩溃。一个通用规则是，你应该让本地方法集中在少数几个类当中。这样就降低了 Java 和 C/C++ 之间的耦合性。</p>
<p>目前来讲使用 JNI 的缺点相对于优点还是可以接受的，可能后面随着 Java 的技术发展，我们不在需要 JNI，</p>
<p>但是目前 JDK 还是一直提供了对 JNI 标准的支持。</p>
<p><strong>2、用 C 语言编写程序本地方法</strong></p>
<p>“上面讲解了什么是 JNI，接下来我们来写个例子：如何用 Java 代码调用本地的 C 程序。”我扭头对三妹说，</p>
<p>“你注意 看。”</p>
<blockquote>
<p>官方文档如下：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/jniTOC.html">https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/jniTOC.html</a></p>
</blockquote>
<p>步骤如下：</p>
<ol>
<li>编写带有 native 方法的 Java 类，生成.java 文件；</li>
<li>使用 javac 命令编译所编写的 Java 类，生成.class 文件；</li>
<li>使用 javah -jni java 类名 生成扩展名为 h 的头文件，也即生成 .h 文件；</li>
<li>使用 C/C++（或者其他编程想语言）实现本地方法，创建 .h 文件的实现，也就是创建 .cpp 文件实现.h文件中的方法；</li>
<li>将 C/C++ 编写的文件生成动态连接库，生成 dll 文件；</li>
</ol>
<p>下面我们通过一个 HelloWorld 程序的调用来完成这几个步骤。</p>
<p><strong>01）编写带有 native 方法的 Java 类 HelloJNI.java</strong></p>
<p>在 /Users/itwanger/Documents/Github/javabetter/testjni 目录下创建 HelloJNI.java 文件，内容如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class HelloJNI &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.loadLibrary(&quot;hello&quot;); // 加载名为 libhello.dylib 的动态链接库</span><br><span class="line">    &#125;</span><br><span class="line">    // 定义本地方法</span><br><span class="line">    private native void helloJNI();</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new HelloJNI().helloJNI(); // 调用本地方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS：后面执行的命令都将在 testjni 的目录下。</p>
<p>解释一下这段代码：</p>
<p>private native void helloJNI() ：用 native 声明的方法告知 JVM 调用该方法在外部定义，也就是我们会用 C 语言去实现。</p>
<p>System.loadLibrary(“hello”) ：加载动态库，参数 hello 是动态库的名字。我们可以这样理解：程序中的方法 helloJNI() 在程序中没有实现，但是我们下面要调用这个方法，怎么办呢？</p>
<p>我们就需要对这个方法进行初始化，所以用了 static 代码块进行初始化，后面会讲到。</p>
<p><strong>02）编译 HelloJNI.java</strong></p>
<p>在命令行通过 javac HelloJNI.java 来编译源代码。</p>
<p><img src="\assets\note\image-20230927222723939.png" alt="image-20230927222723939"></p>
<p><strong>03）使用 生成扩展名为 h 的头文件</strong></p>
<p><img src="\assets\note\image-20230927222756496.png" alt="image-20230927222756496"></p>
<blockquote>
<p>PS：Java 9 以后，javah 被弃用，取而代之的是使用 -h 选项来生成头文件，例如 javac -h .ClassName.java 。</p>
</blockquote>
<p>执行完毕后，会在 HelloJNI.java 所在目录下生成一个名为 HelloJNI.h 的头文件。打开 HelloJNI.h 文件，可以看到如下代码。</p>
<p><img src="\assets\note\image-20230927222847344.png" alt="image-20230927222847344"></p>
<p>看不懂没关系，无所谓，直到它是自动生成的就好。</p>
<p><strong>04）使用 C 语言实现本地方法</strong></p>
<p>创建一个 C 文件 HelloJNI.c，实现本地方法 sayHello。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;jni.h&gt;</span><br><span class="line">#include &quot;HelloJNI.h&quot;</span><br><span class="line">JNIEXPORT void JNICALL Java_HelloJNI_helloJNI(JNIEnv *env, jobject obj) &#123;</span><br><span class="line">    printf(&quot;Hello, JNI!\n&quot;);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，这里需要引入 JNI 头文件，并且实现的方法名称需要与在 Java 中声明的名称一致（ HelloJNI_helloJNI HelloJNI 类的 helloJNI 方法）。</p>
<p><strong>05）编写编译脚本 compile.sh</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># 编译 HelloJNI.c 文件</span><br><span class="line">gcc -I&quot;$JAVA_HOME/include&quot; -I&quot;$JAVA_HOME/include/darwin&quot; -shared -o libhello.dylib </span><br><span class="line">HelloJNI.c</span><br><span class="line"># 把生成的 libhello.dylib 文件拷贝到当前目录</span><br><span class="line">cp libhello.dylib .</span><br></pre></td></tr></table></figure>
<p>注意事项：</p>
<ul>
<li>$JAVA_HOME 是 JDK 的安装路径，需要根据实际情况修改。</li>
<li>在 macOS 上，动态链接库（hello）的后缀是 .dylib，而不是 Linux 上的 .so。</li>
</ul>
<p>这里的 -I 选项是为了告诉编译器头文件的位置， $​JAVA_HOME 是 Java 安装目录的路径。</p>
<p><strong>06）执行编译脚本</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh compile.sh</span><br></pre></td></tr></table></figure>
<p>执行完毕后，会在当前目录下生成一个名为 libhello.dylib 的动态链接库。</p>
<p><img src="\assets\note\image-20230927223317700.png" alt="image-20230927223317700"></p>
<p><strong>07）运行 HelloJNI</strong></p>
<p>执行 java HelloJNI 命令运行 HelloJNI，如果一切正常，就会在终端上输出 Hello, JNI!。</p>
<p><img src="\assets\note\image-20230927223359693.png" alt="image-20230927223359693"></p>
<p><strong>3、JNI 调用 C 的流程图</strong></p>
<p><img src="\assets\note\image-20230927223447275.png" alt="image-20230927223447275"></p>
<p><strong>4、native 关键字</strong></p>
<p>“三妹，现在应该知道什么是 native 了吧？”我问三妹。</p>
<p>“嗯嗯，我来简述一下，二哥你看看我说的是否正确。”</p>
<p>native 用来修饰方法，用 native 声明的方法表示该方法的实现在外部定义，可以用任何语言去实现它，比如说 C/C++。 简单地讲，一个 native Method 就是一个 Java 调用非 Java 代码的接口。</p>
<p>native 语法：</p>
<p>①、修饰方法的位置必须在返回类型之前，和其余的方法控制符前后关系不受限制。</p>
<p>②、不能用 abstract 修饰，也没有方法体，也没有左右大括号。</p>
<p>③、返回值可以是任意类型</p>
<p>“三妹，你学的不错嘛。”我对三妹的学习能力感到非常的欣慰，“<strong>我们在日常编程中看到 native 修饰的方法，只需要知道这个方法的作用是什么，至于别的就不用管了，操作系统会给我们实现，初学的时候也不需要太过深入。”</strong></p>
<h2 id="3-7-Java构造方法"><a href="#3-7-Java构造方法" class="headerlink" title="3.7 Java构造方法"></a>3.7 Java构造方法</h2><p>“三妹，上一节学了 Java 中的方法，接着学构造方法的话，难度就小很多了。”刚吃完中午饭，虽然有些困意，但趁机学个 10 分钟也是不错的，睡眠会更心满意足一些，于是我面露微笑地对三妹说。</p>
<p>“在 Java 中，构造方法是一种特殊的方法，当一个类被实例化的时候，就会调用构造方法。只有在构造方法被调用的时候，对象才会被分配内存空间。每次使用 new 关键字创建对象的时候，构造方法至少会被调用一次。”</p>
<p>“如果你在一个类中没有看见构造方法，并不是因为构造方法不存在，而是被缺省了，编译器会给这个类提供一个默认的构造方法。就是说，Java 有两种类型的构造方法：无参构造方法和有参构造方法。”</p>
<p>“注意，之所以叫它构造方法，是因为对象在创建的时候，需要通过构造方法初始化值——描写对象有哪些初始化状态。”</p>
<p>“哥，你缓缓，一口气说这么多，也真有你的。”三妹听得聚精会神，但也知道关心她这个既当哥又当老师的二哥了。</p>
<p><strong>01、创建构造方法的规则</strong></p>
<p>构造方法必须符合以下规则：</p>
<ul>
<li>构造方法的名字必须和类名一样；</li>
<li>构造方法没有返回类型，包括 void；</li>
<li>构造方法不能是抽象的（abstract）、静态的（static）、最终的（final）、同步的（synchronized）。</li>
</ul>
<p>简单解析一下最后一条规则。</p>
<ul>
<li>由于构造方法不能被子类继承，所以用 final 和 abstract 关键字修饰没有意义；</li>
<li>构造方法用于初始化一个对象，所以用 static 关键字修饰没有意义；</li>
<li>多个线程不会同时创建内存地址相同的同一个对象，所以用 synchronized 关键字修饰没有必要。</li>
</ul>
<p>构造方法的语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class class_name &#123;</span><br><span class="line">    public class_name()&#123;&#125;    // 默认无参构造方法</span><br><span class="line">    public ciass_name([paramList])&#123;&#125;    // 定义有参数列表的构造方法</span><br><span class="line">    …</span><br><span class="line">    // 类主体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得注意的是，如果用 void 声明构造方法的话，编译时不会报错，但 Java 会把这个所谓的“构造方法”当成普通方法来处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">    void Demo()&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>void Demo(){} 看起来很符合构造方法的写法（与类名相同），但其实只是一个不符合规范的普通方法，方法名的首字母使用了大写，方法体为空，它并不是默认的无参构造方法，可以通过反编译后的字节码验证。<br>class class_name {</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">    public Demo() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    void Demo() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>public Demo() {} 才是真正的无参构造方法。</p>
<p>不过，可以使用访问权限修饰符（private、protected、public、default）来修饰构造方法，访问权限修饰符决定了构造方法的创建方式。</p>
<p><strong>02、默认构造方法</strong></p>
<p>如果一个构造方法中没有任何参数，那么它就是一个默认构造方法，也称为无参构造方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Bike &#123;</span><br><span class="line">    Bike()&#123;</span><br><span class="line">        System.out.println(&quot;一辆自行车被创建&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Bike bike = new Bike();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面这个例子中，我们为 Bike 类中创建了一个无参的构造方法，它在我们创建对象的时候被调用。</p>
<p>程序输出结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一辆自行车被创建</span><br></pre></td></tr></table></figure>
<p>通常情况下，无参构造方法是可以缺省的，我们开发者并不需要显式的声明无参构造方法，把这项工作交给编译器就可以了。</p>
<p><img src="\assets\note\image-20231008193525406.png" alt="image-20231008193525406"></p>
<p>“二哥，默认构造方法的目的是什么？它为什么是一个空的啊？”三妹疑惑地看着我，提出了这个尖锐的问题。</p>
<p>“三妹啊，默认构造方法的目的主要是为对象的字段提供默认值，看下面这个例子你就明白了。”我胸有成竹地回答道。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person p = new Person();</span><br><span class="line">        System.out.println(&quot;姓名 &quot; + p.name + &quot; 年龄 &quot; + p.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">姓名 null 年龄 0</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，默认构造方法初始化了 name 和 age 的值，name 是 String 类型，所以默认值为 null，age 是 int 类型，所以默认值为 0。如果没有默认构造方法的话，这项工作就无法完成了。</p>
<p>**03、有参构造方法</p>
<p>有参数的构造方法被称为有参构造方法，参数可以有一个或多个。有参构造方法可以为不同的对象提供不同的值。当然，也可以提供相同的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class ParamConstructorPerson &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    public ParamConstructorPerson(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    public void out() &#123;</span><br><span class="line">        System.out.println(&quot;姓名 &quot; + name + &quot; 年龄 &quot; + age);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ParamConstructorPerson p1 = new ParamConstructorPerson(&quot;沉默王二&quot;,18);</span><br><span class="line">        p1.out();</span><br><span class="line">        ParamConstructorPerson p2 = new ParamConstructorPerson(&quot;沉默王三&quot;,16);</span><br><span class="line">        p2.out();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，构造方法有两个参数（name 和 age），这样的话，我们在创建对象的时候就可以直接为name 和 age 赋值了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new ParamConstructorPerson(&quot;沉默&quot;,18);</span><br><span class="line">new ParamConstructorPerson(&quot;沉默&quot;,16);</span><br></pre></td></tr></table></figure>
<p>如果没有有参构造方法的话，就需要通过 setter 方法给字段赋值了。</p>
<p><strong>04、重载构造方法</strong></p>
<p>在 Java 中，构造方法和方法类似，只不过没有返回类型。它也可以像方法一样被重载。构造方法的重载也很简单，只需要提供不同的参数列表即可。编译器会通过参数的数量来决定应该调用哪一个构造方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class OverloadingConstrutorPerson &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private int sex;</span><br><span class="line">    public OverloadingConstrutorPerson(String name, int age, int sex) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">    public OverloadingConstrutorPerson(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    public void out() &#123;</span><br><span class="line">        System.out.println(&quot;姓名 &quot; + name + &quot; 年龄 &quot; + age + &quot; 性别 &quot; + sex);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        OverloadingConstrutorPerson p1 = new OverloadingConstrutorPerson(&quot;沉默王</span><br><span class="line">二&quot;,18, 1);</span><br><span class="line">        p1.out();</span><br><span class="line">        OverloadingConstrutorPerson p2 = new OverloadingConstrutorPerson(&quot;沉默王</span><br><span class="line">三&quot;,16);</span><br><span class="line">        p2.out();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建对象的时候，如果传递的是三个参数，那么就会调用 OverloadingConstrutorPerson(String name, int age, int sex) 这个构造方法；如果传递的是两个参数，那么就会调用OverloadingConstrutorPerson(String name, int age) 这个构造方法。</p>
<p><strong>05、构造方法和方法的区别</strong></p>
<p>构造方法和方法之间的区别还是蛮多的，比如说下面这些：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">构造方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">方法反映了对象的行为</td>
<td style="text-align:center">构造方法用于初始化对象的字段</td>
</tr>
<tr>
<td style="text-align:center">方法可以有返回类型</td>
<td style="text-align:center">构造方法没有返回类型</td>
</tr>
<tr>
<td style="text-align:center">方法的调用是明确的，开发者通过代码决定调用哪一个</td>
<td style="text-align:center">构造方法的调用是隐式的，通过编译器完成</td>
</tr>
<tr>
<td style="text-align:center">方法在任何情况下都不能由编译器提供</td>
<td style="text-align:center">如果没有明确提供无参构造方法，编译器会提供</td>
</tr>
<tr>
<td style="text-align:center">方法名可以和类名相同，也可以不同</td>
<td style="text-align:center">构造方法的名称必须和类名相同</td>
</tr>
</tbody>
</table>
</div>
<p><strong>06、复制对象</strong></p>
<p>复制一个对象可以通过下面三种方式完成：</p>
<ul>
<li>通过构造方法</li>
<li>通过对象的值</li>
<li>通过 Object 类的 clone() 方法</li>
</ul>
<p><strong>1）通过构造方法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class CopyConstrutorPerson &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public CopyConstrutorPerson(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public CopyConstrutorPerson(CopyConstrutorPerson person) &#123;</span><br><span class="line">        this.name = person.name;</span><br><span class="line">        this.age = person.age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void out() &#123;</span><br><span class="line">        System.out.println(&quot;姓名 &quot; + name + &quot; 年龄 &quot; + age);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CopyConstrutorPerson p1 = new CopyConstrutorPerson(&quot;沉默王二&quot;,18);</span><br><span class="line">        p1.out();</span><br><span class="line">        CopyConstrutorPerson p2 = new CopyConstrutorPerson(p1);</span><br><span class="line">        p2.out();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，有一个参数为 CopyConstrutorPerson 的构造方法，可以把该参数的字段直接复制到新的对象中，这样的话，就可以在 new 关键字创建新对象的时候把之前的 p1 对象传递过去。</p>
<p><strong>2）通过对象的值</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class CopyValuePerson &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    </span><br><span class="line">    public CopyValuePerson(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public CopyValuePerson() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void out() &#123;</span><br><span class="line">        System.out.println(&quot;姓名 &quot; + name + &quot; 年龄 &quot; + age);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CopyValuePerson p1 = new CopyValuePerson(&quot;沉默王二&quot;,18);</span><br><span class="line">        p1.out();</span><br><span class="line">        CopyValuePerson p2 = new CopyValuePerson();</span><br><span class="line">        p2.name = p1.name;</span><br><span class="line">        p2.age = p1.age;</span><br><span class="line">        </span><br><span class="line">        p2.out();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式比较粗暴，直接拿 p1 的字段值复制给 p2 对象（ p2.name = p1.name ）。</p>
<p><strong>3）通过 Object 类的 方法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class ClonePerson implements Cloneable &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    </span><br><span class="line">    public ClonePerson(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    protected Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        return super.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void out() &#123;</span><br><span class="line">        System.out.println(&quot;姓名 &quot; + name + &quot; 年龄 &quot; + age);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) throws CloneNotSupportedException &#123;</span><br><span class="line">        ClonePerson p1 = new ClonePerson(&quot;沉默王二&quot;,18);</span><br><span class="line">        p1.out();</span><br><span class="line">        ClonePerson p2 = (ClonePerson) p1.clone();</span><br><span class="line">        p2.out();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 clone() 方法复制对象的时候，ClonePerson 必须先实现 Cloneable 接口的 clone() 方法，然后再调用 clone() 方法（ ClonePerson p2 = (ClonePerson) p1.clone() ）。</p>
<p><strong>07、ending</strong></p>
<p>“二哥，我能问一些问题吗？”三妹精神焕发，没有丝毫的疲惫。</p>
<p>“当然可以啊，你问。”我很欣赏三妹孜孜不倦的态度。</p>
<p>“构造方法真的不返回任何值吗？”</p>
<p>“构造方法虽然没有返回值，但返回的是类的对象。”</p>
<p>“构造方法只能完成字段初始化的工作吗？”</p>
<p>“初始化字段只是构造方法的一种工作，它还可以做更多，比如启动线程，调用其他方法等。”</p>
<p>“好的，二哥，我的问题问完了，今天的学习可以结束了！”三妹一脸得意的样子。</p>
<p>“那你记得复习下一节的内容哦。”感受到三妹已经学到了知识，我也很欣慰。</p>
<h2 id="3-8-Java访问权限修饰符"><a href="#3-8-Java访问权限修饰符" class="headerlink" title="3.8 Java访问权限修饰符"></a>3.8 Java访问权限修饰符</h2><p>“我们先来讨论一下为什么需要访问权限控制。其实之前我们在讲类和对象的时候有提到，今天我们来详细地聊一聊，三妹。”我开门见山地说，“三妹，你打开思维导图，记得做笔记哦。”</p>
<p>“好的。”三妹应声回答。</p>
<p>考虑两个场景：</p>
<p>场景 1：工程师 A 编写了一个类 ClassA，但是工程师 A 并不希望 ClassA 被其他类都访问到，该如何处理呢？</p>
<p>场景 2：工程师 A 编写了一个类 ClassA，其中有两个方法 fun1、fun2，工程师只想让 fun1 对外可见，也就是说，如果别的工程师来调用 ClassA，只可以调用方法 fun1，该怎么处理呢？</p>
<p>此时，访问权限控制便可以起到作用了。</p>
<p>在 Java 中，提供了四种访问权限控制：</p>
<ul>
<li>默认访问权限（包访问权限）</li>
<li>public</li>
<li>private</li>
<li>protected</li>
</ul>
<p>类只可以用默认访问权限和 public 修饰。比如说：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class Wanger&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Wanger&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>但变量和方法则都可以修饰。</p>
<p><strong>1.修饰类</strong></p>
<ul>
<li>默认访问权限（包访问权限）：用来修饰类的话，表示该类只对同一个包中的其他类可见。</li>
<li>public：用来修饰类的话，表示该类对其他所有的类都可见。</li>
</ul>
<p>例 1：</p>
<p>Main.java:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package com.tobetterjavaer.test1;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String\[\] args) &#123;</span><br><span class="line">        People people = new People(&quot;Tom&quot;);</span><br><span class="line">        System.out.println(people.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>People.java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.tobetterjavaer.test1;</span><br><span class="line">class People &#123;//默认访问权限（包访问权限）</span><br><span class="line">    private String name = null;</span><br><span class="line">    </span><br><span class="line">    public People(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码可以看出，修饰 People 类采用的是默认访问权限，而由于 People 类和 Main 类在同一个包中，因此People 类对于 Main 类是可见的。</p>
<p>例子 2：</p>
<p>People.java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.tobetterjavaer.test2;</span><br><span class="line">class People &#123;//默认访问权限（包访问权限）</span><br><span class="line">    private String name = null;</span><br><span class="line">    </span><br><span class="line">    public People(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时 People 类和 Main 类不在同一个包中，会发生什么情况呢？</p>
<p>下面是 Main 类中的提示的错误：</p>
<p><img src="\assets\note\image-20231008195929488.png" alt="image-20231008195929488"></p>
<p>提示 Peolple 类在 Main 类中不可见。从这里就可以看出，如果用默认访问权限去修饰一个类，该类只对同一个包中的其他类可见，对于不同包中的类是不可见的。</p>
<p>正如上图的快速修正提示所示，将 People 类的默认访问权限更改为 public 的话，People 类对于 Main 类便可见了。</p>
<p><strong>2.修饰方法和变量</strong></p>
<ul>
<li>默认访问权限（包访问权限）：如果一个类的方法或变量被包访问权限修饰，也就意味着只能在同一个包中的其他类中显示地调用该类的方法或者变量，在不同包中的类中不能显式地调用该类的方法或变量。</li>
<li>private：如果一个类的方法或者变量被 private 修饰，那么这个类的方法或者变量只能在该类本身中被访问，在类外以及其他类中都不能显式的进行访问。</li>
<li>protected：如果一个类的方法或者变量被 protected 修饰，对于同一个包的类，这个类的方法或变量是可以被访问的。对于不同包的类，只有继承于该类的类才可以访问到该类的方法或者变量。</li>
<li>public：被 public 修饰的方法或者变量，在任何地方都是可见的。</li>
</ul>
<p>例 3：</p>
<p>Main.java 没有变化</p>
<p>People.java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.tobebetterjavaer.test1;</span><br><span class="line">public class People &#123;</span><br><span class="line">    private String name = null;</span><br><span class="line">    </span><br><span class="line">    public People(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    String getName() &#123;    //默认访问权限（包访问权限）</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void setName(String name) &#123;   //默认访问权限（包访问权限）</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时在 Main 类是可以显示调用方法 getName 和 setName 的。</p>
<p>但是如果 People 类和 Main 类不在同一个包中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.tobebetterjavaer.test2;    //与Main类处于不同包中</span><br><span class="line">public class People &#123;</span><br><span class="line">    private String name = null;</span><br><span class="line">    public People(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    String getName() &#123;    //默认访问权限（包访问权限）</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    void setName(String name) &#123;   //默认访问权限（包访问权限）</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时在 Main 类中会提示错误：</p>
<p><img src="\assets\note\image-20231008200209205.png" alt="image-20231008200209205"></p>
<p>由此可以看出，如果用默认访问权限来修饰类的方法或者变量，则只能在同一个包的其他类中进行访问。</p>
<p>例 4:</p>
<p>People.java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.tobebetterjavaer.test1;</span><br><span class="line">public class People &#123;</span><br><span class="line">    private String name = null;</span><br><span class="line">    </span><br><span class="line">    public People(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    protected void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时是可以在 Main 中显示调用方法 getName 和 setName 的。</p>
<p>如果 People 类和 Main 类处于不同包中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.tobebetterjavaer.test2;</span><br><span class="line">public class People &#123;</span><br><span class="line">    private String name = null;</span><br><span class="line">    public People(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    protected String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    protected void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>则会在 Main 中报错：</p>
<p><img src="\assets\note\image-20231008200350535.png" alt="image-20231008200350535"></p>
<p>如果在 com.cxh.test1 中定一个类 Man 继承 People，则可以在类 Man 中显示调用方法 getName 和setName：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package com.tobebetterjavaer.test1;</span><br><span class="line">import com.tobebetterjavaer.test2.People;</span><br><span class="line">public class Man extends People &#123;</span><br><span class="line">    public Man(String name)&#123;</span><br><span class="line">        super(name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>补充一些关于 Java 包和类文件的知识：</p>
<p>1）Java 中的包主要是为了防止类文件命名冲突以及方便进行代码组织和管理；</p>
<p>2）对于一个 Java 源代码文件，如果存在 public 类的话，只能有一个 public 类，且此时源代码文件的名称必须和 public 类的名称完全相同。</p>
<p>另外，如果还存在其他类，这些类在包外是不可见的。如果源代码文件没有 public 类，则源代码文件的名称可以随意命名。</p>
<p>“三妹，理解了吧？”我问三妹。</p>
<p>“是的，很简单，换句话说，不想让别人看的就 private，想让人看的就 public，想同一个班级/部门看的就默认，想让下一级看的就 protected，对吧？哥”三妹很自信地回答。</p>
<p>“不错不错，总结得有那味了。”</p>
<h2 id="3-9-Java代码初始化块"><a href="#3-9-Java代码初始化块" class="headerlink" title="3.9 Java代码初始化块"></a>3.9 Java代码初始化块</h2><p>“哥，今天我们要学习的内容是‘代码初始化块’，对吧？”看来三妹已经提前预习了我上次留给她的作业。</p>
<p>“是的，三妹。代码初始化块用于初始化一些成员变量。 ”我面带着朴实无华的微笑回答着她，“对象在创建的时候会执行代码初始化块，又称实例初始化块，主要和静态初始化块做区分。”</p>
<p>“可以直接通过‘=’操作符对成员变量进行初始化，但通过代码初始化块可以做更多的事情，比如说打印出成员变量初始化后的值。”</p>
<p>“三妹，来看下面的代码，我们可以直接通过 = 操作符对成员变量进行初始化。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Bike&#123;  </span><br><span class="line">    int speed=100;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>“哥，那为什么还需要代码初始化块呢？”三妹眨了眨眼睛，不解地问。</p>
<p>“我们可以通过代码初始化块执行一个更复杂的操作，比如为集合填充值。来看下面这段代码。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Bike &#123;</span><br><span class="line">    List&lt;String&gt; list;</span><br><span class="line">    &#123;</span><br><span class="line">        list = new ArrayList&lt;&gt;();</span><br><span class="line">        list.add(&quot;沉默&quot;);</span><br><span class="line">        list.add(&quot;沉默&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(new Bike().list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“如果只使用‘=’操作符的话，是没办法完成集合初始化的，对吧？‘=’ 后面只能 new 出集合，却没办法填充值，代码初始化就可以完成这项工作。”</p>
<p>“构造方法执行得早还是代码初始化块啊，哥？”三妹这个问题问的还是挺有水平的。</p>
<p>“不要着急，三妹，先来看下面这个例子。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Car &#123;</span><br><span class="line">    Car() &#123;</span><br><span class="line">        System.out.println(&quot;构造方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;代码初始化块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Car();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“我们来看一下程序的输出结果就一下子明白了。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">代码初始化块</span><br><span class="line">构造方法</span><br></pre></td></tr></table></figure>
<p>“从输出结果看上去，仿佛代码初始化块执行得更早，对吧？事实上是这样子吗？”我露出神秘的微笑，问三妹。</p>
<p>“难道我看到的是假象吗？”三妹睁大了眼睛。</p>
<p>“不是的，对象在初始化的时候会先调用构造方法，这是毫无疑问的，只不过，构造方法在执行的时候会把代码初始化块放在构造方法中其他代码之前，所以，先看到了‘代码初始化块’，后看到了‘’构造方法’。”</p>
<p>说完这句话，我打开 draw.io，使上了吃奶的劲，画出了下面这幅图。</p>
<p><img src="\assets\note\image-20231008200932252.png" alt="image-20231008200932252"></p>
<p>“哦，原来如此啊！”三妹仿佛发现了新大陆，意味深长地说，“编译器把代码初始化块放到了构造方法中，怪不得。”</p>
<p>等三妹明白彻底搞明白后，我对她继续说道：“对于代码初始化来说，它有三个规则。”</p>
<ul>
<li>类实例化的时候执行代码初始化块；</li>
<li>实际上，代码初始化块是放在构造方法中执行的，只不过比较靠前；</li>
<li>代码初始化块里的执行顺序是从前到后的。</li>
</ul>
<p>“这些规则不用死记硬背，大致了解一下就行了。我们继续来看下面这段代码。”话音刚落，我就在新版的IDEA 中噼里啪啦地敲了起来，新版真香。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    A () &#123;</span><br><span class="line">        System.out.println(&quot;父类构造方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class B extends A&#123;</span><br><span class="line">    B() &#123;</span><br><span class="line">        System.out.println(&quot;子类构造方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;代码初始化块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new B();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“来看一下输出结果。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">父类构造方法</span><br><span class="line">代码初始化块</span><br><span class="line">子类构造方法</span><br></pre></td></tr></table></figure>
<p>“在默认情况下，子类的构造方法在执行的时候会主动去调用父类的构造方法。也就是说，其实是构造方法先执行的，再执行的代码初始化块。”</p>
<p>“这个例子再次印证了之前的第二条规则：代码初始化块是放在构造方法中执行的，只不过比较靠前。”</p>
<p>除了这种实例化代码初始化块，还有静态初始化，不过我们会放到 static 关键字中去讲，这里先大致了解一下。</p>
<p>下面是一个 Java 示例代码，演示实例初始化块和静态初始化块的用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class Example &#123;</span><br><span class="line">    // 静态变量</span><br><span class="line">    public static int staticVar = 1;</span><br><span class="line">    // 实例变量</span><br><span class="line">    public int instanceVar = 2;</span><br><span class="line">    </span><br><span class="line">    // 静态初始化块</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;执行静态初始化块&quot;);</span><br><span class="line">        staticVar = 3;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 实例初始化块</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;执行实例初始化块&quot;);</span><br><span class="line">        instanceVar = 4;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 构造方法</span><br><span class="line">    public Example() &#123;</span><br><span class="line">        System.out.println(&quot;执行构造方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;执行main方法&quot;);</span><br><span class="line">        Example e1 = new Example();</span><br><span class="line">        Example e2 = new Example();</span><br><span class="line">        System.out.println(&quot;e1的静态变量：&quot; + e1.staticVar);</span><br><span class="line">        System.out.println(&quot;e1的实例变量：&quot; + e1.instanceVar);</span><br><span class="line">        System.out.println(&quot;e2的静态变量：&quot; + e2.staticVar);</span><br><span class="line">        System.out.println(&quot;e2的实例变量：&quot; + e2.instanceVar);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例代码中，有一个静态变量 staticVar 和一个实例变量 instanceVar，以及一个静态初始化块和一个实例初始化块。在静态初始化块中，我们打印了一条消息并修改了静态变量的值；在实例初始化块中，我们也打印了一条消息并修改了实例变量的值。</p>
<p>来看一下执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">执行静态初始化块</span><br><span class="line">执行main方法</span><br><span class="line">执行实例初始化块</span><br><span class="line">执行构造方法</span><br><span class="line">执行实例初始化块</span><br><span class="line">执行构造方法</span><br><span class="line">e1的静态变量：3</span><br><span class="line">e1的实例变量：4</span><br><span class="line">e2的静态变量：3</span><br><span class="line">e2的实例变量：4</span><br></pre></td></tr></table></figure>
<p>从输出结果可以看出，静态初始化块在类加载时执行，只会执行一次，并且优先于实例初始化块和构造方法的执行；实例初始化块在每次创建对象时执行，在构造方法之前执行。</p>
<p>“好了，今天就先讲到这吧，中午休息一下，下午的精神会更足。”刚对三妹说完这句话，我的哈欠就上来了，好困。</p>
<h2 id="3-10-Java抽象类"><a href="#3-10-Java抽象类" class="headerlink" title="3.10 Java抽象类"></a>3.10 Java抽象类</h2><p>“二哥，你这明显加快了更新的频率呀！”三妹对于我最近的肝劲由衷的佩服了起来。</p>
<p>“哈哈，是呀，我要给广大的学弟学妹们一个完整的 Java 学习体系，记住我们的口号，学 Java 就上二哥的Java 进阶之路。”我对未来充满了信心。</p>
<p>“那就开始吧。”三妹说。</p>
<p><strong>01、定义抽象类</strong></p>
<p>定义抽象类的时候需要用到关键字 abstract ，放在 class 关键字前，就像下面这样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">abstract class AbstractPlayer &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于抽象类的命名，《阿里的 Java 开发手册》上有强调，“抽象类命名要使用 Abstract 或 Base 开头”，这条规约还是值得遵守的，真正做到名如其意。</p>
<p><strong>02、抽象类的特征</strong></p>
<p>抽象类是不能实例化的，尝试通过 new 关键字实例化的话，编译器会报错，提示“类是抽象的，不能实例化”。</p>
<p><img src="\assets\note\image-20231008201407072.png" alt="image-20231008201407072"></p>
<p>虽然抽象类不能实例化，但可以有子类。子类通过 extends 关键字来继承抽象类。就像下面这样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class BasketballPlayer extends AbstractPlayer &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果一个类定义了一个或多个抽象方法，那么这个类必须是抽象类。</p>
<p>当我们尝试在一个普通类中定义抽象方法的时候，编译器会有两处错误提示。第一处在类级别上，提示“这个类必须通过 abstract 关键字定义”，见下图。</p>
<p><img src="\assets\note\image-20231008201509135.png" alt="image-20231008201509135"></p>
<p>第二处在尝试定义 abstract 的方法上，提示“抽象方法所在的类不是抽象的”，见下图。</p>
<p><img src="\assets\note\image-20231008201528683.png" alt="image-20231008201528683"></p>
<p>抽象类中既可以定义抽象方法，也可以定义普通方法，就像下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractPlayer &#123;</span><br><span class="line">    abstract void play();</span><br><span class="line">    </span><br><span class="line">    public void sleep() &#123;</span><br><span class="line">        System.out.println(&quot;运动员也要休息而不是挑战极限&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抽象类派生的子类必须实现父类中定义的抽象方法。比如说，抽象类 AbstractPlayer 中定义了 play() 方法，子类 BasketballPlayer 中就必须实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class BasketballPlayer extends AbstractPlayer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    void play() &#123;</span><br><span class="line">        System.out.println(&quot;我是张伯伦，篮球场上得过 100 分&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果没有实现的话，编译器会提示“子类必须实现抽象方法”，见下图。</p>
<p><img src="\assets\note\image-20231009084933649.png" alt="image-20231009084933649"></p>
<p><strong>03、抽象类的应用场景</strong></p>
<p>“二哥，抽象方法我明白了，那什么时候使用抽象方法呢？能给我讲讲它的应用场景吗？”三妹及时的插话道。</p>
<p>“这问题问的恰到好处呀！”我扶了扶眼镜继续说。</p>
<p><strong>01）第一种场景</strong></p>
<p>当我们希望一些通用的功能被多个子类复用的时候，就可以使用抽象类。比如说，AbstractPlayer 抽象类中有一个普通的方法 sleep() ，表明所有运动员都需要休息，那么这个方法就可以被子类复用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">abstract class AbstractPlayer &#123;</span><br><span class="line">    public void sleep() &#123;</span><br><span class="line">        System.out.println(&quot;运动员也要休息而不是挑战极限&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类 BasketballPlayer 继承了 AbstractPlayer 类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class BasketballPlayer extends AbstractPlayer &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就拥有了 sleep() 方法。BasketballPlayer 的对象可以直接调用父类的 sleep() 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BasketballPlayer basketballPlayer = new BasketballPlayer();</span><br><span class="line">basketballPlayer.sleep();</span><br></pre></td></tr></table></figure>
<p>子类 FootballPlayer 继承了 AbstractPlayer 类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class FootballPlayer extends AbstractPlayer &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也拥有了 sleep() 方法，FootballPlayer 的对象也可以直接调用父类的 sleep() 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FootballPlayer footballPlayer = new FootballPlayer();</span><br><span class="line">footballPlayer.sleep();</span><br></pre></td></tr></table></figure>
<p>这样是不是就实现了代码的复用呢？</p>
<p><strong>02）第二种场景</strong></p>
<p>当我们需要在抽象类中定义好 API，然后在子类中扩展实现的时候就可以使用抽象类。比如说，AbstractPlayer 抽象类中定义了一个抽象方法 play() ，表明所有运动员都可以从事某项运动，但需要对应子类去扩展实现，表明篮球运动员打篮球，足球运动员踢足球。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abstract class AbstractPlayer &#123;</span><br><span class="line">    abstract void play();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BasketballPlayer 继承了 AbstractPlayer 类，扩展实现了自己的 play() 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class BasketballPlayer extends AbstractPlayer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    void play() &#123;</span><br><span class="line">        System.out.println(&quot;我是张伯伦，我篮球场上得过 100 分，&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FootballPlayer 继承了 AbstractPlayer 类，扩展实现了自己的 play() 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class FootballPlayer extends AbstractPlayer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    void play() &#123;</span><br><span class="line">        System.out.println(&quot;我是C罗，我能接住任意高度的头球&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了进一步展示抽象类的特性，我们再来看一个具体的示例。</p>
<blockquote>
<p>PS：网站评论区说涉及到了文件的读写以及 Java 8 的新特性，不适合新人，如果觉得自己实在是看不懂，跳过，等学了 IO 流再来看也行。如果说是为了复习 Java 基础知识，就不存在这个问题了。</p>
</blockquote>
<p>假设现在有一个文件，里面的内容非常简单，只有一个“Hello World”，现在需要有一个读取器将内容从文件中读取出来，最好能按照大写的方式，或者小写的方式来读。</p>
<p>这时候，最好定义一个抽象类 BaseFileReader：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 抽象类，定义了一个读取文件的基础框架，其中 mapFileLine 是一个抽象方法，具体实现需要由子类来完成</span><br><span class="line"> */</span><br><span class="line">abstract class BaseFileReader &#123;</span><br><span class="line">    protected Path filePath; // 定义一个 protected 的 Path 对象，表示读取的文件路径</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 构造方法，传入读取的文件路径</span><br><span class="line">     * @param filePath 读取的文件路径</span><br><span class="line">     */</span><br><span class="line">    protected BaseFileReader(Path filePath) &#123;</span><br><span class="line">        this.filePath = filePath;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 读取文件的方法，返回一个字符串列表</span><br><span class="line">     * @return 字符串列表，表示文件的内容</span><br><span class="line">     * @throws IOException 如果文件读取出错，抛出该异常</span><br><span class="line">     */</span><br><span class="line">    public List&lt;String&gt; readFile() throws IOException &#123;</span><br><span class="line">        return Files.lines(filePath) // 使用 Files 类的 lines 方法，读取文件的每一行</span><br><span class="line">                .map(this::mapFileLine) // 对每一行应用 mapFileLine 方法，将其转化为指定的格式</span><br><span class="line">                .collect(Collectors.toList()); // 将处理后的每一行收集到一个字符串列表中，返回</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 抽象方法，子类需要实现该方法，将文件中的每一行转化为指定的格式</span><br><span class="line">     * @param line 文件中的每一行</span><br><span class="line">     * @return 转化后的字符串</span><br><span class="line">     */</span><br><span class="line">    protected abstract String mapFileLine(String line);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>filePath 为文件路径，使用 protected 修饰，表明该成员变量可以在需要时被子类访问到。</li>
<li>readFile() 方法用来读取文件，方法体里面调用了抽象方法 mapFileLine() ——需要子类来扩展实现大小写的不同读取方式。</li>
</ul>
<p>在我看来，BaseFileReader 类设计的就非常合理，并且易于扩展，子类只需要专注于具体的大小写实现方式就可以了。</p>
<p>小写的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class LowercaseFileReader extends BaseFileReader &#123;</span><br><span class="line">    protected LowercaseFileReader(Path filePath) &#123;</span><br><span class="line">        super(filePath);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected String mapFileLine(String line) &#123;</span><br><span class="line">        return line.toLowerCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大写的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class UppercaseFileReader extends BaseFileReader &#123;</span><br><span class="line">    protected UppercaseFileReader(Path filePath) &#123;</span><br><span class="line">        super(filePath);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected String mapFileLine(String line) &#123;</span><br><span class="line">        return line.toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从文件里面一行一行读取内容的代码被子类复用了。与此同时，子类只需要专注于自己该做的工作，LowercaseFileReader 以小写的方式读取文件内容，UppercaseFileReader 以大写的方式读取文件内容。</p>
<p>来看一下测试类 FileReaderTest：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class FileReaderTest &#123;</span><br><span class="line">    public static void main(String[] args) throws URISyntaxException, IOException &#123;</span><br><span class="line">        URL location = </span><br><span class="line">FileReaderTest.class.getClassLoader().getResource(&quot;helloworld.txt&quot;);</span><br><span class="line">        Path path = Paths.get(location.toURI());</span><br><span class="line">        BaseFileReader lowercaseFileReader = new LowercaseFileReader(path);</span><br><span class="line">        BaseFileReader uppercaseFileReader = new UppercaseFileReader(path);</span><br><span class="line">        System.out.println(lowercaseFileReader.readFile());</span><br><span class="line">        System.out.println(uppercaseFileReader.readFile());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在项目的 resource 目录下建一个文本文件，名字叫 helloworld.txt，里面的内容就是“Hello World”。文件的具体位置如下图所示，我用的集成开发环境是 Intellij IDEA。</p>
<p><img src="\assets\note\image-20231009085712342.png" alt="image-20231009085712342"></p>
<p>在 resource 目录下的文件可以通过 ClassLoader.getResource() 的方式获取到 URI 路径，然后就可以取到文本内容了。</p>
<p>输出结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[hello world]</span><br><span class="line">[HELLO WORLD]</span><br></pre></td></tr></table></figure>
<p><strong>04、抽象类总结</strong></p>
<p>好了，对于抽象类我们简单总结一下：</p>
<ol>
<li>抽象类不能被实例化。</li>
<li>抽象类应该至少有一个抽象方法，否则它没有任何意义。</li>
<li>抽象类中的抽象方法没有方法体。</li>
<li>抽象类的子类必须给出父类中的抽象方法的具体实现，除非该子类也是抽象类。</li>
</ol>
<p>“完了吗？二哥”三妹似乎还沉浸在聆听教诲的快乐中。</p>
<p>“是滴，这次我们系统化的学习了抽象类，可以说面面俱到了。三妹你可以把代码敲一遍，加强了一些印象，电脑交给你了。”</p>
<h2 id="3-11-Java接口"><a href="#3-11-Java接口" class="headerlink" title="3.11 Java接口"></a>3.11 Java接口</h2><p>“今天开始讲 Java 的接口。”我对三妹说，“对于面向对象编程来说，抽象是一个极具魅力的特征。如果一个程序员的抽象思维很差，那他在编程中就会遇到很多困难，无法把业务变成具体的代码。在 Java 中，可以通过两种形式来达到抽象的目的，一种上一篇的主角——抽象类，另外一种就是今天的主角——接口。”</p>
<p>“是呀是呀，让我们开始吧！”</p>
<p><strong>01、定义接口</strong></p>
<p>“接口是什么呀？”三妹顺着我的话题及时的插话到。</p>
<p>接口通过 interface 关键字来定义，它可以包含一些常量和方法，来看下面这个示例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public interface Electronic &#123;</span><br><span class="line">    // 常量</span><br><span class="line">    String LED = &quot;LED&quot;;</span><br><span class="line">    // 抽象方法</span><br><span class="line">    int getElectricityUse();</span><br><span class="line">    // 静态方法</span><br><span class="line">    static boolean isEnergyEfficient(String electtronicType) &#123;</span><br><span class="line">        return electtronicType.equals(LED);</span><br><span class="line">    &#125;</span><br><span class="line">    // 默认方法</span><br><span class="line">    default void printDescription() &#123;</span><br><span class="line">        System.out.println(&quot;电子&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看一下这段代码反编译后的字节码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public interface Electronic</span><br><span class="line">&#123;</span><br><span class="line">    public abstract int getElectricityUse();</span><br><span class="line">    public static boolean isEnergyEfficient(String electtronicType)</span><br><span class="line">    &#123;</span><br><span class="line">        return electtronicType.equals(&quot;LED&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void printDescription()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;\u7535\u5B50&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static final String LED = &quot;LED&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现没？接口中定义的所有变量或者方法，都会自动添加上 public 关键字。</p>
<p>接下来，我来一一解释下 Electronic 接口中的核心知识点。</p>
<p>1）<strong>接口中定义的变量会在编译的时候自动加上 public static final修饰符</strong>（注意看一下反编译后的字节码），也就是说上例中的 LED 变量其实就是一个常量。</p>
<p>Java 官方文档上有这样的声明：</p>
<blockquote>
<p>Every field declaration in the body of an interface is implicitly public, static, and final.</p>
</blockquote>
<p>换句话说，接口可以用来作为常量类使用，还能省略掉 public static final ，看似不错的一种选择，对吧？</p>
<p>不过，这种选择并不可取。因为接口的本意是对方法进行抽象，而常量接口会对子类中的变量造成命名空间上的“污染”。</p>
<p>2）<strong>没有使用 private、 default或者 static关键字修饰的方法是隐式抽象的</strong>，在编译的时候会自动加上 public abstract 修饰符。也就是说上例中的 getElectricityUse() 其实是一个抽象方法，没有方法体——这是定义接口的本意。</p>
<p>3）<strong>从 Java 8 开始，接口中允许有静态方法</strong>，比如说上例中的 isEnergyEfficient() 方法。</p>
<p>静态方法无法由（实现了该接口的）类的对象调用，它只能通过接口名来调用，比如说Electronic.isEnergyEfficient(“LED”) 。</p>
<p>接口中定义静态方法的目的是为了提供一种简单的机制，使我们不必创建对象就能调用方法，从而提高接口的竞争力。</p>
<p>4）<strong>接口中允许定义 方法也是从 Java 8 开始的</strong>，比如说上例中的 printDescription() 方法，它始终由一个代码块组成，为实现该接口而不覆盖该方法的类提供默认实现。既然要提供默认实现，就要有方法体，换句话说，默认方法后面不能直接使用“;”号来结束——编译器会报错。</p>
<p><img src="\assets\note\image-20231009090314788.png" alt="image-20231009090314788"></p>
<p>“为什么要在接口中定义默认方法呢？”三妹好奇地问到。</p>
<p>允许在接口中定义默认方法的理由很充分，因为一个接口可能有多个实现类，这些类就必须实现接口中定义的抽象类，否则编译器就会报错。假如我们需要在所有的实现类中追加某个具体的方法，在没有 default方法的帮助下，我们就必须挨个对实现类进行修改。</p>
<p>由之前的例子我们就可以得出下面这些结论：</p>
<ul>
<li>接口中允许定义变量</li>
<li>接口中允许定义抽象方法</li>
<li>接口中允许定义静态方法（Java 8 之后）</li>
<li>接口中允许定义默认方法（Java 8 之后）</li>
</ul>
<p>除此之外，我们还应该知道：</p>
<p>1）<strong>接口不允许直接实例化</strong>，否则编译器会报错。</p>
<p><img src="\assets\note\image-20231009090411986.png" alt="image-20231009090411986"></p>
<p>需要定义一个类去实现接口，见下例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Computer implements Electronic &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Computer();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public int getElectricityUse() &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后再实例化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Electronic e = new Computer();</span><br></pre></td></tr></table></figure>
<p>2）<strong>接口可以是空的</strong>，既可以不定义变量，也可以不定义方法。最典型的例子就是 Serializable 接口，在java.io 包下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public interface Serializable &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Serializable 接口用来为序列化的具体实现提供一个标记，也就是说，只要某个类实现了 Serializable 接口，那么它就可以用来序列化了。</p>
<p>3）<strong>不要在定义接口的时候使用 final 关键字</strong>，否则会报编译错误，因为接口就是为了让子类实现的，而final 阻止了这种行为。</p>
<p><img src="\assets\note\image-20231009090541758.png" alt="image-20231009090541758"></p>
<p>4）<strong>接口的抽象方法不能是 private、protected 或者 final</strong>，否则编译器都会报错。</p>
<p><img src="\assets\note\image-20231009090603974.png" alt="image-20231009090603974"></p>
<p>5）<strong>接口的变量是隐式 public static final（常量）</strong>，所以其值无法改变。</p>
<p><strong>02、接口的作用</strong></p>
<p>“接口可以做什么呢？”三妹见缝插针，问的很及时。</p>
<p>第一，<strong>使某些实现类具有我们想要的功能</strong>，比如说，实现了 Cloneable 接口的类具有拷贝的功能，实现了Comparable 或者 Comparator 的类具有比较功能。</p>
<p>Cloneable 和 Serializable 一样，都属于标记型接口，它们内部都是空的。实现了 Cloneable 接口的类可以使用 Object.clone() 方法，否则会抛出 CloneNotSupportedException。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class CloneableTest implements Cloneable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        return super.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws CloneNotSupportedException &#123;</span><br><span class="line">        CloneableTest c1 = new CloneableTest();</span><br><span class="line">        CloneableTest c2 = (CloneableTest) c1.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后没有报错。现在把 implements Cloneable 去掉。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class CloneableTest &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        return super.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws CloneNotSupportedException &#123;</span><br><span class="line">        CloneableTest c1 = new CloneableTest();</span><br><span class="line">        CloneableTest c2 = (CloneableTest) c1.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后抛出 CloneNotSupportedException：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.CloneNotSupportedException: </span><br><span class="line">com.cmower.baeldung.interface1.CloneableTest</span><br><span class="line">    at java.base/java.lang.Object.clone(Native Method)</span><br><span class="line">    at com.cmower.baeldung.interface1.CloneableTest.clone(CloneableTest.java:6)</span><br><span class="line">    at com.cmower.baeldung.interface1.CloneableTest.main(CloneableTest.java:11)</span><br></pre></td></tr></table></figure>
<p>第二，<strong>Java 原则上只支持单一继承，但通过接口可以实现多重继承的目的。</strong></p>
<p>如果有两个类共同继承（extends）一个父类，那么父类的方法就会被两个子类重写。然后，如果有一个新类同时继承了这两个子类，那么在调用重写方法的时候，编译器就不能识别要调用哪个类的方法了。这也正是著名的菱形问题，见下图。</p>
<p><img src="\assets\note\image-20231009090838159.png" alt="image-20231009090838159"></p>
<p>简单解释下，ClassC 同时继承了 ClassA 和 ClassB，ClassC 的对象在调用 ClassA 和 ClassB 中重写的方法时，就不知道该调用 ClassA 的方法，还是 ClassB 的方法。</p>
<p>接口没有这方面的困܃。来定义两个接口，Fly 接口会飞，Run 接口会跑。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface Fly &#123;</span><br><span class="line">    void fly();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface Run &#123;</span><br><span class="line">    void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后让 Pig 类同时实现这两个接口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Pig implements Fly,Run&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void fly() &#123;</span><br><span class="line">        System.out.println(&quot;会飞的猪&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;会跑的猪&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在某种形式上，接口实现了多重继承的目的：现实世界里，猪的确只会跑，但在雷军的眼里，站在风口的猪就会飞，这就需要赋予这只猪更多的能力，通过抽象类是无法实现的，只能通过接口。</p>
<p>第三，<strong>实现多态。</strong></p>
<p>什么是多态呢？通俗的理解，就是同一个事件发生在不同的对象上会产生不同的结果，鼠标左键点击窗口上的 X 号可以关闭窗口，点击超链接却可以打开新的网页。</p>
<p>多态可以通过继承（ extends ）的关系实现，也可以通过接口的形式实现。</p>
<p>Shape 接口表示一个形状。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Shape &#123;</span><br><span class="line">    String name();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Circle 类实现了 Shape 接口，并重写了 name() 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Circle implements Shape &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String name() &#123;</span><br><span class="line">        return &quot;圆&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Square 类也实现了 Shape 接口，并重写了 name() 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Square implements Shape &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String name() &#123;</span><br><span class="line">        return &quot;正方形&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后来看测试类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Shape&gt; shapes = new ArrayList&lt;&gt;();</span><br><span class="line">Shape circleShape = new Circle();</span><br><span class="line">Shape squareShape = new Square();</span><br><span class="line">shapes.add(circleShape);</span><br><span class="line">shapes.add(squareShape);</span><br><span class="line">for (Shape shape : shapes) &#123;</span><br><span class="line">    System.out.println(shape.name());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就实现了多态，变量 circleShape、squareShape 的引用类型都是 Shape，但执行 shape.name() 方法的时候，Java 虚拟机知道该去调用 Circle 的 name() 方法还是 Square 的 name() 方法。</p>
<p>说一下多态存在的 3 个前提：</p>
<ol>
<li>要有继承关系，比如说 Circle 和 Square 都实现了 Shape 接口。</li>
<li>子类要重写父类的方法，Circle 和 Square 都重写了 name() 方法。</li>
<li>父类引用指向子类对象，circleShape 和 squareShape 的类型都为 Shape，但前者指向的是 Circle对象，后者指向的是 Square 对象。</li>
</ol>
<p>然后，我们来看一下测试结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">圆</span><br><span class="line">正方形</span><br></pre></td></tr></table></figure>
<p>也就意味着，尽管在 for 循环中，shape 的类型都为 Shape，但在调用 name() 方法的时候，它知道 Circle对象应该调用 Circle 类的 name() 方法，Square 对象应该调用 Square 类的 name() 方法。</p>
<p><strong>03、接口的三种模式</strong></p>
<p><strong>在编程领域，好的设计模式能够让我们的代码事半功倍</strong>。在使用接口的时候，经常会用到三种模式，分别是策略模式、适配器模式和工厂模式。</p>
<p><strong>1）策略模式</strong></p>
<p>策略模式的思想是，针对一组算法，将每一种算法封装到具有共同接口的实现类中，接口的设计者可以在不影响调用者的情况下对算法做出改变。示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 接口：教练</span><br><span class="line">interface Coach &#123;</span><br><span class="line">    // 方法：防守</span><br><span class="line">    void defend();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 何塞·穆里尼奥</span><br><span class="line">class Hesai implements Coach &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void defend() &#123;</span><br><span class="line">        System.out.println(&quot;防守赢得冠军&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 德普·瓜迪奥拉</span><br><span class="line">class Guatu implements Coach &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void defend() &#123;</span><br><span class="line">        System.out.println(&quot;进攻就是最好的防守&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Demo &#123;</span><br><span class="line">    // 参数为接口</span><br><span class="line">    public static void defend(Coach coach) &#123;</span><br><span class="line">        coach.defend();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 为同一个方法传递不同的对象</span><br><span class="line">        defend(new Hesai());</span><br><span class="line">        defend(new Guatu());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Demo.defend() 方法可以接受不同风格的 Coach，并根据所传递的参数对象的不同而产生不同的行为，这被称为“策略模式”。</p>
<p><strong>2）适配器模式</strong></p>
<p>适配器模式的思想是，针对调用者的需求对原有的接口进行转接。生活当中最常见的适配器就是HDMI（英语： High Definition Multimedia Interface ，中文：高清多媒体接口）线，可以同时发送音频和视频信号。适配器模式的示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">interface Coach &#123;</span><br><span class="line">    void defend();</span><br><span class="line">    void attack();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 抽象类实现接口，并置空方法</span><br><span class="line">abstract class AdapterCoach implements Coach &#123;</span><br><span class="line">    public void defend() &#123;&#125;;</span><br><span class="line">    public void attack() &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 新类继承适配器</span><br><span class="line">class Hesai extends AdapterCoach &#123;</span><br><span class="line">    public void defend() &#123;</span><br><span class="line">        System.out.println(&quot;防守赢得冠军&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Demo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Coach coach = new Hesai();</span><br><span class="line">        coach.defend();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Coach 接口中定义了两个方法（ defend() 和 attack() ），如果类直接实现该接口的话，就需要对两个方法进行实现。</p>
<p>如果我们只需要对其中一个方法进行实现的话，就可以使用一个抽象类作为中间件，即适配器（AdapterCoach），用这个抽象类实现接口，并对抽象类中的方法置空（方法体只有一对花括号），这时候，新类就可以绕过接口，继承抽象类，我们就可以只对需要的方法进行覆盖，而不是接口中的所有方法。</p>
<p><strong>3）工厂模式</strong></p>
<p>所谓的工厂模式理解起来也不难，就是什么工厂生产什么，比如说宝马工厂生产宝马，奔驰工厂生产奔驰，A 级学院毕业 A 级教练，C 级学院毕业 C 级教练。示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">// 教练</span><br><span class="line">interface Coach &#123;</span><br><span class="line">    void command();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 教练学院</span><br><span class="line">interface CoachFactory &#123;</span><br><span class="line">    Coach createCoach();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// A级教练</span><br><span class="line">class ACoach implements Coach &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void command() &#123;</span><br><span class="line">        System.out.println(&quot;我是A级证书教练&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// A级教练学院</span><br><span class="line">class ACoachFactory implements CoachFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Coach createCoach() &#123;</span><br><span class="line">        return new ACoach();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// C级教练</span><br><span class="line">class CCoach implements Coach &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void command() &#123;</span><br><span class="line">        System.out.println(&quot;我是C级证书教练&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// C级教练学院</span><br><span class="line">class CCoachFactory implements CoachFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Coach createCoach() &#123;</span><br><span class="line">        return new CCoach();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Demo &#123;</span><br><span class="line">    public static void create(CoachFactory factory) &#123;</span><br><span class="line">        factory.createCoach().command();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 对于一支球队来说，需要什么样的教练就去找什么样的学院</span><br><span class="line">        // 学院会介绍球队对应水平的教练。</span><br><span class="line">        create(new ACoachFactory());</span><br><span class="line">        create(new CCoachFactory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有两个接口，一个是 Coach（教练），可以 command() （指挥球队）；另外一个是 CoachFactory（教练学院），能 createCoach() （教出一名优秀的教练）。然后 ACoach 类实现 Coach 接口，ACoachFactory 类实现 CoachFactory 接口；CCoach 类实现 Coach 接口，CCoachFactory 类实现 CoachFactory 接口。当需要 A 级教练时，就去找 A 级教练学院；当需要 C 级教练时，就去找 C 级教练学院。</p>
<p>依次类推，我们还可以用 BCoach 类实现 Coach 接口，BCoachFactory 类实现 CoachFactory 接口，从而不断地丰富教练的梯队。</p>
<p>“怎么样三妹，一下子接收这么多知识点不容易吧？”</p>
<p>“其实还好啊，二哥你讲的这么细致，我都做好笔记 了，学习嘛，认真一点，效果就会好很多了。”</p>
<p>三妹这种积极乐观的态度真的让我感觉到“付出就会有收获。</p>
<p><strong>04、抽象类和接口的区别</strong></p>
<p>简单总结一下抽象类和接口的区别。</p>
<p>在 Java 中，通过关键字 abstract 定义的类叫做抽象类。Java 是一门面向对象的语言，因此所有的对象都是通过类来描述的；但反过来，并不是所有的类都是用来描述对象的，抽象类就是其中的一种。</p>
<p>以下示例展示了一个简单的抽象类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 个人认为，一名教练必须攻守兼备</span><br><span class="line">abstract class Coach &#123;</span><br><span class="line">    public abstract void defend();</span><br><span class="line">    public abstract void attack();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们知道，有抽象方法的类被称为抽象类，也就意味着抽象类中还能有不是抽象方法的方法。这样的类就不能算作纯粹的接口，尽管它也可以提供接口的功能——只能说抽象类是普通类与接口之间的一种中庸之道。</p>
<p><strong>接口（英文：Interface），在 Java 中是一个抽象类型，是抽象方法的集合</strong>；接口通过关键字 interface来定义。接口与抽象类的不同之处在于：</p>
<ol>
<li>抽象类可以有方法体的方法，但接口没有（Java 8 以前）。</li>
<li>接口中的成员变量隐式为 static final ，但抽象类不是的。</li>
<li>一个类可以实现多个接口，但只能继承一个抽象类。</li>
</ol>
<p>以下示例展示了一个简单的接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 隐式的abstract</span><br><span class="line">interface Coach &#123;</span><br><span class="line">    // 隐式的public</span><br><span class="line">    void defend();</span><br><span class="line">    void attack();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>接口是隐式抽象的，所以声明时没有必要使用 abstract 关键字；</li>
<li>接口的每个方法都是隐式抽象的，所以同样不需要使用 abstract 关键字；</li>
<li>接口中的方法都是隐式 public 的。</li>
</ul>
<p>“哦，我理解了哥。那我再问一下，抽象类和接口有什么差别呢？”</p>
<p>“哇，三妹呀，你这个问题恰到好处，问到了点子上。”我不由得为三妹竖起了大拇指。</p>
<p><strong>1）语法层面上</strong></p>
<ul>
<li>抽象类可以提供成员方法的实现细节，而接口中只能存在 public abstract 方法；</li>
<li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的；</li>
<li>接口中不能含有静态代码块，而抽象类可以有静态代码块；</li>
<li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li>
</ul>
<p><strong>2）设计层面上</strong></p>
<p>抽象类是对一种事物的抽象，即对类抽象，继承抽象类的子类和抽象类本身是一种 is-a 的关系。而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。</p>
<p>举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类 Airplane，将鸟设计为一个类 Bird，但是不能将 飞行 这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。</p>
<p>此时可以将 飞行 设计为一个接口 Fly，包含方法 fly()，然后 Airplane 和 Bird 分别根据自己的需要实现 Fly这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承 Airplane 即可，对于鸟也是类似的，不同种类的鸟直接继承 Bird 类即可。从这里可以看出，继承是一个 “是不是”的关系，而 接口 实现则是”有没有”的关系。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。</p>
<p>接口是对类的某种行为的一种抽象，接口和类之间并没有很强的关联关系，举个例子来说，所有的类都可以实现 Serializable 接口，从而具有序列化的功能，但不能说所有的类和 Serializable 之间是 is-a 的关系。</p>
<p>抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。什么是模板式设计？最简单例子，大家都用过 ppt 里面的模板，如果用模板 A 设计了 ppt B 和 ppt C，ppt B 和ppt C 公共的部分就是模板 A 了，如果它们的公共部分需要改动，则只需要改动模板 A 就可以了，不需要重新对 ppt B 和 ppt C 进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。</p>
<h2 id="3-12-Java内部类"><a href="#3-12-Java内部类" class="headerlink" title="3.12 Java内部类"></a>3.12 Java内部类</h2><p>“在 Java 中，可以将一个类定义在另外一个类里面或者一个方法里面，这样的类叫做内部类。”我放下手中的枸杞杯，对三妹说，“一般来说，内部类分为成员内部类、局部内部类、匿名内部类和静态内部类。”</p>
<p><strong>1）成员内部类</strong></p>
<p>成员内部类是最常见的内部类，看下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Wanger &#123;</span><br><span class="line">    int age = 18;</span><br><span class="line">    </span><br><span class="line">    class Wangxiaoer &#123;</span><br><span class="line">        int age = 81;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看起来内部类 Wangxiaoer 就好像 Wanger 的一个成员，成员内部类可以无限制访问外部类的所有成员属性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Wanger &#123;</span><br><span class="line">    int age = 18;</span><br><span class="line">    private String name = &quot;沉默&quot;;</span><br><span class="line">    static double money = 1;</span><br><span class="line">    </span><br><span class="line">    class Wangxiaoer &#123;</span><br><span class="line">        int age = 81;</span><br><span class="line">        </span><br><span class="line">        public void print() &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">            System.out.println(money);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部类可以随心所欲地访问外部类的成员，但外部类想要访问内部类的成员，就不那么容易了，必须先创建一个成员内部类的对象，再通过这个对象来访问：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Wanger &#123;</span><br><span class="line">    int age = 18;</span><br><span class="line">    private String name = &quot;沉默&quot;;</span><br><span class="line">    static double money = 1;</span><br><span class="line">    </span><br><span class="line">    public Wanger () &#123;</span><br><span class="line">        new Wangxiaoer().print();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    class Wangxiaoer &#123;</span><br><span class="line">        int age = 81;</span><br><span class="line">        public void print() &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">            System.out.println(money);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这也就意味着，如果想要在静态方法中访问成员内部类的时候，就必须先得创建一个外部类的对象，因为内部类是依附于外部类的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Wanger &#123;</span><br><span class="line">    int age = 18;</span><br><span class="line">    private String name = &quot;沉默&quot;;</span><br><span class="line">    static double money = 1;</span><br><span class="line">    </span><br><span class="line">    public Wanger () &#123;</span><br><span class="line">        new Wangxiaoer().print();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Wanger wanger = new Wanger();</span><br><span class="line">        Wangxiaoer xiaoer = wanger.new Wangxiaoer();</span><br><span class="line">        xiaoer.print();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    class Wangxiaoer &#123;</span><br><span class="line">        int age = 81;</span><br><span class="line">        </span><br><span class="line">        public void print() &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">            System.out.println(money);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种创建内部类的方式在实际开发中并不常用，因为内部类和外部类紧紧地绑定在一起，使用起来非常不便。</p>
<p><strong>2）局部内部类</strong></p>
<p>局部内部类是定义在一个方法或者一个作用域里面的类，所以局部内部类的生命周期仅限于作用域内。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Wangsan &#123;</span><br><span class="line">    public Wangsan print() &#123;</span><br><span class="line">        class Wangxiaosan extends Wangsan&#123;</span><br><span class="line">            private int age = 18;</span><br><span class="line">        &#125;</span><br><span class="line">        return new Wangxiaosan();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>局部内部类就好像一个局部变量一样，它是不能被权限修饰符修饰的，比如说 public、protected、private和 static 等。</p>
<p><img src="\assets\note\image-20231009092647012.png" alt="image-20231009092647012"></p>
<p><strong>3）匿名内部类</strong></p>
<p>匿名内部类是我们平常用得最多的，尤其是启动多线程的时候，会经常用到，并且 IDE 也会帮我们自动生成。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread t = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>匿名内部类就好像一个方法的参数一样，用完就没了，以至于我们都不需要为它专门写一个构造方法，它的名字也是由系统自动命名的。仔细观察编译后的字节码文件也可以发现，匿名内部类连名字都不配拥有，哈哈，直接借用的外部类，然后 $1 就搞定了。</p>
<p><img src="\assets\note\image-20231009092806871.png" alt="image-20231009092806871"></p>
<p>匿名内部类是唯一一种没有构造方法的类。就上面的写法来说，匿名内部类也不允许我们为其编写构造方法，因为它就像是直接通过 new 关键字创建出来的一个对象。</p>
<p>匿名内部类的作用主要是用来继承其他类或者实现接口，并不需要增加额外的方法，方便对继承的方法进行实现或者重写。</p>
<p><strong>4）静态内部类</strong></p>
<p>静态内部类和成员内部类类似，只是多了一个 static 关键字。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Wangsi &#123;</span><br><span class="line">    static int age;</span><br><span class="line">    double money;</span><br><span class="line">    </span><br><span class="line">    static class Wangxxiaosi &#123;</span><br><span class="line">        public Wangxxiaosi ()&#123;</span><br><span class="line">            System.out.println(age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 static 关键字的存在，静态内部类是不允许访问外部类中非 static 的变量和方法的，这一点也非常好理解：你一个静态的内部类访问我非静态的成员变量干嘛？</p>
<p><img src="\assets\note\image-20231009093032698.png" alt="image-20231009093032698"></p>
<p>“为什么要使用内部类呢？”三妹问。</p>
<p>三妹这个问题问的非常妙，是时候引经据典了。</p>
<p>在《Think in java》中有这样一句话：</p>
<blockquote>
<p>使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。</p>
</blockquote>
<p>在我们程序设计中有时候会存在一些使用接口很难解决的问题，这个时候我们可以利用内部类提供的、可以继承多个具体的或者抽象的类的能力来解决这些程序设计问题。可以这样说，接口只是解决了部分问题，而内部类使得多重继承的解决方案变得更加完整。</p>
<p>使用内部类还能够为我们带来如下特性：</p>
<ol>
<li>内部类可以使用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。</li>
<li>在单个外部类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。</li>
<li>创建内部类对象的时刻并不依赖于外部类对象的创建。</li>
<li>内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。</li>
<li>内部类提供了更好的封装，除了该外围类，其他类都不能访问。</li>
</ol>
<h2 id="3-13-Java封装继承多态"><a href="#3-13-Java封装继承多态" class="headerlink" title="3.13 Java封装继承多态"></a>3.13 Java封装继承多态</h2><p>在谈 Java 面向对象的时候，不得不提到面向对象的三大特征：封装、继承、多态。三大特征紧密联系而又有区别，合理使用继承能大大减少重复代码，提高代码复用性。</p>
<p>**1）封装</p>
<p>“三妹，准备好了没，我们来讲 Java 封装，算是 Java 的三大特征之一，理清楚了，对以后的编程有较大的帮助。”我对三妹说。</p>
<p>“好的，哥，准备好了。”三妹一边听我说，一边迅速地打开了 XMind，看来一边学习一边总结思维导图这个高效的学习方式三妹已经牢记在心了。</p>
<p>封装从字面上来理解就是包装的意思，专业点就是信息隐藏，是<strong>指利用抽象将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。</strong></p>
<p>数据被保护在类的内部，尽可能地隐藏内部的实现细节，只保留一些对外接口使之与外部发生联系。</p>
<p>其他对象只能通过已经授权的操作来与这个封装的对象进行交互。也就是说用户是无需知道对象内部的细节（当然也无从知道），但可以通过该对象对外的提供的接口来访问该对象。</p>
<p>使用封装有 4 大好处：</p>
<ol>
<li>良好的封装能够减少耦合。</li>
<li>类内部的结构可以自由修改。</li>
<li>可以对成员进行更精确的控制。</li>
<li>隐藏信息，实现细节。</li>
</ol>
<p>首先我们先来看两个类。</p>
<p>Husband.java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class Husband &#123;</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">     * 对属性的封装</span><br><span class="line">     * 一个人的姓名、性别、年龄、妻子都是这个人的私有属性</span><br><span class="line">     */</span><br><span class="line">    private String name ;</span><br><span class="line">    private String sex ;</span><br><span class="line">    private int age ;</span><br><span class="line">    private Wife wife;</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">     * setter()、getter()是该对象对外开发的接口</span><br><span class="line">     */</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public String getSex() &#123;</span><br><span class="line">        return sex;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setSex(String sex) &#123;</span><br><span class="line">        this.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setWife(Wife wife) &#123;</span><br><span class="line">        this.wife = wife;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Wife.java</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class Wife &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private String sex;</span><br><span class="line">    private Husband husband;</span><br><span class="line">    </span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public String getSex() &#123;</span><br><span class="line">        return sex;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setSex(String sex) &#123;</span><br><span class="line">        this.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setHusband(Husband husband) &#123;</span><br><span class="line">        this.husband = husband;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Husband getHusband() &#123;</span><br><span class="line">        return husband;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看得出， Husband 类里面的 wife 属性是没有 getter() 的，同时 Wife 类的 age 属性也是没有getter() 方法的。至于理由我想三妹你是懂的。</p>
<p>没有哪个女人愿意别人知道她的年龄。</p>
<p>所以封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果不想被外界方法，我们大可不必提供方法给外界访问。</p>
<p>但是如果一个类没有提供给外界任何可以访问的方法，那么这个类也没有什么意义了。</p>
<p>比如我们将一个房子看做是一个对象，里面有漂亮的装饰，如沙发、电视剧、空调、茶桌等等都是该房子的私有属性，但是如果我们没有那些墙遮挡，是不是别人就会一览无余呢？没有一点儿隐私！</p>
<p>因为存在那个遮挡的墙，我们既能够有自己的隐私而且我们可以随意的更改里面的摆设而不会影响到外面的人。</p>
<p>但是如果没有门窗，一个包裹的严严实实的黑盒子，又有什么存在的意义呢？所以通过门窗别人也能够看到里面的风景。所以说门窗就是房子对象留给外界访问的接口。</p>
<p>通过这个我们还不能真正体会封装的好处。现在我们从程序的角度来分析封装带来的好处。如果我们不使用封装，那么该对象就没有 setter() 和 getter() ，那么 Husband 类应该这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Husband &#123;</span><br><span class="line">    public String name ;</span><br><span class="line">    public String sex ;</span><br><span class="line">    public int age ;</span><br><span class="line">    public Wife wife;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们应该这样来使用它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Husband husband = new Husband();</span><br><span class="line">husband.age = 30;</span><br><span class="line">husband.name = &quot;张三&quot;;</span><br><span class="line">husband.sex = &quot;男&quot;;    //貌似有点儿多余</span><br></pre></td></tr></table></figure>
<p>但是哪天如果我们需要修改 Husband，例如将 age 修改为 String 类型的呢？你只有一处使用了这个类还好，如果你有几十个甚至上百个这样地方，你是不是要改到崩溃。如果使用了封装，我们完全可以不需要做任何修改，只需要稍微改变下 Husband 类的 setAge() 方法即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Husband &#123;</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">     * 对属性的封装</span><br><span class="line">     * 一个人的姓名、性别、年龄、妻子都是这个人的私有属性</span><br><span class="line">     */</span><br><span class="line">    private String name ;</span><br><span class="line">    private String sex ;</span><br><span class="line">    private String age ;    /* 改成 String类型的*/</span><br><span class="line">    private Wife wife;</span><br><span class="line">    </span><br><span class="line">    public String getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        //转换即可</span><br><span class="line">        this.age = String.valueOf(age);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** 省略其他属性的setter、getter **/</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他的地方依然这样引用( husband.setAge(22) )保持不变。</p>
<p>到了这里我们确实可以看出，<strong>封装确实可以使我们更容易地修改类的内部实现，而无需修改使用了该类的代码。</strong></p>
<p>我们再看这个好处：<strong>封装可以对成员变量进行更精确的控制。</strong></p>
<p>还是那个 Husband，一般来说我们在引用这个对象的时候是不容易出错的，但是有时你迷糊了，写成了这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Husband husband = new Husband();</span><br><span class="line">husband.age = 300;</span><br></pre></td></tr></table></figure>
<p>也许你是因为粗心写成了这样，你发现了还好，如果没有发现那就麻烦大了，谁见过 300 岁的老妖怪啊！但是使用封装我们就可以避免这个问题，我们对 age 的访问入口做一些控制(setter)如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Husband &#123;</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">     * 对属性的封装</span><br><span class="line">     * 一个人的姓名、性别、年龄、妻子都是这个人的私有属性</span><br><span class="line">     */</span><br><span class="line">    private String name ;</span><br><span class="line">    private String sex ;</span><br><span class="line">    private int age ;    /* 改成 String类型的*/</span><br><span class="line">    private Wife wife;</span><br><span class="line">    </span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        if(age &gt; 120)&#123;</span><br><span class="line">            System.out.println(&quot;ERROR：error age input....&quot;);    //提示錯誤信息</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            this.age = age;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** 省略其他属性的setter、getter **/</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面都是对 setter 方法的控制，其实通过封装我们也能够对对象的出口做出很好的控制。例如性别在数据库中一般都是以 1、0 的方式来存储的，但是在前台我们又不能展示 1、0，这里我们只需要在 getter() 方法里面做一些转换即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public String getSexName() &#123;</span><br><span class="line">    if(&quot;0&quot;.equals(sex))&#123;</span><br><span class="line">        sexName = &quot;女&quot;;</span><br><span class="line">    &#125;else if(&quot;1&quot;.equals(sex))&#123;</span><br><span class="line">        sexName = &quot;男&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return sexName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用的时候我们只需要使用 sexName 即可实现正确的性别显示。同理也可以用于针对不同的状态做出不同的操作。</p>
<p>“好了，关于封装我们就暂时就聊这么多吧。”我喝了一口普洱茶后，对三妹说。</p>
<p>“好的，哥，我懂了。”</p>
<p><strong>2）继承</strong></p>
<p><strong>01、什么是继承</strong></p>
<p>继承（英语：inheritance）是面向对象软件技术中的一个概念。它<strong>使得复用以前的代码非常容易。</strong></p>
<p>Java 语言是非常典型的面向对象的语言，在 Java 语言中<strong>继承就是子类继承父类的属性和方法，使得子类对象（实例）具有父类的属性和方法，或子类从父类继承方法，使得子类具有父类相同的方法。</strong></p>
<p>我们来举个例子：动物有很多种，是一个比较大的概念。在动物的种类中，我们熟悉的有猫(Cat)、狗(Dog)等动物，它们都有动物的一般特征（比如能够吃东西，能够发出声音），不过又在细节上有区别（不同动物的吃的不同，叫声不一样）。</p>
<p>在 Java 语言中实现 Cat 和 Dog 等类的时候，就需要继承 Animal 这个类。继承之后 Cat、Dog 等具体动物类就是子类，Animal 类就是父类。</p>
<p><img src="\assets\note\image-20231009104042170.png" alt="image-20231009104042170"></p>
<p><strong>02、为什么需要继承</strong></p>
<p>三妹，你可能会问为什么需要继承？</p>
<p>如果仅仅只有两三个类，每个类的属性和方法很有限的情况下确实没必要实现继承，但事情并非如此，事实上一个系统中往往有很多个类并且有着很多相似之处，比如猫和狗同属动物，或者学生和老师同属人。各个类可能又有很多个相同的属性和方法，这样的话如果每个类都重新写不仅代码显得很乱，代码工作量也很大。</p>
<p>这时继承的优势就出来了：可以直接使用父类的属性和方法，自己也可以有自己新的属性和方法满足拓展，父类的方法如果自己有需求更改也可以重写。这样<strong>使用继承不仅大大的减少了代码量，也使得代码结构更加清晰可见。</strong></p>
<p><img src="\assets\note\image-20231009104136062.png" alt="image-20231009104136062"></p>
<p>所以这样从代码的层面上来看我们设计这个完整的 Animal 类是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Animal</span><br><span class="line">&#123;</span><br><span class="line">    public int id;</span><br><span class="line">    public String name;</span><br><span class="line">    public int age;</span><br><span class="line">    public int weight;</span><br><span class="line">    </span><br><span class="line">    public Animal(int id, String name, int age, int weight) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //这里省略get set方法</span><br><span class="line">    public void sayHello()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void eat()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;I&#x27;m eating&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void sing()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;sing&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而 Dog，Cat，Chicken 类可以这样设计：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Dog extends Animal//继承animal</span><br><span class="line">&#123;</span><br><span class="line">    public Dog(int id, String name, int age, int weight) &#123;</span><br><span class="line">        super(id, name, age, weight);//调用父类构造方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Cat extends Animal&#123;</span><br><span class="line">    public Cat(int id, String name, int age, int weight) &#123;</span><br><span class="line">        super(id, name, age, weight);//调用父类构造方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Chicken extends Animal&#123;</span><br><span class="line">    public Chicken(int id, String name, int age, int weight) &#123;</span><br><span class="line">        super(id, name, age, weight);//调用父类构造方法</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //鸡下蛋</span><br><span class="line">    public void layEggs()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;我是老母鸡下蛋啦，咯哒咯！咯哒咯！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>各自的类继承 Animal 后可以直接使用 Animal 类的属性和方法而不需要重复编写，各个类如果有自己的方法<br>也可很容易地拓展。</p>
<p><strong>03、继承的分类</strong></p>
<p>继承分为单继承和多继承，Java 语言只支持类的单继承，但可以通过实现接口的方式达到多继承的目的。这个我们之前在讲接口的时候就提到过，这里我们再聊一下。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">继承</th>
<th style="text-align:center">定义</th>
<th style="text-align:center">优缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">单继承<img src="\assets\note\image-20231009104637899.png" alt="image-20231009104637899"></td>
<td style="text-align:center">一个子类只拥有一个父类</td>
<td style="text-align:center">优点：在类层次结构上比较清晰<br/>缺点：结构的丰富度有时不能满足使用需求</td>
</tr>
<tr>
<td style="text-align:center">多继承（Java 不支持，但可以用其它方式满足多继承使用需求）<img src="\assets\note\image-20231009104707021.png" alt="image-20231009104707021"></td>
<td style="text-align:center">一个子类拥有多个直接的父类</td>
<td style="text-align:center">优点：子类的丰富度很高<br/>缺点：容易造成混乱</td>
</tr>
</tbody>
</table>
</div>
<p><strong>单继承</strong></p>
<p>单继承，一个子类只有一个父类，如我们上面讲过的 Animal 类和它的子类。<strong>单继承在类层次结构上比较清晰，但缺点是结构的丰富度有时不能满足使用需求。</strong></p>
<p><strong>多继承</strong></p>
<p>多继承，一个子类有多个直接的父类。这样做的好处是子类拥有所有父类的特征，<strong>子类的丰富度很高，但是缺点就是容易造成混乱。</strong>下图为一个混乱的例子。</p>
<p><img src="\assets\note\image-20231009104922728.png" alt="image-20231009104922728"></p>
<p>Java 虽然不支持多继承，但是 Java 有三种实现多继承效果的方式，分别是内部类、多层继承和实现接口。</p>
<p>内部类可以继承一个与外部类无关的类，保证了内部类的独立性，正是基于这一点，可以达到多继承的效果。</p>
<p><strong>多层继承：</strong>子类继承父类，父类如果还继承其他的类，那么这就叫多层继承。这样子类就会拥有所有被继承类的属性和方法。</p>
<p><img src="\assets\note\image-20231009105109312.png" alt="image-20231009105109312"></p>
<p>实现接口无疑是满足多继承使用需求的最好方式，一个类可以实现多个接口满足自己在丰富性和复杂环境的使用需求。</p>
<p>类和接口相比，<strong>类就是一个实体，有属性和方法，而接口更倾向于一组方法。</strong>举个例子，就拿斗罗大陆的唐三来看，他存在的继承关系可能是这样的：</p>
<p><img src="\assets\note\image-20231009105144388.png" alt="image-20231009105144388"></p>
<p><strong>04、如何实现继承</strong></p>
<p><strong>extends 关键字</strong></p>
<p>在 Java 中，类的继承是单一继承，也就是说一个子类只能拥有一个父类，所以extends只能继承一个类。其使用语法为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class 子类名 extends 父类名&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>例如 Dog 类继承 Animal 类，它是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Animal&#123;&#125; //定义Animal类</span><br><span class="line">class Dog extends Animal&#123;&#125; //Dog类继承Animal类</span><br></pre></td></tr></table></figure>
<p>子类继承父类后，就拥有父类的非私有的属性和方法。如果不明白，请看这个案例，在 IDEA 下创建一个项目，创建一个 test 类做测试，分别创建 Animal 类和 Dog 类，Animal 作为父类写一个 sayHello()方法，Dog 类继承 Animal 类之后就可以调用 sayHello()方法。具体代码为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    public void  sayHello()//父类的方法</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;hello,everybody&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal//继承animal</span><br><span class="line">&#123; &#125;</span><br><span class="line"></span><br><span class="line">public class test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">       Dog dog=new Dog();</span><br><span class="line">       dog.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>点击运行的时候 Dog 子类可以直接使用 Animal 父类的方法。</p>
<p><img src="\assets\note\image-20231009105347508.png" alt="image-20231009105347508"></p>
<p><strong>implements 关键字</strong></p>
<p>使用 implements 关键字可以变相使 Java 拥有多继承的特性，使用范围为类实现接口的情况，一个类可以实现多个接口(接口与接口之间用逗号分开)。</p>
<p>我们来看一个案例，创建一个 test2 类做测试，分别创建 doA 接口和 doB 接口，doA 接口声明 sayHello()方法，doB 接口声明 eat()方法，创建 Cat2 类实现 doA 和 doB 接口，并且在类中需要重写 sayHello()方法和eat()方法。具体代码为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">interface doA&#123;</span><br><span class="line">     void sayHello();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface doB&#123;</span><br><span class="line">     void eat();</span><br><span class="line">    //以下会报错 接口中的方法不能具体定义只能声明</span><br><span class="line">    //public void eat()&#123;System.out.println(&quot;eating&quot;);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Cat2 implements  doA,doB&#123;</span><br><span class="line">    @Override//必须重写接口内的方法</span><br><span class="line">    public void sayHello() &#123;</span><br><span class="line">        System.out.println(&quot;hello!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        System.out.println(&quot;I&#x27;m eating&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class test2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Cat2 cat=new Cat2();</span><br><span class="line">        cat.sayHello();</span><br><span class="line">        cat.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Cat 类实现 doA 和 doB 接口的时候，需要实现其声明的方法，点击运行结果如下，这就是一个类实现接口的简单案例：</p>
<p><img src="\assets\note\image-20231009105517320.png" alt="image-20231009105517320"></p>
<p><strong>05、继承的特点</strong></p>
<p>继承的主要内容就是子类继承父类，并重写父类的方法。使用子类的属性或方法时候，首先要创建一个对象，而对象通过构造方法去创建，在构造方法中我们可能会调用子父类的一些属性和方法，所以就需要提前掌握 this 和 super关键字。</p>
<p>创建完这个对象之后，再调用重写父类后的方法，注意重写和重载的区别。</p>
<p><strong>this 和 super 关键字</strong></p>
<p>后面会详细讲，这里先来简单了解一下。</p>
<p>this 和 super 关键字是继承中非常重要的知识点，分别表示当前对象的引用和父类对象的引用，两者有很大相似又有一些区别。</p>
<p><strong>this 表示当前对象，是指向自己的引用。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.属性 // 调用成员变量，要区别成员变量和局部变量</span><br><span class="line">this.() // 调用本类的某个方法</span><br><span class="line">this() // 表示调用本类构造方法</span><br></pre></td></tr></table></figure>
<p><strong>super 表示父类对象，是指向父类的引用。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">super.属性 // 表示父类对象中的成员变量</span><br><span class="line">super.方法() // 表示父类对象中定义的方法</span><br><span class="line">super() // 表示调用父类构造方法</span><br></pre></td></tr></table></figure>
<p><strong>构造方法</strong></p>
<p>构造方法是一种特殊的方法，它是一个与类同名的方法。在继承中构造方法是一种比较特殊的方法（比如不能继承），所以要了解和学习在继承中构造方法的规则和要求。</p>
<p>继承中的构造方法有以下几点需要注意：</p>
<p><strong>父类的构造方法不能被继承：</strong></p>
<p>因为构造方法语法是与类同名，而继承则不更改方法名，如果子类继承父类的构造方法，那明显与构造方法的语法冲突了。比如 Father 类的构造方法名为 Father()，Son 类如果继承 Father 类的构造方法 Father()，那就和构造方法定义：<strong>构造方法与类同名冲突了</strong>，所以在子类中不能继承父类的构造方法，但子类会调用父类的构造方法。</p>
<p><strong>子类的构造过程必须调用其父类的构造方法：</strong></p>
<p>Java 虚拟机构造子类对象前会先构造父类对象，父类对象构造完成之后再来构造子类特有的属性，这被称为内存叠加。而 Java 虚拟机构造父类对象会执行父类的构造方法，所以子类构造方法必须调用 super()即父类的构造方法。就比如一个简单的继承案例应该这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">    public String name;</span><br><span class="line">    </span><br><span class="line">    public A() &#123;//无参构造</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public A (String name)&#123;//有参构造</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A&#123;</span><br><span class="line">    public B() &#123;//无参构造</span><br><span class="line">       super();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public B(String name) &#123;//有参构造</span><br><span class="line">      //super();</span><br><span class="line">       super(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>如果子类的构造方法中没有显示地调用父类构造方法，则系统默认调用父类无参数的构造方法。</strong></p>
<p>你可能有时候在写继承的时候子类并没有使用 super()调用，程序依然没问题，其实这样是为了节省代码，系统执行时会自动添加父类的无参构造方式，如果不信的话我们对上面的类稍作修改执行：</p>
<p><img src="\assets\note\image-20231009105905569.png" alt="image-20231009105905569"></p>
<p><strong>方法重写(Override)</strong></p>
<p>方法重写也就是子类中出现和父类中一模一样的方法(包括返回值类型，方法名，参数列表)，它建立在继承的基础上。你可以理解为方法的<strong>外壳不变，但是核心内容重写。</strong></p>
<p>在这里提供一个简单易懂的方法重写案例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class E1&#123;</span><br><span class="line">    public void doA(int a)&#123;</span><br><span class="line">        System.out.println(&quot;这是父类的方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class E2 extends E1&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void doA(int a) &#123;</span><br><span class="line">        System.out.println(&quot;我重写父类方法，这是子类的方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 @Override 注解显示声明该方法为注解方法，可以帮你检查重写方法的语法正确性，当然如果不加也是可以的，但建议加上。</p>
<p><strong>方法重载(Overload)</strong></p>
<p>如果有两个方法的<strong>方法名相同，但参数不一致</strong>，那么可以说一个方法是另一个方法的重载。</p>
<p>重载可以通常理解为完成同一个事情的方法名相同，但是参数列表不同其他条件也可能不同。一个简单的方法重载的例子，类 E3 中的 add()方法就是一个重载方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class E3&#123;</span><br><span class="line">    public int add(int a,int b)&#123;</span><br><span class="line">        return a+b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public double add(double a,double b) &#123;</span><br><span class="line">        return a+b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int add(int a,int b,int c) &#123;</span><br><span class="line">        return a+b+c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>06、继承与修饰符</strong></p>
<p>Java 修饰符的作用就是对类或类成员进行修饰或限制，每个修饰符都有自己的作用，而在继承中可能有些特殊修饰符使得被修饰的属性或方法不能被继承，或者继承需要一些其他的条件。</p>
<p>Java 语言提供了很多修饰符，修饰符用来定义类、方法或者变量，通常放在语句的最前端。主要分为以下两类：</p>
<ul>
<li>访问权限修饰符，也就是 public、private、protected 等</li>
<li>非访问修饰符，也就是 static、final、abstract 等</li>
</ul>
<p><strong>访问修饰符</strong></p>
<p>Java 子类重写继承的方法时，<strong>不可以降低方法的访问权限，子类继承父类的访问修饰符作用域不能比父类小</strong>，也就是更加开放，假如父类是 protected 修饰的，其子类只能是 protected 或者 public，绝对不能是default(默认的访问范围)或者 private。所以在继承中需要重写的方法不能使用 private 修饰词修饰。</p>
<p>如果还是不太清楚可以看几个小案例就很容易搞懂，写一个 A1 类中用四种修饰词实现四个方法，用子类 A2继承 A1，重写 A1 方法时候你就会发现父类私有方法不能重写，非私有方法重写使用的修饰符作用域不能变小(大于等于)。</p>
<p><img src="\assets\note\image-20231009110222959.png" alt="image-20231009110222959"></p>
<p>正确的案例应该为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class A1 &#123;</span><br><span class="line">    private void doA()&#123; &#125;</span><br><span class="line">    void doB()&#123;&#125;//default</span><br><span class="line">    protected void doC()&#123;&#125;</span><br><span class="line">    public void doD()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class A2 extends A1&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void doB() &#123; &#125;//继承子类重写的方法访问修饰符权限可扩大</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    protected void doC() &#123; &#125;//继承子类重写的方法访问修饰符权限可和父类一致</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void doD() &#123; &#125;//不可用protected或者default修饰</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还要注意的是，<strong>继承当中子类抛出的异常必须是父类抛出的异常或父类抛出异常的子异常。</strong>下面的一个案例四种方法测试可以发现子类方法的异常不可大于父类对应方法抛出异常的范围。</p>
<p><img src="\assets\note\image-20231009110517889.png" alt="image-20231009110517889"></p>
<p>正确的案例应该为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class B1&#123;</span><br><span class="line">    public void doA() throws Exception&#123;&#125;</span><br><span class="line">    public void doB() throws Exception&#123;&#125;</span><br><span class="line">    public void doC() throws IOException&#123;&#125;</span><br><span class="line">    public void doD() throws IOException&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B2 extends B1&#123;</span><br><span class="line">    //异常范围和父类可以一致</span><br><span class="line">    @Override</span><br><span class="line">    public void doA() throws Exception &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    //异常范围可以比父类更小</span><br><span class="line">    @Override</span><br><span class="line">    public void doB() throws IOException &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    //异常范围 不可以比父类范围更大</span><br><span class="line">    @Override</span><br><span class="line">    public void doC() throws IOException &#123; &#125;//不可抛出Exception等比IOException更大的异常</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void doD() throws IOException &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>非访问修饰符</strong></p>
<p>访问修饰符用来控制访问权限，而非访问修饰符每个都有各自的作用，下面针对 static、final、abstract 修饰符进行介绍。</p>
<p><strong>static 修饰符</strong></p>
<p>static 翻译为“静态的”，能够与变量，方法和类一起使用，<strong>称为静态变量，静态方法(也称为类变量、类方法)。</strong>如果在一个类中使用 static 修饰变量或者方法的话，它们<strong>可以直接通过类访问，不需要创建一个类的对象来访问成员。</strong></p>
<p>我们在设计类的时候可能会使用静态方法，有很多工具类比如 Math ， Arrays 等类里面就写了很多静态方法。</p>
<p>可以看以下的案例证明上述规则：</p>
<p><img src="\assets\note\image-20231009110655864.png" alt="image-20231009110655864"></p>
<p>源代码为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class C1&#123;</span><br><span class="line">    public  int a;</span><br><span class="line">    public C1()&#123;&#125;</span><br><span class="line">   // public static C1()&#123;&#125;// 构造方法不允许被声明为static</span><br><span class="line">    public static void doA() &#123;&#125;</span><br><span class="line">    public static void doB() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C2 extends C1&#123;</span><br><span class="line">    public static  void doC()//静态方法中不存在当前对象，因而不能使用this和super。</span><br><span class="line">    &#123;</span><br><span class="line">        //System.out.println(super.a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void doA()&#123;&#125;//静态方法能被静态方法重写</span><br><span class="line">   // public void doB()&#123;&#125;//静态方法不能被非静态方法重写</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>final 修饰符</strong></p>
<p>final 变量：</p>
<ul>
<li>final 表示”最后的、最终的”含义，<strong>变量一旦赋值后，不能被重新赋值。</strong>被 final 修饰的实例变量必须显式指定初始值(即不能只声明)。final 修饰符通常和 static 修饰符一起使用来创建类常量。</li>
</ul>
<p>final 方法：</p>
<ul>
<li><strong>父类中的 final 方法可以被子类继承，但是不能被子类重写。</strong>声明 final 方法的主要目的是防止该方法的内容被修改。</li>
</ul>
<p>final 类：</p>
<ul>
<li><strong>final 类不能被继承</strong>，没有类能够继承 final 类的任何特性。</li>
</ul>
<p>所以无论是变量、方法还是类被 final 修饰之后，都有代表最终、最后的意思。内容无法被修改。</p>
<p><strong>abstract 修饰符</strong></p>
<p>abstract 英文名为“抽象的”，主要用来修饰类和方法，称为抽象类和抽象方法。</p>
<p><strong>抽象方法：</strong>有很多不同类的方法是相似的，但是具体内容又不太一样，所以我们只能抽取他的声明，没有具体的方法体，即抽象方法可以表达概念但无法具体实现。</p>
<p><strong>抽象类：有抽象方法的类必须是抽象类</strong>，抽象类可以表达概念但是无法构造实体的类。</p>
<p><img src="\assets\note\image-20231009110939662.png" alt="image-20231009110939662"></p>
<p>比如我们可以这样设计一个 People 抽象类以及一个抽象方法，在子类中具体完成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">abstract class People&#123;</span><br><span class="line">    public abstract void sayHello();//抽象方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Chinese extends People&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void sayHello() &#123;//实现抽象方法</span><br><span class="line">        System.out.println(&quot;你好&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Japanese extends People&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void sayHello() &#123;//实现抽象方法</span><br><span class="line">        System.out.println(&quot;口你七哇&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class American extends People&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void sayHello() &#123;//实现抽象方法</span><br><span class="line">        System.out.println(&quot;hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>07、Object 类和转型</strong></p>
<p>提到 Java 继承，不得不提及所有类的根类：Object(java.lang.Object)类，如果一个类没有显式声明它的父类（即没有写 extends xx），那么默认这个类的父类就是 Object 类，任何类都可以使用 Object 类的方法，创建的类也可和 Object 进行向上、向下转型，所以 Object 类是掌握和理解继承所必须的知识点。</p>
<p>Java 向上和向下转型在 Java 中运用很多，也是建立在继承的基础上，所以 Java 转型也是掌握和理解继承所必须的知识点。</p>
<p><strong>Object 类概述</strong></p>
<ol>
<li>Object 是类层次结构的根类，所有的类都隐式的继承自 Object 类。</li>
<li>Java 中，所有的对象都拥有 Object 的默认方法。</li>
<li>Object 类有一个构造方法，并且是无参构造方法。</li>
</ol>
<p>Object 是 Java 所有类的父类，是整个类继承结构的顶端，也是最抽象的一个类。</p>
<p>像 toString()、equals()、hashCode()、wait()、notify()、getClass()等都是 Object 的方法。你以后可能会经常碰到，但其中遇到更多的就是 toString()方法和 equals()方法，我们经常需要重写这两种方法满足我们的使用需求。</p>
<p>toString()方法表示返回该对象的字符串，由于各个对象构造不同所以需要重写，如果不重写的话默认返回 类名@hashCode 格式。</p>
<p>如果重写 toString()方法后直接调用 toString()方法就可以返回我们自定义的该类转成字符串类型的内容输出，而不需要每次都手动的拼凑成字符串内容输出，大大简化输出操作。</p>
<p>equals()方法主要比较两个对象是否相等，因为对象的相等不一定非要严格要求两个对象地址上的相同，有时内容上的相同我们就会认为它相等，比如 String 类就重写了euqals()方法，通过字符串的内容比较是否相等。</p>
<p><img src="\assets\note\image-20231009111259886.png" alt="image-20231009111259886"></p>
<p><strong>向上转型</strong></p>
<p><strong>向上转型 : </strong>通过子类对象(小范围)实例化父类对象(大范围)，这种属于自动转换。用一张图就能很好地表示向上转型的逻辑：</p>
<p><img src="\assets\note\image-20231009111323351.png" alt="image-20231009111323351"></p>
<p>父类引用变量指向子类对象后，只能使用父类已声明的方法，但方法如果被重写会执行子类的方法，如果方法未被重写那么将执行父类的方法。</p>
<p><strong>向下转型</strong></p>
<p><strong>向下转型 : </strong>通过父类对象(大范围)实例化子类对象(小范围)，在书写上父类对象需要加括号 () 强制转换为子类类型。但父类引用变量实际引用必须是子类对象才能成功转型，这里也用一张图就能很好表示向下转型的逻辑：</p>
<p><img src="\assets\note\image-20231009111414766.png" alt="image-20231009111414766"></p>
<p>子类引用变量指向父类引用变量指向的对象后(一个 Son()对象)，就完成向下转型，就可以调用一些子类特有而父类没有的方法 。</p>
<p>在这里写一个向上转型和向下转型的案例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object object=new Integer(666);//向上转型</span><br><span class="line">Integer i=(Integer)object;//向下转型Object-&gt;Integer，object的实质还是指向Integer</span><br><span class="line">String str=(String)object;//错误的向下转型，虽然编译器不会报错但是运行会报错</span><br></pre></td></tr></table></figure>
<p><strong>08、子父类初始化顺序</strong></p>
<p>在 Java 继承中，父子类初始化先后顺序为：</p>
<ol>
<li>父类中静态成员变量和静态代码块</li>
<li>子类中静态成员变量和静态代码块</li>
<li>父类中普通成员变量和代码块，父类的构造方法</li>
<li>子类中普通成员变量和代码块，子类的构造方法</li>
</ol>
<p>总的来说，就是<strong>静态&gt;非静态，父类&gt;子类，非构造方法&gt;构造方法。</strong>同一类别（例如普通变量和普通代码块）成员变量和代码块执行从前到后，需要注意逻辑。</p>
<p>这个也不难理解，静态变量也称类变量，可以看成一个全局变量，静态成员变量和静态代码块在类加载的时候就初始化，而非静态变量和代码块在对象创建的时候初始化。所以静态快于非静态初始化。</p>
<p>而在创建子类对象的时候需要先创建父类对象，所以父类优先于子类。</p>
<p>而在调用构造方法的时候，是对成员变量进行一些初始化操作，所以普通成员变量和代码块优于构造方法执行。</p>
<p>至于更深层次为什么这个顺序，就要更深入了解 JVM 执行流程啦。下面一个测试代码为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Father&#123;</span><br><span class="line">    public Father() &#123;</span><br><span class="line">        System.out.println(++b1+&quot;父类构造方法&quot;);</span><br><span class="line">    &#125;//父类构造方法 第四</span><br><span class="line">    </span><br><span class="line">    static int a1=0;//父类static 第一 注意顺序</span><br><span class="line">    </span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(++a1+&quot;父类static&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int b1=a1;//父类成员变量和代码块 第三</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(++b1+&quot;父类代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Son extends Father&#123;</span><br><span class="line">    public Son() &#123;</span><br><span class="line">        System.out.println(++b2+&quot;子类构造方法&quot;);</span><br><span class="line">    &#125;//子类构造方法 第六</span><br><span class="line">    </span><br><span class="line">    static &#123;//子类static第二步</span><br><span class="line">        System.out.println(++a1+&quot;子类static&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int b2=b1;//子类成员变量和代码块 第五</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(++b2 + &quot;子类代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class test9 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Son son=new Son();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<p><img src="\assets\note\image-20231009111730506.png" alt="image-20231009111730506"></p>
<p><strong>3）多态</strong></p>
<p>Java 多态是指在面向对象编程中，同一个类的对象在不同情况下表现出不同的行为和状态。</p>
<ul>
<li>子类可以继承父类的属性和方法，子类对象可以直接使用父类中的方法和变量。</li>
<li>子类可以对从父类继承的方法进行重新实现，使得子类对象调用这个方法时表现出不同的行为。</li>
<li>可以将子类对象赋给父类类型的变量，这样就可以通过父类类型的变量调用子类中重写的方法，实现多态。</li>
</ul>
<p>“很枯燥，有没有？再具体的分析一下。”</p>
<p><strong>01、多态是什么</strong></p>
<p>在我刻板的印象里，西游记里的那段孙悟空和二郎神的精彩对战就能很好的解释“多态”这个词：一个孙悟空，能七十二变；一个二郎神，也能七十二变；他们都可以变成不同的形态，但只需要悄悄地喊一声“变”。</p>
<p>Java的多态是什么呢？其实就是一种能力——同一个行为具有不同的表现形式；换句话说就是，执行一段代码，Java 在运行时能根据对象的不同产生不同的结果。和孙悟空和二郎神都只需要喊一声“变”，然后就变了，并且每次变得还不一样；一个道理。</p>
<p>多态的前提条件有三个：</p>
<ul>
<li>子类继承父类</li>
<li>子类覆盖父类的方法</li>
<li>父类引用指向子类对象</li>
</ul>
<p>多态的一个简单应用，来看程序清单1-1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//子类继承父类</span><br><span class="line">public class Wangxiaoer extends Wanger &#123;</span><br><span class="line">    public void write() &#123; // 子类覆盖父类方法</span><br><span class="line">        System.out.println(&quot;记住仇恨，表明我们要奋发图强的心智&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 父类引用指向子类对象</span><br><span class="line">        Wanger[] wangers = &#123; new Wanger(), new Wangxiaoer() &#125;;</span><br><span class="line">        for (Wanger wanger : wangers) &#123;</span><br><span class="line">            // 对象是王二的时候输出：勿忘国耻</span><br><span class="line">            // 对象是王小二的时候输出：记住仇恨，表明我们要奋发图强的心智</span><br><span class="line">            wanger.write();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Wanger &#123;</span><br><span class="line">    public void write() &#123;</span><br><span class="line">        System.out.println(&quot;勿忘国耻&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>02、多态与后期绑定</strong></p>
<p>现在，我们来思考一个问题：程序清单1-1在执行 wanger.write() 时，由于编译器只有一个 Wanger 引用，它怎么知道究竟该调用父类 Wanger 的 write() 方法，还是子类 Wangxiaoer 的 write() 方法呢？</p>
<p>答案是在运行时根据对象的类型进行后期绑定，编译器在编译阶段并不知道对象的类型，但是Java的方法调用机制能找到正确的方法体，然后执行出正确的结果。</p>
<p>多态机制提供的一个重要的好处程序具有良好的扩展性。来看程序清单2-1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//子类继承父类</span><br><span class="line">public class Wangxiaoer extends Wanger &#123;</span><br><span class="line">    public void write() &#123; // 子类覆盖父类方法</span><br><span class="line">        System.out.println(&quot;记住仇恨，表明我们要奋发图强的心智&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        System.out.println(&quot;我不喜欢读书，我就喜欢吃&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 父类引用指向子类对象</span><br><span class="line">        Wanger[] wangers = &#123; new Wanger(), new Wangxiaoer() &#125;;</span><br><span class="line">        for (Wanger wanger : wangers) &#123;</span><br><span class="line">            // 对象是王二的时候输出：勿忘国耻</span><br><span class="line">            // 对象是王小二的时候输出：记住仇恨，表明我们要奋发图强的心智</span><br><span class="line">            wanger.write();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Wanger &#123;</span><br><span class="line">    public void write() &#123;</span><br><span class="line">        System.out.println(&quot;勿忘国耻&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void read() &#123;</span><br><span class="line">        System.out.println(&quot;每周读一本好书&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在程序清单 2-1 中，我们在 Wanger 类中增加了 read() 方法，在 Wangxiaoer 类中增加了eat()方法，但这丝毫不会影响到 write() 方法的调用。write() 方法忽略了周围代码发生的变化，依然正常运行。这让我想起了金庸《倚天屠龙记》里九阳真经的口诀：“他强由他强，清风拂山岗；他横由他横，明月照大江。”</p>
<p>多态的这个优秀的特性，让我们在修改代码的时候不必过于紧张，因为多态是一项让程序员“将改变的与未改变的分离开来”的重要特性。</p>
<p><strong>03、多态与构造方法</strong></p>
<p>在构造方法中调用多态方法，会产生一个奇妙的结果，我们来看程序清单3-1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class Wangxiaosan extends Wangsan &#123;</span><br><span class="line">    private int age = 3;</span><br><span class="line">    public Wangxiaosan(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">        System.out.println(&quot;王小三的年龄：&quot; + this.age);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void write() &#123; // 子类覆盖父类方法</span><br><span class="line">        System.out.println(&quot;我小三上幼儿园的年龄是：&quot; + this.age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Wangxiaosan(4);</span><br><span class="line">//      上幼儿园之前</span><br><span class="line">//      我小三上幼儿园的年龄是：0</span><br><span class="line">//      上幼儿园之后</span><br><span class="line">//      王小三的年龄：4</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Wangsan &#123;</span><br><span class="line">    Wangsan () &#123;</span><br><span class="line">        System.out.println(&quot;上幼儿园之前&quot;);</span><br><span class="line">        write();</span><br><span class="line">        System.out.println(&quot;上幼儿园之后&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void write() &#123;</span><br><span class="line">        System.out.println(&quot;老子上幼儿园的年龄是3岁半&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从输出结果上看，是不是有点诧异？明明在创建 Wangxiaosan 对象的时候，年龄传递的是 4，但输出结果既不是“老子上幼儿园的年龄是 3 岁半”，也不是“我小三上幼儿园的年龄是：4”。</p>
<p>为什么？</p>
<p>因为在创建子类对象时，会先去调用父类的构造方法，而父类构造方法中又调用了被子类覆盖的多态方法，由于父类并不清楚子类对象中的属性值是什么，于是把int类型的属性暂时初始化为 0，然后再调用子类的构造方法（子类构造方法知道王小二的年龄是 4）。</p>
<p><strong>04、多态与向下转型</strong></p>
<p>向下转型是指将父类引用强转为子类类型；这是不安全的，因为有的时候，父类引用指向的是父类对象，向下转型就会抛出 ClassCastException，表示类型转换失败；但如果父类引用指向的是子类对象，那么向下转型就是成功的。</p>
<p>来看程序清单4-1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Wangxiaosi extends Wangsi &#123;</span><br><span class="line">    public void write() &#123;</span><br><span class="line">        System.out.println(&quot;记住仇恨，表明我们要奋发图强的心智&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        System.out.println(&quot;我不喜欢读书，我就喜欢吃&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Wangsi[] wangsis = &#123; new Wangsi(), new Wangxiaosi() &#125;;</span><br><span class="line">        // wangsis[1]能够向下转型</span><br><span class="line">        ((Wangxiaosi) wangsis[1]).write();</span><br><span class="line">        // wangsis[0]不能向下转型</span><br><span class="line">        ((Wangxiaosi)wangsis[0]).write();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Wangsi &#123;</span><br><span class="line">    public void write() &#123;</span><br><span class="line">        System.out.println(&quot;勿忘国耻&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void read() &#123;</span><br><span class="line">        System.out.println(&quot;每周读一本好书&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“好了，三妹，到此为止，我们就将 Java 的三大特性，封装继承多态全部讲完了，希望你能重新把他们梳理一下。”</p>
<p>“好的，二哥，遵命。”三妹顽皮地笑了。</p>
<p><strong>4）小结</strong></p>
<p>好啦，三妹，本次继承就介绍到这里啦，Java 面向对象三大特征之一继承——优秀的你已经掌握。</p>
<p>封装：是对类的封装，封装是对类的属性和方法进行封装，只对外暴露方法而不暴露具体使用细节，所以我们一般设计类成员变量时候大多设为私有而通过一些 get、set 方法去读写。</p>
<p>继承：子类继承父类，即“子承父业”，子类拥有父类除私有的所有属性和方法，自己还能在此基础上拓展自己新的属性和方法。主要目的是复用代码。</p>
<p>多态：多态是同一个行为具有多个不同表现形式或形态的能力。即一个父类可能有若干子类，各子类实现父类方法有多种多样，调用父类方法时，父类引用变量指向不同子类实例而执行不同方法，这就是所谓父类方法是多态的。</p>
<p>最后送你一张图捋一捋其中的关系吧。</p>
<p><img src="\assets\note\image-20231009141542115.png" alt="image-20231009141542115"></p>
<h2 id="3-14-Java-this和super关键字"><a href="#3-14-Java-this和super关键字" class="headerlink" title="3.14 Java this和super关键字"></a>3.14 Java this和super关键字</h2><p>“今天来学习一下 Java 中的 this 关键字吧。”喝了一口农夫山泉后，我对三妹说。</p>
<p>“this 关键字有很多种用法，其中最常用的一个是，它可以作为引用变量，指向当前对象。”我面带着朴实无华的微笑继续说，“除此之外， this 关键字还可以完成以下工作。”</p>
<ul>
<li>调用当前类的方法；</li>
<li>this() 可以调用当前类的构造方法；</li>
<li>this 可以作为参数在方法中传递；</li>
<li>this 可以作为参数在构造方法中传递；</li>
<li>this 可以作为方法的返回值，返回当前类的对象。</li>
</ul>
<p><strong>01、 指向当前对象</strong></p>
<p>“三妹，来看下面这段代码。”话音刚落，我就在键盘上噼里啪啦一阵敲。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class WithoutThisStudent &#123;</span><br><span class="line">    String name;</span><br><span class="line">    int age;</span><br><span class="line">    </span><br><span class="line">    WithoutThisStudent(String name, int age) &#123;</span><br><span class="line">        name = name;</span><br><span class="line">        age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void out() &#123;</span><br><span class="line">        System.out.println(name+&quot; &quot; + age);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        WithoutThisStudent s1 = new WithoutThisStudent(&quot;沉默二&quot;, 18);</span><br><span class="line">        WithoutThisStudent s2 = new WithoutThisStudent(&quot;沉默三&quot;, 16);</span><br><span class="line">        s1.out();</span><br><span class="line">        s2.out();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“在上面的例子中，构造方法的参数名和实例变量名相同，由于没有使用 this 关键字，所以无法为实例变量赋值。”我抬起右手的食指，指着屏幕上的 name 和 age 对着三妹说。</p>
<p>“来看一下程序的输出结果。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">null 0</span><br><span class="line">null 0</span><br></pre></td></tr></table></figure>
<p>“从结果中可以看得出来，尽管创建对象的时候传递了参数，但实例变量并没有赋值。这是因为如果构造方法中没有使用 this 关键字的话，name 和 age 指向的并不是实例变量而是参数本身。”我把脖子扭向右侧，看着三妹说。</p>
<p>“那怎么解决这个问题呢？哥。”三妹着急地问。</p>
<p>“如果参数名和实例变量名产生了冲突…..”我正准备给出答案，三妹打断了我。</p>
<p>“难道用 this 吗？”三妹脱口而出。</p>
<p>“哇，越来越棒了呀，你。”我感觉三妹在学习 Java 这条道路上逐渐有了自己主动思考的意愿。</p>
<p>“是的，来看加上 this 关键字后的代码。”</p>
<p>安静的屋子里又响起了一阵噼里啪啦的键盘声。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class WithThisStudent &#123;</span><br><span class="line">    String name;</span><br><span class="line">    int age;</span><br><span class="line">    WithThisStudent(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    void out() &#123;</span><br><span class="line">        System.out.println(name+&quot; &quot; + age);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        WithThisStudent s1 = new WithThisStudent(&quot;沉默二&quot;, 18);</span><br><span class="line">        WithThisStudent s2 = new WithThisStudent(&quot;沉默三&quot;, 16);</span><br><span class="line">        s1.out();</span><br><span class="line">        s2.out();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“再来看一下程序的输出结果。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">沉默二 18</span><br><span class="line">沉默三 16</span><br></pre></td></tr></table></figure>
<p>“这次，实例变量有值了，在构造方法中， this.xxx 指向的就是实例变量，而不再是参数本身了。”我慢吞吞地说着，“当然了，如果参数名和实例变量名不同的话，就不必使用 this 关键字，但我建议使用 this 关键字，这样的代码更有意义。”</p>
<p><strong>02、调用当前类的方法</strong></p>
<p>“仔细听，三妹，看我敲键盘的速度是不是够快。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class InvokeCurrentClassMethod &#123;</span><br><span class="line">    void method1() &#123;&#125;</span><br><span class="line">    void method2() &#123;</span><br><span class="line">        method1();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new InvokeCurrentClassMethod().method1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“仔细瞧，三妹，上面这段代码中没有见到 this 关键字吧？”我面带着神秘的微笑，准备给三妹变个魔术。</p>
<p>“确实没有，哥，我确认过了。”</p>
<p>“那接下来，神奇的事情就要发生了。”我突然感觉刘谦附身了。</p>
<p>我快速的在 classes 目录下找到 InvokeCurrentClassMethod.class 文件，然后双击打开（IDEA 默认会使用FernFlower 打开字节码文件）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class InvokeCurrentClassMethod &#123;</span><br><span class="line">    public InvokeCurrentClassMethod() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void method1() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void method2() &#123;</span><br><span class="line">        this.method1();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        (new InvokeCurrentClassMethod()).method1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“瞪大眼睛仔细瞧，三妹， this 关键字是不是出现了？”</p>
<p>“哇，真的呢，好神奇啊！”三妹为了配合我的演出，也是十二分的卖力。</p>
<p>“我们可以在一个类中使用 this 关键字来调用另外一个方法，如果没有使用的话，编译器会自动帮我们加上。”我对自己深厚的编程功底充满自信，“在源代码中， method2() 在调用 method1() 的时候并没有使用this 关键字，但通过反编译后的字节码可以看得到。”</p>
<p><strong>03、调用当前类的构造方法</strong></p>
<p>“再来看下面这段代码。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class InvokeConstrutor &#123;</span><br><span class="line">    InvokeConstrutor() &#123;</span><br><span class="line">        System.out.println(&quot;hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    InvokeConstrutor(int count) &#123;</span><br><span class="line">        this();</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        InvokeConstrutor invokeConstrutor = new InvokeConstrutor(10);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“在有参构造方法 InvokeConstrutor(int count) 中，使用了 this() 来调用无参构造方法InvokeConstrutor() 。”这次，我换成了左手的食指，指着屏幕对三妹说，“ this() 可用于调用当前类的构造方法——构造方法可以重用了。”</p>
<p>“来看一下输出结果。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>“真的啊，无参构造方法也被调用了，所以程序输出了 hello。”三妹看到输出结果后不假思索地说。</p>
<p>“也可以在无参构造方法中使用 this() 并传递参数来调用有参构造方法。”话音没落，我就在键盘上敲了起来，“来看下面这段代码。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class InvokeParamConstrutor &#123;</span><br><span class="line">    InvokeParamConstrutor() &#123;</span><br><span class="line">        this(10);</span><br><span class="line">        System.out.println(&quot;hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    InvokeParamConstrutor(int count) &#123;</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        InvokeParamConstrutor invokeConstrutor = new InvokeParamConstrutor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“再来看一下程序的输出结果。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>“不过，需要注意的是， this() 必须放在构造方法的第一行，否则就报错了。”</p>
<p><img src="\assets\note\image-20231009142331927.png" alt="image-20231009142331927"></p>
<p><strong>04、作为参数在方法中传递</strong></p>
<p>“来看下面这段代码。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class ThisAsParam &#123;</span><br><span class="line">    void method1(ThisAsParam p) &#123;</span><br><span class="line">        System.out.println(p);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void method2() &#123;</span><br><span class="line">        method1(this);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ThisAsParam thisAsParam = new ThisAsParam();</span><br><span class="line">        System.out.println(thisAsParam);</span><br><span class="line">        thisAsParam.method2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“ this 关键字可以作为参数在方法中传递，此时，它指向的是当前类的对象。”一不小心，半个小时过去了，我感到嗓子冒烟，于是赶紧又喝了一口水，润润嗓子后继续说道。</p>
<p>“来看一下输出结果，你就明白了，三妹。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.itwanger.twentyseven.ThisAsParam@77459877</span><br><span class="line">com.itwanger.twentyseven.ThisAsParam@77459877</span><br></pre></td></tr></table></figure>
<p>“ method2() 调用了 method1() ，并传递了参数 this， method1() 中打印了当前对象的字符串。 main()方法中打印了 thisAsParam 对象的字符串。从输出结果中可以看得出来，两者是同一个对象。”</p>
<p><strong>05、作为参数在构造方法中传递</strong></p>
<p>“继续来看代码。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class ThisAsConstrutorParam &#123;</span><br><span class="line">    int count = 10;</span><br><span class="line">    </span><br><span class="line">    ThisAsConstrutorParam() &#123;</span><br><span class="line">        Data data = new Data(this);</span><br><span class="line">        data.out();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new ThisAsConstrutorParam();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Data &#123;</span><br><span class="line">    ThisAsConstrutorParam param;</span><br><span class="line">    </span><br><span class="line">    Data(ThisAsConstrutorParam param) &#123;</span><br><span class="line">        this.param = param;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void out() &#123;</span><br><span class="line">        System.out.println(param.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“在构造方法 ThisAsConstrutorParam() 中，我们使用 this 关键字作为参数传递给了 Data 对象，它其实指向的就是 new ThisAsConstrutorParam() 这个对象。”</p>
<p>“ this 关键字也可以作为参数在构造方法中传递，它指向的是当前类的对象。当我们需要在多个类中使用一个对象的时候，这非常有用。”</p>
<p>“来看一下输出结果。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure>
<p><strong>06、作为方法的返回值</strong></p>
<p>“需要休息会吗？三妹”</p>
<p>“没事的，哥，我的注意力还是很集中的，你继续讲吧。”</p>
<p>“好的，那来继续看代码。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ThisAsMethodResult &#123;</span><br><span class="line">    ThisAsMethodResult getThisAsMethodResult() &#123;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void out() &#123;</span><br><span class="line">        System.out.println(&quot;hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new ThisAsMethodResult().getThisAsMethodResult().out();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“ getThisAsMethodResult() 方法返回了 this 关键字，指向的就是 new ThisAsMethodResult() 这个对象，所以可以紧接着调用 out() 方法——达到了链式调用的目的，这也是 this 关键字非常经典的一种用法。”</p>
<p>“链式调用的形式在 JavaScript 代码更加常见。”为了向三妹证实这一点，我打开了 jQuery 的源码。</p>
<p>“原来这么多链式调用啊！”三妹感叹到。</p>
<p>“是的。”我点点头，然后指着 getThisAsMethodResult() 方法的返回值对三妹说，“需要注意的是， this关键字作为方法的返回值的时候，方法的返回类型为类的类型。”</p>
<p>“来看一下输出结果。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br></pre></td></tr></table></figure>
<p>“那么，关于 this 关键字的介绍，就到此为止了。”我活动了一下僵硬的脖子后，对三妹说，“如果你学习劲头还可以的话，我们顺带把 super 关键字捎带着过一下，怎么样？”</p>
<p>“不用了吧，听说 super 关键字更简单，我自己看看就行了，不用你讲了！”</p>
<p>“不不不，三妹啊，你得假装听一下，不然我怎么向读者们交差。”</p>
<p>“噢噢噢噢。”三妹意味深长地笑了。</p>
<p><strong>07、super 关键字</strong></p>
<p>“super 关键字的用法主要有三种。”</p>
<ul>
<li>指向父类对象；</li>
<li>调用父类的方法；</li>
<li>super() 可以调用父类的构造方法。</li>
</ul>
<p>“其实和 this 有些相似，只不过用意不大相同。”我端起水瓶，咕咚咕咚又喝了几大口，好渴。“每当创建一个子类对象的时候，也会隐式的创建父类对象，由 super 关键字引用。”</p>
<p>“如果父类和子类拥有同样名称的字段，super 关键字可以用来访问父类的同名字段。”</p>
<p>“来看下面这段代码。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class ReferParentField &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Dog().printColor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Animal &#123;</span><br><span class="line">    String color = &quot;白色&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">    String color = &quot;黑色&quot;;</span><br><span class="line">    </span><br><span class="line">    void printColor() &#123;</span><br><span class="line">        System.out.println(color);</span><br><span class="line">        System.out.println(super.color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“父类 Animal 中有一个名为 color 的字段，子类 Dog 中也有一个名为 color 的字段，子类的 printColor()方法中，通过 super 关键字可以访问父类的 color。”</p>
<p>“来看一下输出结果。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">黑色</span><br><span class="line">白色</span><br></pre></td></tr></table></figure>
<p>“当子类和父类的方法名相同时，可以使用 super 关键字来调用父类的方法。换句话说，super 关键字可以用于方法重写时访问到父类的方法。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class ReferParentMethod &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Dog().work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Animal &#123;</span><br><span class="line">    void eat() &#123;</span><br><span class="line">        System.out.println(&quot;吃...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">    @Override</span><br><span class="line">    void eat() &#123;</span><br><span class="line">        System.out.println(&quot;吃...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void bark() &#123;</span><br><span class="line">        System.out.println(&quot;汪汪汪...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void work() &#123;</span><br><span class="line">        super.eat();</span><br><span class="line">        bark();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>“瞧，三妹。父类 Animal 和子类 Dog 中都有一个名为 eat() 的方法，通过 super.eat() 可以访问到父类的 eat() 方法。”</p>
<p>等三妹在自我消化的时候，我在键盘上又敲完了一串代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class ReferParentConstructor &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Dog();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Animal &#123;</span><br><span class="line">    Animal()&#123;</span><br><span class="line">        System.out.println(&quot;动物来了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">    Dog() &#123;</span><br><span class="line">        super();</span><br><span class="line">        System.out.println(&quot;狗狗来了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“子类 Dog 的构造方法中，第一行代码为 super() ，它就是用来调用父类的构造方法的。”</p>
<p>“来看一下输出结果。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">动物来了</span><br><span class="line">狗狗来了</span><br></pre></td></tr></table></figure>
<p>“当然了，在默认情况下， super() 是可以省略的，编译器会主动去调用父类的构造方法。也就是说，子类即使不使用 super() 主动调用父类的构造方法，父类的构造方法仍然会先执行。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class ReferParentConstructor &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Dog();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Animal &#123;</span><br><span class="line">    Animal()&#123;</span><br><span class="line">        System.out.println(&quot;动物来了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">    Dog() &#123;</span><br><span class="line">        System.out.println(&quot;狗狗来了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“输出结果和之前一样。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">动物来了</span><br><span class="line">狗狗来了</span><br></pre></td></tr></table></figure>
<p>“ super() 也可以用来调用父类的有参构造方法，这样可以提高代码的可重用性。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    int id;</span><br><span class="line">    String name;</span><br><span class="line">    </span><br><span class="line">    Person(int id, String name) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Emp extends Person &#123;</span><br><span class="line">    float salary;</span><br><span class="line">    </span><br><span class="line">    Emp(int id, String name, float salary) &#123;</span><br><span class="line">        super(id, name);</span><br><span class="line">        this.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void display() &#123;</span><br><span class="line">        System.out.println(id + &quot; &quot; + name + &quot; &quot; + salary);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class CallParentParamConstrutor &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Emp(1, &quot;沉默王二&quot;, 20000f).display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“Emp 类继承了 Person 类，也就继承了 id 和 name 字段，当在 Emp 中新增了 salary 字段后，构造方法中就可以使用 super(id, name) 来调用父类的有参构造方法。”</p>
<p>“来看一下输出结果。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 沉默王二 20000.0</span><br></pre></td></tr></table></figure>
<p>三妹点了点头，所有所思。</p>
<h2 id="3-15-Java-static关键字"><a href="#3-15-Java-static关键字" class="headerlink" title="3.15 Java static关键字"></a>3.15 Java static关键字</h2><p>我面带着微笑对三妹说，“学习可不能落下，今天我们来学 Java 中 static 关键字吧。”</p>
<p>“static 是 Java 中比较难以理解的一个关键字，也是各大公司的面试官最喜欢问到的一个知识点之一。”我喝了一口咖啡继续说道。</p>
<p>“既然是面试重点，那我可得好好学习下。”三妹连忙说。</p>
<p>“static 关键字的作用可以用一句话来描述：‘<strong>方便在没有创建对象的情况下进行调用，包括变量和方法</strong>’。也就是说，只要类被加载了，就可以通过类名进行访问。”我扶了扶沉重眼镜，继续说到，“static 可以用来修饰类的成员变量，以及成员方法。我们一个个来看。”</p>
<p><strong>01、静态变量</strong></p>
<p>“如果在声明变量的时候使用了 static 关键字，那么这个变量就被称为静态变量。静态变量只在类加载的时候获取一次内存空间，这使得静态变量很节省内存空间。”家里的暖气有点足，我跑去开了一点窗户后继续说道。</p>
<p>“来考虑这样一个 Student 类。”话音刚落，我就在键盘上噼里啪啦一阵敲。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">    String name;</span><br><span class="line">    int age;</span><br><span class="line">    String school = &quot;郑州大学&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码敲完后，我对三妹说：“假设郑州大学录取了一万名新生，那么在创建一万个 Student 对象的时候，所有的字段（name、age 和 school）都会获取到一块内存。学生的姓名和年纪不尽相同，但都属于郑州大学，如果每创建一个对象，school 这个字段都要占用一块内存的话，就很浪费，对吧？三妹。”</p>
<p>“因此，最好将 school 这个字段设置为 static，这样就只会占用一块内存，而不是一万块。”</p>
<p>安静的房子里又响起了一阵噼里啪啦的键盘声。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">    String name;</span><br><span class="line">    int age;</span><br><span class="line">    static String school = &quot;郑州大学&quot;;</span><br><span class="line">    </span><br><span class="line">    public Student(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Student s1 = new Student(&quot;沉默王二&quot;, 18);</span><br><span class="line">        Student s2 = new Student(&quot;沉默王三&quot;, 16);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“瞧，三妹。s1 和 s2 这两个引用变量存放在栈区（stack），沉默王二+18 这个对象和沉默王三+16 这个对象存放在堆区（heap），school 这个静态变量存放在静态区。”</p>
<p>“等等，哥，栈、堆、静态区？”三妹的脸上塞满了疑惑。</p>
<p>“哦哦，别担心，三妹，画幅图你就全明白了。”说完我就打开 draw.io 这个网址，认真地画起了图。</p>
<p><img src="\assets\note\image-20231009143352111.png" alt="image-20231009143352111"></p>
<p>“现在，是不是一下子就明白了？”看着这幅漂亮的手绘图，我心里有点小开心。</p>
<p>“哇，哥，惊艳了呀！”三妹也不忘拍马屁，给我了一个大大的赞。</p>
<p>“好了，三妹，我们来看下面这串代码。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Counter &#123;</span><br><span class="line">    int count = 0;</span><br><span class="line">    </span><br><span class="line">    Counter() &#123;</span><br><span class="line">        count++;</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        Counter c1 = new Counter();</span><br><span class="line">        Counter c2 = new Counter();</span><br><span class="line">        Counter c3 = new Counter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“我们创建一个成员变量 count，并且在构造函数中让它自增。因为成员变量会在创建对象的时候获取内存，因此每一个对象都会有一个 count 的副本， count 的值并不会随着对象的增多而递增。”</p>
<p>我在侃侃而谈，而三妹似乎有些不太明白。</p>
<p>“没关系，三妹，你先盲猜一下，这段代码输出的结果是什么？”</p>
<p>“按照你的逻辑，应该输出三个 1？是这样吗？”三妹眨眨眼，有点不太自信地回答。</p>
<p>“哎呀，不错哟。”</p>
<p>我在 IDEA 中点了一下运行按钮，程序跑了起来。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>“每创建一个 Counter 对象，count 的值就从 0 自增到 1。三妹，想一下，如果 count 是静态的呢？”</p>
<p>“我不知道啊。”</p>
<p>“嗯，来看下面这段代码。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class StaticCounter &#123;</span><br><span class="line">    static int count = 0;</span><br><span class="line">    </span><br><span class="line">    StaticCounter() &#123;</span><br><span class="line">        count++;</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        StaticCounter c1 = new StaticCounter();</span><br><span class="line">        StaticCounter c2 = new StaticCounter();</span><br><span class="line">        StaticCounter c3 = new StaticCounter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“来看一下输出结果。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p>“简单解释一下哈，由于静态变量只会获取一次内存空间，所以任何对象对它的修改都会得到保留，所以每创建一个对象，count 的值就会加 1，所以最终的结果是 3，明白了吧？三妹。这就是静态变量和成员变量之间的差别。”</p>
<p>“另外，需要注意的是，由于静态变量属于一个类，所以不要通过对象引用来访问，而应该直接通过类名来访问，否则编译器会发出警告。”</p>
<p><img src="\assets\note\image-20231009143619914.png" alt="image-20231009143619914"></p>
<p><strong>02、静态方法</strong></p>
<p>“好吧。”我只好喝了一口咖啡继续说，“如果方法上加了 static 关键字，那么它就是一个静态方法。”</p>
<p>“静态方法有以下这些特征。”</p>
<ul>
<li>静态方法属于这个类而不是这个类的对象；</li>
<li>调用静态方法的时候不需要创建这个类的对象；</li>
<li>静态方法可以访问静态变量。</li>
</ul>
<p>“来，继续上代码”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class StaticMethodStudent &#123;</span><br><span class="line">    String name;</span><br><span class="line">    int age;</span><br><span class="line">    static String school = &quot;郑州大学&quot;;</span><br><span class="line">    </span><br><span class="line">    public StaticMethodStudent(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    static void change() &#123;</span><br><span class="line">        school = &quot;河南大学&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void out() &#123;</span><br><span class="line">        System.out.println(name + &quot; &quot; + age + &quot; &quot; + school);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        StaticMethodStudent.change();</span><br><span class="line">        </span><br><span class="line">        StaticMethodStudent s1 = new StaticMethodStudent(&quot;沉默王二&quot;, 18);</span><br><span class="line">        StaticMethodStudent s2 = new StaticMethodStudent(&quot;沉默王三&quot;, 16);</span><br><span class="line">        </span><br><span class="line">        s1.out();</span><br><span class="line">        s2.out();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“仔细听，三妹。 change() 方法就是一个静态方法，所以它可以直接访问静态变量 school，把它的值更改为河南大学；并且，可以通过类名直接调用 change() 方法，就像 StaticMethodStudent.change() 这样。”</p>
<p>“来看一下程序的输出结果吧。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">沉默王二 18 河南大学</span><br><span class="line">沉默王三 16 河南大学</span><br></pre></td></tr></table></figure>
<p>“需要注意的是，静态方法不能访问非静态变量和调用非静态方法。你看，三妹，我稍微改动一下代码，编译器就会报错。”</p>
<p>“先是在静态方法中访问非静态变量，编译器不允许。”</p>
<p><img src="\assets\note\image-20231009143824434.png" alt="image-20231009143824434"></p>
<p>“然后在静态方法中访问非静态方法，编译器同样不允许。”</p>
<p><img src="\assets\note\image-20231009143845779.png" alt="image-20231009143845779"></p>
<p>“关于静态方法的使用，这下清楚了吧，三妹？”</p>
<p>看着三妹点点头，我欣慰地笑了。</p>
<p>“哥，我想到了一个问题，为什么 main 方法是静态的啊？”没想到，三妹串联知识点的功力还是不错的。</p>
<p>“如果 main 方法不是静态的，就意味着 Java 虚拟机在执行的时候需要先创建一个对象才能调用 main 方法，而 main 方法作为程序的入口，创建一个额外的对象显得非常多余。”我不假思索的回答令三妹感到非常的钦佩。</p>
<p>“java.lang.Math 类的几乎所有方法都是静态的，可以直接通过类名来调用，不需要创建类的对象。”</p>
<p><img src="\assets\note\image-20231009143938220.png" alt="image-20231009143938220"></p>
<p><strong>03、静态代码块</strong></p>
<p>“除了静态变量和静态方法，static 关键字还有一个重要的作用。”我心情愉悦地对三妹说，“用一个 static 关键字，外加一个大括号括起来的代码被称为静态代码块。”</p>
<p>“就像下面这串代码。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class StaticBlock &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;静态代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;main 方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“静态代码块通常用来初始化一些静态变量，它会优先于 main() 方法执行。”</p>
<p>“来看一下程序的输出结果吧。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">静态代码块</span><br><span class="line">main 方法</span><br></pre></td></tr></table></figure>
<p>“二哥，既然静态代码块先于 main() 方法执行，那没有 main() 方法的 Java 类能执行成功吗？”三妹的脑回路越来越令我敬佩了。</p>
<p>“Java 1.6 是可以的，但 Java 7 开始就无法执行了。”我胸有成竹地回答到。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class StaticBlockNoMain &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;静态代码块，没有 main&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“在命令行中执行 java StaticBlockNoMain 的时候，会抛出 NoClassDefFoundError 的错误。”</p>
<p><img src="\assets\note\image-20231009144144280.png" alt="image-20231009144144280"></p>
<p>“三妹，来看下面这个例子。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class StaticBlockDemo &#123;</span><br><span class="line">    public static List&lt;String&gt; writes = new ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    static &#123;</span><br><span class="line">        writes.add(&quot;沉默王二&quot;);</span><br><span class="line">        writes.add(&quot;沉默王三&quot;);</span><br><span class="line">        writes.add(&quot;沉默王四&quot;);</span><br><span class="line">        System.out.println(&quot;第一块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    static &#123;</span><br><span class="line">        writes.add(&quot;沉默王五&quot;);</span><br><span class="line">        writes.add(&quot;沉默王六&quot;);</span><br><span class="line">        System.out.println(&quot;第二块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“writes 是一个静态的 ArrayList，所以不太可能在声明的时候完成初始化，因此需要在静态代码块中完成初始化。”</p>
<p>“静态代码块在初始集合的时候，真的非常有用。在实际的项目开发中，通常使用静态代码块来加载配置文件到内存当中。”</p>
<p><strong>04、静态内部类</strong></p>
<p>“三妹啊，除了以上只写，static 还有一个不太常用的功能——静态内部类。”</p>
<p>“Java 允许我们在一个类中声明一个内部类，它提供了一种令人信服的方式，允许我们只在一个地方使用一些变量，使代码更具有条理性和可读性。”</p>
<p>“常见的内部类有四种，成员内部类、局部内部类、匿名内部类和静态内部类，限于篇幅原因，前三种不在我们本次的讨论范围之内，以后有机会再细说。”</p>
<p>“来看下面这个例子。”三妹有点走神，我敲了敲她的脑袋后继续说。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private Singleton() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    private static class SingletonHolder &#123;</span><br><span class="line">        public static final Singleton instance = new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        return SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“三妹，打起精神，马上就结束了。”</p>
<p>“哦哦，这段代码看起来很别致啊，哥。”</p>
<p>“是的，三妹，这段代码在以后创建单例的时候还会见到。”</p>
<p>“第一次加载 Singleton 类时并不会初始化 instance，只有第一次调用 getInstance() 方法时 Java 虚拟机才开始加载 SingletonHolder 并初始化 instance，这样不仅能确保线程安全，也能保证 Singleton 类的唯一性。不过，创建单例更优雅的一种方式是使用枚举，以后再讲给你听。”</p>
<p>“需要注意的是。第一，静态内部类不能访问外部类的所有成员变量；第二，静态内部类可以访问外部类的所有静态变量，包括私有静态变量。第三，外部类不能声明为 static。”</p>
<p>“三妹，你看，在 Singleton 类上加 static 后，编译器就提示错误了。”</p>
<p><img src="\assets\note\image-20231009144403662.png" alt="image-20231009144403662"></p>
<p>三妹点了点头，所有所思。</p>
<h2 id="3-16-Java-final关键字"><a href="#3-16-Java-final关键字" class="headerlink" title="3.16 Java final关键字"></a>3.16 Java final关键字</h2><p>“哥，今天学什么呢？”</p>
<p>“今天学一个重要的关键字——final。 ”我面带着朴实无华的微笑回答着她，“对了，三妹，你打算考研吗？”</p>
<p>“还没想过，我今年才大一呢，到时候再说吧，你决定。”</p>
<p>“好吧。”我摊摊手，表示很无辜，真的是所有的决定都交给我这个哥哥了，如果决定错了，锅得背上。</p>
<p><strong>01、final 变量</strong></p>
<p>“好了，我们先来看 final 修饰的变量吧！”</p>
<p>“被 final 修饰的变量无法重新赋值。换句话说，final 变量一旦初始化，就无法更改。”</p>
<p>“来看这行代码。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final int age = 18;</span><br></pre></td></tr></table></figure>
<p>“当尝试将 age 的值修改为 30 的时候，编译器就生气了。”</p>
<p><img src="\assets\note\image-20231009144552210.png" alt="image-20231009144552210"></p>
<p>“再来看这段代码。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Pig &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    </span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“这是一个很普通的 Java 类，它有一个字段 name。”</p>
<p>“然后，我们创建一个测试类，并声明一个 final 修饰的 Pig 对象。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final Pig pig = new Pig();</span><br></pre></td></tr></table></figure>
<p>“如果尝试将 pig 重新赋值的话，编译器同样会生气。”</p>
<p><img src="\assets\note\image-20231009144645025.png" alt="image-20231009144645025"></p>
<p>“但我们仍然可以去修改 pig 对象的 name。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">final Pig pig = new Pig();</span><br><span class="line">pig.setName(&quot;特立独行&quot;);</span><br><span class="line">System.out.println(pig.getName()); // 特立独行</span><br></pre></td></tr></table></figure>
<p>“另外，final 修饰的成员变量必须有一个默认值，否则编译器将会提醒没有初始化。”</p>
<p><img src="\assets\note\image-20231009144719886.png" alt="image-20231009144719886"></p>
<p>“final 和 static 一起修饰的成员变量叫做常量，常量名必须全部大写。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class Pig &#123;</span><br><span class="line">   private final int age = 1;</span><br><span class="line">   public static final double PRICE = 36.5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“有时候，我们还会用 final 关键字来修饰参数，它意味着参数在方法体内不能被再修改。”</p>
<p>“来看下面这段代码。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class ArgFinalTest &#123;</span><br><span class="line">    public void arg(final int age) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void arg1(final String name) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“如果尝试去修改它的话，编译器会提示以下错误。”</p>
<p><img src="\assets\note\image-20231009144810038.png" alt="image-20231009144810038"></p>
<p><strong>02、final 方法</strong></p>
<p>“被 final 修饰的方法不能被重写。如果我们在设计一个类的时候，认为某些方法不应该被重写，就应该把它设计成 final 的。”</p>
<p>“Thread 类就是一个例子，它本身不是 final 的，这意味着我们可以扩展它，但它的 isAlive() 方法是final 的。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Thread implements Runnable &#123;</span><br><span class="line">    public final native boolean isAlive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“需要注意的是，该方法是一个本地（native）方法，用于确认线程是否处于活跃状态。而本地方法是由操作系统决定的，因此重写该方法并不容易实现。”</p>
<p>“来看这段代码。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class Actor &#123;</span><br><span class="line">    public final void show() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“当我们想要重写该方法的话，就会出现编译错误。”</p>
<p><img src="\assets\note\image-20231009144951509.png" alt="image-20231009144951509"></p>
<p>“三妹，来问你一个问题吧。”正想趁三妹回答问题的时候喝口水。</p>
<p>“你说吧，哥。”</p>
<p>“一个类是 final 的，和一个类不是 final，但它所有的方法都是 final 的，考虑一下，它们之间有什么区别？”</p>
<p>“我能想到的一点，就是前者不能被继承，也就是说方法无法被重写；后者呢，可以被继承，然后追加一些非final 的方法。”还没等我把水咽下去，三妹就回答好了，着实惊呆了我。</p>
<p>“嗯嗯嗯，没毛病没毛病，进步很大啊！”</p>
<p>“那必须啊，谁叫我是你妹呢。”</p>
<p><strong>03、final 类</strong></p>
<p>“如果一个类使用了 final 关键字修饰，那么它就无法被继承…..”</p>
<p>“等等，哥，我知道，String 类就是一个 final 类。”还没等我说完，三妹就抢着说到。</p>
<p>“说得没毛病。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final class String</span><br><span class="line">    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence,</span><br><span class="line">               Constable, ConstantDesc &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>“那三妹你知道为什么 String 类要设计成 final 吗？”</p>
<p>“这个还真不知道。”三妹的表情透露出这种无奈。</p>
<p>“原因大致有 3 个。”</p>
<ul>
<li>为了实现字符串常量池</li>
<li>为了线程安全</li>
<li>为了 HashCode 的不可变性</li>
</ul>
<p>“任何尝试从 final 类继承的行为将会引发编译错误。来看这段代码。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public final class Writer &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    </span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“尝试去继承它，编译器会提示以下错误，Writer 类是 final 的，无法继承。”</p>
<p><img src="\assets\note\image-20231009145208756.png" alt="image-20231009145208756"></p>
<p>“不过，类是 final 的，并不意味着该类的对象是不可变的。”</p>
<p>“来看这段代码。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Writer writer = new Writer();</span><br><span class="line">writer.setName(&quot;沉默王二&quot;);</span><br><span class="line">System.out.println(writer.getName()); // 沉默王二</span><br></pre></td></tr></table></figure>
<p>“Writer 的 name 字段的默认值是 null，但可以通过 settter 方法将其更改为沉默王二。也就是说，如果一个类只是 final 的，那么它并不是不可变的全部条件。”</p>
<p>“关于不可变类，我们留到后面来细讲。”</p>
<p><strong>不可变类</strong></p>
<p>“把一个类设计成 final 的，有其安全方面的考虑，但不应该故意为之，因为把一个类定义成 final 的，意味着它没办法继承，假如这个类的一些方法存在一些问题的话，我们就无法通过重写的方式去修复它。”</p>
<p>“三妹，final 关键字我们就学到这里吧，你一会再学习一下 Java 字符串为什么是不可变的和不可变类。”我揉一揉犯困的双眼，疲惫地给三妹说，“学完这两个知识点，你会对 final 的认知更清晰一些。”</p>
<p>“好的，二哥，我这就去学习去。你去休息会。”</p>
<h2 id="3-17-Java-instanceof关键字"><a href="#3-17-Java-instanceof关键字" class="headerlink" title="3.17 Java instanceof关键字"></a>3.17 Java instanceof关键字</h2><p>“三妹，今天我们来过一个非常简单的知识点，instanceof关键字。”</p>
<p>“用不着哥你来讲了，今天就换个形式，我来讲给你听。”三妹雄赳赳气昂昂地说。</p>
<p>instanceof 关键字的用法其实很简单：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(object) instanceof (type)</span><br></pre></td></tr></table></figure>
<p>用意也非常简单，判断对象是否符合指定的类型，结果要么是 true，要么是 false。在反序列化的时候，instanceof 操作符还是蛮常用的，因为这时候我们不太确定对象属不属于指定的类型，如果不进行判断的话，就容易抛出 ClassCastException 异常。</p>
<p>我们来建这样一个简单的类 Round：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Round &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后新增一个扩展类 Ring：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Ring extends Round &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候，我们就可以通过 instanceof 来检查 Ring 对象是否属于 Round 类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ring ring = new Ring();</span><br><span class="line">System.out.println(ring instanceof Round);</span><br></pre></td></tr></table></figure>
<p>结果会输出 true，因为 Ring 继承了 Round，也就意味着 Ring 和 Round 符合 is-a 的关系，而 instanceof操作符正是基于类与类之间的继承关系，以及类与接口之间的实现关系的。</p>
<p>我们再来新建一个接口 Shape：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">interface Shape &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后新建 Circle 类实现 Shape 接口并继承 Round 类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Circle extends Round implements Shape &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果对象是由该类创建的，那么 instanceof 的结果肯定为 true。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Circle circle = new Circle();</span><br><span class="line">System.out.println(circle instanceof Circle);</span><br></pre></td></tr></table></figure>
<p>这个肯定没毛病，instanceof 就是干这个活的，大家也很好理解。那如果类型是父类呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(circle instanceof Round);</span><br></pre></td></tr></table></figure>
<p>结果肯定还是 true，因为依然符合 is-a 的关系。那如果类型为接口呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(circle instanceof Shape);</span><br></pre></td></tr></table></figure>
<p>结果仍然为 true， 因为也符合 is-a 的关系。如果要比较的对象和要比较的类型之间没有关系，当然是不能使用 instanceof 进行比较的。</p>
<p>为了验证这一点，我们来创建一个实现了 Shape 但与 Circle 无关的 Triangle 类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Triangle implements Shape &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候，再使用 instanceof 进行比较的话，编译器就报错了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(circle instanceof Triangle);</span><br></pre></td></tr></table></figure>
<p>错误信息如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Inconvertible types; cannot cast &#x27;com.itwanger.twentyfour.instanceof1.Circle&#x27; to</span><br><span class="line">&#x27;com.itwanger.twentyfour.instanceof1.Triangle&#x27;</span><br></pre></td></tr></table></figure>
<p>意思就是类型不匹配，不能转换，我们使用 instanceof 比较的目的，也就是希望如果结果为 true 的时候能进行类型转换。但显然 Circle 不能转为 Triangle。</p>
<p>编译器已经提前帮我们预知了，很聪明。</p>
<p>Java 是一门面向对象的编程语言，也就意味着除了基本数据类型，所有的类都会隐式继承 Object 类。所以下面的结果肯定也会输出 true。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread thread = new Thread();</span><br><span class="line">System.out.println(thread instanceof Object);</span><br></pre></td></tr></table></figure>
<p>“那如果对象为 null 呢？”我这时候插话了。</p>
<p>“这个还真的是一个好问题啊。”三妹忍不住对我竖了一个大拇指。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(null instanceof Object);</span><br></pre></td></tr></table></figure>
<p>只有对象才会有 null 值，所以编译器是不会报错的，只不过，对于 null 来说，instanceof 的结果为 false。</p>
<p>因为所有的对象都可以为 null，所以也不好确定 null 到底属于哪一个类。</p>
<p>通常，我们是这样使用 instanceof 操作符的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 先判断类型</span><br><span class="line">if (obj instanceof String) &#123;</span><br><span class="line">    // 然后强制转换</span><br><span class="line">    String s = (String) obj;</span><br><span class="line">    // 然后才能使用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先用 instanceof 进行类型判断，然后再把 obj 强制转换成我们期望的类型再进行使用。</p>
<p>JDK 16 的时候，instanceof 模式匹配转了正，意味着使用 instanceof 的时候更便捷了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (obj instanceof String s) &#123;</span><br><span class="line">    // 如果类型匹配 直接使用 s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以直接在 if 条件判断类型的时候添加一个变量，就不需要再强转和声明新的变量了。</p>
<p>“哇，这样就简洁了呀！”为了配合三妹，我不仅惊叹到！</p>
<p>“好了，关于 instanceof 操作符我们就先讲到这吧，难是一点都不难，希望哥也能够很好的掌握。”三妹笑嘻嘻地说，看来她很享受这个讲的过程嘛。</p>
<h2 id="3-18-Java不可变对象"><a href="#3-18-Java不可变对象" class="headerlink" title="3.18 Java不可变对象"></a>3.18 Java不可变对象</h2><p>“二哥，你能给我说说为什么 String 是 immutable 类（不可变对象）吗？我想研究它，想知道为什么它就不可变了，这种强烈的愿望就像想研究浩瀚的星空一样。但无奈自身功力有限，始终觉得雾里看花终隔一层。”</p>
<p>三妹的这句话里满是彩虹屁的味道。</p>
<p>“既然三妹你说话这么好听，那我们就开始吧！”我愉快的心情就好像吃了两罐蜂蜜一样。</p>
<p><strong>01、什么是不可变类</strong></p>
<p>一个类的对象在通过构造方法创建后如果状态不会再被改变，那么它就是一个不可变（immutable）类。它的所有成员变量的赋值仅在构造方法中完成，不会提供任何 setter 方法供外部类去修改。</p>
<p>还记得《神雕侠侣》中小龙女的古墓吗？随着那一声巨响，仅有的通道就被无情地关闭了。别较真那个密道，我这么说只是为了打开你的想象力，让你对不可变类有一个更直观的印象。</p>
<p>自从有了多线程，生产力就被无限地放大了，所有的程序员都爱它，因为强大的硬件能力被充分地利用了。但与此同时，所有的程序员都对它心生忌惮，因为一不小心，多线程就会把对象的状态变得混乱不堪。</p>
<p>为了保护状态的原子性、可见性、有序性，我们程序员可以说是竭尽所能。其中，synchronized（同步）关键字是最简单最入门的一种解决方案。</p>
<p>假如说类是不可变的，那么对象的状态就也是不可变的。这样的话，每次修改对象的状态，就会产生一个新的对象供不同的线程使用，我们程序员就不必再担心并发问题了。</p>
<p><strong>02、常见的不可变类</strong></p>
<p>提到不可变类，几乎所有的程序员第一个想到的，就是 String 类。那为什么 String 类要被设计成不可变的呢？</p>
<p><strong>1）常量池的需要</strong></p>
<p>字符串常量池是 Java 堆内存中一个特殊的存储区域，当创建一个 String 对象时，假如此字符串在常量池中不存在，那么就创建一个；假如已经存，就不会再创建了，而是直接引用已经存在的对象。这样做能够减少JVM 的内存开销，提高效率。</p>
<p><strong>2）hashCode 需要</strong></p>
<p>因为字符串是不可变的，所以在它创建的时候，其 hashCode 就被缓存了，因此非常适合作为哈希值（比如说作为 HashMap 的键），多次调用只返回同一个值，来提高效率。</p>
<p><strong>3）线程安全</strong></p>
<p>就像之前说的那样，如果对象的状态是可变的，那么在多线程环境下，就很容易造成不可预期的结果。而String 是不可变的，就可以在多个线程之间共享，不需要同步处理。</p>
<p>因此，当我们调用 String 类的任何方法（比如说 trim() 、 substring() 、 toLowerCase() ）时，总会返回一个新的对象，而不影响之前的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String cmower = &quot;沉默王二，一枚有趣的程序员&quot;;</span><br><span class="line">cmower.substring(0,4);</span><br><span class="line">System.out.println(cmower);// 沉默王二，一枚有趣的程序员</span><br></pre></td></tr></table></figure>
<p>虽然调用 substring() 方法对 cmower 进行了截取，但 cmower 的值没有改变。</p>
<p>除了 String 类，包装器类 Integer、Long 等也是不可变类。</p>
<p><strong>03、手撸一个不可变类</strong></p>
<p>看懂一个不可变类也许容易，但要创建一个自定义的不可变类恐怕就有点难了。但知难而进是我们作为一名优秀的程序员不可或缺的品质，正因为不容易，我们才能真正地掌握它。</p>
<p>接下来，就请和我一起，来自定义一个不可变类吧。一个不可变类，必须要满足以下 4 个条件：</p>
<p>1）<strong>确保类是 final 的</strong>，不允许被其他类继承。</p>
<p>2）<strong>确保所有的成员变量（字段）是 final 的</strong>，这样的话，它们就只能在构造方法中初始化值，并且不会在随后被修改。</p>
<p>3）<strong>不要提供任何 setter 方法</strong>。</p>
<p>4）<strong>如果要修改类的状态，必须返回一个新的对象</strong>。</p>
<p>按照以上条件，我们来自定义一个简单的不可变类 Writer。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public final class Writer &#123;</span><br><span class="line">    private final String name;</span><br><span class="line">    private final int age;</span><br><span class="line">    </span><br><span class="line">    public Writer(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Writer 类是 final 的，name 和 age 也是 final 的，没有 setter 方法。</p>
<p>OK，据说这个作者分享了很多博客，广受读者的喜爱，因此某某出版社找他写了一本书（Book）。Book 类是这样定义的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class Book &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int price;</span><br><span class="line">    </span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int getPrice() &#123;</span><br><span class="line">        return price;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setPrice(int price) &#123;</span><br><span class="line">        this.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Book&#123;&quot; +</span><br><span class="line">                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, price=&quot; + price +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2 个字段，分别是 name 和 price，以及 getter 和 setter，重写后的 toString() 方法。然后，在 Writer类中追加一个可变对象字段 book。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public final class Writer &#123;</span><br><span class="line">    private final String name;</span><br><span class="line">    private final int age;</span><br><span class="line">    private final Book book;</span><br><span class="line"></span><br><span class="line">    public Writer(String name, int age, Book book) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.book = book;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Book getBook() &#123;</span><br><span class="line">        return book;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并在构造方法中追加了 Book 参数，以及 Book 的 getter 方法。</p>
<p>完成以上工作后，我们来新建一个测试类，看看 Writer 类的状态是否真的不可变。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class WriterDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Book book = new Book();</span><br><span class="line">        book.setName(&quot;二哥的 Java 进阶之路&quot;);</span><br><span class="line">        book.setPrice(79);</span><br><span class="line">        Writer writer = new Writer(&quot;沉默王二&quot;,18, book);</span><br><span class="line">        System.out.println(&quot;定价：&quot; + writer.getBook());</span><br><span class="line">        writer.getBook().setPrice(59);</span><br><span class="line">        System.out.println(&quot;促销价：&quot; + writer.getBook());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出的结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">定价：Book&#123;name=&#x27;二哥的 Java 进阶之路&#x27;, price=79&#125;</span><br><span class="line">促销价：Book&#123;name=&#x27;二哥的 Java 进阶之路&#x27;, price=59&#125;</span><br></pre></td></tr></table></figure>
<p>糟糕，Writer 类的不可变性被破坏了，价格发生了变化。为了解决这个问题，我们需要为不可变类的定义规则追加一条内容：</p>
<p>如果一个不可变类中包含了可变类的对象，那么就需要确保返回的是可变对象的副本。也就是说，Writer 类中的 getBook() 方法应该修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public Book getBook() &#123;</span><br><span class="line">    Book clone = new Book();</span><br><span class="line">    clone.setPrice(this.book.getPrice());</span><br><span class="line">    clone.setName(this.book.getName());</span><br><span class="line">    return clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的话，构造方法初始化后的 Book 对象就不会再被修改了。此时，运行 WriterDemo，就会发现价格不再发生变化了。</p>
<p><strong>04、总结</strong></p>
<p>不可变类有很多优点，就像之前提到的 String 类那样，尤其是在多线程环境下，它非常的安全。尽管每次修改都会创建一个新的对象，增加了内存的消耗，但这个缺点相比它带来的优点，显然是微不足道的——无非就是捡了西瓜，丢了芝麻。</p>
<p>“好了，三妹，你应该理解了吧？”</p>
<h2 id="3-19-Java方法重写和方法重载"><a href="#3-19-Java方法重写和方法重载" class="headerlink" title="3.19 Java方法重写和方法重载"></a>3.19 Java方法重写和方法重载</h2><p>“今天要学习 Java 中的方法重载与方法重写。”我迅速地走到电脑前面，打开一份 Excel 文档，看了一下《教妹学 Java（二哥的 Java 进阶之路前身）》的进度，然后对三妹说。</p>
<p>“如果一个类有多个名字相同但参数个数不同的方法，我们通常称这些方法为方法重载。 ”我面带着朴实无华的微笑继续说，“如果方法的功能是一样的，但参数不同，使用相同的名字可以提高程序的可读性。”</p>
<p>“如果子类具有和父类一样的方法（参数相同、返回类型相同、方法名相同，但方法体可能不同），我们称之为方法重写。 方法重写用于提供父类已经声明的方法的特殊实现，是实现多态的基础条件。”</p>
<p>“只不过，方法重载与方法重写在名字上很相似，就像是兄弟俩，导致初学者经常把它们俩搞混。”</p>
<p>“方法重载的英文名叫 Overloading，方法重写的英文名叫 Overriding，因此，不仅中文名很相近，英文名之间也很相近，这就更容易让初学者搞混了。”</p>
<p>“但两者其实是完全不同的！通过下面这张图，你就能看得一清二楚。”</p>
<p>话音刚落，我就在 IDEA 中噼里啪啦地敲了起来。两段代码，分别是方法重写和方法重载。然后，把这两段代码截图到 draw.io（一个很漂亮的在线画图网站）上，加了一些文字说明。最后，打开 Photoscape X，把两张图片合并到了一起。<br><img src="\assets\note\image-20231009151318746.png" alt="image-20231009151318746"></p>
<p><strong>01、方法重载</strong></p>
<p>“三妹，你仔细听哦。”我缓了一口气后继续说道。</p>
<p>“在 Java 中，有两种方式可以达到方法重载的目的。”</p>
<p>“第一，改变参数的数目。来看下面这段代码。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class OverloadingByParamNum &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(Adder.add(10, 19));</span><br><span class="line">        System.out.println(Adder.add(10, 19, 20));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Adder &#123;</span><br><span class="line">    static int add(int a, int b) &#123;</span><br><span class="line">        return a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    static int add(int a, int b, int c) &#123;</span><br><span class="line">        return a + b + c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>“Adder 类有两个方法，第一个 add() 方法有两个参数，在调用的时候可以传递两个参数；第二个 add()方法有三个参数，在调用的时候可以传递三个参数。”</p>
<p>“二哥，这样的代码不会显得啰嗦吗？如果有四个参数的时候就再追加一个方法？”三妹突然提了一个很尖锐的问题。</p>
<p>“那倒是，这个例子只是为了说明方法重载的一种类型。如果参数类型相同的话，Java 提供了可变参数的方式，就像下面这样。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static int add(int ... args) &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    for ( int a: args) &#123;</span><br><span class="line">        sum += a;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“第二，通过改变参数类型，也可以达到方法重载的目的。来看下面这段代码。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class OverloadingByParamType &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(Adder.add(10, 19));</span><br><span class="line">        System.out.println(Adder.add(10.1, 19.2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Adder &#123;</span><br><span class="line">    static int add(int a, int b) &#123;</span><br><span class="line">        return a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    static double add(double a, double b) &#123;</span><br><span class="line">        return a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“Adder 类有两个方法，第一个 add() 方法的参数类型为 int，第二个 add() 方法的参数类型为 double。”</p>
<p>“二哥，改变参数的数目和类型都可以实现方法重载，为什么改变方法的返回值类型就不可以呢？”三妹很能抓住问题的重点嘛。</p>
<p>“因为仅仅改变返回值类型的话，会把编译器搞懵逼的。”我略带调皮的口吻回答她。</p>
<p>“编译时报错优于运行时报错，所以当两个方法的名字相同，参数个数和类型也相同的时候，虽然返回值类型不同，但依然会提示方法已经被定义的错误。”</p>
<p><img src="\assets\note\image-20231009151751236.png" alt="image-20231009151751236"></p>
<p>“你想啊，三妹。我们在调用一个方法的时候，可以指定返回值类型，也可以不指定。当不指定的时候，直接指定 add(1, 2) 的时候，编译器就不知道该调用返回 int 的 add() 方法还是返回 double 的 add() 方法，产生了歧义。”</p>
<p>“方法的返回值只是作为方法运行后的一个状态，它是保持方法的调用者和被调用者进行通信的一个纽带，但并不能作为某个方法的‘标识’。”</p>
<p>“二哥，我想到了一个点， main() 方法可以重载吗？”</p>
<p>“三妹，这是个好问题啊！答案是肯定的，毕竟 main() 方法也是个方法，只不过，Java 虚拟机在运行的时候只会调用带有 String 数组的那个 main() 方法。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class OverloadingMain &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;String[] args&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String args) &#123;</span><br><span class="line">        System.out.println(&quot;String args&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main() &#123;</span><br><span class="line">        System.out.println(&quot;无参&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“第一个 main() 方法的参数形式为 String[] args ，是最标准的写法；第二个 main() 方法的参数形式为 String args ，少了中括号；第三个 main() 方法没有参数。”</p>
<p>“来看一下程序的输出结果。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] args</span><br></pre></td></tr></table></figure>
<p>“从结果中，我们可以看得出，尽管 main() 方法可以重载，但程序只认标准写法。”</p>
<p>“由于可以通过改变参数类型的方式实现方法重载，那么当传递的参数没有找到匹配的方法时，就会发生隐式的类型转换。”</p>
<p><img src="\assets\note\image-20231009151922194.png" alt="image-20231009151922194"></p>
<p>“如上图所示，byte 可以向上转换为 short、int、long、float 和 double，short 可以向上转换为 int、long、float 和 double，char 可以向上转换为 int、long、float 和 double，依次类推。”</p>
<p>“三妹，来看下面这个示例。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class OverloadingTypePromotion &#123;</span><br><span class="line">    void sum(int a, long b) &#123;</span><br><span class="line">        System.out.println(a + b);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void sum(int a, int b, int c) &#123;</span><br><span class="line">        System.out.println(a + b + c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        OverloadingTypePromotion obj = new OverloadingTypePromotion();</span><br><span class="line">        obj.sum(20, 20);</span><br><span class="line">        obj.sum(20, 20, 20);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“执行 obj.sum(20, 20) 的时候，发现没有 sum(int a, int b) 的方法，所以此时第二个 20 向上转型为long，所以调用的是 sum(int a, long b) 的方法。”</p>
<p>“再来看一个示例。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class OverloadingTypePromotion1 &#123;</span><br><span class="line">    void sum(int a, int b) &#123;</span><br><span class="line">        System.out.println(&quot;int&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void sum(long a, long b) &#123;</span><br><span class="line">        System.out.println(&quot;long&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        OverloadingTypePromotion1 obj = new OverloadingTypePromotion1();</span><br><span class="line">        obj.sum(20, 20);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“执行 obj.sum(20, 20) 的时候，发现有 sum(int a, int b) 的方法，所以就不会向上转型为 long，调用 sum(long a, long b) 。”</p>
<p>“来看一下程序的输出结果。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int</span><br></pre></td></tr></table></figure>
<p>“继续来看示例。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class OverloadingTypePromotion2 &#123;</span><br><span class="line">    void sum(long a, int b) &#123;</span><br><span class="line">        System.out.println(&quot;long int&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void sum(int a, long b) &#123;</span><br><span class="line">        System.out.println(&quot;int long&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        OverloadingTypePromotion2 obj = new OverloadingTypePromotion2();</span><br><span class="line">        obj.sum(20, 20);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“二哥，我又想到一个问题。当有两个方法 sum(long a, int b) 和 sum(int a, long b) ，参数个数相同，参数类型相同，只不过位置不同的时候，会发生什么呢？”</p>
<p>“当通过 obj.sum(20, 20) 来调用 sum 方法的时候，编译器会提示错误。”</p>
<p><img src="\assets\note\image-20231009152141247.png" alt="image-20231009152141247"></p>
<p>“不明确，编译器会很为难，究竟是把第一个 20 从 int 转成 long 呢，还是把第二个 20 从 int 转成 long，智障了！所以，不能写这样让编译器左右为难的代码。”</p>
<p><strong>02、方法重写</strong></p>
<p>“三妹，累吗？我们稍微休息一下吧。”我把眼镜摘下来，放到桌子上，闭上了眼睛，开始胡思乱想起来。</p>
<p>“哥，醒醒，你就说休息一会，没说睡着啊。赶紧，我还有半个小时就要走了。”</p>
<p>我戴上眼镜，对三妹继续说道：“在 Java 中，方法重写需要满足以下三个规则。”</p>
<ul>
<li>重写的方法必须和父类中的方法有着相同的名字；</li>
<li>重写的方法必须和父类中的方法有着相同的参数；</li>
<li>必须是 is-a 的关系（继承关系）。</li>
</ul>
<p>“来看下面这段代码。”</p>
<p>“来看一下程序的输出结果。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Bike extends Vehicle &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Bike bike = new Bike();</span><br><span class="line">        bike.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Vehicle &#123;</span><br><span class="line">    void run() &#123;</span><br><span class="line">        System.out.println(&quot;车辆在跑&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“来看一下程序的输出结果。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">车辆在跑</span><br></pre></td></tr></table></figure>
<p>“Bike is-a Vehicle，自行车是一种车，没错。Vehicle 类有一个 run() 的方法，也就是说车辆可以跑，Bike继承了 Vehicle，也可以跑。但如果 Bike 没有重写 run() 方法的话，自行车就只能是‘车辆在跑’，而不是‘自行车在跑’，对吧？”</p>
<p>“如果有了方法重写，一切就好办了。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Bike extends Vehicle &#123;</span><br><span class="line">    @Override</span><br><span class="line">    void run() &#123;</span><br><span class="line">        System.out.println(&quot;自行车在跑&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Bike bike = new Bike();</span><br><span class="line">        bike.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Vehicle &#123;</span><br><span class="line">    void run() &#123;</span><br><span class="line">        System.out.println(&quot;车辆在跑&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我把鼠标移动到 Bike 类的 run() 方法，对三妹说：“你看，在方法重写的时候，IDEA 会建议使用@Override 注解，显式的表示这是一个重写后的方法，尽管可以缺省。”</p>
<p>“来看一下程序的输出结果。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">自行车在跑</span><br></pre></td></tr></table></figure>
<p>“Bike 重写了 run() 方法，也就意味着，Bike 可以跑出自己的风格。”</p>
<p>好，接下来说一下重写时应当遵守的 12 条规则，应当谨记哦。</p>
<p><strong>规则一：只能重写继承过来的方法。</strong></p>
<p>因为重写是在子类重新实现从父类继承过来的方法时发生的，所以只能重写继承过来的方法，这很好理解。这就意味着，只能重写那些被 public、protected 或者 default 修饰的方法，private 修饰的方法无法被重写。</p>
<p>Animal 类有 move() 、 eat() 和 sleep() 三个方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Animal &#123;</span><br><span class="line">    public void move() &#123; &#125;</span><br><span class="line">    protected void eat() &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    void sleep()&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Dog 类来重写这三个方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Dog extends Animal &#123;</span><br><span class="line">    public void move() &#123; &#125;</span><br><span class="line">    protected void eat() &#123; &#125;</span><br><span class="line">    void sleep()&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OK，完全没有问题。但如果父类中的方法是 private 的，就行不通了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Animal &#123;</span><br><span class="line">    private void move() &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，Dog 类中的 move() 方法就不再是一个重写方法了，因为父类的 move() 方法是 private 的，对子类并不可见。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Dog extends Animal &#123;</span><br><span class="line">    public void move() &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>规则二：final、static 的方法不能被重写。</strong></p>
<p>一个方法是 final 的就意味着它无法被子类继承到，所以就没办法重写。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Animal &#123;</span><br><span class="line">    final void move() &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于父类 Animal 中的 move() 是 final 的，所以子类在尝试重写该方法的时候就出现编译错误了！</p>
<p><img src="\assets\note\image-20231009152614433.png" alt="image-20231009152614433"></p>
<p>同样的，如果一个方法是 static 的，也不允许重写，因为静态方法可用于父类以及子类的所有实例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Animal &#123;</span><br><span class="line">    final void move() &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重写的目的在于根据对象的类型不同而表现出多态，而静态方法不需要创建对象就可以使用。没有了对象，重写所需要的“对象的类型”也就没有存在的意义了。</p>
<p><img src="\assets\note\image-20231009152657422.png" alt="image-20231009152657422"></p>
<p><strong>规则三：重写的方法必须有相同的参数列表。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Animal &#123;</span><br><span class="line">    void eat(String food) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Dog 类中的 eat() 方法保持了父类方法 eat() 的同一个调调，都有一个参数——String 类型的 food。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Dog extends Animal &#123;</span><br><span class="line">    public void eat(String food) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一旦子类没有按照这个规则来，比如说增加了一个参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Dog extends Animal &#123;</span><br><span class="line">    public void eat(String food, int amount) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就不再是重写的范畴了，当然也不是重载的范畴，因为重载考虑的是同一个类。</p>
<p><strong>规则四：重写的方法必须返回相同的类型。</strong></p>
<p>父类没有返回类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Animal &#123;</span><br><span class="line">    void eat(String food) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类尝试返回 String：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Dog extends Animal &#123;</span><br><span class="line">    public String eat(String food) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>于是就编译出错了（返回类型不兼容）。</p>
<p><img src="\assets\note\image-20231009152918336.png" alt="image-20231009152918336"></p>
<p><strong>规则五：重写的方法不能使用限制等级更严格的权限修饰符。</strong></p>
<p>可以这样来理解：</p>
<ul>
<li>如果被重写的方法是 default，那么重写的方法可以是 default、protected 或者 public。</li>
<li>如果被重写的方法是 protected，那么重写的方法只能是 protected 或者 public。</li>
<li>如果被重写的方法是 public， 那么重写的方法就只能是 public。</li>
</ul>
<p>举个例子，父类中的方法是 protected：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Animal &#123;</span><br><span class="line">    protected void eat() &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类中的方法可以是 public：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Dog extends Animal &#123;</span><br><span class="line">    public void eat() &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果子类中的方法用了更严格的权限修饰符，编译器就报错了。</p>
<p><img src="\assets\note\image-20231009153042304.png" alt="image-20231009153042304"></p>
<p><strong>规则六：重写后的方法不能抛出比父类中更高级别的异常。</strong></p>
<p>举例来说，如果父类中的方法抛出的是 IOException，那么子类中重写的方法不能抛出 Exception，可以是IOException 的子类或者不抛出任何异常。这条规则只适用于可检查的异常。</p>
<p>可检查（checked）异常必须在源代码中显式地进行捕获处理，不检查（unchecked）异常就是所谓的运行时异常，比如说 NullPointerException、ArrayIndexOutOfBoundsException 之类的，不会在编译器强制要求。</p>
<p>父类抛出 IOException：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Animal &#123;</span><br><span class="line">    protected void eat() throws IOException &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类抛出 FileNotFoundException 是可以满足重写的规则的，因为 FileNotFoundException 是 IOException的子类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Dog extends Animal &#123;</span><br><span class="line">   public void eat() throws FileNotFoundException &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果子类抛出了一个新的异常，并且是一个 checked 异常：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Dog extends Animal &#123;</span><br><span class="line">   public void eat() throws FileNotFoundException, InterruptedException &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那编译器就会提示错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Error:(9, 16) java: com.itwanger.overriding.Dog中的eat()无法覆盖</span><br><span class="line">com.itwanger.overriding.Animal中的eat()</span><br><span class="line">  被覆盖的方法未抛出java.lang.InterruptedException</span><br></pre></td></tr></table></figure>
<p>但如果子类抛出的是一个 unchecked 异常，那就没有冲突：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Dog extends Animal &#123;</span><br><span class="line">   public void eat() throws FileNotFoundException, IllegalArgumentException &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果子类抛出的是一个更高级别的异常：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Dog extends Animal &#123;</span><br><span class="line">   public void eat() throws Exception &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器同样会提示错误，因为 Exception 是 IOException 的父类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Error:(9, 16) java: com.itwanger.overriding.Dog中的eat()无法覆盖</span><br><span class="line">com.itwanger.overriding.Animal中的eat()</span><br><span class="line">  被覆盖的方法未抛出java.lang.Exception</span><br></pre></td></tr></table></figure>
<p><strong>规则七：可以在子类中通过 super 关键字来调用父类中被重写的方法。</strong></p>
<p>子类继承父类的方法而不是重新实现是很常见的一种做法，在这种情况下，可以按照下面的形式调用父类的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">super.overriddenMethodName();</span><br></pre></td></tr></table></figure>
<p>来看例子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Animal &#123;</span><br><span class="line">    protected void eat() &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类重写了 eat() 方法，然后在子类的 eat() 方法中，可以在方法体的第一行通过 super.eat() 调用父类的方法，然后再增加属于自己的代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Dog extends Animal &#123;</span><br><span class="line">   public void eat() &#123;</span><br><span class="line">       super.eat();</span><br><span class="line">       // Dog-eat</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>规则八：构造方法不能被重写。</strong></p>
<p>因为构造方法很特殊，而且子类的构造方法不能和父类的构造方法同名（类名不同），所以构造方法和重写之间没有任何关系。</p>
<p><strong>规则九：如果一个类继承了抽象类，抽象类中的抽象方法必须在子类中被重写。</strong></p>
<p>先来看这样一个接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Animal &#123;</span><br><span class="line">    void move();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口中的方法默认都是抽象方法，通过反编译是可以看得到的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Animal</span><br><span class="line">&#123;</span><br><span class="line">    public abstract void move();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果一个抽象类实现了 Animal 接口， move() 方法不是必须被重写的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractDog implements Animal &#123;</span><br><span class="line">    protected abstract void bark();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但如果一个类继承了抽象类 AbstractDog，那么 Animal 接口中的 move() 方法和抽象类 AbstractDog 中的抽象方法 bark() 都必须被重写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class BullDog extends AbstractDog &#123;</span><br><span class="line"> </span><br><span class="line">    public void move() &#123;&#125;</span><br><span class="line"> </span><br><span class="line">    protected void bark() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>规则十：synchronized 关键字对重写规则没有任何影响。</strong></p>
<p>synchronized 关键字用于在多线程环境中获取和释放监听对象，因此它对重写规则没有任何影响，这就意味着 synchronized 方法可以去重写一个非同步方法。</p>
<p><strong>规则十一：strictfp 关键字对重写规则没有任何影响。</strong></p>
<p>如果你想让浮点运算更加精确，而且不会因为硬件平台的不同导致执行的结果不一致的话，可以在方法上添加 strictfp 关键字，之前讲过。因此 strictfp 关键字和重写规则无关。</p>
<p><strong>03、总结</strong></p>
<p>“好了，三妹，我来简单做个总结。”我瞥了一眼电脑右上角的时钟，离三妹离开的时间不到 10 分钟了。</p>
<p>“首先来说一下方法重载时的注意事项，‘两同一不同’。”</p>
<p>“‘两同’：在同一个类，方法名相同。”</p>
<p>“‘一不同’：参数不同。”</p>
<p>“再来说一下方法重写时的注意事项，‘两同一小一大’。”</p>
<p>“‘两同’：方法名相同，参数相同。”</p>
<p>“‘一小’：子类方法声明的异常类型要比父类小一些或者相等。”</p>
<p>“‘一大’：子类方法的访问权限应该比父类的更大或者相等。”</p>
<h2 id="3-20-Java注解"><a href="#3-20-Java注解" class="headerlink" title="3.20 Java注解"></a>3.20 Java注解</h2><p>“二哥，这节讲注解吗？”三妹问。</p>
<p>“是的。”我说，“注解是 Java 中非常重要的一部分，但经常被忽视也是真的。之所以这么说是因为我们更倾向成为一名注解的使用者而不是创建者。 @Override 注解用过吧？方法重写的时候用到过。但你知道怎么自定义一个注解吗？”</p>
<p>三妹毫不犹豫地摇摇头，摆摆手，不好意思地承认自己的确没有自定义过。</p>
<p>“好吧，哥来告诉你吧。”</p>
<p>注解（Annotation）是在 Java 1.5 时引入的概念，同 class 和 interface 一样，也属于一种类型。注解提供了一系列数据用来装饰程序代码（类、方法、字段等），但是注解并不是所装饰代码的一部分，它对代码的运行效果没有直接影响，由编译器决定该执行哪些操作。</p>
<p>来看一段代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class AutowiredTest &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private String name;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;沉默王二，一枚有趣的程序员&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到 @Autowired 这个注解了吧？它本来是为 Spring（后面会讲）容器注入 Bean 的，现在被我无情地扔在了字段 name 的身上，但这段代码所在的项目中并没有启用 Spring，意味着 @Autowired 注解此时只是一个摆设。</p>
<p>“既然只是个摆设，那你这个地方为什么还要用 @Autowired 呢？”三妹好奇地问。</p>
<p>“傻呀你，就是给你举个例子，证明：注解对代码的运行效果没有直接影响，明白我的用意了吧？”我毫不客气地说。</p>
<p>“哦。”三妹若有所思地说。</p>
<p>“认真听哈，接下来给你讲讲注解的生命周期。”我瞅了瞅三妹，看她是否在专注的听，然后继续说，“注解的生命周期有 3 种策略，定义在 RetentionPolicy 枚举中。”</p>
<p>1）SOURCE：在源文件中有效，被编译器丢弃。</p>
<p>2）CLASS：在编译器生成的字节码文件中有效，但在运行时会被处理类文件的 JVM 丢弃。</p>
<p>3）RUNTIME：在运行时有效。这也是注解生命周期中最常用的一种策略，它允许程序通过反射的方式访问注解，并根据注解的定义执行相应的代码。</p>
<p>“然后我们来讲注解装饰的目标。”我看三妹还在线，就继续说。</p>
<p>注解的目标定义了注解将适用于哪一种级别的 Java 代码上，有些注解只适用于方法，有些只适用于成员变量，有些只适用于类，有些则都适用。截止到 Java 9，注解的类型一共有 11 种，定义在 ElementType 枚举中。</p>
<p>1）TYPE：用于类、接口、注解、枚举</p>
<p>2）FIELD：用于字段（类的成员变量），或者枚举常量</p>
<p>3）METHOD：用于方法</p>
<p>4）PARAMETER：用于普通方法或者构造方法的参数</p>
<p>5）CONSTRUCTOR：用于构造方法</p>
<p>6）LOCAL_VARIABLE：用于变量</p>
<p>7）ANNOTATION_TYPE：用于注解</p>
<p>8）PACKAGE：用于包</p>
<p>9）TYPE_PARAMETER：用于泛型参数</p>
<p>10）TYPE_USE：用于声明语句、泛型或者强制转换语句中的类型</p>
<p>11）MODULE：用于模块</p>
<p>“哥，你将这些我都记不住，能不能直接开撸注解呀！！！！！”三妹不耐烦了。</p>
<p>“确实哈，说再多，都不如撸个注解来得让人心动。撸个什么样的注解呢？一个字段注解吧，它用来标记对象在序列化成 JSON 的时候要不要包含这个字段。”我笑着对三妹说，“怎么样？”</p>
<p>“好呀！”</p>
<p>“来看下面这段代码。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.FIELD)</span><br><span class="line">public @interface JsonField &#123;</span><br><span class="line">    public String value() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1）JsonField 注解的生命周期是 RUNTIME，也就是运行时有效。</p>
<p>2）JsonField 注解装饰的目标是 FIELD，也就是针对字段的。</p>
<p>3）创建注解需要用到 @interface 关键字。</p>
<p>4）JsonField 注解有一个参数，名字为 value，类型为 String，默认值为一个空字符串。</p>
<p>“为什么参数名要为 value 呢？有什么特殊的含义吗？”三妹问。</p>
<p>“当然是有的，value 允许注解的使用者提供一个无需指定名字的参数。举个例子，我们可以在一个字段上使用 @JsonField(value = “沉默王二”) ，也可以把 value = 省略，变成 @JsonField(“沉默王二”) 。”我说。</p>
<p>“那 default “” 有什么特殊含义吗？”三妹继续问。</p>
<p>“当然也是有的，它允许我们在一个字段上直接使用 @JsonField ，而无需指定参数的名和值。”我回答说。</p>
<p>“明白了，那 @JsonField 注解已经撸好了，是不是可以使用它了呀？”三妹激动地说。</p>
<p>“嗯，假设有一个 Writer 类，他有 3 个字段，分别是 age、name 和 bookName，后 2 个是必须序列化的字段。就可以这样来用 @JsonField 注解。”我说。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Writer &#123;</span><br><span class="line">    private int age;</span><br><span class="line">    @JsonField(&quot;writerName&quot;)</span><br><span class="line">    private String name;</span><br><span class="line">    @JsonField</span><br><span class="line">    private String bookName;</span><br><span class="line">    public Writer(int age, String name, String bookName) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.bookName = bookName;</span><br><span class="line">    &#125;</span><br><span class="line">    // getter / setter</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Writer&#123;&quot; +</span><br><span class="line">                &quot;age=&quot; + age +</span><br><span class="line">                &quot;, name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, bookName=&#x27;&quot; + bookName + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1）name 上的 @JsonField 注解提供了显式的字符串值。</p>
<p>2）bookName 上的 @JsonField 注解使用了缺省项。</p>
<p>接下来，我们来编写序列化类 JsonSerializer，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class JsonSerializer &#123;</span><br><span class="line">    public static String serialize(Object object) throws IllegalAccessException &#123;</span><br><span class="line">        Class&lt;?&gt; objectClass = object.getClass();</span><br><span class="line">        Map&lt;String, String&gt; jsonElements = new HashMap&lt;&gt;();</span><br><span class="line">        for (Field field : objectClass.getDeclaredFields()) &#123;</span><br><span class="line">            field.setAccessible(true);</span><br><span class="line">            if (field.isAnnotationPresent(JsonField.class)) &#123;</span><br><span class="line">                jsonElements.put(getSerializedKey(field), (String) </span><br><span class="line">field.get(object));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return toJsonString(jsonElements);</span><br><span class="line">    &#125;</span><br><span class="line">    private static String getSerializedKey(Field field) &#123;</span><br><span class="line">        String annotationValue = field.getAnnotation(JsonField.class).value();</span><br><span class="line">        if (annotationValue.isEmpty()) &#123;</span><br><span class="line">            return field.getName();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return annotationValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private static String toJsonString(Map&lt;String, String&gt; jsonMap) &#123;</span><br><span class="line">        String elementsString = jsonMap.entrySet()</span><br><span class="line">                .stream()</span><br><span class="line">                .map(entry -&gt; &quot;\&quot;&quot; + entry.getKey() + &quot;\&quot;:\&quot;&quot; + entry.getValue() + </span><br><span class="line">&quot;\&quot;&quot;)</span><br><span class="line">                .collect(Collectors.joining(&quot;,&quot;));</span><br><span class="line">        return &quot;&#123;&quot; + elementsString + &quot;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“JsonSerializer 类的内容看起来似乎有点多啊，二哥，我有点看不懂。”三妹说。</p>
<p>“不要怕，我一点点来解释，直到你搞明白为止。”</p>
<p>1） serialize() 方法是用来序列化对象的，它接收一个 Object 类型的参数。</p>
<p>objectClass.getDeclaredFields() 通过反射的方式获取对象声明的所有字段，然后进行 for 循环遍历。在 for 循环中，先通过 field.setAccessible(true) 将反射对象的可访问性设置为 true，供序列化使用（如果没有这个步骤的话，private 字段是无法获取的，会抛出 IllegalAccessException 异常）；再通过isAnnotationPresent() 判断字段是否装饰了 JsonField 注解，如果是的话，调用getSerializedKey() 方法，以及获取该对象上由此字段表示的值，并放入 jsonElements 中。</p>
<p>2） getSerializedKey() 方法用来获取字段上注解的值，如果注解的值是空的，则返回字段名。</p>
<p>3） toJsonString() 方法借助 Stream 流的方式返回格式化后的 JSON 字符串。Stream 流你还没有接触过，不过没关系，后面我再给你讲。</p>
<p>“现在是不是豁然开朗了？”我问三妹，看到三妹点了点头，我继续说，“接下来，我们来写一个测试类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class JsonFieldTest &#123;</span><br><span class="line">    public static void main(String[] args) throws IllegalAccessException &#123;</span><br><span class="line">        Writer cmower = new Writer(18,&quot;沉默王二&quot;,&quot;Web全栈开发进阶之路&quot;);</span><br><span class="line">        System.out.println(JsonSerializer.serialize(cmower));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;bookName&quot;:&quot;Web全栈开发进阶之路&quot;,&quot;writerName&quot;:&quot;沉默王二&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>从结果上来看：</p>
<p>1）Writer 类的 age 字段没有装饰 @JsonField 注解，所以没有序列化。</p>
<p>2）Writer 类的 name 字段装饰了 @JsonField 注解，并且显示指定了字符串“writerName”，所以序列化后变成了 writerName。</p>
<p>3）Writer 类的 bookName 字段装饰了 @JsonField 注解，但没有显式指定值，所以序列化后仍然是bookName。</p>
<p>“怎么样，三妹，是不是也不是特别难？”我对三妹说。</p>
<p>“撸个注解好像真没什么难度，但你接下来的那个 JsonSerializer 我还需要再消化一下。”三妹很认真地说。</p>
<p>“嗯，你好好复习下，我看会《编译原理》。”说完我拿起桌子边上的一本书就走了。</p>
<h2 id="3-21-Java枚举（enum）"><a href="#3-21-Java枚举（enum）" class="headerlink" title="3.21 Java枚举（enum）"></a>3.21 Java枚举（enum）</h2><p>“今天我们来学习枚举吧，三妹！”我说，“同学让你去她家玩了两天，感觉怎么样呀？”</p>
<p>“心情放松了不少。”三妹说，“可以开始学 Java 了，二哥。”</p>
<p>“OK。”</p>
<p>“枚举（enum），是 Java 1.5 时引入的关键字，它表示一种特殊类型的类，继承自 java.lang.Enum。”</p>
<p>“我们来新建一个枚举 PlayerType。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public enum PlayerType &#123;</span><br><span class="line">    TENNIS,</span><br><span class="line">    FOOTBALL,</span><br><span class="line">    BASKETBALL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“二哥，我没看到有继承关系呀！”</p>
<p>“别着急，看一下反编译后的字节码，你就明白了。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public final class PlayerType extends Enum</span><br><span class="line">&#123;</span><br><span class="line">    public static PlayerType[] values()</span><br><span class="line">    &#123;</span><br><span class="line">        return (PlayerType[])$VALUES.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static PlayerType valueOf(String name)</span><br><span class="line">    &#123;</span><br><span class="line">        return (PlayerType)Enum.valueOf(com/cmower/baeldung/enum1/PlayerType, name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private PlayerType(String s, int i)</span><br><span class="line">    &#123;</span><br><span class="line">        super(s, i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static final PlayerType TENNIS;</span><br><span class="line">    public static final PlayerType FOOTBALL;</span><br><span class="line">    public static final PlayerType BASKETBALL;</span><br><span class="line">    private static final PlayerType $VALUES[];</span><br><span class="line">    </span><br><span class="line">    static </span><br><span class="line">    &#123;</span><br><span class="line">        TENNIS = new PlayerType(&quot;TENNIS&quot;, 0);</span><br><span class="line">        FOOTBALL = new PlayerType(&quot;FOOTBALL&quot;, 1);</span><br><span class="line">        BASKETBALL = new PlayerType(&quot;BASKETBALL&quot;, 2);</span><br><span class="line">        $VALUES = (new PlayerType[] &#123;</span><br><span class="line">            TENNIS, FOOTBALL, BASKETBALL</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“看到没？Java 编译器帮我们做了很多隐式的工作，不然手写一个枚举就没那么省心省事了。”</p>
<ul>
<li>要继承 Enum 类；</li>
<li>要写构造方法；</li>
<li>要声明静态变量和数组；</li>
<li>要用 static 块来初始化静态变量和数组；</li>
<li>要提供静态方法，比如说 values() 和 valueOf(String name) 。</li>
</ul>
<p>“确实，作为开发者，我们的代码量减少了，枚举看起来简洁明了。”三妹说。</p>
<p>“既然枚举是一种特殊的类，那它其实是可以定义在一个类的内部的，这样它的作用域就可以限定于这个外部类中使用。”我说。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Player &#123;</span><br><span class="line">    private PlayerType type;</span><br><span class="line">    public enum PlayerType &#123;</span><br><span class="line">        TENNIS,</span><br><span class="line">        FOOTBALL,</span><br><span class="line">        BASKETBALL</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean isBasketballPlayer() &#123;</span><br><span class="line">      return getType() == PlayerType.BASKETBALL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public PlayerType getType() &#123;</span><br><span class="line">        return type;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setType(PlayerType type) &#123;</span><br><span class="line">        this.type = type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PlayerType 就相当于 Player 的内部类。</p>
<p>由于枚举是 final 的，所以可以确保在 Java 虚拟机中仅有一个常量对象，基于这个原因，我们可以使用“==”运算符来比较两个枚举是否相等，参照 isBasketballPlayer() 方法。</p>
<p>“那为什么不使用 equals() 方法判断呢？”三妹问。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(player.getType().equals(Player.PlayerType.BASKETBALL))&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>“我来给你解释下。”</p>
<p>“==”运算符比较的时候，如果两个对象都为 null，并不会发生 NullPointerException ，而 equals() 方法则会。</p>
<p>另外， “==”运算符会在编译时进行检查，如果两侧的类型不匹配，会提示错误，而 equals() 方法则不会。</p>
<p><img src="\assets\note\image-20231009155718335.png" alt="image-20231009155718335"></p>
<p>“枚举还可用于 switch 语句，和基本数据类型的用法一致。”我说。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">switch (playerType) &#123;</span><br><span class="line">    case TENNIS:</span><br><span class="line">        return &quot;网球运动员费德勒&quot;;</span><br><span class="line">    case FOOTBALL:</span><br><span class="line">        return &quot;足球运动员C罗&quot;;</span><br><span class="line">    case BASKETBALL:</span><br><span class="line">        return &quot;篮球运动员詹姆斯&quot;;</span><br><span class="line">    case UNKNOWN:</span><br><span class="line">        throw new IllegalArgumentException(&quot;未知&quot;);</span><br><span class="line">    default:</span><br><span class="line">        throw new IllegalArgumentException(</span><br><span class="line">                &quot;运动员类型: &quot; + playerType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“如果枚举中需要包含更多信息的话，可以为其添加一些字段，比如下面示例中的 name，此时需要为枚举添加一个带参的构造方法，这样就可以在定义枚举时添加对应的名称了。”我继续说。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public enum PlayerType &#123;</span><br><span class="line">    TENNIS(&quot;网球&quot;),</span><br><span class="line">    FOOTBALL(&quot;足球&quot;),</span><br><span class="line">    BASKETBALL(&quot;篮球&quot;);</span><br><span class="line">    private String name;</span><br><span class="line">    PlayerType(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“get 了吧，三妹？”</p>
<p>“嗯，比较好理解。”</p>
<p>“那接下来，我就来说点不一样的。”</p>
<p>“来吧，我准备好了。”</p>
<p>“EnumSet 是一个专门针对枚举类型的 Set 接口（后面会讲）的实现类，它是处理枚举类型数据的一把利器，非常高效。”我说，“从名字上就可以看得出，EnumSet 不仅和 Set 有关系，和枚举也有关系。”</p>
<p>“因为 EnumSet 是一个抽象类，所以创建 EnumSet 时不能使用 new 关键字。不过，EnumSet 提供了很多有用的静态工厂方法。”</p>
<p><img src="\assets\note\image-20231009155834717.png" alt="image-20231009155834717"></p>
<p>“来看下面这个例子，我们使用 noneOf() 静态工厂方法创建了一个空的 PlayerType 类型的 EnumSet；使用 allOf() 静态工厂方法创建了一个包含所有 PlayerType 类型的 EnumSet。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class EnumSetTest &#123;</span><br><span class="line">    public enum PlayerType &#123;</span><br><span class="line">        TENNIS,</span><br><span class="line">        FOOTBALL,</span><br><span class="line">        BASKETBALL</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        EnumSet&lt;PlayerType&gt; enumSetNone = EnumSet.noneOf(PlayerType.class);</span><br><span class="line">        System.out.println(enumSetNone);</span><br><span class="line">        EnumSet&lt;PlayerType&gt; enumSetAll = EnumSet.allOf(PlayerType.class);</span><br><span class="line">        System.out.println(enumSetAll);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“来看一下输出结果。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[]</span><br><span class="line">[TENNIS, FOOTBALL, BASKETBALL]</span><br></pre></td></tr></table></figure>
<p>有了 EnumSet 后，就可以使用 Set 的一些方法了，见下图。</p>
<p><img src="\assets\note\image-20231009155924617.png" alt="image-20231009155924617"></p>
<p>“除了 EnumSet，还有 EnumMap，是一个专门针对枚举类型的 Map 接口的实现类，它可以将枚举常量作为键来使用。EnumMap 的效率比 HashMap 还要高，可以直接通过数组下标（枚举的 ordinal 值）访问到元素。”</p>
<p>“和 EnumSet 不同，EnumMap 不是一个抽象类，所以创建 EnumMap 时可以使用 new 关键字。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EnumMap&lt;PlayerType, String&gt; enumMap = new EnumMap&lt;&gt;(PlayerType.class);</span><br></pre></td></tr></table></figure>
<p>有了 EnumMap 对象后就可以使用 Map 的一些方法了，见下图。</p>
<p><img src="\assets\note\image-20231009160001570.png" alt="image-20231009160001570"></p>
<p>和 HashMap（后面会讲）的使用方法大致相同，来看下面的例子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EnumMap&lt;PlayerType, String&gt; enumMap = new EnumMap&lt;&gt;(PlayerType.class);</span><br><span class="line">enumMap.put(PlayerType.BASKETBALL,&quot;篮球运动员&quot;);</span><br><span class="line">enumMap.put(PlayerType.FOOTBALL,&quot;足球运动员&quot;);</span><br><span class="line">enumMap.put(PlayerType.TENNIS,&quot;网球运动员&quot;);</span><br><span class="line">System.out.println(enumMap);</span><br><span class="line">System.out.println(enumMap.get(PlayerType.BASKETBALL));</span><br><span class="line">System.out.println(enumMap.containsKey(PlayerType.BASKETBALL));</span><br><span class="line">System.out.println(enumMap.remove(PlayerType.BASKETBALL));</span><br></pre></td></tr></table></figure>
<p>“来看一下输出结果。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;TENNIS=网球运动员, FOOTBALL=足球运动员, BASKETBALL=篮球运动员&#125;</span><br><span class="line">篮球运动员</span><br><span class="line">true</span><br><span class="line">篮球运动员</span><br></pre></td></tr></table></figure>
<p>“除了以上这些，《Effective Java》这本书里还提到了一点，如果要实现单例的话，最好使用枚举的方式。”我说。</p>
<p>“等等二哥，单例是什么？”三妹没等我往下说，就连忙问道。</p>
<p>“单例（Singleton）用来保证一个类仅有一个对象，并提供一个访问它的全局访问点，在一个进程中。因为这个类只有一个对象，所以就不能再使用 new 关键字来创建新的对象了。”</p>
<p>“Java 标准库有一些类就是单例，比如说 Runtime 这个类。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runtime runtime = Runtime.getRuntime();</span><br></pre></td></tr></table></figure>
<p>“Runtime 类可以用来获取 Java 程序运行时的环境。”</p>
<p>“关于单例，懂了些吧？”我问三妹。</p>
<p>“噢噢噢噢。”三妹点了点头。</p>
<p>“通常情况下，实现单例并非易事，来看下面这种写法。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">    private volatile static Singleton singleton; </span><br><span class="line">    private Singleton ()&#123;&#125;  </span><br><span class="line">    public static Singleton getSingleton() &#123;  </span><br><span class="line">    if (singleton == null) &#123;</span><br><span class="line">        synchronized (Singleton.class) &#123; </span><br><span class="line">        if (singleton == null) &#123;  </span><br><span class="line">            singleton = new Singleton(); </span><br><span class="line">        &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“要用到 volatile、synchronized 关键字等等，但枚举的出现，让代码量减少到极致。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public enum EasySingleton&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“就这？”三妹睁大了眼睛。</p>
<p>“对啊，枚举默认实现了 Serializable 接口，因此 Java 虚拟机可以保证该类为单例，这与传统的实现方式不大相同。传统方式中，我们必须确保单例在反序列化期间不能创建任何新实例。”我说。</p>
<p>“好了，关于枚举就讲这么多吧，三妹，你把这些代码都手敲一遍吧！”</p>
<p>“好勒，这就安排。二哥，你去休息吧。”</p>
<h1 id="4-Java-集合框架"><a href="#4-Java-集合框架" class="headerlink" title="4 Java 集合框架"></a>4 Java 集合框架</h1><h2 id="4-1-List、Set、Map、队列，全面解析"><a href="#4-1-List、Set、Map、队列，全面解析" class="headerlink" title="4.1 List、Set、Map、队列，全面解析"></a>4.1 List、Set、Map、队列，全面解析</h2><p>眼瞅着三妹的王者荣耀杀得正嗨，我趁机喊到：“别打了，三妹，我们来一起学习 Java 的集合框架吧。”</p>
<p>“才不要呢，等我打完这一局啊。”三妹倔强地说。</p>
<p>“好吧。”我只好摊摊手地说，“那我先画张集合框架的结构图等着你。”</p>
<p><img src="\assets\note\image-20231009161608357.png" alt="image-20231009161608357"></p>
<p>“完了没？三妹。”</p>
<p>“完了好一会儿了，二哥，你图画得真慢，让我瞧瞧怎么样？”</p>
<p>“害，图要画得清晰明了，不容易的。三妹，你瞧，不错吧。”</p>
<p>“哇，果然很棒，哥，你可真认真！”</p>
<p>“我来简单介绍一下吧，Java 集合框架可以分为两条大的支线：”</p>
<ul>
<li>Collection，主要由 List、Set、Queue 组成，List 代表有序、可重复的集合，典型代表就是封装了动态数组的 ArrayList 和封装了链表的 LinkedList；Set 代表无序、不可重复的集合，典型代表就是 HashSet 和 TreeSet；Queue 代表队列，典型代表就是双端队列 ArrayDeque，以及优先级队列 PriorityQueue。</li>
<li>Map，代表键值对的集合，典型代表就是 HashMap。</li>
</ul>
<p><strong>01、List </strong></p>
<p>List 的特点是存取有序，可以存放重复的元素，可以用下标对元素进行操作。</p>
<p><strong>1）ArrayList </strong></p>
<p>先来一段 ArrayList 的增删改查，学会用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个集合</span><br><span class="line">ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">// 添加元素</span><br><span class="line">list.add(&quot;王二&quot;);</span><br><span class="line">list.add(&quot;沉默&quot;);</span><br><span class="line">list.add(&quot;陈清扬&quot;);</span><br><span class="line">// 遍历集合 for 循环</span><br><span class="line">for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">    String s = list.get(i);</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line">// 遍历集合 for each</span><br><span class="line">for (String s : list) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line">// 删除元素</span><br><span class="line">list.remove(1);</span><br><span class="line">// 遍历集合</span><br><span class="line">for (String s : list) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line">// 修改元素</span><br><span class="line">list.set(1, &quot;王二狗&quot;);</span><br><span class="line">// 遍历集合</span><br><span class="line">for (String s : list) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单介绍一下 ArrayList 的特征，后面还会详细讲。</p>
<ul>
<li>ArrayList 是由数组实现的，支持随机存取，也就是可以通过下标直接存取元素；</li>
<li>从尾部插入和删除元素会比较快捷，从中间插入和删除元素会比较低效，因为涉及到数组元素的复制和移动；</li>
<li>如果内部数组的容量不足时会自动扩容，因此当元素非常庞大的时候，效率会比较低。</li>
</ul>
<p><strong>2）LinkedList </strong></p>
<p>同样先来一段 LinkedList 的增删改查，和 ArrayList 几乎没什么差别。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个集合</span><br><span class="line">LinkedList&lt;String&gt; list = new LinkedList&lt;String&gt;();</span><br><span class="line">// 添加元素</span><br><span class="line">list.add(&quot;王二&quot;);</span><br><span class="line">list.add(&quot;沉默&quot;);</span><br><span class="line">list.add(&quot;陈清扬&quot;);</span><br><span class="line">// 遍历集合 for 循环</span><br><span class="line">for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">    String s = list.get(i);</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line">// 遍历集合 for each</span><br><span class="line">for (String s : list) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line">// 删除元素</span><br><span class="line">list.remove(1);</span><br><span class="line">// 遍历集合</span><br><span class="line">for (String s : list) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line">// 修改元素</span><br><span class="line">list.set(1, &quot;王二狗&quot;);</span><br><span class="line">// 遍历集合</span><br><span class="line">for (String s : list) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过，LinkedList 和 ArrayList 仍然有较大的不同，后面也会详细地讲。</p>
<ul>
<li>LinkedList 是由双向链表实现的，不支持随机存取，只能从一端开始遍历，直到找到需要的元素后返回；</li>
<li>任意位置插入和删除元素都很方便，因为只需要改变前一个节点和后一个节点的引用即可，不像 ArrayList 那样需要复制和移动数组元素；</li>
<li>因为每个元素都存储了前一个和后一个节点的引用，所以相对来说，占用的内存空间会比 ArrayList 多一些。</li>
</ul>
<p><strong>3）Vector 和 Stack </strong></p>
<p>List 的实现类还有一个 Vector，是一个元老级的类，比 ArrayList 出现得更早。ArrayList 和 Vector 非常相似，只不过 Vector 是线程安全的，像 get、set、add 这些方法都加了 synchronized 关键字，就导致执行执行效率会比较低，所以现在已经很少用了。</p>
<p>我就不写太多代码了，只看一下 add 方法的源码就明白了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public synchronized boolean add(E e) &#123;</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种加了同步方法的类，注定会被淘汰掉，就像StringBuilder取代StringBuffer那样。JDK 源码也说了：</p>
<blockquote>
<p>如果不需要线程安全，建议使用ArrayList代替Vector。</p>
</blockquote>
<p><img src="\assets\note\image-20231009162149917.png" alt="image-20231009162149917"></p>
<p>Stack 是 Vector 的一个子类，本质上也是由动态数组实现的，只不过还实现了先进后出的功能（在 get、set、add 方法的基础上追加了 pop「返回并移除栈顶的元素」、peek「只返回栈顶元素」等方法），所以叫栈。</p>
<p>下面是这两个方法的源码，增删改查我就不写了，和 ArrayList 和 LinkedList 几乎一样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public synchronized E pop() &#123;</span><br><span class="line">    E       obj;</span><br><span class="line">    int     len = size();</span><br><span class="line">    obj = peek();</span><br><span class="line">    removeElementAt(len - 1);</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br><span class="line">public synchronized E peek() &#123;</span><br><span class="line">    int     len = size();</span><br><span class="line">    if (len == 0)</span><br><span class="line">        throw new EmptyStackException();</span><br><span class="line">    return elementAt(len - 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过，由于 Stack 执行效率比较低（方法上同样加了 synchronized 关键字），就被双端队列 ArrayDeque 取代了（下面会介绍）。</p>
<p><strong>02、Set </strong></p>
<p>Set 的特点是存取无序，不可以存放重复的元素，不可以用下标对元素进行操作，和 List 有很多不同。</p>
<p><strong>1）HashSet </strong></p>
<p>HashSet 其实是由 HashMap 实现的，只不过值由一个固定的 Object 对象填充，而键用于操作。来简单看一下它的源码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class HashSet&lt;E&gt;</span><br><span class="line">    extends AbstractSet&lt;E&gt;</span><br><span class="line">    implements Set&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    private transient HashMap&lt;E,Object&gt; map;</span><br><span class="line">    // Dummy value to associate with an Object in the backing Map</span><br><span class="line">    private static final Object PRESENT = new Object();</span><br><span class="line">    public HashSet() &#123;</span><br><span class="line">        map = new HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean add(E e) &#123;</span><br><span class="line">        return map.put(e, PRESENT)==null;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean remove(Object o) &#123;</span><br><span class="line">        return map.remove(o)==PRESENT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际开发中，HashSet 并不常用，比如，如果我们需要按照顺序存储一组元素，那么ArrayList和LinkedList可能更适合；如果我们需要存储键值对并根据键进行查找，那么HashMap可能更适合。</p>
<p>当然，在某些情况下，HashSet仍然是最好的选择。例如，当我们需要快速查找一个元素是否存在于某个集合中，并且我们不需要对元素进行排序时，HashSet可以提供高效的性能。</p>
<p>来一段增删改查体验一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个新的HashSet</span><br><span class="line">HashSet&lt;String&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">// 添加元素</span><br><span class="line">set.add(&quot;沉默&quot;);</span><br><span class="line">set.add(&quot;王二&quot;);</span><br><span class="line">set.add(&quot;陈清扬&quot;);</span><br><span class="line">// 输出HashSet的元素个数</span><br><span class="line">System.out.println(&quot;HashSet size: &quot; + set.size()); // output: 3</span><br><span class="line">// 判断元素是否存在于HashSet中</span><br><span class="line">boolean containsWanger = set.contains(&quot;王二&quot;);</span><br><span class="line">System.out.println(&quot;Does set contain &#x27;王二&#x27;? &quot; + containsWanger); // output: true</span><br><span class="line">// 删除元素</span><br><span class="line">boolean removeWanger = set.remove(&quot;王二&quot;);</span><br><span class="line">System.out.println(&quot;Removed &#x27;王二&#x27;? &quot; + removeWanger); // output: true</span><br><span class="line">// 修改元素，需要先删除后添加</span><br><span class="line">boolean removeChenmo = set.remove(&quot;沉默&quot;);</span><br><span class="line">boolean addBuChenmo = set.add(&quot;不沉默&quot;);</span><br><span class="line">System.out.println(&quot;Modified set? &quot; + (removeChenmo &amp;&amp; addBuChenmo)); // output: true</span><br><span class="line">// 输出修改后的HashSet</span><br><span class="line">System.out.println(&quot;HashSet after modification: &quot; + set); // output: [陈清扬, 不沉默]</span><br></pre></td></tr></table></figure>
<p><strong>2）LinkedHashSet </strong></p>
<p>LinkedHashSet 虽然继承自 HashSet，其实是由 LinkedHashMap 实现的。</p>
<p>这是 LinkedHashSet 的无参构造方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public LinkedHashSet() &#123;</span><br><span class="line">    super(16, .75f, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>super 的意思是它将调用父类的 HashSet 的一个有参构造方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123;</span><br><span class="line">    map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到 LinkedHashMap 了吧，这个我们后面会去讲。</p>
<p>好吧，来看一段 LinkedHashSet 的增删改查吧。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">LinkedHashSet&lt;String&gt; set = new LinkedHashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">// 添加元素</span><br><span class="line">set.add(&quot;沉默&quot;);</span><br><span class="line">set.add(&quot;王二&quot;);</span><br><span class="line">set.add(&quot;陈清扬&quot;);</span><br><span class="line"></span><br><span class="line">// 删除元素</span><br><span class="line">set.remove(&quot;王二&quot;);</span><br><span class="line"></span><br><span class="line">// 修改元素</span><br><span class="line">set.remove(&quot;沉默&quot;);</span><br><span class="line">set.add(&quot;沉默的力量&quot;);</span><br><span class="line"></span><br><span class="line">// 查找元素</span><br><span class="line">boolean hasChenQingYang = set.contains(&quot;陈清扬&quot;);</span><br><span class="line">System.out.println(&quot;set包含陈清扬吗？&quot; + hasChenQingYang);</span><br></pre></td></tr></table></figure>
<p>在以上代码中，我们首先创建了一个LinkedHashSet对象，然后使用add方法依次添加了三个元素：沉默、王二和陈清扬。接着，我们使用remove方法删除了王二这个元素，并使用remove和add方法修改了沉默这个元素。最后，我们使用contains方法查找了陈清扬这个元素是否存在于set中，并打印了结果。</p>
<p>LinkedHashSet是一种基于哈希表实现的Set接口，它继承自HashSet，并且使用链表维护了元素的插入顺序。因此，它既具有HashSet的快速查找、插入和删除操作的优点，又可以维护元素的插入顺序。</p>
<p><strong>3）TreeSet </strong></p>
<p>“二哥，不用你讲了，我能猜到，TreeSet 是由 TreeMap（后面会讲） 实现的，只不过同样操作的键位，值由一个固定的 Object 对象填充。”</p>
<p>哇，三妹都学会了推理。</p>
<p>是的，与 TreeMap 相似，TreeSet 是一种基于红黑树实现的有序集合，它实现了 SortedSet 接口，可以自动对集合中的元素进行排序。按照键的自然顺序或指定的比较器顺序进行排序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 TreeSet 对象</span><br><span class="line">TreeSet&lt;String&gt; set = new TreeSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">// 添加元素</span><br><span class="line">set.add(&quot;沉默&quot;);</span><br><span class="line">set.add(&quot;王二&quot;);</span><br><span class="line">set.add(&quot;陈清扬&quot;);</span><br><span class="line">System.out.println(set); // 输出 [沉默, 王二, 陈清扬]</span><br><span class="line"></span><br><span class="line">// 删除元素</span><br><span class="line">set.remove(&quot;王二&quot;);</span><br><span class="line">System.out.println(set); // 输出 [沉默, 陈清扬]</span><br><span class="line"></span><br><span class="line">// 修改元素：TreeSet 中的元素不支持直接修改，需要先删除再添加</span><br><span class="line">set.remove(&quot;陈清扬&quot;);</span><br><span class="line">set.add(&quot;陈青阳&quot;);</span><br><span class="line">System.out.println(set); // 输出 [沉默, 陈青阳]</span><br><span class="line"></span><br><span class="line">// 查找元素</span><br><span class="line">System.out.println(set.contains(&quot;沉默&quot;)); // 输出 true</span><br><span class="line">System.out.println(set.contains(&quot;王二&quot;)); // 输出 false</span><br></pre></td></tr></table></figure>
<p>需要注意的是，TreeSet 不允许插入 null 元素，否则会抛出 NullPointerException 异常。</p>
<p>“总体上来说，Set 集合不是关注的重点，因为底层都是由 Map 实现的，为什么要用 Map 实现呢？三妹你能猜到原因吗？”</p>
<p>“让我想想。”</p>
<p>“嗯？难道是因为 Map 的键不允许重复、无序吗？”老天，竟然被三妹猜到了。</p>
<p>“是的，你这水平长进了呀，三妹。”</p>
<p><strong>03、Queue </strong></p>
<p>Queue，也就是队列，通常遵循先进先出（FIFO）的原则，新元素插入到队列的尾部，访问元素返回队列的头部。</p>
<p><strong>1）ArrayDeque </strong></p>
<p>从名字上可以看得出，ArrayDeque 是一个基于数组实现的双端队列，为了满足可以同时在数组两端插入或删除元素的需求，数组必须是循环的，也就是说数组的任何一点都可以被看作是起点或者终点。</p>
<p>这是一个包含了 4 个元素的双端队列，和一个包含了 5 个元素的双端队列。</p>
<p><img src="\assets\note\image-20231010092447145.png" alt="image-20231010092447145"></p>
<p>head 指向队首的第一个有效的元素，tail 指向队尾第一个可以插入元素的空位，因为是循环数组，所以 head 不一定从是从 0 开始，tail 也不一定总是比 head 大。</p>
<p>来一段ArrayDeque的增删改查吧。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个ArrayDeque</span><br><span class="line">ArrayDeque&lt;String&gt; deque = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">// 添加元素</span><br><span class="line">deque.add(&quot;沉默&quot;);</span><br><span class="line">deque.add(&quot;王二&quot;);</span><br><span class="line">deque.add(&quot;陈清扬&quot;);</span><br><span class="line"></span><br><span class="line">// 删除元素</span><br><span class="line">deque.remove(&quot;王二&quot;);</span><br><span class="line"></span><br><span class="line">// 修改元素</span><br><span class="line">deque.remove(&quot;沉默&quot;);</span><br><span class="line">deque.add(&quot;沉默的力量&quot;);</span><br><span class="line"></span><br><span class="line">// 查找元素</span><br><span class="line">boolean hasChenQingYang = deque.contains(&quot;陈清扬&quot;);</span><br><span class="line">System.out.println(&quot;deque包含陈清扬吗？&quot; + hasChenQingYang);</span><br></pre></td></tr></table></figure>
<p><strong>2）LinkedList </strong></p>
<p>LinkedList 一般应该归在 List 下，只不过，它也实现了 Deque 接口，可以作为队列来使用。等于说，LinkedList 同时实现了 Stack、Queue、PriorityQueue 的所有功能。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedList&lt;E&gt;</span><br><span class="line">    extends AbstractSequentialList&lt;E&gt;</span><br><span class="line">    implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>换句话说，LinkedList 和 ArrayDeque 都是 Java 集合框架中的双向队列（deque），它们都支持在队列的两端进行元素的插入和删除操作。不过，LinkedList 和 ArrayDeque 在实现上有一些不同：</p>
<ul>
<li>底层实现方式不同：LinkedList 是基于链表实现的，而 ArrayDeque 是基于数组实现的。</li>
<li>随机访问的效率不同：由于底层实现方式的不同，LinkedList 对于随机访问的效率较低，时间复杂度为 O(n)，而 ArrayDeque 可以通过下标随机访问元素，时间复杂度为 O(1)。</li>
<li>迭代器的效率不同：LinkedList 对于迭代器的效率比较低，因为需要通过链表进行遍历，时间复杂度为 O(n)，而 ArrayDeque 的迭代器效率比较高，因为可以直接访问数组中的元素，时间复杂度为 O(1)。</li>
<li>内存占用不同：由于 LinkedList 是基于链表实现的，它在存储元素时需要额外的空间来存储链表节点，因此内存占用相对较高，而 ArrayDeque 是基于数组实现的，内存占用相对较低。</li>
</ul>
<p>因此，在选择使用 LinkedList 还是 ArrayDeque 时，需要根据具体的业务场景和需求来选择。如果需要在双向队列的两端进行频繁的插入和删除操作，并且需要随机访问元素，可以考虑使用 ArrayDeque；如果需要在队列中间进行频繁的插入和删除操作，可以考虑使用 LinkedList。</p>
<p>来一段 LinkedList 作为队列时候的增删改查吧，注意和它作为 List 的时候有很大的不同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 LinkedList 对象</span><br><span class="line">LinkedList&lt;String&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">// 添加元素</span><br><span class="line">queue.offer(&quot;沉默&quot;);</span><br><span class="line">queue.offer(&quot;王二&quot;);</span><br><span class="line">queue.offer(&quot;陈清扬&quot;);</span><br><span class="line">System.out.println(queue); // 输出 [沉默, 王二, 陈清扬]</span><br><span class="line"></span><br><span class="line">// 删除元素</span><br><span class="line">queue.poll();</span><br><span class="line">System.out.println(queue); // 输出 [王二, 陈清扬]</span><br><span class="line"></span><br><span class="line">// 修改元素：LinkedList 中的元素不支持直接修改，需要先删除再添加</span><br><span class="line">String first = queue.poll();</span><br><span class="line">queue.offer(&quot;王大二&quot;);</span><br><span class="line">System.out.println(queue); // 输出 [陈清扬, 王大二]</span><br><span class="line"></span><br><span class="line">// 查找元素：LinkedList 中的元素可以使用 get() 方法进行查找</span><br><span class="line">System.out.println(queue.get(0)); // 输出 陈清扬</span><br><span class="line">System.out.println(queue.contains(&quot;沉默&quot;)); // 输出 false</span><br><span class="line"></span><br><span class="line">// 查找元素：使用迭代器的方式查找陈清扬</span><br><span class="line">// 使用迭代器依次遍历元素并查找</span><br><span class="line">Iterator&lt;String&gt; iterator = queue.iterator();</span><br><span class="line">while (iterator.hasNext()) &#123;</span><br><span class="line">    String element = iterator.next();</span><br><span class="line">    if (element.equals(&quot;陈清扬&quot;)) &#123;</span><br><span class="line">        System.out.println(&quot;找到了：&quot; + element);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用 LinkedList 作为队列时，可以使用 offer() 方法将元素添加到队列的末尾，使用 poll() 方法从队列的头部删除元素。另外，由于 LinkedList 是链表结构，不支持随机访问元素，因此不能使用下标访问元素，需要使用迭代器或者 poll() 方法依次遍历元素。</p>
<p><strong>3）PriorityQueue </strong></p>
<p>PriorityQueue 是一种优先级队列，它的出队顺序与元素的优先级有关，执行 remove 或者 poll 方法，返回的总是优先级最高的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 PriorityQueue 对象</span><br><span class="line">PriorityQueue&lt;String&gt; queue = new PriorityQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">// 添加元素</span><br><span class="line">queue.offer(&quot;沉默&quot;);</span><br><span class="line">queue.offer(&quot;王二&quot;);</span><br><span class="line">queue.offer(&quot;陈清扬&quot;);</span><br><span class="line">System.out.println(queue); // 输出 [沉默, 王二, 陈清扬]</span><br><span class="line"></span><br><span class="line">// 删除元素</span><br><span class="line">queue.poll();</span><br><span class="line">System.out.println(queue); // 输出 [王二, 陈清扬]</span><br><span class="line"></span><br><span class="line">// 修改元素：PriorityQueue 不支持直接修改元素，需要先删除再添加</span><br><span class="line">String first = queue.poll();</span><br><span class="line">queue.offer(&quot;张三&quot;);</span><br><span class="line">System.out.println(queue); // 输出 [张三, 陈清扬]</span><br><span class="line"></span><br><span class="line">// 查找元素：PriorityQueue 不支持随机访问元素，只能访问队首元素</span><br><span class="line">System.out.println(queue.peek()); // 输出 张三</span><br><span class="line">System.out.println(queue.contains(&quot;陈清扬&quot;)); // 输出 true</span><br><span class="line"></span><br><span class="line">// 通过 for 循环的方式查找陈清扬</span><br><span class="line">for (String element : queue) &#123;</span><br><span class="line">    if (element.equals(&quot;陈清扬&quot;)) &#123;</span><br><span class="line">        System.out.println(&quot;找到了：&quot; + element);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要想有优先级，元素就需要实现 Comparable 接口或者 Comparator 接口（我们后面会讲）。</p>
<p>这里先来一段通过实现 Comparator 接口按照年龄姓名排序的优先级队列吧。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Comparator;</span><br><span class="line">import java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line">class Student &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int chineseScore;</span><br><span class="line">    private int mathScore;</span><br><span class="line">    </span><br><span class="line">    public Student(String name, int chineseScore, int mathScore) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.chineseScore = chineseScore;</span><br><span class="line">        this.mathScore = mathScore;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int getChineseScore() &#123;</span><br><span class="line">        return chineseScore;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int getMathScore() &#123;</span><br><span class="line">        return mathScore;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Student&#123;&quot; +</span><br><span class="line">                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, 总成绩=&quot; + (chineseScore + mathScore) +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class StudentComparator implements Comparator&lt;Student&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(Student s1, Student s2) &#123;</span><br><span class="line">        // 比较总成绩</span><br><span class="line">        return Integer.compare(s2.getChineseScore() + s2.getMathScore(),</span><br><span class="line">                s1.getChineseScore() + s1.getMathScore());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class PriorityQueueComparatorExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 创建一个按照总成绩排序的优先级队列</span><br><span class="line">        PriorityQueue&lt;Student&gt; queue = new PriorityQueue&lt;&gt;(new StudentComparator());</span><br><span class="line">        // 添加元素</span><br><span class="line">        queue.offer(new Student(&quot;王二&quot;, 80, 90));</span><br><span class="line">        System.out.println(queue);</span><br><span class="line">        queue.offer(new Student(&quot;陈清扬&quot;, 95, 95));</span><br><span class="line">        System.out.println(queue);</span><br><span class="line">        queue.offer(new Student(&quot;小驼铃&quot;, 90, 95));</span><br><span class="line">        System.out.println(queue);</span><br><span class="line">        queue.offer(new Student(&quot;沉默&quot;, 90, 80));</span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            System.out.print(queue.poll() + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Student 是一个学生对象，包含姓名、语文成绩和数学成绩。</p>
<p>StudentComparator 实现了 Comparator 接口，对总成绩做了一个排序。</p>
<p>PriorityQueue 是一个优先级队列，参数为 StudentComparator，然后我们添加了 4 个学生对象进去。</p>
<p>来看一下输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Student&#123;name=&#x27;王二&#x27;, 总成绩=170&#125;]</span><br><span class="line">[Student&#123;name=&#x27;陈清扬&#x27;, 总成绩=190&#125;, Student&#123;name=&#x27;王二&#x27;, 总成绩=170&#125;]</span><br><span class="line">[Student&#123;name=&#x27;陈清扬&#x27;, 总成绩=190&#125;, Student&#123;name=&#x27;王二&#x27;, 总成绩=170&#125;, Student&#123;name=&#x27;小</span><br><span class="line">驼铃&#x27;, 总成绩=185&#125;]</span><br><span class="line">Student&#123;name=&#x27;陈清扬&#x27;, 总成绩=190&#125; Student&#123;name=&#x27;小驼铃&#x27;, 总成绩=185&#125; Student&#123;name=&#x27;沉</span><br><span class="line">默&#x27;, 总成绩=170&#125; Student&#123;name=&#x27;王二&#x27;, 总成绩=170&#125; </span><br></pre></td></tr></table></figure>
<p>我们使用 offer 方法添加元素，最后用 while 循环遍历元素（通过 poll 方法取出元素），从结果可以看得出，PriorityQueue按照学生的总成绩由高到低进行了排序。</p>
<p><strong>04、Map </strong></p>
<p>Map 保存的是键值对，键要求保持唯一性，值可以重复。</p>
<p><strong>1）HashMap </strong></p>
<p>HashMap 实现了 Map 接口，可以根据键快速地查找对应的值——通过哈希函数将键映射到哈希表中的一个索引位置，从而实现快速访问。后面会详细聊到。</p>
<p>这里先大致了解一下 HashMap 的特点：</p>
<ul>
<li>HashMap 中的键和值都可以为 null。如果键为 null，则将该键映射到哈希表的第一个位置。</li>
<li>可以使用迭代器或者 forEach 方法遍历 HashMap 中的键值对。</li>
<li>HashMap 有一个初始容量和一个负载因子。初始容量是指哈希表的初始大小，负载因子是指哈希表在扩容之前可以存储的键值对数量与哈希表大小的比率。默认的初始容量是 16，负载因子是 0.75。</li>
</ul>
<p>来个简单的增删改查吧。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 HashMap 对象</span><br><span class="line">HashMap&lt;String, String&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">// 添加键值对</span><br><span class="line">hashMap.put(&quot;沉默&quot;, &quot;cenzhong&quot;);</span><br><span class="line">hashMap.put(&quot;王二&quot;, &quot;wanger&quot;);</span><br><span class="line">hashMap.put(&quot;陈清扬&quot;, &quot;chenqingyang&quot;);</span><br><span class="line"></span><br><span class="line">// 获取指定键的值</span><br><span class="line">String value1 = hashMap.get(&quot;沉默&quot;);</span><br><span class="line">System.out.println(&quot;沉默对应的值为：&quot; + value1);</span><br><span class="line"></span><br><span class="line">// 修改键对应的值</span><br><span class="line">hashMap.put(&quot;沉默&quot;, &quot;chenmo&quot;);</span><br><span class="line">String value2 = hashMap.get(&quot;沉默&quot;);</span><br><span class="line">System.out.println(&quot;修改后沉默对应的值为：&quot; + value2);</span><br><span class="line"></span><br><span class="line">// 删除指定键的键值对</span><br><span class="line">hashMap.remove(&quot;王二&quot;);</span><br><span class="line"></span><br><span class="line">// 遍历 HashMap</span><br><span class="line">for (String key : hashMap.keySet()) &#123;</span><br><span class="line">    String value = hashMap.get(key);</span><br><span class="line">    System.out.println(key + &quot; 对应的值为：&quot; + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2）LinkedHashMap </strong></p>
<p>HashMap 已经非常强大了，但它是无序的。如果我们需要一个有序的Map，就要用到 LinkedHashMap。</p>
<p>LinkedHashMap 是 HashMap 的子类，它使用链表来记录插入/访问元素的顺序。</p>
<p>LinkedHashMap 可以看作是 HashMap + LinkedList 的合体，它使用了哈希表来存储数据，又用了双向链表来维持顺序。</p>
<p>来一个简单的例子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 LinkedHashMap，插入的键值对为 沉默 王二 陈清扬</span><br><span class="line">LinkedHashMap&lt;String, String&gt; linkedHashMap = new LinkedHashMap&lt;&gt;();</span><br><span class="line">linkedHashMap.put(&quot;沉默&quot;, &quot;cenzhong&quot;);</span><br><span class="line">linkedHashMap.put(&quot;王二&quot;, &quot;wanger&quot;);</span><br><span class="line">linkedHashMap.put(&quot;陈清扬&quot;, &quot;chenqingyang&quot;);</span><br><span class="line"></span><br><span class="line">// 遍历 LinkedHashMap</span><br><span class="line">for (String key : linkedHashMap.keySet()) &#123;</span><br><span class="line">    String value = linkedHashMap.get(key);</span><br><span class="line">    System.out.println(key + &quot; 对应的值为：&quot; + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">沉默 对应的值为：cenzhong</span><br><span class="line">王二 对应的值为：wanger</span><br><span class="line">陈清扬 对应的值为：chenqingyang</span><br></pre></td></tr></table></figure>
<p>从结果中可以看得出来，LinkedHashMap 维持了键值对的插入顺序，对吧？为了和 LinkedHashMap 做对比，我们用同样的数据试验一下 HashMap。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个HashMap，插入的键值对为 沉默 王二 陈清扬</span><br><span class="line">HashMap&lt;String, String&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">hashMap.put(&quot;沉默&quot;, &quot;cenzhong&quot;);</span><br><span class="line">hashMap.put(&quot;王二&quot;, &quot;wanger&quot;);</span><br><span class="line">hashMap.put(&quot;陈清扬&quot;, &quot;chenqingyang&quot;);</span><br><span class="line"></span><br><span class="line">// 遍历 HashMap</span><br><span class="line">for (String key : hashMap.keySet()) &#123;</span><br><span class="line">    String value = hashMap.get(key);</span><br><span class="line">    System.out.println(key + &quot; 对应的值为：&quot; + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">沉默 对应的值为：cenzhong</span><br><span class="line">陈清扬 对应的值为：chenqingyang</span><br><span class="line">王二 对应的值为：wanger</span><br></pre></td></tr></table></figure>
<p>HashMap 没有维持键值对的插入顺序，对吧？</p>
<p><strong>3）TreeMap </strong></p>
<p>TreeMap 实现了 SortedMap 接口，可以自动将键按照自然顺序或指定的比较器顺序排序，并保证其元素的顺序。内部使用红黑树来实现键的排序和查找。</p>
<p>同样来一个增删改查的 demo：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 TreeMap 对象</span><br><span class="line">Map&lt;String, String&gt; treeMap = new TreeMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">// 向 TreeMap 中添加键值对</span><br><span class="line">treeMap.put(&quot;沉默&quot;, &quot;cenzhong&quot;);</span><br><span class="line">treeMap.put(&quot;王二&quot;, &quot;wanger&quot;);</span><br><span class="line">treeMap.put(&quot;陈清扬&quot;, &quot;chenqingyang&quot;);</span><br><span class="line"></span><br><span class="line">// 查找键值对</span><br><span class="line">String name = &quot;沉默&quot;;</span><br><span class="line">if (treeMap.containsKey(name)) &#123;</span><br><span class="line">    System.out.println(&quot;找到了 &quot; + name + &quot;: &quot; + treeMap.get(name));</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    System.out.println(&quot;没有找到 &quot; + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 修改键值对</span><br><span class="line">name = &quot;王二&quot;;</span><br><span class="line">if (treeMap.containsKey(name)) &#123;</span><br><span class="line">    System.out.println(&quot;修改前的 &quot; + name + &quot;: &quot; + treeMap.get(name));</span><br><span class="line">    treeMap.put(name, &quot;newWanger&quot;);</span><br><span class="line">    System.out.println(&quot;修改后的 &quot; + name + &quot;: &quot; + treeMap.get(name));</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    System.out.println(&quot;没有找到 &quot; + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除键值对</span><br><span class="line">name = &quot;陈清扬&quot;;</span><br><span class="line">if (treeMap.containsKey(name)) &#123;</span><br><span class="line">    System.out.println(&quot;删除前的 &quot; + name + &quot;: &quot; + treeMap.get(name));</span><br><span class="line">    treeMap.remove(name);</span><br><span class="line">    System.out.println(&quot;删除后的 &quot; + name + &quot;: &quot; + treeMap.get(name));</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    System.out.println(&quot;没有找到 &quot; + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 遍历 TreeMap</span><br><span class="line">for (Map.Entry&lt;String, String&gt; entry : treeMap.entrySet()) &#123;</span><br><span class="line">    System.out.println(entry.getKey() + &quot;: &quot; + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与 HashMap 不同的是，TreeMap 会按照键的顺序来进行排序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 TreeMap 对象</span><br><span class="line">Map&lt;String, String&gt; treeMap = new TreeMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">// 向 TreeMap 中添加键值对</span><br><span class="line">treeMap.put(&quot;c&quot;, &quot;cat&quot;);</span><br><span class="line">treeMap.put(&quot;a&quot;, &quot;apple&quot;);</span><br><span class="line">treeMap.put(&quot;b&quot;, &quot;banana&quot;);</span><br><span class="line"></span><br><span class="line">// 遍历 TreeMap</span><br><span class="line">for (Map.Entry&lt;String, String&gt; entry : treeMap.entrySet()) &#123;</span><br><span class="line">    System.out.println(entry.getKey() + &quot;: &quot; + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a: apple</span><br><span class="line">b: banana</span><br><span class="line">c: cat</span><br></pre></td></tr></table></figure>
<p>默认情况下，已经按照键的自然顺序排过了。</p>
<p>“好了，三妹，关于集合框架，我们就先聊到这，随后我们会针对常用的容器进行详细地讲解，比如说 ArrayList、LinkedList、HashMap 等。”</p>
<p>“哇，二哥，这篇讲的东西可真不少，虽然都是比较基础的，但对于我一个小白来说，还是需要花点时间去消化的。”三妹嘟嘟嘴说到。</p>
<h2 id="4-2-时间复杂度，了解下"><a href="#4-2-时间复杂度，了解下" class="headerlink" title="4.2 时间复杂度，了解下"></a>4.2 时间复杂度，了解下</h2><p>“二哥，为什么要讲时间复杂度呀？”三妹问。</p>
<p>“因为接下来要用到啊。后面我们学习 ArrayList、LinkedList 的时候，会比较两者在增删改查时的执行效率，而时间复杂度是衡量执行效率的一个重要标准。”我说。</p>
<p>“到时候跑一下代码，统计一下前后的时间差不更准确吗？”三妹反问道。</p>
<p>“实际上，你说的是另外一种评估方法，这种评估方法可以得出非常准确的数值，但也有很大的局限性。”我不急不慢地说。</p>
<p>第一，测试结果会受到测试环境的影响。你比如说，同样的代码，在我这台 iMac 上跑出来的时间和在你那台华为的 MacBook 上跑出的时间可能就差别很大。</p>
<p>第二，测试结果会受到测试数据的影响。你比如说，一个排序后的数组和一个没有排序后的数组，调用了同一个查询方法，得出来的结果可能会差别特别大。</p>
<p>“因此，我们需要这种不依赖于具体测试环境和测试数据就能粗略地估算出执行效率的方法，时间复杂度就是其中的一种，还有一种是空间复杂度。”我继续补充道，“如果你后面刷 LeetCode的话，对时间复杂度这个概念也会比较依赖。”</p>
<p>来看下面这段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static int sum(int n) &#123;</span><br><span class="line">    int sum = 0; // 第 1 行</span><br><span class="line">    for (int i=0;i&lt;n;i++) &#123; // 第 2 行</span><br><span class="line">        sum = sum + 1; // 第 3 行</span><br><span class="line">    &#125; // 第 4 行</span><br><span class="line">    return sum; // 第 5 行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码非常简单，方法体里总共 5 行代码，包括“}”那一行。每段代码的执行时间可能都不大一样，但假设我们认为每行代码的执行时间是一样的，比如说 unit_time，那么这段代码总的执行时间为多少呢？</p>
<p>“这个我知道呀！”三妹喊道，“第 1、5 行需要 2 个 unit_time，第 2、3 行需要 2nunit_time，总的时间就是 2(n+1)*unit_time。”</p>
<p>“对，一段代码的执行时间 T(n) 和总的执行次数成正比，也就是说，代码执行的次数越多，花费的时间就越多。”我总结道，“这个规律可以用一个公式来表达：”</p>
<blockquote>
<p>T(n) = O(f(n))</p>
</blockquote>
<p>f(n) 表示代码总的执行次数，大写 O 表示代码的执行时间 T(n) 和 f(n) 成正比。</p>
<p>这也就是大 O 表示法，它不关心代码具体的执行时间是多少，它关心的是代码执行时间的变化趋势，这也就是时间复杂度这个概念的由来。</p>
<p>对于上面那段代码 sum() 来说，影响时间复杂度的主要是第 2 行代码，其余的，像系数 2、常数 2 都是可以忽略不计的，我们只关心影响最大的那个，所以时间复杂度就表示为 O(n) 。</p>
<p>常见的时间复杂度有这么 3 个：</p>
<p><strong>1） O(1)</strong></p>
<p>代码的执行时间，和数据规模 n 没有多大关系。</p>
<p>括号中的 1 可以是 3，可以是 5，可以 100，我们习惯用 1 来表示，表示这段代码的执行时间是一个常数级别。比如说下面这段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int i = 0;</span><br><span class="line">int j = 0;</span><br><span class="line">int k = i + j;</span><br></pre></td></tr></table></figure>
<p>实际上执行了 3 次，但我们也认为这段代码的时间复杂度为 O(1) 。</p>
<p>再举一个简单的例子。当我们访问数组中的一个元素时，它的时间复杂度就是常数时间复杂度 O(1)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int[] nums = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">int x = nums[2]; // 访问数组中下标为2的元素，时间复杂度为 O(1)</span><br></pre></td></tr></table></figure>
<p><strong>2） O(n)</strong></p>
<p>时间复杂度和数据规模 n 是线性关系。换句话说，数据规模增大 K 倍，代码执行的时间就大致增加 K 倍。</p>
<p>当我们遍历一个数组时，它的时间复杂度就是线性时间复杂度 O(n)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int[] nums = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">for (int i = 0; i &lt; nums.length; i++) &#123; // 遍历整个数组，时间复杂度为 O(n)</span><br><span class="line">    System.out.println(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3） O(logn)</strong></p>
<p>时间复杂度和数据规模 n 是对数关系。换句话说，数据规模大幅增加时，代码执行的时间只有少量增加。</p>
<p>来看一下代码示例，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void logn(int n) &#123; </span><br><span class="line">    int i = 1;</span><br><span class="line">    while (i &lt; n) &#123;</span><br><span class="line">        i *= 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>换句话说，当数据量 n 从 2 增加到 2^64 时，代码执行的时间只增加了 64 倍。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">遍历次数 |   i</span><br><span class="line">----------+-------</span><br><span class="line">    0     |   i</span><br><span class="line">    1     |  i*2</span><br><span class="line">    2     |  i*4</span><br><span class="line">   ...    |  ...</span><br><span class="line">   ...    |  ...</span><br><span class="line">    k     |  i*2^k </span><br></pre></td></tr></table></figure>
<p>再举个例子。当我们对一个已排序的数组进行二分查找时，它的时间复杂度就是对数时间复杂度 O(log n)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int[] nums = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">int target = 3;</span><br><span class="line">int left = 0, right = nums.length - 1;</span><br><span class="line">while (left &lt;= right) &#123;</span><br><span class="line">    int mid = left + (right - left) / 2;</span><br><span class="line">    if (nums[mid] == target) &#123;</span><br><span class="line">        System.out.println(&quot;找到了，下标为&quot; + mid);</span><br><span class="line">        break;</span><br><span class="line">    &#125; else if (nums[mid] &lt; target) &#123;</span><br><span class="line">        left = mid + 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        right = mid - 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4）平方时间复杂度O(n^2)  </strong></p>
<p>当我们对一个数组进行嵌套循环时，它的时间复杂度就是平方时间复杂度 O(n^2)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int[] nums = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">    for (int j = 0; j &lt; nums.length; j++) &#123;</span><br><span class="line">        System.out.println(nums[i] + &quot; &quot; + nums[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>5）指数时间复杂度O(2^n)</strong>  </p>
<p>当我们递归求解一个问题时，每一次递归都会分成两个子问题，这种情况下，它的时间复杂度就是指数时间复杂度 O(2^n)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static int fib(int n) &#123;</span><br><span class="line">    if (n &lt;= 1) &#123;</span><br><span class="line">        return n;</span><br><span class="line">    &#125;</span><br><span class="line">    return fib(n - 1) + fib(n - 2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码是递归求解斐波那契数列的方法，它的时间复杂度是指数级别的。</p>
<p>“好了，三妹，这节就讲到这吧，理解了上面 5 个时间复杂度，后面我们学习 ArrayList、LinkedList 的时候，两者在增删改查时的执行效率就很容易对比清楚了。”我伸了个懒腰后对三妹说。</p>
<p>“好的，二哥。”三妹重新回答沙发上，一盘王者荣耀即将开始。</p>
<h2 id="4-3-ArrayList详解（附源码）"><a href="#4-3-ArrayList详解（附源码）" class="headerlink" title="4.3 ArrayList详解（附源码）"></a>4.3 ArrayList详解（附源码）</h2><p>“二哥，听说今天我们开讲 ArrayList 了？好期待哦！”三妹明知故问，这个托配合得依然天衣无缝。</p>
<p>“是的呀，三妹。”我肯定地点了点头，继续说道，“ArrayList 可以称得上是集合框架方面最常用的类了，可以和 HashMap 一较高下。”</p>
<p>从名字就可以看得出来，ArrayList 实现了 List 接口，并且是基于数组实现的。</p>
<p>数组的大小是固定的，一旦创建的时候指定了大小，就不能再调整了。也就是说，如果数组满了，就不能再添加任何元素了。ArrayList 在数组的基础上实现了自动扩容，并且提供了比数组更丰富的预定义方法（各种增删改查），非常灵活。</p>
<p>Java 这门编程语言和别的编程语言，比如说 C语言的不同之处就在这里，如果是 C语言的话，你就必须得动手实现自己的 ArrayList，原生的库函数里面是没有的。</p>
<p><strong>01、创建 ArrayList </strong></p>
<p>“二哥，如何创建一个 ArrayList 啊？”三妹问。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; alist = new ArrayList&lt;String&gt;();</span><br></pre></td></tr></table></figure>
<p>可以通过上面的语句来创建一个字符串类型的 ArrayList（通过尖括号来限定 ArrayList 中元素的类型，如果尝试添加其他类型的元素，将会产生编译错误），更简化的写法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; alist = new ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>由于 ArrayList 实现了 List 接口，所以 alist 变量的类型可以是 List 类型；new 关键字声明后的尖括号中可以不再指定元素的类型，因为编译器可以通过前面尖括号中的类型进行智能推断。</p>
<p>此时会调用无参构造方法（见下面的代码）创建一个空的数组，常量DEFAULTCAPACITY_EMPTY_ELEMENTDATA的值为 {} 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList() &#123;</span><br><span class="line">    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果非常确定 ArrayList 中元素的个数，在创建的时候还可以指定初始大小。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; alist = new ArrayList&lt;&gt;(20);</span><br></pre></td></tr></table></figure>
<p>这样做的好处是，可以有效地避免在添加新的元素时进行不必要的扩容。</p>
<p><strong>02、向 ArrayList 中添加元素 </strong></p>
<p>“二哥，那怎么向 ArrayList 中添加一个元素呢？”三妹继续问。</p>
<p>可以通过 add() 方法向 ArrayList 中添加一个元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alist.add(&quot;沉默王二&quot;);</span><br></pre></td></tr></table></figure>
<p>我们来跟一下源码，看看 add 方法到底执行了哪些操作。跟的过程中，我们也可以偷师到 Java 源码的作者（大师级程序员）是如何优雅地写代码的。</p>
<p>我先给个结论，全当抛砖引玉。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">堆栈过程图示：</span><br><span class="line">add(element)</span><br><span class="line">└── if (size == elementData.length) // 判断是否需要扩容</span><br><span class="line">    ├── grow(minCapacity) // 扩容</span><br><span class="line">    │   └── newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1) // 计算新的数组容量</span><br><span class="line">    │   └── Arrays.copyOf(elementData, newCapacity) // 创建新的数组</span><br><span class="line">    ├── elementData[size++] = element; // 添加新元素</span><br><span class="line">    └── return true; // 添加成功</span><br></pre></td></tr></table></figure>
<p>来具体看一下，先是 add() 方法的源码（已添加好详细地注释）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 将指定元素添加到 ArrayList 的末尾</span><br><span class="line"> * @param e 要添加的元素</span><br><span class="line"> * @return 添加成功返回 true</span><br><span class="line"> */</span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    ensureCapacityInternal(size + 1);  // 确保 ArrayList 能够容纳新的元素</span><br><span class="line">    elementData[size++] = e; // 在 ArrayList 的末尾添加指定元素</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数 e 为要添加的元素，此时的值为“沉默王二”，size 为 ArrayList 的长度，此时为 0。</p>
<p>继续跟下去，来看看 ensureCapacityInternal()方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 确保 ArrayList 能够容纳指定容量的元素</span><br><span class="line"> * @param minCapacity 指定容量的最小值</span><br><span class="line"> */</span><br><span class="line">private void ensureCapacityInternal(int minCapacity) &#123;</span><br><span class="line">    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; // 如果 elementData 还是默</span><br><span class="line">认的空数组</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); // 使用 </span><br><span class="line">DEFAULT_CAPACITY 和指定容量的最小值中的较大值</span><br><span class="line">    &#125;</span><br><span class="line">    ensureExplicitCapacity(minCapacity); // 确保容量能够容纳指定容量的元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 此时：</p>
<ul>
<li>参数 minCapacity 为 1（size+1 传过来的）</li>
<li>elementData 为存放 ArrayList 元素的底层数组，前面声明 ArrayList 的时候讲过了，此时为空 {}</li>
<li><p>DEFAULTCAPACITY_EMPTY_ELEMENTDATA 前面也讲过了，为 {}</p>
<p>所以，if 条件此时为 true，if 语句 minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity)要执行。</p>
<p>DEFAULT_CAPACITY 为 10（见下面的代码），所以执行完这行代码后，minCapacity 为 10， Math.max() 方法的作用是取两个当中最大的那个。</p>
<p>接下来执行 ensureExplicitCapacity() 方法，来看一下源码：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 检查并确保集合容量足够，如果需要则增加集合容量。</span><br><span class="line"> *</span><br><span class="line"> * @param minCapacity 所需最小容量</span><br><span class="line"> */</span><br><span class="line">private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class="line">    // 检查是否超出了数组范围，确保不会溢出</span><br><span class="line">    if (minCapacity - elementData.length &gt; 0)</span><br><span class="line">        // 如果需要增加容量，则调用 grow 方法</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 此时：</p>
<ul>
<li>参数 minCapacity 为 10</li>
<li><p>elementData.length 为 0（数组为空）</p>
<p>所以 10-0&gt;0，if 条件为 true，进入 if 语句执行 grow() 方法，来看源码：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 扩容 ArrayList 的方法，确保能够容纳指定容量的元素</span><br><span class="line"> * @param minCapacity 指定容量的最小值</span><br><span class="line"> */</span><br><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">    // 检查是否会导致溢出，oldCapacity 为当前数组长度</span><br><span class="line">    int oldCapacity = elementData.length;</span><br><span class="line">    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); // 扩容至原来的1.5倍</span><br><span class="line">    if (newCapacity - minCapacity &lt; 0) // 如果还是小于指定容量的最小值</span><br><span class="line">        newCapacity = minCapacity; // 直接扩容至指定容量的最小值</span><br><span class="line">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0) // 如果超出了数组的最大长度</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity); // 扩容至数组的最大长度</span><br><span class="line">    // 将当前数组复制到一个新数组中，长度为 newCapacity</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 此时：</p>
<ul>
<li>参数 minCapacity 为 10</li>
<li>变量 oldCapacity 为 0</li>
</ul>
<p>所以 newCapacity 也为 0，于是 newCapacity - minCapacity 等于 -10 小于 0，于是第一个 if 条件为 true，执行第一个 if 语句 newCapacity = minCapacity ，然后 newCapacity 为 10。</p>
<p>紧接着执行 elementData = Arrays.copyOf(elementData, newCapacity); ，也就是进行数组的第一次扩容，长度为 10。</p>
<p>回到 add() 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    ensureCapacityInternal(size + 1);</span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行 elementData[size++] = e 。</p>
<p>此时：</p>
<ul>
<li>size 为 0</li>
<li><p>e 为 “沉默王二”</p>
<p>所以数组的第一个元素（下标为 0） 被赋值为“沉默王二”，接着返回 true，第一次 add 方法执行完毕。</p>
<p>PS：add 过程中会遇到一个令新手感到困惑的右移操作符 &gt;&gt; ，借这个机会来解释一下。</p>
<p>ArrayList 在第一次执行 add 后会扩容为 10，那 ArrayList 第二次扩容发生在什么时候呢？</p>
<p>答案是添加第 11 个元素时，大家可以尝试分析一下这个过程。</p>
</li>
</ul>
<p><strong>03、右移操作符 </strong></p>
<p> “oldCapacity 等于 10， oldCapacity &gt;&gt; 1 这个表达式等于多少呢？三妹你知道吗？”我问三妹。</p>
<p> “不知道啊， &gt;&gt; 是什么意思呢？”三妹很疑惑。</p>
<p> “ &gt;&gt; 是右移运算符， oldCapacity &gt;&gt; 1 相当于 oldCapacity 除以 2。”我给三妹解释道，“在计算机内部，都是按照二进制存储的，10 的二进制就是 1010，也就是 $0<em>2^0 + 1</em>2^1 + 0<em>2^2 + 1</em>2^3 =0+2+0+8=10 $。”</p>
<p> 还没等我解释完，三妹就打断了我，“二哥，能再详细解释一下到底为什么吗？”</p>
<p> “当然可以啊。”我拍着胸脯对三妹说。</p>
<p> 先从位权的含义说起吧。</p>
<p> 平常我们使用的是十进制数，比如说 39，并不是简单的 3 和 9，3 表示的是 3*10 = 30 ，9 表示的是 9*1 = 9 ，和 3 相乘的 10，和 9 相乘的 1，就是位权。位数不同，位权就不同，第 1 位是 10 的 0 次方（也就是 $10^0=1$ ），第 2 位是 10 的 1 次方（ $10^1=10$ ），第 3 位是 10 的 2 次方（ $10^2=100$ ），最右边的是第一位，依次类推。</p>
<p> 位权这个概念同样适用于二进制，第 1 位是 2 的 0 次方（也就是 $2^0=1$ ），第 2 位是 2 的 1 次方（ $2^1=2$ ），第 3 位是 2 的 2 次方（ $2^2=4$ ），第 4 位是 2 的 3 次方（ $2^3=8$ ）。</p>
<p> 十进制的情况下，10 是基数，二进制的情况下，2 是基数。</p>
<p> 10 在十进制的表示法是 $0<em>10^0+1</em>10^1 =0+10=10$。</p>
<p> 10 的二进制数是 1010，也就是 $0<em>2^0 + 1</em>2^1 + 0<em>2^2 + 1</em>2^3 =0+2+0+8=10$。</p>
<p> 然后是移位运算，移位分为左移和右移，在 Java 中，左移的运算符是 &lt;&lt; ，右移的运算符 &gt;&gt; 。</p>
<p> 拿 oldCapacity &gt;&gt; 1 来说吧， &gt;&gt; 左边的是被移位的值，此时是 10，也就是二进制 1010 ； &gt;&gt; 右边的是要移位的位数，此时是 1。</p>
<p> 1010 向右移一位就是 101，空出来的最高位此时要补 0，也就是 0101。</p>
<p> “那为什么不补 1 呢？”三妹这个问题很尖锐。</p>
<p> “因为是算术右移，并且是正数，所以最高位补 0；如果表示的是负数，就需要补 1。”我慢吞吞地回答道，</p>
<p> “0101 的十进制就刚好是 $1<em>2^0 + 0</em>2^1 + 1<em>2^2 + 0</em>2^3 =1+0+4+0=5$，如果多移几个数来找规律的话，就会发现，右移1 位是原来的 1/2，右移 2 位是原来的 1/4，诸如此类。”</p>
<p> 也就是说，ArrayList 的大小会扩容为原来的大小+原来大小/2，也就是 1.5 倍。</p>
<p> 这下明白了吧？</p>
<p> 你可以通过在 ArrayList 中添加第 11 个元素来 debug 验证一下。</p>
<p><img src="\assets\note\image-20231010100257416.png" alt="image-20231010100257416"></p>
<p> <strong>04、向 ArrayList 的指定位置添加元素 </strong></p>
<p> 除了 add(E e) 方法，还可以通过 add(int index, E element) 方法把元素添加到 ArrayList 的指定位置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alist.add(0, &quot;沉默王三&quot;);</span><br></pre></td></tr></table></figure>
<p> add(int index, E element) 方法的源码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 在指定位置插入一个元素。</span><br><span class="line"> *</span><br><span class="line"> * @param index   要插入元素的位置</span><br><span class="line"> * @param element 要插入的元素</span><br><span class="line"> * @throws IndexOutOfBoundsException 如果索引超出范围，则抛出此异常</span><br><span class="line"> */</span><br><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">    rangeCheckForAdd(index); // 检查索引是否越界</span><br><span class="line">    ensureCapacityInternal(size + 1);  // 确保容量足够，如果需要扩容就扩容</span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + 1,</span><br><span class="line">            size - index); // 将 index 及其后面的元素向后移动一位</span><br><span class="line">    elementData[index] = element; // 将元素插入到指定位置</span><br><span class="line">    size++; // 元素个数加一</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> add(int index, E element)方法会调用到一个非常重要的本地方法 System.arraycopy() ，它会对数组进行复制（要插入位置上的元素往后复制）。</p>
<p> 来细品一下。</p>
<p> 这是 arraycopy() 的语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length);</span><br></pre></td></tr></table></figure>
<p> 在 ArrayList.add(int index, E element) 方法中，具体用法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.arraycopy(elementData, index, elementData, index + 1, size - index);</span><br></pre></td></tr></table></figure>
<ul>
<li>elementData：表示要复制的源数组，即 ArrayList 中的元素数组。</li>
<li>index：表示源数组中要复制的起始位置，即需要将 index 及其后面的元素向后移动一位。</li>
<li>elementData：表示要复制到的目标数组，即 ArrayList 中的元素数组。</li>
<li>index + 1：表示目标数组中复制的起始位置，即将 index 及其后面的元素向后移动一位后，应该插入到的位置。</li>
<li><p>size - index：表示要复制的元素个数，即需要将 index 及其后面的元素向后移动一位，需要移动的元素个数为 size - index。</p>
<p>“三妹，注意看，我画幅图来表示下。”我认真地做起了图。</p>
</li>
</ul>
<p><img src="\assets\note\image-20231010100551490.png" alt="image-20231010100551490"></p>
<p><strong>05、更新 ArrayList 中的元素 </strong></p>
<p> “二哥，那怎么更新 ArrayList 中的元素呢？”三妹继续问。</p>
<p> 可以使用 set() 方法来更改 ArrayList 中的元素，需要提供下标和新元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alist.set(0, &quot;沉默王四&quot;);</span><br></pre></td></tr></table></figure>
<p> 假设原来 0 位置上的元素为“沉默王三”，现在可以将其更新为“沉默王四”。</p>
<p> 来看一下 set() 方法的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 用指定元素替换指定位置的元素。</span><br><span class="line"> *</span><br><span class="line"> * @param index   要替换的元素的索引</span><br><span class="line"> * @param element 要存储在指定位置的元素</span><br><span class="line"> * @return 先前在指定位置的元素</span><br><span class="line"> * @throws IndexOutOfBoundsException 如果索引超出范围，则抛出此异常</span><br><span class="line"> */</span><br><span class="line">public E set(int index, E element) &#123;</span><br><span class="line">    rangeCheck(index); // 检查索引是否越界</span><br><span class="line">    E oldValue = elementData(index); // 获取原来在指定位置上的元素</span><br><span class="line">    elementData[index] = element; // 将新元素替换到指定位置上</span><br><span class="line">    return oldValue; // 返回原来在指定位置上的元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法会先对指定的下标进行检查，看是否越界，然后替换新值并返回旧值。</p>
<p><strong>06、删除 ArrayList 中的元素 </strong></p>
<p>“二哥，那怎么删除 ArrayList 中的元素呢？”三妹继续问。</p>
<p>remove(int index) 方法用于删除指定下标位置上的元素， remove(Object o) 方法用于删除指定值的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alist.remove(1);</span><br><span class="line">alist.remove(&quot;沉默王四&quot;);</span><br></pre></td></tr></table></figure>
<p>先来看 remove(int index) 方法的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 删除指定位置的元素。</span><br><span class="line"> *</span><br><span class="line"> * @param index 要删除的元素的索引</span><br><span class="line"> * @return 先前在指定位置的元素</span><br><span class="line"> * @throws IndexOutOfBoundsException 如果索引超出范围，则抛出此异常</span><br><span class="line"> */</span><br><span class="line">public E remove(int index) &#123;</span><br><span class="line">    rangeCheck(index); // 检查索引是否越界</span><br><span class="line">    E oldValue = elementData(index); // 获取要删除的元素</span><br><span class="line">    int numMoved = size - index - 1; // 计算需要移动的元素个数</span><br><span class="line">    if (numMoved &gt; 0) // 如果需要移动元素，就用 System.arraycopy 方法实现</span><br><span class="line">        System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                numMoved);</span><br><span class="line">    elementData[--size] = null; // 将数组末尾的元素置为 null，让 GC 回收该元素占用的空间</span><br><span class="line">    return oldValue; // 返回被删除的元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，在 ArrayList 中，删除元素时，需要将删除位置后面的元素向前移动一位，以填补删除位置留下的空缺。如果需要移动元素，则需要使用 System.arraycopy 方法将删除位置后面的元素向前移动一位。最后，将数组末尾的元素置为 null，以便让垃圾回收机制回收该元素占用的空间。</p>
<p>再来看 remove(Object o) 方法的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 删除列表中第一次出现的指定元素（如果存在）。</span><br><span class="line"> *</span><br><span class="line"> * @param o 要删除的元素</span><br><span class="line"> * @return 如果列表包含指定元素，则返回 true；否则返回 false</span><br><span class="line"> */</span><br><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    if (o == null) &#123; // 如果要删除的元素是 null</span><br><span class="line">        for (int index = 0; index &lt; size; index++) // 遍历列表</span><br><span class="line">            if (elementData[index] == null) &#123; // 如果找到了 null 元素</span><br><span class="line">                fastRemove(index); // 调用 fastRemove 方法快速删除元素</span><br><span class="line">                return true; // 返回 true，表示成功删除元素</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; else &#123; // 如果要删除的元素不是 null</span><br><span class="line">        for (int index = 0; index &lt; size; index++) // 遍历列表</span><br><span class="line">            if (o.equals(elementData[index])) &#123; // 如果找到了要删除的元素</span><br><span class="line">                fastRemove(index); // 调用 fastRemove 方法快速删除元素</span><br><span class="line">                return true; // 返回 true，表示成功删除元素</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false; // 如果找不到要删除的元素，则返回 false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 该方法通过遍历的方式找到要删除的元素，null 的时候使用 == 操作符判断，非 null 的时候使用 equals() 方法，然后调用fastRemove() 方法。</p>
<p> 注意：</p>
<ul>
<li>有相同元素时，只会删除第一个。</li>
<li><p>判断两个元素是否相等，可以参考Java如何判断两个字符串是否相等</p>
<p>继续往后面跟，来看一下 fastRemove() 方法：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 快速删除指定位置的元素。</span><br><span class="line"> *</span><br><span class="line"> * @param index 要删除的元素的索引</span><br><span class="line"> */</span><br><span class="line">private void fastRemove(int index) &#123;</span><br><span class="line">    int numMoved = size - index - 1; // 计算需要移动的元素个数</span><br><span class="line">    if (numMoved &gt; 0) // 如果需要移动元素，就用 System.arraycopy 方法实现</span><br><span class="line">        System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                numMoved);</span><br><span class="line">    elementData[--size] = null; // 将数组末尾的元素置为 null，让 GC 回收该元素占用的空间</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 同样是调用 System.arraycopy() 方法对数组进行复制和移动。</p>
<p> “三妹，注意看，我画幅图来表示下。”我认真地做起了图。</p>
<p><img src="\assets\note\image-20231010101038173.png" alt="image-20231010101038173"></p>
<p> <strong>07、查找 ArrayList 中的元素 </strong></p>
<p> “二哥，那怎么查找 ArrayList 中的元素呢？”三妹继续问。</p>
<p> 如果要正序查找一个元素，可以使用 indexOf() 方法；如果要倒序查找一个元素，可以使用 lastIndexOf() 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alist.indexOf(&quot;沉默王二&quot;);</span><br><span class="line">alist.lastIndexOf(&quot;沉默王二&quot;);</span><br></pre></td></tr></table></figure>
<p> 来看一下 indexOf() 方法的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 返回指定元素在列表中第一次出现的位置。</span><br><span class="line"> * 如果列表不包含该元素，则返回 -1。</span><br><span class="line"> *</span><br><span class="line"> * @param o 要查找的元素</span><br><span class="line"> * @return 指定元素在列表中第一次出现的位置；如果列表不包含该元素，则返回 -1</span><br><span class="line"> */</span><br><span class="line">public int indexOf(Object o) &#123;</span><br><span class="line">    if (o == null) &#123; // 如果要查找的元素是 null</span><br><span class="line">        for (int i = 0; i &lt; size; i++) // 遍历列表</span><br><span class="line">            if (elementData[i]==null) // 如果找到了 null 元素</span><br><span class="line">                return i; // 返回元素的索引</span><br><span class="line">    &#125; else &#123; // 如果要查找的元素不是 null</span><br><span class="line">        for (int i = 0; i &lt; size; i++) // 遍历列表</span><br><span class="line">            if (o.equals(elementData[i])) // 如果找到了要查找的元素</span><br><span class="line">                return i; // 返回元素的索引</span><br><span class="line">    &#125;</span><br><span class="line">    return -1; // 如果找不到要查找的元素，则返回 -1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 如果元素为 null 的时候使用“==”操作符，否则使用 equals() 方法。</p>
<p> lastIndexOf() 方法和 indexOf() 方法类似，不过遍历的时候从最后开始。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 返回指定元素在列表中最后一次出现的位置。</span><br><span class="line"> * 如果列表不包含该元素，则返回 -1。</span><br><span class="line"> *</span><br><span class="line"> * @param o 要查找的元素</span><br><span class="line"> * @return 指定元素在列表中最后一次出现的位置；如果列表不包含该元素，则返回 -1</span><br><span class="line"> */</span><br><span class="line">public int lastIndexOf(Object o) &#123;</span><br><span class="line">    if (o == null) &#123; // 如果要查找的元素是 null</span><br><span class="line">        for (int i = size-1; i &gt;= 0; i--) // 从后往前遍历列表</span><br><span class="line">            if (elementData[i]==null) // 如果找到了 null 元素</span><br><span class="line">                return i; // 返回元素的索引</span><br><span class="line">    &#125; else &#123; // 如果要查找的元素不是 null</span><br><span class="line">        for (int i = size-1; i &gt;= 0; i--) // 从后往前遍历列表</span><br><span class="line">            if (o.equals(elementData[i])) // 如果找到了要查找的元素</span><br><span class="line">                return i; // 返回元素的索引</span><br><span class="line">    &#125;</span><br><span class="line">    return -1; // 如果找不到要查找的元素，则返回 -1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> contains() 方法可以判断 ArrayList 中是否包含某个元素，其内部就是通过 indexOf() 方法实现的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean contains(Object o) &#123;</span><br><span class="line">    return indexOf(o) &gt;= 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>08、二分查找法 </strong></p>
<p> 如果 ArrayList 中的元素是经过排序的，就可以使用二分查找法，效率更快。</p>
<p> Collections 类的 sort() 方法可以对 ArrayList 进行排序，该方法会按照字母顺序对 String 类型的列表进行排序。如果是自定义类型的列表，还可以指定 Comparator 进行排序。</p>
<p> 这里先简单地了解一下，后面会详细地讲。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; copy = new ArrayList&lt;&gt;(alist);</span><br><span class="line">copy.add(&quot;a&quot;);</span><br><span class="line">copy.add(&quot;c&quot;);</span><br><span class="line">copy.add(&quot;b&quot;);</span><br><span class="line">copy.add(&quot;d&quot;);</span><br><span class="line">Collections.sort(copy);</span><br><span class="line">System.out.println(copy);</span><br></pre></td></tr></table></figure>
<p> 输出结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[a, b, c, d]</span><br></pre></td></tr></table></figure>
<p> 排序后就可以使用二分查找法了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int index = Collections.binarySearch(copy, &quot;b&quot;);</span><br></pre></td></tr></table></figure>
<p><strong>09、ArrayList增删改查时的时间复杂度 </strong></p>
<p> “最后，三妹，我们来简单总结一下 ArrayList 的时间复杂度吧，方便后面学习 LinkedList 时对比。”我喝了一口水后补充道。</p>
<p><strong>1）查询 </strong></p>
<p> 时间复杂度为 O(1)，因为 ArrayList 内部使用数组来存储元素，所以可以直接根据索引来访问元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 返回列表中指定位置的元素。</span><br><span class="line"> *</span><br><span class="line"> * @param index 要返回的元素的索引</span><br><span class="line"> * @return 列表中指定位置的元素</span><br><span class="line"> * @throws IndexOutOfBoundsException 如果索引超出范围（index &lt; 0 || index &gt;= size()）</span><br><span class="line"> */</span><br><span class="line">public E get(int index) &#123;</span><br><span class="line">    rangeCheck(index); // 检查索引是否合法</span><br><span class="line">    return elementData(index); // 调用 elementData 方法获取元素</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 返回列表中指定位置的元素。</span><br><span class="line"> * 此方法不进行边界检查，因此只应由内部方法和迭代器调用。</span><br><span class="line"> *</span><br><span class="line"> * @param index 要返回的元素的索引</span><br><span class="line"> * @return 列表中指定位置的元素</span><br><span class="line"> */</span><br><span class="line">E elementData(int index) &#123;</span><br><span class="line">    return (E) elementData[index]; // 返回指定索引位置上的元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>2）插入 </strong></p>
<p> 添加一个元素（调用 add() 方法时）的时间复杂度最好情况为 O(1)，最坏情况为 O(n)。</p>
<ul>
<li>如果在列表末尾添加元素，时间复杂度为 O(1)。</li>
<li>如果要在列表的中间或开头插入元素，则需要将插入位置之后的元素全部向后移动一位，时间复杂度为 O(n)。</li>
</ul>
<p><strong>3）删除 </strong></p>
<p> 删除一个元素（调用 remove(Object) 方法时）的时间复杂度最好情况 O(1)，最坏情况 O(n)。</p>
<ul>
<li>如果要删除列表末尾的元素，时间复杂度为 O(1)。</li>
<li><p>如果要删除列表中间或开头的元素，则需要将删除位置之后的元素全部向前移动一位，时间复杂度为 O(n)。</p>
<p><strong>4）修改 </strong></p>
<p>修改一个元素（调用 set()方法时）与查询操作类似，可以直接根据索引来访问元素，时间复杂度为 O(1)。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 用指定元素替换列表中指定位置的元素。</span><br><span class="line"> *</span><br><span class="line"> * @param index 要替换元素的索引</span><br><span class="line"> * @param element 要放入列表中的元素</span><br><span class="line"> * @return 原来在指定位置上的元素</span><br><span class="line"> * @throws IndexOutOfBoundsException 如果索引超出范围（index &lt; 0 || index &gt;= size()）</span><br><span class="line"> */</span><br><span class="line">public E set(int index, E element) &#123;</span><br><span class="line">    rangeCheck(index); // 检查索引是否合法</span><br><span class="line">    E oldValue = elementData(index); // 获取原来在指定位置上的元素</span><br><span class="line">    elementData[index] = element; // 将指定位置上的元素替换为新元素</span><br><span class="line">    return oldValue; // 返回原来在指定位置上的元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>10、总结 </strong></p>
<p> ArrayList，如果有个中文名的话，应该叫动态数组，也就是可增长的数组，可调整大小的数组。动态数组克服了静态数组的限制，静态数组的容量是固定的，只能在首次创建的时候指定。而动态数组会随着元素的增加自动调整大小，更符合实际的开发需求。</p>
<p> 学习集合框架，ArrayList 是第一课，也是新手进阶的重要一课。要想完全掌握 ArrayList，扩容这个机制是必须得掌握，也是面试中经常考察的一个点。</p>
<p> 要想掌握扩容机制，就必须得读源码，也就肯定会遇到 oldCapacity &gt;&gt; 1 ，有些初学者会选择跳过，虽然不影响整体上的学习，但也错过了一个精进的机会。</p>
<p> 计算机内部是如何表示十进制数的，右移时又发生了什么，静下心来去研究一下，你就会发现，哦，原来这么有趣呢？</p>
<p> “好了，三妹，这一节我们就学到这里，收工！”</p>
<h2 id="4-4-LinkedList详解（附源码）"><a href="#4-4-LinkedList详解（附源码）" class="headerlink" title="4.4 LinkedList详解（附源码）"></a>4.4 LinkedList详解（附源码）</h2><p> 这篇换个表达方式，一起来欣赏。</p>
<p> 大家好，我是 LinkedList，和 ArrayList 是同门师兄弟，但我俩练的内功却完全不同。师兄练的是动态数组，我练的是链表。</p>
<p> 问大家一个问题，知道我为什么要练链表这门内功吗？</p>
<p> 举个例子来讲吧，假如你们手头要管理一推票据，可能有一张，也可能有一亿张。</p>
<p> 该怎么办呢？</p>
<p> 申请一个 10G 的大数组等着？那万一票据只有 100 张呢？</p>
<p> 申请一个默认大小的数组，随着数据量的增大扩容？要知道扩容是需要重新复制数组的，很耗时间。</p>
<p> 关键是，数组还有一个弊端就是，假如现在有 500 万张票据，现在要从中间删除一个票据，就需要把 250 万张票据往前移动一格。</p>
<p> 遇到这种情况的时候，我师兄几乎情绪崩溃，难受的要命。师父不忍心看到师兄这样痛苦，于是打我进入师门那一天，就强迫我练链表这门内功，一开始我很不理解，害怕师父偏心，不把师门最厉害的内功教我。</p>
<p> 直到有一天，我亲眼目睹师兄差点因为移动数据而走火入魔，我才明白师父的良苦用心。从此以后，我苦练“链表”这门内功，取得了显著的进步，师父和师兄都夸我有天赋。</p>
<p> 链表这门内功大致分为三个层次：</p>
<ul>
<li>第一层叫做“单向链表”，我只有一个后指针，指向下一个数据；</li>
<li>第二层叫做“双向链表”，我有两个指针，后指针指向下一个数据，前指针指向上一个数据。</li>
<li><p>第三层叫做“二叉树”，把后指针去掉，换成左右指针。</p>
<p>但我现在的功力还达不到第三层，不过师父说我有这个潜力，练成神功是早晚的事。</p>
</li>
</ul>
<p><strong>01、LinkedList的内功心法 </strong></p>
<p> 好了，经过我这么样的一个剖白后，大家对我应该已经不陌生了。那么接下来，我给大家展示一下我的内功心法。</p>
<p> 我的内功心法主要是一个私有的静态内部类，叫 Node，也就是节点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 链表中的节点类。</span><br><span class="line"> */</span><br><span class="line">private static class Node&lt;E&gt; &#123;</span><br><span class="line">    E item; // 节点中存储的元素</span><br><span class="line">    Node&lt;E&gt; next; // 指向下一个节点的指针</span><br><span class="line">    Node&lt;E&gt; prev; // 指向上一个节点的指针</span><br><span class="line">    /**</span><br><span class="line">     * 构造一个新的节点。</span><br><span class="line">     *</span><br><span class="line">     * @param prev 前一个节点</span><br><span class="line">     * @param element 节点中要存储的元素</span><br><span class="line">     * @param next 后一个节点</span><br><span class="line">     */</span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        this.item = element; // 存储元素</span><br><span class="line">        this.next = next; // 设置下一个节点</span><br><span class="line">        this.prev = prev; // 设置上一个节点</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 它由三部分组成：</p>
<ul>
<li>节点上的元素</li>
<li>下一个节点</li>
<li><p>上一个节点</p>
<p>我画幅图给你们展示下吧。</p>
</li>
</ul>
<p><img src="\assets\note\image-20231010102138237.png" alt="image-20231010102138237"></p>
<ul>
<li>对于第一个节点来说，prev 为 null；</li>
<li>对于最后一个节点来说，next 为 null；</li>
<li><p>其余的节点呢，prev 指向前一个，next 指向后一个。</p>
<p>我的内功心法就这么简单，其实我早已经牢记在心了。但师父叮嘱我，每天早上醒来的时候，每天晚上睡觉的时候，一定要默默地背诵一遍。虽然我有些厌烦，但我对师父的教诲从来都是言听计从。</p>
<p><strong>02、LinkedList的招式 </strong></p>
<p>和师兄 ArrayList 一样，我的招式也无外乎“增删改查”这 4 种。在此之前，我们都必须得初始化。</p>
<p>师兄在初始化的时候可以指定大小，也可以不指定，等到添加第一个元素的时候进行第一次扩容。而我，没有大小，只要内存够大，我就可以无穷大。</p>
</li>
</ul>
<p><strong>1）招式一：增 </strong></p>
<p>  可以调用 add 方法添加元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list.add(&quot;沉默王二&quot;);</span><br><span class="line">list.add(&quot;沉默王三&quot;);</span><br><span class="line">list.add(&quot;沉默王四&quot;);</span><br></pre></td></tr></table></figure>
<p>  add 方法内部其实调用的是 linkLast 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 将指定的元素添加到列表的尾部。</span><br><span class="line"> *</span><br><span class="line"> * @param e 要添加到列表的元素</span><br><span class="line"> * @return 始终为 true（根据 Java 集合框架规范）</span><br><span class="line"> */</span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    linkLast(e); // 在列表的尾部添加元素</span><br><span class="line">    return true; // 添加元素成功，返回 true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  linkLast，顾名思义，就是在链表的尾部添加元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 在列表的尾部添加指定的元素。</span><br><span class="line"> *</span><br><span class="line"> * @param e 要添加到列表的元素</span><br><span class="line"> */</span><br><span class="line">void linkLast(E e) &#123;</span><br><span class="line">    final Node&lt;E&gt; l = last; // 获取链表的最后一个节点</span><br><span class="line">    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); // 创建一个新的节点，并将其设置为链表</span><br><span class="line">的最后一个节点</span><br><span class="line">    last = newNode; // 将新的节点设置为链表的最后一个节点</span><br><span class="line">    if (l == null) // 如果链表为空，则将新节点设置为头节点</span><br><span class="line">        first = newNode;</span><br><span class="line">    else</span><br><span class="line">        l.next = newNode; // 否则将新节点链接到链表的尾部</span><br><span class="line">    size++; // 增加链表的元素个数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>添加第一个元素的时候，first 和 last 都为 null。</li>
<li>然后新建一个节点 newNode，它的 prev 和 next 也为 null。</li>
<li><p>然后把 last 和 first 都赋值为 newNode。</p>
<p>此时还不能称之为链表，因为前后节点都是断裂的。</p>
</li>
</ul>
<p><img src="\assets\note\image-20231010102450377.png" alt="image-20231010102450377"></p>
<ul>
<li>添加第二个元素的时候，first 和 last 都指向的是第一个节点。</li>
<li>然后新建一个节点 newNode，它的 prev 指向的是第一个节点，next 为 null。</li>
<li><p>然后把第一个节点的 next 赋值为 newNode。</p>
<p>此时的链表还不完整。</p>
</li>
</ul>
<p><img src="\assets\note\image-20231010103006080.png" alt="image-20231010103006080"></p>
<ul>
<li>添加第三个元素的时候，first 指向的是第一个节点，last 指向的是最后一个节点。</li>
<li>然后新建一个节点 newNode，它的 prev 指向的是第二个节点，next 为 null。</li>
<li><p>然后把第二个节点的 next 赋值为 newNode。</p>
<p>此时的链表已经完整了。</p>
<p>我这个增的招式，还可以演化成另外两个版本：</p>
</li>
<li><p>addFirst() 方法将元素添加到第一位；</p>
</li>
<li><p>addLast() 方法将元素添加到末尾。</p>
<p>addFirst 内部其实调用的是 linkFirst：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 在列表的开头添加指定的元素。</span><br><span class="line"> *</span><br><span class="line"> * @param e 要添加到列表的元素</span><br><span class="line"> */</span><br><span class="line">public void addFirst(E e) &#123;</span><br><span class="line">    linkFirst(e); // 在列表的开头添加元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> linkFirst 负责把新的节点设为 first，并将新的 first 的 next 更新为之前的 first。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 在列表的开头添加指定的元素。</span><br><span class="line"> *</span><br><span class="line"> * @param e 要添加到列表的元素</span><br><span class="line"> */</span><br><span class="line">private void linkFirst(E e) &#123;</span><br><span class="line">    final Node&lt;E&gt; f = first; // 获取链表的第一个节点</span><br><span class="line">    final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f); // 创建一个新的节点，并将其设置为链表</span><br><span class="line">的第一个节点</span><br><span class="line">    first = newNode; // 将新的节点设置为链表的第一个节点</span><br><span class="line">    if (f == null) // 如果链表为空，则将新节点设置为尾节点</span><br><span class="line">        last = newNode;</span><br><span class="line">    else</span><br><span class="line">        f.prev = newNode; // 否则将新节点链接到链表的头部</span><br><span class="line">    size++; // 增加链表的元素个数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> addLast 的内核其实和 addFirst 差不多，内部调用的是 linkLast 方法，前面分析过了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 在列表的尾部添加指定的元素。</span><br><span class="line"> *</span><br><span class="line"> * @param e 要添加到列表的元素</span><br><span class="line"> * @return 始终为 true（根据 Java 集合框架规范）</span><br><span class="line"> */</span><br><span class="line">public boolean addLast(E e) &#123;</span><br><span class="line">    linkLast(e); // 在列表的尾部添加元素</span><br><span class="line">    return true; // 添加元素成功，返回 true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2）招式二：删 </strong></p>
<p> 我这个删的招式还挺多的：</p>
<ul>
<li>remove() ：删除第一个节点</li>
<li>remove(int) ：删除指定位置的节点</li>
<li>remove(Object) ：删除指定元素的节点</li>
<li>removeFirst() ：删除第一个节点</li>
<li><p>removeLast() ：删除最后一个节点</p>
<p>remove() 内部调用的是 removeFirst() ，所以这两个招式的功效一样。</p>
<p>remove(int) 内部其实调用的是 unlink 方法。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 删除指定位置上的元素。</span><br><span class="line"> *</span><br><span class="line"> * @param index 要删除的元素的索引</span><br><span class="line"> * @return 从列表中删除的元素</span><br><span class="line"> * @throws IndexOutOfBoundsException 如果索引越界（index &amp;lt; 0 || index &amp;gt;= size()）</span><br><span class="line"> */</span><br><span class="line">public E remove(int index) &#123;</span><br><span class="line">    checkElementIndex(index); // 检查索引是否越界</span><br><span class="line">    return unlink(node(index)); // 删除指定位置的节点，并返回节点的元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> unlink 方法其实很好理解，就是更新当前节点的 next 和 prev，然后把当前节点上的元素设为 null。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 从链表中删除指定节点。</span><br><span class="line"> *</span><br><span class="line"> * @param x 要删除的节点</span><br><span class="line"> * @return 从链表中删除的节点的元素</span><br><span class="line"> */</span><br><span class="line">E unlink(Node&lt;E&gt; x) &#123;</span><br><span class="line">    final E element = x.item; // 获取要删除节点的元素</span><br><span class="line">    final Node&lt;E&gt; next = x.next; // 获取要删除节点的下一个节点</span><br><span class="line">    final Node&lt;E&gt; prev = x.prev; // 获取要删除节点的上一个节点</span><br><span class="line">    if (prev == null) &#123; // 如果要删除节点是第一个节点</span><br><span class="line">        first = next; // 将链表的头节点设置为要删除节点的下一个节点</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        prev.next = next; // 将要删除节点的上一个节点指向要删除节点的下一个节点</span><br><span class="line">        x.prev = null; // 将要删除节点的上一个节点设置为空</span><br><span class="line">    &#125;</span><br><span class="line">    if (next == null) &#123; // 如果要删除节点是最后一个节点</span><br><span class="line">        last = prev; // 将链表的尾节点设置为要删除节点的上一个节点</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        next.prev = prev; // 将要删除节点的下一个节点指向要删除节点的上一个节点</span><br><span class="line">        x.next = null; // 将要删除节点的下一个节点设置为空</span><br><span class="line">    &#125;</span><br><span class="line">    x.item = null; // 将要删除节点的元素设置为空</span><br><span class="line">    size--; // 减少链表的元素个数</span><br><span class="line">    return element; // 返回被删除节点的元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> remove(Object) 内部也调用了 unlink 方法，只不过在此之前要先找到元素所在的节点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 从链表中删除指定元素。</span><br><span class="line"> *</span><br><span class="line"> * @param o 要从链表中删除的元素</span><br><span class="line"> * @return 如果链表包含指定元素，则返回 true；否则返回 false</span><br><span class="line"> */</span><br><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    if (o == null) &#123; // 如果要删除的元素为 null</span><br><span class="line">        for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; // 遍历链表</span><br><span class="line">            if (x.item == null) &#123; // 如果节点的元素为 null</span><br><span class="line">                unlink(x); // 删除节点</span><br><span class="line">                return true; // 返回 true 表示删除成功</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123; // 如果要删除的元素不为 null</span><br><span class="line">        for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; // 遍历链表</span><br><span class="line">            if (o.equals(x.item)) &#123; // 如果节点的元素等于要删除的元素</span><br><span class="line">                unlink(x); // 删除节点</span><br><span class="line">                return true; // 返回 true 表示删除成功</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false; // 如果链表中不包含要删除的元素，则返回 false 表示删除失败</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 元素为 null 的时候，必须使用 == 来判断；元素为非 null 的时候，要使用 equals 来判断。</p>
<p> removeFirst 内部调用的是 unlinkFirst 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 从链表中删除第一个元素并返回它。</span><br><span class="line"> * 如果链表为空，则抛出 NoSuchElementException 异常。</span><br><span class="line"> *</span><br><span class="line"> * @return 从链表中删除的第一个元素</span><br><span class="line"> * @throws NoSuchElementException 如果链表为空</span><br><span class="line"> */</span><br><span class="line">public E removeFirst() &#123;</span><br><span class="line">    final Node&lt;E&gt; f = first; // 获取链表的第一个节点</span><br><span class="line">    if (f == null) // 如果链表为空</span><br><span class="line">        throw new NoSuchElementException(); // 抛出 NoSuchElementException 异常</span><br><span class="line">    return unlinkFirst(f); // 调用 unlinkFirst 方法删除第一个节点并返回它的元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> unlinkFirst 负责的就是把第一个节点毁尸灭迹，并且捎带把后一个节点的 prev 设为 null。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 删除链表中的第一个节点并返回它的元素。</span><br><span class="line"> *</span><br><span class="line"> * @param f 要删除的第一个节点</span><br><span class="line"> * @return 被删除节点的元素</span><br><span class="line"> */</span><br><span class="line">private E unlinkFirst(Node&lt;E&gt; f) &#123;</span><br><span class="line">    final E element = f.item; // 获取要删除的节点的元素</span><br><span class="line">    final Node&lt;E&gt; next = f.next; // 获取要删除的节点的下一个节点</span><br><span class="line">    f.item = null; // 将要删除的节点的元素设置为 null</span><br><span class="line">    f.next = null; // 将要删除的节点的下一个节点设置为 null</span><br><span class="line">    first = next; // 将链表的头节点设置为要删除的节点的下一个节点</span><br><span class="line">    if (next == null) // 如果链表只有一个节点</span><br><span class="line">        last = null; // 将链表的尾节点设置为 null</span><br><span class="line">    else</span><br><span class="line">        next.prev = null; // 将要删除节点的下一个节点的前驱设置为 null</span><br><span class="line">    size--; // 减少链表的大小</span><br><span class="line">    return element; // 返回被删除节点的元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>3）招式三：改 </strong></p>
<p> 可以调用 set() 方法来更新元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.set(0, &quot;沉默王五&quot;);</span><br></pre></td></tr></table></figure>
<p> 来看一下 set() 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 将链表中指定位置的元素替换为指定元素，并返回原来的元素。</span><br><span class="line"> *</span><br><span class="line"> * @param index 要替换元素的位置（从 0 开始）</span><br><span class="line"> * @param element 要插入的元素</span><br><span class="line"> * @return 替换前的元素</span><br><span class="line"> * @throws IndexOutOfBoundsException 如果索引超出范围（index &lt; 0 || index &gt;= size()）</span><br><span class="line"> */</span><br><span class="line">public E set(int index, E element) &#123;</span><br><span class="line">    checkElementIndex(index); // 检查索引是否超出范围</span><br><span class="line">    Node&lt;E&gt; x = node(index); // 获取要替换的节点</span><br><span class="line">    E oldVal = x.item; // 获取要替换节点的元素</span><br><span class="line">    x.item = element; // 将要替换的节点的元素设置为指定元素</span><br><span class="line">    return oldVal; // 返回替换前的元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 来看一下node方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 获取链表中指定位置的节点。</span><br><span class="line"> *</span><br><span class="line"> * @param index 节点的位置（从 0 开始）</span><br><span class="line"> * @return 指定位置的节点</span><br><span class="line"> * @throws IndexOutOfBoundsException 如果索引超出范围（index &lt; 0 || index &gt;= size()）</span><br><span class="line"> */</span><br><span class="line">Node&lt;E&gt; node(int index) &#123;</span><br><span class="line">    if (index &lt; (size &gt;&gt; 1)) &#123; // 如果索引在链表的前半部分</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        for (int i = 0; i &lt; index; i++) // 从头节点开始向后遍历链表，直到找到指定位置的节点</span><br><span class="line">            x = x.next;</span><br><span class="line">        return x; // 返回指定位置的节点</span><br><span class="line">    &#125; else &#123; // 如果索引在链表的后半部分</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        for (int i = size - 1; i &gt; index; i--) // 从尾节点开始向前遍历链表，直到找到指定位</span><br><span class="line">置的节点</span><br><span class="line">            x = x.prev;</span><br><span class="line">        return x; // 返回指定位置的节点</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> size &gt;&gt; 1 ：也就是右移一位，相当于除以 2。对于计算机来说，移位比除法运算效率更高，因为数据在计算机内部都是以二进制存的。</p>
<p> 换句话说，node 方法会对下标进行一个初步判断，如果靠近前半截，就从下标 0 开始遍历；如果靠近后半截，就从末尾开始遍历，这样可以提高效率，最大能提高一半的效率。</p>
<p> 找到指定下标的节点就简单了，直接把原有节点的元素替换成新的节点就 OK 了，prev 和 next 都不用改动。</p>
<p><strong>4）招式四：查 </strong></p>
<p> 我这个查的招式可以分为两种：</p>
<ul>
<li>indexOf(Object)：查找某个元素所在的位置</li>
<li><p>get(int)：查找某个位置上的元素</p>
<p>来看一下 indexOf 方法的源码。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 返回链表中首次出现指定元素的位置，如果不存在该元素则返回 -1。</span><br><span class="line"> *</span><br><span class="line"> * @param o 要查找的元素</span><br><span class="line"> * @return 首次出现指定元素的位置，如果不存在该元素则返回 -1</span><br><span class="line"> */</span><br><span class="line">public int indexOf(Object o) &#123;</span><br><span class="line">    int index = 0; // 初始化索引为 0</span><br><span class="line">    if (o == null) &#123; // 如果要查找的元素为 null</span><br><span class="line">        for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; // 从头节点开始向后遍历链表</span><br><span class="line">            if (x.item == null) // 如果找到了要查找的元素</span><br><span class="line">                return index; // 返回该元素的索引</span><br><span class="line">            index++; // 索引加 1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123; // 如果要查找的元素不为 null</span><br><span class="line">        for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; // 从头节点开始向后遍历链表</span><br><span class="line">            if (o.equals(x.item)) // 如果找到了要查找的元素</span><br><span class="line">                return index; // 返回该元素的索引</span><br><span class="line">            index++; // 索引加 1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1; // 如果没有找到要查找的元素，则返回 -1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> get 方法的内核其实还是 node 方法，node 方法之前已经说明过了，这里略过。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public E get(int index) &#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    return node(index).item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 其实，查这个招式还可以演化为其他的一些，比如说：</p>
<ul>
<li>getFirst() 方法用于获取第一个元素；</li>
<li>getLast() 方法用于获取最后一个元素；</li>
<li>poll() 和 pollFirst() 方法用于删除并返回第一个元素（两个方法尽管名字不同，但方法体是完全相同的）；</li>
<li>pollLast() 方法用于删除并返回最后一个元素；</li>
<li>peekFirst() 方法用于返回但不删除第一个元素。</li>
</ul>
<p><strong>03、LinkedList 的挑战 </strong></p>
<p> 说句实在话，我不是很喜欢和师兄 ArrayList 拿来比较，因为我们各自修炼的内功不同，没有孰高孰低。虽然师兄经常喊我一声师弟，但我们之间其实挺和谐的。但我知道，在外人眼里，同门师兄弟，总要一较高下的。</p>
<p> 比如说，我们俩在增删改查时候的时间复杂度。</p>
<p> 也许这就是命运吧，从我进入师门的那天起，这种争论就一直没有停息过。</p>
<p> 无论外人怎么看待我们，在我眼里，师兄永远都是一哥，我敬重他，他也愿意保护我。</p>
<p> 好戏在后头，等着瞧吧。</p>
<p> 我这里先简单聊一下，权当抛砖引玉。</p>
<p> 想象一下，你在玩一款游戏，游戏中有一个道具栏，你需要不断地往里面添加、删除道具。如果你使用的是我的师兄 ArrayList，那么每次添加、删除道具时都需要将后面的道具向后移动或向前移动，这样就会非常耗费时间。但是如果你使用的是我 LinkedList，那么只需要将新道具插入到链表中的指定位置，或者将要删除的道具从链表中删除即可，这样就可以快速地完成道具栏的更新。</p>
<p> 除了游戏中的道具栏，我 LinkedList 还可以用于实现 LRU（Least Recently Used）缓存淘汰算法。LRU 缓存淘汰算法是一种常用的缓存淘汰策略，它的基本思想是，当缓存空间不够时，优先淘汰最近最少使用的缓存数据。在实现 LRU 缓存淘汰算法时，你可以使用我LinkedList 来存储缓存数据，每次访问缓存数据时，将该数据从链表中删除并移动到链表的头部，这样链表的尾部就是最近最少使用的缓存数据，当缓存空间不够时，只需要将链表尾部的缓存数据淘汰即可。</p>
<h2 id="4-5-ArrayList和LinkedList的区别"><a href="#4-5-ArrayList和LinkedList的区别" class="headerlink" title="4.5 ArrayList和LinkedList的区别"></a>4.5 ArrayList和LinkedList的区别</h2><p> “终于，二哥，我们要聊 LinkedList 和 ArrayList 之间的差别了，我期待了很久。”三妹嘟囔着说。</p>
<p> “其实经过前面两节的分析，差别已经很清晰了。”我喃喃道。</p>
<p> “哥，你再说点吧，深挖一下，OK？”</p>
<p> “好吧，那就让我们出发吧！”</p>
<blockquote>
<p>PS：为了和前面两节的源码做适当的区分，这里采用的是 Java 11 的源码，请务必注意。但整体上差别很小。</p>
</blockquote>
<p> <strong>01、ArrayList 是如何实现的？ </strong></p>
<p> ArrayList 实现了 List 接口，继承了 AbstractList 抽象类。</p>
<p><img src="\assets\note\image-20231010104643407.png" alt="image-20231010104643407"></p>
<p> 底层是基于数组实现的，并且实现了动态扩容（当需要添加新元素时，如果 elementData 数组已满，则会自动扩容，新的容量将是原来的 1.5 倍），来看一下 ArrayList 的部分源码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class="line">        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    private static final int DEFAULT_CAPACITY = 10; // 默认容量为 10</span><br><span class="line">    transient Object[] elementData; // 存储元素的数组，数组类型为 Object</span><br><span class="line">    private int size; // 列表的大小，即列表中元素的个数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> ArrayList 还实现了 RandomAccess 接口，这是一个标记接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public interface RandomAccess &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 内部是空的，标记“实现了这个接口的类支持快速（通常是固定时间）随机访问”。快速随机访问是什么意思呢？就是说不需要遍历，就可以通过下标（索引）直接访问到内存地址。而 LinkedList 没有实现该接口，表示它不支持高效的随机访问，需要通过遍历来访问元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 返回列表中指定位置的元素。</span><br><span class="line"> *</span><br><span class="line"> * @param index 要返回的元素的索引</span><br><span class="line"> * @return 列表中指定位置的元素</span><br><span class="line"> * @throws IndexOutOfBoundsException 如果索引越界（index &lt; 0 || index &gt;= size()）</span><br><span class="line"> */</span><br><span class="line">public E get(int index) &#123;</span><br><span class="line">    Objects.checkIndex(index, size); // 检查索引是否越界</span><br><span class="line">    return elementData(index); // 调用 elementData 方法获取元素</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 返回列表中指定位置的元素。</span><br><span class="line"> * 注意：该方法并没有检查索引是否越界，调用该方法前需要先检查索引是否越界。</span><br><span class="line"> *</span><br><span class="line"> * @param index 要返回的元素的索引</span><br><span class="line"> * @return 列表中指定位置的元素</span><br><span class="line"> */</span><br><span class="line">E elementData(int index) &#123;</span><br><span class="line">    return (E) elementData[index]; // 强制类型转换，将 Object 类型转换为 E 类型</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> ArrayList 还实现了 Cloneable 接口，这表明 ArrayList 是支持拷贝的。ArrayList 内部的确也重写了 Object 类的 clone() 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 返回该列表的浅表副本。</span><br><span class="line"> * （元素本身不会被复制。）</span><br><span class="line"> *</span><br><span class="line"> * @return 该列表的副本</span><br><span class="line"> */</span><br><span class="line">public Object clone() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone(); // 调用 Object 类的 clone 方法，得到一个浅表副本</span><br><span class="line">        v.elementData = Arrays.copyOf(elementData, size); // 复制 elementData 数组，创建一个新数组作为副本</span><br><span class="line">        v.modCount = 0; // 将 modCount 置为 0</span><br><span class="line">        return v; // 返回副本</span><br><span class="line">    &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">        // this shouldn&#x27;t happen, since we are Cloneable</span><br><span class="line">        throw new InternalError(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> ArrayList 还实现了 Serializable 接口，同样是一个标记接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public interface Serializable &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 内部也是空的，标记“实现了这个接口的类支持序列化”。序列化是什么意思呢？Java 的序列化是指，将对象转换成以字节序列的形式来表示，这些字节序中包含了对象的字段和方法。序列化后的对象可以被写到数据库、写到文件，也可用于网络传输。</p>
<p> 眼睛雪亮的小伙伴可能会注意到，ArrayList 中的关键字段 elementData 使用了 transient 关键字修饰，这个关键字的作用是，让它修饰的字段不被序列化。</p>
<p> 这不前后矛盾吗？一个类既然实现了 Serilizable 接口，肯定是想要被序列化的，对吧？那为什么保存关键数据的 elementData 又不想被序列化呢?</p>
<p> 这还得从 “ArrayList 是基于数组实现的”开始说起。大家都知道，数组是定长的，就是说，数组一旦声明了，长度（容量）就是固定的，不能像某些东西一样伸缩自如。这就很麻烦，数组一旦装满了，就不能添加新的元素进来了。</p>
<p> ArrayList 不想像数组这样活着，它想能屈能伸，所以它实现了动态扩容。一旦在添加元素的时候，发现容量用满了 s == elementData.length ，就按照原来数组的 1.5 倍（ oldCapacity &gt;&gt; 1 ）进行扩容。扩容之后，再将原有的数组复制到新分配的内存地址上 Arrays.copyOf(elementData, newCapacity) 。</p>
<p> 这部分源码我们在之前讲 ArrayList 的时候就已经讲的很清楚了，这里就一笔带过。</p>
<p> 动态扩容意味着什么？</p>
<p> 意味着数组的实际大小可能永远无法被填满的，总有多余出来空置的内存空间。</p>
<p> 比如说，默认的数组大小是 10，当添加第 11 个元素的时候，数组的长度扩容了 1.5 倍，也就是 15，意味着还有 4 个内存空间是闲置的，对吧？</p>
<p> 序列化的时候，如果把整个数组都序列化的话，是不是就多序列化了 4 个内存空间。当存储的元素数量非常非常多的时候，闲置的空间就非常非常大，序列化耗费的时间就会非常非常多。</p>
<p> 于是，ArrayList 做了一个愉快而又聪明的决定，内部提供了两个私有方法 writeObject 和 readObject 来完成序列化和反序列化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 将此列表实例的状态序列写入指定的 ObjectOutputStream。</span><br><span class="line"> * （即，保存这个列表实例到一个流中。）</span><br><span class="line"> *</span><br><span class="line"> * @param s 要写入的流</span><br><span class="line"> * @throws java.io.IOException 如果写入流时发生异常</span><br><span class="line"> */</span><br><span class="line">private void writeObject(java.io.ObjectOutputStream s)</span><br><span class="line">        throws java.io.IOException &#123;</span><br><span class="line">    s.defaultWriteObject(); // 写出对象的默认字段</span><br><span class="line">    // Write out size as capacity for behavioral compatibility with clone()</span><br><span class="line">    s.writeInt(size); // 写出 size</span><br><span class="line">    // Write out all elements in the proper order.</span><br><span class="line">    for (int i=0; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]); // 依次写出 elementData 数组中的元素</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 从 writeObject 方法的源码中可以看得出，它使用了 ArrayList 的实际大小 size 而不是数组的长度（ elementData.length ）来作为元素的上限进行序列化。</p>
<p> 此处应该有掌声啊！不是为我，为 Java 源码的作者们，他们真的是太厉害了，可以用两个词来形容他们——殚精竭虑、精益求精。</p>
<p> 666</p>
<p> 这是readObject方法的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 从指定的 ObjectInputStream 中读取此列表实例的状态序列。</span><br><span class="line"> * （即，从流中恢复这个列表实例。）</span><br><span class="line"> *</span><br><span class="line"> * @param s 从中读取此列表实例的状态序列的流</span><br><span class="line"> * @throws java.io.IOException 如果读取流时发生异常</span><br><span class="line"> * @throws ClassNotFoundException 如果在读取流时找不到类</span><br><span class="line"> */</span><br><span class="line">private void readObject(java.io.ObjectInputStream s)</span><br><span class="line">        throws java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">    elementData = EMPTY_ELEMENTDATA; // 初始化 elementData 数组为空数组</span><br><span class="line">    // 读取默认字段</span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    // 读取容量，这个值被忽略，因为在 ArrayList 中，容量和长度是两个不同的概念</span><br><span class="line">    s.readInt();</span><br><span class="line">    if (size &gt; 0) &#123;</span><br><span class="line">        // 分配一个新的 elementData 数组，大小为 size</span><br><span class="line">        ensureCapacityInternal(size);</span><br><span class="line">        Object[] a = elementData;</span><br><span class="line">        // 依次从输入流中读取元素，并将其存储在数组中</span><br><span class="line">        for (int i=0; i&lt;size; i++) &#123;</span><br><span class="line">            a[i] = s.readObject(); // 读取对象并存储在 elementData 数组中</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>02、LinkedList 是如何实现的？ </strong></p>
<p> LinkedList 是一个继承自 AbstractSequentialList 的双向链表，因此它也可以被当作堆栈、队列或双端队列进行操作。</p>
<p><img src="\assets\note\image-20231010105516540.png" alt="image-20231010105516540"></p>
<p> 来看一下部分源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedList&lt;E&gt;</span><br><span class="line">    extends AbstractSequentialList&lt;E&gt;</span><br><span class="line">    implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    transient int size = 0; // 非序列化字段，表示链表中的节点个数</span><br><span class="line">    transient Node&lt;E&gt; first; // 非序列化字段，指向链表中的第一个节点</span><br><span class="line">    transient Node&lt;E&gt; last; // 非序列化字段，指向链表中的最后一个节点</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  LinkedList 内部定义了一个 Node 节点，它包含 3 个部分：元素内容 item，前引用 prev 和后引用 next。</p>
<p> 这个在讲 LinkedList 的时候也讲过了，这里略过。</p>
<p> LinkedList 还实现了 Cloneable 接口，这表明 LinkedList 是支持拷贝的。</p>
<p> LinkedList 还实现了 Serializable 接口，这表明 LinkedList 是支持序列化的。眼睛雪亮的小伙伴可能又注意到了，LinkedList 中的关键字段 size、first、last 都使用了 transient 关键字修饰，这不又矛盾了吗？到底是想序列化还是不想序列化？</p>
<p> 答案是 LinkedList 想按照自己的方式序列化，来看它自己实现的 writeObject() 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void writeObject(java.io.ObjectOutputStream s)</span><br><span class="line">        throws java.io.IOException &#123;</span><br><span class="line">    // 写入默认的序列化标记</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line">    // 写入链表的节点个数</span><br><span class="line">    s.writeInt(size);</span><br><span class="line">    // 按正确的顺序写入所有元素</span><br><span class="line">    for (LinkedList.Node&lt;E&gt; x = first; x != null; x = x.next)</span><br><span class="line">        s.writeObject(x.item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 发现没？LinkedList 在序列化的时候只保留了元素的内容 item，并没有保留元素的前后引用。这样就节省了不少内存空间，对吧？</p>
<p> 那有些小伙伴可能就疑惑了，只保留元素内容，不保留前后引用，那反序列化的时候怎么办？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private void readObject(java.io.ObjectInputStream s)</span><br><span class="line">        throws java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">    // 读取默认的序列化标记</span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    // 读取链表的节点个数</span><br><span class="line">    int size = s.readInt();</span><br><span class="line">    // 按正确的顺序读取所有元素</span><br><span class="line">    for (int i = 0; i &lt; size; i++)</span><br><span class="line">        linkLast((E)s.readObject()); // 读取元素并将其添加到链表末尾</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void linkLast(E e) &#123;</span><br><span class="line">    final LinkedList.Node&lt;E&gt; l = last;</span><br><span class="line">    final LinkedList.Node&lt;E&gt; newNode = new LinkedList.Node&lt;&gt;(l, e, null);</span><br><span class="line">    last = newNode; // 将新节点作为链表尾节点</span><br><span class="line">    if (l == null)</span><br><span class="line">        first = newNode; // 如果链表为空，将新节点作为链表头节点</span><br><span class="line">    else</span><br><span class="line">        l.next = newNode; // 否则将新节点链接到链表尾部</span><br><span class="line">    size++; // 增加节点个数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 注意 for 循环中的 linkLast() 方法，它可以把链表重新链接起来，这样就恢复了链表序列化之前的顺序。</p>
<p> 很妙，对吧？</p>
<p> 和 ArrayList 相比，LinkedList 没有实现 RandomAccess 接口，这是因为 LinkedList 存储数据的内存地址是不连续的，所以不支持随机访问。</p>
<p><strong>03、新增元素时究竟谁快？ </strong></p>
<p> 前面我们已经从多个维度了解了 ArrayList 和 LinkedList 的实现原理和各自的特点。那接下来，我们就来聊聊 ArrayList 和 LinkedList 在新增元素时究竟谁快？</p>
<p><strong>1）ArrayList </strong></p>
<p> ArrayList 新增元素有两种情况，一种是直接将元素添加到数组末尾，一种是将元素插入到指定位置。</p>
<p> 添加到数组末尾的源码（这部分前面讲 ArrayList 的时候讲过了，这里再温故一下）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    add(e, elementData, size);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">private void add(E e, Object[] elementData, int s) &#123;</span><br><span class="line">    if (s == elementData.length)</span><br><span class="line">        elementData = grow(); // 扩容数组</span><br><span class="line">    elementData[s] = e; // 将元素添加到数组末尾</span><br><span class="line">    size = s + 1; // 增加元素个数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 很简单，先判断是否需要扩容，然后直接通过索引将元素添加到末尾。</p>
<p> 插入到指定位置的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> public void add(int index, E element) &#123;</span><br><span class="line">    rangeCheckForAdd(index); // 检查插入位置是否越界</span><br><span class="line">    final int s; // 当前元素个数</span><br><span class="line">    Object[] elementData; // 元素数组</span><br><span class="line">    if ((s = size) == (elementData = this.elementData).length) // 如果数组已满，则扩容</span><br><span class="line">        elementData = grow();</span><br><span class="line">    System.arraycopy(elementData, index,</span><br><span class="line">            elementData, index + 1,</span><br><span class="line">            s - index); // 将插入位置后的元素向右移动一位</span><br><span class="line">    elementData[index] = element; // 将新元素插入到指定位置</span><br><span class="line">    size = s + 1; // 增加元素个数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 先检查插入的位置是否在合理的范围之内，然后判断是否需要扩容，再把该位置以后的元素复制到新添加元素的位置之后，最后通过索引将元素添加到指定的位置。</p>
<p><strong>2）LinkedList </strong></p>
<p> LinkedList 新增元素也有两种情况，一种是直接将元素添加到队尾，一种是将元素插入到指定位置。</p>
<p> 添加到队尾的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    linkLast(e); // 将元素添加到链表末尾</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">void linkLast(E e) &#123;</span><br><span class="line">    final LinkedList.Node&lt;E&gt; l = last; // 获取链表的尾节点</span><br><span class="line">    final LinkedList.Node&lt;E&gt; newNode = new LinkedList.Node&lt;&gt;(l, e, null); // 创建新节点</span><br><span class="line">    last = newNode; // 将新节点作为链表的尾节点</span><br><span class="line">    if (l == null)</span><br><span class="line">        first = newNode; // 如果链表为空，则将新节点作为链表的头节点</span><br><span class="line">    else</span><br><span class="line">        l.next = newNode; // 否则将新节点链接到链表的尾部</span><br><span class="line">    size++; // 增加节点个数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 先将队尾的节点 last 存放到临时变量 l 中，然后生成新的 Node 节点，并赋给 last，如果 l  为 null，说明是第一次添加，所以 first 为新的节点；否则将新的节点赋给之前 last 的 next。</p>
<p> 插入到指定位置的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">    checkPositionIndex(index); // 检查插入位置是否越界</span><br><span class="line">    if (index == size)</span><br><span class="line">        linkLast(element); // 如果插入位置为链表末尾，则将元素添加到链表末尾</span><br><span class="line">    else</span><br><span class="line">        linkBefore(element, node(index)); // 否则将元素插入到指定位置的前面的节点后面</span><br><span class="line">&#125;</span><br><span class="line">LinkedList.Node&lt;E&gt; node(int index) &#123;</span><br><span class="line">    if (index &lt; (size &gt;&gt; 1)) &#123; // 如果插入位置在链表前半部分，则从头节点开始查找</span><br><span class="line">        LinkedList.Node&lt;E&gt; x = first;</span><br><span class="line">        for (int i = 0; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        return x;</span><br><span class="line">    &#125; else &#123; // 否则从尾节点开始查找</span><br><span class="line">        LinkedList.Node&lt;E&gt; x = last;</span><br><span class="line">        for (int i = size - 1; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void linkBefore(E e, LinkedList.Node&lt;E&gt; succ) &#123;</span><br><span class="line">    final LinkedList.Node&lt;E&gt; pred = succ.prev; // 获取插入位置的前驱节点</span><br><span class="line">    final LinkedList.Node&lt;E&gt; newNode = new LinkedList.Node&lt;&gt;(pred, e, succ); // 创建新节点</span><br><span class="line">    succ.prev = newNode; // 将新节点链接到后继节点</span><br><span class="line">    if (pred == null)</span><br><span class="line">        first = newNode; // 如果前驱节点为空，则将新节点作为头节点</span><br><span class="line">    else</span><br><span class="line">        pred.next = newNode; // 否则将新节点链接到前驱节点</span><br><span class="line">    size++; // 增加节点个数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 先检查插入的位置是否在合理的范围之内，然后判断插入的位置是否是队尾，如果是，添加到队尾；否则执行 linkBefore() 方法。</p>
<p> 在执行 linkBefore() 方法之前，会调用 node() 方法查找指定位置上的元素，这一步是需要遍历 LinkedList 的。如果插入的位置靠前前半段，就从队头开始往后找；否则从队尾往前找。也就是说，如果插入的位置越靠近 LinkedList 的中间位置，遍历所花费的时间就越多。</p>
<p> 找到指定位置上的元素（参数succ）之后，就开始执行 linkBefore() 方法，先将 succ 的前一个节点（prev）存放到临时变量 pred 中，然后生成新的 Node 节点（newNode），并将 succ 的前一个节点变更为 newNode，如果 pred 为 null，说明插入的是队头，所以 first 为新节点；否则将 pred 的后一个节点变更为 newNode。</p>
<p><img src="\assets\note\image-20231010110120018.png" alt="image-20231010110120018"></p>
<p> 经过源码分析以后，你是不是在想：“好像 ArrayList 在新增元素的时候效率并不一定比 LinkedList 低啊！”</p>
<p> 当两者的起始长度是一样的情况下：</p>
<ul>
<li><p>如果是从集合的头部新增元素，ArrayList 花费的时间应该比 LinkedList 多，因为需要对头部以后的元素进行复制。</p>
<p>我们来测试一下：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayListTest &#123;</span><br><span class="line">    public static void addFromHeaderTest(int num) &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(num);</span><br><span class="line">        int i = 0;</span><br><span class="line">        long timeStart = System.currentTimeMillis();</span><br><span class="line">        while (i &lt; num) &#123;</span><br><span class="line">            list.add(0, i + &quot;沉默王二&quot;);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        long timeEnd = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;ArrayList从集合头部位置新增元素花费的时间&quot; + (timeEnd - timeStart));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class LinkedListTest &#123;</span><br><span class="line">    public static void addFromHeaderTest(int num) &#123;</span><br><span class="line">        LinkedList&lt;String&gt; list = new LinkedList&lt;String&gt;();</span><br><span class="line">        int i = 0;</span><br><span class="line">        long timeStart = System.currentTimeMillis();</span><br><span class="line">        while (i &lt; num) &#123;</span><br><span class="line">            list.addFirst(i + &quot;沉默王二&quot;);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        long timeEnd = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;LinkedList从集合头部位置新增元素花费的时间&quot; + (timeEnd - timeStart));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> num 为 10000，代码实测后的时间如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList从集合头部位置新增元素花费的时间595</span><br><span class="line">LinkedList从集合头部位置新增元素花费的时间15</span><br></pre></td></tr></table></figure>
<p> 此时，ArrayList 花费的时间比 LinkedList 要多很多。</p>
<ul>
<li><p>如果是从集合的中间位置新增元素，ArrayList 花费的时间搞不好要比 LinkedList 少，因为 LinkedList 需要遍历。</p>
<p>来看测试代码。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayListTest &#123;</span><br><span class="line">    public static void addFromMidTest(int num) &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(num);</span><br><span class="line">        int i = 0;</span><br><span class="line">        long timeStart = System.currentTimeMillis();</span><br><span class="line">        while (i &lt; num) &#123;</span><br><span class="line">            int temp = list.size();</span><br><span class="line">            list.add(temp / 2, i + &quot;沉默王二&quot;);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        long timeEnd = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;ArrayList从集合中间位置新增元素花费的时间&quot; + (timeEnd - timeStart));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class LinkedListTest &#123;</span><br><span class="line">    public static void addFromMidTest(int num) &#123;</span><br><span class="line">        LinkedList&lt;String&gt; list = new LinkedList&lt;String&gt;();</span><br><span class="line">        int i = 0;</span><br><span class="line">        long timeStart = System.currentTimeMillis();</span><br><span class="line">        while (i &lt; num) &#123;</span><br><span class="line">            int temp = list.size();</span><br><span class="line">            list.add(temp / 2, i + &quot;沉默王二&quot;);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        long timeEnd = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;LinkedList从集合中间位置新增元素花费的时间&quot; + (timeEnd - timeStart));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>num 为 10000，代码实测后的时间如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList从集合中间位置新增元素花费的时间16</span><br><span class="line">LinkedList从集合中间位置新增元素花费的时间114</span><br></pre></td></tr></table></figure>
<p>ArrayList 花费的时间比 LinkedList 要少很多很多。</p>
<ul>
<li>如果是从集合的尾部新增元素，ArrayList 花费的时间应该比 LinkedList 少，因为数组是一段连续的内存空间，也不需要复制数组；而链表需要创建新的对象，前后引用也要重新排列。</li>
</ul>
<p>来看测试代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedListTest &#123;</span><br><span class="line">    public static void addFromTailTest(int num) &#123;</span><br><span class="line">        LinkedList&lt;String&gt; list = new LinkedList&lt;String&gt;();</span><br><span class="line">        int i = 0;</span><br><span class="line">        long timeStart = System.currentTimeMillis();</span><br><span class="line">        while (i &lt; num) &#123;</span><br><span class="line">            list.add(i + &quot;沉默王二&quot;);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        long timeEnd = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;LinkedList从集合尾部位置新增元素花费的时间&quot; + (timeEnd - timeStart));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ArrayListTest &#123;</span><br><span class="line">    public static void addFromTailTest(int num) &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(num);</span><br><span class="line">        int i = 0;</span><br><span class="line">        long timeStart = System.currentTimeMillis();</span><br><span class="line">        while (i &lt; num) &#123;</span><br><span class="line">            list.add(i + &quot;沉默王二&quot;);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        long timeEnd = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;ArrayList从集合尾部位置新增元素花费的时间&quot; + (timeEnd - timeStart));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>num 为 10000，代码实测后的时间如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList从集合尾部位置新增元素花费的时间69</span><br><span class="line">LinkedList从集合尾部位置新增元素花费的时间193</span><br></pre></td></tr></table></figure>
<p>ArrayList 花费的时间比 LinkedList 要少一些。</p>
<p>这样的结论和预期的是不是不太相符？ArrayList 在添加元素的时候如果不涉及到扩容，性能在两种情况下（中间位置新增元素、尾部新增元素）比 LinkedList 好很多，只有头部新增元素的时候比 LinkedList 差，因为数组复制的原因。</p>
<p>当然了，如果涉及到数组扩容的话，ArrayList 的性能就没那么可观了，因为扩容的时候也要复制数组。</p>
<p><strong>04、删除元素时究竟谁快？ </strong></p>
<p><strong>1）ArrayList </strong></p>
<p>ArrayList 删除元素的时候，有两种方式，一种是直接删除元素（ remove(Object) ），需要直先遍历数组，找到元素对应的索引；一种是按照索引删除元素（ remove(int) ）。</p>
<p>来看一下源码（其实前面也讲过了，这里温习一下）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    final Object[] es = elementData; // 获取数组元素</span><br><span class="line">    final int size = this.size; // 获取数组大小</span><br><span class="line">    int i = 0;</span><br><span class="line">    found: &#123;</span><br><span class="line">        if (o == null) &#123;</span><br><span class="line">            for (; i &lt; size; i++)</span><br><span class="line">                if (es[i] == null)</span><br><span class="line">                    break found;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (; i &lt; size; i++)</span><br><span class="line">                if (o.equals(es[i]))</span><br><span class="line">                    break found;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    fastRemove(es, i); // 调用 fastRemove 方法快速移除元素</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public E remove(int index) &#123;</span><br><span class="line">    Objects.checkIndex(index, size); // 检查索引是否越界</span><br><span class="line">    final Object[] es = elementData; // 获取数组元素</span><br><span class="line">    oldValue = (E) es[index]; // 获取要删除的元素</span><br><span class="line">    fastRemove(es, index); // 调用 fastRemove 方法快速移除元素</span><br><span class="line">    return oldValue; // 返回被删除的元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本质上讲，两个方法是一样的，它们最后调用的都是 fastRemove(Object, int) 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private void fastRemove(Object[] es, int i) &#123;</span><br><span class="line">    final int newSize;</span><br><span class="line">    if ((newSize = size - 1) &gt; i) // 如果要删除的不是最后一个元素</span><br><span class="line">        System.arraycopy(es, i + 1, es, i, newSize - i); // 将要删除元素后面的元素向前移动一位</span><br><span class="line">    es[size = newSize] = null; // 将最后一个元素置为 null，帮助垃圾回收</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从源码可以看得出，只要删除的不是最后一个元素，都需要重新移动数组。删除的元素位置越靠前，代价就越大。</p>
<p><strong>2）LinkedList </strong></p>
<p>LinkedList 删除元素的时候，有四种常用的方式：</p>
<ul>
<li>remove(int) ，删除指定位置上的元素</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public E remove(int index) &#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    return unlink(node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先检查索引，再调用 node(int) 方法（ 前后半段遍历，和新增元素操作一样）找到节点 Node，然后调用 unlink(Node) 解除节点的前后引用，同时更新前节点的后引用和后节点的前引用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">E unlink(Node&lt;E&gt; x) &#123;</span><br><span class="line">    final E element = x.item; // 获取要删除的节点的元素</span><br><span class="line">    final Node&lt;E&gt; next = x.next; // 获取要删除的节点的后继节点</span><br><span class="line">    final Node&lt;E&gt; prev = x.prev; // 获取要删除的节点的前驱节点</span><br><span class="line">    if (prev == null) &#123; // 如果要删除的节点是第一个节点</span><br><span class="line">        first = next; // 将头节点更新为要删除的节点的后继节点</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        prev.next = next; // 将要删除的节点的前驱节点的后继节点指向要删除的节点的后继节点</span><br><span class="line">        x.prev = null; // 将要删除的节点的前驱节点置为 null，帮助垃圾回收</span><br><span class="line">    &#125;</span><br><span class="line">    if (next == null) &#123; // 如果要删除的节点是最后一个节点</span><br><span class="line">        last = prev; // 将尾节点更新为要删除的节点的前驱节点</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        next.prev = prev; // 将要删除的节点的后继节点的前驱节点指向要删除的节点的前驱节点</span><br><span class="line">        x.next = null; // 将要删除的节点的后继节点置为 null，帮助垃圾回收</span><br><span class="line">    &#125;</span><br><span class="line">    x.item = null; // 将要删除的节点的元素置为 null，帮助垃圾回收</span><br><span class="line">    size--; // 将链表的长度减一</span><br><span class="line">    return element; // 返回被删除的元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>remove(Object) ，直接删除元素</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    if (o == null) &#123; // 如果要删除的元素为 null</span><br><span class="line">        for (LinkedList.Node&lt;E&gt; x = first; x != null; x = x.next) &#123;</span><br><span class="line">            if (x.item == null) &#123; // 如果找到了要删除的节点</span><br><span class="line">                unlink(x); // 调用 unlink 方法删除指定节点</span><br><span class="line">                return true; // 返回删除成功</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (LinkedList.Node&lt;E&gt; x = first; x != null; x = x.next) &#123;</span><br><span class="line">            if (o.equals(x.item)) &#123; // 如果找到了要删除的节点</span><br><span class="line">                unlink(x); // 调用 unlink 方法删除指定节点</span><br><span class="line">                return true; // 返回删除成功</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false; // 没有找到要删除的节点，返回删除失败</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也是先前后半段遍历，找到要删除的元素后调用 unlink(Node) 。</p>
<ul>
<li>removeFirst() ，删除第一个节点</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public E removeFirst() &#123;</span><br><span class="line">    final LinkedList.Node&lt;E&gt; f = first;</span><br><span class="line">    if (f == null)</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    return unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line">private E unlinkFirst(LinkedList.Node&lt;E&gt; f) &#123;</span><br><span class="line">    final E element = f.item; // 获取要删除的节点的元素</span><br><span class="line">    final LinkedList.Node&lt;E&gt; next = f.next; // 获取要删除的节点的后继节点</span><br><span class="line">    f.item = null; // 将要删除的节点的元素置为 null，帮助垃圾回收</span><br><span class="line">    f.next = null; // 将要删除的节点的后继节点置为 null，帮助垃圾回收</span><br><span class="line">    first = next; // 将头节点更新为要删除的节点的后继节点</span><br><span class="line">    if (next == null) // 如果链表已经为空</span><br><span class="line">        last = null; // 将尾节点置为 null</span><br><span class="line">    else</span><br><span class="line">        next.prev = null; // 将要删除的节点的后继节点的前驱节点置为 null，帮助垃圾回收</span><br><span class="line">    size--; // 将链表的长度减一</span><br><span class="line">    return element; // 返回被删除的元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除第一个节点就不需要遍历了，只需要把第二个节点更新为第一个节点即可。</p>
<ul>
<li>removeLast() ，删除最后一个节点</li>
</ul>
<p>删除最后一个节点和删除第一个节点类似，只需要把倒数第二个节点更新为最后一个节点即可。</p>
<p>可以看得出，LinkedList 在删除比较靠前和比较靠后的元素时，非常高效，但如果删除的是中间位置的元素，效率就比较低了。</p>
<p>这里就不再做代码测试了，感兴趣的话可以自己试试，结果和新增元素保持一致：</p>
<ul>
<li>从集合头部删除元素时，ArrayList 花费的时间比 LinkedList 多很多；</li>
<li>从集合中间位置删除元素时，ArrayList 花费的时间比 LinkedList 少很多；</li>
<li>从集合尾部删除元素时，ArrayList 花费的时间比 LinkedList 少一点。</li>
</ul>
<p>我本地的统计结果如下所示，可以作为参考：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ArrayList从集合头部位置删除元素花费的时间380</span><br><span class="line">LinkedList从集合头部位置删除元素花费的时间4</span><br><span class="line">ArrayList从集合中间位置删除元素花费的时间381</span><br><span class="line">LinkedList从集合中间位置删除元素花费的时间5922</span><br><span class="line">ArrayList从集合尾部位置删除元素花费的时间8</span><br><span class="line">LinkedList从集合尾部位置删除元素花费的时间12</span><br></pre></td></tr></table></figure>
<p><strong>05、遍历元素时究竟谁快？ </strong></p>
<p><strong>1）ArrayList </strong></p>
<p>遍历 ArrayList 找到某个元素的话，通常有两种形式：</p>
<ul>
<li>get(int) ，根据索引找元素</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public E get(int index) &#123;</span><br><span class="line">    Objects.checkIndex(index, size);</span><br><span class="line">    return elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 ArrayList 是由数组实现的，所以根据索引找元素非常的快，一步到位。</p>
<ul>
<li>indexOf(Object) ，根据元素找索引</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public int indexOf(Object o) &#123;</span><br><span class="line">    return indexOfRange(o, 0, size);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int indexOfRange(Object o, int start, int end) &#123;</span><br><span class="line">    Object[] es = elementData; // 获取 ArrayList 中的元素数组</span><br><span class="line">    if (o == null) &#123; // 如果要查找的元素为 null</span><br><span class="line">        for (int i = start; i &lt; end; i++) &#123;</span><br><span class="line">            if (es[i] == null) &#123; // 如果找到了要查找的元素</span><br><span class="line">                return i; // 返回元素在 ArrayList 中的索引</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (int i = start; i &lt; end; i++) &#123;</span><br><span class="line">            if (o.equals(es[i])) &#123; // 如果找到了要查找的元素</span><br><span class="line">                return i; // 返回元素在 ArrayList 中的索引</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1; // 没有找到要查找的元素，返回 -1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据元素找索引的话，就需要遍历整个数组了，从头到尾依次找。</p>
<p><strong>2）LinkedList </strong></p>
<p>遍历 LinkedList 找到某个元素的话，通常也有两种形式：</p>
<ul>
<li>get(int) ，找指定位置上的元素</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public E get(int index) &#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    return node(index).item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>既然需要调用 node(int) 方法，就意味着需要前后半段遍历了。</p>
<ul>
<li>indexOf(Object) ，找元素所在的位置</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public int indexOf(Object o) &#123;</span><br><span class="line">    int index = 0; // 初始化索引为 0</span><br><span class="line">    if (o == null) &#123; // 如果要查找的元素为 null</span><br><span class="line">        for (LinkedList.Node&lt;E&gt; x = first; x != null; x = x.next) &#123; // 从头节点开始遍历链表</span><br><span class="line">            if (x.item == null) // 如果找到了要查找的元素</span><br><span class="line">                return index; // 返回元素在 LinkedList 中的索引</span><br><span class="line">            index++; // 索引加一</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (LinkedList.Node&lt;E&gt; x = first; x != null; x = x.next) &#123; // 从头节点开始遍历链表</span><br><span class="line">            if (o.equals(x.item)) // 如果找到了要查找的元素</span><br><span class="line">                return index; // 返回元素在 LinkedList 中的索引</span><br><span class="line">            index++; // 索引加一</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1; // 没有找到要查找的元素，返回 -1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要遍历整个链表，和 ArrayList 的 indexOf() 类似。</p>
<p>那在我们对集合遍历的时候，通常有两种做法，一种是使用 for 循环，一种是使用迭代器（Iterator）。</p>
<p>如果使用的是 for 循环，可想而知 LinkedList 在 get 的时候性能会非常差，因为每一次外层的 for 循环，都要执行一次 node(int) 方法进行前后半段的遍历。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">LinkedList.Node&lt;E&gt; node(int index) &#123;</span><br><span class="line">    // assert isElementIndex(index);</span><br><span class="line">    if (index &lt; (size &gt;&gt; 1)) &#123; // 如果要查找的元素在链表的前半部分</span><br><span class="line">        LinkedList.Node&lt;E&gt; x = first; // 从头节点开始遍历链表</span><br><span class="line">        for (int i = 0; i &lt; index; i++) // 循环查找元素</span><br><span class="line">            x = x.next;</span><br><span class="line">        return x; // 返回要查找的元素节点</span><br><span class="line">    &#125; else &#123; // 如果要查找的元素在链表的后半部分</span><br><span class="line">        LinkedList.Node&lt;E&gt; x = last; // 从尾节点开始遍历链表</span><br><span class="line">        for (int i = size - 1; i &gt; index; i--) // 循环查找元素</span><br><span class="line">            x = x.prev;</span><br><span class="line">        return x; // 返回要查找的元素节点</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那如果使用的是迭代器呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;String&gt; list = new LinkedList&lt;String&gt;();</span><br><span class="line">for (Iterator&lt;String&gt; it = list.iterator(); it.hasNext();) &#123;</span><br><span class="line">    it.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代器只会调用一次 node(int) 方法，在执行 list.iterator() 的时候：先调用 AbstractSequentialList 类的 iterator() 方法，再调用 AbstractList 类的 listIterator() 方法，再调用 LinkedList 类的 listIterator(int) 方法，如下图所示。</p>
<p><img src="\assets\note\image-20231010111515822.png" alt="image-20231010111515822"></p>
<p>最后返回的是 LinkedList 类的内部私有类 ListItr 对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public ListIterator&lt;E&gt; listIterator(int index) &#123;</span><br><span class="line">    checkPositionIndex(index); // 检查索引是否在有效范围内</span><br><span class="line">    return new LinkedList.ListItr(index); // 创建一个新的 ListItr 对象并返回</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private class ListItr implements ListIterator&lt;E&gt; &#123;</span><br><span class="line">    private LinkedList.Node&lt;E&gt; lastReturned; // 上一个已返回的节点</span><br><span class="line">    private LinkedList.Node&lt;E&gt; next; // 下一个节点</span><br><span class="line">    private int nextIndex; // 下一个节点的索引</span><br><span class="line">    private int expectedModCount = modCount; // 链表被修改的次数</span><br><span class="line">    ListItr(int index) &#123;</span><br><span class="line">        // assert isPositionIndex(index);</span><br><span class="line">        next = (index == size) ? null : node(index); // 如果 index 等于 size，next 为 null，否则返回 node(index)</span><br><span class="line">        nextIndex = index; // 设置 nextIndex 为 index</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean hasNext() &#123;</span><br><span class="line">        return nextIndex &lt; size; // 如果下一个节点的索引小于链表的长度，返回 true，否则返回 false</span><br><span class="line">    &#125;</span><br><span class="line">    public E next() &#123;</span><br><span class="line">        checkForComodification(); // 检查链表是否已经被修改</span><br><span class="line">        if (!hasNext()) // 如果没有下一个节点，抛出 NoSuchElementException 异常</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">        lastReturned = next; // 将下一个节点设置为上一个已返回节点</span><br><span class="line">        next = next.next; // 将下一个节点设置为当前节点的下一个节点</span><br><span class="line">        nextIndex++; // 将下一个节点的索引增加 1</span><br><span class="line">        return lastReturned.item; // 返回上一个已返回节点的元素</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行 ListItr 的构造方法时调用了一次 node(int) 方法，返回第一个节点。在此之后，迭代器就执行 hasNext() 判断有没有下一个，执行 next() 方法下一个节点。</p>
<p>由此，可以得出这样的结论：遍历 LinkedList 的时候，千万不要使用 for 循环，要使用迭代器。</p>
<p>也就是说，for 循环遍历的时候，ArrayList 花费的时间远小于 LinkedList；迭代器遍历的时候，两者性能差不多。</p>
<p><strong>06、两者的使用场景 </strong></p>
<p>当需要频繁随机访问元素的时候，例如读取大量数据并进行处理或者需要对数据进行排序或查找的场景，可以使用 ArrayList。例如一个学生管理系统，需要对学生列表进行排序或查找操作，可以使用 ArrayList 存储学生信息，以便快速访问和处理。</p>
<p>当需要频繁插入和删除元素的时候，例如实现队列或栈，或者需要在中间插入或删除元素的场景，可以使用 LinkedList。例如一个实时聊天系统，需要实现一个消息队列，可以使用 LinkedList 存储消息，以便快速插入和删除消息。</p>
<p>在一些特殊场景下，可能需要同时支持随机访问和插入/删除操作。例如一个在线游戏系统，需要实现一个玩家列表，需要支持快速查找和遍历玩家，同时也需要支持玩家的加入和离开。在这种情况下，可以使用 LinkedList 和 ArrayList 的组合，例如使用 LinkedList 存储玩家，以便快速插入和删除玩家，同时使用 ArrayList 存储玩家列表，以便快速查找和遍历玩家。</p>
<p>“好了，三妹，关于 LinkedList 和 ArrayList 的差别，我们就先聊到这，你也不用太去扣细节，直到其中的差别就好了。”</p>
<p>“好的，二哥。”</p>
<h2 id="4-6-Java泛型，深入解析"><a href="#4-6-Java泛型，深入解析" class="headerlink" title="4.6 Java泛型，深入解析"></a>4.6 Java泛型，深入解析</h2><p>“二哥，为什么要设计泛型啊？”三妹开门见山地问。</p>
<p>“三妹啊，听哥慢慢给你讲啊。”我说。</p>
<p>Java 在 1.5 时增加了泛型机制，据说专家们为此花费了 5 年左右的时间（听起来是相当不容易）。有了泛型之后，尤其是对集合类的使用，就变得更规范了。</p>
<p>看下面这段简单的代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">list.add(&quot;沉默王二&quot;);</span><br><span class="line">String str = list.get(0);</span><br></pre></td></tr></table></figure>
<p>“三妹，你能想象到在没有泛型之前该怎么办吗？”</p>
<p>“嗯，想不到，还是二哥你说吧。”</p>
<p>嗯，我们可以使用 Object 数组来设计 Arraylist 类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Arraylist &#123;</span><br><span class="line">    private Object[] objs;</span><br><span class="line">    private int i = 0;</span><br><span class="line">    public void add(Object obj) &#123;</span><br><span class="line">        objs[i++] = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Object get(int i) &#123;</span><br><span class="line">        return objs[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我们向 Arraylist 中存取数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Arraylist list = new Arraylist();</span><br><span class="line">list.add(&quot;沉默王二&quot;);</span><br><span class="line">list.add(new Date());</span><br><span class="line">String str = (String)list.get(0);</span><br></pre></td></tr></table></figure>
<p>“三妹，你有没有发现这两个问题？”</p>
<ul>
<li>Arraylist 可以存放任何类型的数据（既可以存字符串，也可以混入日期），因为所有类都继承自 Object 类。</li>
<li>从 Arraylist 取出数据的时候需要强制类型转换，因为编译器并不能确定你取的是字符串还是日期。</li>
</ul>
<p>“嗯嗯，是的呢。”三妹说。</p>
<p>对比一下，你就能明显地感受到泛型的优秀之处：使用类型参数解决了元素的不确定性——参数类型为 String 的集合中是不允许存放其他类型元素的，取出数据的时候也不需要强制类型转换了。</p>
<p><strong>动手设计一个泛型 </strong></p>
<p>“二哥，那怎么才能设计一个泛型呢？”</p>
<p>“三妹啊，你一个小白只要会用泛型就行了，还想设计泛型啊？！不过，既然你想了解，哥义不容辞。”</p>
<p>首先，我们来按照泛型的标准重新设计一下 Arraylist 类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Arraylist&lt;E&gt; &#123;</span><br><span class="line">    private Object[] elementData;</span><br><span class="line">    private int size = 0;</span><br><span class="line">    public Arraylist(int initialCapacity) &#123;</span><br><span class="line">        this.elementData = new Object[initialCapacity];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean add(E e) &#123;</span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    E elementData(int index) &#123;</span><br><span class="line">        return (E) elementData[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个泛型类就是具有一个或多个类型变量的类。Arraylist 类引入的类型变量为 E（Element，元素的首字母），使用尖括号 &lt;&gt; 括起来，放在类名的后面。</p>
<p>然后，我们可以用具体的类型（比如字符串）替换类型变量来实例化泛型类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Arraylist&lt;String&gt; list = new Arraylist&lt;String&gt;();</span><br><span class="line">list.add(&quot;沉默王三&quot;);</span><br><span class="line">String str = list.get(0);</span><br></pre></td></tr></table></figure>
<p>Date 类型也可以的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Arraylist&lt;Date&gt; list = new Arraylist&lt;Date&gt;();</span><br><span class="line">list.add(new Date());</span><br><span class="line">Date date = list.get(0);</span><br></pre></td></tr></table></figure>
<p>其次，我们还可以在一个非泛型的类（或者泛型类）中定义泛型方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Arraylist&lt;E&gt; &#123;</span><br><span class="line">    public &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">        return (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过，说实话，泛型方法的定义看起来略显晦涩。来一副图吧（注意：方法返回类型和方法参数类型至少需要一个）。</p>
<p><img src="\image-20231010112138716.png" alt="image-20231010112138716"></p>
<p>现在，我们来调用一下泛型方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Arraylist&lt;String&gt; list = new Arraylist&lt;&gt;(4);</span><br><span class="line">list.add(&quot;沉&quot;);</span><br><span class="line">list.add(&quot;默&quot;);</span><br><span class="line">list.add(&quot;王&quot;);</span><br><span class="line">list.add(&quot;二&quot;);</span><br><span class="line">String [] strs = new String [4];</span><br><span class="line">strs = list.toArray(strs);</span><br><span class="line">for (String str : strs) &#123;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>泛型限定符 </strong></p>
<p>然后，我们再来说说泛型变量的限定符 extends 。</p>
<p>在解释这个限定符之前，我们假设有三个类，它们之间的定义是这样的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Wanglaoer &#123;</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;王老二&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Wanger extends Wanglaoer&#123;</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;王二&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Wangxiaoer extends Wanger&#123;</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;王小二&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们使用限定符 extends 来重新设计一下 Arraylist 类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Arraylist&lt;E extends Wanger&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们向 Arraylist 中添加 Wanglaoer 元素的时候，编译器会提示错误： Arraylist 只允许添加 Wanger 及其子类 Wangxiaoer 对象，不允许添加其父类 Wanglaoer 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Arraylist&lt;Wanger&gt; list = new Arraylist&lt;&gt;(3);</span><br><span class="line">list.add(new Wanger());</span><br><span class="line">list.add(new Wanglaoer());</span><br><span class="line">// The method add(Wanger) in the type Arraylist&lt;Wanger&gt; is not applicable for the </span><br><span class="line">arguments </span><br><span class="line">// (Wanglaoer)</span><br><span class="line">list.add(new Wangxiaoer());</span><br></pre></td></tr></table></figure>
<p>也就是说，限定符 extends 可以缩小泛型的类型范围。</p>
<p><strong>类型擦除 </strong></p>
<p>“哦，明白了。”三妹若有所思的点点头，“二哥，听说虚拟机没有泛型？”</p>
<p>“三妹，你功课做得可以啊。哥可以肯定地回答你，虚拟机是没有泛型的。”</p>
<p>“怎么确定虚拟机有没有泛型呢？”三妹问。</p>
<p>“只要我们把泛型类的字节码进行反编译就看到了！”用反编译工具（我写这篇文章的时候用的是 jad，你也可以用其他的工具）将 class 文件反编译后，我说，“三妹，你看。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.</span><br><span class="line">// Jad home page: http://www.kpdus.com/jad.html</span><br><span class="line">// Decompiler options: packimports(3) </span><br><span class="line">// Source File Name:   Arraylist.java</span><br><span class="line">package com.cmower.java_demo.fanxing;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">class Arraylist</span><br><span class="line">&#123;</span><br><span class="line">    public Arraylist(int initialCapacity)</span><br><span class="line">    &#123;</span><br><span class="line">        size = 0;</span><br><span class="line">        elementData = new Object[initialCapacity];</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean add(Object e)</span><br><span class="line">    &#123;</span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    Object elementData(int index)</span><br><span class="line">    &#123;</span><br><span class="line">        return elementData[index];</span><br><span class="line">    &#125;</span><br><span class="line">    private Object elementData[];</span><br><span class="line">    private int size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类型变量 <E> 消失了，取而代之的是 Object ！</p>
<p>“既然如此，那如果泛型类使用了限定符 extends ，结果会怎么样呢？”三妹这个问题问的很巧妙。</p>
<p>来看这段代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Arraylist2&lt;E extends Wanger&gt; &#123;</span><br><span class="line">    private Object[] elementData;</span><br><span class="line">    private int size = 0;</span><br><span class="line">    public Arraylist2(int initialCapacity) &#123;</span><br><span class="line">        this.elementData = new Object[initialCapacity];</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean add(E e) &#123;</span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    E elementData(int index) &#123;</span><br><span class="line">        return (E) elementData[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反编译后的结果如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.</span><br><span class="line">// Jad home page: http://www.kpdus.com/jad.html</span><br><span class="line">// Decompiler options: packimports(3) </span><br><span class="line">// Source File Name:   Arraylist2.java</span><br><span class="line">package com.cmower.java_demo.fanxing;</span><br><span class="line">// Referenced classes of package com.cmower.java_demo.fanxing:</span><br><span class="line">//            Wanger</span><br><span class="line">class Arraylist2</span><br><span class="line">&#123;</span><br><span class="line">    public Arraylist2(int initialCapacity)</span><br><span class="line">    &#123;</span><br><span class="line">        size = 0;</span><br><span class="line">        elementData = new Object[initialCapacity];</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean add(Wanger e)</span><br><span class="line">    &#123;</span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    Wanger elementData(int index)</span><br><span class="line">    &#123;</span><br><span class="line">        return (Wanger)elementData[index];</span><br><span class="line">    &#125;</span><br><span class="line">    private Object elementData[];</span><br><span class="line">    private int size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“你看，类型变量 <E extends Wanger> 不见了，E 被替换成了 Wanger ”，我说，“通过以上两个例子说明，Java 虚拟机会将泛型的类型变量擦除，并替换为限定类型（没有限定的话，就用 Object ）”</p>
<p>“二哥，类型擦除会有什么问题吗？”三妹又问了一个很有水平的问题。</p>
<p>“三妹啊，你还别说，类型擦除真的会有一些问题。”我说，“来看一下这段代码。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Cmower &#123;</span><br><span class="line">    </span><br><span class="line">    public static void method(Arraylist&lt;String&gt; list) &#123;</span><br><span class="line">        System.out.println(&quot;Arraylist&lt;String&gt; list&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void method(Arraylist&lt;Date&gt; list) &#123;</span><br><span class="line">        System.out.println(&quot;Arraylist&lt;Date&gt; list&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在浅层的意识上，我们会想当然地认为 Arraylist<String> list 和 Arraylist<Date> list 是两种不同的类型，因为 String 和 Date 是不同的类。</p>
<p>但由于类型擦除的原因，以上代码是不会通过编译的——编译器会提示一个错误（这正是类型擦除引发的那些“问题”）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;Erasure of method method(Arraylist&lt;String&gt;) is the same as another method in type </span><br><span class="line"> Cmower</span><br><span class="line">&gt;</span><br><span class="line">&gt;Erasure of method method(Arraylist&lt;Date&gt;) is the same as another method in type </span><br><span class="line"> Cmower</span><br></pre></td></tr></table></figure>
<p>大致的意思就是，这两个方法的参数类型在擦除后是相同的。</p>
<p>也就是说， method(Arraylist<String> list) 和 method(Arraylist<Date> list) 是同一种参数类型的方法，不能同时存在。类型变量 String 和 Date 在擦除后会自动消失，method 方法的实际参数是 Arraylist list 。</p>
<p>有句俗话叫做：“百闻不如一见”，但即使见到了也未必为真——泛型的擦除问题就可以很好地佐证这个观点。<br>      <strong>泛型通配符 </strong></p>
<p>“哦，明白了。二哥，听说泛型还有通配符？”</p>
<p>“三妹啊，哥突然觉得你很适合作一枚可爱的程序媛啊！你这预习的功课做得可真到家啊，连通配符都知道！”</p>
<p>通配符使用英文的问号 （?）来表示。在我们创建一个泛型对象时，可以使用关键字 extends 限定子类，也可以使用关键字 super 限定父类。</p>
<p>我们来看下面这段代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个泛型类 Arraylist&lt;E&gt;，E 表示元素类型</span><br><span class="line">class Arraylist&lt;E&gt; &#123;</span><br><span class="line">    // 私有成员变量，存储元素数组和元素数量</span><br><span class="line">    private Object[] elementData;</span><br><span class="line">    private int size = 0;</span><br><span class="line">    // 构造函数，传入初始容量 initialCapacity，创建一个指定容量的 Object 数组</span><br><span class="line">    public Arraylist(int initialCapacity) &#123;</span><br><span class="line">        this.elementData = new Object[initialCapacity];</span><br><span class="line">    &#125;</span><br><span class="line">    // 添加元素到数组末尾，返回添加成功与否</span><br><span class="line">    public boolean add(E e) &#123;</span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取指定下标的元素</span><br><span class="line">    public E get(int index) &#123;</span><br><span class="line">        return (E) elementData[index];</span><br><span class="line">    &#125;</span><br><span class="line">    // 查找指定元素第一次出现的下标，如果找不到则返回 -1</span><br><span class="line">    public int indexOf(Object o) &#123;</span><br><span class="line">        if (o == null) &#123;</span><br><span class="line">            for (int i = 0; i &lt; size; i++)</span><br><span class="line">                if (elementData[i]==null)</span><br><span class="line">                    return i;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (int i = 0; i &lt; size; i++)</span><br><span class="line">                if (o.equals(elementData[i]))</span><br><span class="line">                    return i;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    // 判断指定元素是否在数组中出现</span><br><span class="line">    public boolean contains(Object o) &#123;</span><br><span class="line">        return indexOf(o) &gt;= 0;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 将数组中的元素转化成字符串输出</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        </span><br><span class="line">        for (Object o : elementData) &#123;</span><br><span class="line">            if (o != null) &#123;</span><br><span class="line">                E e = (E)o;</span><br><span class="line">                sb.append(e.toString());</span><br><span class="line">                sb.append(&#x27;,&#x27;).append(&#x27; &#x27;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    // 返回数组中元素的数量</span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br><span class="line">    // 修改指定下标的元素，返回修改前的元素</span><br><span class="line">    public E set(int index, E element) &#123;</span><br><span class="line">        E oldValue = (E) elementData[index];</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1）新增 indexOf(Object o) 方法，判断元素在 Arraylist 中的位置。注意参数为 Object 而不是泛型 E 。</p>
<p>2）新增 contains(Object o) 方法，判断元素是否在 Arraylist 中。注意参数为 Object 而不是泛型 E 。</p>
<p>3）新增 toString() 方法，方便对 Arraylist 进行打印。</p>
<p>4）新增 set(int index, E element) 方法，方便对 Arraylist 元素的更改。</p>
<p>因为泛型擦除的原因， Arraylist<Wanger> list = new Arraylist<Wangxiaoer>(); 这样的语句是无法通过编译的，尽管 Wangxiaoer 是 Wanger 的子类。但如果我们确实需要这种 “向上转型” 的关系，该怎么办呢？这时候就需要通配符来发挥作用了。</p>
<p>利用 &lt;? extends Wanger&gt; 形式的通配符，可以实现泛型的向上转型，来看例子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Arraylist&lt;? extends Wanger&gt; list2 = new Arraylist&lt;&gt;(4);</span><br><span class="line">list2.add(null);</span><br><span class="line">// list2.add(new Wanger());</span><br><span class="line">// list2.add(new Wangxiaoer());</span><br><span class="line">Wanger w2 = list2.get(0);</span><br><span class="line">// Wangxiaoer w3 = list2.get(1);</span><br></pre></td></tr></table></figure>
<p>list2 的类型是 Arraylist&lt;? extends Wanger&gt; ，翻译一下就是，list2 是一个 Arraylist ，其类型是 Wanger 及其子类。</p>
<p>注意，“关键”来了！list2 并不允许通过 add(E e) 方法向其添加 Wanger 或者 Wangxiaoer 的对象，唯一例外的是 null 。</p>
<p>“那就奇了怪了，既然不让存放元素，那要 Arraylist&lt;? extends Wanger&gt; 这样的 list2 有什么用呢？”三妹好奇地问。</p>
<p>虽然不能通过 add(E e) 方法往 list2 中添加元素，但可以给它赋值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Arraylist&lt;Wanger&gt; list = new Arraylist&lt;&gt;(4);</span><br><span class="line">Wanger wanger = new Wanger();</span><br><span class="line">list.add(wanger);</span><br><span class="line">Wangxiaoer wangxiaoer = new Wangxiaoer();</span><br><span class="line">list.add(wangxiaoer);</span><br><span class="line">Arraylist&lt;? extends Wanger&gt; list2 = list;</span><br><span class="line">Wanger w2 = list2.get(1);</span><br><span class="line">System.out.println(w2);</span><br><span class="line">System.out.println(list2.indexOf(wanger));</span><br><span class="line">System.out.println(list2.contains(new Wangxiaoer()));</span><br></pre></td></tr></table></figure>
<p>Arraylist&lt;? extends Wanger&gt; list2 = list; 语句把 list 的值赋予了 list2，此时 list2 == list 。</p>
<p>由于 list2 不允许往其添加其他元素，所以此时它是安全的——我们可以从容地对 list2 进行 get() 、indexOf() 和 contains() 。想一想，如果可以向 list2 添加元素的话，这 3 个方法反而变得不太安全，它们的值可能就会变。</p>
<p>利用 &lt;? super Wanger&gt; 形式的通配符，可以向 Arraylist 中存入父类是 Wanger 的元素，来看例子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Arraylist&lt;? super Wanger&gt; list3 = new Arraylist&lt;&gt;(4);</span><br><span class="line">list3.add(new Wanger());</span><br><span class="line">list3.add(new Wangxiaoer());</span><br><span class="line">// Wanger w3 = list3.get(0);</span><br></pre></td></tr></table></figure>
<p>需要注意的是，无法从 Arraylist&lt;? super Wanger&gt; 这样类型的 list3 中取出数据。</p>
<p><strong>小结 </strong></p>
<p>好了，三妹，关于泛型，我们再来做一个简单的总结。</p>
<p>在 Java 中，泛型是一种强类型约束机制，可以在编译期间检查类型安全性，并且可以提高代码的复用性和可读性。</p>
<p><strong>1）类型参数化 </strong></p>
<p>泛型的本质是参数化类型，也就是说，在定义类、接口或方法时，可以使用一个或多个类型参数来表示参数化类型。</p>
<p>例如这样可以定义一个泛型类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Box&lt;T&gt; &#123;</span><br><span class="line">    private T value;</span><br><span class="line">    public Box(T value) &#123;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    public T getValue() &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setValue(T value) &#123;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中， <T> 表示类型参数，可以在类中任何需要使用类型的地方使用 T 代替具体的类型。通过使用泛型，我们可以创建一个可以存储任何类型对象的盒子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Box&lt;Integer&gt; intBox = new Box&lt;&gt;(123);</span><br><span class="line">Box&lt;String&gt; strBox = new Box&lt;&gt;(&quot;Hello, world!&quot;);</span><br></pre></td></tr></table></figure>
<p>泛型在实际开发中的应用非常广泛，例如集合框架中的 List、Set、Map 等容器类，以及并发框架中的 Future、Callable 等工具类都使用了泛型。</p>
<p><strong>2）类型擦除 </strong></p>
<p>在 Java 的泛型机制中，有两个重要的概念：类型擦除和通配符。</p>
<p>泛型在编译时会将泛型类型擦除，将泛型类型替换成 Object 类型。这是为了向后兼容，避免对原有的 Java 代码造成影响。</p>
<p>例如，对于下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; intList = new ArrayList&lt;&gt;();</span><br><span class="line">intList.add(123);</span><br><span class="line">int value = intList.get(0);</span><br></pre></td></tr></table></figure>
<p>在编译时，Java 编译器会将泛型类型 List<Integer> 替换成 List<Object> ，将 get 方法的返回值类型 Integer 替换成 Object，生成的字节码与下面的代码等价：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List intList = new ArrayList();</span><br><span class="line">intList.add(Integer.valueOf(123));</span><br><span class="line">int value = (Integer) intList.get(0);</span><br></pre></td></tr></table></figure>
<p>Java 泛型只在编译时起作用，运行时并不会保留泛型类型信息。</p>
<p><strong>3）通配符 </strong></p>
<p>通配符用于表示某种未知的类型，例如 List&lt;?&gt; 表示一个可以存储任何类型对象的 List，但是不能对其中的元素进行添加操作。通配符可以用来解决类型不确定的情况，例如在方法参数或返回值中使用。</p>
<p>使用通配符可以使方法更加通用，同时保证类型安全。</p>
<p>例如，定义一个泛型方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void printList(List&lt;?&gt; list) &#123;</span><br><span class="line">    for (Object obj : list) &#123;</span><br><span class="line">        System.out.print(obj + &quot; &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法可以接受任意类型的 List，例如 List<Integer> 、 List<String> 等等。</p>
<p><strong>上限通配符 </strong></p>
<p>泛型还提供了上限通配符 &lt;? extends T&gt; ，表示通配符只能接受 T 或 T 的子类。使用上限通配符可以提高程序的类型安全性。</p>
<p>例如，定义一个方法，只接受 Number 及其子类的 List：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void printNumberList(List&lt;? extends Number&gt; list) &#123;</span><br><span class="line">    for (Number num : list) &#123;</span><br><span class="line">        System.out.print(num + &quot; &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法可以接受 List<Integer> 、 List<Double> 等等。</p>
<p><strong>下限通配符 </strong></p>
<p>下限通配符（Lower Bounded Wildcards）用 super 关键字来声明，其语法形式为 &lt;? super T&gt; ，其中 T 表示类型参数。它表示的是该类型参数必须是某个指定类的超类（包括该类本身）。</p>
<p>当我们需要往一个泛型集合中添加元素时，如果使用的是上限通配符，集合中的元素类型可能会被限制，从而无法添加某些类型的元素。但是，如果我们使用下限通配符，可以将指定类型的子类型添加到集合中，保证了元素的完整性。</p>
<p>举个例子，假设有一个类 Animal，以及两个子类 Dog 和 Cat。现在我们有一个 List&lt;? super Dog&gt; 集合，它的类型参数必须是 Dog 或其父类类型。我们可以向该集合中添加 Dog 类型的元素，也可以添加它的子类。但是，不能向其中添加 Cat 类型的元素，因为 Cat 不是 Dog 的子类。</p>
<p>下面是一个使用下限通配符的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? super Dog&gt; animals = new ArrayList&lt;&gt;();</span><br><span class="line">// 可以添加 Dog 类型的元素和其子类型元素</span><br><span class="line">animals.add(new Dog());</span><br><span class="line">animals.add(new Bulldog());</span><br><span class="line">// 不能添加 Cat 类型的元素</span><br><span class="line">animals.add(new Cat()); // 编译报错</span><br></pre></td></tr></table></figure>
<p>需要注意的是，虽然使用下限通配符可以添加某些子类型元素，但是在读取元素时，我们只能确保其是 Object 类型的，无法确保其是指定类型或其父类型。因此，在读取元素时需要进行类型转换，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? super Dog&gt; animals = new ArrayList&lt;&gt;();</span><br><span class="line">animals.add(new Dog());</span><br><span class="line">// 读取元素时需要进行类型转换</span><br><span class="line">Object animal = animals.get(0);</span><br><span class="line">Dog dog = (Dog) animal;</span><br></pre></td></tr></table></figure>
<p>总的来说，Java 的泛型机制是一种非常强大的类型约束机制，可以在编译时检查类型安全性，并提高代码的复用性和可读性。但是，在使用泛型时也需要注意类型擦除和通配符等问题，以确保代码的正确性。</p>
<h2 id="4-7-Iterator和Iterable的区别"><a href="#4-7-Iterator和Iterable的区别" class="headerlink" title="4.7 Iterator和Iterable的区别"></a>4.7 Iterator和Iterable的区别</h2><p>PS: 这篇同样来换一个风格，一起来欣赏。</p>
<p>那天，小二去海康威视面试，面试官老王一上来就甩给了他一道面试题：请问 Iterator与Iterable有什么区别？</p>
<p>小二表示很开心，因为他3 天前刚好在《二哥的Java进阶之路》上读过这篇文章，所以回答得胸有成竹。</p>
<p>以下是小二当时读过的文章内容，他印象深刻。</p>
<p>在 Java 中，我们对 List 进行遍历的时候，主要有这么三种方式。</p>
<p>第一种：for 循环。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">    System.out.print(list.get(i) + &quot;，&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种：迭代器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Iterator it = list.iterator();</span><br><span class="line">while (it.hasNext()) &#123;</span><br><span class="line">    System.out.print(it.next() + &quot;，&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三种：for-each。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (String str : list) &#123;</span><br><span class="line">    System.out.print(str + &quot;，&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一种我们略过，第二种用的是 Iterator，第三种看起来是 for-each，其实背后也是 Iterator，看一下反编译后的代码（如下所示）就明白了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator var3 = list.iterator();</span><br><span class="line">while(var3.hasNext()) &#123;</span><br><span class="line">    String str = (String)var3.next();</span><br><span class="line">    System.out.print(str + &quot;，&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>for-each 只不过是个语法糖，让我们开发者在遍历 List 的时候可以写更少的代码，更简洁明了。</p>
<p>Iterator 是个接口，JDK 1.2 的时候就有了，用来改进 Enumeration 接口：</p>
<ul>
<li>允许删除元素（增加了 remove 方法）</li>
<li>优化了方法名（Enumeration 中是 hasMoreElements 和 nextElement，不简洁）</li>
</ul>
<p>来看一下 Iterator 的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public interface Iterator&lt;E&gt; &#123;</span><br><span class="line">    // 判断集合中是否存在下一个对象</span><br><span class="line">    boolean hasNext();</span><br><span class="line">    // 返回集合中的下一个对象，并将访问指针移动一位</span><br><span class="line">    E next();</span><br><span class="line">    // 删除集合中调用next()方法返回的对象</span><br><span class="line">    default void remove() &#123;</span><br><span class="line">        throw new UnsupportedOperationException(&quot;remove&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JDK 1.8 时，Iterable 接口中新增了 forEach 方法。该方法接受一个 Consumer 对象作为参数，用于对集合中的每个元素执行指定的操作。该方法的实现方式是使用 for-each 循环遍历集合中的元素，对于每个元素，调用 Consumer 对象的 accept 方法执行指定的操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">default void forEach(Consumer&lt;? super T&gt; action) &#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    for (T t : this) &#123;</span><br><span class="line">        action.accept(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法实现时首先会对 action 参数进行非空检查，如果为 null 则抛出 NullPointerException 异常。然后使用 for-each 循环遍历集合中的元素，并对每个元素调用 action.accept(t) 方法执行指定的操作。由于 Iterable 接口是 Java 集合框架中所有集合类型的基本接口，因此该方法可以被所有实现了 Iterable 接口的集合类型使用。</p>
<p>它对 Iterable 的每个元素执行给定操作，具体指定的操作需要自己写Consumer接口通过accept方法回调出来。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = new ArrayList&lt;&gt;(Arrays.asList(1, 2, 3));</span><br><span class="line">list.forEach(integer -&gt; System.out.println(integer));</span><br></pre></td></tr></table></figure>
<p>写得更浅显易懂点，就是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = new ArrayList&lt;&gt;(Arrays.asList(1, 2, 3));</span><br><span class="line">list.forEach(new Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void accept(Integer integer) &#123;</span><br><span class="line">        System.out.println(integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果我们仔细观察ArrayList 或者 LinkedList 的“户口本”就会发现，并没有直接找到 Iterator 的影子。</p>
<p><img src="\assets\note\image-20231010114038331.png" alt="image-20231010114038331"></p>
<p>反而找到了 Iterable！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Iterable&lt;T&gt; &#123;</span><br><span class="line">    Iterator&lt;T&gt; iterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，List 的关系图谱中并没有直接使用 Iterator，而是使用 Iterable 做了过渡。</p>
<p>回头再来看一下第二种遍历 List 的方式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Iterator it = list.iterator();</span><br><span class="line">while (it.hasNext()) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现刚好呼应上了。拿 ArrayList 来说吧，它重写了 Iterable 接口的 iterator 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">    return new Itr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回的对象 Itr 是个内部类，实现了 Iterator 接口，并且按照自己的方式重写了 hasNext、next、remove 等方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * ArrayList 迭代器的实现，内部类。</span><br><span class="line"> */</span><br><span class="line">private class Itr implements Iterator&lt;E&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 游标位置，即下一个元素的索引。</span><br><span class="line">     */</span><br><span class="line">    int cursor;</span><br><span class="line">    /**</span><br><span class="line">     * 上一个元素的索引。</span><br><span class="line">     */</span><br><span class="line">    int lastRet = -1;</span><br><span class="line">    /**</span><br><span class="line">     * 预期的结构性修改次数。</span><br><span class="line">     */</span><br><span class="line">    int expectedModCount = modCount;</span><br><span class="line">    /**</span><br><span class="line">     * 判断是否还有下一个元素。</span><br><span class="line">     *</span><br><span class="line">     * @return 如果还有下一个元素，则返回 true，否则返回 false。</span><br><span class="line">     */</span><br><span class="line">    public boolean hasNext() &#123;</span><br><span class="line">        return cursor != size;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 获取下一个元素。</span><br><span class="line">     *</span><br><span class="line">     * @return 列表中的下一个元素。</span><br><span class="line">     * @throws NoSuchElementException 如果没有下一个元素，则抛出 NoSuchElementException 异常。</span><br><span class="line">     */</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public E next() &#123;</span><br><span class="line">        // 获取 ArrayList 对象的内部数组</span><br><span class="line">        Object[] elementData = ArrayList.this.elementData;</span><br><span class="line">        // 记录当前迭代器的位置</span><br><span class="line">        int i = cursor;</span><br><span class="line">        if (i &gt;= size) &#123;</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">        &#125;</span><br><span class="line">        // 将游标位置加 1，为下一次迭代做准备</span><br><span class="line">        cursor = i + 1;</span><br><span class="line">        // 记录上一个元素的索引</span><br><span class="line">        return (E) elementData[lastRet = i];</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 删除最后一个返回的元素。</span><br><span class="line">     * 迭代器只能删除最后一次调用 next 方法返回的元素。</span><br><span class="line">     *</span><br><span class="line">     * @throws ConcurrentModificationException 如果在最后一次调用 next 方法之后列表结构被修改，则抛出 ConcurrentModificationException 异常。</span><br><span class="line">     * @throws IllegalStateException         如果在调用 next 方法之前没有调用 remove 方法，或者在同一次迭代中多次调用 remove 方法，则抛出 IllegalStateException 异常。</span><br><span class="line">     */</span><br><span class="line">    public void remove() &#123;</span><br><span class="line">        // 检查在最后一次调用 next 方法之后是否进行了结构性修改</span><br><span class="line">        if (expectedModCount != modCount) &#123;</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果上一次调用 next 方法之前没有调用 remove 方法，则抛出 IllegalStateException 异常</span><br><span class="line">        if (lastRet &lt; 0) &#123;</span><br><span class="line">            throw new IllegalStateException();</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 调用 ArrayList 对象的 remove(int index) 方法删除上一个元素</span><br><span class="line">            ArrayList.this.remove(lastRet);</span><br><span class="line">            // 将游标位置设置为上一个元素的位置</span><br><span class="line">            cursor = lastRet;</span><br><span class="line">            // 将上一个元素的索引设置为 -1，表示没有上一个元素</span><br><span class="line">            lastRet = -1;</span><br><span class="line">            // 更新预期的结构性修改次数</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125; catch (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 那可能有些小伙伴会问：为什么不直接将 Iterator 中的核心方法 hasNext、next 放到 Iterable 接口中呢？</p>
<p> 直接像下面这样使用不是更方便？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Iterable it = list.iterator();</span><br><span class="line">while (it.hasNext()) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 从英文单词的后缀语法上来看，（Iterable）able 表示这个 List 是支持迭代的，而 （Iterator）tor 表示这个 List 是如何迭代的。</p>
<p> 支持迭代与具体怎么迭代显然不能混在一起，否则就乱的一笔。还是各司其职的好。</p>
<p> 想一下，如果把 Iterator 和 Iterable 合并，for-each 这种遍历 List 的方式是不是就不好办了？</p>
<p> 原则上，只要一个 List 实现了 Iterable 接口，那么它就可以使用 for-each 这种方式来遍历，那具体该怎么遍历，还是要看它自己是怎么实现 Iterator 接口的。</p>
<p> Map 就没办法直接使用 for-each，因为 Map 没有实现 Iterable 接口，只有通过 map.entrySet() 、map.keySet() 、 map.values() 这种返回一个  Collection 的方式才能 使用 for-each。</p>
<p> 如果我们仔细研究 LinkedList 的源码就会发现，LinkedList 并没有直接重写 Iterable 接口的 iterator 方法，而是由它的父类 AbstractSequentialList 来完成。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">    return listIterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> LinkedList 重写了 listIterator 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public ListIterator&lt;E&gt; listIterator(int index) &#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line">    return new ListItr(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 这里我们发现了一个新的迭代器 ListIterator，它继承了 Iterator 接口，在遍历List 时可以从任意下标开始遍历，而且支持双向遍历。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface ListIterator&lt;E&gt; extends Iterator&lt;E&gt; &#123;</span><br><span class="line">    boolean hasNext();</span><br><span class="line">    E next();</span><br><span class="line">    boolean hasPrevious();</span><br><span class="line">    E previous();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 我们知道，集合（Collection）不仅有 List，还有 Set，那 Iterator 不仅支持 List，还支持 Set，但 ListIterator 就只支持 List。</p>
<p> 那可能有些小伙伴会问：为什么不直接让 List 实现 Iterator 接口，而是要用内部类来实现呢？</p>
<p> 这是因为有些 List 可能会有多种遍历方式，比如说 LinkedList，除了支持正序的遍历方式，还支持逆序的遍历方式——DescendingIterator：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line"> * ArrayList 逆向迭代器的实现，内部类。</span><br><span class="line"> */</span><br><span class="line">private class DescendingIterator implements Iterator&lt;E&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 使用 ListItr 对象进行逆向遍历。</span><br><span class="line">     */</span><br><span class="line">    private final ListItr itr = new ListItr(size());</span><br><span class="line">    /**</span><br><span class="line">     * 判断是否还有下一个元素。</span><br><span class="line">     *</span><br><span class="line">     * @return 如果还有下一个元素，则返回 true，否则返回 false。</span><br><span class="line">     */</span><br><span class="line">    public boolean hasNext() &#123;</span><br><span class="line">        return itr.hasPrevious();</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 获取下一个元素。</span><br><span class="line">     *</span><br><span class="line">     * @return 列表中的下一个元素。</span><br><span class="line">     * @throws NoSuchElementException 如果没有下一个元素，则抛出 NoSuchElementException 异常。</span><br><span class="line">     */</span><br><span class="line">    public E next() &#123;</span><br><span class="line">        return itr.previous();</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 删除最后一个返回的元素。</span><br><span class="line">     * 迭代器只能删除最后一次调用 next 方法返回的元素。</span><br><span class="line">     *</span><br><span class="line">     * @throws UnsupportedOperationException 如果列表不支持删除操作，则抛出 UnsupportedOperationException 异常。</span><br><span class="line">     * @throws IllegalStateException         如果在调用 next 方法之前没有调用 remove 方法，或者在同一次迭代中多次调用 remove 方法，则抛出 IllegalStateException 异常。</span><br><span class="line">     */</span><br><span class="line">    public void remove() &#123;</span><br><span class="line">        itr.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  可以看得到，DescendingIterator 刚好利用了 ListIterator 向前遍历的方式。可以通过以下的方式来使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Iterator it = list.descendingIterator();</span><br><span class="line">while (it.hasNext()) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  好了，关于Iterator与Iterable我们就先聊这么多，总结两点：</p>
<ul>
<li>学会深入思考，一点点抽丝剥茧，多想想为什么这样实现，很多问题没有自己想象中的那么复杂。</li>
<li>遇到疑惑不放弃，这是提升自己最好的机会，遇到某个疑难的点，解决的过程中会挖掘出很多相关的东西。</li>
</ul>
<h2 id="4-8-Java-foreach-循环陷阱"><a href="#4-8-Java-foreach-循环陷阱" class="headerlink" title="4.8 Java foreach 循环陷阱"></a>4.8 Java foreach 循环陷阱</h2><p> 这篇文章同样采用小二去面试的形式，给大家换个胃口。</p>
<p> 那天，小二去阿里面试，面试官老王一上来就甩给了他一道面试题：为什么阿里的 Java 开发手册里会强制不要在 foreach 里进行元素的删除操作？</p>
<p><img src="\assets\note\image-20231010114955252.png" alt="image-20231010114955252"></p>
<p> 小二听完这句话就乐了。为什么呢？因为一天前他刚在《Java进阶之路》上看到过这道题的答案。</p>
<p> 以下是整篇文章的内容。</p>
<p> 关于fail-fast </p>
<p> 为了镇楼，先搬一段英文来解释一下 fail-fast。</p>
<blockquote>
<p>In systems design, a fail-fast system is one which immediately reports at its interface any condition that is likely to indicate a failure. Fail-fast systems are usually designed to stop normal operation rather than attempt to continue a possibly flawed process. Such designs often check the system’s state at several points in an operation, so any failures can be detected early. The responsibility of a fail-fast module is detecting errors, then letting the next-highest level of the system handle them.</p>
</blockquote>
<p> 这段话的大致意思就是，fail-fast 是一种通用的系统设计思想，一旦检测到可能会发生错误，就立马抛出异常，程序将不再往下执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void test(Wanger wanger) &#123;   </span><br><span class="line">    if (wanger == null) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;wanger 不能为空&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    System.out.println(wanger.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 一旦检测到 wanger 为 null，就立马抛出异常，让调用者来决定这种情况下该怎么处理，下一步 wanger.toString() 就不会执行了——避免更严重的错误出现。</p>
<p> 很多时候，我们会把 fail-fast 归类为 Java 集合框架的一种错误检测机制，但其实 fail-fast 并不是 Java 集合框架特有的机制。</p>
<p> <strong>for-each 删除元素报错 </strong></p>
<p> 之所以我们把 fail-fast 放在集合框架篇里介绍，是因为问题比较容易再现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list.add(&quot;沉默王二&quot;);</span><br><span class="line">list.add(&quot;沉默王三&quot;);</span><br><span class="line">list.add(&quot;一个文章真特么有趣的程序员&quot;);</span><br><span class="line">for (String str : list) &#123;</span><br><span class="line">    if (&quot;沉默王二&quot;.equals(str)) &#123;</span><br><span class="line">        list.remove(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>
<p> 这段代码看起来没有任何问题，但运行起来就报错了。</p>
<p><img src="\assets\note\image-20231010115215172.png" alt="image-20231010115215172"></p>
<p> 根据错误的堆栈信息，我们可以定位到 ArrayList 的第 901 行代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">final void checkForComodification() &#123;</span><br><span class="line">    if (modCount != expectedModCount)</span><br><span class="line">        throw new ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 也就是说，remove 的时候触发执行了 checkForComodification 方法，该方法对 modCount 和 expectedModCount 进行了比较，发现两者不等，就抛出了 ConcurrentModificationException 异常。</p>
<p> 为什么会执行 checkForComodification 方法呢？</p>
<p> 是因为 for-each 本质上是个语法糖，底层是通过迭代器 Iterator 配合 while 循环实现的，来看一下反编译后的字节码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList();</span><br><span class="line">list.add(&quot;沉默王二&quot;);</span><br><span class="line">list.add(&quot;沉默王三&quot;);</span><br><span class="line">list.add(&quot;一个文章真特么有趣的程序员&quot;);</span><br><span class="line">Iterator var2 = list.iterator();</span><br><span class="line">while(var2.hasNext()) &#123;</span><br><span class="line">    String str = (String)var2.next();</span><br><span class="line">    if (&quot;沉默王二&quot;.equals(str)) &#123;</span><br><span class="line">        list.remove(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>
<p> 来看一下 ArrayList 的 iterator 方法吧：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">    return new Itr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 内部类 Itr 实现了 Iterator 接口，这是 Itr 的源码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> private class Itr implements Iterator&lt;E&gt; &#123;</span><br><span class="line">    int cursor;             // 下一个元素的索引</span><br><span class="line">    int lastRet = -1;       // 上一个返回元素的索引；如果没有则为 -1</span><br><span class="line">    int expectedModCount = modCount; // ArrayList 的修改次数</span><br><span class="line">    Itr() &#123; &#125;  // 构造函数</span><br><span class="line"></span><br><span class="line">    public boolean hasNext() &#123; // 判断是否还有下一个元素</span><br><span class="line">        return cursor != size;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public E next() &#123; // 返回下一个元素</span><br><span class="line">        checkForComodification(); // 检查 ArrayList 是否被修改过</span><br><span class="line">        int i = cursor; // 当前索引</span><br><span class="line">        Object[] elementData = ArrayList.this.elementData; // ArrayList 中的元素数组</span><br><span class="line">        if (i &gt;= elementData.length) // 超出数组范围</span><br><span class="line">            throw new ConcurrentModificationException(); // 抛出异常</span><br><span class="line">        cursor = i + 1; // 更新下一个元素的索引</span><br><span class="line">        return (E) elementData[lastRet = i]; // 返回下一个元素</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 也就是说 new Itr() 的时候 expectedModCount 被赋值为 modCount，而 modCount 是 ArrayList 中的一个计数器，用于记录 ArrayList 对象被修改的次数。ArrayList 的修改操作包括添加、删除、设置元素值等。每次对 ArrayList 进行修改操作时，modCount 的值会自增 1。</p>
<p> 在迭代 ArrayList 时，如果迭代过程中发现 modCount 的值与迭代器的 expectedModCount 不一致，则说明 ArrayList 已被修改过，此时会抛出 ConcurrentModificationException 异常。这种机制可以保证迭代器在遍历 ArrayList 时，不会遗漏或重复元素，同时也可以在多线程环境下检测到并发修改问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected transient int modCount = 0;</span><br></pre></td></tr></table></figure>
<p> <strong>分析代码执行的逻辑 </strong></p>
<p> 我们来继续定位之前报错的错误堆栈。这是之前的代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list.add(&quot;沉默王二&quot;);</span><br><span class="line">list.add(&quot;沉默王三&quot;);</span><br><span class="line">list.add(&quot;一个文章真特么有趣的程序员&quot;);</span><br><span class="line">for (String str : list) &#123;</span><br><span class="line">    if (&quot;沉默王二&quot;.equals(str)) &#123;</span><br><span class="line">        list.remove(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>
<p> 由于 list 此前执行了 3 次 add 方法。</p>
<ul>
<li>add 方法调用 ensureCapacityInternal 方法</li>
<li>ensureCapacityInternal 方法调用 ensureExplicitCapacity 方法</li>
<li>ensureExplicitCapacity 方法中会执行 modCount++</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 所以 modCount 的值在经过三次 add 后为 3，于是 new Itr() 后 expectedModCount 的值也为 3（回到前面去看一下 Itr 的源码）。</p>
<p> 接着来执行 for-each 的循环遍历。</p>
<p> 执行第一次循环时，发现“沉默王二”等于 str，于是执行 list.remove(str) 。</p>
<ul>
<li>remove 方法调用 fastRemove 方法</li>
<li>fastRemove 方法中会执行 modCount++</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private void fastRemove(int index) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> modCount 的值变成了 4。</p>
<p> 第二次遍历时，会执行 Itr 的 next 方法（ String str = (String) var3.next(); ），next 方法就会调用 checkForComodification 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">final void checkForComodification() &#123;</span><br><span class="line">    if (modCount != expectedModCount)</span><br><span class="line">        throw new ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 此时 expectedModCount 为 3，modCount 为 4，就只好抛出 ConcurrentModificationException 异常了。</p>
<p> 那其实在阿里巴巴的 Java 开发手册里也提到了，不要在 for-each 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterator 方式。</p>
<p><img src="\assets\note\image-20231010115730076.png" alt="image-20231010115730076"></p>
<p> 那原因其实就是我们上面分析的这些，出于 fail-fast 保护机制。</p>
<p><strong>那该如何正确地删除元素呢？ </strong></p>
<p><strong>1）remove 后 break </strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list.add(&quot;沉默王二&quot;);</span><br><span class="line">list.add(&quot;沉默王三&quot;);</span><br><span class="line">list.add(&quot;一个文章真特么有趣的程序员&quot;);</span><br><span class="line">for (String str : list) &#123;</span><br><span class="line">    if (&quot;沉默王二&quot;.equals(str)) &#123;</span><br><span class="line">        list.remove(str);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> break 后循环就不再遍历了，意味着 Iterator 的 next 方法不再执行了，也就意味着 checkForComodification 方法不再执行了，所以异常也就不会抛出了。</p>
<p> 但是呢，当 List 中有重复元素要删除的时候，break 就不合适了。</p>
<p><strong>2）for 循环 </strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list.add(&quot;沉默王二&quot;);</span><br><span class="line">list.add(&quot;沉默王三&quot;);</span><br><span class="line">list.add(&quot;一个文章真特么有趣的程序员&quot;);</span><br><span class="line">for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">    String str = list.get(i);</span><br><span class="line">    if (&quot;沉默王二&quot;.equals(str)) &#123;</span><br><span class="line">        list.remove(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> for 循环虽然可以避开 fail-fast 保护机制，也就说 remove 元素后不再抛出异常；但是呢，这段程序在原则上是有问题的。为什么呢？</p>
<p> 第一次循环的时候，i 为 0， list.size() 为 3，当执行完 remove 方法后，i 为 1， list.size() 却变成了 2，因为 list 的大小在 remove 后发生了变化，也就意味着“沉默王三”这个元素被跳过了。能明白吗？</p>
<p> remove 之前 list.get(1) 为“沉默王三”；但 remove 之后 list.get(1) 变成了“一个文章真特么有趣的程序员”，而 list.get(0) 变成了“沉默王三”。</p>
<p><strong>3）使用 Iterator </strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list.add(&quot;沉默王二&quot;);</span><br><span class="line">list.add(&quot;沉默王三&quot;);</span><br><span class="line">list.add(&quot;一个文章真特么有趣的程序员&quot;);</span><br><span class="line">Iterator&lt;String&gt; itr = list.iterator();</span><br><span class="line">while (itr.hasNext()) &#123;</span><br><span class="line">    String str = itr.next();</span><br><span class="line">    if (&quot;沉默王二&quot;.equals(str)) &#123;</span><br><span class="line">        itr.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 为什么使用 Iterator 的 remove 方法就可以避开 fail-fast 保护机制呢？看一下 remove 的源码就明白了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void remove() &#123;</span><br><span class="line">    if (lastRet &lt; 0) // 如果没有上一个返回元素的索引，则抛出异常</span><br><span class="line">        throw new IllegalStateException();</span><br><span class="line">    checkForComodification(); // 检查 ArrayList 是否被修改过</span><br><span class="line">    try &#123;</span><br><span class="line">        ArrayList.this.remove(lastRet); // 删除上一个返回元素</span><br><span class="line">        cursor = lastRet; // 更新下一个元素的索引</span><br><span class="line">        lastRet = -1; // 清空上一个返回元素的索引</span><br><span class="line">        expectedModCount = modCount; // 更新 ArrayList 的修改次数</span><br><span class="line">    &#125; catch (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">        throw new ConcurrentModificationException(); // 抛出异常</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 删除完会执行 expectedModCount = modCount ，保证了 expectedModCount 与 modCount 的同步。</p>
<p><strong>小结 </strong></p>
<p> 为什么不能在foreach里执行删除操作？</p>
<p> 因为 foreach 循环是基于迭代器实现的，而迭代器在遍历集合时会维护一个 expectedModCount 属性来记录集合被修改的次数。如果在 foreach 循环中执行删除操作会导致 expectedModCount 属性值与实际的 modCount 属性值不一致，从而导致迭代器的 hasNext() 和 next() 方法抛出 ConcurrentModificationException 异常。</p>
<p> 为了避免这种情况，应该使用迭代器的 remove() 方法来删除元素，该方法会在删除元素后更新迭代器状态，确保循环的正确性。如果需要在循环中删除元素，应该使用迭代器的 remove() 方法，而不是集合自身的 remove() 方法。</p>
<p> 就像这样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list.add(&quot;沉默王二&quot;);</span><br><span class="line">list.add(&quot;沉默王三&quot;);</span><br><span class="line">list.add(&quot;一个文章真特么有趣的程序员&quot;);</span><br><span class="line">Iterator&lt;String&gt; itr = list.iterator();</span><br><span class="line">while (itr.hasNext()) &#123;</span><br><span class="line">    String str = itr.next();</span><br><span class="line">    if (&quot;沉默王二&quot;.equals(str)) &#123;</span><br><span class="line">        itr.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 除此之外，我们还可以采用 Stream 流的filter() 方法来过滤集合中的元素，然后再通过 collect() 方法将过滤后的元素收集到一个新的集合中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;沉默&quot;, &quot;王二&quot;, &quot;陈清扬&quot;));</span><br><span class="line">list = list.stream().filter(s -&gt; !s.equals(&quot;陈清扬&quot;)).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<p> 好了，关于这个问题，就聊到这里吧，希望能帮助到你。</p>
<h2 id="4-9-HashMap详解（附源码）"><a href="#4-9-HashMap详解（附源码）" class="headerlink" title="4.9 HashMap详解（附源码）"></a>4.9 HashMap详解（附源码）</h2><p> 这篇文章将通过源码的方式，详细透彻地讲清楚 Java 的 HashMap，包括 hash 方法的原理、HashMap 的扩容机制、HashMap的加载因子为什么是 0.75 而不是 0.6、0.8，以及 HashMap 为什么是线程不安全的，基本上 HashMap 的常见面试题，都会在这一篇文章里讲明白。</p>
<p> HashMap 是 Java 中常用的数据结构之一，用于存储键值对。在 HashMap 中，每个键都映射到一个唯一的值，可以通过键来快速访问对应的值。</p>
<p> HashMap 不仅在日常开发中经常用到，在面试中也是重点考察的对象。</p>
<p> 以下是 HashMap 增删改查的简单例子：</p>
<p><strong>1）增加元素：</strong></p>
<p> 将一个键值对（元素）添加到 HashMap 中，可以使用 put() 方法。例如，将名字和年龄作为键值对添加到 HashMap 中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">map.put(&quot;沉默&quot;, 20);</span><br><span class="line">map.put(&quot;王二&quot;, 25);</span><br></pre></td></tr></table></figure>
<p><strong>2）删除元素：</strong></p>
<p> 从 HashMap 中删除一个键值对，可以使用 remove() 方法。例如，删除名字为 “沉默” 的键值对：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.remove(&quot;沉默&quot;);</span><br></pre></td></tr></table></figure>
<p> <strong>3）修改元素：</strong></p>
<p> 修改 HashMap 中的一个键值对，可以使用 put() 方法。例如，将名字为 “沉默” 的年龄修改为 30：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.put(&quot;沉默&quot;, 30);</span><br></pre></td></tr></table></figure>
<p> 为什么和添加元素的方法一样呢？这个我们后面会讲，先简单说一下，是因为 HashMap 的键是唯一的，所以再次 put 的时候会覆盖掉之前的键值对。</p>
<p><strong>4）查找元素：</strong></p>
<p> 从 HashMap 中查找一个键对应的值，可以使用 get() 方法。例如，查找名字为 “沉默” 的年龄：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int age = map.get(&quot;沉默&quot;);</span><br></pre></td></tr></table></figure>
<p> 在实际应用中，HashMap 可以用于缓存、索引等场景。例如，可以将用户 ID 作为键，用户信息作为值，将用户信息缓存到 HashMap 中，以便快速查找。又如，可以将关键字作为键，文档 ID 列表作为值，将文档索引缓存到 HashMap 中，以便快速搜索文档。</p>
<p> HashMap 的实现原理是基于哈希表的，它的底层是一个数组，数组的每个位置可能是一个链表或红黑树，也可能只是一个键值对（后面会讲）。当添加一个键值对时，HashMap 会根据键的哈希值计算出该键对应的数组下标（索引），然后将键值对插入到对应的位置。</p>
<p>当通过键查找值时，HashMap 也会根据键的哈希值计算出数组下标，并查找对应的值。</p>
<p><strong>01、hash方法的原理 </strong></p>
<p> 简单了解 HashMap 后，我们来讨论第一个问题：hash 方法的原理，对吃透 HashMap 会大有帮助。</p>
<p> 来看一下 hash 方法的源码（JDK 8 中的 HashMap）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 这段代码究竟是用来干嘛的呢？</p>
<p> 将 key 的 hashCode 值进行处理，得到最终的哈希值。</p>
<p> 怎么理解这句话呢？不要着急。</p>
<p> 我们来 new 一个 HashMap，并通过 put 方法添加一个元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">map.put(&quot;chenmo&quot;, &quot;沉默&quot;);</span><br></pre></td></tr></table></figure>
<p> 来看一下 put 方法的源码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 看到 hash 方法的身影了吧？</p>
<p><strong>hash 方法的作用 </strong></p>
<p> 前面也说了，HashMap 的底层是通过数组的形式实现的，初始大小是 16（这个后面会讲），先记住。</p>
<p> 也就是说，HashMap 在添加第一个元素的时候，需要通过键的哈希码在大小为 16 的数组中确定一个位置（索引），怎么确定呢？</p>
<p> 为了方便大家直观的感受，我这里画了一副图，16 个方格子（可以把它想象成一个一个桶），每个格子都有一个编号，对应大小为 16 的数组下标（索引）。</p>
<p><img src="\assets\note\image-20231010142503420.png" alt="image-20231010142503420"></p>
<p> 现在，我们要把 key 为 “chenmo”，value 为“沉默”的键值对放到这 16 个格子中的一个。</p>
<p> 怎么确定位置（索引）呢？</p>
<p> 我先告诉大家结论，通过这个与运算 (n - 1) &amp; hash ，其中变量 n 为数组的长度，变量 hash 就是通过 hash() 方法计算后的结果。</p>
<p> 那“chenmo”这个 key 计算后的位置（索引）是多少呢？</p>
<p> 答案是 8，也就是说 map.put(“chenmo”, “沉默”) 会把key 为 “chenmo”，value 为“沉默”的键值对放到下标为 8 的位置上（也就是索引为 8 的桶上）。</p>
<p><img src="\assets\note\image-20231010142547756.png" alt="image-20231010142547756"></p>
<p> 这样大家就会对 HashMap 存放键值对（元素）的时候有一个大致的印象。其中的一点是，hash 方法对计算键值对的位置起到了至关重要的作用。</p>
<p> 回到 hash 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 下面是对该方法的一些解释：</p>
<ul>
<li>参数 key：需要计算哈希码的键值。</li>
<li>key == null ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16) ：这是一个三目运算符，如果键值为null，则哈希码为0（依旧是说如果键为 null，则存放在第一个位置）；否则，通过调用 hashCode()方法获取键的哈希码，并将其与右移16位的哈希码进行异或运算。</li>
<li>^ 运算符：异或运算符是Java中的一种位运算符，它用于将两个数的二进制位进行比较，如果相同则为0，不同则为1。</li>
<li>h &gt;&gt;&gt; 16 ：将哈希码向右移动16位，相当于将原来的哈希码分成了两个16位的部分。</li>
<li><p>最终返回的是经过异或运算后得到的哈希码值。</p>
<p>这短短的一行代码，汇聚不少计算机巨佬们的聪明才智。</p>
<p>理论上，哈希值（哈希码）是一个 int 类型，范围从-2147483648 到 2147483648。前后加起来大概 40 亿的映射空间，只要哈希值映射得比较均匀松散，一般是不会出现哈希碰撞（哈希冲突会降低 HashMap 的效率）。</p>
<p>但问题是一个 40 亿长度的数组，内存是放不下的。HashMap 扩容之前的数组初始大小只有 16，所以这个哈希值是不能直接拿来用的，用之前要和数组的长度做取模运算（前文提到的 (n - 1) &amp; hash ），用得到的余数来访问数组下标才行。</p>
<p><strong>取模运算 </strong></p>
<p>取模运算（（“Modulo Operation”））和取余运算（（“Remainder Operation ”））是两种不同的运算方式，它们在计算机中的实现也不同。</p>
<p>在数学中，取模运算和取余运算是等价的，都是计算一个数除以另一个数的余数。例如，10 mod 3 和 10 % 3 都等于 1，因为 10 除以 3 的余数是 1。</p>
<p>在计算机中，取模运算和取余运算的差别在于，当被除数为负数时，<strong>取模运算的结果符号与被除数相同，取余运算的结果符号与除数相同</strong>。</p>
<p>例如，-10 mod 3 的结果是 -1，而 -10 % 3 的结果是 2，因为 -10 除以 3 的余数是 -1，所以 -10 取模 3 的结果应该是 -1；而 -10 对 3 取余的结果是 2，因为：-10 ÷ 3 = -3 余 -1，由于除数为正数 3，余数的符号应与被除数的符号相同，因此余数应为正数 2，而不是 -1。</p>
<p>在 Java 中，取模运算使用 % 运算符，取余运算使用 Math.floorMod() 方法。例如，计算 -10 mod 3 和 -10 % 3 的结果：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a = -10 % 3; // a = -1</span><br><span class="line">int b = Math.floorMod(-10, 3); // b = 2</span><br></pre></td></tr></table></figure>
<p> 需要注意的是，在数学中，取模运算和取余运算都有定义域的限制，即除数不能为 0。在计算机中，除数为 0 会抛出异常或返回 NaN（Not a Number）。</p>
<p> HashMap 的取模运算有两处。</p>
<p> 一处是往 HashMap 中 put 的时候（会调用私有的 putVal 方法）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123;</span><br><span class="line">    // 数组</span><br><span class="line">    HashMap.Node&lt;K,V&gt;[] tab; </span><br><span class="line">    // 元素</span><br><span class="line">    HashMap.Node&lt;K,V&gt; p; </span><br><span class="line">    // n 为数组的长度 i 为下标</span><br><span class="line">    int n, i;</span><br><span class="line">    // 数组为空的时候</span><br><span class="line">    if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">        // 第一次扩容后的数组长度</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    // 计算节点的插入位置，如果该位置为空，则新建一个节点插入</span><br><span class="line">    if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">        tab[i] = newNode(hash, key, value, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 其中 (n - 1) &amp; hash 为取模运算，为什么没用 % ，我们随后解释。</p>
<p> 一处是从 HashMap 中 get 的时候（会调用 getNode 方法）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">    // 获取当前的数组和长度，以及当前节点链表的第一个节点（根据索引直接从数组中找）</span><br><span class="line">    Node&lt;K,V&gt;[] tab; </span><br><span class="line">    Node&lt;K,V&gt; first, e; </span><br><span class="line">    int n; </span><br><span class="line">    K k;</span><br><span class="line">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">            (first = tab[(n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">        // 如果第一个节点就是要查找的节点，则直接返回</span><br><span class="line">        if (first.hash == hash &amp;&amp; ((k = first.key) == key || (key != null &amp;&amp; </span><br><span class="line">key.equals(k))))</span><br><span class="line">            return first;</span><br><span class="line">        // 如果第一个节点不是要查找的节点，则遍历节点链表查找</span><br><span class="line">        if ((e = first.next) != null) &#123;</span><br><span class="line">            do &#123;</span><br><span class="line">                if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; </span><br><span class="line">key.equals(k))))</span><br><span class="line">                    return e;</span><br><span class="line">            &#125; while ((e = e.next) != null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果节点链表中没有找到对应的节点，则返回 null</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 看到没，取模运算 (n - 1) &amp; hash 再次出现，说简单点，就是把键的哈希码经过 hash() 方法计算后，再和（数组长度-1）做了一个“与”运算。</p>
<p> <strong>取模运算%和位运算&amp; </strong></p>
<p> 可能大家在疑惑：<strong>取模运算难道不该用 %吗？为什么要用位运算 &amp;呢？</strong></p>
<p> 这是因为 &amp; 运算比 % 更加高效，并且当 b 为 2 的 n 次方时，存在下面这样一个公式。</p>
<blockquote>
<p>a % b = a &amp; (b-1)</p>
</blockquote>
<p> 用 $2^n$ 替换下 b 就是：</p>
<blockquote>
<p>a % $2^n$ = a &amp; ($2^n$-1)</p>
</blockquote>
<p> 我们来验证一下，假如 a = 14，b = 8，也就是 $2^3$，n=3。</p>
<p> 14%8（余数为 6）。</p>
<p> 14 的二进制为 1110，8 的二进制 1000，8-1 = 7，7 的二进制为 0111，1110&amp;0111=0110，也就是 0 <em> $2^0$+1 </em> $2^1$+1 <em> $2^2$+0 </em> $2^3$=0+2+4+0=6，14%8 刚好也等于 6。</p>
<p> 害，计算机就是这么讲道理，没办法</p>
<p> 这也正好解释了为什么 HashMap 的数组长度要取 2 的整次方。</p>
<p> 为什么会这样巧呢？</p>
<p> 因为（数组长度-1）正好相当于一个“低位掩码”——这个掩码的低位最好全是 1，这样 &amp; 操作才有意义，否则结果就肯定是 0，那么 &amp; 操作就没有意义了。</p>
<blockquote>
<p>a&amp;b 操作的结果是：a、b 中对应位同时为 1，则对应结果位为 1，否则为 0</p>
</blockquote>
<p> 2 的整次幂刚好是偶数，偶数-1 是奇数，奇数的二进制最后一位是 1，保证了 hash &amp;(length-1) 的最后一位可能为 0，也可能为 1（这取决于 h 的值），即 &amp; 运算后的结果可能为偶数，也可能为奇数，这样便可以保证哈希值的均匀性。</p>
<p> &amp; 操作的结果就是将哈希值的高位全部归零，只保留低位值，用来做数组下标访问。</p>
<p> 假设某哈希值为 10100101 11000100 00100101 ，用它来做取模运算，我们来看一下结果。HashMap 的初始长度为 16（内部是数组），16-1=15，二进制是 00000000 00000000 00001111 （高位用 0 来补齐）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    10100101 11000100 00100101</span><br><span class="line">&amp;   00000000 00000000 00001111</span><br><span class="line">----------------------------------</span><br><span class="line">    00000000 00000000 00000101</span><br></pre></td></tr></table></figure>
<p> 因为 15 的高位全部是 0，所以 &amp; 运算后的高位结果肯定是 0，只剩下 4 个低位 0101 ，也就是十进制的 5，也就是将哈希值为 10100101 11000100 00100101 的键放在数组的第 5 位。</p>
<p> 当然了，如果你是新手，上面这些 01 串没看懂，也没关系，记住取模运算就行了，记不住取模运算也没关系，记住<strong>取模运算是为了计算数组的下标就可以了。</strong></p>
<ul>
<li>put 的时候计算下标，把键值对放到对应的桶上。</li>
<li><p>get 的时候通过下标，把键值对从对应的桶上取出来。</p>
<p><strong>为什么取模运算之前要调用 hash 方法呢？ </strong></p>
<p>看下面这个图。</p>
</li>
</ul>
<p><img src="\assets\note\image-20231010143331295.png" alt="image-20231010143331295"></p>
<p>某哈希值为 11111111 11111111 11110000 1110 1010 ，将它右移 16 位（h &gt;&gt;&gt; 16），刚好是 00000000 00000000 11111111 11111111 ，再进行异或操作（h ^ (h &gt;&gt;&gt; 16)），结果是 11111111 11111111 00001111 00010101</p>
<blockquote>
<p>异或（ ^ ）运算是基于二进制的位运算，采用符号 XOR 或者 ^来表示，运算规则是：如果是同值取 0、异值取 1</p>
</blockquote>
<p>由于混合了原来哈希值的高位和低位，所以低位的随机性加大了（掺杂了部分高位的特征，高位的信息也得到了保留）。</p>
<p>结果再与数组长度-1（ 00000000 00000000 00000000 00001111 ）做取模运算，得到的下标就是 00000000 00000000 00000000 00000101 ，也就是 5。</p>
<p>还记得之前我们假设的某哈希值 10100101 11000100 00100101 吗？在没有调用 hash 方法之前，与 15 做取模运算后的结果也是 5，我们不妨来看看调用 hash 之后的取模运算结果是多少。</p>
<p>某哈希值 00000000 10100101 11000100 00100101 （补齐 32 位），将它右移 16 位（h &gt;&gt;&gt; 16），刚好是 00000000 00000000 00000000 10100101 ，再进行异或操作（h ^ (h &gt;&gt;&gt; 16)），结果是 00000000 10100101 00111011 10000000</p>
<p>结果再与数组长度-1（ 00000000 00000000 00000000 00001111 ）做取模运算，得到的下标就是 00000000 00000000 00000000 00000000 ，也就是 0。</p>
<p>综上所述，<strong>hash 方法是用来做哈希值优化的</strong>，把哈希值右移 16 位，也就正好是自己长度的一半，之后与原哈希值做异或运算，这样就混合了原哈希值中的高位和低位，增大了随机性。</p>
<p>说白了，<strong>hash 方法就是为了增加随机性，让数据元素更加均衡的分布，减少碰撞。</strong></p>
<p>我这里写了一段测试代码，假如 HashMap 的容量就是第一次扩容时候的 16，我在里面放了五个键值对，来看一下键的 hash 值（经过 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">map.put(&quot;chenmo&quot;, &quot;沉默&quot;);</span><br><span class="line">map.put(&quot;wanger&quot;, &quot;王二&quot;);</span><br><span class="line">map.put(&quot;chenqingyang&quot;, &quot;陈清扬&quot;);</span><br><span class="line">map.put(&quot;xiaozhuanling&quot;, &quot;小转铃&quot;);</span><br><span class="line">map.put(&quot;fangxiaowan&quot;, &quot;方小婉&quot;);</span><br><span class="line">// 遍历 HashMap</span><br><span class="line">for (String key : map.keySet()) &#123;</span><br><span class="line">    int h, n = 16;</span><br><span class="line">    int hash = (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">    int i = (n - 1) &amp; hash;</span><br><span class="line">    // 打印 key 的 hash 值 和 索引 i</span><br><span class="line">    System.out.println(key + &quot;的hash值 : &quot; + hash +&quot; 的索引 : &quot; + i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xiaozhuanling的hash值 : 14597045 的索引 : 5</span><br><span class="line">fangxiaowan的hash值 : -392727066 的索引 : 6</span><br><span class="line">chenmo的hash值 : -1361556696 的索引 : 8</span><br><span class="line">chenqingyang的hash值 : -613818743 的索引 : 9</span><br><span class="line">wanger的hash值 : -795084437 的索引 : 11</span><br></pre></td></tr></table></figure>
<p>也就是说，此时还没有发生哈希冲突，索引值都是比较均匀分布的，5、6、8、9、11，这其中的很大一部分功劳，就来自于 hash 方法。</p>
<p><strong>小结 </strong></p>
<p>hash 方法的主要作用是将 key 的 hashCode 值进行处理，得到最终的哈希值。由于 key 的 hashCode 值是不确定的，可能会出现哈希冲突，因此需要将哈希值通过一定的算法映射到 HashMap 的实际存储位置上。</p>
<p>hash 方法的原理是，先获取 key 对象的 hashCode 值，然后将其高位与低位进行异或操作，得到一个新的哈希值。为什么要进行异或操作呢？因为对于 hashCode 的高位和低位，它们的分布是比较均匀的，如果只是简单地将它们加起来或者进行位运算，容易出现哈希冲突，而异或操作可以避免这个问题。</p>
<p>然后将新的哈希值取模（mod），得到一个实际的存储位置。这个取模操作的目的是将哈希值映射到桶（Bucket）的索引上，桶是 HashMap 中的一个数组，每个桶中会存储着一个链表（或者红黑树），装载哈希值相同的键值对（没有相同哈希值的话就只存储一个键值对）。</p>
<p>总的来说，HashMap 的 hash 方法就是将 key 对象的 hashCode 值进行处理，得到最终的哈希值，并通过一定的算法映射到实际的存储位置上。这个过程决定了 HashMap 内部键值对的查找效率。</p>
<p><strong>02、HashMap的扩容机制 </strong></p>
<p>好，理解了 hash 方法后我们来看第二个问题，HashMap 的扩容机制。</p>
<p>大家都知道，数组一旦初始化后大小就无法改变了，所以就有了 ArrayList这种“动态数组”，可以自动扩容。</p>
<p>HashMap 的底层用的也是数组。向 HashMap 里不停地添加元素，当数组无法装载更多元素时，就需要对数组进行扩容，以便装入更多的元素；除此之外，容量的提升也会相应地提高查询效率，因为“桶（坑）”更多了嘛，原来需要通过链表存储的（查询的时候需要遍历），扩容后可能就有自己专属的“坑位”了（直接就能查出来）。</p>
<p>来看这个例子，容量我们定位 16：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">map.put(&quot;chenmo&quot;, &quot;沉默&quot;);</span><br><span class="line">map.put(&quot;wanger&quot;, &quot;王二&quot;);</span><br><span class="line">map.put(&quot;chenqingyang&quot;, &quot;陈清扬&quot;);</span><br><span class="line">map.put(&quot;xiaozhuanling&quot;, &quot;小转铃&quot;);</span><br><span class="line">map.put(&quot;fangxiaowan&quot;, &quot;方小婉&quot;);</span><br><span class="line">map.put(&quot;yexin&quot;, &quot;叶辛&quot;);</span><br><span class="line">map.put(&quot;liuting&quot;,&quot;刘婷&quot;);</span><br><span class="line">map.put(&quot;yaoxiaojuan&quot;,&quot;姚小娟&quot;);</span><br><span class="line">// 遍历 HashMap</span><br><span class="line">for (String key : map.keySet()) &#123;</span><br><span class="line">    int h, n = 16;</span><br><span class="line">    int hash = (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">    int i = (n - 1) &amp; hash;</span><br><span class="line">    // 打印 key 的 hash 值 和 索引 i</span><br><span class="line">    System.out.println(key + &quot;的hash值 : &quot; + hash +&quot; 的索引 : &quot; + i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">liuting的hash值 : 183821170 的索引 : 2</span><br><span class="line">xiaozhuanling的hash值 : 14597045 的索引 : 5</span><br><span class="line">fangxiaowan的hash值 : -392727066 的索引 : 6</span><br><span class="line">yaoxiaojuan的hash值 : 1231568918 的索引 : 6</span><br><span class="line">chenmo的hash值 : -1361556696 的索引 : 8</span><br><span class="line">chenqingyang的hash值 : -613818743 的索引 : 9</span><br><span class="line">yexin的hash值 : 114873289 的索引 : 9</span><br><span class="line">wanger的hash值 : -795084437 的索引 : 11</span><br></pre></td></tr></table></figure>
<p>看到没？</p>
<ul>
<li>fangxiaowan（方小婉）和 yaoxiaojuan（姚小娟）的索引都是 6；</li>
<li>chenqingyang（陈清扬）和yexin（叶辛）的索引都是 9</li>
</ul>
<p>这就意味着，要采用拉链法（后面会讲）将他们放在同一个索引的链表上。查询的时候，就不能直接通过索引的方式直接拿到（时间复杂度为 O(1)），而要通过遍历的方式（时间复杂度为 O(n)）。</p>
<p>那假如把数组的长度由 16 扩容为 32 呢？</p>
<p>将之前示例中的 n 由 16 改为 32 即可得到如下的答案：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">liuting的hash值 : 183821170 的索引 : 18</span><br><span class="line">xiaozhuanling的hash值 : 14597045 的索引 : 21</span><br><span class="line">fangxiaowan的hash值 : -392727066 的索引 : 6</span><br><span class="line">yaoxiaojuan的hash值 : 1231568918 的索引 : 22</span><br><span class="line">chenmo的hash值 : -1361556696 的索引 : 8</span><br><span class="line">chenqingyang的hash值 : -613818743 的索引 : 9</span><br><span class="line">yexin的hash值 : 114873289 的索引 : 9</span><br><span class="line">wanger的hash值 : -795084437 的索引 : 11</span><br></pre></td></tr></table></figure>
<p>可以看到：</p>
<ul>
<li>虽然chenqingyang（陈清扬）和yexin（叶辛）的索引仍然是 9。</li>
<li>但 fangxiaowan（方小婉）的索引为 6，yaoxiaojuan（姚小娟）的索引由 6 变为 22，各自都有坑了。</li>
</ul>
<p>当然了，数组是无法自动扩容的，所以如果要扩容的话，就需要新建一个大的数组，然后把之前小的数组的元素复制过去，并且要重新计算哈希值和重新分配桶（重新散列），这个过程也是挺耗时的。</p>
<p><strong>resize方法 </strong></p>
<p>HashMap 的扩容是通过 resize 方法来实现的，JDK 8 中融入了红黑树（链表长度超过 8 的时候，会将链表转化为红黑树来提高查询效率），对于新手来说，可能比较难理解。</p>
<p>为了减轻大家的学习压力，就还使用 JDK 7 的源码，搞清楚了 JDK 7 的，再看 JDK 8 的就会轻松很多。</p>
<p>来看 Java7 的 resize 方法源码，我加了注释：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// newCapacity为新的容量</span><br><span class="line">void resize(int newCapacity) &#123;</span><br><span class="line">    // 小数组，临时过度下</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    // 扩容前的容量</span><br><span class="line">    int oldCapacity = oldTable.length;</span><br><span class="line">    // MAXIMUM_CAPACITY 为最大容量，2 的 30 次方 = 1&lt;&lt;30</span><br><span class="line">    if (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        // 容量调整为 Integer 的最大值 0x7fffffff（十六进制）=2 的 31 次方-1</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 初始化一个新的数组（大容量）</span><br><span class="line">    Entry[] newTable = new Entry[newCapacity];</span><br><span class="line">    // 把小数组的元素转移到大数组中</span><br><span class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">    // 引用新的大数组</span><br><span class="line">    table = newTable;</span><br><span class="line">    // 重新计算阈值</span><br><span class="line">    threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法接收一个新的容量 newCapacity，然后将 HashMap 的容量扩大到 newCapacity。</p>
<p>首先，方法获取当前 HashMap 的旧数组 oldTable 和旧容量 oldCapacity。如果旧容量已经达到 HashMap 支持的最大容量 MAXIMUM_CAPACITY（ 2 的 30 次方），就将新的阈值 threshold 调整为 Integer.MAX_VALUE（2 的 31 次方 - 1），这是因为 HashMap 的容量不能超过 MAXIMUM_CAPACITY。</p>
<p>因为 2,147,483,647（Integer.MAX_VALUE） - 1,073,741,824（MAXIMUM_CAPACITY） = 1,073,741,823，刚好相差一倍（HashMap 每次扩容都是之前的一倍）。</p>
<p>接着，方法创建一个新的数组 newTable，并将旧数组 oldTable 中的元素转移到新数组 newTable 中。转移过程是通过调用 transfer 方法来实现的。该方法遍历旧数组中的每个桶，并将每个桶中的键值对重新计算哈希值后，将其插入到新数组对应的桶中。</p>
<p>转移完成后，方法将 HashMap 内部的数组引用 table 指向新数组 newTable，并重新计算阈值 threshold。新的阈值是新容量 newCapacity 乘以负载因子 loadFactor 的结果，但如果计算结果超过了 HashMap 支持的最大容量 MAXIMUM_CAPACITY，则将阈值设置为 MAXIMUM_CAPACITY + 1，这是因为 HashMap 的元素数量不能超过 MAXIMUM_CAPACITY。</p>
<p><strong>新容量newCapacity </strong></p>
<p>那 newCapacity 是如何计算的呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int newCapacity = oldCapacity * 2;</span><br><span class="line">if (newCapacity &lt; 0 || newCapacity &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">    newCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">&#125; else if (newCapacity &lt; DEFAULT_INITIAL_CAPACITY) &#123;</span><br><span class="line">    newCapacity = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新容量 newCapacity 被初始化为原容量 oldCapacity 的两倍。然后，如果 newCapacity 超过了 HashMap 的容量限制 MAXIMUM_CAPACITY（2^30），就将 newCapacity 设置为 MAXIMUM_CAPACITY。如果 newCapacity 小于默认初始容量 DEFAULT_INITIAL_CAPACITY（16），就将 newCapacity 设置为 DEFAULT_INITIAL_CAPACITY。这样可以避免新容量太小或太大导致哈希冲突过多或者浪费空间。</p>
<p>Java 8 的时候，newCapacity 的计算方式发生了一些细微的变化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int newCapacity = oldCapacity &lt;&lt; 1;</span><br><span class="line">if (newCapacity &gt;= DEFAULT_INITIAL_CAPACITY &amp;&amp; oldCapacity &gt;= </span><br><span class="line">DEFAULT_INITIAL_CAPACITY) &#123;</span><br><span class="line">    if (newCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        newCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    if (newCapacity &lt; DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">        newCapacity = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意， oldCapacity * 2 变成了 oldCapacity &lt;&lt; 1 ，出现了左移（ &lt;&lt; ），这里简单介绍一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=39</span><br><span class="line">b = a &lt;&lt; 2</span><br></pre></td></tr></table></figure>
<p>十进制 39 用 8 位的二进制来表示，就是 00100111，左移两位后是 10011100（低位用 0 补上），再转成十进制数就是 156。</p>
<p>移位运算通常可以用来代替乘法运算和除法运算。例如，将 0010011（39）左移两位就是 10011100（156），刚好变成了原来的 4 倍。</p>
<p>实际上呢，二进制数左移后会变成原来的 2 倍、4 倍、8 倍，记住这个就好。</p>
<p><strong>transfer方法 </strong></p>
<p>接下来，来说 transfer 方法，该方法用来转移，将旧的小数组元素拷贝到新的大数组中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void transfer(Entry[] newTable, boolean rehash) &#123;</span><br><span class="line">    // 新的容量</span><br><span class="line">    int newCapacity = newTable.length;</span><br><span class="line">    // 遍历小数组</span><br><span class="line">    for (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        while(null != e) &#123;</span><br><span class="line">            // 拉链法，相同 key 上的不同值</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            // 是否需要重新计算 hash</span><br><span class="line">            if (rehash) &#123;</span><br><span class="line">                e.hash = null == e.key ? 0 : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            // 根据大数组的容量，和键的 hash 计算元素在数组中的下标</span><br><span class="line">            int i = indexFor(e.hash, newCapacity);</span><br><span class="line">            // 同一位置上的新元素被放在链表的头部</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            // 放在新的数组上</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            // 链表上的下一个元素</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法接受一个新的 Entry 数组 newTable 和一个布尔值 rehash 作为参数，其中 newTable 表示新的哈希表，rehash 表示是否需要重新计算键的哈希值。</p>
<p>在方法中，首先获取新哈希表（数组）的长度 newCapacity，然后遍历旧哈希表中的每个 Entry。对于每个 Entry，使用拉链法将相同 key 值的不同 value 值存储在同一个链表中。如果 rehash 为 true，则需要重新计算键的哈希值，并将新的哈希值存储在 Entry 的 hash 属性中。</p>
<p>接着，根据新哈希表的长度和键的哈希值，计算 Entry 在新数组中的位置 i，然后将该 Entry 添加到新数组的 i 位置上。由于新元素需要被放在链表的头部，因此将新元素的下一个元素设置为当前数组位置上的元素。</p>
<p>最后，遍历完旧哈希表中的所有元素后，转移工作完成，新的哈希表 newTable 已经包含了旧哈希表中的所有元素。</p>
<p><strong>拉链法 </strong></p>
<p>注意， e.next = newTable[i] ，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素最终会被放到链表的尾部，这就会导致<strong>在旧数组中同一个链表上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。</strong></p>
<p>就这点上，Java 8 做了很大的优化（下面会讲）。</p>
<p>现在假设 hash 算法就是简单的用键的哈希值（一个 int 值）和数组大小取模（也就是 hashCode % table.length ）。</p>
<p>继续假设：</p>
<ul>
<li>数组 table 的长度为 2</li>
<li>键的哈希值为 3、7、5</li>
</ul>
<p>取模运算后，哈希冲突都到 table[1] 上了，因为余数为 1。那么扩容前的样子如下图所示。</p>
<p><img src="\assets\note\image-20231010144428407.png" alt="image-20231010144428407"></p>
<p>数组的容量为 2， key 3、7、5 都在 table[1] 的链表上。</p>
<p>假设负载因子（后面会细讲） loadFactor 为 1，也就是当元素的个数大于 table 的长度时进行扩容。</p>
<p>扩容后的数组容量为 4。</p>
<ul>
<li>key 3 取模（3%4）后是 3，放在 table[3] 上。</li>
<li>key 7 取模（7%4）后是 3，放在 table[3] 上的链表头部。</li>
<li>key 5 取模（5%4）后是 1，放在 table[1] 上。</li>
</ul>
<p><img src="\assets\note\image-20231010144506517.png" alt="image-20231010144506517"></p>
<p>按照我们的预期，扩容后的 7 仍然应该在 3 这条链表的后面，但实际上呢？ 7 跑到 3 这条链表的头部了。</p>
<p>针对 JDK 7 中的这个情况，JDK 8 做了哪些优化呢？</p>
<p>看下面这张图。</p>
<p><img src="\assets\note\image-20231010144539682.png" alt="image-20231010144539682"></p>
<p>n 为 table 的长度，默认值为 16。</p>
<ul>
<li>n-1 也就是二进制的 0000 1111（1X$2^0$+1X$2^1$+1X$2^2$+1X$2^3$=1+2+4+8=15）；</li>
<li>key1 哈希值的最后 8 位为 0000 0101</li>
<li>key2 哈希值的最后 8 位为 0001 0101（和 key1 不同）</li>
<li>做与运算后发生了哈希冲突，索引都在（0000 0101）上。</li>
</ul>
<p>扩容后为 32。</p>
<ul>
<li>n-1 也就是二进制的 0001 1111（1X$2^0$+1X$2^1$+1X$2^2$+1X$2^3$+1X$2^4$=1+2+4+8+16=31），扩容前是 0000 1111。</li>
<li>key1 哈希值的低位为 0000 0101</li>
<li>key2 哈希值的低位为 0001 0101（和 key1 不同）</li>
<li>key1 做与运算后，索引为 0000 0101。</li>
<li>key2 做与运算后，索引为 0001 0101。</li>
</ul>
<p>新的索引就会发生这样的变化：</p>
<ul>
<li>原来的索引是 5（0 0101）</li>
<li>原来的容量是 16</li>
<li>扩容后的容量是 32</li>
<li>扩容后的索引是 21（1 0101），也就是 5+16，也就是原来的索引+原来的容量</li>
</ul>
<p><img src="\assets\note\image-20231010144658763.png" alt="image-20231010144658763"></p>
<p>也就是说，JDK 8 不需要像 JDK 7 那样重新计算 hash，只需要看原来的hash值新增的那个bit是1还是0就好了，是0的话就表示索引没变，是1的话，索引就变成了“原索引+原来的容量”。</p>
<p><img src="\assets\note\image-20231010144735415.png" alt="image-20231010144735415"></p>
<p>JDK 8 的这个设计非常巧妙，既省去了重新计算hash的时间，同时，由于新增的1 bit是0还是1是随机的，因此扩容的过程，可以均匀地把之前的节点分散到新的位置上。</p>
<p>woc，只能说 HashMap 的作者 Doug Lea、Josh Bloch、Arthur van Hoff、Neal Gafter 真的强——的一笔。</p>
<p><strong>Java 8 扩容 </strong></p>
<p>JDK 8 的扩容源代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table; // 获取原来的数组 table</span><br><span class="line">    int oldCap = (oldTab == null) ? 0 : oldTab.length; // 获取数组长度 oldCap</span><br><span class="line">    int oldThr = threshold; // 获取阈值 oldThr</span><br><span class="line">    int newCap, newThr = 0;</span><br><span class="line">    if (oldCap &gt; 0) &#123; // 如果原来的数组 table 不为空</span><br><span class="line">        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; // 超过最大值就不再扩充了，就只好随你碰撞去吧</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            return oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; // 没超过最大值，就扩充为原来的2倍</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line">    &#125;</span><br><span class="line">    else if (oldThr &gt; 0) // initial capacity was placed in threshold</span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    else &#123; // zero initial threshold signifies using defaults</span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    // 计算新的 resize 上限</span><br><span class="line">    if (newThr == 0) &#123;</span><br><span class="line">        float ft = (float)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (int)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr; // 将新阈值赋值给成员变量 threshold</span><br><span class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; // 创建新数组 newTab</span><br><span class="line">    table = newTab; // 将新数组 newTab 赋值给成员变量 table</span><br><span class="line">    if (oldTab != null) &#123; // 如果旧数组 oldTab 不为空</span><br><span class="line">        for (int j = 0; j &lt; oldCap; ++j) &#123; // 遍历旧数组的每个元素</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            if ((e = oldTab[j]) != null) &#123; // 如果该元素不为空</span><br><span class="line">                oldTab[j] = null; // 将旧数组中该位置的元素置为 null，以便垃圾回收</span><br><span class="line">                if (e.next == null) // 如果该元素没有冲突</span><br><span class="line">                    newTab[e.hash &amp; (newCap - 1)] = e; // 直接将该元素放入新数组</span><br><span class="line">                else if (e instanceof TreeNode) // 如果该元素是树节点</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); // 将该树节点分裂成两个链表</span><br><span class="line">                else &#123; // 如果该元素是链表</span><br><span class="line">                    Node&lt;K,V&gt; loHead = null, loTail = null; // 低位链表的头结点和尾结点</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = null, hiTail = null; // 高位链表的头结点和尾结点</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    do &#123; // 遍历该链表</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        if ((e.hash &amp; oldCap) == 0) &#123; // 如果该元素在低位链表中</span><br><span class="line">                            if (loTail == null) // 如果低位链表还没有结点</span><br><span class="line">                                loHead = e; // 将该元素作为低位链表的头结点</span><br><span class="line">                            else</span><br><span class="line">                                loTail.next = e; // 如果低位链表已经有结点，将该元素加入低位链表的尾部</span><br><span class="line">                            loTail = e; // 更新低位链表的尾结点</span><br><span class="line">                        &#125;</span><br><span class="line">                        else &#123; // 如果该元素在高位链表中</span><br><span class="line">                            if (hiTail == null) // 如果高位链表还没有结点</span><br><span class="line">                                hiHead = e; // 将该元素作为高位链表的头结点</span><br><span class="line">                            else</span><br><span class="line">                                hiTail.next = e; // 如果高位链表已经有结点，将该元素加入高位链表的尾部</span><br><span class="line">                            hiTail = e; // 更新高位链表的尾结点</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; while ((e = next) != null); //</span><br><span class="line">                    if (loTail != null) &#123; // 如果低位链表不为空</span><br><span class="line">                        loTail.next = null; // 将低位链表的尾结点指向 null，以便垃圾回收</span><br><span class="line">                        newTab[j] = loHead; // 将低位链表作为新数组对应位置的元素</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (hiTail != null) &#123; // 如果高位链表不为空</span><br><span class="line">                        hiTail.next = null; // 将高位链表的尾结点指向 null，以便垃圾回收</span><br><span class="line">                        newTab[j + oldCap] = hiHead; // 将高位链表作为新数组对应位置的元素</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newTab; // 返回新数组</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1、获取原来的数组 table、数组长度 oldCap 和阈值 oldThr。</p>
<p>2、如果原来的数组 table 不为空，则根据扩容规则计算新数组长度 newCap 和新阈值 newThr，然后将原数组中的元素复制到新数组中。</p>
<p>3、如果原来的数组 table 为空但阈值 oldThr 不为零，则说明是通过带参数构造函数创建的 HashMap，此时将阈值作为新数组长度 newCap。</p>
<p>4、如果原来的数组 table 和阈值 oldThr 都为零，则说明是通过无参数构造函数创建的 HashMap，此时将默认初始容量 DEFAULT_INITIAL_CAPACITY（16）和默认负载因子 DEFAULT_LOAD_FACTOR（0.75）计算出新数组长度 newCap 和新阈值 newThr。</p>
<p>5、计算新阈值 threshold，并将其赋值给成员变量 threshold。</p>
<p>6、创建新数组 newTab，并将其赋值给成员变量 table。</p>
<p>7、如果旧数组 oldTab 不为空，则遍历旧数组的每个元素，将其复制到新数组中。</p>
<p>8、返回新数组 newTab。</p>
<p><strong>小结 </strong></p>
<p>HashMap 的内部实现是通过一个数组和链表或红黑树的组合来实现的。当我们往 HashMap 中不断添加元素时，HashMap 会自动进行扩容操作（条件是元素数量达到负载因子（load factor）乘以数组长度时），以保证其存储的元素数量不会超出其容量限制。下面是 HashMap 的扩容机制：</p>
<p>1、在进行扩容操作时，HashMap 会先将数组的长度扩大一倍，然后将原来的元素重新散列（这个词还是挺贴切的）到新的数组中。由于元素的散列位置是通过 key 的 hashcode 和数组长度取模得到的，因此在数组长度扩大后，元素的散列位置也会发生一些改变。</p>
<p>2、在重新散列元素时，如果一个元素的散列位置发生了改变，那么它需要被移动到新的位置。如果新的位置上已经有元素了，那么这个元素就会被添加到链表的末尾，如果链表的长度超过了阈值（8个），那么它将会被转换成红黑树。</p>
<p>总之，HashMap 的扩容机制是通过增加数组长度和重新散列元素来实现的，它可以保证 HashMap 的存储容量足够大，同时也可以保证 HashMap 的存储效率和检索效率。但是，由于扩容操作需要耗费一定的时间和空间，因此我们需要在使用 HashMap 时，合理地设置初始容量和负载因子，以避免过多的扩容操作。</p>
<p><strong>03、加载因子为什么是0.75 </strong></p>
<p>上一个问题提到了加载因子（或者叫负载因子），那么这个问题我们来讨论为什么加载因子是 0.75 而不是 0.6、0.8。</p>
<p>我们知道，HashMap 是用数组+链表/红黑树实现的，我们要想往 HashMap 中添加数据（元素/键值对）或者取数据，就需要确定数据在数组中的下标（索引）。</p>
<p>先把数据的键进行一次 hash：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再做一次取模运算确定下标：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = (n - 1) &amp; hash</span><br></pre></td></tr></table></figure>
<p>那这样的过程容易产生两个问题：</p>
<ul>
<li>数组的容量过小，经过哈希计算后的下标，容易出现冲突；</li>
<li>数组的容量过大，导致空间利用率不高。</li>
</ul>
<p>加载因子是用来表示 HashMap 中数据的填满程度：</p>
<blockquote>
<p>加载因子 = 填入哈希表中的数据个数 / 哈希表的长度</p>
</blockquote>
<p>这就意味着：</p>
<ul>
<li>加载因子越小，填满的数据就越少，哈希冲突的几率就减少了，但浪费了空间，而且还会提高扩容的触发几率；</li>
<li>加载因子越大，填满的数据就越多，空间利用率就高，但哈希冲突的几率就变大了。</li>
</ul>
<p>好难！！！！</p>
<p>这就必须在“哈希冲突”与“空间利用率”两者之间有所取舍，尽量保持平衡，谁也不碍着谁。</p>
<p>我们知道，HashMap 是通过拉链法来解决哈希冲突的。</p>
<p>为了减少哈希冲突发生的概率，当 HashMap 的数组长度达到一个临界值的时候，就会触发扩容，扩容后会将之前小数组中的元素转移到大数组中，这是一个相当耗时的操作。</p>
<p>这个临界值由什么来确定呢？</p>
<blockquote>
<p>临界值 = 初始容量 * 加载因子</p>
</blockquote>
<p>一开始，HashMap 的容量是 16：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16</span><br></pre></td></tr></table></figure>
<p>加载因子是 0.75：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static final float DEFAULT_LOAD_FACTOR = 0.75f;</span><br></pre></td></tr></table></figure>
<p>也就是说，当 16*0.75=12 时，会触发扩容机制。</p>
<p><strong>为什么加载因子会选择 0.75 呢？为什么不是0.8、0.6呢？</strong></p>
<p>这跟统计学里的一个很重要的原理——泊松分布有关。</p>
<p>是时候上维基百科了：</p>
<blockquote>
<p>泊松分布，是一种统计与概率学里常见到的离散概率分布，由法国数学家西莫恩·德尼·泊松在1838年时提出。它会对随机事件的发生次数进行建模，适用于涉及计算在给定的时间段、距离、面积等范围内发生随机事件的次数的应用情形。</p>
</blockquote>
<p>阮一峰老师曾在一篇博文中详细的介绍了泊松分布和指数分布，大家可以去看一下。</p>
<blockquote>
<p>链接：<a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2015/06/poisson-distribution.html">https://www.ruanyifeng.com/blog/2015/06/poisson-distribution.html</a></p>
</blockquote>
<p>具体是用这么一个公式来表示的。</p>
<script type="math/tex; mode=display">
P(N(t)=n)=\frac{(\lambda t)^ne^{-\lambda t}}{n!}</script><p>等号的左边，P 表示概率，N表示某种函数关系，t 表示时间，n 表示数量。</p>
<p>在 HashMap 的 doc 文档里，曾有这么一段描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Because TreeNodes are about twice the size of regular nodes, we</span><br><span class="line">use them only when bins contain enough nodes to warrant use</span><br><span class="line">(see TREEIFY_THRESHOLD). And when they become too small (due to</span><br><span class="line">removal or resizing) they are converted back to plain bins.  In</span><br><span class="line">usages with well-distributed user hashCodes, tree bins are</span><br><span class="line">rarely used.  Ideally, under random hashCodes, the frequency of</span><br><span class="line">nodes in bins follows a Poisson distribution</span><br><span class="line">(http://en.wikipedia.org/wiki/Poisson_distribution) with a</span><br><span class="line">parameter of about 0.5 on average for the default resizing</span><br><span class="line">threshold of 0.75, although with a large variance because of</span><br><span class="line">resizing granularity. Ignoring variance, the expected</span><br><span class="line">occurrences of list size k are (exp(-0.5) * pow(0.5, k) /</span><br><span class="line">factorial(k)). The first values are:</span><br><span class="line">0:    0.60653066</span><br><span class="line">1:    0.30326533</span><br><span class="line">2:    0.07581633</span><br><span class="line">3:    0.01263606</span><br><span class="line">4:    0.00157952</span><br><span class="line">5:    0.00015795</span><br><span class="line">6:    0.00001316</span><br><span class="line">7:    0.00000094</span><br><span class="line">8:    0.00000006</span><br><span class="line">more: less than 1 in ten million</span><br></pre></td></tr></table></figure>
<p>为了便于大家的理解，这里来重温一下 HashMap 的拉链法和红黑树结构。</p>
<p>Java 8 之前，HashMap 使用链表来解决冲突，即当两个或者多个键映射到同一个桶时，它们被放在同一个桶的链表上。当链表上的节点（Node）过多时，链表会变得很长，查找的效率（LinkedList 的查找效率为 O（n））就会受到影响。</p>
<p>Java 8 中，当链表的节点数超过一个阈值（8）时，链表将转为红黑树（节点为TreeNode），红黑树（在讲TreeMap时会细说）是一种高效的平衡树结构，能够在 O(log n) 的时间内完成插入、删除和查找等操作。这种结构在节点数很多时，可以提高 HashMap 的性能和可伸缩性。好，有了这个背景，我们来把上面的 doc 文档翻译为中文：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">因为TreeNode（红黑树的节点）的大小大约是常规节点（链表的节点 Node）的两倍，所以只有当桶内包含足够多</span><br><span class="line">的节点时才使用红黑树（参见TREEIFY_THRESHOLD「阈值，值为8」，节点数量较多时，红黑树可以提高查询效</span><br><span class="line">率）。</span><br><span class="line">由于删除元素或者调整数组大小（扩容）时（再次散列），红黑树可能会被转换为链表（节点数量小于 8 时），节</span><br><span class="line">点数量较少时，链表的效率比红黑树更高，因为红黑树需要更多的内存空间来存储节点。</span><br><span class="line">在具有良好分布的hashCode使用中，很少使用红黑树。</span><br><span class="line">理想情况下，在随机hashCode下，节点在桶中的频率遵循泊松分布（https://zh.wikipedia.org/wiki/卜瓦</span><br><span class="line">松分布），平均缩放阈值为0.75，忽略方差，列表大小k的预期出现次数为（exp（-0.5）* pow（0.5，k）/ </span><br><span class="line">factorial（k））。</span><br><span class="line">前几个值是：</span><br><span class="line">0: 0.60653066</span><br><span class="line">1: 0.30326533</span><br><span class="line">2: 0.07581633</span><br><span class="line">3: 0.01263606</span><br><span class="line">4: 0.00157952</span><br><span class="line">5: 0.00015795</span><br><span class="line">6: 0.00001316</span><br><span class="line">7: 0.00000094</span><br><span class="line">8: 0.00000006</span><br><span class="line">更多：小于一千万分之一</span><br></pre></td></tr></table></figure>
<p>虽然这段话的本意更多的是表示 jdk 8中为什么拉链长度超过8的时候进行了红黑树转换，但提到了 0.75 这个加载因子，但没提到底为什么。</p>
<p>为了搞清楚到底为什么，我看到了这篇文章：</p>
<blockquote>
<p>参考链接：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000023308658">https://segmentfault.com/a/1190000023308658</a></p>
</blockquote>
<p>里面提到了一个概念：二项分布（Binomial Distribution）。</p>
<p>在做一件事情的时候，其结果的概率只有2种情况，和抛硬币一样，不是正面就是反面。</p>
<p>假如，我们做了 N 次实验，那么在每次试验中只有两种可能的结果，并且每次实验是独立的，不同实验之间互不影响，每次实验成功的概率都是一样的。</p>
<p>以此理论为基础：我们往哈希表中扔数据，如果发生哈希冲突就为失败，否则为成功。</p>
<p>我们可以设想，实验的hash值是随机的，并且经过hash运算的键都会映射到hash表的地址空间上，那么这个结果也是随机的。所以，每次put的时候就相当于我们在扔一个16面（HashMap 第一次扩容后的数组默认长度为16）的骰子，扔骰子实验那肯定是相互独立的。碰撞发生即扔了n次有出现重复数字。</p>
<p>然后，我们的目的是啥呢？</p>
<p>就是掷了k次骰子，没有一次是相同的概率，需要尽可能的大些，一般意义上我们肯定要大于0.5（这个数是个理想数）。</p>
<p>于是，n次事件里面，碰撞为0的概率，由上面公式得：</p>
<script type="math/tex; mode=display">
binom(n,0)=C_{n}^{0} \times (\frac{1}{s} )^0 \times (1-\frac{1}{s})^{n-0}=(1-\frac{1}{s})^n</script><p>这个概率值需要大于0.5，我们认为这样的hashmap可以提供很低的碰撞率。所以：</p>
<p>这时候，我们对于该公式其实最想求的时候长度s的时候，n为多少次就应该进行扩容了？而负载因子则是$n/s$的值。所以推导如下：</p>
<script type="math/tex; mode=display">
\begin{align*}
&nln(1-\frac{1}{s} )\ge -ln2...两边取对数\\
&n\le \frac{-ln2}{ln(1-\frac{1}{s} )} \to n\le \frac{ln2}{ln\frac{s}{s-1} } ...提取n\\
&\frac{n}{s} \le \frac{ln2}{sln\frac{s}{s-1} } ...两边除以s\\
\end{align*}</script><p>所以可以得到</p>
<script type="math/tex; mode=display">
loadFactor=\lim_{s \to \infty} \frac{ln2}{sln\frac{s}{s-1} }</script><p>其中</p>
<script type="math/tex; mode=display">
\lim_{s \to \infty} \frac{ln2}{sln\frac{s}{s-1} }</script><p>这就是一个求 ∞⋅0函数极限问题，这里我们先令$s = m+1（m \to \infty）$则转化为</p>
<script type="math/tex; mode=display">
\lim_{m \to \infty} (m+1)ln(1+\frac{1}{m} )</script><p>我们再令 $x = \frac{1}{m} （x \to 0）$ 则有，</p>
<script type="math/tex; mode=display">
\begin{align*}
&\lim_{s \to \infty} sln\frac{s}{s-1} =\lim_{x \to 0} (\frac{1}{x} +1)ln(1+x)\\
&=\lim_{x \to 0} (\frac{1}{x} +1)x...无穷小等价替换有ln(1+x)\sim x\\
&=\lim_{x \to 0} (1+x)\\
&\sim1\\
\end{align*}</script><p>所以</p>
<script type="math/tex; mode=display">
\begin{align*}
&loadFactor=\lim_{s \to \infty} \frac{ln2}{sln\frac{s}{s-1} } \\
&\sim ln2\\
&\sim 0.693\\
\end{align*}</script><p>考虑到 HashMap的容量有一个要求：它必须是2的n 次幂。当加载因子选择了0.75就可以保证它与容量的乘积为整数。</p>
<p>除了 0.75，0.5~1 之间还有 0.625（5/8）、0.875（7/8）可选，从中位数的角度，挑 0.75 比较完美。另外，维基百科上说，拉链法（解决哈希冲突的一种）的加载因子最好限制在 0.7-0.8以下，超过0.8，查表时的CPU缓存不命中（cache missing）会按照指数曲线上升。</p>
<p>综上，0.75 是个比较完美的选择。</p>
<p><strong>小结 </strong></p>
<p>HashMap 的加载因子（load factor，直译为加载因子，意译为负载因子）是指哈希表中填充元素的个数与桶的数量的比值，当元素个数达到负载因子与桶的数量的乘积时，就需要进行扩容。这个值一般选择 0.75，是因为这个值可以在时间和空间成本之间做到一个折中，使得哈希表的性能达到较好的表现。</p>
<p>如果负载因子过大，填充因子较多，那么哈希表中的元素就会越来越多地聚集在少数的桶中，这就导致了冲突的增加，这些冲突会导致查找、插入和删除操作的效率下降。同时，这也会导致需要更频繁地进行扩容，进一步降低了性能。</p>
<p>如果负载因子过小，那么桶的数量会很多，虽然可以减少冲突，但是在空间利用上面也会有浪费，因此选择 0.75 是为了取得一个平衡点，即在时间和空间成本之间取得一个比较好的平衡点。</p>
<p>总之，选择 0.75 这个值是为了在时间和空间成本之间达到一个较好的平衡点，既可以保证哈希表的性能表现，又能够充分利用空间。</p>
<p><strong>04、线程不安全 </strong></p>
<p>其实这个问题也不用说太多，但考虑到面试的时候有些面试官会问，那就简单说一下。</p>
<p>三方面原因：</p>
<ul>
<li>多线程下扩容会死循环</li>
<li>多线程下 put 会导致元素丢失</li>
<li>put 和 get 并发时会导致 get 到 null</li>
</ul>
<p><strong>1）多线程下扩容会死循环 </strong></p>
<p>众所周知，HashMap 是通过拉链法来解决哈希冲突的，也就是当哈希冲突时，会将相同哈希值的键值对通过链表的形式存放起来。</p>
<p>JDK 7 时，采用的是头部插入的方式来存放链表的，也就是下一个冲突的键值对会放在上一个键值对的前面（讲扩容的时候讲过了）。扩容的时候就有可能导致出现环形链表，造成死循环。</p>
<p>resize 方法的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// newCapacity为新的容量</span><br><span class="line">void resize(int newCapacity) &#123;</span><br><span class="line">    // 小数组，临时过度下</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    // 扩容前的容量</span><br><span class="line">    int oldCapacity = oldTable.length;</span><br><span class="line">    // MAXIMUM_CAPACITY 为最大容量，2 的 30 次方 = 1&lt;&lt;30</span><br><span class="line">    if (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        // 容量调整为 Integer 的最大值 0x7fffffff（十六进制）=2 的 31 次方-1</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 初始化一个新的数组（大容量）</span><br><span class="line">    Entry[] newTable = new Entry[newCapacity];</span><br><span class="line">    // 把小数组的元素转移到大数组中</span><br><span class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">    // 引用新的大数组</span><br><span class="line">    table = newTable;</span><br><span class="line">    // 重新计算阈值</span><br><span class="line">    threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>transfer 方法用来转移，将小数组的元素拷贝到新的数组中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void transfer(Entry[] newTable, boolean rehash) &#123;</span><br><span class="line">    // 新的容量</span><br><span class="line">    int newCapacity = newTable.length;</span><br><span class="line">    // 遍历小数组</span><br><span class="line">    for (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        while(null != e) &#123;</span><br><span class="line">            // 拉链法，相同 key 上的不同值</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            // 是否需要重新计算 hash</span><br><span class="line">            if (rehash) &#123;</span><br><span class="line">                e.hash = null == e.key ? 0 : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            // 根据大数组的容量，和键的 hash 计算元素在数组中的下标</span><br><span class="line">            int i = indexFor(e.hash, newCapacity);</span><br><span class="line">            // 同一位置上的新元素被放在链表的头部</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            // 放在新的数组上</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            // 链表上的下一个元素</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意 e.next = newTable[i] 和 newTable[i] = e 这两行代码，就会将同一位置上的新元素被放在链表的头部。</p>
<p>扩容前的样子假如是下面这样子。</p>
<p> <img src="\assets\note\image-20231010152210618.png" alt="image-20231010152210618"></p>
<p>那么正常扩容后就是下面这样子。</p>
<p><img src="\assets\note\image-20231010152226084.png" alt="image-20231010152226084"></p>
<p>假设现在有两个线程同时进行扩容，线程 A 在执行到 newTable[i] = e; 被挂起，此时线程 A 中：e=3、next=7、e.next=null</p>
<p><img src="\assets\note\image-20231010152248252.png" alt="image-20231010152248252"></p>
<p>线程 B 开始执行，并且完成了数据转移。</p>
<p><img src="\assets\note\image-20231010152308768.png" alt="image-20231010152308768"></p>
<p>此时，7 的 next 为 3，3 的 next 为 null。</p>
<p>随后线程A获得CPU时间片继续执行 newTable[i] = e ，将3放入新数组对应的位置，执行完此轮循环后线程A的情况如下：</p>
<p><img src="\assets\note\image-20231010152329436.png" alt="image-20231010152329436"></p>
<p>执行下一轮循环，此时 e=7，原本线程 A 中 7 的 next 为 5，但由于 table 是线程 A 和线程 B 共享的，而线程 B 顺利执行完后，7 的 next 变成了 3，那么此时线程 A 中，7 的 next 也为 3 了。</p>
<p>采用头部插入的方式，变成了下面这样子：</p>
<p><img src="\assets\note\image-20231010152352419.png" alt="image-20231010152352419"></p>
<p>好像也没什么问题，此时 next = 3，e = 3。</p>
<p>进行下一轮循环，但此时，由于线程 B 将 3 的 next 变为了 null，所以此轮循环应该是最后一轮了。</p>
<p>接下来当执行完 e.next=newTable[i] 即 3.next=7 后，3 和 7 之间就相互链接了，执行完 newTable[i]=e 后，3 被头插法重新插入到链表中，执行结果如下图所示：</p>
<p><img src="\assets\note\image-20231010152425560.png" alt="image-20231010152425560"></p>
<p>套娃开始，元素 5 也就成了弃婴，惨~~~</p>
<p>不过，JDK 8 时已经修复了这个问题，扩容时会保持链表原来的顺序（嗯，等于说了半天白说了，哈哈，这个面试题确实是这样，很水，但有些面试官又确实比较装逼）。</p>
<p>**2）多线程下 put 会导致元素丢失 </p>
<p>正常情况下，当发生哈希冲突时，HashMap 是这样的：</p>
<p><img src="\assets\note\image-20231010152459546.png" alt="image-20231010152459546"></p>
<p>但多线程同时执行 put 操作时，如果计算出来的索引位置是相同的，那会造成前一个 key 被后一个 key 覆盖，从而导致元素的丢失。</p>
<p>put 的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">               boolean evict) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">    // 步骤①：tab为空则创建</span><br><span class="line">    if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    // 步骤②：计算index，并对null做处理 </span><br><span class="line">    if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">        tab[i] = newNode(hash, key, value, null);</span><br><span class="line">    else &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        // 步骤③：节点key存在，直接覆盖value</span><br><span class="line">        if (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        // 步骤④：判断该链为红黑树</span><br><span class="line">        else if (p instanceof TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">        // 步骤⑤：该链为链表</span><br><span class="line">        else &#123;</span><br><span class="line">            for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">                if ((e = p.next) == null) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, null);</span><br><span class="line">                    //链表长度大于8转换为红黑树进行处理</span><br><span class="line">                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                // key已经存在直接覆盖value</span><br><span class="line">                if (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    break;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 步骤⑥、直接覆盖</span><br><span class="line">        if (e != null) &#123; // existing mapping for key</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    // 步骤⑦：超过最大容量 就扩容</span><br><span class="line">    if (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题发生在步骤 ② 这里：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">    tab[i] = newNode(hash, key, value, null);</span><br></pre></td></tr></table></figure>
<p>两个线程都执行了 if 语句，假设线程 A 先执行了 tab[i] = newNode(hash, key, value, null) ，那 table 是这样的：<br>      <img src="\assets\note\image-20231010152638506.png" alt="image-20231010152638506">    </p>
<p>接着，线程 B 执行了 tab[i] = newNode(hash, key, value, null) ，那 table 是这样的：</p>
<p><img src="\assets\note\image-20231010152655351.png" alt="image-20231010152655351"></p>
<p>3 被干掉了。</p>
<p><strong>3）put 和 get 并发时会导致 get 到 null </strong></p>
<p>线程 A 执行put时，因为元素个数超出阈值而出现扩容，线程B 此时执行get，有可能导致这个问题。</p>
<p>注意来看 resize 源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">    int oldThr = threshold;</span><br><span class="line">    int newCap, newThr = 0;</span><br><span class="line">    if (oldCap &gt; 0) &#123;</span><br><span class="line">        // 超过最大值就不再扩充了，就只好随你碰撞去吧</span><br><span class="line">        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            return oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        // 没超过最大值，就扩充为原来的2倍</span><br><span class="line">        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line">    &#125;</span><br><span class="line">    else if (oldThr &gt; 0) // initial capacity was placed in threshold</span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    else &#123;               // zero initial threshold signifies using defaults</span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    // 计算新的resize上限</span><br><span class="line">    if (newThr == 0) &#123;</span><br><span class="line">        float ft = (float)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (int)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程 A 执行完 table = newTab 之后，线程 B 中的 table 此时也发生了变化，此时去 get 的时候当然会 get 到 null 了，因为元素还没有转移。</p>
<p>参考链接：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lonyw/article/details/80519652">https://blog.csdn.net/lonyw/article/details/80519652</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/91636401">https://zhuanlan.zhihu.com/p/91636401</a></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20733617">https://www.zhihu.com/question/20733617</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/21673805">https://zhuanlan.zhihu.com/p/21673805</a></p>
</blockquote>
<p><strong>4）小结 </strong></p>
<p>HashMap 是线程不安全的主要是因为它在进行插入、删除和扩容等操作时可能会导致链表的结构发生变化，从而破坏了 HashMap 的不变性。具体来说，如果在一个线程正在遍历 HashMap 的链表时，另外一个线程对该链表进行了修改（比如添加了一个节点），那么就会导致链表的结构发生变化，从而破坏了当前线程正在进行的遍历操作，可能导致遍历失败或者出现死循环等问题。</p>
<p>为了解决这个问题，Java 提供了线程安全的 HashMap 实现类 ConcurrentHashMap。ConcurrentHashMap 内部采用了分段锁（Segment），将整个 Map 拆分为多个小的 HashMap，每个小的 HashMap 都有自己的锁，不同的线程可以同时访问不同的小 Map，从而实现了线程安全。在进行插入、删除和扩容等操作时，只需要锁住当前小 Map，不会对整个 Map 进行锁定，提高了并发访问的效率。</p>
<p><strong>05、总结 </strong></p>
<p>HashMap是Java中最常用的集合之一，它是一种键值对存储的数据结构，可以根据键来快速访问对应的值。</p>
<p>以下是对HashMap的总结：</p>
<ul>
<li>HashMap采用数组+链表/红黑树的存储结构，能够在O(1)的时间复杂度内实现元素的添加、删除、查找等操作。</li>
<li>HashMap是线程不安全的，因此在多线程环境下需要使用ConcurrentHashMap来保证线程安全。</li>
<li>HashMap的扩容机制是通过扩大数组容量和重新计算hash值来实现的，扩容时需要重新计算所有元素的hash值，因此在元素较多时扩容会影响性能。</li>
<li>在Java 8中，HashMap的实现引入了拉链法、树化等机制来优化大量元素存储的情况，进一步提升了性能。</li>
<li>HashMap中的key是唯一的，如果要存储重复的key，则后面的值会覆盖前面的值。</li>
<li>HashMap的初始容量和加载因子都可以设置，初始容量表示数组的初始大小，加载因子表示数组的填充因子。一般情况下，初始容量为16，加载因子为0.75。</li>
<li>HashMap在遍历时是无序的，因此如果需要有序遍历，可以使用TreeMap。</li>
</ul>
<p>综上所述，HashMap是一种高效的数据结构，具有快速查找和插入元素的能力，但需要注意线程安全和性能问题。</p>
<h2 id="4-10-LinkedHashMap详解（附源码）"><a href="#4-10-LinkedHashMap详解（附源码）" class="headerlink" title="4.10 LinkedHashMap详解（附源码）"></a>4.10 LinkedHashMap详解（附源码）</h2><p>这篇继续换个文风来写，给大家一点新鲜的空气。</p>
<p>俗话说了，“金无足赤人无完人”，HashMap 也不例外，有一种需求它就满足不了，假如我们需要一个按照插入顺序来排列的键值对集合，那 HashMap 就无能为力了。那该怎么办呢？必须得上今天这篇文章的主角：LinkedHashMap。</p>
<p>同学们好啊，还记得 HashMap 那篇吗？我自己感觉写得非常棒啊，既通俗易懂，又深入源码，真的是分析得透透彻彻、清清楚楚、明明白白的。（一不小心又甩了三个成语，有文化吧？）HashMap 哪哪都好，真的，只要你想用键值对，第一时间就应该想到它。</p>
<p>为了提高查找效率，HashMap 在插入的时候对键做了一次哈希算法，这就导致插入的元素是无序的。</p>
<p>对这一点还不太明白的同学，可以再回到 HashMap 那一篇，看看 hash 方法，再看看我对 put() 方法的讲解，就能明白了，我们这里再来回顾一下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">               boolean evict) &#123;</span><br><span class="line">    HashMap.Node&lt;K,V&gt;[] tab; HashMap.Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">    // ①、数组 table 为 null 时，调用 resize 方法创建默认大小的数组</span><br><span class="line">    if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    // ②、计算下标，如果该位置上没有值，则填充</span><br><span class="line">    if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">        tab[i] = newNode(hash, key, value, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中这个公式 i = (n - 1) &amp; hash 计算后的值就是键位在数组（桶）中的索引（下标/位置），但这它并不是按照 0、1、2、3、4、5 这样有序的下标将键值对插入到数组当中的，而是有一定的随机性。</p>
<p>比如说默认大小为 16 的 HashMap，如果 put 了 4 个键值对，可能下标是 0、4、9、11，那这样的话，在遍历 HashMap 的时候，就不一定能按照插入顺序来了。</p>
<p>看下面的例子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 创建 HashMap 对象，键类型为 String，值类型为 String</span><br><span class="line">Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">// 使用 put() 方法向 HashMap 中添加数据</span><br><span class="line">map.put(&quot;chenmo&quot;, &quot;沉默&quot;);</span><br><span class="line">map.put(&quot;wanger&quot;, &quot;王二&quot;);</span><br><span class="line">map.put(&quot;chenqingyang&quot;, &quot;陈清扬&quot;);</span><br><span class="line">// 遍历 HashMap，输出所有键值对</span><br><span class="line">for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    String key = entry.getKey();</span><br><span class="line">    String value = entry.getValue();</span><br><span class="line">    System.out.println(&quot;Key: &quot; + key + &quot;, Value: &quot; + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看输出结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Key: chenmo, Value: 沉默</span><br><span class="line">Key: chenqingyang, Value: 陈清扬</span><br><span class="line">Key: wanger, Value: 王二</span><br></pre></td></tr></table></figure>
<p>对比一下输出结果就可以看得出来，put 的时候是 沉默、王二、陈清扬的顺序，但遍历的时候就没有按照这个顺序来：沉默、陈清扬、王二，因为 HashMap 是无序的。</p>
<p>那怎么保证键值对的插入顺序呢？</p>
<p>LinkedHashMap 就是为这个需求应运而生的。LinkedHashMap 继承了 HashMap，所以 HashMap 有的关于键值对的功能，它也有了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedHashMap&lt;K,V&gt;</span><br><span class="line">    extends HashMap&lt;K,V&gt;</span><br><span class="line">    implements Map&lt;K,V&gt;&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>在此基础上，LinkedHashMap 内部追加了双向链表，来维护元素的插入顺序。注意下面代码中的 before 和 after，它俩就是用来维护当前元素的前一个元素和后一个元素的顺序的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        super(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于双向链表，同学们可以回头看一遍我写的 LinkedList 那篇文章，会对理解本篇的 LinkedHashMap 有很大的帮助。</p>
<p>用 LinkedHashMap 替换 HashMap，再来对比一下输出结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 创建 LinkedHashMap 对象，键类型为 String，值类型为 String</span><br><span class="line">Map&lt;String, String&gt; map = new LinkedHashMap&lt;&gt;();</span><br><span class="line">// 使用 put() 方法向 LinkedHashMap 中添加数据</span><br><span class="line">map.put(&quot;chenmo&quot;, &quot;沉默&quot;);</span><br><span class="line">map.put(&quot;wanger&quot;, &quot;王二&quot;);</span><br><span class="line">map.put(&quot;chenqingyang&quot;, &quot;陈清扬&quot;);</span><br><span class="line">// 遍历 LinkedHashMap，输出所有键值对</span><br><span class="line">for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    String key = entry.getKey();</span><br><span class="line">    String value = entry.getValue();</span><br><span class="line">    System.out.println(&quot;Key: &quot; + key + &quot;, Value: &quot; + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Key: chenmo, Value: 沉默</span><br><span class="line">Key: wanger, Value: 王二</span><br><span class="line">Key: chenqingyang, Value: 陈清扬</span><br></pre></td></tr></table></figure>
<p>看，LinkedHashMap 是不是保持了插入顺序？这就对了。</p>
<p><strong>01、插入顺序 </strong></p>
<p>在 HashMap 那篇文章里，我有讲解到一点，不知道同学们记不记得，就是 null 会插入到 HashMap 的第一位。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line">hashMap.put(&quot;沉&quot;, &quot;沉默王二&quot;);</span><br><span class="line">hashMap.put(&quot;默&quot;, &quot;沉默王二&quot;);</span><br><span class="line">hashMap.put(&quot;王&quot;, &quot;沉默王二&quot;);</span><br><span class="line">hashMap.put(&quot;二&quot;, &quot;沉默王二&quot;);</span><br><span class="line">hashMap.put(null, null);</span><br><span class="line">for (String key : hashMap.keySet()) &#123;</span><br><span class="line">    System.out.println(key + &quot; : &quot; + hashMap.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出的结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">null : null</span><br><span class="line">默 : 沉默王二</span><br><span class="line">沉 : 沉默王二</span><br><span class="line">王 : 沉默王二</span><br><span class="line">二 : 沉默王二</span><br></pre></td></tr></table></figure>
<p>虽然 null 最后一位 put 进去的，但在遍历输出的时候，跑到了第一位。</p>
<p>那再来对比看一下 LinkedHashMap。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; linkedHashMap = new LinkedHashMap&lt;&gt;();</span><br><span class="line">linkedHashMap.put(&quot;沉&quot;, &quot;沉默王二&quot;);</span><br><span class="line">linkedHashMap.put(&quot;默&quot;, &quot;沉默王二&quot;);</span><br><span class="line">linkedHashMap.put(&quot;王&quot;, &quot;沉默王二&quot;);</span><br><span class="line">linkedHashMap.put(&quot;二&quot;, &quot;沉默王二&quot;);</span><br><span class="line">linkedHashMap.put(null, null);</span><br><span class="line">for (String key : linkedHashMap.keySet()) &#123;</span><br><span class="line">    System.out.println(key + &quot; : &quot; + linkedHashMap.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">沉 : 沉默王二</span><br><span class="line">默 : 沉默王二</span><br><span class="line">王 : 沉默王二</span><br><span class="line">二 : 沉默王二</span><br><span class="line">null : null</span><br></pre></td></tr></table></figure>
<p>null 在最后一位插入，在最后一位输出。</p>
<p>输出结果可以再次证明，<strong>HashMap 是无序的，LinkedHashMap 是可以维持插入顺序的。</strong></p>
<p>那 LinkedHashMap 是如何做到这一点呢？我相信同学们和我一样，非常希望知道原因。</p>
<p>要想搞清楚，就需要深入研究一下 LinkedHashMap 的源码。LinkedHashMap 并未重写 HashMap 的 put() 方法，而是重写了 put() 方法需要调用的内部方法 newNode() 。</p>
<p>这是 HashMap 的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">    return new Node&lt;&gt;(hash, key, value, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是 LinkedHashMap 的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HashMap.Node&lt;K,V&gt; newNode(int hash, K key, V value, HashMap.Node&lt;K,V&gt; e) &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            new LinkedHashMap.Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面曾提到 LinkedHashMap.Entry 继承了 HashMap.Node，并且追加了两个字段 before 和 after，用来维持键值对的关系。</p>
<p>在 LinkedHashMap 中，链表中的节点顺序是按照插入顺序维护的。当使用 put() 方法向 LinkedHashMap 中添加键值对时，会将新节点插入到链表的尾部，并更新 before 和 after 属性，以保证链表的顺序关系——由 linkNodeLast() 方法来完成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 将指定节点插入到链表的尾部</span><br><span class="line"> *</span><br><span class="line"> * @param p 要插入的节点</span><br><span class="line"> */</span><br><span class="line">private void linkNodeLast(LinkedHashMap.Entry&lt;K,V&gt; p) &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail; // 获取链表的尾节点</span><br><span class="line">    tail = p; // 将 p 设为尾节点</span><br><span class="line">    if (last == null)</span><br><span class="line">        head = p; // 如果链表为空，则将 p 设为头节点</span><br><span class="line">    else &#123;</span><br><span class="line">        p.before = last; // 将 p 的前驱节点设为链表的尾节点</span><br><span class="line">        last.after = p; // 将链表的尾节点的后继节点设为 p</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到了吧，LinkedHashMap 在添加第一个元素的时候，会把 head 赋值为第一个元素，等到第二个元素添加进来的时候，会把第二个元素的 before 赋值为第一个元素，第一个元素的 afer 赋值为第二个元素。</p>
<p>这就保证了键值对是按照插入顺序排列的，明白了吧？</p>
<p><strong>02、访问顺序 </strong></p>
<p>LinkedHashMap 不仅能够维持插入顺序，还能够维持访问顺序。访问包括调用 get() 方法、 remove() 方法和 put() 方法。</p>
<p>要维护访问顺序，需要我们在声明 LinkedHashMap 的时候指定三个参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LinkedHashMap&lt;String, String&gt; map = new LinkedHashMap&lt;&gt;(16, .75f, true);</span><br></pre></td></tr></table></figure>
<p>第一个参数和第二个参数，看过 HashMap 的同学们应该很熟悉了，指的是初始容量和负载因子。</p>
<p>第三个参数如果为 true 的话，就表示 LinkedHashMap 要维护访问顺序；否则，维护插入顺序。默认是 false。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; linkedHashMap = new LinkedHashMap&lt;&gt;(16, .75f, true);</span><br><span class="line">linkedHashMap.put(&quot;沉&quot;, &quot;沉默王二&quot;);</span><br><span class="line">linkedHashMap.put(&quot;默&quot;, &quot;沉默王二&quot;);</span><br><span class="line">linkedHashMap.put(&quot;王&quot;, &quot;沉默王二&quot;);</span><br><span class="line">linkedHashMap.put(&quot;二&quot;, &quot;沉默王二&quot;);</span><br><span class="line">System.out.println(linkedHashMap);</span><br><span class="line">linkedHashMap.get(&quot;默&quot;);</span><br><span class="line">System.out.println(linkedHashMap);</span><br><span class="line">linkedHashMap.get(&quot;王&quot;);</span><br><span class="line">System.out.println(linkedHashMap);</span><br></pre></td></tr></table></figure>
<p>输出的结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;沉=沉默王二, 默=沉默王二, 王=沉默王二, 二=沉默王二&#125;</span><br><span class="line">&#123;沉=沉默王二, 王=沉默王二, 二=沉默王二, 默=沉默王二&#125;</span><br><span class="line">&#123;沉=沉默王二, 二=沉默王二, 默=沉默王二, 王=沉默王二&#125;</span><br></pre></td></tr></table></figure>
<p>当我们使用 get() 方法访问键位“默”的元素后，输出结果中，默=沉默王二 在最后；当我们访问键位“王”的元素后，输出结果中，王=沉默王二 在最后，默=沉默王二 在倒数第二位。</p>
<p>也就是说，最不经常访问的放在头部，这就有意思了。有意思在哪呢？</p>
<p>我们可以使用 LinkedHashMap 来实现 LRU 缓存，LRU 是 Least Recently Used 的缩写，即最近最少使用，是一种常用的页面置换算法，选择最近最久未使用的页面予以淘汰。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 自定义的 MyLinkedHashMap 类，继承了 Java 中内置的 LinkedHashMap&lt;K, V&gt; 类。</span><br><span class="line"> * 用于实现一个具有固定大小的缓存，当缓存达到最大容量时，会自动移除最早加入的元素，以腾出空间给新的元素。</span><br><span class="line"> *</span><br><span class="line"> * @param &lt;K&gt; 键的类型</span><br><span class="line"> * @param &lt;V&gt; 值的类型</span><br><span class="line"> */</span><br><span class="line">public class MyLinkedHashMap&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; &#123;</span><br><span class="line">    private static final int MAX_ENTRIES = 5; // 表示 MyLinkedHashMap 中最多存储的键值对数量</span><br><span class="line">    /**</span><br><span class="line">     * 构造方法，使用 super() 调用了父类的构造函数，并传递了三个参数：initialCapacity、loadFactor 和 accessOrder。</span><br><span class="line">     *</span><br><span class="line">     * @param initialCapacity 初始容量</span><br><span class="line">     * @param loadFactor      负载因子</span><br><span class="line">     * @param accessOrder     访问顺序</span><br><span class="line">     */</span><br><span class="line">    public MyLinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) &#123;</span><br><span class="line">        super(initialCapacity, loadFactor, accessOrder);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 重写父类的 removeEldestEntry() 方法，用于指示是否应该移除最早加入的元素。</span><br><span class="line">     * 如果返回 true，那么将删除最早加入的元素。</span><br><span class="line">     *</span><br><span class="line">     * @param eldest 最早加入的元素</span><br><span class="line">     * @return 如果当前 MyLinkedHashMap 中元素的数量大于 MAX_ENTRIES，返回 true，否则返回 false。</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected boolean removeEldestEntry(Map.Entry eldest) &#123;</span><br><span class="line">        return size() &gt; MAX_ENTRIES;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MyLinkedHashMap 是一个自定义类，它继承了 LinkedHashMap，并且重写了 removeEldestEntry() 方<br>法——使 Map 最多可容纳 5 个元素，超出后就淘汰。</p>
<p>我们来测试一下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MyLinkedHashMap&lt;String,String&gt; map = new MyLinkedHashMap&lt;&gt;(16,0.75f,true);</span><br><span class="line">map.put(&quot;沉&quot;, &quot;沉默王二&quot;);</span><br><span class="line">map.put(&quot;默&quot;, &quot;沉默王二&quot;);</span><br><span class="line">map.put(&quot;王&quot;, &quot;沉默王二&quot;);</span><br><span class="line">map.put(&quot;二&quot;, &quot;沉默王二&quot;);</span><br><span class="line">map.put(&quot;一枚有趣的程序员&quot;, &quot;一枚有趣的程序员&quot;);</span><br><span class="line">System.out.println(map);</span><br><span class="line">map.put(&quot;一枚有颜值的程序员&quot;, &quot;一枚有颜值的程序员&quot;);</span><br><span class="line">System.out.println(map);</span><br><span class="line">map.put(&quot;一枚有才华的程序员&quot;,&quot;一枚有才华的程序员&quot;);</span><br><span class="line">System.out.println(map);</span><br></pre></td></tr></table></figure>
<p>输出结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;沉=沉默王二, 默=沉默王二, 王=沉默王二, 二=沉默王二, 一枚有趣的程序员=一枚有趣的程序员&#125;</span><br><span class="line">&#123;默=沉默王二, 王=沉默王二, 二=沉默王二, 一枚有趣的程序员=一枚有趣的程序员, 一枚有颜值的程序员=一枚</span><br><span class="line">有颜值的程序员&#125;</span><br><span class="line">&#123;王=沉默王二, 二=沉默王二, 一枚有趣的程序员=一枚有趣的程序员, 一枚有颜值的程序员=一枚有颜值的程序</span><br><span class="line">员, 一枚有才华的程序员=一枚有才华的程序员&#125;</span><br></pre></td></tr></table></figure>
<p>沉=沉默王二 和 默=沉默王二 依次被淘汰出局。</p>
<p>假如在 put “一枚有才华的程序员”之前 get 了键位为“默”的元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">MyLinkedHashMap&lt;String,String&gt; map = new MyLinkedHashMap&lt;&gt;(16,0.75f,true);</span><br><span class="line">map.put(&quot;沉&quot;, &quot;沉默王二&quot;);</span><br><span class="line">map.put(&quot;默&quot;, &quot;沉默王二&quot;);</span><br><span class="line">map.put(&quot;王&quot;, &quot;沉默王二&quot;);</span><br><span class="line">map.put(&quot;二&quot;, &quot;沉默王二&quot;);</span><br><span class="line">map.put(&quot;一枚有趣的程序员&quot;, &quot;一枚有趣的程序员&quot;);</span><br><span class="line">System.out.println(map);</span><br><span class="line">map.put(&quot;一枚有颜值的程序员&quot;, &quot;一枚有颜值的程序员&quot;);</span><br><span class="line">System.out.println(map);</span><br><span class="line">map.get(&quot;默&quot;);</span><br><span class="line">map.put(&quot;一枚有才华的程序员&quot;,&quot;一枚有才华的程序员&quot;);</span><br><span class="line">System.out.println(map);</span><br></pre></td></tr></table></figure>
<p>那输出结果就变了，对吧？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;沉=沉默王二, 默=沉默王二, 王=沉默王二, 二=沉默王二, 一枚有趣的程序员=一枚有趣的程序员&#125;</span><br><span class="line">&#123;默=沉默王二, 王=沉默王二, 二=沉默王二, 一枚有趣的程序员=一枚有趣的程序员, 一枚有颜值的程序员=一枚</span><br><span class="line">有颜值的程序员&#125;</span><br><span class="line">&#123;二=沉默王二, 一枚有趣的程序员=一枚有趣的程序员, 一枚有颜值的程序员=一枚有颜值的程序员, 默=沉默王</span><br><span class="line">二, 一枚有才华的程序员=一枚有才华的程序员&#125;</span><br></pre></td></tr></table></figure>
<p>沉=沉默王二 和 王=沉默王二 被淘汰出局了。</p>
<p>那 LinkedHashMap 是如何来维持访问顺序呢？同学们感兴趣的话，可以研究一下下面这三个方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void afterNodeAccess(Node&lt;K,V&gt; p) &#123; &#125;</span><br><span class="line">void afterNodeInsertion(boolean evict) &#123; &#125;</span><br><span class="line">void afterNodeRemoval(Node&lt;K,V&gt; p) &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>afterNodeAccess() 会在调用 get() 方法的时候被调用， afterNodeInsertion() 会在调用 put() 方法的时候被调用， afterNodeRemoval() 会在调用 remove() 方法的时候被调用。</p>
<p>我来以 afterNodeAccess() 为例来讲解一下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 在访问节点后，将节点移动到链表的尾部</span><br><span class="line"> *</span><br><span class="line"> * @param e 要移动的节点</span><br><span class="line"> */</span><br><span class="line">void afterNodeAccess(HashMap.Node&lt;K,V&gt; e) &#123; // move node to last</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    if (accessOrder &amp;&amp; (last = tail) != e) &#123; // 如果按访问顺序排序，并且访问的节点不是尾节点</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = </span><br><span class="line">p.after;</span><br><span class="line">        p.after = null; // 将要移动的节点的后继节点设为 null</span><br><span class="line">        if (b == null)</span><br><span class="line">            head = a; // 如果要移动的节点没有前驱节点，则将要移动的节点设为头节点</span><br><span class="line">        else</span><br><span class="line">            b.after = a; // 将要移动的节点的前驱节点的后继节点设为要移动的节点的后继节点</span><br><span class="line">        if (a != null)</span><br><span class="line">            a.before = b; // 如果要移动的节点有后继节点，则将要移动的节点的后继节点的前驱节点设</span><br><span class="line">为要移动的节点的前驱节点</span><br><span class="line">        else</span><br><span class="line">            last = b; // 如果要移动的节点没有后继节点，则将要移动的节点的前驱节点设为尾节点</span><br><span class="line">        if (last == null)</span><br><span class="line">            head = p; // 如果尾节点为空，则将要移动的节点设为头节点</span><br><span class="line">        else &#123;</span><br><span class="line">            p.before = last; // 将要移动的节点的前驱节点设为尾节点</span><br><span class="line">            last.after = p; // 将尾节点的后继节点设为要移动的节点</span><br><span class="line">        &#125;</span><br><span class="line">        tail = p; // 将要移动的节点设为尾节点</span><br><span class="line">        ++modCount; // 修改计数器</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>哪个元素被 get 就把哪个元素放在最后。了解了吧？</p>
<p>那同学们可能还想知道，为什么 LinkedHashMap 能实现 LRU 缓存，把最不经常访问的那个元素淘汰？</p>
<p>在插入元素的时候，需要调用 put() 方法，该方法最后会调用 afterNodeInsertion() 方法，这个方法被 LinkedHashMap 重写了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 在插入节点后，如果需要，可能会删除最早加入的元素</span><br><span class="line"> *</span><br><span class="line"> * @param evict 是否需要删除最早加入的元素</span><br><span class="line"> */</span><br><span class="line">void afterNodeInsertion(boolean evict) &#123; // possibly remove eldest</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) &#123; // 如果需要删除</span><br><span class="line">最早加入的元素</span><br><span class="line">        K key = first.key; // 获取要删除元素的键</span><br><span class="line">        removeNode(hash(key), key, null, false, true); // 调用 removeNode() 方法删除元</span><br><span class="line">素</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>removeEldestEntry() 方法会判断第一个元素是否超出了可容纳的最大范围，如果超出，那就会调用 removeNode() 方法对最不经常访问的那个元素进行删除。</p>
<p><strong>03、小结 </strong></p>
<p>由于 LinkedHashMap 要维护双向链表，所以 LinkedHashMap 在插入、删除操作的时候，花费的时间要比 HashMap 多一些。</p>
<p>这也是没办法的事，对吧，欲戴皇冠必承其重嘛。既然想要维护元素的顺序，总要付出点代价才行。</p>
<p>简单总结一下吧。</p>
<p>首先，我们知道 HashMap 是一种常用的哈希表数据结构，它可以快速地进行键值对的查找和插入操作。但是，HashMap 本身并不保证键值对的顺序，如果我们需要按照插入顺序或访问顺序来遍历键值对，就需要使用 LinkedHashMap 了。</p>
<p>LinkedHashMap 继承自 HashMap，它在 HashMap 的基础上，增加了一个双向链表来维护键值对的顺序。这个链表可以按照插入顺序或访问顺序排序，它的头节点表示最早插入或访问的元素，尾节点表示最晚插入或访问的元素。这个链表的作用就是让 LinkedHashMap 可以保持键值对的顺序，并且可以按照顺序遍历键值对。</p>
<p>LinkedHashMap 还提供了两个构造方法来指定排序方式，分别是按照插入顺序排序和按照访问顺序排序。在按照访问顺序排序的情况下，每次访问一个键值对，都会将该键值对移到链表的尾部，以保证最近访问的元素在最后面。如果需要删除最早加入的元素，可以通过重写 removeEldestEntry() 方法来实现。</p>
<p>总之，LinkedHashMap 通过维护一个双向链表来保持键值对的顺序，可以按照插入顺序或访问顺序来遍历键值对。如果你需要按照顺序来遍历键值对，那么 LinkedHashMap 就是你的不二选择了！</p>
<h2 id="4-11-TreeMap详解（附源码）"><a href="#4-11-TreeMap详解（附源码）" class="headerlink" title="4.11 TreeMap详解（附源码）"></a>4.11 TreeMap详解（附源码）</h2><p>下面有请王老师上台，来给大家讲一讲 TreeMap，鼓掌了！</p>
<p>之前 LinkedHashMap 那篇文章里提到过了，HashMap 是无序的，所以有了 LinkedHashMap，加上了双向链表后，就可以保持元素的插入顺序和访问顺序，那 TreeMap 呢？</p>
<p>TreeMap 由红黑树实现，可以保持元素的自然顺序，或者实现了 Comparator 接口的自定义顺序。</p>
<p>可能有些同学不了解红黑树，我这里来普及一下：</p>
<blockquote>
<p>红黑树（英语：Red–black tree）是一种自平衡的二叉查找树（Binary Search Tree），结构复杂，但却有着良好的性能，完成查找、插入和删除的时间复杂度均为 log(n)。</p>
</blockquote>
<p>二叉查找树是一种常见的树形结构，它的每个节点都包含一个键值对。每个节点的左子树节点的键值小于该节点的键值，右子树节点的键值大于该节点的键值，这个特性使得二叉查找树非常适合进行数据的查找和排序操作。</p>
<p>下面是一个简单的手绘图，展示了一个二叉查找树的结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     8</span><br><span class="line">   /   \</span><br><span class="line">  3     10</span><br><span class="line"> / \      \</span><br><span class="line">1   6     14</span><br><span class="line">   / \    /</span><br><span class="line">  4   7  13</span><br></pre></td></tr></table></figure>
<p>在上面这个二叉查找树中，根节点是 8，左子树节点包括 3、1、6、4 和 7，右子树节点包括 10、14 和 13。</p>
<ul>
<li>3&lt;8&lt;10</li>
<li>1&lt;3&lt;6</li>
<li>4&lt;6&lt;7</li>
<li>10&lt;14</li>
<li>13&lt;14</li>
</ul>
<p>这是一颗典型的二叉查找树：</p>
<p>1）左子树上所有节点的值均小于或等于它的根结点的值。</p>
<p>2）右子树上所有节点的值均大于或等于它的根结点的值。</p>
<p>3）左、右子树也分别为二叉查找树。</p>
<p>二叉查找树用来查找非常方面，从根节点开始遍历，如果当前节点的键值等于要查找的键值，则查找成功；如果要查找的键值小于当前节点的键值，则继续遍历左子树；如果要查找的键值大于当前节点的键值，则继续遍历右子树。如果遍历到叶子节点仍然没有找到，则查找失败。</p>
<p>插入操作也非常简单，从根节点开始遍历，如果要插入的键值小于当前节点的键值，则将其插入到左子树中；如果要插入的键值大于当前节点的键值，则将其插入到右子树中。如果要插入的键值已经存在于树中，则更新该节点的值。</p>
<p>删除操作稍微复杂一些，需要考虑多种情况，包括要删除的节点是叶子节点、要删除的节点只有一个子节点、要删除的节点有两个子节点等等。</p>
<p>总之，二叉查找树是一种非常常用的数据结构，它可以帮助我们实现数据的查找、排序和删除等操作。</p>
<p>理解二叉查找树了吧？</p>
<p>不过，二叉查找树有一个明显的不足，就是容易变成瘸子，就是一侧多，一侧少，比如说这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">       6</span><br><span class="line">     /   \</span><br><span class="line">    4     8</span><br><span class="line">   /     / \</span><br><span class="line">  3     7   9</span><br><span class="line"> /</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>在上面这个不平衡的二叉查找树中，左子树比右子树高。根节点是 6，左子树节点包括 4、3 和 1，右子树节点包括 8、7 和 9。</p>
<p>由于左子树比右子树高，这个不平衡的二叉查找树可能会导致查找、插入和删除操作的效率下降。</p>
<p>来一个更极端的情况。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line">   \</span><br><span class="line">    3</span><br><span class="line">     \</span><br><span class="line">      4</span><br><span class="line">       \</span><br><span class="line">        5</span><br><span class="line">         \</span><br><span class="line">          6</span><br></pre></td></tr></table></figure>
<p>在上面这个极度不平衡的二叉查找树中，所有节点都只有一个右子节点，根节点是 1，右子树节点包括 2、3、4、5 和 6。</p>
<p>这种极度不平衡的二叉查找树会导致查找、插入和删除操作的效率急剧下降，因为每次操作都只能在右子树中进行，而左子树几乎没有被利用到。</p>
<p>查找的效率就要从 log(n) 变成 o(n) 了（戳这里了解时间复杂度），对吧？</p>
<p>必须要平衡一下，对吧？于是就有了平衡二叉树，左右两个子树的高度差的绝对值不超过 1，就像下图这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     8</span><br><span class="line">   /   \</span><br><span class="line">  4     12</span><br><span class="line"> / \    / \</span><br><span class="line">2   6  10  14</span><br><span class="line">   / \    / \</span><br><span class="line">  5   7  13  15</span><br></pre></td></tr></table></figure>
<p>根节点是 8，左子树节点包括 4、2、6、5 和 7，右子树节点包括 12、10、14、13 和 15。左子树和右子树的高度差不超过1，因此它是一个平衡二叉查找树。</p>
<p>平衡二叉树就像是一棵树形秤，它的左右两边的重量要尽可能的平衡。当我们往平衡二叉树中插入一个节点时，平衡二叉树会自动调整节点的位置，以保证树的左右两边的高度差不超过1。类似地，当我们删除一个节点时，平衡二叉树也会自动调整节点的位置，以保证树的左右两边的高度差不超过1。</p>
<p>常见的平衡二叉树包括AVL树、红黑树等等，它们都是通过旋转操作来调整树的平衡，使得左子树和右子树的高度尽可能接近。</p>
<p>AVL树的示意图：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     8</span><br><span class="line">   /   \</span><br><span class="line">  4     12</span><br><span class="line"> / \   /  \</span><br><span class="line">2   6 10  14</span><br><span class="line">   / \</span><br><span class="line">  5   7</span><br></pre></td></tr></table></figure>
<p>AVL树是一种高度平衡的二叉查找树，它要求左子树和右子树的高度差不超过1。由于AVL树的平衡度比较高，因此在进行插入和删除操作时需要进行更多的旋转操作来保持平衡，但是在查找操作时效率较高。AVL树适用于读操作比较多的场景。</p>
<p>例如，对于一个需要频繁进行查找操作的场景，如字典树、哈希表等数据结构，可以使用AVL树来进行优化。另外，AVL树也适用于需要保证数据有序性的场景，如数据库中的索引。</p>
<p>AVL树最初由两位苏联的计算机科学家，Adelson-Velskii和Landis，于1962年提出。因此，AVL树就以他们两人名字的首字母缩写命名了。</p>
<p>AVL树的发明对计算机科学的发展有着重要的影响，不仅为后来的平衡二叉树提供了基础，而且为其他领域的数据结构和算法提供了启示。</p>
<p>红黑树的示意图（R 即 Red「红」、B 即 Black「黑」）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     8B</span><br><span class="line">   /   \</span><br><span class="line">  4R    12R</span><br><span class="line"> / \   /  \</span><br><span class="line">2B 6B 10B 14B</span><br><span class="line">   / \</span><br><span class="line">  5R 7R</span><br></pre></td></tr></table></figure>
<p>红黑树，顾名思义，就是节点是红色或者黑色的平衡二叉树，它通过颜色的约束来维持二叉树的平衡，它要求任意一条路径上的黑色节点数目相同，同时还需要满足一些其他特定的条件，如红色节点的父节点必须为黑色节点等。</p>
<p>1）每个节点都只能是红色或者黑色</p>
<p>2）根节点是黑色</p>
<p>3）每个叶节点（NIL 节点，空节点）是黑色的。</p>
<p>4）如果一个节点是红色的，则它两个子节点都是黑色的。也就是说在一条路径上不能出现相邻的两个红色节点。</p>
<p>5）从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</p>
<p>由于红黑树的平衡度比AVL树稍低，因此在进行插入和删除操作时需要进行的旋转操作较少，但是在查找操作时效率仍然较高。红黑树适用于读写操作比较均衡的场景。</p>
<p>那，关于红黑树，同学们就先了解到这，脑子里有个大概的印象，知道 TreeMap 是个什么玩意。</p>
<p><strong>01、自然顺序 </strong></p>
<p>默认情况下，TreeMap 是根据 key 的自然顺序排列的。比如说整数，就是升序，1、2、3、4、5。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TreeMap&lt;Integer,String&gt; mapInt = new TreeMap&lt;&gt;();</span><br><span class="line">mapInt.put(3, &quot;沉默王二&quot;);</span><br><span class="line">mapInt.put(2, &quot;沉默王二&quot;);</span><br><span class="line">mapInt.put(1, &quot;沉默王二&quot;);</span><br><span class="line">mapInt.put(5, &quot;沉默王二&quot;);</span><br><span class="line">mapInt.put(4, &quot;沉默王二&quot;);</span><br><span class="line">System.out.println(mapInt);</span><br></pre></td></tr></table></figure>
<p>输出结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;1=沉默王二, 2=沉默王二, 3=沉默王二, 4=沉默王二, 5=沉默王二&#125;</span><br></pre></td></tr></table></figure>
<p>TreeMap 是怎么做到的呢？想一探究竟，就得上源码了，来看 TreeMap 的 put() 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    Entry&lt;K,V&gt; t = root; // 将根节点赋值给变量t</span><br><span class="line">    if (t == null) &#123; // 如果根节点为null，说明TreeMap为空</span><br><span class="line">        compare(key, key); // type (and possibly null) check，检查key的类型是否合法</span><br><span class="line">        root = new Entry&lt;&gt;(key, value, null); // 创建一个新节点作为根节点</span><br><span class="line">        size = 1; // size设置为1</span><br><span class="line">        return null; // 返回null，表示插入成功</span><br><span class="line">    &#125;</span><br><span class="line">    int cmp;</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    // split comparator and comparable paths，根据使用的比较方法进行查找</span><br><span class="line">    Comparator&lt;? super K&gt; cpr = comparator; // 获取比较器</span><br><span class="line">    if (cpr != null) &#123; // 如果使用了Comparator</span><br><span class="line">        do &#123;</span><br><span class="line">            parent = t; // 将当前节点赋值给parent</span><br><span class="line">            cmp = cpr.compare(key, t.key); // 使用Comparator比较key和t的键的大小</span><br><span class="line">            if (cmp &lt; 0) // 如果key小于t的键</span><br><span class="line">                t = t.left; // 在t的左子树中查找</span><br><span class="line">            else if (cmp &gt; 0) // 如果key大于t的键</span><br><span class="line">                t = t.right; // 在t的右子树中查找</span><br><span class="line">            else // 如果key等于t的键</span><br><span class="line">                return t.setValue(value); // 直接更新t的值</span><br><span class="line">        &#125; while (t != null);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123; // 如果没有使用Comparator</span><br><span class="line">        if (key == null) // 如果key为null</span><br><span class="line">            throw new NullPointerException(); // 抛出NullPointerException异常</span><br><span class="line">            Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; // 将key强制转换为Comparable类型</span><br><span class="line">        do &#123;</span><br><span class="line">            parent = t; // 将当前节点赋值给parent</span><br><span class="line">            cmp = k.compareTo(t.key); // 使用Comparable比较key和t的键的大小</span><br><span class="line">            if (cmp &lt; 0) // 如果key小于t的键</span><br><span class="line">                t = t.left; // 在t的左子树中查找</span><br><span class="line">            else if (cmp &gt; 0) // 如果key大于t的键</span><br><span class="line">                t = t.right; // 在t的右子树中查找</span><br><span class="line">            else // 如果key等于t的键</span><br><span class="line">                return t.setValue(value); // 直接更新t的值</span><br><span class="line">        &#125; while (t != null);</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果没有找到相同的键，需要创建一个新节点插入到TreeMap中</span><br><span class="line">    Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent); // 创建一个新节点</span><br><span class="line">    if (cmp &lt; 0) // 如果key小于parent的键</span><br><span class="line">        parent.left = e; // 将e作为parent的左子节点</span><br><span class="line">    else</span><br><span class="line">        parent.right = e; // 将e作为parent的右子节点</span><br><span class="line">    fixAfterInsertion(e); // 插入节点后需要进行平衡操作</span><br><span class="line">    size++; // size加1</span><br><span class="line">    return null; // 返回null，表示插入成功</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>首先定义一个Entry类型的变量t，用于表示当前的根节点；</li>
<li>如果t为null，说明TreeMap为空，直接创建一个新的节点作为根节点，并将size设置为1；</li>
<li>如果t不为null，说明需要在TreeMap中查找键所对应的节点。因为TreeMap中的元素是有序的，所以可以使用二分查找的方式来查找节点；</li>
<li>如果TreeMap中使用了Comparator来进行排序，则使用Comparator进行比较，否则使用Comparable进行比较。如果查找到了相同的键，则直接更新键所对应的值；</li>
<li>如果没有查找到相同的键，则创建一个新的节点，并将其插入到TreeMap中。然后使用fixAfterInsertion()方法来修正插入节点后的平衡状态；</li>
<li>最后将TreeMap的size加1，然后返回null。如果更新了键所对应的值，则返回原先的值。</li>
</ul>
<p>注意 cmp = k.compareTo(t.key) 这行代码，就是用来进行 key 比较的，由于此时 key 是 String，所以就会调用 String 类的compareTo() 方法进行比较。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public int compareTo(String anotherString) &#123;</span><br><span class="line">    // 获取当前字符串和另一个字符串的长度</span><br><span class="line">    int len1 = value.length;</span><br><span class="line">    int len2 = anotherString.value.length;</span><br><span class="line">    // 取两个字符串长度的较短者作为比较的上限</span><br><span class="line">    int lim = Math.min(len1, len2);</span><br><span class="line">    // 获取当前字符串和另一个字符串的字符数组</span><br><span class="line">    char v1[] = value;</span><br><span class="line">    char v2[] = anotherString.value;</span><br><span class="line">    int k = 0;</span><br><span class="line">    // 对两个字符串的每个字符进行比较</span><br><span class="line">    while (k &lt; lim) &#123;</span><br><span class="line">        char c1 = v1[k];</span><br><span class="line">        char c2 = v2[k];</span><br><span class="line">        // 如果两个字符不相等，返回它们的差值</span><br><span class="line">        if (c1 != c2) &#123;</span><br><span class="line">            return c1 - c2;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果两个字符串前面的字符都相等，返回它们长度的差值</span><br><span class="line">    return len1 - len2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看下面的示例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TreeMap&lt;String,String&gt; mapString = new TreeMap&lt;&gt;();</span><br><span class="line">mapString.put(&quot;c&quot;, &quot;沉默王二&quot;);</span><br><span class="line">mapString.put(&quot;b&quot;, &quot;沉默王二&quot;);</span><br><span class="line">mapString.put(&quot;a&quot;, &quot;沉默王二&quot;);</span><br><span class="line">mapString.put(&quot;e&quot;, &quot;沉默王二&quot;);</span><br><span class="line">mapString.put(&quot;d&quot;, &quot;沉默王二&quot;);</span><br><span class="line">System.out.println(mapString);</span><br></pre></td></tr></table></figure>
<p>输出结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;a=沉默王二, b=沉默王二, c=沉默王二, d=沉默王二, e=沉默王二&#125;</span><br></pre></td></tr></table></figure>
<p>从结果可以看得出，是按照字母的升序进行排序的。</p>
<p><strong>02、自定义排序 </strong></p>
<p>如果自然顺序不满足，那就可以在声明 TreeMap 对象的时候指定排序规则。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TreeMap&lt;Integer,String&gt; mapIntReverse = new TreeMap&lt;&gt;(Comparator.reverseOrder());</span><br><span class="line">mapIntReverse.put(3, &quot;沉默王二&quot;);</span><br><span class="line">mapIntReverse.put(2, &quot;沉默王二&quot;);</span><br><span class="line">mapIntReverse.put(1, &quot;沉默王二&quot;);</span><br><span class="line">mapIntReverse.put(5, &quot;沉默王二&quot;);</span><br><span class="line">mapIntReverse.put(4, &quot;沉默王二&quot;);</span><br><span class="line">System.out.println(mapIntReverse);</span><br></pre></td></tr></table></figure>
<p>TreeMap 提供了可以指定排序规则的构造方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public TreeMap(Comparator&lt;? super K&gt; comparator) &#123;</span><br><span class="line">    this.comparator = comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Comparator.reverseOrder() 返回的是 Collections.ReverseComparator 对象，就是用来反转顺序的，非常方便。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private static class ReverseComparator</span><br><span class="line">        implements Comparator&lt;Comparable&lt;Object&gt;&gt;, Serializable &#123;</span><br><span class="line">    // 单例模式，用于表示逆序比较器</span><br><span class="line">    static final ReverseComparator REVERSE_ORDER</span><br><span class="line">            = new ReverseComparator();</span><br><span class="line">    // 实现比较方法，对两个实现了Comparable接口的对象进行逆序比较</span><br><span class="line">    public int compare(Comparable&lt;Object&gt; c1, Comparable&lt;Object&gt; c2) &#123;</span><br><span class="line">        return c2.compareTo(c1); // 调用c2的compareTo()方法，以c1为参数，实现逆序比较</span><br><span class="line">    &#125;</span><br><span class="line">    // 反序列化时，返回Collections.reverseOrder()，保证单例模式</span><br><span class="line">    private Object readResolve() &#123;</span><br><span class="line">        return Collections.reverseOrder();</span><br><span class="line">    &#125;</span><br><span class="line">    // 返回正序比较器</span><br><span class="line">    @Override</span><br><span class="line">    public Comparator&lt;Comparable&lt;Object&gt;&gt; reversed() &#123;</span><br><span class="line">        return Comparator.naturalOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，输出结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;5=沉默王二, 4=沉默王二, 3=沉默王二, 2=沉默王二, 1=沉默王二&#125;</span><br></pre></td></tr></table></figure>
<p>HashMap 是无序的，插入的顺序随着元素的增加会不停地变动。但 TreeMap 能够至始至终按照指定的顺序排列，这对于需要自定义排序的场景，实在是太有用了！</p>
<p><strong>03、排序的好处 </strong></p>
<p>既然 TreeMap 的元素是经过排序的，那找出最大的那个，最小的那个，或者找出所有大于或者小于某个值的键来说，就方便多了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Integer highestKey = mapInt.lastKey();</span><br><span class="line">Integer lowestKey = mapInt.firstKey();</span><br><span class="line">Set&lt;Integer&gt; keysLessThan3 = mapInt.headMap(3).keySet();</span><br><span class="line">Set&lt;Integer&gt; keysGreaterThanEqTo3 = mapInt.tailMap(3).keySet();</span><br><span class="line">System.out.println(highestKey);</span><br><span class="line">System.out.println(lowestKey);</span><br><span class="line">System.out.println(keysLessThan3);</span><br><span class="line">System.out.println(keysGreaterThanEqTo3);</span><br></pre></td></tr></table></figure>
<p>TreeMap 考虑得很周全，恰好就提供了 lastKey() 、 firstKey() 这样获取最后一个 key 和第一个 key 的方法。</p>
<p>headMap() 获取的是到指定 key 之前的 key； tailMap() 获取的是指定 key 之后的 key（包括指定 key）。</p>
<p>来看一下输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1</span><br><span class="line">[1, 2]</span><br><span class="line">[3, 4, </span><br></pre></td></tr></table></figure>
<p>再来看一下例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">TreeMap&lt;Integer, String&gt; treeMap = new TreeMap&lt;&gt;();</span><br><span class="line">treeMap.put(1, &quot;value1&quot;);</span><br><span class="line">treeMap.put(2, &quot;value2&quot;);</span><br><span class="line">treeMap.put(3, &quot;value3&quot;);</span><br><span class="line">treeMap.put(4, &quot;value4&quot;);</span><br><span class="line">treeMap.put(5, &quot;value5&quot;);</span><br><span class="line">// headMap示例，获取小于3的键值对</span><br><span class="line">Map&lt;Integer, String&gt; headMap = treeMap.headMap(3);</span><br><span class="line">System.out.println(headMap); // 输出 &#123;1=value1, 2=value2&#125;</span><br><span class="line">// tailMap示例，获取大于等于4的键值对</span><br><span class="line">Map&lt;Integer, String&gt; tailMap = treeMap.tailMap(4);</span><br><span class="line">System.out.println(tailMap); // 输出 &#123;4=value4, 5=value5&#125;</span><br><span class="line">// subMap示例，获取大于等于2且小于4的键值对</span><br><span class="line">Map&lt;Integer, String&gt; subMap = treeMap.subMap(2, 4);</span><br><span class="line">System.out.println(subMap); // 输出 &#123;2=value2, 3=value3&#125;</span><br></pre></td></tr></table></figure>
<p>headMap、tailMap、subMap方法分别获取了小于3、大于等于4、大于等于2且小于4的键值对。</p>
<p><strong>04、如何选择 Map </strong></p>
<p>在学习 TreeMap 之前，我们已经学习了 HashMap 和 LinkedHashMap ，那如何从它们三个中间选择呢？</p>
<p>需要考虑以下因素：</p>
<ul>
<li>是否需要按照键的自然顺序或者自定义顺序进行排序。如果需要按照键排序，则可以使用 TreeMap；如果不需要排序，则可以使用 HashMap 或 LinkedHashMap。</li>
<li>是否需要保持插入顺序。如果需要保持插入顺序，则可以使用 LinkedHashMap；如果不需要保持插入顺序，则可以使用 TreeMap 或 HashMap。</li>
<li>是否需要高效的查找。如果需要高效的查找，则可以使用 LinkedHashMap 或 HashMap，因为它们的查找操作的时间复杂度为 O(1)，而是 TreeMap 是 O(log n)。</li>
<li>LinkedHashMap 内部使用哈希表来存储键值对，并使用一个双向链表来维护插入顺序，但查找操作只需要在哈希表中进行，与链表无关，所以时间复杂度为 O(1)</li>
</ul>
<p>来个表格吧，一目了然。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">特性</th>
<th style="text-align:center">TreeMap</th>
<th style="text-align:center">HashMap</th>
<th style="text-align:center">LinkedHashMap</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">排序</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">不支持</td>
<td style="text-align:center">不支持</td>
</tr>
<tr>
<td style="text-align:center">插入顺序</td>
<td style="text-align:center">不保证</td>
<td style="text-align:center">不保证</td>
<td style="text-align:center">保证</td>
</tr>
<tr>
<td style="text-align:center">查找效率</td>
<td style="text-align:center">O(log n)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">O(1)</td>
</tr>
<tr>
<td style="text-align:center">空间占用</td>
<td style="text-align:center">通常较大</td>
<td style="text-align:center">通常较小</td>
<td style="text-align:center">通常较大</td>
</tr>
<tr>
<td style="text-align:center">适用场景</td>
<td style="text-align:center">需要排序的场景</td>
<td style="text-align:center">无需排序的场景</td>
<td style="text-align:center">需要保持插入顺</td>
</tr>
</tbody>
</table>
</div>
<p>好了，下课，关于 TreeMap 我们就讲到这里吧，希望同学们都能对 TreeMap 有一个清晰的认识。我们下节课见~</p>
<h2 id="4-12-双端队列ArrayDeque详解"><a href="#4-12-双端队列ArrayDeque详解" class="headerlink" title="4.12 双端队列ArrayDeque详解"></a>4.12 双端队列ArrayDeque详解</h2><p>好，我们这节继续有请王老师上台来给大家讲 ArrayDeque，鼓掌欢迎了 。</p>
<p>Java 里有一个叫做Stack的类，却没有叫做Queue的类（它只是个接口名字，和类还不一样）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public interface Queue&lt;E&gt; extends Collection&lt;E&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>当需要使用栈时，Java 已不推荐使用Stack，而是推荐使用更高效的ArrayDeque（双端队列），原因我们第一次讲集合框架的时候，其实已经聊过了，Stack 是一个“原始”类，它的核心方法上都加了 synchronized 关键字以确保线程安全，当我们不需要线程安全（比如说单线程环境下）性能就会比较差。</p>
<p><img src="\assets\note\image-20231010160805462.png" alt="image-20231010160805462"></p>
<p>也就是说，当需要使用栈时候，请首选ArrayDeque。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 声明一个双端队列</span><br><span class="line">ArrayDeque&lt;String&gt; stack = new ArrayDeque&lt;&gt;();</span><br><span class="line">// 增加元素</span><br><span class="line">stack.push(&quot;沉默&quot;);</span><br><span class="line">stack.push(&quot;王二&quot;);</span><br><span class="line">stack.push(&quot;陈清扬&quot;);</span><br><span class="line">// 获取栈顶元素</span><br><span class="line">String top = stack.peek();</span><br><span class="line">System.out.println(&quot;栈顶元素为：&quot; + top); // 陈清扬</span><br><span class="line">// 弹出栈顶元素</span><br><span class="line">String pop = stack.pop();</span><br><span class="line">System.out.println(&quot;弹出的元素为：&quot; + pop); // 陈清扬</span><br><span class="line">// 修改栈顶元素</span><br><span class="line">stack.pop();</span><br><span class="line">stack.push(&quot;小明&quot;);</span><br><span class="line">System.out.println(&quot;修改后的栈为：&quot; + stack); // [沉默, 小明]</span><br><span class="line">// 遍历队列查找元素</span><br><span class="line">Iterator&lt;String&gt; iterator = stack.iterator();</span><br><span class="line">int index = -1;</span><br><span class="line">String target = &quot;王二&quot;;</span><br><span class="line">while (iterator.hasNext()) &#123;</span><br><span class="line">    String element = iterator.next();</span><br><span class="line">    index++;</span><br><span class="line">    if (element.equals(target)) &#123;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">if (index == -1) &#123;</span><br><span class="line">    System.out.println(&quot;元素 &quot; + target + &quot; 不存在于队列中&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    System.out.println(&quot;元素 &quot; + target + &quot; 在队列中的位置为：&quot; + index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们先创建了一个 ArrayDeque 对象，然后使用 push 方法向栈中添加了三个元素。接着使用 peek 方法获取栈顶元素，使用 pop 方法弹出栈顶元素，使用 pop 和 push 方法修改栈顶元素，使用迭代器查找元素在栈中的位置。</p>
<p>ArrayDeque 又实现了 Deque 接口（Deque 又实现了 Queue 接口）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayDeque&lt;E&gt; extends AbstractCollection&lt;E&gt;</span><br><span class="line">                           implements Deque&lt;E&gt;, Cloneable, Serializable</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>因此，当我们需要使用队列的时候，也可以选择 ArrayDeque。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ArrayDeque&lt;String&gt; queue = new ArrayDeque&lt;&gt;();</span><br><span class="line">// 增加元素</span><br><span class="line">queue.offer(&quot;沉默&quot;);</span><br><span class="line">queue.offer(&quot;王二&quot;);</span><br><span class="line">queue.offer(&quot;陈清扬&quot;);</span><br><span class="line">// 获取队首元素</span><br><span class="line">String front = queue.peek();</span><br><span class="line">System.out.println(&quot;队首元素为：&quot; + front); // 沉默</span><br><span class="line">// 弹出队首元素</span><br><span class="line">String poll = queue.poll();</span><br><span class="line">System.out.println(&quot;弹出的元素为：&quot; + poll); // 沉默</span><br><span class="line">// 修改队列中的元素</span><br><span class="line">queue.poll();</span><br><span class="line">queue.offer(&quot;小明&quot;);</span><br><span class="line">System.out.println(&quot;修改后的队列为：&quot; + queue); // [陈清扬, 小明]</span><br><span class="line">// 查找元素</span><br><span class="line">Iterator&lt;String&gt; iterator = queue.iterator();</span><br><span class="line">int index = 0;</span><br><span class="line">while (iterator.hasNext()) &#123;</span><br><span class="line">    String element = iterator.next();</span><br><span class="line">    if (element.equals(&quot;王二&quot;)) &#123;</span><br><span class="line">        System.out.println(&quot;元素在队列中的位置为：&quot; + index); // 0</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    index++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们先创建了一个 ArrayDeque 对象，然后使用 offer 方法向队列中添加了三个元素。接着使用 peek 方法获取队首元素，使用 poll 方法弹出队首元素，使用 poll 和 offer 方法修改队列中的元素，使用迭代器查找元素在队列中的位置。</p>
<p>我们前面讲了，LinkedList不只是个 List，还是一个 Queue，它也实现了 Deque 接口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedList&lt;E&gt;</span><br><span class="line">    extends AbstractSequentialList&lt;E&gt;</span><br><span class="line">    implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>所以，当我们需要使用队列时，还可以选择LinkedList。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 LinkedList 对象</span><br><span class="line">LinkedList&lt;String&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">// 添加元素</span><br><span class="line">queue.offer(&quot;沉默&quot;);</span><br><span class="line">queue.offer(&quot;王二&quot;);</span><br><span class="line">queue.offer(&quot;陈清扬&quot;);</span><br><span class="line">System.out.println(queue); // 输出 [沉默, 王二, 陈清扬]</span><br><span class="line">// 删除元素</span><br><span class="line">queue.poll();</span><br><span class="line">System.out.println(queue); // 输出 [王二, 陈清扬]</span><br><span class="line">// 修改元素：LinkedList 中的元素不支持直接修改，需要先删除再添加</span><br><span class="line">String first = queue.poll();</span><br><span class="line">queue.offer(&quot;王大二&quot;);</span><br><span class="line">System.out.println(queue); // 输出 [陈清扬, 王大二]</span><br><span class="line">// 查找元素：LinkedList 中的元素可以使用 get() 方法进行查找</span><br><span class="line">System.out.println(queue.get(0)); // 输出 陈清扬</span><br><span class="line">System.out.println(queue.contains(&quot;沉默&quot;)); // 输出 false</span><br><span class="line">// 查找元素：使用迭代器的方式查找陈清扬</span><br><span class="line">// 使用迭代器依次遍历元素并查找</span><br><span class="line">Iterator&lt;String&gt; iterator = queue.iterator();</span><br><span class="line">while (iterator.hasNext()) &#123;</span><br><span class="line">    String element = iterator.next();</span><br><span class="line">    if (element.equals(&quot;陈清扬&quot;)) &#123;</span><br><span class="line">        System.out.println(&quot;找到了：&quot; + element);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用 LinkedList 作为队列时，可以使用 offer() 方法将元素添加到队列的末尾，使用 poll() 方法从队列的头部删除元素，使用迭代器或者 poll() 方法依次遍历元素。</p>
<p><strong>栈和队列 </strong></p>
<p>要讲栈和队列，首先要讲Deque接口。Deque的含义是“double ended queue”，即双端队列，它既可以当作栈使用，也可以当作队列使用。下表列出了Deque与Queue相对应的接口：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Queue Method</th>
<th style="text-align:center">Equivalent Deque Method</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">add(e)</td>
<td style="text-align:center">addLast(e)</td>
<td style="text-align:center">向队尾插入元素，失败则抛出异常</td>
</tr>
<tr>
<td style="text-align:center">offer(e)</td>
<td style="text-align:center">offerLast(e)</td>
<td style="text-align:center">向队尾插入元素，失败则返回 false</td>
</tr>
<tr>
<td style="text-align:center">remove()</td>
<td style="text-align:center">removeFirst()</td>
<td style="text-align:center">获取并删除队首元素，失败则抛出异常</td>
</tr>
<tr>
<td style="text-align:center">poll()</td>
<td style="text-align:center">pollFirst()</td>
<td style="text-align:center">获取并删除队首元素，失败则返回 null</td>
</tr>
<tr>
<td style="text-align:center">element()</td>
<td style="text-align:center">getFirst()</td>
<td style="text-align:center">获取但不删除队首元素，失败则抛出异常</td>
</tr>
<tr>
<td style="text-align:center">peek()</td>
<td style="text-align:center">peekFirst()</td>
<td style="text-align:center">获取但不删除队首元素，失败则返回 null</td>
</tr>
</tbody>
</table>
</div>
<p>下表列出了Deque与Stack对应的接口：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Stack Method</th>
<th style="text-align:center">Equivalent Deque Method</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">push(e)</td>
<td style="text-align:center">addFirst(e)</td>
<td style="text-align:center">向栈顶插入元素，失败则抛出异常</td>
</tr>
<tr>
<td style="text-align:center">无</td>
<td style="text-align:center">offerFirst(e)</td>
<td style="text-align:center">向栈顶插入元素，失败则返回 false</td>
</tr>
<tr>
<td style="text-align:center">pop()</td>
<td style="text-align:center">removeFirst()</td>
<td style="text-align:center">获取并删除栈顶元素，失败则抛出异常</td>
</tr>
<tr>
<td style="text-align:center">无</td>
<td style="text-align:center">pollFirst()</td>
<td style="text-align:center">获取并删除栈顶元素，失败则返回 null</td>
</tr>
<tr>
<td style="text-align:center">peek()</td>
<td style="text-align:center">getFirst()</td>
<td style="text-align:center">获取但不删除栈顶元素，失败则抛出异常</td>
</tr>
<tr>
<td style="text-align:center">无</td>
<td style="text-align:center">peekFirst()</td>
<td style="text-align:center">获取但不删除栈顶元素，失败则返回 null</td>
</tr>
</tbody>
</table>
</div>
<p>上面两个表共定义了Deque的 12 个接口。</p>
<p>添加，删除，取值都有两套接口，它们功能相同，区别是对失败情况的处理不同。</p>
<p><strong>一套接口遇到失败就会抛出异常，另一套遇到失败会返回特殊值（ 或 ）</strong>。除非某种实现对容量有限制，大多数情况下，添加操作是不会失败的。</p>
<p><strong>虽然Deque的接口有 12 个之多，但无非就是对容器的两端进行操作，或添加，或删除，或查看</strong>。明白了这一点讲解起来就会非常简单。</p>
<p>ArrayDeque和LinkedList是Deque的两个通用实现，由于官方更推荐使用ArrayDeque用作栈和队列，加之上一篇已经讲解过LinkedList，本文将着重讲解ArrayDeque的具体实现。</p>
<p>从名字可以看出ArrayDeque底层通过数组实现，为了满足可以同时在数组两端插入或删除元素的需求，该数组还必须是循环的，即循环数组（circular array），也就是说数组的任何一点都可能被看作起点或者终点。</p>
<p><strong>ArrayDeque是非线程安全的</strong>（not thread-safe），当多个线程同时使用的时候，需要手动同步；另外，该容器不允许放入 null元素。</p>
<p><img src="\assets\note\image-20231010161808695.png" alt="image-20231010161808695"></p>
<p>上图中我们看到， <strong>head指向首端第一个有效元素， tail指向尾端第一个可以插入元素的空位</strong>。因为是循环数组，所以 head不一定总等于 0， tail也不一定总是比 head大。</p>
<p><strong>方法剖析 </strong></p>
<p><strong>addFirst() </strong></p>
<p>addFirst(E e)的作用是在Deque的首端插入元素，也就是在 head的前面插入元素，在空间足够且下标没有越界的情况下，只需要将 elements[—head] = e即可。</p>
<p><img src="\assets\note\image-20231010161947212.png" alt="image-20231010161947212"></p>
<p>实际需要考虑：</p>
<ol>
<li>空间是否够用，以及 </li>
<li>下标是否越界的问题。</li>
</ol>
<p>上图中，如果 head为 0之后接着调用 addFirst() ，虽然空余空间还够用，但 head为 -1 ，下标越界了。</p>
<p>下列代码很好的解决了这两个问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//addFirst(E e)</span><br><span class="line">public void addFirst(E e) &#123;</span><br><span class="line">    if (e == null)//不允许放入null</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    elements[head = (head - 1) &amp; (elements.length - 1)] = e;//2.下标是否越界</span><br><span class="line">    if (head == tail)//1.空间是否够用</span><br><span class="line">        doubleCapacity();//扩容</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码我们看到，<strong>空间问题是在插入之后解决的</strong>，因为 tail总是指向下一个可插入的空位，也就意味着elements数组至少有一个空位，所以插入元素的时候不用考虑空间问题。</p>
<p>下标越界的处理解决起来非常简单， head = (head - 1) &amp; (elements.length - 1)就可以了，<strong>这段代码相当于取余，同时解决了 head为负值的情况</strong>。因为 elements.length必需是 2的指数倍， elements - 1就是二进制低位全 1 ，跟 head - 1相与之后就起到了取模的作用，如果 head - 1为负数（其实只可能是-1），则相当于对其取相对于 elements.length的补码。</p>
<p>下面再说说扩容函数 doubleCapacity() ，其逻辑是申请一个更大的数组（原数组的两倍），然后将原数组复制过去。过程如下图所示：</p>
<p><img src="\assets\note\image-20231010162150336.png" alt="image-20231010162150336"></p>
<p>图中我们看到，复制分两次进行，第一次复制 head右边的元素，第二次复制 head左边的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//doubleCapacity()</span><br><span class="line">private void doubleCapacity() &#123;</span><br><span class="line">    assert head == tail;</span><br><span class="line">    int p = head;</span><br><span class="line">    int n = elements.length;</span><br><span class="line">    int r = n - p; // head右边元素的个数</span><br><span class="line">    int newCapacity = n &lt;&lt; 1;//原空间的2倍</span><br><span class="line">    if (newCapacity &lt; 0)</span><br><span class="line">        throw new IllegalStateException(&quot;Sorry, deque too big&quot;);</span><br><span class="line">    Object[] a = new Object[newCapacity];</span><br><span class="line">    System.arraycopy(elements, p, a, 0, r);//复制右半部分，对应上图中绿色部分</span><br><span class="line">    System.arraycopy(elements, 0, a, r, p);//复制左半部分，对应上图中灰色部分</span><br><span class="line">    elements = (E[])a;</span><br><span class="line">    head = 0;</span><br><span class="line">    tail = n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法的实现中，首先检查 head 和 tail 是否相等，如果不相等则抛出异常。然后计算出 head 右边的元素个数 r，以及新的容量 newCapacity，如果 newCapacity 太大则抛出异常。</p>
<p>接下来创建一个新的 Object 数组 a，将原有 ArrayDeque 中 head 右边的元素复制到 a 的前面（即图中绿色部分），将 head 左边的元素复制到 a 的后面（即图中灰色部分）。最后将 elements 数组替换为 a，head 设置为 0，tail 设置为 n（即新容量的长度）。</p>
<p>需要注意的是，由于 elements 数组被替换为 a 数组，因此在方法调用结束后，原有的 elements 数组将不再被引用，会被垃圾回收器回收。</p>
<p><strong>addLast() </strong></p>
<p>addLast(E e)的作用是在Deque的尾端插入元素，也就是在 tail的位置插入元素，由于 tail总是指向下一个可以插入的空位，因此只需要 elements[tail] = e;即可。插入完成后再检查空间，如果空间已经用光，则调用 doubleCapacity()进行扩容。</p>
<p><img src="\assets\note\image-20231010162257399.png" alt="image-20231010162257399"></p>
<p>下标越界处理方式 addFirt()中已经讲过，不再赘述。</p>
<p><strong>pollFirst() </strong></p>
<p>pollFirst()的作用是删除并返回Deque首端元素，也即是 head位置处的元素。如果容器不空，只需要直接返回 elements[head]即可，当然还需要处理下标的问题。由于 ArrayDeque中不允许放入 null ，当elements[head] == null时，意味着容器为空。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public E pollFirst() &#123;</span><br><span class="line">    E result = elements[head];</span><br><span class="line">    if (result == null)//null值意味着deque为空</span><br><span class="line">        return null;</span><br><span class="line">    elements[h] = null;//let GC work</span><br><span class="line">    head = (head + 1) &amp; (elements.length - 1);//下标越界处理</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>pollLast() </strong></p>
<p>pollLast()的作用是删除并返回Deque尾端元素，也即是 tail位置前面的那个元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public E pollLast() &#123;</span><br><span class="line">    int t = (tail - 1) &amp; (elements.length - 1);//tail的上一个位置是最后一个元素</span><br><span class="line">    E result = elements[t];</span><br><span class="line">    if (result == null)//null值意味着deque为空</span><br><span class="line">        return null;</span><br><span class="line">    elements[t] = null;//let GC work</span><br><span class="line">    tail = t;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>peekFirst() </strong></p>
<p>peekFirst()的作用是返回但不删除Deque首端元素，也即是 head位置处的元素，直接返回elements[head]即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public E peekFirst() &#123;</span><br><span class="line">    return elements[head]; // elements[head] is null if deque empty</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>peekLast() </strong></p>
<p>peekLast()的作用是返回但不删除Deque尾端元素，也即是 tail位置前面的那个元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public E peekLast() &#123;</span><br><span class="line">    return elements[(tail - 1) &amp; (elements.length - 1)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>小结 </strong></p>
<p>当需要实现先进先出(FIFO)或者先进后出(LIFO)的数据结构时，可以考虑使用 ArrayDeque。以下是一些使用 ArrayDeque 的场景：</p>
<ul>
<li>管理任务队列：如果需要实现一个任务队列，可以使用 ArrayDeque 来存储任务元素。在队列头部添加新任务元素，从队列尾部取出任务进行处理，可以保证任务按照先进先出的顺序执行。</li>
<li>实现栈：ArrayDeque 可以作为栈的实现方式，支持 push、pop、peek 等操作，可以用于需要后进先出的场景。</li>
<li>实现缓存：在需要缓存一定数量的数据时，可以使用 ArrayDeque。当缓存的数据量超过容量时，可以从队列头部删除最老的数据，从队列尾部添加新的数据。</li>
<li>实现事件处理器：ArrayDeque 可以作为事件处理器的实现方式，支持从队列头部获取事件进行处理，从队列尾部添加新的事件。</li>
</ul>
<p>简单总结一下吧。</p>
<p>ArrayDeque 是 Java 标准库中的一种双端队列实现，底层基于数组实现。与 LinkedList 相比，ArrayDeque 的性能更优，因为它使用连续的内存空间存储元素，可以更好地利用 CPU 缓存，在大多数情况下也更快。</p>
<p>为什么这么说呢？</p>
<p>因为ArrayDeque 的底层实现是数组，而 LinkedList 的底层实现是链表。数组是一段连续的内存空间，而链表是由多个节点组成的，每个节点存储数据和指向下一个节点的指针。因此，在使用 LinkedList 时，需要频繁进行内存分配和释放，而 ArrayDeque 在创建时就一次性分配了连续的内存空间，不需要频繁进行内存分配和释放，这样可以更好地利用 CPU 缓存，提高访问效率。</p>
<p>现代计算机CPU对于数据的局部性有很强的依赖，如果需要访问的数据在内存中是连续存储的，那么就可以利用CPU的缓存机制，提高访问效率。而当数据存储在不同的内存块里时，每次访问都需要从内存中读取，效率会受到影响。</p>
<p>当然了，使用 ArrayDeque 时，数组复制操作也是需要考虑的性能消耗之一。</p>
<p>当 ArrayDeque 的元素数量超过了初始容量时，会触发扩容操作。扩容操作会创建一个新的数组，并将原有元素复制到新数组中。扩容操作的时间复杂度为 O(n)。</p>
<p>不过，ArrayDeque 的扩容策略（当 ArrayDeque 中的元素数量达到数组容量时，就需要进行扩容操作，扩容时会将数组容量扩大为原来的两倍）可以在一定程度上减少数组复制的次数和时间消耗，同时保证 ArrayDeque 的性能和空间利用率。</p>
<p>ArrayDeque 不仅支持常见的队列操作，如添加元素、删除元素、获取队列头部元素、获取队列尾部元素等。同时，它还支持栈操作，如 push、pop、peek 等。这使得 ArrayDeque 成为一种非常灵活的数据结构，可以用于各种场景的数据存储和处理。</p>
<h2 id="4-13-优先级队列PriorityQueue详解"><a href="#4-13-优先级队列PriorityQueue详解" class="headerlink" title="4.13 优先级队列PriorityQueue详解"></a>4.13 优先级队列PriorityQueue详解</h2><p>继续有请王老师，来上台给大家讲讲优先级队列 PriorityQueue。</p>
<p>PriorityQueue 是 Java 中的一个基于优先级堆的优先队列实现，它能够在 O(log n) 的时间复杂度内实现元素的插入和删除操作，并且能够自动维护队列中元素的优先级顺序。</p>
<p>通俗来说，PriorityQueue 就是一个队列，但是它不是先进先出的，而是按照元素优先级进行排序的。当你往 PriorityQueue 中插入一个元素时，它会自动根据元素的优先级将其插入到合适的位置。当你从 PriorityQueue 中删除一个元素时，它会自动将优先级最高的元素出队。</p>
<p>下面 是一个简单的PriorityQueue示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 创建 PriorityQueue 对象</span><br><span class="line">PriorityQueue&lt;String&gt; priorityQueue = new PriorityQueue&lt;&gt;();</span><br><span class="line">// 添加元素到 PriorityQueue</span><br><span class="line">priorityQueue.offer(&quot;沉默王二&quot;);</span><br><span class="line">priorityQueue.offer(&quot;陈清扬&quot;);</span><br><span class="line">priorityQueue.offer(&quot;小转铃&quot;);</span><br><span class="line">// 打印 PriorityQueue 中的元素</span><br><span class="line">System.out.println(&quot;PriorityQueue 中的元素：&quot;);</span><br><span class="line">while (!priorityQueue.isEmpty()) &#123;</span><br><span class="line">    System.out.print(priorityQueue.poll() + &quot; &quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，我们首先创建了一个 PriorityQueue 对象，并向其中添加了三个元素。然后，我们使用 while 循环遍历 PriorityQueue 中的元素，并打印出来。来看输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue 中的元素：</span><br><span class="line">小转铃 沉默王二 陈清扬 </span><br></pre></td></tr></table></figure>
<p>再来看一下示例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 创建 PriorityQueue 对象，并指定优先级顺序</span><br><span class="line">PriorityQueue&lt;String&gt; priorityQueue = new PriorityQueue&lt;&gt;</span><br><span class="line">(Comparator.reverseOrder());</span><br><span class="line">// 添加元素到 PriorityQueue</span><br><span class="line">priorityQueue.offer(&quot;沉默王二&quot;);</span><br><span class="line">priorityQueue.offer(&quot;陈清扬&quot;);</span><br><span class="line">priorityQueue.offer(&quot;小转铃&quot;);</span><br><span class="line">// 打印 PriorityQueue 中的元素</span><br><span class="line">System.out.println(&quot;PriorityQueue 中的元素：&quot;);</span><br><span class="line">while (!priorityQueue.isEmpty()) &#123;</span><br><span class="line">    System.out.print(priorityQueue.poll() + &quot; &quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，我们使用了 Comparator.reverseOrder() 方法指定了 PriorityQueue 的优先级顺序为降序。</p>
<p>也就是说，PriorityQueue 中的元素会按照从大到小的顺序排序。</p>
<p>其他部分的代码与之前的例子相同，我们再来看一下输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue 中的元素：</span><br><span class="line">陈清扬 沉默王二 小转铃</span><br></pre></td></tr></table></figure>
<p>对比一下两个例子的输出结果，不难发现，顺序正好相反。</p>
<p><strong>PriorityQueue的作用 </strong></p>
<p>PriorityQueue 的主要作用是维护一组数据的排序，使得取出数据时可以按照一定的优先级顺序进行，当我们调用 poll() 方法时，它会从队列的顶部弹出最高优先级的元素。它在很多场景下都有广泛的应用，例如任务调度、事件处理等场景，以及一些算法中需要对数据进行排序的场景。</p>
<p>在实际应用中，PriorityQueue 也经常用于实现 Dijkstra 算法、Prim 算法、Huffman 编码等算法。这里简单说一下这几种算法的作用，理解不了也没关系哈。</p>
<p>Dijkstra算法是一种用于计算带权图中的最短路径的算法。该算法采用贪心的策略，在遍历图的过程中，每次选取当前到源点距离最短的一个顶点，并以它为中心进行扩展，更新其他顶点的距离值。经过多次扩展，可以得到源点到其它所有顶点的最短路径。</p>
<p>Prim算法是一种用于求解最小生成树的算法，可以在加权连通图中找到一棵生成树，使得这棵生成树的所有边的权值之和最小。该算法从任意一个顶点开始，逐渐扩展生成树的规模，每次选择一个距离已生成树最近的顶点加入到生成树中。</p>
<p>Huffman编码是一种基于霍夫曼树的压缩算法，用于将一个字符串转换为二进制编码以进行压缩。该算法的主要思想是通过建立霍夫曼树，将出现频率较高的字符用较短的编码表示，而出现频率较低的字符用较长的编码表示，从而实现对字符串的压缩。在解压缩时，根据编码逐步解析出原字符串。</p>
<p>由于 PriorityQueue 的底层是基于堆实现的，因此在数据量比较大时，使用 PriorityQueue 可以获得较好的时间复杂度。</p>
<p>这里牵涉到了大小关系，<strong>元素大小的评判可以通过元素本身的自然顺序（natural ordering），也可以通过构造时传入的比较器（Comparator，或者元素自身实现 Comparable 接口）来决定。</strong></p>
<p>在 PriorityQueue 中，每个元素都有一个优先级，这个优先级决定了元素在队列中的位置。队列内部通过小顶堆（也可以是大顶堆）的方式来维护元素的优先级关系。具体来说，小顶堆是一个完全二叉树，任何一个非叶子节点的权值，都不大于其左右子节点的权值，这样保证了队列的顶部元素（堆顶）一定是优先级最高的元素。</p>
<p>完全二叉树（Complete Binary Tree）是一种二叉树，其中除了最后一层，其他层的节点数都是满的，最后<br>一层的节点都靠左对齐。下面是一个完全二叉树的示意图：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     1</span><br><span class="line">   /   \</span><br><span class="line">  2     3</span><br><span class="line"> / \   /</span><br><span class="line">4   5 6</span><br></pre></td></tr></table></figure>
<p>堆是一种完全二叉树，堆的特点是根节点的值最小（小顶堆）或最大（大顶堆），并且任意非根节点i的值都不大于（或不小于）其父节点的值。</p>
<p>这是一颗包含整数 1, 2, 3, 4, 5, 6, 7 的小顶堆：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \ / \</span><br><span class="line">4  5 6  7</span><br></pre></td></tr></table></figure>
<p>这是一颗大顶堆。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     8</span><br><span class="line">   /   \</span><br><span class="line">  7     5</span><br><span class="line"> / \   / \</span><br><span class="line">6   4 2   1</span><br></pre></td></tr></table></figure>
<p>因为完全二叉树的结构比较规则，所以可以使用数组来存储堆的元素，而不需要使用指针等额外的空间。</p>
<p>在堆中，每个节点的下标和其在数组中的下标是一一对应的，假设节点下标为i，则其父节点下标为i/2，其左子节点下标为2i，其右子节点下标为2i+1。</p>
<p>假设有一个数组arr=[10, 20, 15, 30, 40]，现在要将其转化为一个小顶堆。</p>
<p>首先，我们将数组按照完全二叉树的形式排列，如下图所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">      10</span><br><span class="line">     /  \</span><br><span class="line">   20    15</span><br><span class="line">  /  \</span><br><span class="line">30   40</span><br></pre></td></tr></table></figure>
<p>从上往下、从左往右依次给每个节点编号，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \</span><br><span class="line">4   5</span><br></pre></td></tr></table></figure>
<p>接下来，我们按照上述公式，依次确定每个节点在数组中的位置。例如，节点1的父节点下标为1/2=0，左子节点下标为2<em>1=2，右子节点下标为2</em>1+1=3，因此节点1在数组中的位置为0，节点2在数组中的位置为2，节点3在数组中的位置为3。</p>
<p>对应的数组为[10, 20, 15, 30, 40]，符合小顶堆的定义，即每个节点的值都小于或等于其子节点的值。</p>
<p>好，我们画幅图再来理解一下。</p>
<p><img src="\assets\note\image-20231010163222552.png" alt="image-20231010163222552"></p>
<p>上图中我们给每个元素按照层序遍历的方式进行了编号，如果你足够细心，会发现父节点和子节点的编号是有联系的，更确切的说父子节点的编号之间有如下关系：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">leftNo = parentNo\*2+1</span><br><span class="line">rightNo = parentNo\*2+2</span><br><span class="line">parentNo = (nodeNo-1)/2</span><br></pre></td></tr></table></figure>
<p>通过上述三个公式，可以轻易计算出某个节点的父节点以及子节点的下标。这也就是为什么可以直接用数组来存储堆的原因。</p>
<p><strong>方法剖析 </strong></p>
<p><strong>add()和 offer() </strong></p>
<p>add(E e)和 offer(E e)的语义相同，都是向优先队列中插入元素，只是 Queue接口规定二者对插入失败时的处理不同，前者在插入失败时抛出异常，后则则会返回 false 。对于PriorityQueue这两个方法其实没什么差别。</p>
<p><img src="\assets\note\image-20231010163320807.png" alt="image-20231010163320807"></p>
<p>新加入的元素可能会破坏小顶堆的性质，因此需要进行必要的调整。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//offer(E e)</span><br><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">    if (e == null)//不允许放入null元素</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    modCount++;</span><br><span class="line">    int i = size;</span><br><span class="line">    if (i &gt;= queue.length)</span><br><span class="line">        grow(i + 1);//自动扩容</span><br><span class="line">    size = i + 1;</span><br><span class="line">    if (i == 0)//队列原来为空，这是插入的第一个元素</span><br><span class="line">        queue[0] = e;</span><br><span class="line">    else</span><br><span class="line">        siftUp(i, e);//调整</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中，扩容函数 grow()类似于 ArrayList里的 grow()函数，就是再申请一个更大的数组，并将原数组的元素复制过去，这里不再赘述。需要注意的是 siftUp(int k, E x)方法，该方法用于插入元素 x并维持堆的特性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//siftUp()</span><br><span class="line">private void siftUp(int k, E x) &#123;</span><br><span class="line">    while (k &gt; 0) &#123;</span><br><span class="line">        int parent = (k - 1) &gt;&gt;&gt; 1;//parentNo = (nodeNo-1)/2</span><br><span class="line">        Object e = queue[parent];</span><br><span class="line">        if (comparator.compare(x, (E) e) &gt;= 0)//调用比较器的比较方法</span><br><span class="line">            break;</span><br><span class="line">        queue[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调整的过程为：<strong>从k指定的位置开始，将x逐层与当前点的parent进行比较并交换，直到满足x &gt;= queue[parent]为止</strong>。注意这里的比较可以是元素的自然顺序，也可以是依靠比较器的顺序。</p>
<p><strong>element()和 peek() </strong></p>
<p>element()和 peek()的语义完全相同，都是获取但不删除队首元素，也就是队列中权值最小的那个元素，二者唯一的区别是当方法失败时前者抛出异常，后者返回 null 。根据小顶堆的性质，堆顶那个元素就是全局最小的那个；由于堆用数组表示，根据下标关系， 0下标处的那个元素既是堆顶元素。所以<strong>直接返回数组0下标处的那个元素即可。</strong></p>
<p><img src="\assets\note\image-20231010163540087.png" alt="image-20231010163540087"></p>
<p>代码也就非常简洁：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//peek()</span><br><span class="line">public E peek() &#123;</span><br><span class="line">    if (size == 0)</span><br><span class="line">        return null;</span><br><span class="line">    return (E) queue[0];//0下标处的那个元素就是最小的那个</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>remove()和 poll() </strong></p>
<p>remove()和 poll()方法的语义也完全相同，都是获取并删除队首元素，区别是当方法失败时前者抛出异常，后者返回 null 。由于删除操作会改变队列的结构，为维护小顶堆的性质，需要进行必要的调整。</p>
<p><img src="\assets\note\image-20231010163619147.png" alt="image-20231010163619147"></p>
<p>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public E poll() &#123;</span><br><span class="line">    if (size == 0)</span><br><span class="line">        return null;</span><br><span class="line">    int s = --size;</span><br><span class="line">    modCount++;</span><br><span class="line">    E result = (E) queue[0];//0下标处的那个元素就是最小的那个</span><br><span class="line">    E x = (E) queue[s];</span><br><span class="line">    queue[s] = null;</span><br><span class="line">    if (s != 0)</span><br><span class="line">        siftDown(0, x);//调整</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码首先记录 0下标处的元素，并用最后一个元素替换 0下标位置的元素，之后调用 siftDown()方法对堆进行调整，最后返回原来 0下标处的那个元素（也就是最小的那个元素）。重点是 siftDown(int k, E x)方法，该方法的作用是<strong>从 k指定的位置开始，将 x逐层向下与当前点的左右孩子中较小的那个交换，直到 小于或等于左右孩子中的任何一个为止。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//siftDown()</span><br><span class="line">private void siftDown(int k, E x) &#123;</span><br><span class="line">    int half = size &gt;&gt;&gt; 1;</span><br><span class="line">    while (k &lt; half) &#123;</span><br><span class="line">      //首先找到左右孩子中较小的那个，记录到c里，并用child记录其下标</span><br><span class="line">        int child = (k &lt;&lt; 1) + 1;//leftNo = parentNo*2+1</span><br><span class="line">        Object c = queue[child];</span><br><span class="line">        int right = child + 1;</span><br><span class="line">        if (right &lt; size &amp;&amp;</span><br><span class="line">            comparator.compare((E) c, (E) queue[right]) &gt; 0)</span><br><span class="line">            c = queue[child = right];</span><br><span class="line">        if (comparator.compare(x, (E) c) &lt;= 0)</span><br><span class="line">            break;</span><br><span class="line">        queue[k] = c;//然后用c取代原来的值</span><br><span class="line">        k = child;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>remove(Object o) </strong></p>
<p>remove(Object o)方法用于删除队列中跟 o相等的某一个元素（如果有多个相等，只删除一个），该方法不是Queue接口内的方法，而是Collection接口的方法。由于删除操作会改变队列结构，所以要进行调整；又由于删除元素的位置可能是任意的，所以调整过程比其它方法稍加繁琐。</p>
<p>具体来说， remove(Object o)可以分为 2 种情况：</p>
<ol>
<li>删除的是最后一个元素。直接删除即可，不需要调整。</li>
<li>删除的不是最后一个元素，从删除点开始以最后一个元素为参照调用一次 siftDown()即可。此处不再赘述。</li>
</ol>
<p><img src="\assets\note\image-20231010163808582.png" alt="image-20231010163808582"></p>
<p>具体代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//remove(Object o)</span><br><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">  //通过遍历数组的方式找到第一个满足o.equals(queue[i])元素的下标</span><br><span class="line">    int i = indexOf(o);</span><br><span class="line">    if (i == -1)</span><br><span class="line">        return false;</span><br><span class="line">    int s = --size;</span><br><span class="line">    if (s == i) //情况1</span><br><span class="line">        queue[i] = null;</span><br><span class="line">    else &#123;</span><br><span class="line">        E moved = (E) queue[s];</span><br><span class="line">        queue[s] = null;</span><br><span class="line">        siftDown(i, moved);//情况2</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>小结 </strong></p>
<p>PriorityQueue 是一个非常常用的数据结构，它是一种特殊的堆（Heap）实现，可以用来高效地维护一个有序的集合。</p>
<ul>
<li>它的底层实现是一个数组，通过堆的性质来维护元素的顺序。</li>
<li>取出元素时按照优先级顺序（从小到大或者从大到小）进行取出。</li>
<li>如果需要指定排序，元素必须实现 Comparable 接口或者传入一个 Comparator 来进行比较。</li>
</ul>
<h2 id="4-14-Comparable和Comparator的区别"><a href="#4-14-Comparable和Comparator的区别" class="headerlink" title="4.14 Comparable和Comparator的区别"></a>4.14 Comparable和Comparator的区别</h2><p>在前面学习优先级队列的时候，我们曾提到过 Comparable和Comparator，那这篇继续以面试官的角度去切入，一起来看。</p>
<p>那天，小二去马蜂窝面试，面试官老王一上来就甩给了他一道面试题：请问Comparable和Comparator有什么区别？小二差点笑出声，因为他在《Java进阶之路》上看到过这题 。</p>
<p>Comparable 和 Comparator 是 Java 的两个接口，从名字上我们就能够读出来它们俩的相似性：以某种方式来比较两个对象。<br>但它们之间到底有什么区别呢？请随我来，打怪进阶喽！</p>
<p><strong>01、Comparable </strong></p>
<p>Comparable 接口的定义非常简单，源码如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Comparable&lt;T&gt; &#123;</span><br><span class="line">    int compareTo(T t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果一个类实现了 Comparable 接口（只需要干一件事，重写 compareTo() 方法），就可以按照自己制定的规则将由它创建的对象进行比较。下面给出一个例子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Cmower implements Comparable&lt;Cmower&gt; &#123;</span><br><span class="line">    private int age;</span><br><span class="line">    private String name;</span><br><span class="line">    public Cmower(int age, String name) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(Cmower o) &#123;</span><br><span class="line">        return this.getAge() - o.getAge();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Cmower wanger = new Cmower(19,&quot;沉默王二&quot;);</span><br><span class="line">        Cmower wangsan = new Cmower(16,&quot;沉默王三&quot;);</span><br><span class="line">        if (wanger.compareTo(wangsan) &lt; 0) &#123;</span><br><span class="line">            System.out.println(wanger.getName() + &quot;比较年轻有为&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(wangsan.getName() + &quot;比较年轻有为&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我创建了一个 Cmower 类，它有两个字段：age 和 name。Cmower 类实现了 Comparable 接口，并重写了 compareTo() 方法。</p>
<p>程序输出的结果是“沉默王三比较年轻有为”，因为他比沉默王二小三岁。这个结果有什么凭证吗？</p>
<p>凭证就在于 compareTo() 方法，该方法的返回值可能为负数，零或者正数，代表的意思是该对象按照排序的规则小于、等于或者大于要比较的对象。如果指定对象的类型与此对象不能进行比较，则引发 ClassCastException 异常（自从有了泛型，这种情况就少有发生了）。</p>
<p><strong>02、Comparator </strong></p>
<p>Comparator 接口的定义相比较于 Comparable 就复杂的多了，不过，核心的方法只有两个，来看一下源码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Comparator&lt;T&gt; &#123;</span><br><span class="line">    int compare(T o1, T o2);</span><br><span class="line">    boolean equals(Object obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个方法 compare(T o1, T o2) 的返回值可能为负数，零或者正数，代表的意思是第一个对象小于、等于或者大于第二个对象。</p>
<p>第二个方法 equals(Object obj) 需要传入一个 Object 作为参数，并判断该 Object 是否和 Comparator 保持一致。</p>
<p>有时候，我们想让类保持它的原貌，不想主动实现 Comparable 接口，但我们又需要它们之间进行比较，该怎么办呢？</p>
<p>Comparator 就派上用场了，来看一下示例。</p>
<p><strong>1）原封不动的 Cmower 类。 </strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Cmower  &#123;</span><br><span class="line">    private int age;</span><br><span class="line">    private String name;</span><br><span class="line">    public Cmower(int age, String name) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Cmower 类有两个字段：age 和 name，意味着该类可以按照 age 或者 name 进行排序。</p>
<p><strong>2）再来看 Comparator 接口的实现类。 </strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class CmowerComparator implements Comparator&lt;Cmower&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(Cmower o1, Cmower o2) &#123;</span><br><span class="line">        return o1.getAge() - o2.getAge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照 age 进行比较。当然也可以再实现一个比较器，按照 name 进行自然排序，示例如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class CmowerNameComparator implements Comparator&lt;Cmower&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(Cmower o1, Cmower o2) &#123;</span><br><span class="line">        if (o1.getName().hashCode() &lt; o2.getName().hashCode()) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125; else if (o1.getName().hashCode() == o2.getName().hashCode()) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3）再来看测试类。 </strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Cmower wanger = new Cmower(19,&quot;沉默王二&quot;);</span><br><span class="line">Cmower wangsan = new Cmower(16,&quot;沉默王三&quot;);</span><br><span class="line">Cmower wangyi = new Cmower(28,&quot;沉默王一&quot;);</span><br><span class="line">List&lt;Cmower&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list.add(wanger);</span><br><span class="line">list.add(wangsan);</span><br><span class="line">list.add(wangyi);</span><br><span class="line">list.sort(new CmowerComparator());</span><br><span class="line">for (Cmower c : list) &#123;</span><br><span class="line">    System.out.println(c.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建了三个对象，age 不同，name 不同，并把它们加入到了 List 当中。然后使用 List 的 sort() 方法进行排序，来看一下输出的结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">沉默王三</span><br><span class="line">沉默王二</span><br><span class="line">沉默王一</span><br></pre></td></tr></table></figure>
<p>这意味着沉默王三的年纪比沉默王二小，排在第一位；沉默王一的年纪比沉默王二大，排在第三位。和我们的预期完全符合。</p>
<p>借此机会，再来看一下 sort 方法的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void sort(Comparator&lt;? super E&gt; c) &#123;</span><br><span class="line">    // 保存当前队列的 modCount 值，用于检测 sort 操作是否非法</span><br><span class="line">    final int expectedModCount = modCount;</span><br><span class="line">    // 调用 Arrays.sort 对 elementData 数组进行排序，使用传入的比较器 c</span><br><span class="line">    Arrays.sort((E[]) elementData, 0, size, c);</span><br><span class="line">    // 检查操作期间 modCount 是否被修改，如果被修改则抛出并发修改异常</span><br><span class="line">    if (modCount != expectedModCount) &#123;</span><br><span class="line">        throw new ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">    // 增加 modCount 值，表示队列已经被修改过</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，参数就是一个 Comparator 接口，并且使用了泛型 Comparator&lt;? super E&gt; c 。</p>
<p><strong>03、到底该用哪一个？ </strong></p>
<p>通过上面的两个例子可以比较出 Comparable 和 Comparator 两者之间的区别：</p>
<ul>
<li>一个类实现了 Comparable 接口，意味着该类的对象可以直接进行比较（排序），但比较（排序）的方式只有一种，很单一。</li>
<li>一个类如果想要保持原样，又需要进行不同方式的比较（排序），就可以定制比较器（实现 Comparator 接口）。</li>
<li>Comparable 接口在 java.lang 包下，而 Comparator 接口在 java.util 包下，算不上是亲兄弟，但可以称得上是表（堂）兄弟。</li>
</ul>
<p>举个不恰当的例子。我想从洛阳出发去北京看长城，体验一下好汉的感觉，要么坐飞机，要么坐高铁；但如果是孙悟空的话，翻个筋斗就到了。我和孙悟空之间有什么区别呢？</p>
<p>孙悟空自己实现了 Comparable 接口（他那年代也没有飞机和高铁，没得选），而我可以借助 Comparator 接口（现代化的交通工具）。</p>
<p>好了，关于 Comparable 和 Comparator 我们就先聊这么多。总而言之，如果对象的排序需要基于自然顺序，请选择 Comparable ，如果需要按照对象的不同属性进行排序，请选择 Comparator 。</p>
<h1 id="5-Java-IO"><a href="#5-Java-IO" class="headerlink" title="5 Java IO"></a>5 Java IO</h1><h2 id="5-1-IO-分类"><a href="#5-1-IO-分类" class="headerlink" title="5.1 IO 分类"></a>5.1 IO 分类</h2><p>“老王，Java IO 也太上头了吧？”新兵蛋子小二向头顶很凉快的老王抱怨道，“你瞧，我就按照传输方式对 IO 进行了一个简单的分类，就能搞出来这么多的玩意！”</p>
<p><img src="\assets\note\image-20231010220517447.png" alt="image-20231010220517447"></p>
<p>好久没搞过 IO 了，老王看到这幅思维导图也是吃了一惊。想想也是，他当初学习 Java IO 的时候头也大，乌央乌央的一片，全是类，估计是所有 Java 包里面类最多的，一会是 Input 一会是 Output，一会是 Reader ，一会是 Writer，真不知道 Java 的设计者是怎么想的。</p>
<p>看着肺都快要气炸的小二，老王深深地吸了一口气，耐心地对小二说：“主要是 Java 的设计者考虑得比较多吧，所以 IO 给人一种很乱的感觉，我来给你梳理一下。”</p>
<p><strong>00、初识 Java IO </strong></p>
<p>IO，即in和out，也就是输入和输出，指应用程序和外部设备之间的数据传递，常见的外部设备包括文件、管道、网络连接。</p>
<p>Java 中是通过流处理IO 的，那么什么是流？</p>
<p>流（Stream），是一个抽象的概念，是指一连串的数据（字符或字节），是以先进先出的方式发送信息的通道。</p>
<p>当程序需要读取数据的时候，就会开启一个通向数据源的流，这个数据源可以是文件，内存，或是网络连接。类似的，当程序需要写入数据的时候，就会开启一个通向目的地的流。这时候你就可以想象数据好像在这其中“流”动一样。</p>
<p>一般来说关于流的特性有下面几点：</p>
<ul>
<li>先进先出：最先写入输出流的数据最先被输入流读取到。</li>
<li>顺序存取：可以一个接一个地往流中写入一串字节，读出时也将按写入顺序读取一串字节，不能随机访问中间的数据（RandomAccessFile除外）</li>
<li>只读或只写：每个流只能是输入流或输出流的一种，不能同时具备两个功能，输入流只能进行读操作，对输出流只能进行写操作。在一个数据传输通道中，如果既要写入数据，又要读取数据，则要分别提供两个流。</li>
</ul>
<p><strong>01、传输方式划分 </strong></p>
<p>就按照你的那副思维导图来说吧。</p>
<p>传输方式有两种，字节和字符，那首先得搞明白字节和字符有什么区别，对吧？</p>
<p>字节（byte）是计算机中用来表示存储容量的一个计量单位，通常情况下，一个字节有 8 位（bit）。</p>
<p>字符（char）可以是计算机中使用的字母、数字、和符号，比如说 A 1 $ 这些。</p>
<p>通常来说，一个字母或者一个字符占用一个字节，一个汉字占用两个字节。</p>
<p><img src="\assets\note\image-20231010220752842.png" alt="image-20231010220752842"></p>
<p>具体还要看字符编码，比如说在 UTF-8 编码下，一个英文字母（不分大小写）为一个字节，一个中文汉字为三个字节；在 Unicode 编码中，一个英文字母为一个字节，一个中文汉字为两个字节。</p>
<p>明白了字节与字符的区别，再来看字节流和字符流就会轻松多了。</p>
<p>字节流用来处理二进制文件，比如说图片啊、MP3 啊、视频啊。</p>
<p>字符流用来处理文本文件，文本文件可以看作是一种特殊的二进制文件，只不过经过了编码，便于人们阅读。</p>
<p>换句话说就是，字节流可以处理一切文件，而字符流只能处理文本。</p>
<p>虽然 IO 类很多，但核心的就是 4 个抽象类：InputStream、OutputStream、Reader、Writer。（抽象大法真好）</p>
<p>虽然 IO 类的方法也很多，但核心的也就 2 个：read 和 write。</p>
<p><strong>InputStream 类</strong></p>
<ul>
<li>int read() ：读取数据</li>
<li>int read(byte b[], int off, int len) ：从第 off 位置开始读，读取 len 长度的字节，然后放入数组 b 中</li>
<li>long skip(long n) ：跳过指定个数的字节</li>
<li>int available() ：返回可读的字节数</li>
<li>void close() ：关闭流，释放资源</li>
</ul>
<p><strong>OutputStream 类</strong></p>
<ul>
<li>void write(int b) ： 写入一个字节，虽然参数是一个 int 类型，但只有低 8 位才会写入，高 24 位会舍弃（这块后面再讲）</li>
<li>void write(byte b[], int off, int len) ： 将数组 b 中的从 off 位置开始，长度为 len 的字节写入</li>
<li>void flush() ： 强制刷新，将缓冲区的数据写入</li>
<li>void close() ：关闭流</li>
</ul>
<p><strong>Reader 类</strong></p>
<ul>
<li>int read() ：读取单个字符</li>
<li>int read(char cbuf[], int off, int len) ：从第 off 位置开始读，读取 len 长度的字符，然后放入数组 b 中</li>
<li>long skip(long n) ：跳过指定个数的字符</li>
<li>int ready() ：是否可以读了</li>
<li>void close() ：关闭流，释放资源</li>
</ul>
<p><strong>Writer 类</strong></p>
<ul>
<li>void write(int c) ： 写入一个字符</li>
<li>void write( char cbuf[], int off, int len) ： 将数组 cbuf 中的从 off 位置开始，长度为 len 的字符写入</li>
<li>void flush() ： 强制刷新，将缓冲区的数据写入</li>
<li>void close() ：关闭流</li>
</ul>
<p>理解了上面这些方法，基本上 IO 的灵魂也就全部掌握了。</p>
<p>字节流和字符流的区别：</p>
<ul>
<li>字节流一般用来处理图像、视频、音频、PPT、Word等类型的文件。字符流一般用于处理纯文本类型的文件，如TXT文件等，但不能处理图像视频等非文本文件。用一句话说就是：字节流可以处理一切文件，而字符流只能处理纯文本文件。</li>
<li>字节流本身没有缓冲区，缓冲字节流相对于字节流，效率提升非常高。而字符流本身就带有缓冲区，缓冲字符流相对于字符流效率提升就不是那么大了。</li>
</ul>
<p>以写文件为例，我们查看字符流的源码，发现确实有利用到缓冲区：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 声明一个 char 类型的数组，用于写入输出流</span><br><span class="line">private char[] writeBuffer;</span><br><span class="line">// 定义 writeBuffer 数组的大小，必须 &gt;= 1</span><br><span class="line">private static final int WRITE_BUFFER_SIZE = 1024;</span><br><span class="line">// 写入给定字符串中的一部分到输出流中</span><br><span class="line">public void write(String str, int off, int len) throws IOException &#123;</span><br><span class="line">    // 使用 synchronized 关键字同步代码块，确保线程安全</span><br><span class="line">    synchronized (lock) &#123;</span><br><span class="line">        char cbuf[];</span><br><span class="line">        // 如果 len &lt;= WRITE_BUFFER_SIZE，则使用 writeBuffer 数组进行写入</span><br><span class="line">        if (len &lt;= WRITE_BUFFER_SIZE) &#123;</span><br><span class="line">            // 如果 writeBuffer 为 null，则创建一个大小为 WRITE_BUFFER_SIZE 的新 char 数组</span><br><span class="line">            if (writeBuffer == null) &#123;</span><br><span class="line">                writeBuffer = new char[WRITE_BUFFER_SIZE];</span><br><span class="line">            &#125;</span><br><span class="line">            cbuf = writeBuffer;</span><br><span class="line">        &#125; else &#123;    // 如果 len &gt; WRITE_BUFFER_SIZE，则不永久分配非常大的缓冲区</span><br><span class="line">            // 创建一个大小为 len 的新 char 数组</span><br><span class="line">            cbuf = new char[len];</span><br><span class="line">        &#125;</span><br><span class="line">        // 将 str 中的一部分（从 off 开始，长度为 len）拷贝到 cbuf 数组中</span><br><span class="line">        str.getChars(off, (off + len), cbuf, 0);</span><br><span class="line">        // 将 cbuf 数组中的数据写入输出流中</span><br><span class="line">        write(cbuf, 0, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码是 Java IO 类库中的 OutputStreamWriter 类的 write 方法，可以看到缓冲区的大小是 1024 个 char。</p>
<p>我们再以文件的字符流和字节流来做一下对比，代码差别很小。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 字节流</span><br><span class="line">try (FileInputStream fis = new FileInputStream(&quot;input.txt&quot;);</span><br><span class="line">     FileOutputStream fos = new FileOutputStream(&quot;output.txt&quot;)) &#123;</span><br><span class="line">    byte[] buffer = new byte[1024];</span><br><span class="line">    int len;</span><br><span class="line">    while ((len = fis.read(buffer)) != -1) &#123;</span><br><span class="line">        fos.write(buffer, 0, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">// 字符流</span><br><span class="line">try (FileReader fr = new FileReader(&quot;input.txt&quot;);</span><br><span class="line">     FileWriter fw = new FileWriter(&quot;output.txt&quot;)) &#123;</span><br><span class="line">    char[] buffer = new char[1024];</span><br><span class="line">    int len;</span><br><span class="line">    while ((len = fr.read(buffer)) != -1) &#123;</span><br><span class="line">        fw.write(buffer, 0, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>02、操作对象划分 </strong></p>
<p>小二，你细想一下，IO IO，不就是输入输出（Input/Output）嘛：</p>
<ul>
<li>Input：将外部的数据读入内存，比如说把文件从硬盘读取到内存，从网络读取数据到内存等等</li>
<li>Output：将内存中的数据写入到外部，比如说把数据从内存写入到文件，把数据从内存输出到网络等等。</li>
</ul>
<p>所有的程序，在执行的时候，都是在内存上进行的，一旦关机，内存中的数据就没了，那如果想要持久化，就需要把内存中的数据输出到外部，比如说文件。</p>
<p>文件操作算是 IO 中最典型的操作了，也是最频繁的操作。那其实你可以换个角度来思考，比如说按照 IO 的操作对象来思考，IO 就可以分类为：文件、数组、管道、基本数据类型、缓冲、打印、对象序列化/反序列化，以及转换等。</p>
<p><img src="\assets\note\image-20231010221438501.png" alt="image-20231010221438501"></p>
<p><strong>1）文件 </strong></p>
<p>文件流也就是直接操作文件的流，可以细分为字节流（FileInputStream 和 FileOuputStream）和字符流（FileReader 和 FileWriter）。</p>
<p>FileInputStream 的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 声明一个 int 类型的变量 b，用于存储读取到的字节</span><br><span class="line">int b;</span><br><span class="line">// 创建一个 FileInputStream 对象，用于读取文件 fis.txt 中的数据</span><br><span class="line">FileInputStream fis1 = new FileInputStream(&quot;fis.txt&quot;);</span><br><span class="line">// 循环读取文件中的数据</span><br><span class="line">while ((b = fis1.read()) != -1) &#123;</span><br><span class="line">    // 将读取到的字节转换为对应的 ASCII 字符，并输出到控制台</span><br><span class="line">    System.out.println((char)b);</span><br><span class="line">&#125;</span><br><span class="line">// 关闭 FileInputStream 对象，释放资源</span><br><span class="line">fis1.close();</span><br></pre></td></tr></table></figure>
<p>FileOutputStream 的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 FileOutputStream 对象，用于写入数据到文件 fos.txt 中</span><br><span class="line">FileOutputStream fos = new FileOutputStream(&quot;fos.txt&quot;);</span><br><span class="line">// 向文件中写入数据，这里写入的是字符串 &quot;沉默王二&quot; 对应的字节数组</span><br><span class="line">fos.write(&quot;沉默王二&quot;.getBytes());</span><br><span class="line">// 关闭 FileOutputStream 对象，释放资源</span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure>
<p>FileReader 的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 声明一个 int 类型的变量 b，用于存储读取到的字符</span><br><span class="line">int b = 0;</span><br><span class="line">// 创建一个 FileReader 对象，用于读取文件 read.txt 中的数据</span><br><span class="line">FileReader fileReader = new FileReader(&quot;read.txt&quot;);</span><br><span class="line">// 循环读取文件中的数据</span><br><span class="line">while ((b = fileReader.read()) != -1) &#123;</span><br><span class="line">    // 将读取到的字符强制转换为 char 类型，并输出到控制台</span><br><span class="line">    System.out.println((char)b);</span><br><span class="line">&#125;</span><br><span class="line">// 关闭 FileReader 对象，释放资源</span><br><span class="line">fileReader.close();</span><br></pre></td></tr></table></figure>
<p>FileWriter 的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 FileWriter 对象，用于写入数据到文件 fw.txt 中</span><br><span class="line">FileWriter fileWriter = new FileWriter(&quot;fw.txt&quot;);</span><br><span class="line">// 将字符串 &quot;沉默王二&quot; 转换为字符数组</span><br><span class="line">char[] chars = &quot;沉默王二&quot;.toCharArray();</span><br><span class="line">// 向文件中写入数据，这里写入的是 chars 数组中的所有字符</span><br><span class="line">fileWriter.write(chars, 0, chars.length);</span><br><span class="line">// 关闭 FileWriter 对象，释放资源</span><br><span class="line">fileWriter.close();</span><br></pre></td></tr></table></figure>
<p>文件流还可以用于创建、删除、重命名文件等操作。FileOutputStream 和 FileWriter 构造函数的第二个参数可以指定是否追加数据到文件末尾。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 创建文件</span><br><span class="line">File file = new File(&quot;test.txt&quot;);</span><br><span class="line">if (file.createNewFile()) &#123;</span><br><span class="line">    System.out.println(&quot;文件创建成功&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    System.out.println(&quot;文件已存在&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// 删除文件</span><br><span class="line">if (file.delete()) &#123;</span><br><span class="line">    System.out.println(&quot;文件删除成功&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    System.out.println(&quot;文件删除失败&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// 重命名文件</span><br><span class="line">File oldFile = new File(&quot;old.txt&quot;);</span><br><span class="line">File newFile = new File(&quot;new.txt&quot;);</span><br><span class="line">if (oldFile.renameTo(newFile)) &#123;</span><br><span class="line">    System.out.println(&quot;文件重命名成功&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    System.out.println(&quot;文件重命名失败&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当掌握了文件的输入输出，其他的自然也就掌握了，都大差不差。</p>
<p><strong>2）数组（内存）</strong></p>
<p>通常来说，针对文件的读写操作，使用文件流配合缓冲流就够用了，但为了提升效率，频繁地读写文件并不是太好，那么就出现了数组流，有时候也称为内存流。</p>
<p>ByteArrayInputStream 的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 ByteArrayInputStream 对象，用于从字节数组中读取数据</span><br><span class="line">InputStream is = new BufferedInputStream(</span><br><span class="line">        new ByteArrayInputStream(</span><br><span class="line">                &quot;沉默王二&quot;.getBytes(StandardCharsets.UTF_8)));</span><br><span class="line">// 定义一个字节数组用于存储读取到的数据</span><br><span class="line">byte[] flush = new byte[1024];</span><br><span class="line">// 定义一个变量用于存储每次读取到的字节数</span><br><span class="line">int len = 0;</span><br><span class="line">// 循环读取字节数组中的数据，并输出到控制台</span><br><span class="line">while (-1 != (len = is.read(flush))) &#123;</span><br><span class="line">    // 将读取到的字节转换为对应的字符串，并输出到控制台</span><br><span class="line">    System.out.println(new String(flush, 0, len));</span><br><span class="line">&#125;</span><br><span class="line">// 关闭输入流，释放资源</span><br><span class="line">is.close();</span><br></pre></td></tr></table></figure>
<p>ByteArrayOutputStream 的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 ByteArrayOutputStream 对象，用于写入数据到内存缓冲区中</span><br><span class="line">ByteArrayOutputStream bos = new ByteArrayOutputStream();</span><br><span class="line">// 定义一个字节数组用于存储要写入内存缓冲区中的数据</span><br><span class="line">byte[] info = &quot;沉默王二&quot;.getBytes();</span><br><span class="line">// 向内存缓冲区中写入数据，这里写入的是 info 数组中的所有字节</span><br><span class="line">bos.write(info, 0, info.length);</span><br><span class="line">// 将内存缓冲区中的数据转换为字节数组</span><br><span class="line">byte[] dest = bos.toByteArray();</span><br><span class="line">// 关闭 ByteArrayOutputStream 对象，释放资源</span><br><span class="line">bos.close();</span><br></pre></td></tr></table></figure>
<p>数组流可以用于在内存中读写数据，比如将数据存储在字节数组中进行压缩、加密、序列化等操作。它的优点是不需要创建临时文件，可以提高程序的效率。但是，数组流也有缺点，它只能存储有限的数据量，如果存储的数据量过大，会导致内存溢出。</p>
<p><strong>3）管道 </strong></p>
<p>Java 中的管道和 Unix/Linux 中的管道不同，在 Unix/Linux 中，不同的进程之间可以通过管道来通信，但 Java 中，通信的双方必须在同一个进程中，也就是在同一个 JVM 中，管道为线程之间的通信提供了通信能力。</p>
<p>一个线程通过 PipedOutputStream 写入的数据可以被另外一个线程通过相关联的 PipedInputStream 读取出来。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 PipedOutputStream 对象和一个 PipedInputStream 对象</span><br><span class="line">final PipedOutputStream pipedOutputStream = new PipedOutputStream();</span><br><span class="line">final PipedInputStream pipedInputStream = new PipedInputStream(pipedOutputStream);</span><br><span class="line">// 创建一个线程，向 PipedOutputStream 中写入数据</span><br><span class="line">Thread thread1 = new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 将字符串 &quot;沉默王二&quot; 转换为字节数组，并写入到 PipedOutputStream 中</span><br><span class="line">            pipedOutputStream.write(&quot;沉默王二&quot;.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">            // 关闭 PipedOutputStream，释放资源</span><br><span class="line">            pipedOutputStream.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">// 创建一个线程，从 PipedInputStream 中读取数据并输出到控制台</span><br><span class="line">Thread thread2 = new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 定义一个字节数组用于存储读取到的数据</span><br><span class="line">            byte[] flush = new byte[1024];</span><br><span class="line">            // 定义一个变量用于存储每次读取到的字节数</span><br><span class="line">            int len = 0;</span><br><span class="line">            // 循环读取字节数组中的数据，并输出到控制台</span><br><span class="line">            while (-1 != (len = pipedInputStream.read(flush))) &#123;</span><br><span class="line">                // 将读取到的字节转换为对应的字符串，并输出到控制台</span><br><span class="line">                System.out.println(new String(flush, 0, len));</span><br><span class="line">            &#125;</span><br><span class="line">            // 关闭 PipedInputStream，释放资源</span><br><span class="line">            pipedInputStream.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">// 启动线程1和线程2</span><br><span class="line">thread1.start();</span><br><span class="line">thread2.start();</span><br></pre></td></tr></table></figure>
<p>使用管道流可以实现不同线程之间的数据传输，可以用于线程间的通信、数据的传递等。但是，管道流也有一些局限性，比如只能在同一个 JVM 中的线程之间使用，不能跨越不同的 JVM 进程。</p>
<p><strong>4）基本数据类型 </strong></p>
<p>基本数据类型输入输出流是一个字节流，该流不仅可以读写字节和字符，还可以读写基本数据类型。</p>
<p>DataInputStream 提供了一系列可以读基本数据类型的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 DataInputStream 对象，用于从文件中读取数据</span><br><span class="line">DataInputStream dis = new DataInputStream(new FileInputStream(&quot;das.txt&quot;));</span><br><span class="line">// 读取一个字节，将其转换为 byte 类型</span><br><span class="line">byte b = dis.readByte();</span><br><span class="line">// 读取两个字节，将其转换为 short 类型</span><br><span class="line">short s = dis.readShort();</span><br><span class="line">// 读取四个字节，将其转换为 int 类型</span><br><span class="line">int i = dis.readInt();</span><br><span class="line">// 读取八个字节，将其转换为 long 类型</span><br><span class="line">long l = dis.readLong();</span><br><span class="line">// 读取四个字节，将其转换为 float 类型</span><br><span class="line">float f = dis.readFloat();</span><br><span class="line">// 读取八个字节，将其转换为 double 类型</span><br><span class="line">double d = dis.readDouble();</span><br><span class="line">// 读取一个字节，将其转换为 boolean 类型</span><br><span class="line">boolean bb = dis.readBoolean();</span><br><span class="line">// 读取两个字节，将其转换为 char 类型</span><br><span class="line">char ch = dis.readChar();</span><br><span class="line">// 关闭 DataInputStream，释放资源</span><br><span class="line">dis.close();</span><br></pre></td></tr></table></figure>
<p>DataOutputStream 提供了一系列可以写基本数据类型的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 DataOutputStream 对象，用于将数据写入到文件中</span><br><span class="line">DataOutputStream das = new DataOutputStream(new FileOutputStream(&quot;das.txt&quot;));</span><br><span class="line">// 将一个 byte 类型的数据写入到文件中</span><br><span class="line">das.writeByte(10);</span><br><span class="line">// 将一个 short 类型的数据写入到文件中</span><br><span class="line">das.writeShort(100);</span><br><span class="line">// 将一个 int 类型的数据写入到文件中</span><br><span class="line">das.writeInt(1000);</span><br><span class="line">// 将一个 long 类型的数据写入到文件中</span><br><span class="line">das.writeLong(10000L);</span><br><span class="line">// 将一个 float 类型的数据写入到文件中</span><br><span class="line">das.writeFloat(12.34F);</span><br><span class="line">// 将一个 double 类型的数据写入到文件中</span><br><span class="line">das.writeDouble(12.56);</span><br><span class="line">// 将一个 boolean 类型的数据写入到文件中</span><br><span class="line">das.writeBoolean(true);</span><br><span class="line">// 将一个 char 类型的数据写入到文件中</span><br><span class="line">das.writeChar(&#x27;A&#x27;);</span><br><span class="line">// 关闭 DataOutputStream，释放资源</span><br><span class="line">das.close();</span><br></pre></td></tr></table></figure>
<p>除了 DataInputStream 和 DataOutputStream，Java IO 还提供了其他一些读写基本数据类型和字符串的流类，包括 ObjectInputStream 和 ObjectOutputStream（用于读写对象）。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    try (ObjectOutputStream oos = new ObjectOutputStream(new </span><br><span class="line">FileOutputStream(&quot;person.dat&quot;))) &#123;</span><br><span class="line">        Person p = new Person(&quot;张三&quot;, 20);</span><br><span class="line">        oos.writeObject(p);</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    try (ObjectInputStream ois = new ObjectInputStream(new </span><br><span class="line">FileInputStream(&quot;person.dat&quot;))) &#123;</span><br><span class="line">        Person p = (Person) ois.readObject();</span><br><span class="line">        System.out.println(p);</span><br><span class="line">    &#125; catch (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码创建了一个 Person 对象，将其写入文件中，然后从文件中读取该对象，并打印在控制台上。</p>
<p><strong>5）缓冲 </strong></p>
<p>CPU 很快，它比内存快 100 倍，比磁盘快百万倍。那也就意味着，程序和内存交互会很快，和硬盘交互相对就很慢，这样就会导致性能问题。</p>
<p>为了减少程序和硬盘的交互，提升程序的效率，就引入了缓冲流，也就是类名前缀带有 Buffer 的那些，比如说 BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter。</p>
<p><img src="\assets\note\image-20231010223429527.png" alt="image-20231010223429527"></p>
<p>缓冲流在内存中设置了一个缓冲区，只有缓冲区存储了足够多的带操作的数据后，才会和内存或者硬盘进行交互。简单来说，就是一次多读/写点，少读/写几次，这样程序的性能就会提高。</p>
<p>以下是一个使用 BufferedInputStream 读取文件的示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 BufferedInputStream 对象，用于从文件中读取数据</span><br><span class="line">BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;data.txt&quot;));</span><br><span class="line">// 创建一个字节数组，作为缓存区</span><br><span class="line">byte[] buffer = new byte[1024];</span><br><span class="line">// 读取文件中的数据，并将其存储到缓存区中</span><br><span class="line">int bytesRead;</span><br><span class="line">while ((bytesRead = bis.read(buffer)) != -1) &#123;</span><br><span class="line">    // 对缓存区中的数据进行处理</span><br><span class="line">    // 这里只是简单地将读取到的字节数组转换为字符串并打印出来</span><br><span class="line">    System.out.println(new String(buffer, 0, bytesRead));</span><br><span class="line">&#125;</span><br><span class="line">// 关闭 BufferedInputStream，释放资源</span><br><span class="line">bis.close();</span><br></pre></td></tr></table></figure>
<p>上述代码中，首先创建了一个 BufferedInputStream 对象，用于从文件中读取数据。然后创建了一个字节数组作为缓存区，每次读取数据时将数据存储到缓存区中。读取数据的过程是通过 while 循环实现的，每次读取数据后对缓存区中的数据进行处理。最后关闭BufferedInputStream，释放资源。</p>
<p>以下是一个使用 BufferedOutputStream 写入文件的示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 BufferedOutputStream 对象，用于将数据写入到文件中</span><br><span class="line">BufferedOutputStream bos = new BufferedOutputStream(new </span><br><span class="line">FileOutputStream(&quot;data.txt&quot;));</span><br><span class="line">// 创建一个字节数组，作为缓存区</span><br><span class="line">byte[] buffer = new byte[1024];</span><br><span class="line">// 将数据写入到文件中</span><br><span class="line">String data = &quot;沉默王二是个大傻子!&quot;;</span><br><span class="line">buffer = data.getBytes();</span><br><span class="line">bos.write(buffer);</span><br><span class="line">// 刷新缓存区，将缓存区中的数据写入到文件中</span><br><span class="line">bos.flush();</span><br><span class="line">// 关闭 BufferedOutputStream，释放资源</span><br><span class="line">bos.close();</span><br></pre></td></tr></table></figure>
<p>上述代码中，首先创建了一个 BufferedOutputStream 对象，用于将数据写入到文件中。然后创建了一个字节数组作为缓存区，将数据写入到缓存区中。写入数据的过程是通过 write() 方法实现的，将字节数组作为参数传递给 write() 方法即可。</p>
<p>最后，通过 flush() 方法将缓存区中的数据写入到文件中。在写入数据时，由于使用了 BufferedOutputStream，数据会先被写入到缓存区中，只有在缓存区被填满或者调用了 flush() 方法时才会将缓存区中的数据写入到文件中。</p>
<p>以下是一个使用 BufferedReader 读取文件的示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 BufferedReader 对象，用于从文件中读取数据</span><br><span class="line">BufferedReader br = new BufferedReader(new FileReader(&quot;data.txt&quot;));</span><br><span class="line">// 读取文件中的数据，并将其存储到字符串中</span><br><span class="line">String line;</span><br><span class="line">while ((line = br.readLine()) != null) &#123;</span><br><span class="line">    // 对读取到的数据进行处理</span><br><span class="line">    // 这里只是简单地将读取到的每一行字符串打印出来</span><br><span class="line">    System.out.println(line);</span><br><span class="line">&#125;</span><br><span class="line">// 关闭 BufferedReader，释放资源</span><br><span class="line">br.close();</span><br></pre></td></tr></table></figure>
<p>上述代码中，首先创建了一个 BufferedReader 对象，用于从文件中读取数据。然后使用 readLine() 方法读取文件中的数据，每次读取一行数据并将其存储到一个字符串中。读取数据的过程是通过 while 循环实现的。</p>
<p>以下是一个使用 BufferedWriter 写入文件的示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 BufferedWriter 对象，用于将数据写入到文件中</span><br><span class="line">BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;data.txt&quot;));</span><br><span class="line">// 将数据写入到文件中</span><br><span class="line">String data = &quot;沉默王二，真帅气&quot;;</span><br><span class="line">bw.write(data);</span><br><span class="line">// 刷新缓存区，将缓存区中的数据写入到文件中</span><br><span class="line">bw.flush();</span><br><span class="line">// 关闭 BufferedWriter，释放资源</span><br><span class="line">bw.close();</span><br></pre></td></tr></table></figure>
<p>上述代码中，首先创建了一个 BufferedWriter 对象，用于将数据写入到文件中。然后使用 write() 方法将数据写入到缓存区中，写入数据的过程和使用 FileWriter 类似。需要注意的是，使用 BufferedWriter 写入数据时，数据会先被写入到缓存区中，只有在缓存区被填满或者调用了 flush() 方法时才会将缓存区中的数据写入到文件中。</p>
<p>最后，通过 flush() 方法将缓存区中的数据写入到文件中，并通过 close() 方法关闭 BufferedWriter，释放资源。</p>
<p>使用缓冲流可以提高读写效率，减少了频繁的读写磁盘或网络的次数，从而提高了程序的性能。但是，在使用缓冲流时需要注意缓冲区的大小和清空缓冲区的时机，以避免数据丢失或不完整的问题。</p>
<p><strong>6）打印 </strong></p>
<p>Java 的打印流是一组用于打印输出数据的类，包括 PrintStream 和 PrintWriter 两个类。</p>
<p>恐怕 Java 程序员一生当中最常用的就是打印流了： System.out 其实返回的就是一个 PrintStream 对象，可以用来打印各式各样的对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;沉默王二是真的二！&quot;);</span><br></pre></td></tr></table></figure>
<p>PrintStream 最终输出的是字节数据，而 PrintWriter 则是扩展了 Writer 接口，所以它的 print()/println() 方法最终输出的是字符数据。使用上几乎和 PrintStream 一模一样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StringWriter buffer = new StringWriter();</span><br><span class="line">try (PrintWriter pw = new PrintWriter(buffer)) &#123;</span><br><span class="line">    pw.println(&quot;沉默王二&quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(buffer.toString());</span><br></pre></td></tr></table></figure>
<p><strong>7）对象序列化/反序列化</strong> </p>
<p>序列化本质上是将一个 Java 对象转成字节数组，然后可以将其保存到文件中，或者通过网络传输到远程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 ByteArrayOutputStream 对象 buffer，用于存储数据</span><br><span class="line">ByteArrayOutputStream buffer = new ByteArrayOutputStream();</span><br><span class="line">// 使用 try-with-resources 语句创建一个 ObjectOutputStream 对象 output，并将其与 buffer </span><br><span class="line">关联</span><br><span class="line">try (ObjectOutputStream output = new ObjectOutputStream(buffer)) &#123;</span><br><span class="line">    </span><br><span class="line">    // 使用 writeUTF() 方法将字符串 &quot;沉默王二&quot; 写入到缓冲区中</span><br><span class="line">    output.writeUTF(&quot;沉默王二&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// 使用 toByteArray() 方法将缓冲区中的数据转换成字节数组，并输出到控制台</span><br><span class="line">System.out.println(Arrays.toString(buffer.toByteArray()));</span><br></pre></td></tr></table></figure>
<p>与其对应的，有序列化，就有反序列化，也就是再将字节数组转成 Java 对象的过程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">try (ObjectInputStream input = new ObjectInputStream(new FileInputStream(</span><br><span class="line">        new File(&quot;Person.txt&quot;)))) &#123;</span><br><span class="line">    String s = input.readUTF();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码主要使用了 Java 的 ByteArrayOutputStream 和 ObjectOutputStream 类，将字符串 “沉默王二” 写入到一个字节数组缓冲区中，并将缓冲区中的数据转换成字节数组输出到控制台。</p>
<p>具体的执行过程如下：</p>
<ul>
<li>创建一个 ByteArrayOutputStream 对象 buffer，用于存储数据。</li>
<li>使用 try-with-resources 语句创建一个 ObjectOutputStream 对象 output，并将其与 buffer 关联。</li>
<li>使用 writeUTF() 方法将字符串 “沉默王二” 写入到缓冲区中。</li>
<li>当 try-with-resources 语句执行完毕时，会自动调用 output 的 close() 方法关闭输出流，释放资源。</li>
<li>使用 toByteArray() 方法将缓冲区中的数据转换成字节数组。</li>
<li>使用 Arrays.toString() 方法将字节数组转换成字符串，并输出到控制台。</li>
</ul>
<p><strong>8）转换 </strong></p>
<p>InputStreamReader 是从字节流到字符流的桥连接，它使用指定的字符集读取字节并将它们解码为字符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 InputStreamReader 对象 isr，使用 FileInputStream 对象读取文件 demo.txt 的内容并</span><br><span class="line">将其转换为字符流</span><br><span class="line">InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;demo.txt&quot;));</span><br><span class="line">// 创建一个字符数组 cha，用于存储读取的字符数据，其中 1024 表示数组的长度</span><br><span class="line">char[] cha = new char[1024];</span><br><span class="line">// 使用 read() 方法读取 isr 中的数据，并将读取的字符数据存储到 cha 数组中，返回值 len 表示读取的</span><br><span class="line">字符数</span><br><span class="line">int len = isr.read(cha);</span><br><span class="line">// 将 cha 数组中从下标 0 开始、长度为 len 的部分转换成字符串，并输出到控制台</span><br><span class="line">System.out.println(new String(cha, 0, len));</span><br><span class="line">// 关闭 InputStreamReader 对象 isr，释放资源</span><br><span class="line">isr.close();</span><br></pre></td></tr></table></figure>
<p>这段代码主要使用了 Java 的 InputStreamReader 和 FileInputStream 类，从文件 demo.txt 中读取数据并将其转换为字符流，然后将读取的字符数据存储到一个字符数组中，并输出转换成字符串后的结果到控制台。</p>
<p>OutputStreamWriter 将一个字符流的输出对象变为字节流的输出对象，是字符流通向字节流的桥梁。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 File 对象 f，表示文件 test.txt</span><br><span class="line">File f = new File(&quot;test.txt&quot;);</span><br><span class="line">// 创建一个 OutputStreamWriter 对象 out，使用 FileOutputStream 对象将数据写入到文件 f 中，并</span><br><span class="line">将字节流转换成字符流</span><br><span class="line">Writer out = new OutputStreamWriter(new FileOutputStream(f));</span><br><span class="line">// 使用 write() 方法将字符串 &quot;沉默王二!!&quot; 写入到文件 f 中</span><br><span class="line">out.write(&quot;沉默王二!!&quot;);</span><br><span class="line">// 关闭 Writer 对象 out，释放资源</span><br><span class="line">out.close();</span><br></pre></td></tr></table></figure>
<p>使用转换流可以方便地在字节流和字符流之间进行转换。在进行文本文件读写时，通常使用字符流进行操作，而在进行网络传输或与设备进行通信时，通常使用字节流进行操作。</p>
<p>另外，在使用转换流时需要注意字符编码的问题。如果不指定字符编码，则使用默认的字符编码，可能会出现乱码问题。因此，建议在使用转换流时，始终指定正确的字符编码，以避免出现乱码问题。</p>
<p>“小二啊，你看，经过我的梳理，是不是感觉 IO 也没多少东西！针对不同的场景、不同的业务，选择对应的 IO 流就可以了，用法上就是读和写。”老王一口气讲完这些，长长的舒了一口气。</p>
<p>此时此刻的小二，还沉浸在老王的滔滔不绝中。不仅感觉老王的肺活量是真的大，还感慨老王不愧是工作了十多年的“老油条”，一下子就把自己感觉头大的 IO 给梳理得很清晰了。</p>
<h2 id="5-2-文件流"><a href="#5-2-文件流" class="headerlink" title="5.2 文件流"></a>5.2 文件流</h2><p>在 IO 操作中，文件的操作相对来说是比较复杂的，但也是使用频率最高的部分，我们几乎所有的项目中几乎都躺着一个叫做 FileUtil 或者 FileUtils 的工具类。</p>
<p>java.io.File 类是专门对文件进行操作的类，注意只能对文件本身进行操作，不能对文件内容进行操作，想要操作内容，必须借助输入输出流。</p>
<p>File 类是文件和目录的抽象表示，主要用于文件和目录的创建、查找和删除等操作。</p>
<p>怎么理解上面两句话？其实很简单！</p>
<p>第一句是说 File 跟流无关，File 类不能对文件进行读和写，也就是输入和输出！</p>
<p>第二句是说 File 可以表示 D:\文件目录1与 D:\文件目录1\文件.txt ，前者是文件夹（Directory，或者叫目录）后者是文件(file)，File 类就是用来操作它俩的。</p>
<p><strong>File 构造方法 </strong></p>
<p>在 Java 中，一切皆是对象，File 类也不例外，不论是哪个对象都应该从该对象的构造说起，所以我们来分析分析 File类的构造方法。</p>
<p>比较常用的构造方法有三个：</p>
<p>1、 File(String pathname) ：通过给定的路径来创建新的 File 实例。</p>
<p>2、 File(String parent, String child) ：从父路径（字符串）和子路径创建新的 File 实例。</p>
<p>3、 File(File parent, String child) ：从父路径（File）和子路径名字符串创建新的 File 实例。</p>
<p>看文字描述不够生动、不够形象、不得劲？没事，通过举例马上就生动形象了，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 文件路径名</span><br><span class="line">String path = &quot;/Users/username/123.txt&quot;;</span><br><span class="line">File file1 = new File(path);</span><br><span class="line">// 文件路径名</span><br><span class="line">String path2 = &quot;/Users/username/1/2.txt&quot;;</span><br><span class="line">File file2 = new File(path2); -------------相当于/Users/username/1/2.txt</span><br><span class="line">// 通过父路径和子路径字符串</span><br><span class="line">String parent = &quot;/Users/username/aaa&quot;;</span><br><span class="line">String child = &quot;bbb.txt&quot;;</span><br><span class="line">File file3 = new File(parent, child); --------相当于/Users/username/aaa/bbb.txt</span><br><span class="line">// 通过父级File对象和子路径字符串</span><br><span class="line">File parentDir = new File(&quot;/Users/username/aaa&quot;);</span><br><span class="line">String child = &quot;bbb.txt&quot;;</span><br><span class="line">File file4 = new File(parentDir, child); --------相当于/Users/username/aaa/bbb.txt</span><br></pre></td></tr></table></figure>
<p>注意，macOS 路径使用正斜杠（ / ）作为路径分隔符，而 Windows 路径使用反斜杠（ \ ）作为路径分隔符。所以在遇到路径分隔符的时候，不要直接去写 /或者 \ 。</p>
<p>Java 中提供了一个跨平台的方法来获取路径分隔符，即使用 File.separator ，这个属性会根据操作系统自动返回正确的路径分隔符。</p>
<p>File 类的注意点：</p>
<ol>
<li>一个 File 对象代表硬盘中实际存在的一个文件或者目录。</li>
<li>File 类的构造方法不会检验这个文件或目录是否真实存在，因此无论该路径下是否存在文件或者目录，都不影响 File 对象的创建。</li>
</ol>
<p><strong>File 常用方法 </strong></p>
<p>File 的常用方法主要分为获取功能、获取绝对路径和相对路径、判断功能、创建删除功能的方法。</p>
<p><strong>1）获取功能的方法 </strong></p>
<p>1、 getAbsolutePath() ：返回此 File 的绝对路径。</p>
<p>2、 getPath() ：结果和 getAbsolutePath 一致。</p>
<p>3、 getName() ：返回文件名或目录名。</p>
<p>4、 length() ：返回文件长度，以字节为单位。</p>
<p>测试代码如下【注意测试以你自己的电脑文件夹为准】：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">File f = new File(&quot;/Users/username/aaa/bbb.java&quot;);</span><br><span class="line">System.out.println(&quot;文件绝对路径:&quot;+f.getAbsolutePath());</span><br><span class="line">System.out.println(&quot;文件构造路径:&quot;+f.getPath());</span><br><span class="line">System.out.println(&quot;文件名称:&quot;+f.getName());</span><br><span class="line">System.out.println(&quot;文件长度:&quot;+f.length()+&quot;字节&quot;);</span><br><span class="line">File f2 = new File(&quot;/Users/username/aaa&quot;);</span><br><span class="line">System.out.println(&quot;目录绝对路径:&quot;+f2.getAbsolutePath());</span><br><span class="line">System.out.println(&quot;目录构造路径:&quot;+f2.getPath());</span><br><span class="line">System.out.println(&quot;目录名称:&quot;+f2.getName());</span><br><span class="line">System.out.println(&quot;目录长度:&quot;+f2.length());</span><br></pre></td></tr></table></figure>
<p>注意： length() 表示文件的长度， File 对象表示目录的时候，返回值并无意义。</p>
<p><strong>2）绝对路径和相对路径 </strong></p>
<p>绝对路径是从文件系统的根目录开始的完整路径，它描述了一个文件或目录在文件系统中的确切位置。在 Windows 系统中，绝对路径通常以盘符（如 C:）开始，例如 “ C:\Program Files\Java\jdk1.8.0_291\bin\java.exe “。在 macOS 和 Linux 系统中，绝对路径通常以斜杠（ / ）开始，例如 “ /usr/local/bin/python3 “。</p>
<p>相对路径是相对于当前工作目录的路径，它描述了一个文件或目录与当前工作目录之间的位置关系。在 Java 中，相对路径通常是相对于当前 Java 程序所在的目录，例如 “ config/config.properties “。如果当前工作目录是 “ /Users/username/project “，那么相对路径 “ config/config.properties “ 就表示 “ /Users/username/project/config/config.properties “。</p>
<p>注意：</p>
<ul>
<li>在 Windows 操作系统中，文件系统默认是不区分大小写的，即在文件系统中，文件名和路径的大小写可以混合使用。例如，” C:\Users\username\Documents\example.txt “ 和 “ C:\Users\Username\Documents\Example.txt “ 表示的是同一个文件。但是，Windows 操作系统提供了一个区分大小写的选项，可以在格式化磁盘时选择启用，这样文件系统就会区分大小写。</li>
<li>在 macOS 和 Linux 等 Unix 系统中，文件系统默认是区分大小写的。例如，在 macOS 系统中，” /Users/username/Documents/example.txt “ 和 “ /Users/username/Documents/Example.txt “ 表示的是两个不同的文件。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 绝对路径示例</span><br><span class="line">File absoluteFile = new File(&quot;/Users/username/example/test.txt&quot;);</span><br><span class="line">System.out.println(&quot;绝对路径：&quot; + absoluteFile.getAbsolutePath());</span><br><span class="line">// 相对路径示例</span><br><span class="line">File relativeFile = new File(&quot;example/test.txt&quot;);</span><br><span class="line">System.out.println(&quot;相对路径：&quot; + relativeFile.getPath());</span><br></pre></td></tr></table></figure>
<p><strong>3）判断功能的方法 </strong></p>
<p>1、 exists() ：判断文件或目录是否存在。</p>
<p>2、 isDirectory() ：判断是否为目录。</p>
<p>3、 isFile() ：判断是否为文件。</p>
<p>方法演示，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">File file = new File(&quot;/Users/username/example&quot;);</span><br><span class="line">// 判断文件或目录是否存在</span><br><span class="line">if (file.exists()) &#123;</span><br><span class="line">    System.out.println(&quot;文件或目录存在&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    System.out.println(&quot;文件或目录不存在&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// 判断是否是目录</span><br><span class="line">if (file.isDirectory()) &#123;</span><br><span class="line">    System.out.println(&quot;是目录&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    System.out.println(&quot;不是目录&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// 判断是否是文件</span><br><span class="line">if (file.isFile()) &#123;</span><br><span class="line">    System.out.println(&quot;是文件&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    System.out.println(&quot;不是文件&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4）创建、删除功能的方法 </strong></p>
<ul>
<li>createNewFile() ：文件不存在，创建一个新的空文件并返回 true ，文件存在，不创建文件并返回false 。</li>
<li>delete() ：删除文件或目录。如果是目录，只有目录为空才能删除。</li>
<li>mkdir() ：只能创建一级目录，如果父目录不存在，则创建失败。返回 true 表示创建成功，返回 false 表示创建失败。</li>
<li>mkdirs() ：可以创建多级目录，如果父目录不存在，则会一并创建。返回 true 表示创建成功，返回 false 表示创建失败或目录已经存在。</li>
</ul>
<p>开发中一般用 mkdirs() ;</p>
<p>方法测试，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 创建文件</span><br><span class="line">File file = new File(&quot;/Users/username/example/test.txt&quot;);</span><br><span class="line">if (file.createNewFile()) &#123;</span><br><span class="line">    System.out.println(&quot;创建文件成功：&quot; + file.getAbsolutePath());</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    System.out.println(&quot;创建文件失败：&quot; + file.getAbsolutePath());</span><br><span class="line">&#125;</span><br><span class="line">// 删除文件</span><br><span class="line">if (file.delete()) &#123;</span><br><span class="line">    System.out.println(&quot;删除文件成功：&quot; + file.getAbsolutePath());</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    System.out.println(&quot;删除文件失败：&quot; + file.getAbsolutePath());</span><br><span class="line">&#125;</span><br><span class="line">// 创建多级目录</span><br><span class="line">File directory = new File(&quot;/Users/username/example/subdir1/subdir2&quot;);</span><br><span class="line">if (directory.mkdirs()) &#123;</span><br><span class="line">    System.out.println(&quot;创建目录成功：&quot; + directory.getAbsolutePath());</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    System.out.println(&quot;创建目录失败：&quot; + directory.getAbsolutePath());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>5）目录的遍历 </strong></p>
<ul>
<li>String[] list() ：返回一个 String 数组，表示该 File 目录中的所有子文件或目录。</li>
<li>File[] listFiles() ：返回一个 File 数组，表示该 File 目录中的所有的子文件或目录。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">File directory = new File(&quot;/Users/itwanger/Documents/Github/paicoding&quot;);</span><br><span class="line">// 列出目录下的文件名</span><br><span class="line">String[] files = directory.list();</span><br><span class="line">System.out.println(&quot;目录下的文件名：&quot;);</span><br><span class="line">for (String file : files) &#123;</span><br><span class="line">    System.out.println(file);</span><br><span class="line">&#125;</span><br><span class="line">// 列出目录下的文件和子目录</span><br><span class="line">File[] filesAndDirs = directory.listFiles();</span><br><span class="line">System.out.println(&quot;目录下的文件和子目录：&quot;);</span><br><span class="line">for (File fileOrDir : filesAndDirs) &#123;</span><br><span class="line">    if (fileOrDir.isFile()) &#123;</span><br><span class="line">        System.out.println(&quot;文件：&quot; + fileOrDir.getName());</span><br><span class="line">    &#125; else if (fileOrDir.isDirectory()) &#123;</span><br><span class="line">        System.out.println(&quot;目录：&quot; + fileOrDir.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>listFiles在获取指定目录下的文件或者子目录时必须满足下面两个条件：</p>
<ol>
<li>指定的目录必须存在</li>
<li>指定的必须是目录。否则容易引发 NullPointerException 异常</li>
</ol>
<p><strong>6）递归遍历 </strong></p>
<p>不说啥了，直接上代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    File directory = new File(&quot;/Users/itwanger/Documents/Github/paicoding&quot;);</span><br><span class="line">    // 递归遍历目录下的文件和子目录</span><br><span class="line">    traverseDirectory(directory);</span><br><span class="line">&#125;</span><br><span class="line">public static void traverseDirectory(File directory) &#123;</span><br><span class="line">    // 列出目录下的所有文件和子目录</span><br><span class="line">    File[] filesAndDirs = directory.listFiles();</span><br><span class="line">    // 遍历每个文件和子目录</span><br><span class="line">    for (File fileOrDir : filesAndDirs) &#123;</span><br><span class="line">        if (fileOrDir.isFile()) &#123;</span><br><span class="line">            // 如果是文件，输出文件名</span><br><span class="line">            System.out.println(&quot;文件：&quot; + fileOrDir.getName());</span><br><span class="line">        &#125; else if (fileOrDir.isDirectory()) &#123;</span><br><span class="line">            // 如果是目录，递归遍历子目录</span><br><span class="line">            System.out.println(&quot;目录：&quot; + fileOrDir.getName());</span><br><span class="line">            traverseDirectory(fileOrDir);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>RandomAccessFile </strong></p>
<p>RandomAccessFile 是 Java 中一个非常特殊的类，它既可以用来读取文件，也可以用来写入文件。与其他 IO 类（如 FileInputStream 和 FileOutputStream）不同，RandomAccessFile 允许您跳转到文件的任何位置，从那里开始读取或写入。这使得它特别适用于需要在文件中随机访问数据的场景，如数据库系统。</p>
<p>下面是一个使用 RandomAccessFile 的示例，包括写入和读取文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.RandomAccessFile;</span><br><span class="line">public class RandomAccessFileDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String filePath = &quot;logs/javabetter/itwanger.txt&quot;;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 使用 RandomAccessFile 写入文件</span><br><span class="line">            writeToFile(filePath, &quot;Hello, 沉默王二!&quot;);</span><br><span class="line">            // 使用 RandomAccessFile 读取文件</span><br><span class="line">            String content = readFromFile(filePath);</span><br><span class="line">            System.out.println(&quot;文件内容: &quot; + content);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private static void writeToFile(String filePath, String content) throws IOException &#123;</span><br><span class="line">        try (RandomAccessFile randomAccessFile = new RandomAccessFile(filePath, &quot;rw&quot;)) &#123;</span><br><span class="line">            // 将文件指针移动到文件末尾（在此处追加内容）</span><br><span class="line">            randomAccessFile.seek(randomAccessFile.length());</span><br><span class="line">            // 写入内容</span><br><span class="line">            randomAccessFile.writeUTF(content);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private static String readFromFile(String filePath) throws IOException &#123;</span><br><span class="line">        StringBuilder content = new StringBuilder();</span><br><span class="line">        try (RandomAccessFile randomAccessFile = new RandomAccessFile(filePath, &quot;r&quot;)) &#123;</span><br><span class="line">            // 将文件指针移动到文件开始处（从头开始读取）</span><br><span class="line">            randomAccessFile.seek(0);</span><br><span class="line">            content.append(randomAccessFile.readUTF());</span><br><span class="line">        &#125;</span><br><span class="line">        return content.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了避免中文乱码问题，我们使用 RandomAccessFile 的 writeUTF 和 readUTF 方法，它们将使用 UTF-8 编码处理字符串。大家可以运行一下这段代码，体验一下。</p>
<p><img src="\assets\note\image-20231010224921704.png" alt="image-20231010224921704"></p>
<p>接下来，会详细介绍一下 RandomAccessFile 的构造方法和常用的方法。</p>
<p><strong>构造方法 </strong></p>
<p>RandomAccessFile 主要有两个构造方法：</p>
<ul>
<li>RandomAccessFile(File file, String mode) ：使用给定的文件对象和访问模式创建一个新的 RandomAccessFile 实例。</li>
<li>RandomAccessFile(String name, String mode) ：使用给定的文件名和访问模式创建一个新的 RandomAccessFile 实例。</li>
</ul>
<p>访问模式 mode 的值可以是：</p>
<ul>
<li>“r”：以只读模式打开文件。调用结果对象的任何 write 方法都将导致 IOException。</li>
<li>“rw”：以读写模式打开文件。如果文件不存在，它将被创建。</li>
<li>“rws”：以读写模式打开文件，并要求对内容或元数据的每个更新都被立即写入到底层存储设备。这种模式是同步的，可以确保在系统崩溃时不会丢失数据。</li>
<li>“rwd”：与“rws”类似，以读写模式打开文件，但仅要求对文件内容的更新被立即写入。元数据可能会被延迟写入。</li>
</ul>
<p><strong>主要方法 </strong></p>
<ul>
<li>long getFilePointer() ：返回文件指针的当前位置。</li>
<li>long length() ：返回此文件的长度。</li>
<li>int read() ：从该文件中读取一个字节数据。</li>
<li>int read(byte[] b) ：从该文件中读取字节数据并将其存储到指定的字节数组中。</li>
<li>int read(byte[] b, int off, int len) ：从该文件中读取字节数据并将其存储到指定的字节数组中，从偏移量 off 开始，最多读取 len 个字节。</li>
<li>String readLine() ：从该文件中读取一行文本。</li>
<li>readUTF() ：从文件读取 UTF-8 编码的字符串。此方法首先读取两个字节的长度信息，然后根据这个长度读取字符串的 UTF-8 字节。最后，这些字节被转换为 Java 字符串。这意味着当你使用 readUTF 方法读取字符串时，需要确保文件中的字符串是使用 writeUTF 方法写入的，这样它们之间的长度信息和编码方式才能保持一致。</li>
<li>void seek(long pos) ：将文件指针设置到文件中的 pos 位置。</li>
<li>void write(byte[] b) ：将指定的字节数组的所有字节写入该文件。</li>
<li>void write(byte[] b, int off, int len) ：将指定字节数组的部分字节写入该文件，从偏移量 off 开始，写入 len 个字节。</li>
<li>void write(int b) ：将指定的字节写入该文件。</li>
<li>writeUTF(String str) ：将一个字符串以 UTF-8 编码写入文件。此方法首先写入两个字节的长度信息，表示字符串的 UTF-8 字节长度，然后写入 UTF-8 字节本身。因此，当你使用 writeUTF 写入字符串时，实际写入的字节数会比字符串的 UTF-8 字节长度多两个字节。这两个字节用于在读取字符串时确定正确的字符串长度。</li>
</ul>
<p>再来看一个示例，结合前面的讲解，就会彻底掌握 RandomAccessFile。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">File file = new File(&quot;logs/javabetter/itwanger.txt&quot;);</span><br><span class="line">try (RandomAccessFile raf = new RandomAccessFile(file, &quot;rw&quot;)) &#123;</span><br><span class="line">    // 写入文件</span><br><span class="line">    raf.writeUTF(&quot;Hello, 沉默王二!&quot;);</span><br><span class="line">    // 将文件指针移动到文件开头</span><br><span class="line">    raf.seek(0);</span><br><span class="line">    // 读取文件内容</span><br><span class="line">    String content = raf.readUTF();</span><br><span class="line">    System.out.println(&quot;内容: &quot; + content);</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们首先创建了一个名为 itwanger.txt 的文件对象。然后我们使用 RandomAccessFile 以读写模式打开这个文件。</p>
<p>接下来，我们使用 writeUTF 方法将字符串”Hello, 沉默王二!”写入文件。然后，我们使用 seek 方法将文件指针移动到文件开头，并使用 readUTF 方法读取文件内容。输出应该是”Hello, 沉默王二!”。</p>
<p>最后，我们使用try-with-resources语句确保 RandomAccessFile 在操作完成后被正确关闭。</p>
<p><strong>Apache FileUtils 类 </strong></p>
<p>FileUtils 类是 Apache Commons IO 库中的一个类，提供了一些更为方便的方法来操作文件或目录。</p>
<p><strong>1）复制文件或目录：</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">File srcFile = new File(&quot;path/to/src/file&quot;);</span><br><span class="line">File destFile = new File(&quot;path/to/dest/file&quot;);</span><br><span class="line">// 复制文件</span><br><span class="line">FileUtils.copyFile(srcFile, destFile);</span><br><span class="line">// 复制目录</span><br><span class="line">FileUtils.copyDirectory(srcFile, destFile);</span><br></pre></td></tr></table></figure>
<p><strong>2）删除文件或目录： </strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File file = new File(&quot;path/to/file&quot;);</span><br><span class="line">// 删除文件或目录</span><br><span class="line">FileUtils.delete(file);</span><br></pre></td></tr></table></figure>
<p>需要注意的是，如果要删除一个非空目录，需要先删除目录中的所有文件和子目录。</p>
<p><strong>3）移动文件或目录： </strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">File srcFile = new File(&quot;path/to/src/file&quot;);</span><br><span class="line">File destFile = new File(&quot;path/to/dest/file&quot;);</span><br><span class="line">// 移动文件或目录</span><br><span class="line">FileUtils.moveFile(srcFile, destFile);</span><br></pre></td></tr></table></figure>
<p><strong>4）查询文件或目录的信息： </strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">File file = new File(&quot;path/to/file&quot;);</span><br><span class="line">// 获取文件或目录的修改时间</span><br><span class="line">Date modifyTime = FileUtils.lastModified(file);</span><br><span class="line">// 获取文件或目录的大小</span><br><span class="line">long size = FileUtils.sizeOf(file);</span><br><span class="line">// 获取文件或目录的扩展名</span><br><span class="line">String extension = FileUtils.getExtension(file.getName());</span><br></pre></td></tr></table></figure>
<p><strong>Hutool FileUtil 类 </strong></p>
<p>FileUtil 类是 Hutool 工具包中的文件操作工具类，提供了一系列简单易用的文件操作方法，可以帮助 Java 开发者快速完成文件相关的操作任务。</p>
<p>FileUtil 类包含以下几类操作工具：</p>
<ul>
<li>文件操作：包括文件目录的新建、删除、复制、移动、改名等</li>
<li>文件判断：判断文件或目录是否非空，是否为目录，是否为文件等等。</li>
<li>绝对路径：针对 ClassPath 中的文件转换为绝对路径文件。</li>
<li>文件名：主文件名，扩展名的获取</li>
<li>读操作：包括 getReader、readXXX 操作</li>
<li>写操作：包括 getWriter、writeXXX 操作</li>
</ul>
<p>下面是 FileUtil 类中一些常用的方法：</p>
<p>1、copyFile：复制文件。该方法可以将指定的源文件复制到指定的目标文件中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File dest = FileUtil.file(&quot;FileUtilDemo2.java&quot;);</span><br></pre></td></tr></table></figure>
<p>2、move：移动文件或目录。该方法可以将指定的源文件或目录移动到指定的目标文件或目录中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileUtil.move(file, dest, true);</span><br></pre></td></tr></table></figure>
<p>3、del：删除文件或目录。该方法可以删除指定的文件或目录，如果指定的文件或目录不存在，则会抛出异常。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileUtil.del(file);</span><br></pre></td></tr></table></figure>
<p>4、rename：重命名文件或目录。该方法可以将指定的文件或目录重命名为指定的新名称。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileUtil.rename(file, &quot;FileUtilDemo3.java&quot;, true);</span><br></pre></td></tr></table></figure>
<p>5、readLines：从文件中读取每一行数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileUtil.readLines(file, &quot;UTF-8&quot;).forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>更多方法，可以去看一下 hutool 的源码，里面有非常多实用的方法，多看看，绝对能提升不少编程水平。</p>
<h2 id="5-3-字节流"><a href="#5-3-字节流" class="headerlink" title="5.3 字节流"></a>5.3 字节流</h2><p>我们必须得明确一点，一切文件（文本、视频、图片）的数据都是以二进制的形式存储的，传输时也是。所以，字节流可以传输任意类型的文件数据。</p>
<p><strong>字节输出流（OutputStream） </strong></p>
<p>java.io.OutputStream 是字节输出流的超类（父类），我们来看一下它定义的一些共性方法：</p>
<p>1、 close() ：关闭此输出流并释放与此流相关联的系统资源。</p>
<p>2、 flush() ：刷新此输出流并强制缓冲区的字节被写入到目的地。</p>
<p>3、 write(byte[] b) ：将 b.length 个字节从指定的字节数组写入此输出流。</p>
<p>4、 write(byte[] b, int off, int len) ：从指定的字节数组写入 len 字节到此输出流，从偏移量 off开始。 <strong>也就是说从off个字节数开始一直到len个字节结束</strong></p>
<p><strong>FileOutputStream类 </strong></p>
<p>OutputStream 有很多子类，我们从最简单的一个子类 FileOutputStream 开始。看名字就知道是文件输出流，用于将数据写入到文件。</p>
<p><strong>1）FileOutputStrea 的构造方法 </strong></p>
<p>1、使用文件名创建 FileOutputStream 对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String fileName = &quot;example.txt&quot;;</span><br><span class="line">FileOutputStream fos = new FileOutputStream(fileName);</span><br></pre></td></tr></table></figure>
<p>以上代码使用文件名 “example.txt” 创建一个 FileOutputStream 对象，将数据写入到该文件中。<strong>如果文件不存在，则创建一个新文件；如果文件已经存在，则覆盖原有文件。</strong></p>
<p>2、使用文件对象创建 FileOutputStream 对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File file = new File(&quot;example.txt&quot;);</span><br><span class="line">FileOutputStream fos = new FileOutputStream(file);</span><br></pre></td></tr></table></figure>
<p>FileOutputStream 的使用示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fos = null;</span><br><span class="line">try &#123;</span><br><span class="line">  fos = new FileOutputStream(&quot;example.txt&quot;);</span><br><span class="line">  fos.write(&quot;沉默王二&quot;.getBytes());</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">  if (fos != null) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      fos.close();</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码创建了一个 FileOutputStream 对象，将字符串 “沉默王二” 写入到 example.txt 文件中，并在最后关闭了输出流。</p>
<p><strong>2）FileOutputStream 写入字节数据 </strong></p>
<p>使用 FileOutputStream 写入字节数据主要通过 write 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">write(int b)</span><br><span class="line">write(byte[] b)</span><br><span class="line">write(byte[] b,int off,int len)  //从òff`索引开始，`len`个字节</span><br></pre></td></tr></table></figure>
<p>①、写入字节： write(int b) 方法，每次可以写入一个字节，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 使用文件名称创建流对象</span><br><span class="line">FileOutputStream fos = new FileOutputStream(&quot;fos.txt&quot;);     </span><br><span class="line">// 写出数据</span><br><span class="line">fos.write(97); // 第1个字节</span><br><span class="line">fos.write(98); // 第2个字节</span><br><span class="line">fos.write(99); // 第3个字节</span><br><span class="line">// 关闭资源</span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure>
<p>字符 a 的 ASCII 值为 97，字符 b 的ASCII 值为 98，字符 b 的ASCII 值为 99。也就是说，以上代码可以写成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 使用文件名称创建流对象</span><br><span class="line">FileOutputStream fos = new FileOutputStream(&quot;fos.txt&quot;);     </span><br><span class="line">// 写出数据</span><br><span class="line">fos.write(&#x27;a&#x27;); // 第1个字节</span><br><span class="line">fos.write(&#x27;b&#x27;); // 第2个字节</span><br><span class="line">fos.write(&#x27;c&#x27;); // 第3个字节</span><br><span class="line">// 关闭资源</span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure>
<p>当使用 write(int b) 方法写出一个字节时，参数 b 表示要写出的字节的整数值。由于一个字节只有8位，因此参数 b 的取值范围应该在 0 到 255 之间，超出这个范围的值将会被截断。例如，如果参数 b 的值为 -1，那么它会被截断为 255，如果参数 b 的值为 256，那么它会被截断为 0。</p>
<p>在将参数 b 写入输出流中时，write(int b) 方法只会将参数 b 的低8位写入，而忽略高24位。这是因为在 Java 中，整型类型（包括 byte、short、int、long）在内存中以二进制补码形式表示。当将一个整型值传递给 write(int b) 方法时，方法会将该值转换为 byte 类型，只保留二进制补码的低8位，而忽略高24位。</p>
<p>例如，如果要写出的整数为 0x12345678，它的二进制补码表示为 0001 0010 0011 0100 0101 0110 0111 1000。当使用 write(int b) 方法写出该整数时，只会将二进制补码的低8位 0111 1000 写出，而忽略高24位 0001 0010 0011 0100 0101 0110。这就是参数 b 的高24位被忽略的原因。</p>
<p>0111 1000 是一个8位的二进制数，它对应的十进制数是 120，对应的 ASCII 码字符是小写字母 “x”。在 ASCII 码表中，小写字母 “x” 的十进制 ASCII 码值为 120。因此，如果使用 write(int b) 方法写出一个字节值为 0x78（十进制为 120），那么写出的结果就是小写字母 “x”。</p>
<p>我们来验证一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fos = null;</span><br><span class="line">try &#123;</span><br><span class="line">    fos = new FileOutputStream(&quot;example.txt&quot;);</span><br><span class="line">    fos.write(120);</span><br><span class="line">    fos.write(&#x27;x&#x27;);</span><br><span class="line">    fos.write(0x12345678);</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    if (fos != null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            fos.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看一下结果：</p>
<p><img src="\assets\note\image-20231011100559469.png" alt="image-20231011100559469"></p>
<p>果然是 3 个 x。</p>
<p>②、写入字节数组： write(byte[] b) ，代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 使用文件名称创建流对象</span><br><span class="line">FileOutputStream fos = new FileOutputStream(&quot;fos.txt&quot;);     </span><br><span class="line">// 字符串转换为字节数组</span><br><span class="line">byte[] b = &quot;沉默王二有点帅&quot;.getBytes();</span><br><span class="line">// 写入字节数组数据</span><br><span class="line">fos.write(b);</span><br><span class="line">// 关闭资源</span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure>
<p>③、写入指定长度字节数组： write(byte[] b, int off, int len) ，代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 使用文件名称创建流对象</span><br><span class="line">FileOutputStream fos = new FileOutputStream(&quot;fos.txt&quot;);     </span><br><span class="line">// 字符串转换为字节数组</span><br><span class="line">byte[] b = &quot;abcde&quot;.getBytes();</span><br><span class="line">// 从索引2开始，2个字节。索引2是c，两个字节，也就是cd。</span><br><span class="line">fos.write(b,2,2);</span><br><span class="line">// 关闭资源</span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure>
<p><strong>3）FileOutputStream实现数据追加、换行 </strong></p>
<p>在上面的代码示例中，每次运行程序都会创建新的输出流对象，于是文件中的数据也会被清空。如果想保留目标文件中的数据，还能继续追加新数据，该怎么办呢？以及如何实现换行呢？</p>
<p>其实很简单。</p>
<p>我们来学习 FileOutputStream的另外两个构造方法，如下：</p>
<p>1、使用文件名和追加标志创建 FileOutputStream 对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String fileName = &quot;example.txt&quot;;</span><br><span class="line">boolean append = true;</span><br><span class="line">FileOutputStream fos = new FileOutputStream(fileName, append);</span><br></pre></td></tr></table></figure>
<p>以上代码使用文件名 “example.txt” 和追加标志创建一个 FileOutputStream 对象，将数据追加到该文件的末尾。如果文件不存在，则创建一个新文件；如果文件已经存在，则在文件末尾追加数据。</p>
<p>2、使用文件对象和追加标志创建 FileOutputStream 对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File file = new File(&quot;example.txt&quot;);</span><br><span class="line">boolean append = true;</span><br><span class="line">FileOutputStream fos = new FileOutputStream(file, append);</span><br></pre></td></tr></table></figure>
<p>以上代码使用文件对象和追加标志创建一个 FileOutputStream 对象，将数据追加到该文件的末尾。</p>
<p>这两个构造方法，第二个参数中都需要传入一个boolean类型的值， true 表示追加数据， false 表示不追加也就是清空原有数据。</p>
<p>实现数据追加代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 使用文件名称创建流对象</span><br><span class="line">FileOutputStream fos = new FileOutputStream(&quot;fos.txt&quot;,true);     </span><br><span class="line">// 字符串转换为字节数组</span><br><span class="line">byte[] b = &quot;abcde&quot;.getBytes();</span><br><span class="line">// 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。</span><br><span class="line">fos.write(b);</span><br><span class="line">// 关闭资源</span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure>
<p>多次运行代码，你会发现数据在不断地追加。</p>
<p>在 Windows 系统中，换行符号是 \r\n ，具体代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String filename = &quot;example.txt&quot;;</span><br><span class="line">FileOutputStream fos = new FileOutputStream(filename, true);  // 追加模式</span><br><span class="line">String content = &quot;沉默王二\r\n&quot;;  // 使用回车符和换行符的组合</span><br><span class="line">fos.write(content.getBytes());</span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure>
<p>在 macOS 系统中，换行符是 \n ，具体代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String filename = &quot;example.txt&quot;;</span><br><span class="line">FileOutputStream fos = new FileOutputStream(filename, true);  // 追加模式</span><br><span class="line">String content = &quot;沉默王二\n&quot;;  // 只使用换行符</span><br><span class="line">fos.write(content.getBytes());</span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure>
<p>这里再唠一唠回车符和换行符。</p>
<p>回车符（ \r ）和换行符（ \n ）是计算机中常见的控制字符，用于表示一行的结束或者换行的操作。它们在不同的操作系统和编程语言中的使用方式可能有所不同。</p>
<p>在 Windows 系统中，通常使用回车符和换行符的组合（ \r\n ）来表示一行的结束。在文本文件中，每行的末尾都会以一个回车符和一个换行符的组合结束。这是由于早期的打印机和终端设备需要回车符和换行符的组合来完成一行的结束和换行操作。在 Windows 中，文本编辑器和命令行终端等工具都支持使用回车符和换行符的组合来表示一行的结束。</p>
<p>而在 macOS 和 Linux 系统中，通常只使用换行符（ \n ）来表示一行的结束。在文本文件中，每行的末尾只有一个换行符。这是由于早期 Unix 系统中的终端设备只需要换行符来完成一行的结束和跨行操作。在 macOS 和 Linux 中，文本编辑器和终端等工具都支持使用换行符来表示一行的结束。</p>
<p>在编程语言中，通常也会使用回车符和换行符来进行字符串的操作。例如，在 Java 中，字符串中的回车符可以用 “ \r “ 来表示，换行符可以用 “ \n “ 来表示。在通过输入输出流进行文件读写时，也需要注意回车符和换行符的使用方式和操作系统的差异。</p>
<p><strong>字节输入流（InputStream） </strong></p>
<p>java.io.InputStream 是字节输入流的超类（父类），我们来看一下它的一些共性方法：</p>
<p>1、 close() ：关闭此输入流并释放与此流相关的系统资源。</p>
<p>2、 int read() ： 从输入流读取数据的下一个字节。</p>
<p>3、 read(byte[] b) ： 该方法返回的 int 值代表的是读取了多少个字节，读到几个返回几个，读取不到返回-1</p>
<p><strong>FileInputStream类 </strong></p>
<p>InputStream 有很多子类，我们从最简单的一个子类 FileInputStream 开始。看名字就知道是文件输入流，用于将数据从文件中读取数据。</p>
<p><strong>1）FileInputStream的构造方法 </strong></p>
<p>1、 FileInputStream(String name) ：创建一个 FileInputStream 对象，并打开指定名称的文件进行读取。文件名由 name 参数指定。如果文件不存在，将会抛出 FileNotFoundException 异常。</p>
<p>2、 FileInputStream(File file) ：创建一个 FileInputStream 对象，并打开指定的 File 对象表示的文件进行读取。</p>
<p>代码示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 FileInputStream 对象</span><br><span class="line">FileInputStream fis = new FileInputStream(&quot;test.txt&quot;);</span><br><span class="line">// 读取文件内容</span><br><span class="line">int data;</span><br><span class="line">while ((data = fis.read()) != -1) &#123;</span><br><span class="line">    System.out.print((char) data);</span><br><span class="line">&#125;</span><br><span class="line">// 关闭输入流</span><br><span class="line">fis.close();</span><br></pre></td></tr></table></figure>
<p><strong>2）FileInputStream读取字节数据 </strong></p>
<p>①、读取字节： read()方法会读取一个字节并返回其整数表示。如果已经到达文件的末尾，则返回 -1。如果在读取时发生错误，则会抛出 IOException 异常。</p>
<p>代码示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 FileInputStream 对象</span><br><span class="line">FileInputStream fis = new FileInputStream(&quot;test.txt&quot;);</span><br><span class="line">// 读取文件内容</span><br><span class="line">int data;</span><br><span class="line">while ((data = fis.read()) != -1) &#123;</span><br><span class="line">    System.out.print((char) data);</span><br><span class="line">&#125;</span><br><span class="line">// 关闭输入流</span><br><span class="line">fis.close();</span><br></pre></td></tr></table></figure>
<p>②、使用字节数组读取： read(byte[] b) 方法会从输入流中最多读取 b.length 个字节，并将它们存储到缓冲区数组 b 中。</p>
<p>代码示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 FileInputStream 对象</span><br><span class="line">FileInputStream fis = new FileInputStream(&quot;test.txt&quot;);</span><br><span class="line">// 读取文件内容到缓冲区</span><br><span class="line">byte[] buffer = new byte[1024];</span><br><span class="line">int count;</span><br><span class="line">while ((count = fis.read(buffer)) != -1) &#123;</span><br><span class="line">    System.out.println(new String(buffer, 0, count));</span><br><span class="line">&#125;</span><br><span class="line">// 关闭输入流</span><br><span class="line">fis.close();</span><br></pre></td></tr></table></figure>
<p><strong>3）字节流FileInputstream复制图片 </strong></p>
<p>原理很简单，就是把图片信息读入到字节输入流中，再通过字节输出流写入到文件中。</p>
<p>代码示例如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 FileInputStream 对象以读取原始图片文件</span><br><span class="line">FileInputStream fis = new FileInputStream(&quot;original.jpg&quot;);</span><br><span class="line">// 创建一个 FileOutputStream 对象以写入复制后的图片文件</span><br><span class="line">FileOutputStream fos = new FileOutputStream(&quot;copy.jpg&quot;);</span><br><span class="line">// 创建一个缓冲区数组以存储读取的数据</span><br><span class="line">byte[] buffer = new byte[1024];</span><br><span class="line">int count;</span><br><span class="line">// 读取原始图片文件并将数据写入复制后的图片文件</span><br><span class="line">while ((count = fis.read(buffer)) != -1) &#123;</span><br><span class="line">    fos.write(buffer, 0, count);</span><br><span class="line">&#125;</span><br><span class="line">// 关闭输入流和输出流</span><br><span class="line">fis.close();</span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure>
<p>上面的代码创建了一个 FileInputStream 对象以读取原始图片文件，并创建了一个 FileOutputStream 对象以写入复制后的图片文件。然后，使用 while 循环逐个读取原始图片文件中的字节，并将其写入复制后的图片文件中。最后，关闭输入流和输出流释放资源。</p>
<p><strong>小结 </strong></p>
<p>InputStream 是字节输入流的抽象类，它定义了读取字节数据的方法，如 read() 、 read(byte[] b) 、read(byte[] b, int off, int len) 等。OutputStream 是字节输出流的抽象类，它定义了写入字节数据的方法，如 write(int b) 、 write(byte[] b) 、 write(byte[] b, int off, int len) 等。这两个抽象类是字节流的基础。</p>
<p>FileInputStream 是从文件中读取字节数据的流，它继承自 InputStream。FileOutputStream 是将字节数据写入文件的流，它继承自 OutputStream。这两个类是字节流最常用的实现类之一。</p>
<h2 id="5-4-字符流"><a href="#5-4-字符流" class="headerlink" title="5.4 字符流"></a>5.4 字符流</h2><p>字符流 Reader 和 Writer 的故事要从它们的类关系图开始，来看图。</p>
<p><img src="\assets\note\image-20231011101237315.png" alt="image-20231011101237315"></p>
<p>字符流是一种用于读取和写入字符数据的输入输出流。与字节流不同，字符流以字符为单位读取和写入数据，而不是以字节为单位。常用来处理文本信息。</p>
<p>如果用字节流直接读取中文，可能会遇到乱码问题，见下例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//FileInputStream为操作文件的字符输入流</span><br><span class="line">FileInputStream inputStream = new FileInputStream(&quot;a.txt&quot;);//内容为“沉默王二是傻 X”</span><br><span class="line">int len;</span><br><span class="line">while ((len=inputStream.read())!=-1)&#123;</span><br><span class="line">    System.out.print((char)len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">运行结果：   æ²•é»•ç••äº•æ•¯å•» X</span><br></pre></td></tr></table></figure>
<p>看一下截图：</p>
<p><img src="\assets\note\image-20231011101330869.png" alt="image-20231011101330869"></p>
<p>之所以出现乱码是因为在字节流中，一个字符通常由多个字节组成，而不同的字符编码使用的字节数不同。如果我们使用了错误的字符编码，或者在读取和写入数据时没有正确处理字符编码的转换，就会导致读取出来的中文字符出现乱码。</p>
<p>例如，当我们使用默认的字符编码（见上例）读取一个包含中文字符的文本文件时，就会出现乱码。因为默认的字符编码通常是 ASCII 编码，它只能表示英文字符，而不能正确地解析中文字符。</p>
<p>那使用字节流该如何正确地读出中文呢？见下例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try (FileInputStream inputStream = new FileInputStream(&quot;a.txt&quot;)) &#123;</span><br><span class="line">    byte[] bytes = new byte[1024];</span><br><span class="line">    int len;</span><br><span class="line">    while ((len = inputStream.read(bytes)) != -1) &#123;</span><br><span class="line">        System.out.print(new String(bytes, 0, len));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么这种方式就可以呢？</p>
<p>因为我们拿 String 类进行了解码，查看 new String(byte bytes[], int offset, int length)的源码就可以发现，该构造方法有解码功能：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public String(byte bytes[], int offset, int length) &#123;</span><br><span class="line">    checkBounds(bytes, offset, length);</span><br><span class="line">    this.value = StringCoding.decode(bytes, offset, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续追看 StringCoding.decode() 方法调用的 defaultCharset() 方法，会发现默认编码是 UTF-8 ，代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static Charset defaultCharset() &#123;</span><br><span class="line">    if (defaultCharset == null) &#123;</span><br><span class="line">        synchronized (Charset.class) &#123;</span><br><span class="line">            if (cs != null)</span><br><span class="line">                defaultCharset = cs;</span><br><span class="line">            else</span><br><span class="line">                defaultCharset = forName(&quot;UTF-8&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return defaultCharset;</span><br><span class="line">&#125;</span><br><span class="line">static char[] decode(byte[] ba, int off, int len) &#123;</span><br><span class="line">    String csn = Charset.defaultCharset().name();</span><br><span class="line">    try &#123;</span><br><span class="line">        // use charset name decode() variant which provides caching.</span><br><span class="line">        return decode(csn, ba, off, len);</span><br><span class="line">    &#125; catch (UnsupportedEncodingException x) &#123;</span><br><span class="line">        warnUnsupportedCharset(csn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Java 中，常用的字符编码有 ASCII、ISO-8859-1、UTF-8、UTF-16 等。其中，ASCII 和 ISO-8859-1 只能表示部分字符，而 UTF-8 和 UTF-16 可以表示所有的 Unicode 字符，包括中文字符。</p>
<p>当我们使用 new String(byte bytes[], int offset, int length) 将字节流转换为字符串时，Java 会根据 UTF-8 的规则将每 3 个字节解码为一个中文字符，从而正确地解码出中文。</p>
<p>尽管字节流也有办法解决乱码问题，但不够直接，于是就有了字符流，专门用于处理文本文件（音频、图片、视频等为非文本文件）。</p>
<p>从另一角度来说：字符流 = 字节流 + 编码表</p>
<p><strong>01、字符输入流（Reader） </strong></p>
<p>java.io.Reader是字符输入流的超类（父类），它定义了字符输入流的一些共性方法：</p>
<p>1、 close() ：关闭此流并释放与此流相关的系统资源。</p>
<p>2、 read() ：从输入流读取一个字符。</p>
<p>3、 read(char[] cbuf) ：从输入流中读取一些字符，并将它们存储到字符数组 cbuf中</p>
<p>FileReader 是 Reader 的子类，用于从文件中读取字符数据。它的主要特点如下：</p>
<ul>
<li>可以通过构造方法指定要读取的文件路径。</li>
<li>每次可以读取一个或多个字符。</li>
<li>可以读取 Unicode 字符集中的字符，通过指定字符编码来实现字符集的转换。</li>
</ul>
<p><strong>1）FileReader构造方法 </strong></p>
<p>1、 FileReader(File file) ：创建一个新的 FileReader，参数为File对象。</p>
<p>2、 FileReader(String fileName) ：创建一个新的 FileReader，参数为文件名。</p>
<p>代码示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 使用File对象创建流对象</span><br><span class="line">File file = new File(&quot;a.txt&quot;);</span><br><span class="line">FileReader fr = new FileReader(file);</span><br><span class="line">// 使用文件名称创建流对象</span><br><span class="line">FileReader fr = new FileReader(&quot;b.txt&quot;);</span><br></pre></td></tr></table></figure>
<p><strong>2）FileReader读取字符数据 </strong></p>
<p>①、读取字符： read方法，每次可以读取一个字符，返回读取的字符（转为 int 类型），当读取到文件末尾时，返回 -1 。代码示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 使用文件名称创建流对象</span><br><span class="line">FileReader fr = new FileReader(&quot;abc.txt&quot;);</span><br><span class="line">// 定义变量，保存数据</span><br><span class="line">int b;</span><br><span class="line">// 循环读取</span><br><span class="line">while ((b = fr.read())!=-1) &#123;</span><br><span class="line">    System.out.println((char)b);</span><br><span class="line">&#125;</span><br><span class="line">// 关闭资源</span><br><span class="line">fr.close();</span><br></pre></td></tr></table></figure>
<p>②、读取指定长度的字符： read(char[] cbuf, int off, int len) ，并将其存储到字符数组中。其中，cbuf 表示存储读取结果的字符数组，off 表示存储结果的起始位置，len 表示要读取的字符数。代码示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">File textFile = new File(&quot;docs/约定.md&quot;);</span><br><span class="line">// 给一个 FileReader 的示例</span><br><span class="line">// try-with-resources FileReader</span><br><span class="line">try(FileReader reader = new FileReader(textFile);) &#123;</span><br><span class="line">    // read(char[] cbuf)</span><br><span class="line">    char[] buffer = new char[1024];</span><br><span class="line">    int len;</span><br><span class="line">    while ((len = reader.read(buffer, 0, buffer.length)) != -1) &#123;</span><br><span class="line">        System.out.print(new String(buffer, 0, len));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，使用 FileReader 从文件中读取字符数据，并将其存储到一个大小为 1024 的字符数组中。每次读取 len 个字符，然后使用 String 构造方法将其转换为字符串并输出。</p>
<p>FileReader 实现了 AutoCloseable 接口，因此可以使用 try-with-resources 语句自动关闭资源，避免了手动关闭资源的繁琐操作。</p>
<p><strong>02、字符输出流（Writer） </strong></p>
<p>java.io.Writer 是字符输出流类的超类（父类），可以将指定的字符信息写入到目的地，来看它定义的一些共性方法：</p>
<p>1、 write(int c) 写入单个字符。</p>
<p>2、 write(char[] cbuf) 写入字符数组。</p>
<p>3、 write(char[] cbuf, int off, int len) 写入字符数组的一部分，off为开始索引，len为字符个数。</p>
<p>4、 write(String str) 写入字符串。</p>
<p>5、 write(String str, int off, int len) 写入字符串的某一部分，off 指定要写入的子串在 str 中的起始位置，len 指定要写入的子串的长度。</p>
<p>6、 flush() 刷新该流的缓冲。</p>
<p>7、 close() 关闭此流，但要先刷新它。</p>
<p>java.io.FileWriter 类是 Writer 的子类，用来将字符写入到文件。</p>
<p><strong>1）FileWriter 构造方法 </strong></p>
<ul>
<li>FileWriter(File file) ： 创建一个新的 FileWriter，参数为要读取的File对象。</li>
<li>FileWriter(String fileName) ： 创建一个新的 FileWriter，参数为要读取的文件的名称。</li>
</ul>
<p>代码示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 第一种：使用File对象创建流对象</span><br><span class="line">File file = new File(&quot;a.txt&quot;);</span><br><span class="line">FileWriter fw = new FileWriter(file);</span><br><span class="line">// 第二种：使用文件名称创建流对象</span><br><span class="line">FileWriter fw = new FileWriter(&quot;b.txt&quot;);</span><br></pre></td></tr></table></figure>
<p><strong>2）FileWriter写入数据 </strong></p>
<p>①、写入字符： write(int b) 方法，每次可以写出一个字符，代码示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">FileWriter fw = null;</span><br><span class="line">try &#123;</span><br><span class="line">    fw = new FileWriter(&quot;output.txt&quot;);</span><br><span class="line">    fw.write(72); // 写入字符&#x27;H&#x27;的ASCII码</span><br><span class="line">    fw.write(101); // 写入字符&#x27;e&#x27;的ASCII码</span><br><span class="line">    fw.write(108); // 写入字符&#x27;l&#x27;的ASCII码</span><br><span class="line">    fw.write(108); // 写入字符&#x27;l&#x27;的ASCII码</span><br><span class="line">    fw.write(111); // 写入字符&#x27;o&#x27;的ASCII码</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        if (fw != null) &#123;</span><br><span class="line">            fw.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例代码中，首先创建一个 FileWriter 对象 fw，并指定要写入的文件路径 “output.txt”。然后使用 fw.write() 方法将字节写入文件中，这里分别写入字符’H’、’e’、’l’、’l’、’o’的 ASCII 码。最后在 finally 块中关闭 FileWriter 对象，释放资源。</p>
<p>需要注意的是，使用 write(int b) 方法写入的是一个字节，而不是一个字符。如果需要写入字符，可以使用 write(char cbuf[]) 或 write(String str) 方法。</p>
<p>②、写入字符数组： write(char[] cbuf) 方法，将指定字符数组写入输出流。代码示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">FileWriter fw = null;</span><br><span class="line">try &#123;</span><br><span class="line">    fw = new FileWriter(&quot;output.txt&quot;);</span><br><span class="line">    char[] chars = &#123;&#x27;H&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;&#125;;</span><br><span class="line">    fw.write(chars); // 将字符数组写入文件</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        if (fw != null) &#123;</span><br><span class="line">            fw.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>③、写入指定字符数组： write(char[] cbuf, int off, int len) 方法，将指定字符数组的一部分写入输出流。代码示例如下（重复的部分就不写了哈，参照上面的部分）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fw = new FileWriter(&quot;output.txt&quot;);</span><br><span class="line">    char[] chars = &#123;&#x27;H&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;,&#x27;, &#x27; &#x27;, &#x27;W&#x27;, &#x27;o&#x27;, &#x27;r&#x27;, &#x27;l&#x27;, &#x27;d&#x27;, </span><br><span class="line">&#x27;!&#x27;&#125;;</span><br><span class="line">fw.write(chars, 0, 5); // 将字符数组的前 5 个字符写入文件</span><br></pre></td></tr></table></figure>
<p>使用 fw.write() 方法将字符数组的前 5 个字符写入文件中。</p>
<p>④、写入字符串： write(String str) 方法，将指定字符串写入输出流。代码示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fw = new FileWriter(&quot;output.txt&quot;);</span><br><span class="line">String str = &quot;沉默王二&quot;;</span><br><span class="line">fw.write(str); // 将字符串写入文件</span><br></pre></td></tr></table></figure>
<p>⑤、写入指定字符串： write(String str, int off, int len) 方法，将指定字符串的一部分写入输出流。代码示例如下（try-with-resources形式）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;沉默王二真的帅啊！&quot;;</span><br><span class="line">try (FileWriter fw = new FileWriter(&quot;output.txt&quot;)) &#123;</span><br><span class="line">    fw.write(str, 0, 5); // 将字符串的前 5 个字符写入文件</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>【注意】如果不关闭资源，数据只是保存到缓冲区，并未保存到文件中。</p>
</blockquote>
<p><strong>3）关闭close和刷新flush </strong></p>
<p>因为 FileWriter 内置了缓冲区 ByteBuffer，所以如果不关闭输出流，就无法把字符写入到文件中。</p>
<p><img src="\assets\note\image-20231011102644327.png" alt="image-20231011102644327"></p>
<p>但是关闭了流对象，就无法继续写数据了。如果我们既想写入数据，又想继续使用流，就需要 flush 方法了。</p>
<p>flush ：刷新缓冲区，流对象可以继续使用。</p>
<p>close ：先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。</p>
<p>flush还是比较有趣的，来段代码体会体会：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//源   也就是输入流【读取流】 读取a.txt文件</span><br><span class="line">FileReader fr=new FileReader(&quot;abc.txt&quot;);  //必须要存在a.txt文件，否则报</span><br><span class="line">FileNotFoundException异常</span><br><span class="line">//目的地  也就是输出流</span><br><span class="line">FileWriter fw=new FileWriter(&quot;b.txt&quot;);  //系统会自动创建b.txt，因为它是输出流！</span><br><span class="line">int len;</span><br><span class="line">while((len=fr.read())!=-1)&#123;</span><br><span class="line">    fw.write(len);</span><br><span class="line">&#125;</span><br><span class="line">//注意这里是没有使用close关闭流，开发中不能这样做，但是为了更好的体会flush的作用</span><br></pre></td></tr></table></figure>
<p>运行效果是怎么样的呢？答案是b.txt文件中依旧是空的，并没有任何东西。</p>
<p><img src="\assets\note\image-20231011102734614.png" alt="image-20231011102734614"></p>
<p>原因我们前面已经说过了。编程就是这样，不去敲，永远学不会！！！所以一定要去敲，多敲啊！！！</p>
<p>在以上的代码中再添加下面三句代码，b.txt文件就能复制到源文件的数据了！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fr.close();</span><br><span class="line">fw.flush();</span><br><span class="line">fw.close();</span><br></pre></td></tr></table></figure>
<p>flush()这个方法是清空缓存的意思，用于清空缓冲区的数据流，进行流的操作时，数据先被读到内存中，然后再把数据写到文件中。</p>
<p>你可以使用下面的代码示例再体验一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 使用文件名称创建流对象</span><br><span class="line">FileWriter fw = new FileWriter(&quot;fw.txt&quot;);</span><br><span class="line">// 写出数据，通过flush</span><br><span class="line">fw.write(&#x27;刷&#x27;); // 写出第1个字符</span><br><span class="line">fw.flush();</span><br><span class="line">fw.write(&#x27;新&#x27;); // 继续写出第2个字符，写出成功</span><br><span class="line">fw.flush();</span><br><span class="line">// 写出数据，然后close</span><br><span class="line">fw.write(&#x27;关&#x27;); // 写出第1个字符</span><br><span class="line">fw.close();</span><br><span class="line">fw.write(&#x27;闭&#x27;); // 继续写出第2个字符,【报错】java.io.IOException: Stream closed</span><br><span class="line">fw.close();</span><br></pre></td></tr></table></figure>
<p>注意，即便是flush方法写出了数据，操作的最后还是要调用close方法，释放系统资源。当然你也可以用 try-with-resources 的方式。</p>
<p><strong>4）FileWriter的续写和换行 </strong></p>
<p>续写和换行：操作类似于FileOutputStream操作，直接上代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 使用文件名称创建流对象，可以续写数据</span><br><span class="line">FileWriter fw = new FileWriter(&quot;fw.txt&quot;,true);     </span><br><span class="line">// 写出字符串</span><br><span class="line">fw.write(&quot;沉默王二&quot;);</span><br><span class="line">// 写出换行</span><br><span class="line">fw.write(&quot;\r\n&quot;);</span><br><span class="line">// 写出字符串</span><br><span class="line">fw.write(&quot;是傻 X&quot;);</span><br><span class="line">// 关闭资源</span><br><span class="line">fw.close();</span><br></pre></td></tr></table></figure>
<p>输出结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输出结果:</span><br><span class="line">沉默王二</span><br><span class="line">是傻 X</span><br></pre></td></tr></table></figure>
<p><strong>5）文本文件复制 </strong></p>
<p>直接上代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import java.io.FileReader;</span><br><span class="line">import java.io.FileWriter;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">public class CopyFile &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        //创建输入流对象</span><br><span class="line">        FileReader fr=new FileReader(&quot;aa.txt&quot;);//文件不存在会抛出</span><br><span class="line">java.io.FileNotFoundException</span><br><span class="line">        //创建输出流对象</span><br><span class="line">        FileWriter fw=new FileWriter(&quot;copyaa.txt&quot;);</span><br><span class="line">        /*创建输出流做的工作：</span><br><span class="line">         *      1、调用系统资源创建了一个文件</span><br><span class="line">         *      2、创建输出流对象</span><br><span class="line">         *      3、把输出流对象指向文件        </span><br><span class="line">         * */</span><br><span class="line">        //文本文件复制，一次读一个字符</span><br><span class="line">        copyMethod1(fr, fw);</span><br><span class="line">        //文本文件复制，一次读一个字符数组</span><br><span class="line">        copyMethod2(fr, fw);</span><br><span class="line">        </span><br><span class="line">        fr.close();</span><br><span class="line">        fw.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void copyMethod1(FileReader fr, FileWriter fw) throws IOException </span><br><span class="line">&#123;</span><br><span class="line">        int ch;</span><br><span class="line">        while((ch=fr.read())!=-1) &#123;//读数据</span><br><span class="line">            fw.write(ch);//写数据</span><br><span class="line">        &#125;</span><br><span class="line">        fw.flush();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void copyMethod2(FileReader fr, FileWriter fw) throws IOException </span><br><span class="line">&#123;</span><br><span class="line">        char chs[]=new char[1024];</span><br><span class="line">        int len=0;</span><br><span class="line">        while((len=fr.read(chs))!=-1) &#123;//读数据</span><br><span class="line">            fw.write(chs,0,len);//写数据</span><br><span class="line">        &#125;</span><br><span class="line">        fw.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>03、IO异常的处理 </strong></p>
<p>我们在学习的过程中可能习惯把异常抛出，而实际开发中建议使用 try…catch…finally 代码块，处理异常部分，格式代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 声明变量</span><br><span class="line">FileWriter fw = null;</span><br><span class="line">try &#123;</span><br><span class="line">    //创建流对象</span><br><span class="line">    fw = new FileWriter(&quot;fw.txt&quot;);</span><br><span class="line">    // 写出数据</span><br><span class="line">    fw.write(&quot;二哥真的帅&quot;); //哥敢摸si</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        if (fw != null) &#123;</span><br><span class="line">            fw.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者直接使用 try-with-resources 的方式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try (FileWriter fw = new FileWriter(&quot;fw.txt&quot;)) &#123;</span><br><span class="line">    // 写出数据</span><br><span class="line">    fw.write(&quot;二哥真的帅&quot;); //哥敢摸si</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个代码中，try-with-resources 会在 try 块执行完毕后自动关闭 FileWriter 对象 fw，不需要手动关闭流。如果在 try 块中发生了异常，也会自动关闭流并抛出异常。因此，使用 try-with-resources 可以让代码更加简洁、安全和易读。</p>
<p><strong>04、小结 </strong></p>
<p>Writer 和 Reader 是 Java I/O 中用于字符输入输出的抽象类，它们提供了一系列方法用于读取和写入字符数据。它们的区别在于 Writer 用于将字符数据写入到输出流中，而 Reader 用于从输入流中读取字符数据。</p>
<p>Writer 和 Reader 的常用子类有 FileWriter、FileReader，可以将字符流写入和读取到文件中。</p>
<p>在使用 Writer 和 Reader 进行字符输入输出时，需要注意字符编码的问题。</p>
<h2 id="5-5-缓冲流"><a href="#5-5-缓冲流" class="headerlink" title="5.5 缓冲流"></a>5.5 缓冲流</h2><p>Java 的缓冲流是对字节流和字符流的一种封装，通过在内存中开辟缓冲区来提高 I/O 操作的效率。Java 通过 BufferedInputStream 和 BufferedOutputStream 来实现字节流的缓冲，通过 BufferedReader 和 BufferedWriter 来实现字符流的缓冲。</p>
<p>缓冲流的工作原理是将数据先写入缓冲区中，当缓冲区满时再一次性写入文件或输出流，或者当缓冲区为空时一次性从文件或输入流中读取一定量的数据。这样可以减少系统的 I/O 操作次数，提高系统的 I/O 效率，从而提高程序的运行效率。</p>
<p><strong>01、字节缓冲流 </strong></p>
<p>BufferedInputStream 和 BufferedOutputStream 属于字节缓冲流，强化了字节流 InputStream 和 OutputStream，关于字节流，我们前面已经详细地讲过了。</p>
<p><strong>1）构造方法 </strong></p>
<ul>
<li>BufferedInputStream(InputStream in) ：创建一个新的缓冲输入流，注意参数类型为InputStream。</li>
<li>BufferedOutputStream(OutputStream out) ： 创建一个新的缓冲输出流，注意参数类型为OutputStream。</li>
</ul>
<p>代码示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 创建字节缓冲输入流，先声明字节流</span><br><span class="line">FileInputStream fps = new FileInputStream(b.txt);</span><br><span class="line">BufferedInputStream bis = new BufferedInputStream(fps)</span><br><span class="line">// 创建字节缓冲输入流（一步到位）</span><br><span class="line">BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;b.txt&quot;));</span><br><span class="line">// 创建字节缓冲输出流（一步到位）</span><br><span class="line">BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;b.txt&quot;));</span><br></pre></td></tr></table></figure>
<p><strong>2）缓冲流的高效 </strong></p>
<p>我们通过复制一个 370M+ 的大文件，来测试缓冲流的效率。为了做对比，我们先用基本流来实现一下，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 记录开始时间</span><br><span class="line">long start = System.currentTimeMillis();</span><br><span class="line">// 创建流对象</span><br><span class="line">try (FileInputStream fis = new FileInputStream(&quot;py.mp4&quot;);//exe文件够大</span><br><span class="line">        FileOutputStream fos = new FileOutputStream(&quot;copyPy.mp4&quot;))&#123;</span><br><span class="line">    // 读写数据</span><br><span class="line">    int b;</span><br><span class="line">    while ((b = fis.read()) != -1) &#123;</span><br><span class="line">        fos.write(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 记录结束时间</span><br><span class="line">long end = System.currentTimeMillis();</span><br><span class="line">System.out.println(&quot;普通流复制时间:&quot;+(end - start)+&quot; 毫秒&quot;);</span><br></pre></td></tr></table></figure>
<p>不好意思，我本机比较菜，10 分钟还在复制中。切换到缓冲流试一下，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 记录开始时间</span><br><span class="line">long start = System.currentTimeMillis();</span><br><span class="line">// 创建流对象</span><br><span class="line">try (BufferedInputStream bis = new BufferedInputStream(new </span><br><span class="line">FileInputStream(&quot;py.mp4&quot;));</span><br><span class="line">        BufferedOutputStream bos = new BufferedOutputStream(new </span><br><span class="line">FileOutputStream(&quot;copyPy.mp4&quot;));)&#123;</span><br><span class="line">    // 读写数据</span><br><span class="line">    int b;</span><br><span class="line">    while ((b = bis.read()) != -1) &#123;</span><br><span class="line">        bos.write(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 记录结束时间</span><br><span class="line">long end = System.currentTimeMillis();</span><br><span class="line">System.out.println(&quot;缓冲流复制时间:&quot;+(end - start)+&quot; 毫秒&quot;);</span><br></pre></td></tr></table></figure>
<p>只需要 8016 毫秒，如何更快呢？</p>
<p>可以换数组的方式来读写，这个我们前面也有讲到，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 记录开始时间</span><br><span class="line">long start = System.currentTimeMillis();</span><br><span class="line">// 创建流对象</span><br><span class="line">try (BufferedInputStream bis = new BufferedInputStream(new </span><br><span class="line">FileInputStream(&quot;py.mp4&quot;));</span><br><span class="line">        BufferedOutputStream bos = new BufferedOutputStream(new </span><br><span class="line">FileOutputStream(&quot;copyPy.mp4&quot;));)&#123;</span><br><span class="line">    // 读写数据</span><br><span class="line">    int len;</span><br><span class="line">    byte[] bytes = new byte[8*1024];</span><br><span class="line">    while ((len = bis.read(bytes)) != -1) &#123;</span><br><span class="line">        bos.write(bytes, 0 , len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 记录结束时间</span><br><span class="line">long end = System.currentTimeMillis();</span><br><span class="line">System.out.println(&quot;缓冲流使用数组复制时间:&quot;+(end - start)+&quot; 毫秒&quot;);</span><br></pre></td></tr></table></figure>
<p>这下就更快了，只需要 521 毫秒。</p>
<p><strong>3）为什么字节缓冲流会这么快？ </strong></p>
<p>传统的 Java IO 是阻塞模式的，它的工作状态就是“读/写，等待，读/写，等待。。。。。。”</p>
<p>字节缓冲流解决的就是这个问题：<strong>一次多读点多写点，减少读写的频率，用空间换时间。</strong></p>
<ul>
<li>减少系统调用次数：在使用字节缓冲流时，数据不是立即写入磁盘或输出流，而是先写入缓冲区，当缓冲区满时再一次性写入磁盘或输出流。这样可以减少系统调用的次数，从而提高 I/O 操作的效率。</li>
<li>减少磁盘读写次数：在使用字节缓冲流时，当需要读取数据时，缓冲流会先从缓冲区中读取数据，如果缓冲区中没有足够的数据，则会一次性从磁盘或输入流中读取一定量的数据。同样地，当需要写入数据时，缓冲流会先将数据写入缓冲区，如果缓冲区满了，则会一次性将缓冲区中的数据写入磁盘或输出流。这样可以减少磁盘读写的次数，从而提高 I/O 操作的效率。</li>
<li>提高数据传输效率：在使用字节缓冲流时，由于数据是以块的形式进行传输，因此可以减少数据传输的次数，从而提高数据传输的效率。</li>
</ul>
<p>我们来看 BufferedInputStream 的 read 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public synchronized int read() throws IOException &#123;</span><br><span class="line">    if (pos &gt;= count) &#123;     // 如果当前位置已经到达缓冲区末尾</span><br><span class="line">        fill();             // 填充缓冲区</span><br><span class="line">        if (pos &gt;= count)   // 如果填充后仍然到达缓冲区末尾，说明已经读取完毕</span><br><span class="line">            return -1;      // 返回 -1 表示已经读取完毕</span><br><span class="line">    &#125;</span><br><span class="line">    return getBufIfOpen()[pos++] &amp; 0xff; // 返回当前位置的字节，并将位置加 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码主要有两部分：</p>
<ul>
<li>fill() ：该方法会将缓冲 buf 填满。</li>
<li>getBufIfOpen()[pos++] &amp; 0xff ：返回当前读取位置 pos 处的字节（ getBufIfOpen()返回的是 buffer 数组，是 byte 类型），并将其与 0xff 进行位与运算。这里的目的是将读取到的字节 b 当做无符号的字节处理，因为 Java 的 byte 类型是有符号的，而将 b 与 0xff 进行位与运算，就可以将其转换为无符号的字节，其范围为 0 到 255。</li>
</ul>
<blockquote>
<p>byte &amp; 0xFF 我们一会再细讲。</p>
</blockquote>
<p>再来看 FileInputStream 的 read 方法：</p>
<p><img src="\assets\note\image-20231011103948813.png" alt="image-20231011103948813"></p>
<p>在这段代码中， read0() 方法是一个本地方法，它的实现是由底层操作系统提供的，并不是 Java 语言实现的。在不同的操作系统上， read0() 方法的实现可能会有所不同，但是它们的功能都是相同的，都是用于读取一个字节。</p>
<p>再来看一下 BufferedOutputStream 的 write(byte b[], int off, int len) 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void write(byte b[], int off, int len) throws IOException &#123;</span><br><span class="line">    if (len &gt;= buf.length) &#123;    // 如果写入的字节数大于等于缓冲区长度</span><br><span class="line">        flushBuffer();          // 先刷新缓冲区</span><br><span class="line">        out.write(b, off, len); // 直接将数据写入输出流</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (len &gt; buf.length - count) &#123; // 如果写入的字节数大于空余空间</span><br><span class="line">        flushBuffer();              // 先刷新缓冲区</span><br><span class="line">    &#125;</span><br><span class="line">    System.arraycopy(b, off, buf, count, len); // 将数据拷贝到缓冲区中</span><br><span class="line">    count += len;                             // 更新计数器</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，该方法会检查写入的字节数是否大于等于缓冲区长度，如果是，则先将缓冲区中的数据刷新到磁盘中，然后直接将数据写入输出流。这样做是为了避免缓冲流级联时的问题，即缓冲区的大小不足以容纳写入的数据时，可能会引发级联刷新，导致效率降低。</p>
<blockquote>
<p>级联问题（Cascade Problem）是指在一组缓冲流（Buffered Stream）中，由于缓冲区的大小不足以容纳要写入的数据，导致数据被分割成多个部分，并分别写入到不同的缓冲区中，最终需要逐个刷新缓冲区，从而导致性能下降的问题。</p>
</blockquote>
<p>其次，如果写入的字节数小于缓冲区长度，则检查缓冲区中剩余的空间是否足够容纳要写入的字节数，如果不够，则先将缓冲区中的数据刷新到磁盘中。然后，使用 System.arraycopy() 方法将要写入的数据拷贝到缓冲区中，并更新计数器 count。</p>
<p>最后，如果写入的字节数小于缓冲区长度且缓冲区中还有剩余空间，则直接将要写入的数据拷贝到缓冲区中，并更新计数器 count。</p>
<p>也就是说，只有当 buf 写满了，才会 flush，将数据刷到磁盘，默认一次刷 8192 个字节。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public BufferedOutputStream(OutputStream out) &#123;</span><br><span class="line">    this(out, 8192);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 buf 没有写满，会继续写 buf。</p>
<p><img src="\assets\note\image-20231011104153679.png" alt="image-20231011104153679"></p>
<p>当把 BufferedOutputStream 和 BufferedInputStream 配合起来使用后，就减少了大量的读写次数，尤其是 byte[] bytes = new byte[8*1024] ，就相当于缓冲区的空间有 8 个 1024 字节，那读写效率就会大大提高。</p>
<p><strong>4） byte &amp; 0xFF</strong></p>
<p>byte 类型通常被用于存储二进制数据，例如读取和写入文件、网络传输等场景。在这些场景下，byte 类型的变量可以用来存储数据流中的每个字节，从而进行读取和写入操作。</p>
<p>byte 类型是有符号的，即其取值范围为 -128 到 127。如果我们希望得到的是一个无符号的 byte 值，就需要使用 byte &amp; 0xFF 来进行转换。</p>
<p>这是因为 0xFF 是一个无符号的整数，它的二进制表示为 11111111。当一个 byte 类型的值与 0xFF 进行位与运算时，会将 byte 类型的值转换为一个无符号的整数，其范围为 0 到 255。</p>
<p>0xff 是一个十六进制的数，相当于二进制的 11111111，&amp; 运算符的意思是：如果两个操作数的对应位为 1，则输出 1，否则为 0；由于 0xff 有 8 个 1，单个 byte 转成 int 其实就是将 byte 和 int 类型的 255 进行(&amp;)与运算。</p>
<p>例如，如果我们有一个 byte 类型的变量 b，其值为 -1，那么 b &amp; 0xFF 的结果就是 255。这样就可以将一个有符号的 byte 类型的值转换为一个无符号的整数。</p>
<p>&amp; 运算是一种二进制数据的计算方式, 两个操作位都为1，结果才为1，否则结果为0. 在上面的 getBufIfOpen()[pos++] &amp; 0xff 计算过程中, byte 有 8bit, OXFF 是16进制的255, 表示的是 int 类型, int 有 32bit.</p>
<p>如果 getBufIfOpen()[pos++] 为 -118, 那么其原码表示为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00000000 00000000 00000000 10001010</span><br></pre></td></tr></table></figure>
<p>反码为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11111111 11111111 11111111 11110101</span><br></pre></td></tr></table></figure>
<p>补码为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11111111 11111111 11111111 11110110</span><br></pre></td></tr></table></figure>
<p>0XFF 表示16进制的数据255, 原码, 反码, 补码都是一样的, 其二进制数据为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00000000 00000000 00000000 11111111</span><br></pre></td></tr></table></figure>
<p>0XFF 和 -118 进行&amp;运算后结果为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00000000 00000000 00000000 11110110</span><br></pre></td></tr></table></figure>
<p>还原为原码后为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00000000 00000000 00000000 10001010</span><br></pre></td></tr></table></figure>
<p>其表示的 int 值为 138，可见将 byte 类型的 -118 与 0XFF 进行与运算后值由 -118 变成了 int 类型的 138，其中低8位和byte的-118完全一致。</p>
<p>顺带聊一下 原码、反码和补码。</p>
<p>①、原码</p>
<p>原码就是符号位加上真值的绝对值，即用第一位表示符号，其余位表示值。比如如果是8位二进制:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[+1]原 = 0000 0001</span><br><span class="line">[-1]原 = 1000 0001</span><br></pre></td></tr></table></figure>
<p>第一位是符号位。因为第一位是符号位，所以8位二进制数的取值范围就是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1111 1111 , 0111 1111]</span><br></pre></td></tr></table></figure>
<p>即</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[-127 , 127]</span><br></pre></td></tr></table></figure>
<p>②、反码</p>
<p>反码的表示方法是：</p>
<ul>
<li>正数的反码是其本身</li>
<li>负数的反码是在其原码的基础上，符号位不变，其余各个位取反。</li>
</ul>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[+1] = [00000001]原 = [00000001]反</span><br><span class="line">[-1] = [10000001]原 = [11111110]反</span><br></pre></td></tr></table></figure>
<p>可见如果一个反码表示的是负数，人脑无法直观的看出来它的数值。通常要将其转换成原码再计算。</p>
<p>③、补码</p>
<p>补码的表示方法是：</p>
<ul>
<li>正数的补码就是其本身</li>
<li>负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后+1。(即在反码的基础上+1)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[+1] = [00000001]原 = [00000001]反 = [00000001]补</span><br><span class="line">[-1] = [10000001]原 = [11111110]反 = [11111111]补</span><br></pre></td></tr></table></figure>
<p>对于负数，补码表示方式也是人脑无法直观看出其数值的。通常也需要转换成原码在计算其数值。</p>
<p>从上面可以看到：</p>
<ul>
<li>对于正数：原码，反码，补码都是一样的</li>
<li>对于负数：原码，反码，补码都是不一样的</li>
</ul>
<p><strong>02、字符缓冲流 </strong></p>
<p>BufferedReader 类继承自 Reader 类，提供了一些便捷的方法，例如 readLine() 方法可以一次读取一行数据，而不是一个字符一个字符地读取。</p>
<p>BufferedWriter 类继承自 Writer 类，提供了一些便捷的方法，例如 newLine() 方法可以写入一个系统特定的行分隔符。</p>
<p><strong>1）构造方法 </strong></p>
<ul>
<li>BufferedReader(Reader in) ：创建一个新的缓冲输入流，注意参数类型为Reader。</li>
<li>BufferedWriter(Writer out) ： 创建一个新的缓冲输出流，注意参数类型为Writer。</li>
</ul>
<p>代码示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 创建字符缓冲输入流</span><br><span class="line">BufferedReader br = new BufferedReader(new FileReader(&quot;b.txt&quot;));</span><br><span class="line">// 创建字符缓冲输出流</span><br><span class="line">BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;b.txt&quot;));</span><br></pre></td></tr></table></figure>
<p><strong>2）字符缓冲流特有方法 </strong></p>
<p>字符缓冲流的基本方法与普通字符流调用方式一致，这里不再赘述，我们来看字符缓冲流特有的方法。</p>
<ul>
<li>BufferedReader： String readLine() : 读一行数据，读取到最后返回 null</li>
<li>BufferedWriter： newLine() : 换行，由系统定义换行符。</li>
</ul>
<p>来看 readLine()方法的代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 创建流对象</span><br><span class="line">BufferedReader br = new BufferedReader(new FileReader(&quot;a.txt&quot;));</span><br><span class="line">// 定义字符串,保存读取的一行文字</span><br><span class="line">String line  = null;</span><br><span class="line">// 循环读取,读取到最后返回null</span><br><span class="line">while ((line = br.readLine())!=null) &#123;</span><br><span class="line">    System.out.print(line);</span><br><span class="line">    System.out.println(&quot;------&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// 释放资源</span><br><span class="line">br.close();</span><br></pre></td></tr></table></figure>
<p>再来看 newLine() 方法的代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 创建流对象</span><br><span class="line">BfferedWriter bw = new BufferedWriter(new FileWriter(&quot;b.txt&quot;));</span><br><span class="line">// 写出数据</span><br><span class="line">bw.write(&quot;沉&quot;);</span><br><span class="line">// 写出换行</span><br><span class="line">bw.newLine();</span><br><span class="line">bw.write(&quot;默&quot;);</span><br><span class="line">bw.newLine();</span><br><span class="line">bw.write(&quot;王&quot;);</span><br><span class="line">bw.newLine();</span><br><span class="line">bw.write(&quot;二&quot;);</span><br><span class="line">bw.newLine();</span><br><span class="line">// 释放资源</span><br><span class="line">bw.close();</span><br></pre></td></tr></table></figure>
<p><strong>03、字符缓冲流练习</strong></p>
<p>来欣赏一下我写的这篇诗：</p>
<blockquote>
<p>6.岑夫子，丹丘生，将进酒，杯莫停。</p>
<p>1.君不见黄河之水天上来，奔流到海不复回。</p>
<p>8.钟鼓馔玉不足贵，但愿长醉不愿醒。</p>
<p>3.人生得意须尽欢，莫使金樽空对月。</p>
<p>5.烹羊宰牛且为乐，会须一饮三百杯。</p>
<p>2.君不见高堂明镜悲白发，朝如青丝暮成雪。</p>
<p>7.与君歌一曲，请君为我倾耳听。</p>
<p>4.天生我材必有用，千金散尽还复来。</p>
</blockquote>
<p>欣赏完了没？</p>
<p>估计你也看出来了，这是李白写的《将进酒》，不是我王二写的。</p>
<p>不过，顺序是乱的，还好，我都编了号。那如何才能按照正确的顺序来呢？</p>
<p>来看代码实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 创建map集合,保存文本数据,键为序号,值为文字</span><br><span class="line">HashMap&lt;String, String&gt; lineMap = new HashMap&lt;&gt;();</span><br><span class="line">// 创建流对象  源</span><br><span class="line">BufferedReader br = new BufferedReader(new FileReader(&quot;logs/test.log&quot;));</span><br><span class="line">//目标</span><br><span class="line">BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;logs/test1.txt&quot;));</span><br><span class="line">// 读取数据</span><br><span class="line">String line;</span><br><span class="line">while ((line = br.readLine())!=null) &#123;</span><br><span class="line">    // 解析文本</span><br><span class="line">    if (line.isEmpty()) &#123;</span><br><span class="line">        continue;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] split = line.split(Pattern.quote(&quot;.&quot;));</span><br><span class="line">    // 保存到集合</span><br><span class="line">    lineMap.put(split[0], split[1]);</span><br><span class="line">&#125;</span><br><span class="line">// 释放资源</span><br><span class="line">br.close();</span><br><span class="line">// 遍历map集合</span><br><span class="line">for (int i = 1; i &lt;= lineMap.size(); i++) &#123;</span><br><span class="line">    String key = String.valueOf(i);</span><br><span class="line">    // 获取map中文本</span><br><span class="line">    String value = lineMap.get(key);</span><br><span class="line">    // 写出拼接文本</span><br><span class="line">    bw.write(key+&quot;.&quot;+value);</span><br><span class="line">    // 写出换行</span><br><span class="line">    bw.newLine();</span><br><span class="line">&#125;</span><br><span class="line">// 释放资源</span><br><span class="line">bw.close();</span><br></pre></td></tr></table></figure>
<p>这里面用到的知识都是我们前面学过的，比如说 HashMap，字符串分割，包括刚刚学习的字符缓冲流。</p>
<p>来看输出结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.君不见黄河之水天上来，奔流到海不复回。</span><br><span class="line">2.君不见高堂明镜悲白发，朝如青丝暮成雪。</span><br><span class="line">3.人生得意须尽欢，莫使金樽空对月。</span><br><span class="line">4.天生我材必有用，千金散尽还复来。</span><br><span class="line">5.烹羊宰牛且为乐，会须一饮三百杯。</span><br><span class="line">6.岑夫子，丹丘生，将进酒，杯莫停。</span><br><span class="line">7.与君歌一曲，请君为我倾耳听。</span><br><span class="line">8.钟鼓馔玉不足贵，但愿长醉不愿醒。</span><br></pre></td></tr></table></figure>
<h2 id="5-6-转换流"><a href="#5-6-转换流" class="headerlink" title="5.6 转换流"></a>5.6 转换流</h2><p>转换流可以将一个字节流包装成字符流，或者将一个字符流包装成字节流。这种转换通常用于处理文本数据，如读取文本文件或将数据从网络传输到应用程序。</p>
<p>转换流主要有两种类型：InputStreamReader 和 OutputStreamWriter。</p>
<p>InputStreamReader 将一个字节输入流转换为一个字符输入流，而 OutputStreamWriter 将一个字节输出流转换为一个字符输出流。它们使用指定的字符集将字节流和字符流之间进行转换。常用的字符集包括 UTF-8、GBK、ISO-8859-1 等。</p>
<p><img src="\assets\note\image-20231011105242854.png" alt="image-20231011105242854"></p>
<p><strong>01、编码和解码 </strong></p>
<p>在计算机中，数据通常以二进制形式存储和传输。</p>
<ul>
<li>编码就是将原始数据（比如说文本、图像、视频、音频等）转换为二进制形式。</li>
<li>解码就是将二进制数据转换为原始数据，是一个反向的过程。</li>
</ul>
<p>常见的编码和解码方式有很多，举几个例子：</p>
<ul>
<li>ASCII 编码和解码：在计算机中，常常使用 ASCII 码来表示字符，如键盘上的字母、数字和符号等。例如，字母 A 对应的 ASCII 码是 65，字符 + 对应的 ASCII 码是 43。</li>
<li>Unicode 编码和解码：Unicode 是一种字符集，支持多种语言和字符集。在计算机中，Unicode 可以使用 UTF-8、UTF-16 等编码方式将字符转换为二进制数据进行存储和传输。</li>
<li>Base64 编码和解码：Base64 是一种将二进制数据转换为 ASCII 码的编码方式。它将 3 个字节的二进制数据转换为 4 个 ASCII 字符，以便在网络传输中使用。例如，将字符串 “Hello, world!” 进行 Base64 编码后，得到的结果是 “SGVsbG8sIHdvcmxkIQ==”。</li>
<li>图像编码和解码：在图像处理中，常常使用 JPEG、PNG、GIF 等编码方式将图像转换为二进制数据进行存储和传输。在解码时，可以将二进制数据转换为图像，以便显示或处理。</li>
<li>视频编码和解码：在视频处理中，常常使用 H.264、AVC、MPEG-4 等编码方式将视频转换为二进制数据进行存储和传输。在解码时，可以将二进制数据转换为视频，以便播放或处理。</li>
</ul>
<p>简单一点说就是：</p>
<ul>
<li>编码：字符(能看懂的)—&gt;字节(看不懂的)</li>
<li>解码：字节(看不懂的)—&gt;字符(能看懂的)</li>
</ul>
<p>我用代码来表示一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;沉默王二&quot;;</span><br><span class="line">String charsetName = &quot;UTF-8&quot;;</span><br><span class="line">// 编码</span><br><span class="line">byte[] bytes = str.getBytes(Charset.forName(charsetName));</span><br><span class="line">System.out.println(&quot;编码: &quot; + bytes);</span><br><span class="line">// 解码</span><br><span class="line">String decodedStr = new String(bytes, Charset.forName(charsetName));</span><br><span class="line">System.out.println(&quot;解码: &quot; + decodedStr);</span><br></pre></td></tr></table></figure>
<p>在这个示例中，首先定义了一个字符串变量 str 和一个字符集名称 charsetName。然后，使用 Charset.forName() 方法获取指定字符集的 Charset 对象。接着，使用字符串的 getBytes() 方法将字符串编码为指定字符集的字节数组。最后，使用 new String() 方法将字节数组解码为字符串。</p>
<p>需要注意的是，在编码和解码过程中，要保证使用相同的字符集，以便正确地转换数据。</p>
<p><strong>02、字符集 </strong></p>
<p>Charset：字符集，是一组字符的集合，每个字符都有一个唯一的编码值，也称为码点。</p>
<p>常见的字符集包括 ASCII、Unicode 和 GBK，而 Unicode 字符集包含了多种编码方式，比如说 UTF-8、UTF-16。</p>
<p><img src="\assets\note\image-20231011105519195.png" alt="image-20231011105519195"></p>
<p><strong>ASCII 字符集 </strong></p>
<p>ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）字符集是一种最早的字符集，包含 128 个字符，其中包括控制字符、数字、英文字母以及一些标点符号。ASCII 字符集中的每个字符都有一个唯一的 7 位二进制编码（由 0 和 1 组成），可以表示为十进制数或十六进制数。</p>
<p>ASCII 编码方式是一种固定长度的编码方式，每个字符都使用 7 位二进制编码来表示。ASCII 编码只能表示英文字母、数字和少量的符号，不能表示其他语言的文字和符号，因此在全球范围内的应用受到了很大的限制。</p>
<p><strong>Unicode 字符集 </strong></p>
<p>Unicode 包含了世界上几乎所有的字符，用于表示人类语言、符号和表情等各种信息。Unicode 字符集中的每个字符都有一个唯一的码点（code point），用于表示该字符在字符集中的位置，可以用十六进制数表示。</p>
<p>为了在计算机中存储和传输 Unicode 字符集中的字符，需要使用一种编码方式。UTF-8、UTF-16 和 UTF-32 都是 Unicode 字符集的编码方式，用于将 Unicode 字符集中的字符转换成字节序列，以便于存储和传输。</p>
<p>它们的差别在于使用的字节长度不同。</p>
<ul>
<li>UTF-8 是一种可变长度的编码方式，对于 ASCII 字符（码点范围为 0x00~0x7F ），使用一个字节表示，对于其他 Unicode 字符，使用两个、三个或四个字节表示。UTF-8 编码方式被广泛应用于互联网和计算机领域，因为它可以有效地压缩数据，适用于网络传输和存储。</li>
<li>UTF-16 是一种固定长度的编码方式，对于基本多语言平面（Basic Multilingual Plane，Unicode 字符集中的一个码位范围，包含了世界上大部分常用的字符，总共包含了超过 65,000 个码位）中的字符（码点范围为 0x0000~0xFFFF ），使用两个字节表示，对于其他 Unicode 字符，使用四个字节表示。</li>
<li>UTF-32 是一种固定长度的编码方式，对于所有 Unicode 字符，使用四个字节表示。</li>
</ul>
<p><strong>GBK 字符集 </strong></p>
<p>GBK 包含了 GB2312 字符集中的字符，同时还扩展了许多其他汉字字符和符号，共收录了 21,913 个字符。</p>
<p>GBK 采用双字节编码方式，每个汉字占用 2 个字节，其中高字节和低字节都使用了 8 位，因此 GBK 编码共有 2^16=65536 种可能的编码，其中大部分被用于表示汉字字符。</p>
<p>GBK 编码是一种变长的编码方式，对于 ASCII 字符（码位范围为 0x00 到 0x7F），使用一个字节表示，对于其他字符，使用两个字节表示。GBK 编码中的每个字节都可以采用 0x81 到 0xFE 之间的任意一个值，因此可以表示 2^15=32768 个字符。为了避免与 ASCII 码冲突，GBK 编码的第一个字节采用了 0x81 到 0xFE 之间除了 0x7F 的所有值，第二个字节采用了 0x40 到 0x7E 和 0x80 到 0xFE 之间的所有值，共 94 个值。</p>
<p>GB2312 的全名是《信息交换用汉字编码字符集基本集》，也被称为“国标码”。采用了双字节编码方式，每个汉字占用 2 个字节，其中高字节和低字节都使用了 8 位，因此 GB2312 编码共有 2^16=65536 种可能的编码，其中大部分被用于表示汉字字符。GB2312 编码中的每个字节都可以采用 0xA1 到 0xF7 之间的任意一个值，因此可以表示 126 个字符。</p>
<p>GB2312 是一个较为简单的字符集，只包含了常用的汉字和符号，因此对于一些较为罕见的汉字和生僻字，GB2312 不能满足需求，现在已经逐渐被 GBK、GB18030 等字符集所取代。</p>
<p>GB18030 是最新的中文码表。收录汉字 70244 个，采用多字节编码，每个字可以由 1 个、2 个或 4 个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。</p>
<p><strong>03、乱码 </strong></p>
<p>当使用不同的编码方式读取或者写入文件时，就会出现乱码问题，来看示例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">String s = &quot;沉默王二！&quot;;</span><br><span class="line">try &#123;</span><br><span class="line">    // 将字符串按GBK编码方式保存到文件中</span><br><span class="line">    OutputStreamWriter out = new OutputStreamWriter(</span><br><span class="line">            new FileOutputStream(&quot;logs/test_utf8.txt&quot;), &quot;GBK&quot;);</span><br><span class="line">    out.write(s);</span><br><span class="line">    out.close();</span><br><span class="line">    FileReader fileReader = new FileReader(&quot;logs/test_utf8.txt&quot;);</span><br><span class="line">    int read;</span><br><span class="line">    while ((read = fileReader.read()) != -1) &#123;</span><br><span class="line">        System.out.print((char)read);</span><br><span class="line">    &#125;</span><br><span class="line">    fileReader.close();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例代码中，首先定义了一个包含中文字符的字符串，然后将该字符串按 GBK 编码方式保存到文件中，接着将文件按默认编码方式（UTF-8）读取，并显示内容。此时就会出现乱码问题，显示为“��Ĭ������”。</p>
<p>这是因为文件中的 GBK 编码的字符在使用 UTF-8 编码方式解析时无法正确解析，从而导致出现乱码问题。</p>
<p>那如何才能解决乱码问题呢？</p>
<p>这就引出我们今天的主角了——转换流。</p>
<p><strong>04、InputStreamReader </strong></p>
<p>java.io.InputStreamReader 是 Reader 类的子类。它的作用是将字节流（InputStream）转换为字符流（Reader），同时支持指定的字符集编码方式，从而实现字符流与字节流之间的转换。</p>
<p><strong>1）构造方法 </strong></p>
<ul>
<li>InputStreamReader(InputStream in) : 创建一个使用默认字符集的字符流。</li>
<li>InputStreamReader(InputStream in, String charsetName) : 创建一个指定字符集的字符流。</li>
</ul>
<p>代码示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;in.txt&quot;));</span><br><span class="line">InputStreamReader isr2 = new InputStreamReader(new FileInputStream(&quot;in.txt&quot;) , &quot;GBK&quot;);</span><br></pre></td></tr></table></figure>
<p><strong>2）解决编码问题 </strong></p>
<p>下面是一个使用 InputStreamReader 解决乱码问题的示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">String s = &quot;沉默王二！&quot;;</span><br><span class="line">try &#123;</span><br><span class="line">    // 将字符串按GBK编码方式保存到文件中</span><br><span class="line">    OutputStreamWriter outUtf8 = new OutputStreamWriter(</span><br><span class="line">            new FileOutputStream(&quot;logs/test_utf8.txt&quot;), &quot;GBK&quot;);</span><br><span class="line">    outUtf8.write(s);</span><br><span class="line">    outUtf8.close();</span><br><span class="line">    // 将字节流转换为字符流，使用GBK编码方式</span><br><span class="line">    InputStreamReader isr = new InputStreamReader(new </span><br><span class="line">FileInputStream(&quot;logs/test_utf8.txt&quot;), &quot;GBK&quot;);</span><br><span class="line">    // 读取字符流</span><br><span class="line">    int c;</span><br><span class="line">    while ((c = isr.read()) != -1) &#123;</span><br><span class="line">        System.out.print((char) c);</span><br><span class="line">    &#125;</span><br><span class="line">    isr.close();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于使用了 InputStreamReader 对字节流进行了编码方式的转换，因此在读取字符流时就可以正确地解析出中文字符，避免了乱码问题。</p>
<p><strong>05、OutputStreamWriter </strong></p>
<p>java.io.OutputStreamWriter 是 Writer 的子类，字面看容易误以为是转为字符流，其实是将字符流转换为字节流，是字符流到字节流的桥梁。</p>
<ul>
<li>OutputStreamWriter(OutputStream in) : 创建一个使用默认字符集的字符流。</li>
<li>OutputStreamWriter(OutputStream in, String charsetName) ：创建一个指定字符集的字符流。</li>
</ul>
<p>代码示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OutputStreamWriter isr = new OutputStreamWriter(new FileOutputStream(&quot;a.txt&quot;));</span><br><span class="line">OutputStreamWriter isr2 = new OutputStreamWriter(new FileOutputStream(&quot;b.txt&quot;) , &quot;GBK&quot;);</span><br></pre></td></tr></table></figure>
<p>通常为了提高读写效率，我们会在转换流上再加一层缓冲流，来看代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    // 从文件读取字节流，使用UTF-8编码方式</span><br><span class="line">    FileInputStream fis = new FileInputStream(&quot;test.txt&quot;);</span><br><span class="line">    // 将字节流转换为字符流，使用UTF-8编码方式</span><br><span class="line">    InputStreamReader isr = new InputStreamReader(fis, &quot;UTF-8&quot;);</span><br><span class="line">    // 使用缓冲流包装字符流，提高读取效率</span><br><span class="line">    BufferedReader br = new BufferedReader(isr);</span><br><span class="line">    // 创建输出流，使用UTF-8编码方式</span><br><span class="line">    FileOutputStream fos = new FileOutputStream(&quot;output.txt&quot;);</span><br><span class="line">    // 将输出流包装为转换流，使用UTF-8编码方式</span><br><span class="line">    OutputStreamWriter osw = new OutputStreamWriter(fos, &quot;UTF-8&quot;);</span><br><span class="line">    // 使用缓冲流包装转换流，提高写入效率</span><br><span class="line">    BufferedWriter bw = new BufferedWriter(osw);</span><br><span class="line">    // 读取输入文件的每一行，写入到输出文件中</span><br><span class="line">    String line;</span><br><span class="line">    while ((line = br.readLine()) != null) &#123;</span><br><span class="line">        bw.write(line);</span><br><span class="line">        bw.newLine(); // 每行结束后写入一个换行符</span><br><span class="line">    &#125;</span><br><span class="line">    // 关闭流</span><br><span class="line">    br.close();</span><br><span class="line">    bw.close();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例代码中，首先使用 FileInputStream 从文件中读取字节流，使用 UTF-8 编码方式进行读取。然后，使用 InputStreamReader 将字节流转换为字符流，使用 UTF-8 编码方式进行转换。接着，使用 BufferedReader 包装字符流，提高读取效率。然后，创建 FileOutputStream 用于输出文件，使用 UTF-8 编码方式进行创建。接着，使用 OutputStreamWriter 将输出流转换为字符流，使用 UTF-8 编码方式进行转换。最后，使用 BufferedWriter 包装转换流，提高写入效率。</p>
<p><strong>06、小结 </strong></p>
<p>InputStreamReader 和 OutputStreamWriter 是将字节流转换为字符流或者将字符流转换为字节流。通常用于解决字节流和字符流之间的转换问题，可以将字节流以指定的字符集编码方式转换为字符流，或者将字符流以指定的字符集编码方式转换为字节流。</p>
<p>InputStreamReader 类的常用方法包括：</p>
<ul>
<li>read() ：从输入流中读取一个字符的数据。</li>
<li>read(char[] cbuf, int off, int len) ：从输入流中读取 len 个字符的数据到指定的字符数组 cbuf 中，从 off 位置开始存放。</li>
<li>ready() ：返回此流是否已准备好读取。</li>
<li>close() ：关闭输入流。</li>
</ul>
<p>OutputStreamWriter 类的常用方法包括：</p>
<ul>
<li>write(int c) ：向输出流中写入一个字符的数据。</li>
<li>write(char[] cbuf, int off, int len) ：向输出流中写入指定字符数组 cbuf 中的 len 个字符，从 off 位置开始。</li>
<li>flush() ：将缓冲区的数据写入输出流中。</li>
<li>close() ：关闭输出流。</li>
</ul>
<p>在使用转换流时，需要指定正确的字符集编码方式，否则可能会导致数据读取或写入出现乱码。</p>
<h2 id="5-7-打印流"><a href="#5-7-打印流" class="headerlink" title="5.7 打印流"></a>5.7 打印流</h2><p>在我的职业生涯中， System.out.println() 的使用频率恐怕不亚于 main 方法的使用频率。其中 System.out 返回的正是打印流 PrintStream 。</p>
<p>除此之外，还有它还有一个孪生兄弟，PrintWriter。PrintStream 是 OutputStream 的子类，PrintWriter 是 Writer 的子类，也就是说，一个字节流，一个是字符流。</p>
<p>打印流具有以下几个特点：</p>
<ul>
<li>可以自动进行数据类型转换：打印流可以将各种数据类型转换为字符串，并输出到指定的输出流中。</li>
<li>可以自动进行换行操作：打印流可以在输出字符串的末尾自动添加换行符，方便输出多个字符串时的格式控制。</li>
<li>可以输出到控制台或者文件中：打印流可以将数据输出到控制台或者文件中，方便调试和日志记录（尽管生产环境下更推荐使用 Logback、ELK 等）。</li>
</ul>
<p>PrintStream 类的常用方法包括：</p>
<ul>
<li>print() ：输出一个对象的字符串表示形式。</li>
<li>println() ：输出一个对象的字符串表示形式，并在末尾添加一个换行符。</li>
<li>printf() ：使用指定的格式字符串和参数输出格式化的字符串。</li>
</ul>
<p>来一个示例体验一下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PrintStream ps = System.out;</span><br><span class="line">ps.println(&quot;沉默王二&quot;);</span><br><span class="line">ps.print(&quot;沉 &quot;);</span><br><span class="line">ps.print(&quot;默 &quot;);</span><br><span class="line">ps.print(&quot;王 &quot;);</span><br><span class="line">ps.print(&quot;二 &quot;);</span><br><span class="line">ps.println();</span><br><span class="line">ps.printf(&quot;姓名：%s，年龄：%d，成绩：%f&quot;, &quot;沉默王二&quot;, 18, 99.9);</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们创建了一个 PrintStream 对象 ps，它输出到控制台。我们使用 ps 的 print 和 println 方法输出了一些字符串。</p>
<p>使用 printf 方法输出了一个格式化字符串，其中 %s、%d 和 %.2f 分别表示字符串、整数和浮点数的格式化输出。我们使用逗号分隔的参数列表指定了要输出的值。</p>
<p>来详细说说 printf 方法哈。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public PrintStream printf(String format, Object... args);</span><br></pre></td></tr></table></figure>
<p>其中，format 参数是格式化字符串，args 参数是要输出的参数列表。格式化字符串包含了普通字符和转换说明符。普通字符是指除了转换说明符之外的字符，它们在输出时直接输出。转换说明符是由百分号（%）和一个或多个字符组成的，用于指定输出的格式和数据类型。</p>
<p>下面是 Java 的常用转换说明符及对应的输出格式：</p>
<ul>
<li>%s ：输出一个字符串。</li>
<li>%d 或 %i ：输出一个十进制整数。</li>
<li>%x 或 %X ：输出一个十六进制整数， %x 输出小写字母， %X 输出大写字母。</li>
<li>%f 或 %F ：输出一个浮点数。</li>
<li>%e 或 %E ：输出一个科学计数法表示的浮点数， %e 输出小写字母 e， %E 输出大写字母 E。</li>
<li>%g 或 %G ：输出一个浮点数，自动选择 %f 或 %e/%E 格式输出。</li>
<li>%c ：输出一个字符。</li>
<li>%b ：输出一个布尔值。</li>
<li>%h ：输出一个哈希码（16进制）。</li>
<li>%n ：换行符。</li>
</ul>
<p>除了转换说明符之外，Java 的 printf 方法还支持一些修饰符，用于指定输出的宽度、精度、对齐方式等。</p>
<ul>
<li>宽度修饰符：用数字指定输出的最小宽度，如果输出的数据不足指定宽度，则在左侧或右侧填充空格或零。</li>
<li>精度修饰符：用点号（.）和数字指定浮点数或字符串的精度，对于浮点数，指定小数点后的位数，对于字符串，指定输出的字符数。</li>
<li>对齐修饰符：用减号（-）或零号（0）指定输出的对齐方式，减号表示左对齐，零号表示右对齐并填充零。</li>
</ul>
<p>下面是一些示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int num = 123;</span><br><span class="line">System.out.printf(&quot;%5d\n&quot;, num); // 输出 &quot;  123&quot;</span><br><span class="line">System.out.printf(&quot;%-5d\n&quot;, num); // 输出 &quot;123  &quot;</span><br><span class="line">System.out.printf(&quot;%05d\n&quot;, num); // 输出 &quot;00123&quot;</span><br><span class="line">double pi = Math.PI;</span><br><span class="line">System.out.printf(&quot;%10.2f\n&quot;, pi); // 输出 &quot;      3.14&quot;</span><br><span class="line">System.out.printf(&quot;%-10.4f\n&quot;, pi); // 输出 &quot;3.1416    &quot;</span><br><span class="line">String name = &quot;沉默王二&quot;;</span><br><span class="line">System.out.printf(&quot;%10s\n&quot;, name); // 输出 &quot;     沉默王二&quot;</span><br><span class="line">System.out.printf(&quot;%-10s\n&quot;, name); // 输出 &quot;沉默王二     &quot;</span><br></pre></td></tr></table></figure>
<p>具体来说，</p>
<ul>
<li>我们使用 %5d 来指定输出的整数占据 5 个字符的宽度，不足部分在左侧填充空格。</li>
<li>使用 %-5d 来指定输出的整数占据 5 个字符的宽度，不足部分在右侧填充空格。</li>
<li>使用 %05d 来指定输出的整数占据 5 个字符的宽度，不足部分在左侧填充 0。</li>
<li>使用 %10.2f 来指定输出的浮点数占据 10 个字符的宽度，保留 2 位小数，不足部分在左侧填充空格。</li>
<li>使用 %-10.4f 来指定输出的浮点数占据 10 个字符的宽度，保留 4 位小数，不足部分在右侧填充空格。</li>
<li>使用 %10s 来指定输出的字符串占据 10 个字符的宽度，不足部分在左侧填充空格。</li>
<li>使用 %-10s 来指定输出的字符串占据 10 个字符的宽度，不足部分在右侧填充空格。</li>
</ul>
<p>接下来，我们给出一个 PrintWriter 的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PrintWriter writer = new PrintWriter(new FileWriter(&quot;output.txt&quot;));</span><br><span class="line">writer.println(&quot;沉默王二&quot;);</span><br><span class="line">writer.printf(&quot;他的年纪为 %d.\n&quot;, 18);</span><br><span class="line">writer.close();</span><br></pre></td></tr></table></figure>
<p>首先，我们创建一个 PrintWriter 对象，它的构造函数接收一个 Writer 对象作为参数。在这里，我们使用 FileWriter 来创建一个输出文件流，并将其作为参数传递给 PrintWriter 的构造函数。然后，我们使用 PrintWriter 的 println 和 printf 方法来输出两行内容，其中 printf 方法可以接收格式化字符串。最后，我们调用 PrintWriter 的 close 方法来关闭输出流。</p>
<p>我们也可以不创建 FileWriter 对象，直接指定文件名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PrintWriter pw = new PrintWriter(&quot;output.txt&quot;);</span><br><span class="line">pw.println(&quot;沉默王二&quot;);</span><br><span class="line">pw.printf(&quot;他的年纪为 %d.\n&quot;, 18);</span><br><span class="line">pw.close();</span><br></pre></td></tr></table></figure>
<p>好，关于打印流我们就说这么多，比较简单。至于 printf 的一些规则，用到的时候可以再查使用说明或者看 API 文档就可以了，记不住没关系。</p>
<h2 id="5-8-序列流-序列化和反序列化"><a href="#5-8-序列流-序列化和反序列化" class="headerlink" title="5.8 序列流(序列化和反序列化)"></a>5.8 序列流(序列化和反序列化)</h2><p>Java 的序列流（ObjectInputStream 和 ObjectOutputStream）是一种可以将 Java 对象序列化和反序列化的流。</p>
<p>序列化是指将一个对象转换为一个字节序列（包含对象的数据 、对象的类型和对象中存储的属性等信息），以便在网络上传输或保存到文件中，或者在程序之间传递。在 Java 中，序列化通过实现 java.io.Serializable 接口来实现，只有实现了 Serializable 接口的对象才能被序列化。</p>
<p>反序列化是指将一个字节序列转换为一个对象，以便在程序中使用。</p>
<p><img src="\assets\note\image-20231011110758602.png" alt="image-20231011110758602"></p>
<p><strong>01、ObjectOutputStream </strong></p>
<p>java.io.ObjectOutputStream 继承自 OutputStream 类，因此可以将序列化后的字节序列写入到文件、网络等输出流中。</p>
<p>来看 ObjectOutputStream 的构造方法： </p>
<p>ObjectOutputStream(OutputStream out)</p>
<p>该构造方法接收一个 OutputStream 对象作为参数，用于将序列化后的字节序列输出到指定的输出流中。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fos = new FileOutputStream(&quot;file.txt&quot;);</span><br><span class="line">ObjectOutputStream oos = new ObjectOutputStream(fos);</span><br></pre></td></tr></table></figure>
<p>一个对象要想序列化，必须满足两个条件:</p>
<ul>
<li>该类必须实现 java.io.Serializable 接口，否则会抛出 NotSerializableException 。</li>
<li>该类的所有字段都必须是可序列化的。如果一个字段不需要序列化，则需要使用 transient 关键字进行修饰。</li>
</ul>
<p>使用示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Employee implements Serializable &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    public String address;</span><br><span class="line">    public transient int age; // transient瞬态修饰成员,不会被序列化</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，来聊聊 writeObject (Object obj) 方法，该方法是 ObjectOutputStream 类中用于将对象序列化成字节序列并输出到输出流中的方法，可以处理对象之间的引用关系、继承关系、静态字段和 transient 字段。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class ObjectOutputStreamDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person person = new Person(&quot;沉默王二&quot;, 20);</span><br><span class="line">        try &#123;</span><br><span class="line">            FileOutputStream fos = new FileOutputStream(&quot;logs/person.dat&quot;);</span><br><span class="line">            ObjectOutputStream oos = new ObjectOutputStream(fos);</span><br><span class="line">            oos.writeObject(person);</span><br><span class="line">            oos.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Person implements Serializable &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    public Person(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中，首先创建了一个 Person 对象，然后使用 FileOutputStream 和 ObjectOutputStream 将 Person 对象序列化并输出到 person.dat 文件中。在 Person 类中，实现了 Serializable 接口，表示该类可以进行对象序列化。</p>
<p><strong>02、ObjectInputStream </strong></p>
<p>ObjectInputStream 可以读取 ObjectOutputStream 写入的字节流，并将其反序列化为相应的对象（包含对象的数据 、对象的类型和对象中存储的属性等信息）。</p>
<p>说简单点就是，序列化之前是什么样子，反序列化后就是什么样子。</p>
<p>来看一下构造方法： ObjectInputStream(InputStream in) ： 创建一个指定 InputStream 的 ObjectInputStream。</p>
<p>其中，ObjectInputStream 的 readObject 方法用来读取指定文件中的对象，示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String filename = &quot;logs/person.dat&quot;; // 待反序列化的文件名</span><br><span class="line">try (FileInputStream fileIn = new FileInputStream(filename);</span><br><span class="line">     ObjectInputStream in = new ObjectInputStream(fileIn)) &#123;</span><br><span class="line">     // 从指定的文件输入流中读取对象并反序列化</span><br><span class="line">     Object obj = in.readObject();</span><br><span class="line">     // 将反序列化后的对象强制转换为指定类型</span><br><span class="line">     Person p = (Person) obj;</span><br><span class="line">     // 打印反序列化后的对象信息</span><br><span class="line">     System.out.println(&quot;Deserialized Object: &quot; + p);</span><br><span class="line">&#125; catch (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">     e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们首先指定了待反序列化的文件名（前面通过 ObjectOutputStream 序列化后的文件），然后创建了一个 FileInputStream 对象和一个 ObjectInputStream 对象。接着我们调用 ObjectInputStream 的 readObject 方法来读取指定文件中的对象，并将其强制转换为 Person 类型。最后我们打印了反序列化后的对象信息。</p>
<p><strong>03、Kryo </strong></p>
<p>实际开发中，很少使用 JDK 自带的序列化和反序列化，这是因为：</p>
<ul>
<li>可移植性差：Java 特有的，无法跨语言进行序列化和反序列化。</li>
<li>性能差：序列化后的字节体积大，增加了传输/保存成本。</li>
<li>安全问题：攻击者可以通过构造恶意数据来实现远程代码执行，从而对系统造成严重的安全威胁。相关阅读：Java 反序列化漏洞之殇 。</li>
</ul>
<p>Kryo 是一个优秀的 Java 序列化和反序列化库，具有高性能、高效率和易于使用和扩展等特点，有效地解决了 JDK 自带的序列化机制的痛点。</p>
<blockquote>
<p>GitHub 地址：<a target="_blank" rel="noopener" href="https://github.com/EsotericSoftware/kryo">https://github.com/EsotericSoftware/kryo</a></p>
</blockquote>
<p>使用示例：</p>
<p>第一步，在 pom.xml 中引入依赖。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 引入 Kryo 序列化工具 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;com.esotericsoftware&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;kryo&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;5.4.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>第二步，创建一个 Kryo 对象，并使用 register() 方法将对象进行注册。然后，使用 writeObject() 方法将 Java 对象序列化为二进制流，再使用 readObject() 方法将二进制流反序列化为 Java 对象。最后，输出反序列化后的 Java 对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public class KryoDemo &#123;</span><br><span class="line">    public static void main(String[] args) throws FileNotFoundException &#123;</span><br><span class="line">        Kryo kryo = new Kryo();</span><br><span class="line">        kryo.register(KryoParam.class);</span><br><span class="line">        KryoParam object = new KryoParam(&quot;沉默王二&quot;, 123);</span><br><span class="line">        Output output = new Output(new FileOutputStream(&quot;logs/kryo.bin&quot;));</span><br><span class="line">        kryo.writeObject(output, object);</span><br><span class="line">        output.close();</span><br><span class="line">        Input input = new Input(new FileInputStream(&quot;logs/kryo.bin&quot;));</span><br><span class="line">        KryoParam object2 = kryo.readObject(input, KryoParam.class);</span><br><span class="line">        System.out.println(object2);</span><br><span class="line">        input.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class KryoParam &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    public KryoParam() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public KryoParam(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;KryoParam&#123;&quot; +</span><br><span class="line">                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, age=&quot; + age +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>04、小结 </strong></p>
<p>本节我们介绍了 Java 的序列化机制，并推荐了一款高性能的 Java 类库 Kryo 来取代 JDK 自带的序列化机<br>制，已经在 Twitter、Groupon、Yahoo 以及多个著名开源项目（如 Hive、Storm）中广泛使用。以上，希望能帮助到大家。</p>
<h2 id="5-9-序列接口Serializable"><a href="#5-9-序列接口Serializable" class="headerlink" title="5.9 序列接口Serializable"></a>5.9 序列接口Serializable</h2><p>对于 Java 的序列化，我之前一直停留在最浅层次的认知上——把那个要序列化的类实现 Serializbale 接口就可以了嘛。</p>
<p>我似乎不愿意做更深入的研究，因为会用就行了嘛。</p>
<p>但随着时间的推移，见到 Serializbale 的次数越来越多，我便对它产生了浓厚的兴趣。是时候花点时间研究研究了。</p>
<p><strong>01、先来点理论 </strong></p>
<p>Java 序列化是 JDK 1.1 时引入的一组开创性的特性，用于将 Java 对象转换为字节数组，便于存储或传输。此后，仍然可以将字节数组转换回 Java 对象原有的状态。</p>
<p>序列化的思想是“冻结”对象状态，然后写到磁盘或者在网络中传输；反序列化的思想是“解冻”对象状态，重新获得可用的 Java 象。</p>
<p>序列化有一条规则，就是要序列化的对象必须实现 Serializbale 接口，否则就会报 NotSerializableException 异常。</p>
<p>好，来看看 Serializbale 接口的定义吧：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public interface Serializable &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没别的了！</p>
<p>明明就一个空的接口嘛，竟然能够保证实现了它的“类对象”被序列化和反序列化？</p>
<p><strong>02、再来点实战 </strong></p>
<p>在回答上述问题之前，我们先来创建一个类（只有两个字段，和对应的 getter/setter ），用于序列化和反序列化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Wanger &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来创建一个测试类，通过 ObjectOutputStream 将“18 岁的王二”写入到文件当中，实际上就是一种序列化的过程；再通过 ObjectInputStream 将“18 岁的王二”从文件中读出来，实际上就是一种反序列化的过程。（前面我们学习序列流的时候也讲过）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 初始化</span><br><span class="line">Wanger wanger = new Wanger();</span><br><span class="line">wanger.setName(&quot;王二&quot;);</span><br><span class="line">wanger.setAge(18);</span><br><span class="line">System.out.println(wanger);</span><br><span class="line">// 把对象写到文件中</span><br><span class="line">try (ObjectOutputStream oos = new ObjectOutputStream(new </span><br><span class="line">FileOutputStream(&quot;chenmo&quot;));)&#123;</span><br><span class="line">    oos.writeObject(wanger);</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">// 从文件中读出对象</span><br><span class="line">try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(new </span><br><span class="line">File(&quot;chenmo&quot;)));)&#123;</span><br><span class="line">    Wanger wanger1 = (Wanger) ois.readObject();</span><br><span class="line">    System.out.println(wanger1);</span><br><span class="line">&#125; catch (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过，由于 Wanger 没有实现 Serializbale 接口，所以在运行测试类的时候会抛出异常，堆栈信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.io.NotSerializableException: com.cmower.java_demo.xuliehua.Wanger</span><br><span class="line">    at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1184)</span><br><span class="line">    at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:348)</span><br><span class="line">    at com.cmower.java_demo.xuliehua.Test.main(Test.java:21)</span><br></pre></td></tr></table></figure>
<p>顺着堆栈信息，我们来看一下 ObjectOutputStream 的 writeObject0() 方法。其部分源码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 判断对象是否为字符串类型，如果是，则调用 writeString 方法进行序列化</span><br><span class="line">if (obj instanceof String) &#123;</span><br><span class="line">    writeString((String) obj, unshared);</span><br><span class="line">&#125;</span><br><span class="line">// 判断对象是否为数组类型，如果是，则调用 writeArray 方法进行序列化</span><br><span class="line">else if (cl.isArray()) &#123;</span><br><span class="line">    writeArray(obj, desc, unshared);</span><br><span class="line">&#125;</span><br><span class="line">// 判断对象是否为枚举类型，如果是，则调用 writeEnum 方法进行序列化</span><br><span class="line">else if (obj instanceof Enum) &#123;</span><br><span class="line">    writeEnum((Enum&lt;?&gt;) obj, desc, unshared);</span><br><span class="line">&#125;</span><br><span class="line">// 判断对象是否为可序列化类型，如果是，则调用 writeOrdinaryObject 方法进行序列化</span><br><span class="line">else if (obj instanceof Serializable) &#123;</span><br><span class="line">    writeOrdinaryObject(obj, desc, unshared);</span><br><span class="line">&#125;</span><br><span class="line">// 如果对象不能被序列化，则抛出 NotSerializableException 异常</span><br><span class="line">else &#123;</span><br><span class="line">if (extendedDebugInfo) &#123;</span><br><span class="line">    throw new NotSerializableException(</span><br><span class="line">        cl.getName() + &quot;\n&quot; + debugInfoStack.toString());</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    throw new NotSerializableException(cl.getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说， ObjectOutputStream 在序列化的时候，会判断被序列化的对象是哪一种类型，字符串？数组？枚举？还是 Serializable ，如果全都不是的话，抛出 NotSerializableException 。</p>
<p>假如 Wanger 实现了 Serializable 接口，就可以序列化和反序列化了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Wanger implements Serializable&#123;</span><br><span class="line">    private static final long serialVersionUID = -2095916884810199532L;</span><br><span class="line">    </span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体怎么序列化呢？</p>
<p>以 ObjectOutputStream 为例吧，它在序列化的时候会依次调用 writeObject() → writeObject0() → writeOrdinaryObject() → writeSerialData() → invokeWriteObject() → defaultWriteFields() 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private void defaultWriteFields(Object obj, ObjectStreamClass desc) throws </span><br><span class="line">IOException &#123;</span><br><span class="line">    // 获取对象的类，并检查是否可以进行默认的序列化</span><br><span class="line">    Class&lt;?&gt; cl = desc.forClass();</span><br><span class="line">    desc.checkDefaultSerialize();</span><br><span class="line">    // 获取对象的基本类型字段的数量，以及这些字段的值</span><br><span class="line">    int primDataSize = desc.getPrimDataSize();</span><br><span class="line">    desc.getPrimFieldValues(obj, primVals);</span><br><span class="line">    // 将基本类型字段的值写入输出流</span><br><span class="line">    bout.write(primVals, 0, primDataSize, false);</span><br><span class="line">    // 获取对象的非基本类型字段的值</span><br><span class="line">    ObjectStreamField[] fields = desc.getFields(false);</span><br><span class="line">    Object[] objVals = new Object[desc.getNumObjFields()];</span><br><span class="line">    int numPrimFields = fields.length - objVals.length;</span><br><span class="line">    desc.getObjFieldValues(obj, objVals);</span><br><span class="line">    // 循环写入对象的非基本类型字段的值</span><br><span class="line">    for (int i = 0; i &lt; objVals.length; i++) &#123;</span><br><span class="line">        // 调用 writeObject0 方法将对象的非基本类型字段序列化写入输出流</span><br><span class="line">        try &#123;</span><br><span class="line">            writeObject0(objVals[i], fields[numPrimFields + i].isUnshared());</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果在写入过程中出现异常，则将异常包装成 IOException 抛出</span><br><span class="line">        catch (IOException ex) &#123;</span><br><span class="line">            if (abortIOException == null) &#123;</span><br><span class="line">                abortIOException = ex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那怎么反序列化呢？</p>
<p>以 ObjectInputStream 为例，它在反序列化的时候会依次调用 readObject() → readObject0() → readOrdinaryObject() → readSerialData() → defaultReadFields() 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">private void defaultReadFields(Object obj, ObjectStreamClass desc) throws </span><br><span class="line">IOException &#123;</span><br><span class="line">    // 获取对象的类，并检查对象是否属于该类</span><br><span class="line">    Class&lt;?&gt; cl = desc.forClass();</span><br><span class="line">    if (cl != null &amp;&amp; obj != null &amp;&amp; !cl.isInstance(obj)) &#123;</span><br><span class="line">        throw new ClassCastException();</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取对象的基本类型字段的数量和值</span><br><span class="line">    int primDataSize = desc.getPrimDataSize();</span><br><span class="line">    if (primVals == null || primVals.length &lt; primDataSize) &#123;</span><br><span class="line">        primVals = new byte[primDataSize];</span><br><span class="line">    &#125;</span><br><span class="line">    // 从输入流中读取基本类型字段的值，并存储在 primVals 数组中</span><br><span class="line">    bin.readFully(primVals, 0, primDataSize, false);</span><br><span class="line">    if (obj != null) &#123;</span><br><span class="line">        // 将 primVals 数组中的基本类型字段的值设置到对象的相应字段中</span><br><span class="line">        desc.setPrimFieldValues(obj, primVals);</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取对象的非基本类型字段的数量和值</span><br><span class="line">    int objHandle = passHandle;</span><br><span class="line">    ObjectStreamField[] fields = desc.getFields(false);</span><br><span class="line">    Object[] objVals = new Object[desc.getNumObjFields()];</span><br><span class="line">    int numPrimFields = fields.length - objVals.length;</span><br><span class="line">    // 循环读取对象的非基本类型字段的值</span><br><span class="line">    for (int i = 0; i &lt; objVals.length; i++) &#123;</span><br><span class="line">        // 调用 readObject0 方法读取对象的非基本类型字段的值</span><br><span class="line">        ObjectStreamField f = fields[numPrimFields + i];</span><br><span class="line">        objVals[i] = readObject0(Object.class, f.isUnshared());</span><br><span class="line">        // 如果该字段是一个引用字段，则将其标记为依赖该对象</span><br><span class="line">        if (f.getField() != null) &#123;</span><br><span class="line">            handles.markDependency(objHandle, passHandle);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (obj != null) &#123;</span><br><span class="line">        // 将 objVals 数组中的非基本类型字段的值设置到对象的相应字段中</span><br><span class="line">        desc.setObjFieldValues(obj, objVals);</span><br><span class="line">    &#125;</span><br><span class="line">    passHandle = objHandle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我想看到这，你应该会恍然大悟的“哦”一声了。 Serializable 接口之所以定义为空，是因为它只起到了一个标识的作用，告诉程序实现了它的对象是可以被序列化的，但真正序列化和反序列化的操作并不需要它来完成。</p>
<p><strong>03、再来点注意事项 </strong></p>
<p>开门见山的说吧， static 和 transient 修饰的字段是不会被序列化的。</p>
<p>为什么呢？我们先来证明，再来解释原因。</p>
<p>首先，在 Wanger 类中增加两个字段。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Wanger implements Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = -2095916884810199532L;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    public static String pre = &quot;沉默&quot;;</span><br><span class="line">    transient String meizi = &quot;王三&quot;;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Wanger&#123;&quot; + &quot;name=&quot; + name + &quot;,age=&quot; + age + &quot;,pre=&quot; + pre + </span><br><span class="line">&quot;,meizi=&quot; + meizi + &quot;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其次，在测试类中打印序列化前和反序列化后的对象，并在序列化后和反序列化前改变 static 字段的值。</p>
<p>具体代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 初始化</span><br><span class="line">Wanger wanger = new Wanger();</span><br><span class="line">wanger.setName(&quot;王二&quot;);</span><br><span class="line">wanger.setAge(18);</span><br><span class="line">System.out.println(wanger);</span><br><span class="line">// 把对象写到文件中</span><br><span class="line">try (ObjectOutputStream oos = new ObjectOutputStream(new </span><br><span class="line">FileOutputStream(&quot;chenmo&quot;));)&#123;</span><br><span class="line">        oos.writeObject(wanger);</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    // 改变 static 字段的值</span><br><span class="line">Wanger.pre =&quot;不沉默&quot;;</span><br><span class="line">// 从文件中读出对象</span><br><span class="line">try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(new </span><br><span class="line">File(&quot;chenmo&quot;)));)&#123;</span><br><span class="line">    Wanger wanger1 = (Wanger) ois.readObject();</span><br><span class="line">    System.out.println(wanger1);</span><br><span class="line">&#125; catch (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Wanger&#123;name=王二,age=18,pre=沉默,meizi=王三&#125;</span><br><span class="line">Wanger&#123;name=王二,age=18,pre=不沉默,meizi=null&#125;</span><br></pre></td></tr></table></figure>
<p>从结果的对比当中，我们可以发现：</p>
<p>1）序列化前， pre 的值为“沉默”，序列化后， pre 的值修改为“不沉默”，反序列化后， pre 的值为“不沉默”，而不是序列化前的状态“沉默”。</p>
<p>为什么呢？因为序列化保存的是对象的状态，而 static 修饰的字段属于类的状态，因此可以证明序列化并不保存 static 修饰的字段。</p>
<p>2）序列化前， meizi 的值为“王三”，反序列化后， meizi 的值为 null ，而不是序列化前的状态“王三”。</p>
<p>为什么呢？ transient 的中文字义为“临时的”（论英语的重要性），它可以阻止字段被序列化到文件中，在被反序列化后， transient 字段的值被设为初始值，比如 int 型的初始值为 0，对象型的初始值为 null 。</p>
<p>如果想要深究源码的话，你可以在 ObjectStreamClass 中发现下面这样的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private static ObjectStreamField[] getDefaultSerialFields(Class&lt;?&gt; cl) &#123;</span><br><span class="line">    // 获取该类中声明的所有字段</span><br><span class="line">    Field[] clFields = cl.getDeclaredFields();</span><br><span class="line">    ArrayList&lt;ObjectStreamField&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">    int mask = Modifier.STATIC | Modifier.TRANSIENT;</span><br><span class="line">    // 遍历所有字段，将非 static 和 transient 的字段添加到 list 中</span><br><span class="line">    for (int i = 0; i &lt; clFields.length; i++) &#123;</span><br><span class="line">        Field field = clFields[i];</span><br><span class="line">        int mods = field.getModifiers();</span><br><span class="line">        if ((mods &amp; mask) == 0) &#123;</span><br><span class="line">            // 根据字段名、字段类型和字段是否可序列化创建一个 ObjectStreamField 对象</span><br><span class="line">            ObjectStreamField osf = new ObjectStreamField(field.getName(), </span><br><span class="line">field.getType(), !Serializable.class.isAssignableFrom(cl));</span><br><span class="line">            list.add(osf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int size = list.size();</span><br><span class="line">    // 如果 list 为空，则返回一个空的 ObjectStreamField 数组，否则将 list 转换为 </span><br><span class="line">ObjectStreamField 数组并返回</span><br><span class="line">    return (size == 0) ? NO_FIELDS :</span><br><span class="line">        list.toArray(new ObjectStreamField[size]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到 Modifier.STATIC | Modifier.TRANSIENT 了吧，这两个修饰符标记的字段就没有被放入到序列化的字段中，明白了吧？</p>
<p><strong>04、再来点干货 </strong></p>
<p>除了 Serializable 之外，Java 还提供了一个序列化接口 Externalizable （念起来有点拗口）。</p>
<p>两个接口有什么不一样的吗？试一试就知道了。</p>
<p>首先，把 Wanger 类实现的接口  Serializable 替换为 Externalizable 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Wanger implements Externalizable &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    public Wanger() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Wanger&#123;&quot; + &quot;name=&quot; + name + &quot;,age=&quot; + age + &quot;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void writeExternal(ObjectOutput out) throws IOException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void readExternal(ObjectInput in) throws IOException, </span><br><span class="line">ClassNotFoundException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现 Externalizable 接口的 Wanger 类和实现 Serializable 接口的 Wanger 类有一些不同：</p>
<p>1）新增了一个无参的构造方法。</p>
<p>使用 Externalizable 进行反序列化的时候，会调用被序列化类的无参构造方法去创建一个新的对象，然后再将被保存对象的字段值复制过去。否则的话，会抛出以下异常：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">java.io.InvalidClassException: com.cmower.java_demo.xuliehua1.Wanger; no valid </span><br><span class="line">constructor</span><br><span class="line">    at </span><br><span class="line">java.io.ObjectStreamClass$ExceptionInfo.newInvalidClassException(ObjectStreamClass.j</span><br><span class="line">ava:150)</span><br><span class="line">    at java.io.ObjectStreamClass.checkDeserialize(ObjectStreamClass.java:790)</span><br><span class="line">    at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:1782)</span><br><span class="line">    at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1353)</span><br><span class="line">    at java.io.ObjectInputStream.readObject(ObjectInputStream.java:373)</span><br><span class="line">    at com.cmower.java_demo.xuliehua1.Test.main(Test.java:27)</span><br></pre></td></tr></table></figure>
<p>2）新增了两个方法 writeExternal() 和 readExternal() ，实现 Externalizable 接口所必须的。</p>
<p>然后，我们再在测试类中打印序列化前和反序列化后的对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 初始化</span><br><span class="line">Wanger wanger = new Wanger();</span><br><span class="line">wanger.setName(&quot;王二&quot;);</span><br><span class="line">wanger.setAge(18);</span><br><span class="line">System.out.println(wanger);</span><br><span class="line">// 把对象写到文件中</span><br><span class="line">try (ObjectOutputStream oos = new ObjectOutputStream(new </span><br><span class="line">FileOutputStream(&quot;chenmo&quot;));) &#123;</span><br><span class="line">    oos.writeObject(wanger);</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">// 从文件中读出对象</span><br><span class="line">try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(new </span><br><span class="line">File(&quot;chenmo&quot;)));) &#123;</span><br><span class="line">    Wanger wanger1 = (Wanger) ois.readObject();</span><br><span class="line">    System.out.println(wanger1);</span><br><span class="line">&#125; catch (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">// Wanger&#123;name=王二,age=18&#125;</span><br><span class="line">// Wanger&#123;name=null,age=0&#125;</span><br></pre></td></tr></table></figure>
<p>从输出的结果看，反序列化后得到的对象字段都变成了默认值，也就是说，序列化之前的对象状态没有被“冻结”下来。</p>
<p>为什么呢？因为我们没有为 Wanger 类重写具体的 writeExternal() 和 readExternal() 方法。那该怎么重写呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void writeExternal(ObjectOutput out) throws IOException &#123;</span><br><span class="line">    out.writeObject(name);</span><br><span class="line">    out.writeInt(age);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException </span><br><span class="line">&#123;</span><br><span class="line">    name = (String) in.readObject();</span><br><span class="line">    age = in.readInt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1）调用 ObjectOutput 的 writeObject() 方法将字符串类型的 name 写入到输出流中；</p>
<p>2）调用 ObjectOutput 的 writeInt() 方法将整型的 age 写入到输出流中；</p>
<p>3）调用 ObjectInput 的 readObject() 方法将字符串类型的 name 读入到输入流中；</p>
<p>4）调用 ObjectInput 的 readInt() 方法将字符串类型的 age 读入到输入流中；</p>
<p>再运行一次测试了类，你会发现对象可以正常地序列化和反序列化了。</p>
<blockquote>
<p>序列化前：Wanger{name=王二,age=18} </p>
<p>序列化后：Wanger{name=王二,age=18}</p>
</blockquote>
<p>总结一下：</p>
<p>Externalizable 和 Serializable 都是用于实现 Java 对象的序列化和反序列化的接口，但是它们有以下区别：</p>
<p>①、Serializable 是 Java 标准库提供的接口，而 Externalizable 是 Serializable 的子接口；</p>
<p><img src="\assets\note\image-20231011112552567.png" alt="image-20231011112552567"></p>
<p>②、Serializable 接口不需要实现任何方法，只需要将需要序列化的类标记为 Serializable 即可，而 Externalizable 接口需要实现 writeExternal 和 readExternal 两个方法；</p>
<p>③、Externalizable 接口提供了更高的序列化控制能力，可以在序列化和反序列化过程中对对象进行自定义的处理，如对一些敏感信息进行加密和解密。</p>
<p><strong>05、再来点甜点 </strong></p>
<p>让我先问问你吧，你知道 private static final long serialVersionUID = -2095916884810199532L; 这段代码的作用吗？</p>
<p>嗯……</p>
<p>serialVersionUID 被称为序列化 ID，它是决定 Java 对象能否反序列化成功的重要因子。在反序列化时，Java 虚拟机会把字节流中的 serialVersionUID 与被序列化类中的 serialVersionUID 进行比较，如果相同则可以进行反序列化，否则就会抛出序列化版本不一致的异常。</p>
<p>当一个类实现了 Serializable 接口后，IDE 就会提醒该类最好产生一个序列化 ID，就像下面这样：</p>
<p><img src="\assets\note\image-20231011112646445.png" alt="image-20231011112646445"></p>
<p>1）添加一个默认版本的序列化 ID：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final long serialVersionUID = 1L。</span><br></pre></td></tr></table></figure>
<p>2）添加一个随机生成的不重复的序列化 ID。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final long serialVersionUID = -2095916884810199532L;</span><br></pre></td></tr></table></figure>
<p>3）添加 @SuppressWarnings 注解。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&quot;serial&quot;)</span><br></pre></td></tr></table></figure>
<p>怎么选择呢？</p>
<p>首先，我们采用第二种办法，在被序列化类中添加一个随机生成的序列化 ID。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Wanger implements Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = -2095916884810199532L;</span><br><span class="line">    </span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    // 其他代码忽略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，序列化一个 Wanger 对象到文件中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 初始化</span><br><span class="line">Wanger wanger = new Wanger();</span><br><span class="line">wanger.setName(&quot;王二&quot;);</span><br><span class="line">wanger.setAge(18);</span><br><span class="line">System.out.println(wanger);</span><br><span class="line">// 把对象写到文件中</span><br><span class="line">try (ObjectOutputStream oos = new ObjectOutputStream(new </span><br><span class="line">FileOutputStream(&quot;chenmo&quot;));) &#123;</span><br><span class="line">    oos.writeObject(wanger);</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候，我们悄悄地把 Wanger 类的序列化 ID 偷梁换柱一下，嘿嘿。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// private static final long serialVersionUID = -2095916884810199532L;</span><br><span class="line">private static final long serialVersionUID = -2095916884810199533L;</span><br></pre></td></tr></table></figure>
<p>好了，准备反序列化吧。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(new </span><br><span class="line">File(&quot;chenmo&quot;)));) &#123;</span><br><span class="line">    Wanger wanger = (Wanger) ois.readObject();</span><br><span class="line">    System.out.println(wanger);</span><br><span class="line">&#125; catch (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>哎呀，出错了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.io.InvalidClassException:  local class incompatible: stream classdesc </span><br><span class="line">serialVersionUID = -2095916884810199532,</span><br><span class="line">local class serialVersionUID = -2095916884810199533</span><br><span class="line">    at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1521)</span><br><span class="line">    at com.cmower.java_demo.xuliehua1.Test.main(Test.java:27)</span><br></pre></td></tr></table></figure>
<p>异常堆栈信息里面告诉我们，从持久化文件里面读取到的序列化 ID 和本地的序列化 ID 不一致，无法反序列化。</p>
<p>那假如我们采用第三种方法，为 Wanger 类添加个 @SuppressWarnings(“serial”) 注解呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&quot;serial&quot;)</span><br><span class="line">class Wanger implements Serializable &#123;</span><br><span class="line">// 省略其他代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，再来一次反序列化吧。可惜依然报错。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.io.InvalidClassException:  local class incompatible: stream classdesc </span><br><span class="line">serialVersionUID = -2095916884810199532, </span><br><span class="line">local class serialVersionUID = -3818877437117647968</span><br><span class="line">    at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1521)</span><br><span class="line">    at com.cmower.java_demo.xuliehua1.Test.main(Test.java:27)</span><br></pre></td></tr></table></figure>
<p>异常堆栈信息里面告诉我们，本地的序列化 ID 为 -3818877437117647968，和持久化文件里面读取到的序列化 ID 仍然不一致，无法反序列化。这说明什么呢？使用 @SuppressWarnings(“serial”) 注解时，该注解会为被序列化类自动生成一个随机的序列化 ID。</p>
<p>由此可以证明，Java 虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，还有一个非常重要的因素就是序列化 ID 是否一致。</p>
<p>也就是说，如果没有特殊需求，采用默认的序列化 ID（1L）就可以，这样可以确保代码一致时反序列化成功。</p>
<p><strong>06、再来点总结 </strong></p>
<p>写这篇文章之前，我真没想到：“空空其身”的 Serializable 竟然有这么多可以研究的内容！</p>
<p>写完这篇文章之后，我不由得想起理科状元曹林菁说说过的一句话：“在学习中再小的问题也不放过，每个知识点都要总结”——说得真真真真的对啊！</p>
<h2 id="5-10-transient关键字"><a href="#5-10-transient关键字" class="headerlink" title="5.10 transient关键字"></a>5.10 transient关键字</h2><p>害，小二最熟的是 Java，但很多 Java 基础知识都不知道，比如 transient 关键字以前就没用到过，所以不知道它的作用是什么，今天去招银面试的时候，面试官问到了这个：说说 Java 的 transient 关键字吧，结果小二直接懵逼了。</p>
<p>下面是他自己面试凉了以后回去做的总结，分享出来，大家一起涨下姿势~~~好了，废话不多说，下面开始：</p>
<p><strong>01、transient 的作用及使用方法 </strong></p>
<p>我们知道，一个对象只要实现了 Serilizable 接口，它就可以被序列化。</p>
<p>在实际开发过程中，我们常常会遇到这样的问题，一个类的有些字段需要序列化，有些字段不需要，比如说用户的一些敏感信息（如密码、银行卡号等），为了安全起见，不希望在网络操作中传输或者持久化到磁盘文件中，那这些字段就可以加上 transient 关键字。</p>
<p>需要注意的是，被 transient 关键字修饰的成员变量在反序列化时会被自动初始化为默认值，例如基本数据类型为 0，引用类型为 null。</p>
<p>来看示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">public class TransientTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        </span><br><span class="line">        User user = new User();</span><br><span class="line">        user.setUsername(&quot;沉默王二&quot;);</span><br><span class="line">        user.setPasswd(&quot;123456&quot;);</span><br><span class="line">        </span><br><span class="line">        System.out.println(&quot;read before Serializable: &quot;);</span><br><span class="line">        System.out.println(&quot;username: &quot; + user.getUsername());</span><br><span class="line">        System.err.println(&quot;password: &quot; + user.getPasswd());</span><br><span class="line">        </span><br><span class="line">        try &#123;</span><br><span class="line">            ObjectOutputStream os = new ObjectOutputStream(</span><br><span class="line">                    new FileOutputStream(&quot;user.txt&quot;));</span><br><span class="line">            os.writeObject(user); // 将User对象写进文件</span><br><span class="line">            os.flush();</span><br><span class="line">            os.close();</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            ObjectInputStream is = new ObjectInputStream(new FileInputStream(</span><br><span class="line">                    &quot;user.txt&quot;));</span><br><span class="line">            user = (User) is.readObject(); // 从流中读取User的数据</span><br><span class="line">            is.close();</span><br><span class="line">            </span><br><span class="line">            System.out.println(&quot;\nread after Serializable: &quot;);</span><br><span class="line">            System.out.println(&quot;username: &quot; + user.getUsername());</span><br><span class="line">            System.err.println(&quot;password: &quot; + user.getPasswd());</span><br><span class="line">            </span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class User implements Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = 8294180014912103005L;  </span><br><span class="line">    </span><br><span class="line">    private String username;</span><br><span class="line">    private transient String passwd;</span><br><span class="line">    </span><br><span class="line">    public String getUsername() &#123;</span><br><span class="line">        return username;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setUsername(String username) &#123;</span><br><span class="line">        this.username = username;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public String getPasswd() &#123;</span><br><span class="line">        return passwd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setPasswd(String passwd) &#123;</span><br><span class="line">        this.passwd = passwd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">read before Serializable:</span><br><span class="line">username: 沉默王二</span><br><span class="line">password: 123456 </span><br><span class="line">read after Serializable:</span><br><span class="line">username: 沉默王二</span><br><span class="line">password: null</span><br></pre></td></tr></table></figure>
<p>密码字段为 null，说明反序列化时根本没有从文件中获取到信息。</p>
<p><strong>02、transient 使用小结 </strong></p>
<p>1）一旦字段被 transient 修饰，成员变量将不再是对象持久化的一部分，该变量的值在序列化后无法访问。</p>
<p>2）transient 关键字只能修饰字段，而不能修饰方法和类。</p>
<p>3）被 transient 关键字修饰的字段不能被序列化，一个静态变量（static关键字修饰）不管是否被 transient 修饰，均不能被序列化，前面讲到过。</p>
<p>来看示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">public class TransientTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        </span><br><span class="line">        User user = new User();</span><br><span class="line">        user.setUsername(&quot;沉默王二&quot;);</span><br><span class="line">        user.setPasswd(&quot;123456&quot;);</span><br><span class="line">        </span><br><span class="line">        System.out.println(&quot;read before Serializable: &quot;);</span><br><span class="line">        System.out.println(&quot;username: &quot; + user.getUsername());</span><br><span class="line">        System.err.println(&quot;password: &quot; + user.getPasswd());</span><br><span class="line">        </span><br><span class="line">        try &#123;</span><br><span class="line">            ObjectOutputStream os = new ObjectOutputStream(</span><br><span class="line">                    new FileOutputStream(&quot;user.txt&quot;));</span><br><span class="line">            os.writeObject(user); // 将User对象写进文件</span><br><span class="line">            os.flush();</span><br><span class="line">            os.close();</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 在反序列化之前改变username的值</span><br><span class="line">            User.username = &quot;沉默王三&quot;;</span><br><span class="line">            </span><br><span class="line">            ObjectInputStream is = new ObjectInputStream(new FileInputStream(&quot;user.txt&quot;));</span><br><span class="line">            user = (User) is.readObject(); // 从流中读取User的数据</span><br><span class="line">            is.close();</span><br><span class="line">            </span><br><span class="line">            System.out.println(&quot;\nread after Serializable: &quot;);</span><br><span class="line">            System.out.println(&quot;username: &quot; + user.getUsername());</span><br><span class="line">            System.err.println(&quot;password: &quot; + user.getPasswd());</span><br><span class="line">            </span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class User implements Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = 8294180014912103005L;  </span><br><span class="line">    </span><br><span class="line">    public static String username;</span><br><span class="line">    private transient String passwd;</span><br><span class="line">    </span><br><span class="line">    public String getUsername() &#123;</span><br><span class="line">        return username;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setUsername(String username) &#123;</span><br><span class="line">        this.username = username;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public String getPasswd() &#123;</span><br><span class="line">        return passwd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setPasswd(String passwd) &#123;</span><br><span class="line">        this.passwd = passwd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">read before Serializable:</span><br><span class="line">username: 沉默王二</span><br><span class="line">password: 123456 </span><br><span class="line">read after Serializable:</span><br><span class="line">username: 沉默王三</span><br><span class="line">password: null</span><br></pre></td></tr></table></figure>
<p>序列化前，static 修饰的 username 为 沉默王二，然后我们在反序列化前将其修改为 沉默王三 了，如果说 static 修饰的字段能保持状态的话，反序列化后应该是 沉默王二，对吧？</p>
<p>但结果是 沉默王三，这就证明了我们之前的结论：<strong>static 修饰的字段不能被序列化。</strong></p>
<p><strong>03、transient 修饰的字段真的不能被序列化？ </strong></p>
<p>思考下面的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class ExternalizableTest implements Externalizable &#123;</span><br><span class="line">    private transient String content = &quot;是的，我将会被序列化，不管我是否被transient关键字修</span><br><span class="line">饰&quot;;</span><br><span class="line">    @Override</span><br><span class="line">    public void writeExternal(ObjectOutput out) throws IOException &#123;</span><br><span class="line">        out.writeObject(content);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void readExternal(ObjectInput in) throws IOException,</span><br><span class="line">            ClassNotFoundException &#123;</span><br><span class="line">        content = (String) in.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        </span><br><span class="line">        ExternalizableTest et = new ExternalizableTest();</span><br><span class="line">        ObjectOutput out = new ObjectOutputStream(new FileOutputStream(</span><br><span class="line">                new File(&quot;test&quot;)));</span><br><span class="line">        out.writeObject(et);</span><br><span class="line">        ObjectInput in = new ObjectInputStream(new FileInputStream(new File(</span><br><span class="line">                &quot;test&quot;)));</span><br><span class="line">        et = (ExternalizableTest) in.readObject();</span><br><span class="line">        System.out.println(et.content);</span><br><span class="line">        out.close();</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看下输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">是的，我将会被序列化，不管我是否被transient关键字修饰</span><br></pre></td></tr></table></figure>
<p>这是为什么呢？不是说 transient 关键字修饰的字段不能序列化吗？</p>
<p>我先说结论，这是因为我们使用了 Externalizable 接口而不是 Serializable接口，这个知识点我们前面其实也讲到过。</p>
<p>在 Java 中，对象的序列化可以通过实现两种接口来实现，如果实现的是 Serializable 接口，则所有的序列化将会自动进行，如果实现的是 Externalizable 接口，则需要在 writeExternal 方法中指定要序列化的字段，与 transient 关键字修饰无关。</p>
<p>因此例子输出的是变量 content 的内容，而不是 null。</p>
<p><strong>04、小结 </strong></p>
<p>transient 关键字用于修饰类的成员变量，在序列化对象时，被修饰的成员变量不会被序列化和保存到文件中。其作用是告诉 JVM 在序列化对象时不需要将该变量的值持久化，这样可以避免一些安全或者性能问题。但是，transient 修饰的成员变量在反序列化时会被初始化为其默认值（如 int 类型会被初始化为 0，引用类型会被初始化为 null），因此需要在程序中进行适当的处理。</p>
<p>transient 关键字和 static 关键字都可以用来修饰类的成员变量。其中，transient 关键字表示该成员变量不参与序列化和反序列化，而 static 关键字表示该成员变量是属于类的，不属于对象的，因此不需要序列化和反序列化。</p>
<p>在 Serializable 和 Externalizable 接口中，transient 关键字的表现也不同，在 Serializable 中表示该成员变量不参与序列化和反序列化，在 Externalizable 中不起作用，因为 Externalizable 接口需要实现 readExternal 和 writeExternal 方法，需要手动完成序列化和反序列化的过程。</p>
<h1 id="6-异常处理"><a href="#6-异常处理" class="headerlink" title="6 异常处理"></a>6 异常处理</h1><h2 id="6-1-Java异常处理全面解析"><a href="#6-1-Java异常处理全面解析" class="headerlink" title="6.1 Java异常处理全面解析"></a>6.1 Java异常处理全面解析</h2><p><strong>01、什么是异常 </strong></p>
<p>“二哥，今天就要学习异常了吗？”三妹问。</p>
<p>“是的。只有正确地处理好异常，才能保证程序的可靠性，所以异常的学习还是很有必要的。”我说。</p>
<p>“那到底什么是异常呢？”三妹问。</p>
<p>“异常是指中断程序正常执行的一个不确定的事件。当异常发生时，程序的正常执行流程就会被打断。一般情况下，程序都会有很多条语句，如果没有异常处理机制，前面的语句一旦出现了异常，后面的语句就没办法继续执行了。”</p>
<p>“有了异常处理机制后，程序在发生异常的时候就不会中断，我们可以对异常进行捕获，然后改变程序执行的流程。”</p>
<p>“除此之外，异常处理机制可以保证我们向用户提供友好的提示信息，而不是程序原生的异常信息——用户根本理解不了。”</p>
<p>“不过，站在开发者的角度，我们更希望看到原生的异常信息，因为这有助于我们更快地找到 bug 的根源，反而被过度包装的异常信息会干扰我们的视线。”</p>
<p>“Java 语言在一开始就提供了相对完善的异常处理机制，这种机制大大降低了编写可靠程序的门槛，这也是 Java 之所以能够流行的原因之一。”</p>
<p>“那导致程序抛出异常的原因有哪些呢？”三妹问。</p>
<p>比如说：</p>
<ul>
<li>程序在试图打开一个不存在的文件；</li>
<li>程序遇到了网络连接问题；</li>
<li>用户输入了糟糕的数据；</li>
<li>程序在处理算术问题时没有考虑除数为 0 的情况；</li>
</ul>
<p>等等等等。</p>
<p>挑个最简单的原因来说吧。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(10/0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码在运行的时候抛出的异常信息如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.ArithmeticException: / by zero</span><br><span class="line">    at com.itwanger.s41.Demo.main(Demo.java:8)</span><br></pre></td></tr></table></figure>
<p>“你看，三妹，这个原生的异常信息对用户来说，显然是不太容易理解的，但对于我们开发者来说，简直不要太直白了——很容易就能定位到异常发生的根源。”</p>
<p><strong>02、Exception和Error的区别 </strong></p>
<p>“哦，我知道了。下一个问题，我经常看到一些文章里提到 Exception 和 Error，二哥你能帮我解释一下它们之间的区别吗？”三妹问。</p>
<p>“这是一个好问题呀，三妹！”</p>
<p>从单词的释义上来看，error 为错误，exception 为异常，错误的等级明显比异常要高一些。</p>
<p>从程序的角度来看，也的确如此。</p>
<p>Error 的出现，意味着程序出现了严重的问题，而这些问题不应该再交给 Java 的异常处理机制来处理，程序应该直接崩溃掉，比如说 OutOfMemoryError，内存溢出了，这就意味着程序在运行时申请的内存大于系统能够提供的内存，导致出现的错误，这种错误的出现，对于程序来说是致命的。</p>
<p>Exception 的出现，意味着程序出现了一些在可控范围内的问题，我们应当采取措施进行挽救。</p>
<p>比如说之前提到的 ArithmeticException，很明显是因为除数出现了 0 的情况，我们可以选择捕获异常，然后提示用户不应该进行除 0 操作，当然了，更好的做法是直接对除数进行判断，如果是 0 就不进行除法运算，而是告诉用户换一个非 0 的数进行运算。</p>
<p><strong>03、checked和unchecked异常 </strong></p>
<p>“三妹，还能想到其他的问题吗？”</p>
<p>“嗯，不用想，二哥，我已经提前做好预习工作了。”三妹自信地说，“异常又可以分为 checked 和 unchecked，它们之间又有什么区别呢？”</p>
<p>“哇，三妹，果然又是一个好问题呢。”</p>
<p>checked 异常（检查型异常）在源代码里必须显式地捕获或者抛出，否则编译器会提示你进行相应的操作；而 unchecked 异常（非检查型异常）就是所谓的运行时异常，通常是可以通过编码进行规避的，并不需要显式地捕获或者抛出。</p>
<p>“我先画一幅思维导图给你感受一下。”</p>
<p><img src="\assets\note\image-20231011114343485.png" alt="image-20231011114343485"></p>
<p>首先，Exception 和 Error 都继承了 Throwable 类。换句话说，只有 Throwable 类（或者子类）的对象才能使用 throw 关键字抛出，或者作为 catch 的参数类型。</p>
<p>面试中经常问到的一个问题是，NoClassDefFoundError 和 ClassNotFoundException 有什么区别？</p>
<p>“三妹你知道吗？”</p>
<p>“不知道，二哥，你解释下呗。”</p>
<p>它们都是由于系统运行时找不到要加载的类导致的，但是触发的原因不一样。</p>
<ul>
<li>NoClassDefFoundError：程序在编译时可以找到所依赖的类，但是在运行时找不到指定的类文件，导致抛出该错误；原因可能是 jar 包缺失或者调用了初始化失败的类。</li>
<li>ClassNotFoundException：当动态加载 Class 对象的时候找不到对应的类时抛出该异常；原因可能是要加载的类不存在或者类名写错了。</li>
</ul>
<p>其次，像 IOException、ClassNotFoundException、SQLException 都属于 checked 异常；像 RuntimeException 以及子类 ArithmeticException、ClassCastException、ArrayIndexOutOfBoundsException、NullPointerException，都属于 unchecked 异常。</p>
<p>unchecked 异常可以不在程序中显示处理，就像之前提到的 ArithmeticException 就是的；但 checked 异常必须显式处理。</p>
<p>比如说下面这行代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clz = Class.forName(&quot;com.itwanger.s41.Demo1&quot;);</span><br></pre></td></tr></table></figure>
<p>如果没做处理，比如说在 Intellij IDEA 环境下，就会提示你这行代码可能会抛出 java.lang.ClassNotFoundException 。</p>
<p><img src="\assets\note\image-20231011114528608.png" alt="image-20231011114528608"></p>
<p>建议你要么使用 try-catch 进行捕获：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    Class clz = Class.forName(&quot;com.itwanger.s41.Demo1&quot;);</span><br><span class="line">&#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意打印异常堆栈信息的 printStackTrace() 方法，该方法会将异常的堆栈信息打印到标准的控制台下，如果是测试环境，这样的写法还 OK，如果是生产环境，这样的写法是不可取的，必须使用日志框架把异常的堆栈信息输出到日志系统中，否则可能没办法跟踪。</p>
<p>要么在方法签名上使用 throws 关键字抛出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Demo1 &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException &#123;</span><br><span class="line">        Class clz = Class.forName(&quot;com.itwanger.s41.Demo1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样做的好处是不需要对异常进行捕获处理，只需要交给 Java 虚拟机来处理即可；坏处就是没法针对这种情况做相应的处理。</p>
<p>“二哥，针对 checked 异常，我在知乎上看到一个帖子，说 Java 中的 checked 很没有必要，这种异常在编译期要么 try-catch，要么 throws，但又不一定会出现异常，你觉得这样的设计有意义吗？”三妹提出了一个很尖锐的问题。</p>
<p>“哇，这种问题问的好。”我不由得对三妹心生敬佩。</p>
<p>“的确，checked 异常在业界是有争论的，它假设我们捕获了异常，并且针对这种情况作了相应的处理，但有些时候，根本就没法处理。”我说，“就拿上面提到的 ClassNotFoundException 异常来说，我们假设对其进行了 try-catch，可真的出现了 ClassNotFoundException 异常后，我们也没多少的可操作性，再 Class.forName() 一次？”</p>
<p>另外，checked 异常也不兼容函数式编程，后面如果你写 Lambda/Stream 代码的时候，就会体验到这种苦涩。</p>
<p>当然了，checked 异常并不是一无是处，尤其是在遇到 IO 或者网络异常的时候，比如说进行 Socket 链接，我大致写了一段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Demo2 &#123;</span><br><span class="line">    private String mHost;</span><br><span class="line">    private int mPort;</span><br><span class="line">    private Socket mSocket;</span><br><span class="line">    private final Object mLock = new Object();</span><br><span class="line">    public void run() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    private void initSocket() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Socket socket = new Socket(mHost, mPort);</span><br><span class="line">                synchronized (mLock) &#123;</span><br><span class="line">                    mSocket = socket;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当发生 IOException 的时候，socket 就重新尝试连接，否则就 break 跳出循环。意味着如果 IOException 不是 checked 异常，这种写法就略显突兀，因为 IOException 没办法像 ArithmeticException 那样用一个 if 语句判断除数是否为 0 去规避。</p>
<p>或者说，强制性的 checked 异常可以让我们在编程的时候去思考，遇到这种异常的时候该怎么更优雅的去处理。显然，Socket 编程中，肯定是会遇到 IOException 的，假如 IOException 是非检查型异常，就意味着开发者也可以不考虑，直接跳过，交给 Java 虚拟机来处理，但我觉得这样做肯定更不合适。</p>
<p><strong>04、关于 throw 和 throws </strong></p>
<p>“二哥，你能告诉我 throw 和 throws 两个关键字的区别吗？”三妹问。</p>
<p>“throw 关键字，用于主动地抛出异常；正常情况下，当除数为 0 的时候，程序会主动抛出 ArithmeticException；但如果我们想要除数为 1 的时候也抛出 ArithmeticException，就可以使用 throw 关键字主动地抛出异常。”我说。</p>
<p>语法也非常简单，throw 关键字后跟上 new 关键字，以及异常的类型还有参数即可。</p>
<p>举个例子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ThrowDemo &#123;</span><br><span class="line">    static void checkEligibilty(int stuage)&#123;</span><br><span class="line">        if(stuage&lt;18) &#123;</span><br><span class="line">            throw new ArithmeticException(&quot;年纪未满 18 岁，禁止观影&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;请认真观影!!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String args[])&#123;</span><br><span class="line">        checkEligibilty(10);</span><br><span class="line">        System.out.println(&quot;愉快地周末..&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码在运行的时候就会抛出以下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.ArithmeticException: 年纪未满 18 岁，禁止观影</span><br><span class="line">    at com.itwanger.s43.ThrowDemo.checkEligibilty(ThrowDemo.java:9)</span><br><span class="line">    at com.itwanger.s43.ThrowDemo.main(ThrowDemo.java:16)</span><br></pre></td></tr></table></figure>
<p>“throws 关键字的作用就和 throw 完全不同。”我说，“前面的小节里已经讲了 checked exception 和 unchecked exception，也就是检查型异常和非检查型异常；对于检查型异常来说，如果你没有做处理，编译器就会提示你。”</p>
<p>Class.forName() 方法在执行的时候可能会遇到 java.lang.ClassNotFoundException 异常，一个检查型异常，如果没有做处理，IDEA 就会提示你，要么在方法签名上声明，要么放在 try-catch 中。</p>
<p><img src="\assets\note\image-20231011114921164.png" alt="image-20231011114921164"></p>
<p>“那什么情况下使用 throws 而不是 try-catch 呢？”三妹问。</p>
<p>“假设现在有这么一个方法 myMethod() ，可能会出现 ArithmeticException 异常，也可能会出现 NullPointerException。这种情况下，可以使用 try-catch 来处理。”我回答。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void myMethod() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 可能抛出异常 </span><br><span class="line">    &#125; catch (ArithmeticException e) &#123;</span><br><span class="line">        // 算术异常</span><br><span class="line">    &#125; catch (NullPointerException e) &#123;</span><br><span class="line">        // 空指针异常</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“但假设有好几个类似 myMethod() 的方法，如果为每个方法都加上 try-catch，就会显得非常繁琐。代码就会变得又臭又长，可读性就差了。”我继续说。</p>
<p>“一个解决办法就是，使用 throws 关键字，在方法签名上声明可能会抛出的异常，然后在调用该方法的地方使用 try-catch 进行理。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String args[])&#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        myMethod1();</span><br><span class="line">    &#125; catch (ArithmeticException e) &#123;</span><br><span class="line">        // 算术异常</span><br><span class="line">    &#125; catch (NullPointerException e) &#123;</span><br><span class="line">        // 空指针异常</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void myMethod1() throws ArithmeticException, NullPointerException&#123;</span><br><span class="line">    // 方法签名上声明异常</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“好了，我来总结下 throw 和 throws 的区别，三妹，你记一下。”</p>
<p> 1）throws 关键字用于声明异常，它的作用和 try-catch 相似；而 throw 关键字用于显式的抛出异常。</p>
<p>2）throws 关键字后面跟的是异常的名字；而 throw 关键字后面跟的是异常的对象。</p>
<p>示例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throws ArithmeticException;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throw new ArithmeticException(&quot;算术异常&quot;);</span><br></pre></td></tr></table></figure>
<p>3）throws 关键字出现在方法签名上，而 throw 关键字出现在方法体里。</p>
<p>4）throws 关键字在声明异常的时候可以跟多个，用逗号隔开；而 throw 关键字每次只能抛出一个异常。</p>
<p><strong>05、关于 try-catch-finally </strong></p>
<p>“二哥，之前你讲了异常处理机制，这一节讲什么呢？”三妹问。</p>
<p>“该讲 try-catch-finally 了。”我说，“try 关键字后面会跟一个大括号 {} ，我们把一些可能发生异常的代码放到大括号里； try 块后面一般会跟 catch 块，用来处理发生异常的情况；当然了，异常不一定会发生，为了保证发不发生异常都能执行一些代码，就会跟一个 finally 块。”</p>
<p>“具体该怎么用呀，二哥？”三妹问。</p>
<p>“别担心，三妹，我一一来说明下。”我说。</p>
<p>try 块的语法很简单：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">// 可能发生异常的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“注意啊，三妹，如果一些代码确定不会抛出异常，就尽量不要把它包裹在 try 块里，因为加了异常处理的代码执行起来要比没有加的花费更多的时间。”</p>
<p>catch 块的语法也很简单：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">// 可能发生异常的代码</span><br><span class="line">&#125;catch (exception(type) e(object))&#123;</span><br><span class="line">// 异常处理代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个 try 块后面可以跟多个 catch 块，用来捕获不同类型的异常并做相应的处理，当 try 块中的某一行代码发生异常时，之后的代码就不再执行，而是会跳转到异常对应的 catch 块中执行。</p>
<p>如果一个 try 块后面跟了多个与之关联的 catch 块，那么应该把特定的异常放在前面，通用型的异常放在后面，不然编译器会提示错误。举例来说。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static void test() &#123;</span><br><span class="line">    int num1, num2;</span><br><span class="line">    try &#123;</span><br><span class="line">        num1 = 0;</span><br><span class="line">        num2 = 62 / num1;</span><br><span class="line">        System.out.println(num2);</span><br><span class="line">        System.out.println(&quot;try 块的最后一句&quot;);</span><br><span class="line">    &#125; catch (ArithmeticException e) &#123;</span><br><span class="line">        // 算术运算发生时跳转到这里</span><br><span class="line">        System.out.println(&quot;除数不能为零&quot;);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        // 通用型的异常意味着可以捕获所有的异常，它应该放在最后面，</span><br><span class="line">        System.out.println(&quot;异常发生了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;try-catch 之外的代码.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“为什么 Exception 不能放到 ArithmeticException 前面呢？”三妹问。</p>
<p>“因为 ArithmeticException 是 Exception 的子类，它更具体，我们看到就这个异常就知道是发生了算术错误，而 Exception 比较泛，它隐藏了具体的异常信息，我们看到后并不确定到底是发生了哪一种类型的异常，对错误的排查很不利。”我说，“再者，如果把通用型的异常放在前面，就意味着其他的 catch 块永远也不会执行，所以编译器就直接提示错误了。”</p>
<p>“再给你举个例子，注意看，三妹。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static void test1 () &#123;</span><br><span class="line">    try&#123;</span><br><span class="line">        int arr[]=new int[7];</span><br><span class="line">        arr[4]=30/0;</span><br><span class="line">        System.out.println(&quot;try 块的最后&quot;);</span><br><span class="line">    &#125; catch(ArithmeticException e)&#123;</span><br><span class="line">        System.out.println(&quot;除数必须是 0&quot;);</span><br><span class="line">    &#125; catch(ArrayIndexOutOfBoundsException e)&#123;</span><br><span class="line">        System.out.println(&quot;数组越界了&quot;);</span><br><span class="line">    &#125; catch(Exception e)&#123;</span><br><span class="line">        System.out.println(&quot;一些其他的异常&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;try-catch 之外&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码在执行的时候，第一个 catch 块会执行，因为除数为零；我再来稍微改动下代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static void test1 () &#123;</span><br><span class="line">    try&#123;</span><br><span class="line">        int arr[]=new int[7];</span><br><span class="line">        arr[9]=30/1;</span><br><span class="line">        System.out.println(&quot;try 块的最后&quot;);</span><br><span class="line">    &#125; catch(ArithmeticException e)&#123;</span><br><span class="line">        System.out.println(&quot;除数必须是 0&quot;);</span><br><span class="line">    &#125; catch(ArrayIndexOutOfBoundsException e)&#123;</span><br><span class="line">        System.out.println(&quot;数组越界了&quot;);</span><br><span class="line">    &#125; catch(Exception e)&#123;</span><br><span class="line">        System.out.println(&quot;一些其他的异常&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;try-catch 之外&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“我知道，二哥，第二个 catch 块会执行，因为没有发生算术异常，但数组越界了。”三妹没等我把代码运行起来就说出了答案。</p>
<p>“三妹，你说得很对，我再来改一下代码。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static void test1 () &#123;</span><br><span class="line">    try&#123;</span><br><span class="line">        int arr[]=new int[7];</span><br><span class="line">        arr[9]=30/1;</span><br><span class="line">        System.out.println(&quot;try 块的最后&quot;);</span><br><span class="line">    &#125; catch(ArithmeticException | ArrayIndexOutOfBoundsException e)&#123;</span><br><span class="line">        System.out.println(&quot;除数必须是 0&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;try-catch 之外&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“当有多个 catch 的时候，也可以放在一起，用竖划线 | 隔开，就像上面这样。”我说。</p>
<p>“这样不错呀，看起来更简洁了。”三妹说。</p>
<p>finally 块的语法也不复杂。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    // 可能发生异常的代码</span><br><span class="line">&#125;catch &#123;</span><br><span class="line">   // 异常处理</span><br><span class="line">&#125;finally &#123;</span><br><span class="line">   // 必须执行的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在没有 try-with-resources 之前，finally 块常用来关闭一些连接资源，比如说 socket、数据库链接、IO 输入输出流等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OutputStream osf = new FileOutputStream( &quot;filename&quot; );</span><br><span class="line">OutputStream osb = new BufferedOutputStream(opf);</span><br><span class="line">ObjectOutput op = new ObjectOutputStream(osb);</span><br><span class="line">try&#123;</span><br><span class="line">    output.writeObject(writableObject);</span><br><span class="line">&#125; finally&#123;</span><br><span class="line">    op.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“三妹，注意，使用 finally 块的时候需要遵守这些规则。”</p>
<ul>
<li>finally 块前面必须有 try 块，不要把 finally 块单独拉出来使用。编译器也不允许这样做。</li>
<li>finally 块不是必选项，有 try 块的时候不一定要有 finally 块。</li>
<li>如果 finally 块中的代码可能会发生异常，也应该使用 try-catch 进行包裹。</li>
<li>即便是 try 块中执行了 return、break、continue 这些跳转语句，finally 块也会被执行。</li>
</ul>
<p>“真的吗，二哥？”三妹对最后一个规则充满了疑惑。</p>
<p>“来试一下就知道了。”我说。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static int test2 () &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        return 112;</span><br><span class="line">    &#125;</span><br><span class="line">    finally &#123;</span><br><span class="line">        System.out.println(&quot;即使 try 块有 return，finally 块也会执行&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看一下输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">即使 try 块有 return，finally 块也会执行</span><br></pre></td></tr></table></figure>
<p>“那，会不会有不执行 finally 的情况呀？”三妹很好奇。</p>
<p>“有的。”我斩钉截铁地回答。</p>
<ul>
<li>遇到了死循环。</li>
<li>执行了 System. exit() 这行代码。</li>
</ul>
<p>System.exit() 和 return 语句不同，前者是用来退出程序的，后者只是回到了上一级方法调用。</p>
<p>“三妹，来看一下源码的文档注释就全明白了！”</p>
<p><img src="\assets\note\image-20231011115617590.png" alt="image-20231011115617590"></p>
<p>至于参数 status 的值也很好理解，如果是异常退出，设置为非 0 即可，通常用 1 来表示；如果是想正常退出程序，用 0 表示即可。</p>
<p><strong>06、小结 </strong></p>
<p>Java 的异常处理是一种重要的机制，可以帮助我们处理程序执行期间发生的错误 或异常。</p>
<p>异常分为两类：Checked Exception 和 Unchecked Exception，其中 Checked Exception 需要在代码中显式地处理或声明抛出，而 Unchecked Exception 不需要在代码中显式地处理或声明抛出。异常处理通常使用 try-catch-finally 块来处理，也可以使用 throws 关键字将异常抛出给调用者处理。</p>
<p>下面是 Java 异常处理的一些总结：</p>
<ul>
<li>使用 try-catch 块捕获并处理异常，可以避免程序因异常而崩溃。</li>
<li>可以使用多个 catch 块来捕获不同类型的异常，并进行不同的处理。</li>
<li>可以使用 finally 块来执行一些必要的清理工作，无论是否发生异常都会执行。</li>
<li>可以使用 throw 关键字手动抛出异常，用于在程序中明确指定某些异常情况。</li>
<li>可以使用 throws 关键字将异常抛出给调用者处理，用于在方法签名中声明可能会出现的异常。</li>
<li>Checked Exception 通常是由于外部因素导致的问题，需要在代码中显式地处理或声明抛出。</li>
<li>Unchecked Exception 通常是由于程序内部逻辑或数据异常导致的，可以不处理或者在需要时进行处理。</li>
<li>在处理异常时，应该根据具体的异常类型进行处理，例如可以尝试重新打开文件、重新建立网络连接等操作。</li>
<li>异常处理应该根据具体的业务需求和设计原则进行，避免过度捕获和处理异常，从而降低程序的性能和可维护性。</li>
</ul>
<h2 id="6-2-try-with-resources"><a href="#6-2-try-with-resources" class="headerlink" title="6.2 try-with-resources"></a>6.2 try-with-resources</h2><p>“二哥，终于等到你讲 try-with-resources 了！”三妹夸张的表情让我有些吃惊。</p>
<p>“三妹，不要激动呀！开讲之前，我们还是要来回顾一下 try–catch-finally，好做个铺垫。”我说，“来看看这段代码吧。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class TrycatchfinallyDecoder &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BufferedReader br = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            String path = TrycatchfinallyDecoder.class.getResource(&quot;/牛逼.txt&quot;).getFile();</span><br><span class="line">            String decodePath = URLDecoder.decode(path,&quot;utf-8&quot;);</span><br><span class="line">            br = new BufferedReader(new FileReader(decodePath));</span><br><span class="line">            String str = null;</span><br><span class="line">            while ((str =br.readLine()) != null) &#123;</span><br><span class="line">                System.out.println(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (br != null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    br.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“我简单来解释下。”等三妹看完这段代码后，我继续说，“在 try 块中读取文件中的内容，并一行一行地打印到控制台。如果文件找不到或者出现 IO 读写错误，就在 catch 中捕获并打印错误的堆栈信息。最后，在 finally 中关闭缓冲字符读取器对象 BufferedReader，有效杜绝了资源未被关闭的情况下造成的严重性能后果。”</p>
<p>“在 Java 7 之前，try–catch-finally 的确是确保资源会被及时关闭的最佳方法，无论程序是否会抛出异常。”</p>
<p>三妹点了点头，表示同意。</p>
<p>“不过，这段代码还是有些臃肿，尤其是 finally 中的代码。”我说，“况且，try–catch-finally 至始至终存在一个严重的隐患：try 中的 br.readLine() 有可能会抛出 IOException ，finally 中的 br.close() 也有可能会抛出 IOException 。假如两处都不幸地抛出了 IOException，那程序的调试任务就变得复杂了起来，到底是哪一处出了错误，就需要花一番功夫，这是我们不愿意看到的结果。”</p>
<p>“我来给你演示下，三妹。”</p>
<p>“首先，我们来定义这样一个类 MyfinallyReadLineThrow，它有两个方法，分别是 readLine() 和 close() ，方法体都是主动抛出异常。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class MyfinallyReadLineThrow &#123;</span><br><span class="line">    public void close() throws Exception &#123;</span><br><span class="line">        throw new Exception(&quot;close&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void readLine() throws Exception &#123;</span><br><span class="line">        throw new Exception(&quot;readLine&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“然后在 main() 方法中使用 try-catch-finally 的方式调用 MyfinallyReadLineThrow 的 readLine() 和 close() 方法。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class TryfinallyCustomReadLineThrow &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        MyfinallyReadLineThrow myThrow = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            myThrow = new MyfinallyReadLineThrow();</span><br><span class="line">            myThrow.readLine();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            myThrow.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上述代码后，错误堆栈如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.Exception: close</span><br><span class="line">    at </span><br><span class="line">com.cmower.dzone.trycatchfinally.MyfinallyOutThrow.close(TryfinallyCustomOutThrow.ja</span><br><span class="line">va:17)</span><br><span class="line">    at </span><br><span class="line">com.cmower.dzone.trycatchfinally.TryfinallyCustomOutThrow.main(TryfinallyCustomOutTh</span><br><span class="line">row.java:10)</span><br></pre></td></tr></table></figure>
<p>“看出来问题了吗，三妹？”</p>
<p>“啊？ readLine() 方法的异常信息竟然被 close() 方法的堆栈信息吃了！”</p>
<p>“不错啊，三妹，火眼金睛，的确，这会让我们误以为要调查的目标是 close() 方法而不是 readLine() 方法——尽管它也是应该怀疑的对象。”</p>
<p>“但有了 try-with-resources 后，这些问题就迎刃而解了。前提条件只有一个，就是需要释放的资源（比如 BufferedReader）实现了 AutoCloseable 接口。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try (BufferedReader br = new BufferedReader(new FileReader(decodePath));) &#123;</span><br><span class="line">    String str = null;</span><br><span class="line">    while ((str =br.readLine()) != null) &#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“你瞧，三妹，finally 块消失了，取而代之的是把要释放的资源写在 try 后的 () 中。如果有多个资源（BufferedReader 和 PrintWriter）需要释放的话，可以直接在 () 中添加。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try (BufferedReader br = new BufferedReader(new FileReader(decodePath));</span><br><span class="line">     PrintWriter writer = new PrintWriter(new File(writePath))) &#123;</span><br><span class="line">    String str = null;</span><br><span class="line">    while ((str =br.readLine()) != null) &#123;</span><br><span class="line">        writer.print(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“如果想释放自定义资源的话，只要让它实现 AutoCloseable 接口，并提供 close() 方法即可。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class TrywithresourcesCustom &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try (MyResource resource = new MyResource();) &#123;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class MyResource implements AutoCloseable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void close() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;关闭自定义资源&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看一下代码运行后的输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">关闭自定义资源</span><br></pre></td></tr></table></figure>
<p>“好神奇呀！”三妹欣喜若狂，“在 try () 中只是 new 了一个 MyResource 的对象，其他什么也没干，close() 方法就执行了！”</p>
<p>“想知道为什么吗？三妹。”</p>
<p>“当然想啊。”</p>
<p>“来看看反编译后的字节码吧。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class MyResource implements AutoCloseable &#123;</span><br><span class="line">    MyResource() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public void close() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;关闭自定义资源&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class TrywithresourcesCustom &#123;</span><br><span class="line">    public TrywithresourcesCustom() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            MyResource resource = new MyResource();</span><br><span class="line">            resource.close();</span><br><span class="line">        &#125; catch (Exception var2) &#123;</span><br><span class="line">            var2.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“啊，原来如此。编译器主动为 try-with-resources 进行了变身，在 try 中调用了 close() 方法。”</p>
<p>“是这样的。接下来，我们在 MyResourceOut 类中再添加一个 out() 方法。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class MyResourceOut implements AutoCloseable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void close() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;关闭自定义资源&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void out() throws Exception&#123;</span><br><span class="line">        System.out.println(&quot;沉默王二，一枚有趣的程序员&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“这次，我们在 try 中调用一下 out() 方法。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class TrywithresourcesCustomOut &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try (MyResourceOut resource = new MyResourceOut();) &#123;</span><br><span class="line">            resource.out();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“再来看一下反编译的字节码。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class TrywithresourcesCustomOut &#123;</span><br><span class="line">    public TrywithresourcesCustomOut() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            MyResourceOut resource = new MyResourceOut();</span><br><span class="line">            try &#123;</span><br><span class="line">                resource.out();</span><br><span class="line">            &#125; catch (Throwable var5) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    resource.close();</span><br><span class="line">                &#125; catch (Throwable var4) &#123;</span><br><span class="line">                    var5.addSuppressed(var4);</span><br><span class="line">                &#125;</span><br><span class="line">                throw var5;</span><br><span class="line">            &#125;</span><br><span class="line">            resource.close();</span><br><span class="line">        &#125; catch (Exception var6) &#123;</span><br><span class="line">            var6.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“这次， catch 块主动调用了 resource.close() ，并且有一段很关键的代码 var5.addSuppressed(var4) 。”</p>
<p>“这是为了什么呢？”三妹问。</p>
<p>“当一个异常被抛出的时候，可能有其他异常因为该异常而被抑制住，从而无法正常抛出。这时可以通过 addSuppressed() 方法把这些被抑制的方法记录下来，然后被抑制的异常就会出现在抛出的异常的堆栈信息中，可以通过 getSuppressed() 方法来获取这些异常。这样做的好处是不会丢失任何异常，方便我们进行调试。”我说。</p>
<p>“有没有想到之前的那个例子——在 try-catch-finally 中， readLine() 方法的异常信息竟然被 close() 方法的堆栈信息吃了。现在有了 try-with-resources，再来看看和 readLine() 方法一致的 out() 方法会不会被 close() 吃掉吧。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class MyResourceOutThrow implements AutoCloseable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void close() throws Exception &#123;</span><br><span class="line">        throw  new Exception(&quot;close()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void out() throws Exception&#123;</span><br><span class="line">        throw new Exception(&quot;out()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“调用这 2 个方法。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class TrywithresourcesCustomOutThrow &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try (MyResourceOutThrow resource = new MyResourceOutThrow();) &#123;</span><br><span class="line">            resource.out();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“程序输出的结果如下所示。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Exception: out()</span><br><span class="line">    at </span><br><span class="line">com.cmower.dzone.trycatchfinally.MyResourceOutThrow.out(TrywithresourcesCustomOutThr</span><br><span class="line">ow.java:20)</span><br><span class="line">    at </span><br><span class="line">com.cmower.dzone.trycatchfinally.TrywithresourcesCustomOutThrow.main(Trywithresource</span><br><span class="line">sCustomOutThrow.java:6)</span><br><span class="line">    Suppressed: java.lang.Exception: close()</span><br><span class="line">        at </span><br><span class="line">com.cmower.dzone.trycatchfinally.MyResourceOutThrow.close(TrywithresourcesCustomOutT</span><br><span class="line">hrow.java:16)</span><br><span class="line">        at </span><br><span class="line">com.cmower.dzone.trycatchfinally.TrywithresourcesCustomOutThrow.main(Trywithresource</span><br><span class="line">sCustomOutThrow.java:5)</span><br></pre></td></tr></table></figure>
<p>“瞧，这次不会了， out() 的异常堆栈信息打印出来了，并且 close() 方法的堆栈信息上加了一个关键字 Suppressed ，一目了然。”</p>
<p>“三妹，怎么样？是不是感觉 try-with-resources 好用多了！我来简单总结下哈，在处理必须关闭的资源时，始终有限考虑使用 try-with-resources，而不是 try–catch-finally。前者产生的代码更加简洁、清晰，产生的异常信息也更靠谱。”</p>
<p>“靠谱！”三妹说。</p>
<h2 id="6-3-异常处理的20个最佳实践"><a href="#6-3-异常处理的20个最佳实践" class="headerlink" title="6.3 异常处理的20个最佳实践"></a>6.3 异常处理的20个最佳实践</h2><p>“三妹啊，今天我来给你传授 20 个异常处理的最佳实践经验，以免你以后在开发中采坑。”我面带着微笑对三妹说。</p>
<p>“好啊，二哥，我洗耳恭听。”三妹也微微一笑，欣然接受。</p>
<p>“好，那哥就不废话了。开整。”</p>
<p><strong>01、尽量不要捕获 RuntimeException </strong></p>
<p>阿里出品的 Java 开发手册上这样规定：</p>
<blockquote>
<p>尽量不要 catch RuntimeException，比如 NullPointerException、IndexOutOfBoundsException 等等，应该用预检查的方式来规避。</p>
</blockquote>
<p>正例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (obj != null) &#123;</span><br><span class="line">  //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123; </span><br><span class="line">  obj.method(); </span><br><span class="line">&#125; catch (NullPointerException e) &#123;</span><br><span class="line">  //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“哦，那如果有些异常预检查不出来呢？”三妹问。</p>
<p>“的确会存在这样的情况，比如说 NumberFormatException，虽然也属于 RuntimeException，但没办法预检查，所以还是应该用 catch 捕获处理。”我说。</p>
<p><strong>02、尽量使用 try-with-resource 来关闭资源 </strong></p>
<p>当需要关闭资源时，尽量不要使用 try-catch-finally，禁止在 try 块中直接关闭资源。</p>
<p>反例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void doNotCloseResourceInTry() &#123;</span><br><span class="line">    FileInputStream inputStream = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        File file = new File(&quot;./tmp.txt&quot;);</span><br><span class="line">        inputStream = new FileInputStream(file);</span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“为什么呢？”三妹问。</p>
<p>“原因也很简单，因为一旦 close() 之前发生了异常，那么资源就无法关闭。直接使用 try-with-resource 来处理是最佳方式。”我说。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void automaticallyCloseResource() &#123;</span><br><span class="line">    File file = new File(&quot;./tmp.txt&quot;);</span><br><span class="line">    try (FileInputStream inputStream = new FileInputStream(file);) &#123;</span><br><span class="line">    &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“除非资源没有实现 AutoCloseable 接口。”我补充道。</p>
<p>“那这种情况下怎么办呢？”三妹问。</p>
<p>“就在 finally 块关闭流。”我说。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void closeResourceInFinally() &#123;</span><br><span class="line">    FileInputStream inputStream = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        File file = new File(&quot;./tmp.txt&quot;);</span><br><span class="line">        inputStream = new FileInputStream(file);</span><br><span class="line">    &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (inputStream != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                log.error(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>03、不要捕获 Throwable </strong></p>
<p>Throwable 是 exception 和 error 的父类，如果在 catch 子句中捕获了 Throwable，很可能把超出程序处理能力之外的错误也捕获了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void doNotCatchThrowable() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        // 不要这样做</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“到底为什么啊？”三妹问。</p>
<p>“因为有些 error 是不需要程序来处理，程序可能也处理不了，比如说 OutOfMemoryError 或者 StackOverflowError，前者是因为 Java 虚拟机无法申请到足够的内存空间时出现的非正常的错误，后者是因为线程申请的栈深度超过了允许的最大深度出现的非正常错误，如果捕获了，就掩盖了程序应该被发现的严重错误。”我说。</p>
<p>“打个比方，一匹马只能拉一车厢的货物，拉两车厢可能就挂了，但一 catch，就发现不了问题了。”我补充道。</p>
<p><strong>04、不要省略异常信息的记录 </strong></p>
<p>很多时候，由于疏忽大意，我们很容易捕获了异常却没有记录异常信息，导致程序上线后真的出现了问题却没有记录可查。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void doNotIgnoreExceptions() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">    &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">        // 没有记录异常</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应该把错误信息记录下来。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void logAnException() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">    &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">        log.error(&quot;哦，错误竟然发生了: &quot; + e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>05、不要记录了异常又抛出了异常 </strong></p>
<p>这纯属画蛇添足，并且容易造成错误信息的混乱。</p>
<p>反例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">&#125; catch (NumberFormatException e) &#123;</span><br><span class="line">    log.error(e);</span><br><span class="line">    throw e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要抛出就抛出，不要记录，记录了又抛出，等于多此一举。</p>
<p>反例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void wrapException(String input) throws MyBusinessException &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">    &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">        throw new MyBusinessException(&quot;错误信息描述：&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种也是一样的道理，既然已经捕获了，就不要在方法签名上抛出了。</p>
<p><strong>06、不要在 finally 块中使用 return </strong></p>
<p>阿里出品的 Java 开发手册上这样规定：</p>
<blockquote>
<p>try 块中的 return 语句执行成功后，并不会马上返回，而是继续执行 finally 块中的语句，如果 finally 块中也存在 return 语句，那么 try 块中的 return 就将被覆盖。</p>
</blockquote>
<p>反例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private int x = 0;</span><br><span class="line">public int checkReturn() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        return ++x;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        return ++x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“哦，确实啊，try 块中 x 返回的值为 1，到了 finally 块中就返回 2 了。”三妹说。</p>
<p>“是这样的。”我点点头。</p>
<p><strong>07、抛出具体定义的检查性异常而不是 Exception </strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public void foo() throws Exception &#123; //错误方式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一定要避免出现上面的代码，它破坏了检查性（checked）异常的目的。声明的方法应该尽可能抛出具体的检查性异常。</p>
<p>例如，如果一个方法可能会抛出 SQLException 异常，应该显式地声明抛出 SQLException 而不是 Exception 类型的异常。这样可以让其他开发者更好地理解代码的意图和异常处理的方式，并且可以根据 SQLException 的定义和文档来确定异常的处理方式和策略。</p>
<p><strong>08、捕获具体的子类而不是捕获 Exception 类 </strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">   someMethod();</span><br><span class="line">&#125; catch (Exception e) &#123; //错误方式</span><br><span class="line">   LOGGER.error(&quot;method has failed&quot;, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在 catch 块中捕获 Exception 类型的异常，会将所有异常都捕获，从而可能会给程序带来不必要的麻烦。具体来说，如果捕获 Exception 类型的异常，可能会导致以下问题：</p>
<ul>
<li>难以识别和定位异常：如果捕获 Exception 类型的异常，可能会捕获到一些不应该被处理的异常，从而导致程序难以识别和定位异常。</li>
<li>难以调试和排错：如果捕获 Exception 类型的异常，可能会使得调试和排错变得更加困难，因为无法确定具体的异常类型和异常发生的原因。</li>
</ul>
<p>下面举一个例子来说明为什么应该尽可能地捕获具体的子类而不是 Exception 类型的异常。</p>
<p>假设我们有一个方法 readFromFile(String filePath) ，用于从指定文件中读取数据。在方法实现过程中，可能会出现两种异常：FileNotFoundException 和 IOException。</p>
<p>如果在方法中使用以下 catch 块来捕获异常：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    // 读取数据的代码</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    // 异常处理的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样做会捕获所有类型的异常，包括 Checked Exception 和 Unchecked Exception。这可能会导致以下问题：</p>
<ul>
<li>发生 RuntimeException 类型的异常时，也会被捕获，从而可能会掩盖实际的异常信息。</li>
<li>在调试和排错时，无法确定异常的具体类型和发生原因，从而增加了调试和排错的难度。</li>
<li>在程序运行时，可能会捕获一些不需要处理的异常（如 NullPointerException、IllegalArgumentException 等），从而降低程序的性能和稳定性。</li>
</ul>
<p>因此，为了更好地定位和处理异常，应该尽可能地捕获具体的子类，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    // 读取数据的代码</span><br><span class="line">&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">    // 处理文件未找到异常的代码</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    // 处理输入输出异常的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样做可以更准确地捕获异常，从而提高程序的健壮性和稳定性。</p>
<p><strong>09、自定义异常时不要丢失堆栈跟踪 </strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">catch (NoSuchMethodException e) &#123;</span><br><span class="line">   throw new MyServiceException(&quot;Some information: &quot; + e.getMessage());  //错误方式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这破坏了原始异常的堆栈跟踪，正确的做法是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">catch (NoSuchMethodException e) &#123;</span><br><span class="line">   throw new MyServiceException(&quot;Some information: &quot; , e);  //正确方式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如，下面是一个自定义异常类，它重写了 printStackTrace() 方法来打印堆栈跟踪信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class MyException extends Exception &#123;</span><br><span class="line">    public MyException(String message, Throwable cause) &#123;</span><br><span class="line">        super(message, cause);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void printStackTrace() &#123;</span><br><span class="line">        System.err.println(&quot;MyException:&quot;);</span><br><span class="line">        super.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样做可以保留堆栈跟踪信息，同时也可以提供自定义的异常信息。在抛出 MyException 异常时，可以得到完整的堆栈跟踪信息，从而更好地定位和解决异常。</p>
<p><strong>10、finally 块中不要抛出任何异常</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  someMethod();  //Throws exceptionOne</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">  cleanUp();    //如果finally还抛出异常，那么exceptionOne将永远丢失</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>finally 块用于定义一段代码，无论 try 块中是否出现异常，都会被执行。finally 块通常用于释放资源、关闭文件等必须执行的操作。</p>
<p>如果在 finally 块中抛出异常，可能会导致原始异常被掩盖。比如说上例中，一旦 cleanup 抛出异常，someMethod 中的异常将会被覆盖。</p>
<p><strong>11、不要在生产环境中使用 </strong> </p>
<p>在 Java 中， printStackTrace() 方法用于将异常的堆栈跟踪信息输出到标准错误流中。这个方法对于调试和排错非常有用。但在生产环境中，不应该使用 printStackTrace() 方法，因为它可能会导致以下问题：</p>
<ul>
<li>printStackTrace() 方法将异常的堆栈跟踪信息输出到标准错误流中，这可能会暴露敏感信息，如文件路径、用户名、密码等。</li>
<li>printStackTrace() 方法会将堆栈跟踪信息输出到标准错误流中，这可能会影响程序的性能和稳定性。在高并发的生产环境中，大量的异常堆栈跟踪信息可能会导致系统崩溃或出现意外的行为。</li>
<li>由于生产环境中往往是多线程、分布式的复杂系统， printStackTrace() 方法输出的堆栈跟踪信息可能并不完整或准确。</li>
</ul>
<p>在生产环境中，应该使用日志系统来记录异常信息，例如 log4j、slf4j、logback 等。日志系统可以将异常信息记录到文件或数据库中，而不会暴露敏感信息，也不会影响程序的性能和稳定性。同时，日志系统也提供了更多的功能，如级别控制、滚动日志、邮件通知等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例如，可以使用 logback 记录异常信息，如下所示：</span><br><span class="line">try &#123;</span><br><span class="line">    // some code</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    logger.error(&quot;An error occurred: &quot;, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>12、对于不打算处理的异常，直接使用 try-finally，不用 catch </strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  method1();  // 会调用 Method 2</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">  cleanUp();    //do cleanup here</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 method1 正在访问 Method 2，而 Method 2 抛出一些你不想在 Method 1 中处理的异常，但是仍然希望在发生异常时进行一些清理，可以直接在 finally 块中进行清理，不要使用 catch 块。</p>
<p><strong>13、记住早 throw 晚 catch 原则 </strong></p>
<p>“早 throw, 晚 catch” 是 Java 中的一种异常处理原则。这个原则指的是在代码中尽可能早地抛出异常，以便在异常发生时能够及时地处理异常。同时，在 catch 块中尽可能晚地捕获异常，以便在捕获异常时能够获得更多的上下文信息，从而更好地处理异常。</p>
<p>来举个 “早 throw” 例子，如果一个方法需要传递参数，并且该参数必须满足一定的条件，如果参数不符合条件，则应该立即抛出异常，而不是在方法中进行其他操作。这可以确保异常在发生时能够及时被处理，避免更严重的问题。</p>
<p>再来举个“晚 catch”的例子，如果一个方法调用了其他方法，可能会抛出异常，如果在方法内部立即捕获异常，则可能会导致对异常的处理不充分。</p>
<p>来看这段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class ExceptionDemo1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        String str = sc.nextLine();</span><br><span class="line">        try &#123;</span><br><span class="line">            int num = parseInt(str);</span><br><span class="line">            System.out.println(&quot;转换结果：&quot; + num);</span><br><span class="line">        &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">            System.out.println(&quot;转换失败：&quot; + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static int parseInt(String str) &#123;</span><br><span class="line">        if (str == null || &quot;&quot;.equals(str)) &#123;</span><br><span class="line">            throw new NullPointerException(&quot;字符串为空&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (!str.matches(&quot;\\d+&quot;)) &#123;</span><br><span class="line">            throw new NumberFormatException(&quot;字符串不是数字&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return Integer.parseInt(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个示例中，定义了一个 parseInt() 方法，用于将字符串转换为整数。在该方法中，首先检测字符串是否为空，如果为空，则立即抛出 NullPointerException 异常。然后，检测字符串是否为数字，如果不是数字，则抛出 NumberFormatException 异常。最后，使用 Integer.parseInt() 方法将字符串转换为整数，并返回。</p>
<p>在示例的 main() 方法中，调用 parseInt() 方法，并使用 try-catch 块捕获可能抛出的 NumberFormatException 异常。如果转换成功，则输出转换结果，否则输出转换失败信息。</p>
<p>这个示例使用了 “早 throw, 晚 catch” 的原则，在 parseInt() 方法中尽可能早地抛出异常，在 main() 方法中尽可能晚地捕获异常，以便在捕获异常时能够获得更多的上下文信息，从而更好地处理异常。</p>
<p>运行该示例，输入一个数字字符串，可以看到输出转换结果。如果输入一个非数字字符串，则输出转换失败信息。</p>
<p><strong>14、只抛出和方法相关的异常 </strong></p>
<p>相关性对于保持代码的整洁非常重要。一种尝试读取文件的方法，如果抛出 NullPointerException，那么它不会给用户提供有价值的信息。相反，如果这种异常被包裹在自定义异常中，则会更好。</p>
<p>NoSuchFileFoundException 则对该方法的用户更有用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            int result = divide(10, 0);</span><br><span class="line">            System.out.println(&quot;The result is: &quot; + result);</span><br><span class="line">        &#125; catch (ArithmeticException e) &#123;</span><br><span class="line">            System.err.println(&quot;Error: &quot; + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static int divide(int a, int b) throws ArithmeticException &#123;</span><br><span class="line">        if (b == 0) &#123;</span><br><span class="line">            throw new ArithmeticException(&quot;Division by zero&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return a / b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在该示例中，只抛出了和方法相关的异常 ArithmeticException，这可以使代码更加清晰和易于维护。</p>
<p><strong>15、切勿在代码中使用异常来进行流程控制 </strong></p>
<p>在代码中使用异常来进行流程控制会导致代码的可读性、可维护性和性能出现问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String input = &quot;1,2,3,a,5&quot;;</span><br><span class="line">        String[] values = input.split(&quot;,&quot;);</span><br><span class="line">        for (String value : values) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                int num = Integer.parseInt(value);</span><br><span class="line">                System.out.println(num);</span><br><span class="line">            &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">                System.err.println(value + &quot; is not a valid number&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然这个示例可以正确地处理输入字符串中的非数字字符，但是它使用异常进行流程控制，这就导致代码变得混乱、难以理解。应该使用其他合适的控制结构（如 if、switch、循环等）来管理程序的流程。</p>
<p><strong>16、尽早验证用户输入以在请求处理的早期捕获异常 </strong></p>
<p>例如：在用户注册的业务中，如果按照这样来做：</p>
<ol>
<li>验证用户</li>
<li>插入用户</li>
<li>验证地址</li>
<li>插入地址</li>
<li>如果出问题回滚一切</li>
</ol>
<p>这是不正确的做法，它会使数据库在各种情况下处于不一致的状态，应该首先验证所有内容，然后再进行数据库更新。正确的做法是：</p>
<ol>
<li>验证用户</li>
<li>验证地址</li>
<li>插入用户</li>
<li>插入地址</li>
<li>如果问题回滚一切</li>
</ol>
<p>举个例子，我们用 JDBC 的方式往数据库插入数据，那么最好是先 validate 再 insert，而不是 validateUserInput、insertUserData、</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Connection conn = null;</span><br><span class="line">try &#123;</span><br><span class="line">    // Connect to the database</span><br><span class="line">    conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/mydatabase&quot;, &quot;username&quot;, &quot;password&quot;);</span><br><span class="line">    // Start a transaction</span><br><span class="line">    conn.setAutoCommit(false);</span><br><span class="line">    // Validate user input</span><br><span class="line">    validateUserInput();</span><br><span class="line">    // Insert user data</span><br><span class="line">    insertUserData(conn);</span><br><span class="line">    // Validate address input</span><br><span class="line">    validateAddressInput();</span><br><span class="line">    // Insert address data</span><br><span class="line">    insertAddressData(conn);</span><br><span class="line">    // Commit the transaction if everything is successful</span><br><span class="line">    conn.commit();</span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">    // Rollback the transaction if there is an error</span><br><span class="line">    if (conn != null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            conn.rollback();</span><br><span class="line">        &#125; catch (SQLException ex) &#123;</span><br><span class="line">            System.err.println(&quot;Error: &quot; + ex.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.err.println(&quot;Error: &quot; + e.getMessage());</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    // Close the database connection</span><br><span class="line">    if (conn != null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            conn.close();</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            System.err.println(&quot;Error: &quot; + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>17、一个异常只能包含在一个日志中 </strong></p>
<p>不要这样做：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">log.debug(&quot;Using cache sector A&quot;);</span><br><span class="line">log.debug(&quot;Using retry sector B&quot;);</span><br></pre></td></tr></table></figure>
<p>在单线程环境中，这样看起来没什么问题，但如果在多线程环境中，这两行紧挨着的代码中间可能会输出很多其他的内容，导致问题查起来会很难受。应该这样做：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOGGER.debug(&quot;Using cache sector A, using retry sector B&quot;);</span><br></pre></td></tr></table></figure>
<p><strong>18、将所有相关信息尽可能地传递给异常 </strong></p>
<p>有用的异常消息和堆栈跟踪非常重要，如果你的日志不能定位异常位置，那要日志有什么用呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Log exception message and stack trace</span><br><span class="line">LOGGER.debug(&quot;Error reading file&quot;, e);</span><br></pre></td></tr></table></figure>
<p>应该尽量把 String message, Throwable cause 异常信息和堆栈都输出。</p>
<p><strong>19、终止掉被中断线程 </strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">while (true) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    Thread.sleep(100000);</span><br><span class="line">  &#125; catch (InterruptedException e) &#123;&#125; //别这样做</span><br><span class="line">  doSomethingCool();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>InterruptedException 提示应该停止程序正在做的事情，比如事务超时或线程池被关闭等。</p>
<p>应该尽最大努力完成正在做的事情，并完成当前执行的线程，而不是忽略 InterruptedException。修改后的程序如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">while (true) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    Thread.sleep(100000);</span><br><span class="line">  &#125; catch (InterruptedException e) &#123;</span><br><span class="line">    break;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">doSomethingCool();</span><br></pre></td></tr></table></figure>
<p><strong>20、对于重复的 try-catch，使用模板方法 </strong></p>
<p>类似的 catch 块是无用的，只会增加代码的重复性，针对这样的问题可以使用模板方法。</p>
<p>例如，在尝试关闭数据库连接时的异常处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class DBUtil&#123;</span><br><span class="line">    public static void closeConnection(Connection conn)&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            conn.close();</span><br><span class="line">        &#125; catch(Exception ex)&#123;</span><br><span class="line">            //Log Exception - Cannot close connection</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这类的方法将在应用程序很多地方使用。不要把这块代码放的到处都是，而是定义上面的方法，然后像下面这样使用它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void dataAccessCode() &#123;</span><br><span class="line">    Connection conn = null;</span><br><span class="line">    try&#123;</span><br><span class="line">        conn = getConnection();</span><br><span class="line">        ....</span><br><span class="line">    &#125; finally&#123;</span><br><span class="line">        DBUtil.closeConnection(conn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“好了，三妹，关于异常处理实践就先讲这 20 条吧，实际开发中你还会碰到其他的一些坑，自己踩一踩可能印象更深刻一些。”我说。</p>
<p>“那万一到时候我工作后被领导骂了怎么办？”三妹委屈地说。</p>
<p>“新人嘛，总要写几个 bug 才能对得起新人这个称号嘛。”我轻描淡写地说。</p>
<p>“好吧。”三妹无奈地叹了口气。</p>
<h2 id="6-4-空指针的传说"><a href="#6-4-空指针的传说" class="headerlink" title="6.4 空指针的传说"></a>6.4 空指针的传说</h2><p>空指针，号称天下最强刺客。</p>
<p>他原本不叫这个名字，空指针原本复姓异常，空指针只不过是他的武器，但他杀戮过多，渐渐地人们只记住了空指针这三个字。</p>
<p>天下武功，唯快不破，空指针的针，以快和诡异著称，稍有不慎，便是伤亡。</p>
<p>… …</p>
<p>我叫王二，我来到这个奇怪的世界已经一年了，我等了一年，穿越附赠的老爷爷、戒指、系统什么的我到现在都没发现。</p>
<p>而且这个世界看起来也太奇怪了，这里好像叫什么 Java 大陆，我只知道这个世界的最强者叫做 Object，听说是什么道祖级的存在，我也不知道是什么意思，毕竟我现在好像还是个菜鸡，别的主角一年都应该要飞升仙界了吧，我还连个小火球都放不出来。</p>
<p>哦，对了，上面的那段话是我在茶馆喝茶的时候听说书的先生说的，总觉得空指针这个名字怪怪的，好像在什么地方听说过。</p>
<p>我的头痛的毛病又犯了，我已经记不起来我为什么来到这里了，我只记得我的名字叫王二，其他的，我只感觉这个奇怪的世界有一种熟悉，但是我什么都记不起来了。</p>
<p>算了，得过且过吧。</p>
<p>我准备去找空指针了，虽然听说他很可怕，但是好像听说他不是嗜杀之人，应该不会滥杀无辜吧，目前为止，我也只对这三个字有熟悉的感觉了，我一定要找到他，找回我的记忆！</p>
<p>我打听了很久，原来空指针是异常组织的三代嫡传，异常组织是这个世界上最恐怖的杀手组织，空指针就是异常现在最出色的刺客。</p>
<p>听说空指针出生的时候，脖子上就挂着一根针，整个 Java 大陆雪下一月不停，Linux 森林多块陆地直接沉陷，于是他的父亲 RuntimeException 就给他起了空指针这个名字。</p>
<p>空指针出生的天生异象也引起了异常组织高层的注意，听说他的祖父 Exception，还有整个异常组织的领军人物 Throwable 都亲自接见了空指针，并且认为空指针天赋异禀，未来可期。</p>
<p>要知道，Throwable 可是 Object 亲自任命的异常组织头领。作为 Object 最值得信任的亲信，跟随 Object 万年以来，所有的脏活累活都依靠 Thrwoable 创立的异常组织来处理，真可谓一人之下，万人之上。</p>
<p>Throwable 只有两个亲子，就是 Error 和 Exception，传说中 Error 心狠手辣，手下无一活口，见过 Error 的人还能活下来的寥寥无几。</p>
<p>整个大陆只有他们恐怖的传说，谁也不知道他们什么时候出现，但是一旦他们出现，基本宣告着你已经是个死人了。</p>
<p>而我听说过最恐怖的就是 OutOfMemoryError  和  StackOverflowError  这两位刺客，因为大陆上永远有一座风云榜悬挂在帝都门口，而这两位，一直位居杀手榜榜首位置，空指针也只只能屈居第三而已。当然，大陆不少人都认为空指针会后来居上。</p>
<p>我的消息只是打听到这么多，接下来的日子，我走过无数的城市、荒野，我穿过沙漠、丛林，这一天，终于，我来到了大陆的帝都—堆。</p>
<p>这个名字听起来也有点耳熟，不管他，先进城再说。</p>
<p>进城后我发现这里非常诡异，整座城市好像都非常年轻，好像连一个成年人都没有！街道上熙熙攘攘竟然都是年轻人。</p>
<p>带着疑惑，我走进了一家叫做同福客栈的酒楼。</p>
<p>”客官，打尖还是住店啊？“一个小二模样的小孩带着一丝谄媚的对我说。</p>
<p>”住店，带我去最好的房间，这些钱先押你这里，不够再跟我要。“一路走来，对于这些地方的行情我也算轻车熟路了。</p>
<p>”小朋友，这里是怎么回事？你们这里没有大人吗？“我一边走一边问这个只有我一半身高的小孩，根据我目测，他身高不超过1米，应该还只有七八岁的样子，难道这里的商人如此黑心，竟然雇佣童工，不过这也不貌似不对，因为周围的客人好像也都是这般年纪，他们竟然还有在抽烟喝酒的！</p>
<p>”客官可真幽默，不过我看客官应该是刚来帝都，不瞒您说，整个帝都就基本没有超过15岁的人，超过15的据说都在叫做老年区的养老去了！就拿我来说吧，我今年可不小了，我都8岁了，像我这般年纪的已经半截腿迈进棺材咯。哎，这身子也是一年不如一年了。“</p>
<p>看着这个小二一脸认真的样子，我越发觉得这座城市诡异起来了！8岁，什么鬼？8岁不是应该在家里看喜羊羊吗？！还半截腿迈进棺材！</p>
<p>”可是你看我比你高这么多，你不觉得奇怪吗？“我奇怪的问他。</p>
<p>”有什么好奇怪的，要不是我小时候喝多了三鹿，没准我也长这么高了！“小二有点生气的对我说。</p>
<p>行吧，再说两句把他激怒了，跳起来打我膝盖就大事不妙了。</p>
<p>接下来的几天，经过我的打探，原来我在的地方是叫做年轻区，整个帝都就只有这两个区域，年轻区的人年龄确实没有超过15岁的，有些人刚出生没几天就死了，对此，生活在这里的人也见怪不怪了。对于他们来说，寄希望能活到超过15岁进入老年区养老就是他们的梦想。</p>
<p>我在怀疑是不是异常组织在这里暗杀，可是发现结果并不是，这里的人貌似已经习惯了，生活对他们来说就是随便活活就好了，每次的死亡对于他们来说毫无征兆，可能刚踢着球呢，就突然挂了，有的上着厕所突然就死了，临死前连个屁股都没擦，不说了，有点恶心。</p>
<p>就在我等的不耐烦想打算去老年区看看的时候，一个穿着黑衣的人找到了我。</p>
<p>”你是谁？“我警惕的问他。</p>
<p>”本座IOException。“黑衣人神情冰冷的看着我说。</p>
<p>”你找我什么事？“</p>
<p>”这些你不用知道，跟我走一趟吧！“</p>
<p>我刚想说话拒绝，开什么玩笑，跟你们异常组打交道的人非死即残，谁要跟你去。</p>
<p>但是由不得我拒绝，我只感觉一阵天旋地转，我感觉我在天上飞，然后我就失去了意识。当我醒来的时候，我发现我躺在一张巨大的床上，桌子上点着一支檀香，整个房间只有一张桌子、一把椅子和我躺的地方。</p>
<p>房间很小，应该只有10几个平方，但是我竟然又有一种熟悉的感觉，这种感觉萦绕在我心头挥散不去。</p>
<p>没等我再想更多，房门打开了。</p>
<p>”是你，你把我带来干什么？“</p>
<p>”走吧，有人要见你。“</p>
<p>还是不容我抗拒，如果我的战斗力是5的话，我想，IO他该有好几万了吧。</p>
<p>又是这该死的眩晕感，不过这次没有几秒钟，我就发现我在一个花园里，花园中间一个身穿黄袍的中年人正在慢悠悠的喝茶。在他身上我感受不到任何强大的气息，甚至不如IOException给我的压迫感强烈。这是谁？</p>
<p>不等我思绪飘飞，IOException弯腰躬身说道：”陛下，人带过来了。“</p>
<p>”嗯，你退下吧。“中年人转过身来，脸上丝毫看不出情绪的说道。</p>
<p>我大概猜到了这是哪里了，于是也放下心来，在这里，或许能找到我的答案。</p>
<p>反正他要对我怎么样，我也没有办法反抗，我径直坐到他的对面，看着他说：”您就是Object陛下吧，不知找我所谓何事？“</p>
<p>中年人也不在意，没有正面回答我的问题，反而略带一丝调侃的说道：”不用咬文嚼字，说点正常人的话吧。</p>
<p>… …</p>
<p>这不按套路出牌啊，我这不是来久了，模仿你们古代人说话嘛，怎么还埋怨起我来了？！</p>
<p>”那我就直说了，我想知道空指针在哪里。“</p>
<p>”空指针就在皇宫轮值，你找他干嘛？“</p>
<p>”我暂时不能说“</p>
<p>”呵呵，你就不好奇我为什么知道你，为什么又把你带过来？“</p>
<p>”好奇，可是我就是不想问。“</p>
<p>Object喝了口茶，不紧不慢的回道：”年轻人有性格是好事，可是过刚易折的道理你应该明白。“</p>
<p>”我不明白，我在这里反正也没看见什么老人，当然，除了你。“我理所当然的认为这肯定是Object搞得鬼，整个帝都都是小朋友，要是没有猫腻，骗鬼呢！</p>
<p>Object听到这话，皱了皱眉，他沉默了一会儿，缓缓站起身子走到一颗柳树下，背着手说道：“你不知道这一切是为什么吗？”</p>
<p>废话，我当然不知道了，我知道还能问你吗？！</p>
<p>又是沉默… …这个气氛让我感觉很不舒服。就在我受不了想说话的时候，Object突然说了一句：“带他去见空指针吧。”</p>
<p>“是，陛下！”突然，一个身穿红袍的枯瘦老者出现在我背后，把我吓了一跳。</p>
<p>我也不想再多生事端，直觉告诉我这里不是久留之地，虽然有点莫名其妙，我还是跟着红袍老者来走了。</p>
<p>… …</p>
<p>“陛下，是他吗？”一个光头大汉的身影在半空若影若现的说道。</p>
<p>“还不能确定… 不过，留给我们的时间不多了，下一次的轮回就快来了。”</p>
<p>“轮回，又是轮回。我们还有希望吗？”大汉呢喃着，不知道是对自己说还是对中年人说。</p>
<p>中年人依然背着手，抬头望着漫天的柳絮说道：“这一世，该是个了断了。”</p>
<p>… …</p>
<p>没多久，他把我带到一个房间门口，也是面无表情的说道：“进去吧，空指针就在里面。”</p>
<p>我挺住脚步，转过身问他：“你是谁？我们是不是见过？”</p>
<p>红袍老者怪异一笑：“也许吧，老夫 IndexOutOfBoundsException ，空指针便是我好友。”</p>
<p>这个名字可真长，我听说过他，据传闻他的实力也非常之强，可能不下于空指针，都是以诡异的出手角度著称，不过相比于空指针的大名，他好像更低调，难怪在皇宫当个老太监一般。</p>
<p>我也不在多想，点点头，走进了房间。刚进房间，我就看见一个一身白衣的身影背对着我，笔直的身影好像要冲破天际，身上的气势强大无比，至少在我见过的所有人里足以排进前三了。空指针，果然名不虚传！</p>
<p>我走到房间中央，环目四望才发现这好像是一座祠堂的样子，就在我还在打量四周之际，一道清冷的声音传到我的耳边：</p>
<p>“你身上的气息让我非常讨厌！”</p>
<p>他转过身来，我发现我根本看不清空指针长什么样子，他的脸好像打上了马赛克。听到他的话，我心里的疑惑更多了，我只是觉得他的气息让我感到非常熟悉，他的话让我有点莫名其妙。于是我试探道：</p>
<p>“你知道我是谁？”</p>
<p>听到我的话，他一步步走进我，在我身边闻了闻，这让我什么一紧，虽然我想搞清楚我身上的问题，但是我不是出卖肉体的人，我退后一步说：</p>
<p>“你想干嘛？”</p>
<p>空指针皱紧了眉头，仿佛自言自语道：“不对，不对，这是… 规则的气息？可是他明明身上没有任何能量波动。”</p>
<p>我见他好像魔怔了，仿佛在思考什么，于是迈步走到他刚才站立的地方看着前面，原来，这是他们的族谱！</p>
<p>这里是异常的祠堂！</p>
<p><img src="\assets\note\image-20231011144045101.png" alt="image-20231011144045101"></p>
<p>看完这张族谱，我恍然大悟，好像明白了什么。突然，我的脑袋里出现了一个冰冷的机器声音：“获取异常族谱，历练完成度+100。”</p>
<p>我Kao，系统，这是系统啊，我不禁内牛满面，啥任务系统啊，一点提示都没有，我赶紧喊道：</p>
<p>“系统，系统，还在吗？在线等，挺着急的。”可是没有任何回复！这啥破系统！就在我想破口大骂的时候，空指针看到我和个二傻子似的大呼小叫，突然一脸不可思议的对着我说：</p>
<p>“你明悟了规则？”</p>
<p>我愣了愣，嗯？难道我不是战5渣了？规则之力？好像是很高端的样子啊？</p>
<p>“撒豆成兵！”</p>
<p>“呼风！”</p>
<p>”唤雨！“<br>”临兵斗者皆阵列在前！“</p>
<p>一点反应都没有。。。啥玩意儿？还规则之力？九字真言都没用啊？</p>
<p>空指针好像都蒙了，他敲了敲太阳穴，无语的看着我说：</p>
<p>”你不是来找我的吗？说完你的问题，然后给我滚！“</p>
<p>对啊，这系统把我整的我都忘记我来干嘛的了，我赶紧说：</p>
<p>”你认识我对不对，你是不是觉得我有一种熟悉的感觉？我想知道我的来历！“</p>
<p>空指针又愣了愣，他看着我，沉默了一会儿，回道：“不知道！”</p>
<p>我有点奇怪，看他一脸便秘的表情应该是见过我的，他一定在撒谎，既然如此…</p>
<p>“那你告诉我你们有什么办法能在你们异常的攻击下防身吧？”</p>
<p>空指针大怒，刚想起身说话，空中突然传来一道声音：答应他的要求！</p>
<p>他冷哼一声，丢给我一本书，上面写着catch一个字，还有一块写着catch的令牌，冰冷的说到：“你想知道的都在这里了。”说完，拂袖而去。</p>
<p>我看着桌子上的这本书，想了想还是翻阅起来。</p>
<p>原来 Exception  和它的儿子们，除了 RuntimeException  一支，都叫作 Checked Exception ，我还能用catch令牌来对抗他们的攻击！包括空指针，以后我就不怕他们了！</p>
<p>可是，他为什么要给我，看他刚才的样子都想打我了，又突然给了我这些？还有他一直在说的规则之力又是什么？这座城市为什么又这么诡异？</p>
<h2 id="6-5-try-catch会影响性能吗？"><a href="#6-5-try-catch会影响性能吗？" class="headerlink" title="6.5 try-catch会影响性能吗？"></a>6.5 try-catch会影响性能吗？</h2><p>“二哥，你看着这鬼代码，竟然在 for 循环里面搞了个 try-catch ，不知道 try-catch有性能损耗吗？” 老王煞有其事地指着屏幕里的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; 5000; i++) &#123;</span><br><span class="line">     try &#123;</span><br><span class="line">         dosth</span><br><span class="line">     &#125; catch (Exception e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>我探过头去看了眼代码，“那 老王你觉得该怎么改？”</p>
<p>“当然是把 try-catch 提到外面啊！” 老王脑子都不转一下，脱口而出。</p>
<p>“你是不是傻？且不说性能，这代码的目的明显是让循环内部单次调用出错不影响循环的运行，你移到外面，业务逻辑不就变了吗！”<br>老王挠了挠他的地中海，“好像也是啊！”</p>
<p>“回过头来，catch 整个 for 循环和在循环内部 catch，在不出错的情况下，其实性能差不多。” 我喝一口咖啡不经意地提到，准备在 老王前面秀一下。</p>
<p>“啥意思？” 老王有点懵地看着我，“ try-catch是有性能损耗的，我可是看过网上资料的！”</p>
<p>果然， 老王上钩了，我二话不说直接打开 idea，一顿操作敲了以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class TryCatchTest &#123;</span><br><span class="line">    // 用 @Benchmark 注解标记一个方法作为基准测试方法</span><br><span class="line">    @Benchmark</span><br><span class="line">    public void tryfor(Blackhole blackhole) &#123;</span><br><span class="line">        // 使用 try-catch 语句包装一个 for 循环</span><br><span class="line">        try &#123;</span><br><span class="line">            for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">                // 在循环中调用 Blackhole.consume() 方法</span><br><span class="line">                blackhole.consume(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            // 捕获异常并打印堆栈跟踪信息</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 用 @Benchmark 注解标记另一个方法作为基准测试方法</span><br><span class="line">    @Benchmark</span><br><span class="line">    public void fortry(Blackhole blackhole) &#123;</span><br><span class="line">        // 使用 for 循环包装一个 try-catch 语句</span><br><span class="line">        for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                // 在 try 块中调用 Blackhole.consume() 方法</span><br><span class="line">                blackhole.consume(i);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                // 捕获异常并打印堆栈跟踪信息</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，请允许我补充一些概念，以便大家能更好的理解这段代码。</p>
<blockquote>
<p>第一个： @Benchmark 是一个来自于 JMH（Java Microbenchmark Harness）库的注解，用来标记一个方法作为基准测试方法。JMH 是一个专门用于编写 Java 微基准测试的工具包，包含了一些用于测试 Java 代码性能和微调 JVM 的工具和库。使用 @Benchmark 注解标记的方法将被 JMH 自动识别为基准测试方法，并在运行时进行基准测试。在基准测试期间，JMH 会运行被标记的方法多次，并测量方法的执行时间、吞吐量、延迟等指标，并生成统计结果。</p>
<p>第二个：在 JMH 进行基准测试时，为了避免 JIT 编译器优化掉测试代码中的某些操作，我们需要在测试代码中使用一些占位符，以便让编译器认为这些操作是有意义的，不应该被优化掉。Blackhole.consume() 方法就是这样的一个占位符。它用来占用一些 CPU 时间和内存空间，以确保测试结果的准确性和可靠性。</p>
</blockquote>
<p>“BB 不如 show code，看到没， 老王，我把 try-catch 从 for 循环里面提出来跟在for循环里面做个对比跑一下，你猜猜两个差多少？”</p>
<p>“切，肯定 tryfor 性能好，想都不用想，不是的话我倒立洗头！” 老王信誓旦旦道。</p>
<p>我懒得跟他BB，直接开始了 benchmark，跑的结果如下：<br>     <img src="\assets\note\image-20231011144451106.png" alt="image-20231011144451106"></p>
<p>可以看到，两者的性能（数字越大越好）其实差不多：551063.024 VS 551525.861。</p>
<p>在这里，简单普及一下 JMH 的使用指南。</p>
<blockquote>
<p>第一步，在 pom.xml 文件中加入依赖。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 引入 JMH 工具包 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.openjdk.jmh&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jmh-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.35&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.openjdk.jmh&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jmh-generator-annprocess&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.35&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第二步，Intellij IDEA 中安装 JMH 插件。</p>
</blockquote>
<p><img src="\assets\note\image-20231011144544374.png" alt="image-20231011144544374"></p>
<blockquote>
<p>第三步，在代码编辑器中点击这个带有时间和运行的图标。然后静静等待结果就可以了，我本机（32G 内存 Intel i7 跑了 16 分钟，贼慢，因为 JMH 比较喜欢追求公平公正 ）</p>
</blockquote>
<p><img src="\assets\note\image-20231011144619049.png" alt="image-20231011144619049"></p>
<p>老王一看傻了：“说好的性能影响呢？怎么没了？”</p>
<p>我直接一个javap，让 老王看看，其实两个实现在字节码层面没啥区别：</p>
<blockquote>
<p>tryfor 的字节码</p>
</blockquote>
<p>异常表记录的是 0 - 20 行，如果这些行里面的代码出现问题，直接跳到 23 行处理。</p>
<p><img src="\assets\note\image-20231011144653816.png" alt="image-20231011144653816"></p>
<blockquote>
<p>fortry 的字节码</p>
</blockquote>
<p>差别也就是异常表的范围小点，包的是 9-14 行，其它跟 tryfor 都差不多。</p>
<p><img src="\assets\note\image-20231011144720356.png" alt="image-20231011144720356"></p>
<p>所以从字节码层面来看，没抛错两者的执行效率其实没啥差别。</p>
<p>“那为什么网上流传着 try-catch会有性能问题的说法啊？” 老王觉得非常奇怪。</p>
<p>这个说法确实有，在《Effective Java》这本书里就提到了 try-catch 性能问题：</p>
<p><img src="\assets\note\image-20231011144813673.png" alt="image-20231011144813673"></p>
<p>正所谓听话不能听一半，以前读书时候最怕的就是一知半解，因为完全理解选择题能选对，完全不懂蒙可能蒙对，一知半解必定选到错误的选项！</p>
<p>《Effective Java》书中说的其实是不要用 try-catch 来代替正常的代码，书中的举例了正常的 for 循环肯定这样实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for ( Mountain m : range )</span><br><span class="line">    m.climb();</span><br></pre></td></tr></table></figure>
<p>但有个卧龙偏偏不这样实现，要通过   try-catch 拐着弯来实现循环：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* Horrible abuse of exceptions. Don&#x27;t ever do this! */</span><br><span class="line">try &#123;</span><br><span class="line">    int i = 0;</span><br><span class="line">    while ( true )</span><br><span class="line">        range[i++].climb();</span><br><span class="line">&#125; catch ( ArrayIndexOutOfBoundsException e ) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这操作我只能说有点逆天，这两个实现的对比就有性能损耗了。</p>
<p>我们直接再跑下有 try-catch 的代码和没 try-catch的 for 循环区别，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class TryCatchTest1 &#123;</span><br><span class="line">    @Benchmark</span><br><span class="line">    public void fornotry(Blackhole blackhole) &#123;</span><br><span class="line">        for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">            blackhole.consume(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Benchmark</span><br><span class="line">    public void tryfor(Blackhole blackhole) &#123;</span><br><span class="line">        for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                blackhole.consume(i);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="\assets\note\image-20231011144930607.png" alt="image-20231011144930607"></p>
<p>+-差不多，直接看前面的分数对比，没有 ry-catch 的性能确实好些，这也和书中说的 try-catch 会影响 JVM 一些特定的优化说法吻合，但是具体没有说影响哪些优化，我猜测可能是指令重排之类的。</p>
<p>好了，我再总结下有关 try-catch 性能问题说法：</p>
<ol>
<li>try-catch 相比较没 try-catch ，确实有一定的性能影响，但是旨在不推荐我们用 try-catch 来代替正常能不用 try-catch 的实现，而不是不让用 try-catch 。</li>
<li>for循环内用   try-catch 和用 try-catch 包裹整个 for 循环性能差不多，但是其实两者本质上是业务处理方式的不同，跟性能扯不上关系，关键看你的业务流程处理。</li>
<li>虽然知道 try-catch会有性能影响，但是业务上不需要避讳其使用，业务实现优先（只要不是书中举例的那种逆天代码就行），非特殊情况下性能都是其次，有意识地避免大范围的 try-catch ，只 catch 需要的部分即可（没把握全 catch 也行，代码安全执行第一）。</li>
</ol>
<p>“好了， 老王你懂了没？”</p>
<p>“行啊二哥，BB是一套一套的，走请你喝燕麦拿铁！”  老王一把拉起我，我直接一个挣脱，“少来，我刚喝过咖啡，你那个倒立洗头，赶紧的！”我立马意识到 老王想岔开话题。</p>
<p>“洗洗洗，我们先喝个咖啡，晚上回去给你洗！”</p>
<h1 id="7-常用工具类"><a href="#7-常用工具类" class="headerlink" title="7 常用工具类"></a>7 常用工具类</h1><h2 id="7-1-Scanner工具类"><a href="#7-1-Scanner工具类" class="headerlink" title="7.1 Scanner工具类"></a>7.1 Scanner工具类</h2><p>Java 的 Scanner 类是一个方便在控制台扫描用户输入的工具类，虽然它也可以扫描文件内容，但我们通常更喜欢它扮演前面的角色，因为扫描文件可以通过文件流来完成。</p>
<p>接下来，我们通过几个简单的示例讲一下 Scanner 类。</p>
<p><strong>01、扫描控制台输入 </strong></p>
<p>通常，我们会使用 Scanner 类来扫描控制台输入，尤其是对于初学 Java 的人来说，这样会非常的酷，因为终于可以拿到我们自己想要输入的数据了。</p>
<p>来看下面的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Scanner scanner = new Scanner(System.in); // 创建 Scanner 对象，从标准输入流中读取数据</span><br><span class="line">System.out.print(&quot;请输入一个整数：&quot;);</span><br><span class="line">int num = scanner.nextInt(); // 获取用户输入的整数</span><br><span class="line">System.out.println(&quot;您输入的整数是：&quot; + num);</span><br><span class="line">scanner.nextLine(); // 读取换行符，避免影响下一次读取</span><br><span class="line">System.out.print(&quot;请输入一个字符串：&quot;);</span><br><span class="line">String str = scanner.nextLine(); // 获取用户输入的字符串</span><br><span class="line">System.out.println(&quot;您输入的字符串是：&quot; + str);</span><br><span class="line">scanner.close(); // 关闭 Scanner 对象</span><br></pre></td></tr></table></figure>
<p>运行后就可以在控制台交互了，对于新手来说，估计会觉得比较有趣。</p>
<p><img src="\assets\note\image-20231011145657922.png" alt="image-20231011145657922"></p>
<p>其中 System.in 返回的是一个字节输入流 InputStream，和 System.out 刚好对应。</p>
<p><img src="\assets\note\image-20231011145722053.png" alt="image-20231011145722053"></p>
<p><strong>1）nextLine </strong></p>
<p>nextLine() 方法会扫描输入流中的字符，直到遇到行末尾的换行符 \n ，然后将该行的内容作为字符串返回，同时， nextLine() 会将 Scanner 对象的位置移动到下一行的开头，以便下一次读取数据时从下一行的开头开始读取。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Scanner scanner = new Scanner(System.in); // 创建 Scanner 对象，从标准输入流中读取数据</span><br><span class="line">System.out.println(&quot;请输入多行文本，以空行结束：&quot;);</span><br><span class="line">StringBuilder sb = new StringBuilder(); // 创建 StringBuilder 对象，用于保存读取的文本</span><br><span class="line">String line = scanner.nextLine(); // 读取输入流中的第一行</span><br><span class="line">while (!line.isEmpty()) &#123; // 如果读取的行不为空，则继续读取下一行</span><br><span class="line">    sb.append(line).append(&quot;\n&quot;); // 将当前行的内容添加到 StringBuilder 对象中，并换行</span><br><span class="line">    line = scanner.nextLine(); // 读取下一行</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;您输入的文本是：\n&quot; + sb.toString()); // 打印读取的文本</span><br><span class="line">scanner.close(); // 关闭 Scanner 对象</span><br></pre></td></tr></table></figure>
<p><strong>2）nextInt </strong></p>
<p>nextInt() 用于从输入流中读取下一个整数并返回，如果输入流中没有整数，或者不是整数，将抛出 InputMismatchException 异常。</p>
<p><img src="\assets\note\image-20231011145927831.png" alt="image-20231011145927831"></p>
<p><strong>3）其他方法 </strong></p>
<p>除了以上两个常用的方法，Scanner 类中还有一些其他的方法：</p>
<ul>
<li>boolean hasNext() ：检查输入流是否还有下一个标记。</li>
<li>boolean hasNextLine() ：检查输入流是否还有下一行。</li>
<li>String next() ：读取输入流中的下一个标记（使用默认的分隔符，通常是空格或换行符）。</li>
<li>double nextDouble() ：读取输入流中的下一个双精度浮点数。</li>
</ul>
<p>来个 demo 吧。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Scanner scanner = new Scanner(System.in); // 创建 Scanner 对象，从标准输入流中读取数据</span><br><span class="line">System.out.print(&quot;请输入一个整数：&quot;);</span><br><span class="line">if (scanner.hasNextInt()) &#123; // 判断输入流中是否有下一个整数</span><br><span class="line">    int num = scanner.nextInt(); // 读取输入流中的下一个整数</span><br><span class="line">    System.out.println(&quot;您输入的整数是：&quot; + num);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    System.out.println(&quot;输入的不是整数！&quot;);</span><br><span class="line">&#125;</span><br><span class="line">scanner.nextLine(); // 读取输入流中的换行符</span><br><span class="line">System.out.print(&quot;请输入多个单词，以空格分隔：&quot;);</span><br><span class="line">while (scanner.hasNext()) &#123; // 判断输入流中是否还有下一个标记</span><br><span class="line">    String word = scanner.next(); // 读取输入流中的下一个单词</span><br><span class="line">    System.out.println(&quot;您输入的单词是：&quot; + word);</span><br><span class="line">&#125;</span><br><span class="line">scanner.nextLine(); // 读取输入流中的换行符</span><br><span class="line">System.out.print(&quot;请输入一个实数：&quot;);</span><br><span class="line">if (scanner.hasNextDouble()) &#123; // 判断输入流中是否有下一个实数</span><br><span class="line">    double num = scanner.nextDouble(); // 读取输入流中的下一个实数</span><br><span class="line">    System.out.println(&quot;您输入的实数是：&quot; + num);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    System.out.println(&quot;输入的不是实数！&quot;);</span><br><span class="line">&#125;</span><br><span class="line">scanner.nextLine(); // 读取输入流中的换行符</span><br><span class="line">System.out.print(&quot;请输入一个字符串：&quot;);</span><br><span class="line">if (scanner.hasNextLine()) &#123; // 判断输入流中是否有下一行</span><br><span class="line">    String line = scanner.nextLine(); // 读取输入流中的下一行</span><br><span class="line">    System.out.println(&quot;您输入的字符串是：&quot; + line);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    System.out.println(&quot;输入的不是字符串！&quot;);</span><br><span class="line">&#125;</span><br><span class="line">scanner.close(); // 关闭 Scanner 对象</span><br></pre></td></tr></table></figure>
<p><strong>02、扫描文件 </strong></p>
<p>当然了，Scanner 也是可以用来扫描文件的，方式也非常的简单，以下是代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    // 创建 File 对象，表示要扫描的文件</span><br><span class="line">    File file = new File(&quot;docs/安装环境.md&quot;);</span><br><span class="line">    Scanner scanner = new Scanner(file); // 创建 Scanner 对象，从文件中读取数据</span><br><span class="line">    while (scanner.hasNextLine()) &#123; // 判断文件中是否有下一行</span><br><span class="line">        String line = scanner.nextLine(); // 读取文件中的下一行</span><br><span class="line">        System.out.println(line); // 打印读取的行</span><br><span class="line">    &#125;</span><br><span class="line">    scanner.close(); // 关闭 Scanner 对象</span><br><span class="line">&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">    System.out.println(&quot;文件不存在！&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们首先创建了一个 File 对象，表示要扫描的文件。然后，我们使用 Scanner 类的构造方法来创建 Scanner 对象，将文件作为参数传递给构造方法。在 while 循环中，我们使用 hasNextLine() 方法来判断文件中是否有下一行，如果有，则使用 nextLine() 方法读取该行字符串，并使用 println() 方法将其打印出来。最后，我们在程序结束前使用 close() 方法关闭 Scanner 对象。</p>
<p>除了使用循环+nextLine，我们还可以使用 useDelimiter 方法设置文件结束符 \Z 来读取整个文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 创建 File 对象，表示要扫描的文件</span><br><span class="line">Scanner scanner = new Scanner(new File(&quot;docs/安装环境.md&quot;)); // 创建 Scanner 对象，从文</span><br><span class="line">件中读取数据</span><br><span class="line">scanner.useDelimiter(&quot;\\Z&quot;); // 设置分隔符为文件结尾</span><br><span class="line">if (scanner.hasNext()) &#123; // 判断文件中是否有下一行</span><br><span class="line">    String content = scanner.next(); // 读取文件中的下一行</span><br><span class="line">    System.out.println(content); // 打印读取的行</span><br><span class="line">&#125;</span><br><span class="line">scanner.close(); // 关闭 Scanner 对象</span><br></pre></td></tr></table></figure>
<p>正则表达式中的 \Z 表示输入的结尾，也就是文件结束符。在 Scanner 类中，我们可以使用 \Z 作为分隔符，以便读取整个文件内容。</p>
<p><strong>03、查找匹配项 </strong></p>
<p>除了上面提到的扫描控制台输入流、文件，Scanner 还提供了另外四个以 find 开头的查找匹配项的方法：</p>
<p><img src="\assets\note\image-20231012142345475.png" alt="image-20231012142345475"></p>
<p>来看示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String input = &quot;good good study, day day up.&quot;;</span><br><span class="line">Scanner scanner = new Scanner(input);</span><br><span class="line">String result;</span><br><span class="line">// 使用 findInLine() 方法查找字符串中的单词</span><br><span class="line">result = scanner.findInLine(&quot;study&quot;);</span><br><span class="line">System.out.println(&quot;findInLine(): &quot; + result); // 输出 &quot;study&quot;</span><br><span class="line">// 使用 findWithinHorizon() 方法查找字符串中的单词</span><br><span class="line">scanner = new Scanner(input);</span><br><span class="line">result = scanner.findWithinHorizon(&quot;study&quot;, 20);</span><br><span class="line">System.out.println(&quot;findWithinHorizon(): &quot; + result); // 输出 &quot;study&quot;</span><br><span class="line">scanner.close(); // 关闭 Scanner 对象</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们首先创建了一个字符串 input，表示要查找的文本。然后，我们使用 Scanner 类的构造方法创建 Scanner 对象，并将 input 作为输入流传递给该对象。接着，我们使用 findInLine() 方法和 findWithinHorizon() 方法分别查找字符串中的单词 “study”。其中， findInLine() 方法在当前行中查找匹配项，而 findWithinHorizon() 方法在指定的限制范围内查找匹配项。在本例中，我们将查找的范围<br>限制为前 20 个字符。</p>
<p>需要注意的是， findInLine() 方法和 findWithinHorizon() 方法都返回找到的匹配项。如果没有找到匹配项，则返回 null。此外， findInLine() 方法和 findWithinHorizon() 方法都会忽略默认的分隔符，因此需要使用正则表达式来指定查找的模式。在本例中，我们使用了字符串 “study” 作为查找的模式。</p>
<p>当然我们也可以使用正则表达式，比如说我们要在下面的文件中查找 openjdk 这个关键字。</p>
<p><img src="\assets\note\image-20231012142449036.png" alt="image-20231012142449036"></p>
<p>代码就可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 创建 File 对象，表示要扫描的文件</span><br><span class="line">Scanner scanner = new Scanner(new File(&quot;docs/安装环境.md&quot;)); // 创建 Scanner 对象，从文</span><br><span class="line">件中读取数据</span><br><span class="line">Pattern pattern = Pattern.compile(&quot;op..jdk&quot;);</span><br><span class="line">String result;</span><br><span class="line">while ((result = scanner.findWithinHorizon(pattern, 0)) != null) &#123;</span><br><span class="line">    System.out.println(&quot;findWithinHorizon(): &quot; + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们用正则表达式 pattern 来表示 openjdk 这个关键字， op..jdk 中的 . 表示任意字符，可以通过查找正则表达式去了解。</p>
<p>然后我们使用 while 循环来查找文件中所有的 openjdk ，其中 findWithinHorizon 方法的第二个参数如果为 0 则表示忽略边界，如果没找到，会返回 null。</p>
<p><img src="\assets\note\image-20231012142541300.png" alt="image-20231012142541300"></p>
<p>由于文件中有两个 openjdk 关键字，所以输出结果如下所示：</p>
<p><img src="\assets\note\image-20231012142557757.png" alt="image-20231012142557757"></p>
<p><strong>04、小结 </strong></p>
<p>总之，Scanner 类是一个功能强大的输入处理工具类，不仅可以扫描控制台的输入流，还可以扫描文件，并且提供了多种方法来读取不同类型的数据，比如 next() , nextInt() , nextLine() , nextDouble() 等。</p>
<p>除此之外，还可以通过 useDelimiter() 方法设置分隔符，通过 findInLine() , findWithinHorizon() 查找匹配项等。</p>
<h2 id="7-2-Arrays工具类"><a href="#7-2-Arrays工具类" class="headerlink" title="7.2 Arrays工具类"></a>7.2 Arrays工具类</h2><p>“哥，数组专用工具类是专门用来操作数组的吗？比如说创建数组、数组排序、数组检索等等。”三妹的提问其实已经把答案说了出来。</p>
<p>“是滴，这里说的数组专用工具类指的是 java.util.Arrays 类，基本上常见的数组操作，这个类都提供了静态方法可供直接调用。毕竟数组本身想完成这些操作还是挺麻烦的，有了这层封装，就方便多了。”在回答三妹的同时，我打开 Intellij IDEA，找到了 Arrays 类的源码。</p>
<p>“具体来说，数组操作可分为以下 9 种。”</p>
<ul>
<li>创建数组</li>
<li>比较数组</li>
<li>数组排序</li>
<li>数组检索</li>
<li>数组转流</li>
<li>打印数组</li>
<li>数组转 List</li>
<li>setAll（没想好中文名）</li>
<li>parallelPrefix（没想好中文名）</li>
</ul>
<p>“我们来一个一个学习。”</p>
<p><strong>01、创建数组 </strong></p>
<p>使用 Arrays 类创建数组可以通过以下三个方法：</p>
<ul>
<li>copyOf，复制指定的数组，截取或用 null 填充</li>
<li>copyOfRange，复制指定范围内的数组到一个新的数组</li>
<li>fill，对数组进行填充</li>
</ul>
<p><strong>1）copyOf </strong></p>
<p>直接来看例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String[] intro = new String[] &#123; &quot;沉&quot;, &quot;默&quot;, &quot;王&quot;, &quot;二&quot; &#125;;</span><br><span class="line">String[] revised = Arrays.copyOf(intro, 3);</span><br><span class="line">String[] expanded = Arrays.copyOf(intro, 5);</span><br><span class="line">System.out.println(Arrays.toString(revised));</span><br><span class="line">System.out.println(Arrays.toString(expanded));</span><br></pre></td></tr></table></figure>
<p>revised 和 expanded 是复制后的新数组，长度分别是 3 和 5，指定的数组长度是 4。来看一下输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[沉, 默, 王]</span><br><span class="line">[沉, 默, 王, 二, null]</span><br></pre></td></tr></table></figure>
<p>看到没？revised 截取了最后一位，因为长度是 3 嘛；expanded 用 null 填充了一位，因为长度是 5。</p>
<p>ArrayList（内部的数据结构用的就是数组）源码中的 grow() 方法就调用了 copyOf() 方法：当 ArrayList 初始大小不满足元素的增长时就会扩容。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private Object[] grow(int minCapacity) &#123;</span><br><span class="line">    return elementData = Arrays.copyOf(elementData,</span><br><span class="line">            newCapacity(minCapacity));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2）copyOfRange </strong></p>
<p>直接来看例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] intro = new String[] &#123; &quot;沉&quot;, &quot;默&quot;, &quot;王&quot;, &quot;二&quot; &#125;;</span><br><span class="line">String[] abridgement = Arrays.copyOfRange(intro, 0, 3);</span><br><span class="line">System.out.println(Arrays.toString(abridgement));</span><br></pre></td></tr></table></figure>
<p>copyOfRange() 方法需要三个参数，第一个是指定的数组，第二个是起始位置（包含），第三个是截止位置（不包含）。来看一下输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[沉, 默, 王]</span><br></pre></td></tr></table></figure>
<p>0 的位置是“沉”，3 的位置是“二”，也就是说截取了从 0 位（包含）到 3 位（不包含）的数组元素。那假如说下标超出了数组的长度，会发生什么呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] abridgementExpanded = Arrays.copyOfRange(intro, 0, 6);</span><br><span class="line">System.out.println(Arrays.toString(abridgementExpanded));</span><br></pre></td></tr></table></figure>
<p>结束位置此时为 6，超出了指定数组的长度 4，来看一下输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[沉, 默, 王, 二, null, null]</span><br></pre></td></tr></table></figure>
<p>仍然使用了 null 进行填充。</p>
<p>“为什么要这么做呢？”经过这段时间的学习，三妹的眼光越来越毒辣了，问的问题都恰到好处。</p>
<p>“嗯，我想是 Arrays 的设计者考虑到了数组越界的问题，不然每次调用 Arrays 类就要先判断很多次长度，很麻烦。”稍作思考后，我给出了这样一个回答。</p>
<p><strong>3）fill </strong></p>
<p>直接来看例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] stutter = new String[4];</span><br><span class="line">Arrays.fill(stutter, &quot;沉默王二&quot;);</span><br><span class="line">System.out.println(Arrays.toString(stutter));</span><br></pre></td></tr></table></figure>
<p>使用 new 关键字创建了一个长度为 4 的数组，然后使用 fill() 方法将 4 个位置填充为“沉默王二”，来看一下输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[沉默王二, 沉默王二, 沉默王二, 沉默王二]</span><br></pre></td></tr></table></figure>
<p>如果想要一个元素完全相同的数组时， fill() 方法就派上用场了。</p>
<p><strong>02、比较数组 </strong></p>
<p>Arrays 类的 equals() 方法用来判断两个数组是否相等，来看下面这个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String[] intro = new String[] &#123; &quot;沉&quot;, &quot;默&quot;, &quot;王&quot;, &quot;二&quot; &#125;;</span><br><span class="line">boolean result = Arrays.equals(new String[] &#123; &quot;沉&quot;, &quot;默&quot;, &quot;王&quot;, &quot;二&quot; &#125;, intro);</span><br><span class="line">System.out.println(result);</span><br><span class="line">boolean result1 = Arrays.equals(new String[] &#123; &quot;沉&quot;, &quot;默&quot;, &quot;王&quot;, &quot;三&quot; &#125;, intro);</span><br><span class="line">System.out.println(result1);</span><br></pre></td></tr></table></figure>
<p>输出结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure>
<p>指定的数组为沉默王二四个字，比较的数组一个是沉默王二，一个是沉默王三，所以 result 为 true，result1 为 false。</p>
<p>简单看一下 equals() 方法的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static boolean equals(Object[] a, Object[] a2) &#123;</span><br><span class="line">    if (a==a2)</span><br><span class="line">        return true;</span><br><span class="line">    if (a==null || a2==null)</span><br><span class="line">        return false;</span><br><span class="line">    int length = a.length;</span><br><span class="line">    if (a2.length != length)</span><br><span class="line">        return false;</span><br><span class="line">    for (int i=0; i&lt;length; i++) &#123;</span><br><span class="line">        if (!Objects.equals(a[i], a2[i]))</span><br><span class="line">            return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为数组是一个对象，所以先使用“\==”操作符进行判断，如果不相等，再判断是否为 null，其中一个为 null，返回 false；紧接着判断 length，不等的话，返回 false；否则的话，依次调用 Objects.equals() 比较相同位置上的元素是否相等。</p>
<p>“这段代码还是非常严谨的，对吧？三妹，这也就是我们学习源码的意义，欣赏的同时，可以学习源码作者清晰的编码思路。”我语重心长地给三妹讲。</p>
<p>除了 equals() 方法，还有另外一个诀窍可以判断两个数组是否相等，尽管可能会出现误差。那就是 Arrays.hashCode() 方法，先来看一下该方法的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static int hashCode(Object a[]) &#123;</span><br><span class="line">    if (a == null)</span><br><span class="line">        return 0;</span><br><span class="line">    int result = 1;</span><br><span class="line">    for (Object element : a)</span><br><span class="line">        result = 31 * result + (element == null ? 0 : element.hashCode());</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>哈希算法本身是非常严谨的，所以如果两个数组的哈希值相等，那几乎可以判断两个数组是相等的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] intro = new String[] &#123; &quot;沉&quot;, &quot;默&quot;, &quot;王&quot;, &quot;二&quot; &#125;;</span><br><span class="line">System.out.println(Arrays.hashCode(intro));</span><br><span class="line">System.out.println(Arrays.hashCode(new String[] &#123; &quot;沉&quot;, &quot;默&quot;, &quot;王&quot;, &quot;二&quot; &#125;));</span><br></pre></td></tr></table></figure>
<p>来看一下输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">868681617</span><br><span class="line">868681617</span><br></pre></td></tr></table></figure>
<p>两个数组的哈希值相等，毕竟元素是一样的。但这样确实不够严谨，优先使用 Objects.equals() 方法，当我们想快速确认两个数组是否相等时，可以通过比较 hashCode 来确认——算是投机取巧吧，高收益高风险，哈哈。</p>
<p><strong>03、数组排序 </strong></p>
<p>Arrays 类的 sort() 方法用来对数组进行排序，来看下面这个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] intro1 = new String[] &#123; &quot;chen&quot;, &quot;mo&quot;, &quot;wang&quot;, &quot;er&quot; &#125;;</span><br><span class="line">String[] sorted = Arrays.copyOf(intro1, 4);</span><br><span class="line">Arrays.sort(sorted);</span><br><span class="line">System.out.println(Arrays.toString(sorted));</span><br></pre></td></tr></table></figure>
<p>由于排序会改变原有的数组，所以我们使用了 copyOf() 方法重新复制了一份。来看一下输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[chen, er, mo, wang]</span><br></pre></td></tr></table></figure>
<p>可以看得出，按照的是首字母的升序进行排列的。基本数据类型是按照双轴快速排序的，引用数据类型是按照 TimSort 排序的，使用了 Peter McIlroy 的“乐观排序和信息理论复杂性”中的技术。</p>
<p>“哥，你说的这些排序算法我都不太懂啊！”三妹眨巴眨巴眼睛说。</p>
<p>“不要紧的，后面学了数据结构与算法后，就明白了，现在了解这个东西即可。”我赶紧甩出了安抚大法。</p>
<p><strong>04、数组检索 </strong></p>
<p>数组排序后就可以使用 Arrays 类的 binarySearch() 方法进行二分查找了。否则的话，只能线性检索，效率就会低很多。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String[] intro1 = new String[] &#123; &quot;chen&quot;, &quot;mo&quot;, &quot;wang&quot;, &quot;er&quot; &#125;;</span><br><span class="line">String[] sorted = Arrays.copyOf(intro1, 4);</span><br><span class="line">Arrays.sort(sorted);</span><br><span class="line">int exact = Arrays.binarySearch(sorted, &quot;wang&quot;);</span><br><span class="line">System.out.println(exact);</span><br><span class="line">int caseInsensitive = Arrays.binarySearch(sorted, &quot;Wang&quot;, </span><br><span class="line">String::compareToIgnoreCase);</span><br><span class="line">System.out.println(caseInsensitive);</span><br></pre></td></tr></table></figure>
<p> binarySearch() 方法既可以精确检索，也可以模糊检索，比如说忽略大小写。来看一下输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p>排序后的结果是 [chen, er, mo, wang] ，所以检索出来的下标是 3。</p>
<p>“三妹，记住了，以后如果要从数组或者集合中查找元素的话，尽量先排序，然后使用二分查找法，这样能提高检索的效率。”</p>
<p>三妹若有所思的点了点头。</p>
<p><strong>05、数组转流 </strong></p>
<p>“流是什么呀？”三妹好奇的问。</p>
<p>“流的英文单词是 Stream，它可以极大提高 Java 程序员的生产力，让程序员写出高效、干净、简洁的代码。 这种风格将要处理的集合看作是一种流，想象一下水流在管道中流过的样子，我们可以在管道中对流进行处理，比如筛选、排序等等。Stream 具体怎么使用，我们留到后面再详细地讲，这里你先有一个大致的印象就可以了。”我回答到。</p>
<p>Arrays 类的 stream() 方法可以将数组转换成流：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] intro = new String[] &#123; &quot;沉&quot;, &quot;默&quot;, &quot;王&quot;, &quot;二&quot; &#125;;</span><br><span class="line">System.out.println(Arrays.stream(intro).count());</span><br></pre></td></tr></table></figure>
<p>还可以为 stream() 方法指定起始下标和结束下标：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Arrays.stream(intro, 1, 2).count());</span><br></pre></td></tr></table></figure>
<p>如果下标的范围有误的时候，比如说从 2 到 1 结束，则程序会抛出 ArrayIndexOutOfBoundsException 异常：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.ArrayIndexOutOfBoundsException: origin(2) &gt; </span><br><span class="line">fence(1)</span><br><span class="line">    at java.base/java.util.Spliterators.checkFromToBounds(Spliterators.java:387)</span><br></pre></td></tr></table></figure>
<p><strong>06、打印数组 </strong></p>
<p>因为数组是一个对象，直接 System.out.println 的话，结果是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Ljava.lang.String;@3d075dc0</span><br></pre></td></tr></table></figure>
<p>最优雅的打印方式，是使用 Arrays.toString() ，其实前面讲过。来看一下该方法的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static String toString(Object[] a) &#123;</span><br><span class="line">    if (a == null)</span><br><span class="line">        return &quot;null&quot;;</span><br><span class="line">    int iMax = a.length - 1;</span><br><span class="line">    if (iMax == -1)</span><br><span class="line">        return &quot;[]&quot;;</span><br><span class="line">    StringBuilder b = new StringBuilder();</span><br><span class="line">    b.append(&#x27;[&#x27;);</span><br><span class="line">    for (int i = 0; ; i++) &#123;</span><br><span class="line">        b.append(String.valueOf(a[i]));</span><br><span class="line">        if (i == iMax)</span><br><span class="line">            return b.append(&#x27;]&#x27;).toString();</span><br><span class="line">        b.append(&quot;, &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>先判断 null，是的话，直接返回“null”字符串；</li>
<li>获取数组的长度，如果数组的长度为 0（ 等价于 length - 1 为 -1），返回中括号“[]”，表示数组为空的；</li>
<li>如果数组既不是 null，长度也不为 0，就声明 StringBuilder 对象，然后添加一个数组的开始标记“[”，之后再遍历数组，把每个元素添加进去；其中一个小技巧就是，当遇到末尾元素的时候（i == iMax），不再添加逗号和空格“, ”，而是添加数组的闭合标记“]”。</li>
</ul>
<p>“哥，我能不能问一个问题呀？”</p>
<p>“你问啊。”</p>
<p>“就是为什么判断数组长度为 0 的时候判断的是减 1 后比较 -1 呢？为什么不直接比较 0 呢？”</p>
<p>“呀，你这个问题问的很妙啊！”我想到三妹说一句“respect”，很强！“其实是和遍历数组的时候判断 i == iMax 有关了，否则这里就要用 i == iMax -1 来判断是否到达数组的最后一个元素了。”</p>
<p>“哦—————”三妹似乎明白了什么。</p>
<p><strong>07、数组转 List </strong></p>
<p>尽管数组非常强大，但它自身可以操作的工具方法很少，比如说判断数组中是否包含某个值。如果能转成 List 的话，就简便多了，因为 Java 的集合框架 List 中封装了很多常用的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] intro = new String[] &#123; &quot;沉&quot;, &quot;默&quot;, &quot;王&quot;, &quot;二&quot; &#125;;</span><br><span class="line">List&lt;String&gt; rets = Arrays.asList(intro);</span><br><span class="line">System.out.println(rets.contains(&quot;二&quot;));</span><br></pre></td></tr></table></figure>
<p>不过需要注意的是， Arrays.asList() 返回的是 java.util.Arrays.ArrayList ，并不是 java.util.ArrayList ，它的长度是固定的，无法进行元素的删除或者添加。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rets.add(&quot;三&quot;);</span><br><span class="line">rets.remove(&quot;二&quot;);</span><br></pre></td></tr></table></figure>
<p>这个在编码的时候一定要注意，否则在执行这两个方法的时候，会抛出异常：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException</span><br><span class="line">    at java.base/java.util.AbstractList.add(AbstractList.java:153)</span><br><span class="line">    at java.base/java.util.AbstractList.add(AbstractList.java:111)</span><br></pre></td></tr></table></figure>
<p>要想操作元素的话，需要多一步转化，转成真正的 java.util.ArrayList ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; rets1 = new ArrayList&lt;&gt;(Arrays.asList(intro));</span><br><span class="line">rets1.add(&quot;三&quot;);</span><br><span class="line">rets1.remove(&quot;二&quot;);</span><br></pre></td></tr></table></figure>
<p><strong>08、setAll </strong></p>
<p>Java 8 新增了 setAll() 方法，它提供了一个函数式编程的入口，可以对数组的元素进行填充：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int[] array = new int[10];</span><br><span class="line">Arrays.setAll(array, i -&gt; i * 10);</span><br><span class="line">System.out.println(Arrays.toString(array));</span><br></pre></td></tr></table></figure>
<p>“这段代码什么意思呢？”三妹问。</p>
<p>i 就相当于是数组的下标，值从 0 开始，到 9 结束，那么 i <em> 10 就意味着值从 0 </em> 10 开始，到 9 * 10 结束，来看一下输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0, 10, 20, 30, 40, 50, 60, 70, 80, 90]</span><br></pre></td></tr></table></figure>
<p>可以用来为新数组填充基于原来数组的新元素。</p>
<p><strong>09、parallelPrefix </strong></p>
<p>parallelPrefix() 方法和 setAll() 方法一样，也是 Java 8 之后提供的，提供了一个函数式编程的入口，通过遍历数组中的元素，将当前下标位置上的元素与它之前下标的元素进行操作，然后将操作后的结果覆盖当前下标位置上的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int[] arr = new int[] &#123; 1, 2, 3, 4&#125;;</span><br><span class="line">Arrays.parallelPrefix(arr, (left, right) -&gt; left + right);</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br></pre></td></tr></table></figure>
<p>上面代码中有一个 Lambda 表达式（ (left, right) -&gt; left + right ），是什么意思呢？上面这段代码等同于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int[] arr = new int[]&#123;1, 2, 3, 4&#125;;</span><br><span class="line">Arrays.parallelPrefix(arr, (left, right) -&gt; &#123;</span><br><span class="line">    System.out.println(left + &quot;，&quot; + right);</span><br><span class="line">    return left + right;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br></pre></td></tr></table></figure>
<p>来看一下输出结果就明白了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1，2</span><br><span class="line">3，3</span><br><span class="line">6，4</span><br><span class="line">[1, 3, 6, 10]</span><br></pre></td></tr></table></figure>
<p>也就是说， Lambda 表达式执行了三次：</p>
<ul>
<li>第一次是 1 和 2 相加，结果是 3，替换下标为 1 的位置</li>
<li>第二次是 3 和 3 相加，结果是 6，也就是第一次的结果和下标为 2 的元素相加的结果</li>
<li>第三次是 6 和 4 相加，结果是 10，也就是第二次的结果和下标为 3 的元素相加的结果</li>
</ul>
<p><strong>10、总结 </strong></p>
<p>“好了，三妹，就先学到这吧。如果你以后翻 Java 源码的时候，只要是用到数组的，尤其是 ArrayList 类，就可以看到 Arrays 类的很多影子。”</p>
<p>“嗯嗯，我先复习一下这节的内容。哥，你去休息吧。”</p>
<h2 id="7-3-StringUtils工具类"><a href="#7-3-StringUtils工具类" class="headerlink" title="7.3 StringUtils工具类"></a>7.3 StringUtils工具类</h2><p>字符串 （String）在我们的日常工作中，用得非常非常非常多。</p>
<p>在我们的代码中经常需要对字符串判空，截取字符串、转换大小写、分隔字符串、比较字符串、去掉多余空格、拼接字符串、使用正则表达式等等。</p>
<p>如果只用 String 类提供的那些方法，我们需要手写大量的额外代码，不然容易出现各种异常。</p>
<p>现在有个好消息是： org.apache.commons.lang3包下的 StringUtils工具类，给我们提供了非常丰富的选择。</p>
<p>Maven 坐标：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.12.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>StringUtils 提供了非常多实用的方法，大概有下图的四页到五页，我只截了两页，实在是太多了。</p>
<p><img src="\assets\note\image-20231012144531912.png" alt="image-20231012144531912"></p>
<p>接下来，我们来拿一些常用的方法举例说明。</p>
<p><strong>字符串判空 </strong></p>
<p>其实空字符串，不只是 null 一种，还有””，” “，”null”等等，多种情况。</p>
<p>StringUtils 给我们提供了多个判空的静态方法，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">String str1 = null;</span><br><span class="line">String str2 = &quot;&quot;;</span><br><span class="line">String str3 = &quot; &quot;;</span><br><span class="line">String str4 = &quot;abc&quot;;</span><br><span class="line">System.out.println(StringUtils.isEmpty(str1));</span><br><span class="line">System.out.println(StringUtils.isEmpty(str2));</span><br><span class="line">System.out.println(StringUtils.isEmpty(str3));</span><br><span class="line">System.out.println(StringUtils.isEmpty(str4));</span><br><span class="line">System.out.println(&quot;=====&quot;);</span><br><span class="line">System.out.println(StringUtils.isNotEmpty(str1));</span><br><span class="line">System.out.println(StringUtils.isNotEmpty(str2));</span><br><span class="line">System.out.println(StringUtils.isNotEmpty(str3));</span><br><span class="line">System.out.println(StringUtils.isNotEmpty(str4));</span><br><span class="line">System.out.println(&quot;=====&quot;);</span><br><span class="line">System.out.println(StringUtils.isBlank(str1));</span><br><span class="line">System.out.println(StringUtils.isBlank(str2));</span><br><span class="line">System.out.println(StringUtils.isBlank(str3));</span><br><span class="line">System.out.println(StringUtils.isBlank(str4));</span><br><span class="line">System.out.println(&quot;=====&quot;);</span><br><span class="line">System.out.println(StringUtils.isNotBlank(str1));</span><br><span class="line">System.out.println(StringUtils.isNotBlank(str2));</span><br><span class="line">System.out.println(StringUtils.isNotBlank(str3));</span><br><span class="line">System.out.println(StringUtils.isNotBlank(str4));</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">true</span><br><span class="line">false</span><br><span class="line">false</span><br><span class="line">=====</span><br><span class="line">false</span><br><span class="line">false</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">=====</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">false</span><br><span class="line">=====</span><br><span class="line">false</span><br><span class="line">false</span><br><span class="line">false</span><br><span class="line">true</span><br></pre></td></tr></table></figure>
<p>示例中的： isEmpty 、 isNotEmpty 、 isBlank和 isNotBlank ，这 4 个判空方法你们可以根据实际情况使用。</p>
<p>优先推荐使用 isBlank和 isNotBlank方法，因为它会把 “ “也考虑进去。</p>
<p><strong>分隔字符串 </strong></p>
<p>分隔字符串是常见需求，如果直接使用 String 类的 split 方法，就可能会出现空指针异常。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str1 = null;</span><br><span class="line">System.out.println(StringUtils.split(str1,&quot;,&quot;));</span><br><span class="line">System.out.println(str1.split(&quot;,&quot;));</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">null</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.NullPointerException</span><br><span class="line">\tat com.sue.jump.service.test1.UtilTest.main(UtilTest.java:21)</span><br></pre></td></tr></table></figure>
<p>使用 StringUtils 的 split 方法会返回 null，而使用 String 的 split 方法会报指针异常。</p>
<p><strong>判断是否纯数字 </strong></p>
<p>给定一个字符串，判断它是否为纯数字，可以使用 isNumeric方法。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String str1 = &quot;123&quot;;</span><br><span class="line">String str2 = &quot;123q&quot;;</span><br><span class="line">String str3 = &quot;0.33&quot;;</span><br><span class="line">System.out.println(StringUtils.isNumeric(str1));</span><br><span class="line">System.out.println(StringUtils.isNumeric(str2));</span><br><span class="line">System.out.println(StringUtils.isNumeric(str3));</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br><span class="line">false</span><br></pre></td></tr></table></figure>
<p><strong>将集合拼接成字符串 </strong></p>
<p>有时候，我们需要将某个集合的内容，拼接成一个字符串，然后输出，这时可以使用 join方法。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Lists.newArrayList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</span><br><span class="line">List&lt;Integer&gt; list2 = Lists.newArrayList(1, 2, 3);</span><br><span class="line">System.out.println(StringUtils.join(list, &quot;,&quot;));</span><br><span class="line">System.out.println(StringUtils.join(list2, &quot; &quot;));</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a,b,c</span><br><span class="line">1 2 3</span><br></pre></td></tr></table></figure>
<p><strong>其他方法 </strong></p>
<p>这里再列举一些，其他的方法可以自己去研究一下。</p>
<ul>
<li>trim(String str) ：去除字符串首尾的空白字符。</li>
<li>trimToEmpty(String str) ：去除字符串首尾的空白字符，如果字符串为 null，则返回空字符串。</li>
<li>trimToNull(String str) ：去除字符串首尾的空白字符，如果结果为空字符串，则返回 null。</li>
<li>equals(String str1, String str2) ：比较两个字符串是否相等。</li>
<li>equalsIgnoreCase(String str1, String str2) ：比较两个字符串是否相等，忽略大小写。</li>
<li>startsWith(String str, String prefix) ：检查字符串是否以指定的前缀开头。</li>
<li>endsWith(String str, String suffix) ：检查字符串是否以指定的后缀结尾。</li>
<li>contains(String str, CharSequence seq) ：检查字符串是否包含指定的字符序列。</li>
<li>indexOf(String str, CharSequence seq) ：返回指定字符序列在字符串中首次出现的索引，如果没有找到，则返回 -1。</li>
<li>lastIndexOf(String str, CharSequence seq) ：返回指定字符序列在字符串中最后一次出现的索引，如果没有找到，则返回 -1。</li>
<li>substring(String str, int start, int end) ：截取字符串中指定范围的子串。</li>
<li>replace(String str, String searchString, String replacement) ：替换字符串中所有出现的搜索字符串为指定的替换字符串。</li>
<li>replaceAll(String str, String regex, String replacement) ：使用正则表达式替换字符串中所有匹配的部分。</li>
<li>join(Iterable&lt;?&gt; iterable, String separator) ：使用指定的分隔符将可迭代对象中的元素连接为一个字符串。</li>
<li>split(String str, String separator) ：使用指定的分隔符将字符串分割为一个字符串数组。</li>
<li>capitalize(String str) ：将字符串的第一个字符转换为大写。</li>
<li>uncapitalize(String str) ：将字符串的第一个字符转换为小写。</li>
</ul>
<h2 id="7-4-Objects工具类"><a href="#7-4-Objects工具类" class="headerlink" title="7.4 Objects工具类"></a>7.4 Objects工具类</h2><p>Java 的 Objects 类是一个实用工具类，包含了一系列静态方法，用于处理对象。它位于 java.util 包中，自 Java 7 引入。Objects 类的主要目的是降低代码中的空指针异常 (NullPointerException) 风险，同时提供一些非常实用的方法供我们使用。</p>
<p><strong>对象判空 </strong></p>
<p>在 Java 中，万物皆对象，对象的判空可以说无处不在。Objects 的 isNull 方法用于判断对象是否为空，而 nonNull 方法判断对象是否不为空。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Integer integer = new Integer(1);</span><br><span class="line">if (Objects.isNull(integer)) &#123;</span><br><span class="line">    System.out.println(&quot;对象为空&quot;);</span><br><span class="line">&#125;</span><br><span class="line">if (Objects.nonNull(integer)) &#123;</span><br><span class="line">    System.out.println(&quot;对象不为空&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>对象为空时抛异常 </strong></p>
<p>如果我们想在对象为空时，抛出空指针异常，可以使用 Objects 的 requireNonNull 方法。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer integer1 = new Integer(128);</span><br><span class="line">Objects.requireNonNull(integer1);</span><br><span class="line">Objects.requireNonNull(integer1, &quot;参数不能为空&quot;);</span><br><span class="line">Objects.requireNonNull(integer1, () -&gt; &quot;参数不能为空&quot;);</span><br></pre></td></tr></table></figure>
<p><strong>判断两个对象是否相等 </strong></p>
<p>我们经常需要判断两个对象是否相等，Objects 给我们提供了 equals 方法，能非常方便的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer integer1 = new Integer(1);</span><br><span class="line">Integer integer2 = new Integer(1);</span><br><span class="line">System.out.println(Objects.equals(integer1, integer2));</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure>
<p>但使用这个方法有坑，比如例子改成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer integer1 = new Integer(1);</span><br><span class="line">Long integer2 = new Long(1);</span><br><span class="line">System.out.println(Objects.equals(integer1, integer2));</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">false</span><br></pre></td></tr></table></figure>
<p>不过，需要注意的是，虽然 Objects.equals() 方法本身是用来避免坑的，因为它可以处理 null 值的比较，而不会抛出空指针异常。然而，这并不意味着它没有任何潜在问题。实际上， Objects.equals() 方法的一个潜在问题是依赖于被比较对象的 equals() 方法实现。</p>
<p>当两个对象的类没有正确实现 equals() 方法时， Objects.equals() 方法可能会产生不符合预期的结果。举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class ObjectsDemo1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person person1 = new Person(&quot;沉默王二&quot;, 18);</span><br><span class="line">        Person person2 = new Person(&quot;沉默王二&quot;, 18);</span><br><span class="line">        System.out.println(Objects.equals(person1, person2)); // 输出：false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Person &#123;</span><br><span class="line">    String name;</span><br><span class="line">    int age;</span><br><span class="line">    Person(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，我们创建了一个名为 Person 的类，但是没有重写 equals() 方法。然后我们创建了两个具有相同属性的 Person 对象，并使用 Objects.equals() 方法比较它们。尽管这两个对象的属性是相同的，但输出结果却是 false。这是因为 Objects.equals() 方法依赖于对象的 equals() 方法，而在这个例子中，Person 类没有正确地实现 equals() 方法，所以默认情况下会使用 Object 类的 equals() 方法，它只比较对象引用是否相同。</p>
<p>为了解决这个问题，我们需要在 Person 类中重写 equals() 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">    if (this == obj) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (obj == null || getClass() != obj.getClass()) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    Person person = (Person) obj;</span><br><span class="line">    return age == person.age &amp;&amp; Objects.equals(name, person.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，当我们使用 Objects.equals() 方法比较两个具有相同属性的 Person 对象时，输出将是 true，符合我们的预期。</p>
<p><strong>获取对象的hashCode </strong></p>
<p>如果你想获取某个对象的 hashCode，可以使用 Objects 的 hashCode 方法。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = new String(&quot;沉默王二&quot;);</span><br><span class="line">System.out.println(Objects.hashCode(str));</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">867758096</span><br></pre></td></tr></table></figure>
<p><strong>比较两个对象 </strong></p>
<p>compare() 方法用于比较两个对象，通常用于自定义排序。它需要一个比较器 (Comparator) 作为参数。如果比较器为 null，则使用自然顺序。以下是一个 compare() 方法的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class ObjectsCompareDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        PersonCompare person1 = new PersonCompare(&quot;itwanger&quot;, 30);</span><br><span class="line">        PersonCompare person2 = new PersonCompare(&quot;chenqingyang&quot;, 25);</span><br><span class="line">        Comparator&lt;PersonCompare&gt; ageComparator = Comparator.comparingInt(p -&gt; </span><br><span class="line">p.age);</span><br><span class="line">        int ageComparisonResult = Objects.compare(person1, person2, ageComparator);</span><br><span class="line">        System.out.println(&quot;年龄排序: &quot; + ageComparisonResult); // 输出：1（表示 </span><br><span class="line">person1 的 age 在 person2 之后）</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class PersonCompare &#123;</span><br><span class="line">    String name;</span><br><span class="line">    int age;</span><br><span class="line">    PersonCompare(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>比较两个数组 </strong></p>
<p>deepEquals() 用于比较两个数组类型的对象，当对象是非数组的话，行为和 equals() 一致。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int[] array1 = &#123;1, 2, 3&#125;;</span><br><span class="line">int[] array2 = &#123;1, 2, 3&#125;;</span><br><span class="line">int[] array3 = &#123;1, 2, 4&#125;;</span><br><span class="line">System.out.println(Objects.deepEquals(array1, array2)); // 输出：true（因为 array1 和 array2 的内容相同）</span><br><span class="line">System.out.println(Objects.deepEquals(array1, array3)); // 输出：false（因为 array1 和 array3 的内容不同）</span><br><span class="line">// 对于非数组对象，deepEquals() 的行为与 equals() 相同</span><br><span class="line">String string1 = &quot;hello&quot;;</span><br><span class="line">String string2 = &quot;hello&quot;;</span><br><span class="line">String string3 = &quot;world&quot;;</span><br><span class="line">System.out.println(Objects.deepEquals(string1, string2)); // 输出：true（因为 string1 和 string2 相同）</span><br><span class="line">System.out.println(Objects.deepEquals(string1, string3)); // 输出：false（因为 string1 和 string3 不同）</span><br></pre></td></tr></table></figure>
<p>再来个二维数组的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String[][] nestedArray1 = &#123;&#123;&quot;A&quot;, &quot;B&quot;&#125;, &#123;&quot;C&quot;, &quot;D&quot;&#125;&#125;;</span><br><span class="line">String[][] nestedArray2 = &#123;&#123;&quot;A&quot;, &quot;B&quot;&#125;, &#123;&quot;C&quot;, &quot;D&quot;&#125;&#125;;</span><br><span class="line">String[][] nestedArray3 = &#123;&#123;&quot;A&quot;, &quot;B&quot;&#125;, &#123;&quot;C&quot;, &quot;E&quot;&#125;&#125;;</span><br><span class="line">System.out.println(Objects.deepEquals(nestedArray1, nestedArray2)); // 输出：true (因为嵌套数组元素相同)</span><br><span class="line">System.out.println(Objects.deepEquals(nestedArray1, nestedArray3)); // 输出：false (因为嵌套数组元素不同)</span><br></pre></td></tr></table></figure>
<p><strong>小结 </strong></p>
<p>除了上面提到的这些方法，Objects 还提供了一些其他的方法，比如说 toString，感兴趣的话可以试一下。</p>
<p><img src="\assets\note\image-20231012145518757.png" alt="image-20231012145518757"></p>
<p>总之，Objects 类提供的这些方法在许多情况下还是非常有用得，可以简化代码并减少出错的可能性。</p>
<h2 id="7-5-Collections工具类"><a href="#7-5-Collections工具类" class="headerlink" title="7.5 Collections工具类"></a>7.5 Collections工具类</h2><p>Collections 是 JDK 提供的一个工具类，位于 java.util 包下，提供了一系列的静态方法，方便我们对集合进行各种骚操作，算是集合框架的一个大管家。</p>
<p>还记得我们前面讲过的 Arrays 工具类吗？可以回去温习下。</p>
<p>Collections 的用法很简单，在 Intellij IDEA 中敲完 Collections. 之后就可以看到它提供的方法了，大致看一下方法名和参数就能知道这个方法是干嘛的。</p>
<p><img src="\assets\note\image-20231012145612062.png" alt="image-20231012145612062"></p>
<p>为了节省大家的学习时间，我将这些方法做了一些分类，并列举了一些简单的例子。</p>
<p><strong>01、排序操作 </strong></p>
<ul>
<li>reverse(List list) ：反转顺序</li>
<li>shuffle(List list) ：洗牌，将顺序打乱</li>
<li>sort(List list) ：自然升序</li>
<li>sort(List list, Comparator c) ：按照自定义的比较器排序</li>
<li>swap(List list, int i, int j) ：将 i 和 j 位置的元素交换位置</li>
</ul>
<p>来看例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list.add(&quot;沉默王二&quot;);</span><br><span class="line">list.add(&quot;沉默王三&quot;);</span><br><span class="line">list.add(&quot;沉默王四&quot;);</span><br><span class="line">list.add(&quot;沉默王五&quot;);</span><br><span class="line">list.add(&quot;沉默王六&quot;);</span><br><span class="line">System.out.println(&quot;原始顺序：&quot; + list);</span><br><span class="line">// 反转</span><br><span class="line">Collections.reverse(list);</span><br><span class="line">System.out.println(&quot;反转后：&quot; + list);</span><br><span class="line">// 洗牌</span><br><span class="line">Collections.shuffle(list);</span><br><span class="line">System.out.println(&quot;洗牌后：&quot; + list);</span><br><span class="line">// 自然升序</span><br><span class="line">Collections.sort(list);</span><br><span class="line">System.out.println(&quot;自然升序后：&quot; + list);</span><br><span class="line">// 交换</span><br><span class="line">Collections.swap(list, 2,4);</span><br><span class="line">System.out.println(&quot;交换后：&quot; + list);</span><br></pre></td></tr></table></figure>
<p>输出后：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原始顺序：[沉默王二, 沉默王三, 沉默王四, 沉默王五, 沉默王六]</span><br><span class="line">反转后：[沉默王六, 沉默王五, 沉默王四, 沉默王三, 沉默王二]</span><br><span class="line">洗牌后：[沉默王五, 沉默王二, 沉默王六, 沉默王三, 沉默王四]</span><br><span class="line">自然升序后：[沉默王三, 沉默王二, 沉默王五, 沉默王六, 沉默王四]</span><br><span class="line">交换后：[沉默王三, 沉默王二, 沉默王四, 沉默王六, 沉默王五]</span><br></pre></td></tr></table></figure>
<p><strong>02、查找操作 </strong></p>
<ul>
<li>binarySearch(List list, Object key) ：二分查找法，前提是 List 已经排序过了</li>
<li>max(Collection coll) ：返回最大元素</li>
<li>max(Collection coll, Comparator comp) ：根据自定义比较器，返回最大元素</li>
<li>min(Collection coll) ：返回最小元素</li>
<li>min(Collection coll, Comparator comp) ：根据自定义比较器，返回最小元素</li>
<li>fill(List list, Object obj) ：使用指定对象填充</li>
<li>frequency(Collection c, Object o) ：返回指定对象出现的次数</li>
</ul>
<p>来看例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;最大元素：&quot; + Collections.max(list));</span><br><span class="line">System.out.println(&quot;最小元素：&quot; + Collections.min(list));</span><br><span class="line">System.out.println(&quot;出现的次数：&quot; + Collections.frequency(list, &quot;沉默王二&quot;));</span><br><span class="line">// 没有排序直接调用二分查找，结果是不确定的</span><br><span class="line">System.out.println(&quot;排序前的二分查找结果：&quot; + Collections.binarySearch(list, &quot;沉默王</span><br><span class="line">二&quot;));</span><br><span class="line">Collections.sort(list);</span><br><span class="line">// 排序后，查找结果和预期一致</span><br><span class="line">System.out.println(&quot;排序后的二分查找结果：&quot; + Collections.binarySearch(list, &quot;沉默王</span><br><span class="line">二&quot;));</span><br><span class="line">Collections.fill(list, &quot;沉默王八&quot;);</span><br><span class="line">System.out.println(&quot;填充后的结果：&quot; + list);</span><br></pre></td></tr></table></figure>
<p>输出后：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">原始顺序：[沉默王二, 沉默王三, 沉默王四, 沉默王五, 沉默王六]</span><br><span class="line">最大元素：沉默王四</span><br><span class="line">最小元素：沉默王三</span><br><span class="line">出现的次数：1</span><br><span class="line">排序前的二分查找结果：0</span><br><span class="line">排序后的二分查找结果：1</span><br><span class="line">填充后的结果：[沉默王八, 沉默王八, 沉默王八, 沉默王八, 沉默王八]</span><br></pre></td></tr></table></figure>
<p><strong>03、同步控制 </strong></p>
<p>HashMap 是线程不安全的，这个我们前面讲到了。那其实 ArrayList 也是线程不安全的，没法在多线程环境下使用，那 Collections 工具类中提供了多个 synchronizedXxx 方法，这些方法会返回一个同步的对象，从而解决多线程中访问集合时的安全问题。</p>
<p><img src="\assets\note\image-20231012145844347.png" alt="image-20231012145844347"></p>
<p>使用起来也非常的简单：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SynchronizedList synchronizedList = Collections.synchronizedList(list);</span><br></pre></td></tr></table></figure>
<p>看一眼 SynchronizedList 的源码就明白了，不过是在方法里面使用 synchronized 关键字加了一层锁而已。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">static class SynchronizedList&lt;E&gt;</span><br><span class="line">    extends SynchronizedCollection&lt;E&gt;</span><br><span class="line">    implements List&lt;E&gt; &#123;</span><br><span class="line">    private static final long serialVersionUID = -7754090372962971524L;</span><br><span class="line">    final List&lt;E&gt; list;</span><br><span class="line">    SynchronizedList(List&lt;E&gt; list) &#123;</span><br><span class="line">        super(list); // 调用父类 SynchronizedCollection 的构造方法，传入 list</span><br><span class="line">        this.list = list; // 初始化成员变量 list</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取指定索引处的元素</span><br><span class="line">    public E get(int index) &#123;</span><br><span class="line">        synchronized (mutex) &#123;return list.get(index);&#125; // 加锁，调用 list 的 get 方法获</span><br><span class="line">取元素</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 在指定索引处插入指定元素</span><br><span class="line">    public void add(int index, E element) &#123;</span><br><span class="line">        synchronized (mutex) &#123;list.add(index, element);&#125; // 加锁，调用 list 的 add 方法</span><br><span class="line">插入元素</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 移除指定索引处的元素</span><br><span class="line">    public E remove(int index) &#123;</span><br><span class="line">        synchronized (mutex) &#123;return list.remove(index);&#125; // 加锁，调用 list 的 remove </span><br><span class="line">方法移除元素</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那这样的话，其实效率和那些直接在方法上加 synchronized 关键字的 Vector、Hashtable 差不多（JDK 1.0 时期就有了），而这些集合类基本上已经废弃了，几乎不怎么用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Vector&lt;E&gt;</span><br><span class="line">    extends AbstractList&lt;E&gt;</span><br><span class="line">    implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    // 获取指定索引处的元素</span><br><span class="line">    public synchronized E get(int index) &#123;</span><br><span class="line">        if (index &gt;= elementCount) // 如果索引超出了列表的大小，则抛出数组下标越界异常</span><br><span class="line">            throw new ArrayIndexOutOfBoundsException(index);</span><br><span class="line">        return elementData(index); // 返回指定索引处的元素</span><br><span class="line">    &#125;</span><br><span class="line">    // 移除指定索引处的元素</span><br><span class="line">    public synchronized E remove(int index) &#123;</span><br><span class="line">        modCount++; // 修改计数器，标识列表已被修改</span><br><span class="line">        if (index &gt;= elementCount) // 如果索引超出了列表的大小，则抛出数组下标越界异常</span><br><span class="line">            throw new ArrayIndexOutOfBoundsException(index);</span><br><span class="line">        E oldValue = elementData(index); // 获取指定索引处的元素</span><br><span class="line">        int numMoved = elementCount - index - 1; // 计算需要移动的元素个数</span><br><span class="line">        if (numMoved &gt; 0) // 如果需要移动元素</span><br><span class="line">            System.arraycopy(elementData, index+1, elementData, index,numMoved); // 将数组中的元素向左移动一位</span><br><span class="line">        elementData[--elementCount] = null; // 将最后一个元素设置为 null，等待垃圾回收</span><br><span class="line">        return oldValue; // 返回被移除的元素</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正确的做法是使用并发包下的 CopyOnWriteArrayList、ConcurrentHashMap。这些我们放到并发编程时再讲。</p>
<p><strong>04、不可变集合 </strong></p>
<ul>
<li>emptyXxx() ：制造一个空的不可变集合</li>
<li>singletonXxx() ：制造一个只有一个元素的不可变集合</li>
<li>unmodifiableXxx() ：为指定集合制作一个不可变集合</li>
</ul>
<p>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List emptyList = Collections.emptyList();</span><br><span class="line">emptyList.add(&quot;非空&quot;);</span><br><span class="line">System.out.println(emptyList);</span><br></pre></td></tr></table></figure>
<p>这段代码在执行的时候就抛出错误了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException</span><br><span class="line">    at java.util.AbstractList.add(AbstractList.java:148)</span><br><span class="line">    at java.util.AbstractList.add(AbstractList.java:108)</span><br><span class="line">    at com.itwanger.s64.Demo.main(Demo.java:61)</span><br></pre></td></tr></table></figure>
<p>这是因为 Collections.emptyList() 会返回一个 Collections 的内部类 EmptyList，而 EmptyList 并没有重写父类 AbstractList 的 add(int index, E element) 方法，所以执行的时候就抛出了不支持该操作的 UnsupportedOperationException 了。</p>
<p>这是从分析 add 方法源码得出的原因。除此之外，emptyList 方法是 final 的，返回的 EMPTY_LIST 也是 final 的，种种迹象表明 emptyList 返回的就是不可变对象，没法进行增伤改查。     </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static final &lt;T&gt; List&lt;T&gt; emptyList() &#123;</span><br><span class="line">    return (List&lt;T&gt;) EMPTY_LIST;</span><br><span class="line">&#125;</span><br><span class="line">public static final List EMPTY_LIST = new EmptyList&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p><strong>05、其他 </strong></p>
<p>还有两个方法比较常用：</p>
<ul>
<li>addAll(Collection&lt;? super T&gt; c, T… elements) ，往集合中添加元素</li>
<li>disjoint(Collection&lt;?&gt; c1, Collection&lt;?&gt; c2) ，判断两个集合是否没有交集</li>
</ul>
<p>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; allList = new ArrayList&lt;&gt;();</span><br><span class="line">Collections.addAll(allList, &quot;沉默王九&quot;,&quot;沉默王十&quot;,&quot;沉默王二&quot;);</span><br><span class="line">System.out.println(&quot;addAll 后：&quot; + allList);</span><br><span class="line">System.out.println(&quot;是否没有交集：&quot; + (Collections.disjoint(list, allList) ? &quot;是&quot; : &quot;否&quot;));</span><br></pre></td></tr></table></figure>
<p>输出后：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原始顺序：[沉默王二, 沉默王三, 沉默王四, 沉默王五, 沉默王六]</span><br><span class="line">addAll 后：[沉默王九, 沉默王十, 沉默王二]</span><br><span class="line">是否没有交集：否</span><br></pre></td></tr></table></figure>
<p><strong>06、CollectionUtils：Spring 和 Apache 都有提供的集合工具类 </strong></p>
<p>对集合操作，除了前面说的 JDK 原生 Collections 工具类， CollectionUtils工具类也很常用。</p>
<p>目前比较主流的是 Spring的 org.springframework.util包下的 CollectionUtils 工具类。</p>
<p><img src="\assets\note\image-20231012150329100.png" alt="image-20231012150329100"></p>
<p>和 Apache的 org.apache.commons.collections包下的 CollectionUtils 工具类。</p>
<p><img src="\assets\note\image-20231012150348343.png" alt="image-20231012150348343"></p>
<p>Maven 坐标如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-collections4&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.4&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>Apache 的方法比 Spring 的更多一些，我们就以 Apache 的为例，来介绍一下常用的方法。</p>
<p><strong>集合判空 </strong></p>
<p>通过 CollectionUtils 工具类的 isEmpty方法可以轻松判断集合是否为空， isNotEmpty方法判断集合不为空。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list.add(2);</span><br><span class="line">list.add(1);</span><br><span class="line">list.add(3);</span><br><span class="line">if (CollectionUtils.isEmpty(list)) &#123;</span><br><span class="line">    System.out.println(&quot;集合为空&quot;);</span><br><span class="line">&#125;</span><br><span class="line">if (CollectionUtils.isNotEmpty(list)) &#123;</span><br><span class="line">    System.out.println(&quot;集合不为空&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>对两个集合进行操作 </strong></p>
<p>有时候我们需要对已有的两个集合进行操作，比如取交集或者并集等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list.add(2);</span><br><span class="line">list.add(1);</span><br><span class="line">list.add(3);</span><br><span class="line">List&lt;Integer&gt; list2 = new ArrayList&lt;&gt;();</span><br><span class="line">list2.add(2);</span><br><span class="line">list2.add(4);</span><br><span class="line">//获取并集</span><br><span class="line">Collection&lt;Integer&gt; unionList = CollectionUtils.union(list, list2);</span><br><span class="line">System.out.println(unionList);</span><br><span class="line">//获取交集</span><br><span class="line">Collection&lt;Integer&gt; intersectionList = CollectionUtils.intersection(list, list2);</span><br><span class="line">System.out.println(intersectionList);</span><br><span class="line">//获取交集的补集</span><br><span class="line">Collection&lt;Integer&gt; disjunctionList = CollectionUtils.disjunction(list, list2);</span><br><span class="line">System.out.println(disjunctionList);</span><br><span class="line">//获取差集</span><br><span class="line">Collection&lt;Integer&gt; subtractList = CollectionUtils.subtract(list, list2);</span><br><span class="line">System.out.println(subtractList);</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4]</span><br><span class="line">[2]</span><br><span class="line">[1, 3, 4]</span><br><span class="line">[1, 3]</span><br></pre></td></tr></table></figure>
<p>说句实话，对两个集合的操作，在实际工作中用得挺多的，特别是很多批量的场景中。以前我们需要写一堆代码，但没想到有现成的轮子。</p>
<p><strong>07、小结 </strong></p>
<p>整体上，Collections 工具类作为集合框架的大管家，提供了一些非常便利的方法供我们调用，也非常容易掌握，没什么难点，看看方法的注释就能大致明白干嘛的。</p>
<p>不过，工具就放在那里，用是一回事，为什么要这么用就是另外一回事了。能不能提高自己的编码水平，很大程度上取决于你到底有没有去钻一钻源码，看这些设计 JDK 的大师们是如何写代码的，学会一招半式，在工作当中还是能很快脱颖而出的。</p>
<p>恐怕 JDK 的设计者是这个世界上最好的老师了，文档写得不能再详细了，代码写得不能再优雅了，基本上都达到了性能上的极致。</p>
<p>可能有人会说，工具类没什么鸟用，不过是调用下方法而已，但这就大错特错了：如果要你来写，你能写出来 Collections 这样一个工具类吗？</p>
<p>这才是高手要思考的一个问题。</p>
<h2 id="7-6-Hutool工具类库"><a href="#7-6-Hutool工具类库" class="headerlink" title="7.6 Hutool工具类库"></a>7.6 Hutool工具类库</h2><p>读者群里有个小伙伴感慨说，“Hutool 这款开源类库太厉害了，基本上该有该的工具类，它里面都有。”讲真的，我平常工作中也经常用 Hutool，它确实可以帮助我们简化每一行代码，使 Java 拥有函数式语言般的优雅，让 Java 语言变得“甜甜的”。</p>
<p>Hutool 的作者在官网上说，Hutool 是 Hu+tool 的自造词（好像不用说，我们也能猜得到），“Hu”用来致敬他的“前任”公司，“tool”就是工具的意思，谐音就有意思了，“糊涂”，寓意追求“万事都作糊涂观，无所谓失，无所谓得”（一个开源类库，上升到了哲学的高度，作者厉害了）。</p>
<p>看了一下开发团队的一个成员介绍，一个 Java 后端工具的作者竟然爱前端、爱数码，爱美女，嗯嗯嗯，确实“难得糊涂”（手动狗头）。</p>
<p>废话就说到这，来吧，实操走起！</p>
<p><strong>01、引入 Hutool </strong></p>
<p>Maven 项目只需要在 pom.xml 文件中添加以下依赖即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;cn.hutool&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;hutool-all&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.4.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>Hutool 的设计思想是尽量减少重复的定义，让项目中的 util 包尽量少。一个好的轮子可以在很大程度上避免“复制粘贴”，从而节省我们开发人员对项目中公用类库和公用工具方法的封装时间。同时呢，成熟的开源库也可以最大限度的避免封装不完善带来的 bug。</p>
<p>就像作者在官网上说的那样：</p>
<ul>
<li>以前，我们打开搜索引擎 -&gt; 搜“Java MD5 加密” -&gt; 打开某篇博客 -&gt; 复制粘贴 -&gt; 改改，变得好用些</li>
<li>有了 Hutool 以后呢，引入 Hutool -&gt; 直接 SecureUtil.md5()</li>
</ul>
<p>Hutool 对不仅对 JDK 底层的文件、流、加密解密、转码、正则、线程、XML等做了封装，还提供了以下这些组件：</p>
<p><img src="\assets\note\image-20231012150800077.png" alt="image-20231012150800077"></p>
<p>非常多，非常全面，鉴于此，我只挑选一些我喜欢的来介绍下（偷偷地告诉你，我就是想偷懒）。</p>
<p><strong>02、类型转换 </strong></p>
<p>类型转换在 Java 开发中很常见，尤其是从 HttpRequest 中获取参数的时候，前端传递的是整型，但后端只能先获取到字符串，然后再调用 parseXXX() 方法进行转换，还要加上判空，很繁琐。</p>
<p>Hutool 的 Convert 类可以简化这个操作，可以将任意可能的类型转换为指定类型，同时第二个参数 defaultValue 可用于在转换失败时返回一个默认值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String param = &quot;10&quot;;</span><br><span class="line">int paramInt = Convert.toInt(param);</span><br><span class="line">int paramIntDefault = Convert.toInt(param, 0);</span><br></pre></td></tr></table></figure>
<p>把字符串转换成日期：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String dateStr = &quot;2020年09月29日&quot;;</span><br><span class="line">Date date = Convert.toDate(dateStr);</span><br></pre></td></tr></table></figure>
<p>把字符串转成 Unicode：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String unicodeStr = &quot;沉默王二&quot;;</span><br><span class="line">String unicode = Convert.strToUnicode(unicodeStr);</span><br></pre></td></tr></table></figure>
<p><strong>03、日期时间 </strong></p>
<p>JDK 自带的 Date 和 Calendar 不太好用，Hutool 封装的 DateUtil 用起来就舒服多了！</p>
<p>获取当前日期：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date date = DateUtil.date();</span><br></pre></td></tr></table></figure>
<p>DateUtil.date() 返回的其实是 DateTime，它继承自 Date 对象，重写了 toString() 方法，返回 yyyy-MM-dd HH:mm:ss 格式的字符串。</p>
<p>有些小伙伴是不是想看看我写这篇文章的时间，输出一下给大家看看：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(date);// 2020-09-29 04:28:02</span><br></pre></td></tr></table></figure>
<p>字符串转日期：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String dateStr = &quot;2020-09-29&quot;;</span><br><span class="line">Date date = DateUtil.parse(dateStr);</span><br></pre></td></tr></table></figure>
<p>DateUtil.parse() 会自动识别一些常用的格式，比如说：</p>
<ul>
<li>yyyy-MM-dd HH:mm:ss</li>
<li>yyyy-MM-dd</li>
<li>HH:mm:ss</li>
<li>yyyy-MM-dd HH:mm</li>
<li>yyyy-MM-dd HH:mm:ss.SSS</li>
</ul>
<p>还可以识别带中文的：</p>
<ul>
<li>年月日时分秒</li>
</ul>
<p>格式化时间差：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String dateStr1 = &quot;2020-09-29 22:33:23&quot;;</span><br><span class="line">Date date1 = DateUtil.parse(dateStr1);</span><br><span class="line">String dateStr2 = &quot;2020-10-01 23:34:27&quot;;</span><br><span class="line">Date date2 = DateUtil.parse(dateStr2);</span><br><span class="line">long betweenDay = DateUtil.between(date1, date2, DateUnit.MS);</span><br><span class="line">// 输出：2天1小时1分4秒</span><br><span class="line">String formatBetween = DateUtil.formatBetween(betweenDay, </span><br><span class="line">BetweenFormater.Level.SECOND);</span><br></pre></td></tr></table></figure>
<p>星座和属相：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 射手座</span><br><span class="line">String zodiac = DateUtil.getZodiac(Month.DECEMBER.getValue(), 10);</span><br><span class="line">// 蛇</span><br><span class="line">String chineseZodiac = DateUtil.getChineseZodiac(1989);</span><br></pre></td></tr></table></figure>
<p><strong>04、IO 流相关 </strong></p>
<p>IO 操作包括读和写，应用的场景主要包括网络操作和文件操作，原生的 Java 类库区分字符流和字节流，字节流 InputStream 和 OutputStream 就有很多很多种，使用起来让人头皮发麻。</p>
<p>Hutool 封装了流操作工具类 IoUtil、文件读写操作工具类 FileUtil、文件类型判断工具类 FileTypeUtil 等等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BufferedInputStream in = FileUtil.getInputStream(&quot;hutool/origin.txt&quot;);</span><br><span class="line">BufferedOutputStream out = FileUtil.getOutputStream(&quot;hutool/to.txt&quot;);</span><br><span class="line">long copySize = IoUtil.copy(in, out, IoUtil.DEFAULT_BUFFER_SIZE);</span><br></pre></td></tr></table></figure>
<p>在 IO 操作中，文件的操作相对来说是比较复杂的，但使用频率也很高，几乎所有的项目中都躺着一个叫 FileUtil 或者 FileUtils 的工具类。Hutool 的 FileUtil 类包含以下几类操作：</p>
<ul>
<li>文件操作：包括文件目录的新建、删除、复制、移动、改名等</li>
<li>文件判断：判断文件或目录是否非空，是否为目录，是否为文件等等</li>
<li>绝对路径：针对 ClassPath 中的文件转换为绝对路径文件</li>
<li>文件名：主文件名，扩展名的获取</li>
<li>读操作：包括 getReader、readXXX 操作</li>
<li>写操作：包括 getWriter、writeXXX 操作</li>
</ul>
<p>顺带说说 classpath。</p>
<p>在实际编码当中，我们通常需要从某些文件里面读取一些数据，比如配置文件、文本文件、图片等等，那这些文件通常放在什么位置呢？</p>
<p><img src="\assets\note\image-20231012151243271.png" alt="image-20231012151243271"></p>
<p>放在项目结构图中的 resources 目录下，当项目编译后，会出现在 classes 目录下。对应磁盘上的目录如下图所示：</p>
<p><img src="\assets\note\image-20231012151304232.png" alt="image-20231012151304232"></p>
<p>当我们要读取文件的时候，我是不建议使用绝对路径的，因为操作系统不一样的话，文件的路径标识符也是不一样的。最好使用相对路径。</p>
<p>假设在 src/resources 下放了一个文件 origin.txt，文件的路径参数如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileUtil.getInputStream(&quot;origin.txt&quot;)</span><br></pre></td></tr></table></figure>
<p>假设文件放在 src/resources/hutool 目录下，则路径参数改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileUtil.getInputStream(&quot;hutool/origin.txt&quot;)</span><br></pre></td></tr></table></figure>
<p><strong>05、字符串工具 </strong></p>
<p>Hutool 封装的字符串工具类 StrUtil 和 Apache Commons Lang 包中的 StringUtils 类似，作者认为优势在于 Str 比 String 短，尽管我不觉得。不过，我倒是挺喜欢其中的一个方法的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String template = &quot;&#123;&#125;，一枚沉默但有趣的程序员，喜欢他的文章的话，请微信搜索&#123;&#125;&quot;;</span><br><span class="line">String str = StrUtil.format(template, &quot;沉默王二&quot;, &quot;沉默王二&quot;);</span><br><span class="line">// 沉默王二，一枚沉默但有趣的程序员，喜欢他的文章的话，请微信搜索沉默王二</span><br></pre></td></tr></table></figure>
<p><strong>06、反射工具 </strong></p>
<p>反射机制可以让 Java 变得更加灵活，因此在某些情况下，反射可以做到事半功倍的效果。Hutool 封装的反射工具 ReflectUtil 包括：</p>
<ul>
<li>获取构造方法</li>
<li>获取字段</li>
<li>获取字段值</li>
<li>获取方法</li>
<li>执行方法（对象方法和静态方法）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package com.itwanger.hutool.reflect;</span><br><span class="line">import cn.hutool.core.util.ReflectUtil;</span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">public class ReflectDemo &#123;</span><br><span class="line">    private int id;</span><br><span class="line">    public ReflectDemo() &#123;</span><br><span class="line">        System.out.println(&quot;构造方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void print() &#123;</span><br><span class="line">        System.out.println(&quot;我是沉默王二&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws IllegalAccessException &#123;</span><br><span class="line">        // 构建对象</span><br><span class="line">        ReflectDemo reflectDemo = ReflectUtil.newInstance(ReflectDemo.class);</span><br><span class="line">        // 获取构造方法</span><br><span class="line">        Constructor[] constructors = ReflectUtil.getConstructors(ReflectDemo.class);</span><br><span class="line">        for (Constructor constructor : constructors) &#123;</span><br><span class="line">            System.out.println(constructor.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        // 获取字段</span><br><span class="line">        Field field = ReflectUtil.getField(ReflectDemo.class, &quot;id&quot;);</span><br><span class="line">        field.setInt(reflectDemo, 10);</span><br><span class="line">        // 获取字段值</span><br><span class="line">        System.out.println(ReflectUtil.getFieldValue(reflectDemo, field));</span><br><span class="line">        // 获取所有方法</span><br><span class="line">        Method[] methods = ReflectUtil.getMethods(ReflectDemo.class);</span><br><span class="line">        for (Method m : methods) &#123;</span><br><span class="line">            System.out.println(m.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        // 获取指定方法</span><br><span class="line">        Method method = ReflectUtil.getMethod(ReflectDemo.class, &quot;print&quot;);</span><br><span class="line">        System.out.println(method.getName());</span><br><span class="line">        // 执行方法</span><br><span class="line">        ReflectUtil.invoke(reflectDemo, &quot;print&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>07、压缩工具 </strong></p>
<p>在 Java 中，对文件、文件夹打包压缩是一件很繁琐的事情，Hutool 封装的 ZipUtil 针对 java.util.zip 包做了优化，可以使用一个方法搞定压缩和解压，并且自动处理文件和目录的问题，不再需要用户判断，大大简化的压缩解压的复杂度。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZipUtil.zip(&quot;hutool&quot;, &quot;hutool.zip&quot;);</span><br><span class="line">File unzip = ZipUtil.unzip(&quot;hutool.zip&quot;, &quot;hutoolzip&quot;);</span><br></pre></td></tr></table></figure>
<p><strong>08、身份证工具 </strong></p>
<p>Hutool 封装的 IdcardUtil 可以用来对身份证进行验证，支持大陆 15 位、18 位身份证，港澳台 10 位身份证。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String ID_18 = &quot;321083197812162119&quot;;</span><br><span class="line">String ID_15 = &quot;150102880730303&quot;;</span><br><span class="line">boolean valid = IdcardUtil.isValidCard(ID_18);</span><br><span class="line">boolean valid15 = IdcardUtil.isValidCard(ID_15);</span><br></pre></td></tr></table></figure>
<p><strong>09、扩展 HashMap </strong></p>
<p>Java 中的 HashMap 是强类型的，而 Hutool 封装的 Dict 对键的类型要求没那么严格。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Dict dict = Dict.create()</span><br><span class="line">        .set(&quot;age&quot;, 18)</span><br><span class="line">        .set(&quot;name&quot;, &quot;沉默王二&quot;)</span><br><span class="line">        .set(&quot;birthday&quot;, DateTime.now());</span><br><span class="line">int age = dict.getInt(&quot;age&quot;);</span><br><span class="line">String name = dict.getStr(&quot;name&quot;);</span><br></pre></td></tr></table></figure>
<p><strong>10、控制台打印 </strong></p>
<p>本地编码的过程中，经常需要使用 System.out 打印结果，但是往往一些复杂的对象不支持直接打印，比如说数组，需要调用 Arrays.toString 。Hutool 封装的 Console 类借鉴了 JavaScript 中的 console.log() ，使得打印变成了一个非常便捷的方式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class ConsoleDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 打印字符串</span><br><span class="line">        Console.log(&quot;沉默王二，一枚有趣的程序员&quot;);</span><br><span class="line">        // 打印字符串模板</span><br><span class="line">        Console.log(&quot;洛阳是&#123;&#125;朝古都&quot;,13);</span><br><span class="line">        int [] ints = &#123;1,2,3,4&#125;;</span><br><span class="line">        // 打印数组</span><br><span class="line">        Console.log(ints);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>11、字段验证器 </strong></p>
<p>做 Web 开发的时候，后端通常需要对表单提交过来的数据进行验证。Hutool 封装的 Validator 可以进行很多有效的条件验证：</p>
<ul>
<li>是不是邮箱</li>
<li>是不是 IP V4、V6</li>
<li>是不是电话号码</li>
<li>等等</li>
</ul>
<p><img src="\assets\note\image-20231012151731368.png" alt="image-20231012151731368"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Validator.isEmail(&quot;沉默王二&quot;);</span><br><span class="line">Validator.isMobile(&quot;itwanger.com&quot;);</span><br></pre></td></tr></table></figure>
<p><strong>12、双向查找 Map </strong></p>
<p>Guava 中提供了一种特殊的 Map 结构，叫做 BiMap，实现了一种双向查找的功能，可以根据 key 查找 value，也可以根据 value 查找 key，Hutool 也提供这种 Map 结构。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BiMap&lt;String, String&gt; biMap = new BiMap&lt;&gt;(new HashMap&lt;&gt;());</span><br><span class="line">biMap.put(&quot;wanger&quot;, &quot;沉默王二&quot;);</span><br><span class="line">biMap.put(&quot;wangsan&quot;, &quot;沉默王三&quot;);</span><br><span class="line">// get value by key</span><br><span class="line">biMap.get(&quot;wanger&quot;);</span><br><span class="line">biMap.get(&quot;wangsan&quot;);</span><br><span class="line">// get key by value</span><br><span class="line">biMap.getKey(&quot;沉默王二&quot;);</span><br><span class="line">biMap.getKey(&quot;沉默王三&quot;);</span><br></pre></td></tr></table></figure>
<p>在实际的开发工作中，其实我更倾向于使用 Guava 的 BiMap，而不是 Hutool 的。这里提一下，主要是我发现了 Hutool 在线文档上的一处错误，提了个 issue（从中可以看出我一颗一丝不苟的心和一双清澈明亮的大眼睛啊）。</p>
<p><img src="\assets\note\image-20231012151845639.png" alt="image-20231012151845639"></p>
<p><strong>13、图片工具 </strong></p>
<p>Hutool 封装的 ImgUtil 可以对图片进行缩放、裁剪、转为黑白、加水印等操作。</p>
<p>缩放图片：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ImgUtil.scale(</span><br><span class="line">        FileUtil.file(&quot;hutool/wangsan.jpg&quot;),</span><br><span class="line">        FileUtil.file(&quot;hutool/wangsan_small.jpg&quot;),</span><br><span class="line">        0.5f</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>裁剪图片：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ImgUtil.cut(</span><br><span class="line">        FileUtil.file(&quot;hutool/wangsan.jpg&quot;),</span><br><span class="line">        FileUtil.file(&quot;hutool/wangsan_cut.jpg&quot;),</span><br><span class="line">        new Rectangle(200, 200, 100, 100)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>添加水印：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ImgUtil.pressText(//</span><br><span class="line">        FileUtil.file(&quot;hutool/wangsan.jpg&quot;),</span><br><span class="line">        FileUtil.file(&quot;hutool/wangsan_logo.jpg&quot;),</span><br><span class="line">        &quot;沉默王二&quot;, Color.WHITE,</span><br><span class="line">        new Font(&quot;黑体&quot;, Font.BOLD, 100),</span><br><span class="line">        0,</span><br><span class="line">        0,</span><br><span class="line">        0.8f</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><strong>14、配置文件 </strong></p>
<blockquote>
<p>众所周知，Java 中广泛应用的配置文件 Properties 存在一个特别大的诟病：不支持中文。每次使用时，如果想存放中文字符，就必须借助 IDE 相关插件才能转为 Unicode 符号，而这种反人类的符号在命令行下根本没法看。</p>
</blockquote>
<p>于是，Hutool 的 Setting 运用而生。Setting 除了兼容 Properties 文件格式外，还提供了一些特有功能，这些功能包括：</p>
<ul>
<li>各种编码方式支持</li>
<li>变量支持</li>
<li>分组支持</li>
</ul>
<p>先整个配置文件 example.setting，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name=沉默王二</span><br><span class="line">age=18</span><br></pre></td></tr></table></figure>
<p>再来读取和更新配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class SettingDemo &#123;</span><br><span class="line">    private final static String SETTING = &quot;hutool/example.setting&quot;;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 初始化 Setting</span><br><span class="line">        Setting setting = new Setting(SETTING);</span><br><span class="line">        // 读取</span><br><span class="line">        setting.getStr(&quot;name&quot;, &quot;沉默王二&quot;);</span><br><span class="line">        // 在配置文件变更时自动加载</span><br><span class="line">        setting.autoLoad(true);</span><br><span class="line">        // 通过代码方式增加键值对</span><br><span class="line">        setting.set(&quot;birthday&quot;, &quot;2020年09月29日&quot;);</span><br><span class="line">        setting.store(SETTING);</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
<p><strong>15、日志工厂 </strong></p>
<p>Hutool 封装的日志工厂 LogFactory 兼容了各大日志框架，使用起来也非常简便。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class LogDemo &#123;</span><br><span class="line">    private static final Log log = LogFactory.get();</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        log.debug(&quot;难得糊涂&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先通过 LogFactory.get() 自动识别引入的日志框架，从而创建对应日志框架的门面 Log 对象，然后调用 debug() 、 info() 等方法输出日志。</p>
<p>如果不想创建 Log 对象的话，可以使用 StaticLog，顾名思义，一个提供了静态方法的日志类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StaticLog.info(&quot;爽啊 &#123;&#125;.&quot;, &quot;沉默王二的文章&quot;);</span><br></pre></td></tr></table></figure>
<p><strong>16、缓存工具 </strong></p>
<p>CacheUtil 是 Hutool 封装的创建缓存的快捷工具类，可以创建不同的缓存对象：</p>
<ul>
<li>FIFOCache：先入先出，元素不停的加入缓存直到缓存满为止，当缓存满时，清理过期缓存对象，清理后依旧满则删除先入的缓存。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Cache&lt;String, String&gt; fifoCache = CacheUtil.newFIFOCache(3);</span><br><span class="line">fifoCache.put(&quot;key1&quot;, &quot;沉默王一&quot;);</span><br><span class="line">fifoCache.put(&quot;key2&quot;, &quot;沉默王二&quot;);</span><br><span class="line">fifoCache.put(&quot;key3&quot;, &quot;沉默王三&quot;);</span><br><span class="line">fifoCache.put(&quot;key4&quot;, &quot;沉默王四&quot;);</span><br><span class="line">// 大小为 3，所以 key3 放入后 key1 被清除</span><br><span class="line">String value1 = fifoCache.get(&quot;key1&quot;);</span><br></pre></td></tr></table></figure>
<ul>
<li>LFUCache，最少使用，根据使用次数来判定对象是否被持续缓存，当缓存满时清理过期对象，清理后依旧满的情况下清除最少访问的对象并将其他对象的访问数减去这个最少访问数，以便新对象进入后可以公平计数。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Cache&lt;String, String&gt; lfuCache = CacheUtil.newLFUCache(3);</span><br><span class="line">lfuCache.put(&quot;key1&quot;, &quot;沉默王一&quot;);</span><br><span class="line">// 使用次数+1</span><br><span class="line">lfuCache.get(&quot;key1&quot;);</span><br><span class="line">lfuCache.put(&quot;key2&quot;, &quot;沉默王二&quot;);</span><br><span class="line">lfuCache.put(&quot;key3&quot;, &quot;沉默王三&quot;);</span><br><span class="line">lfuCache.put(&quot;key4&quot;, &quot;沉默王四&quot;);</span><br><span class="line">// 由于缓存容量只有 3，当加入第 4 个元素的时候，最少使用的将被移除（2,3被移除）</span><br><span class="line">String value2 = lfuCache.get(&quot;key2&quot;);</span><br><span class="line">String value3 = lfuCache.get(&quot;key3&quot;);</span><br></pre></td></tr></table></figure>
<ul>
<li>LRUCache，最近最久未使用，根据使用时间来判定对象是否被持续缓存，当对象被访问时放入缓存，当缓存满了，最久未被使用的对象将被移除。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Cache&lt;String, String&gt; lruCache = CacheUtil.newLRUCache(3);</span><br><span class="line">lruCache.put(&quot;key1&quot;, &quot;沉默王一&quot;);</span><br><span class="line">lruCache.put(&quot;key2&quot;, &quot;沉默王二&quot;);</span><br><span class="line">lruCache.put(&quot;key3&quot;, &quot;沉默王三&quot;);</span><br><span class="line">// 使用时间近了</span><br><span class="line">lruCache.get(&quot;key1&quot;);</span><br><span class="line">lruCache.put(&quot;key4&quot;, &quot;沉默王四&quot;);</span><br><span class="line">// 由于缓存容量只有 3，当加入第 4 个元素的时候，最久使用的将被移除（2）</span><br><span class="line">String value2 = lruCache.get(&quot;key2&quot;);</span><br><span class="line">System.out.println(value2);</span><br></pre></td></tr></table></figure>
<p><strong>17、加密解密 </strong></p>
<p>加密分为三种：</p>
<ul>
<li>对称加密（symmetric），例如：AES、DES 等</li>
<li>非对称加密（asymmetric），例如：RSA、DSA 等</li>
<li>摘要加密（digest），例如：MD5、SHA-1、SHA-256、HMAC 等</li>
</ul>
<p>Hutool 针对这三种情况都做了封装：</p>
<ul>
<li>对称加密 SymmetricCrypto</li>
<li>非对称加密 AsymmetricCrypto</li>
<li>摘要加密 Digester</li>
</ul>
<p>快速加密工具类 SecureUtil 有以下这些方法：</p>
<p>1）对称加密</p>
<ul>
<li>SecureUtil.aes</li>
<li>SecureUtil.des</li>
</ul>
<p>2）非对称加密</p>
<ul>
<li>SecureUtil.rsa</li>
<li>SecureUtil.dsa</li>
</ul>
<p>3）摘要加密</p>
<ul>
<li>SecureUtil.md5</li>
<li>SecureUtil.sha1</li>
<li>SecureUtil.hmac</li>
<li>SecureUtil.hmacMd5</li>
<li>SecureUtil.hmacSha1</li>
</ul>
<p>只写一个简单的例子作为参考：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class SecureUtilDemo &#123;</span><br><span class="line">    static AES aes = SecureUtil.aes();</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String encry = aes.encryptHex(&quot;沉默王二&quot;);</span><br><span class="line">        System.out.println(encry);</span><br><span class="line">        String oo = aes.decryptStr(encry);</span><br><span class="line">        System.out.println(oo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>18、其他类库 </strong></p>
<p>Hutool 中的类库还有很多，尤其是一些对第三方类库的进一步封装，比如邮件工具 MailUtil，二维码工具 QrCodeUtil，Emoji 工具 EmojiUtil，小伙伴们可以参考 Hutool 的官方文档：<a target="_blank" rel="noopener" href="https://www.hutool.cn/">https://www.hutool.cn/</a></p>
<p>项目源码地址：<a target="_blank" rel="noopener" href="https://github.com/looly/hutool">https://github.com/looly/hutool</a></p>
<h2 id="7-7-Guava工具库"><a href="#7-7-Guava工具库" class="headerlink" title="7.7 Guava工具库"></a>7.7 Guava工具库</h2><p><strong>01、前世今生 </strong></p>
<p>你好呀，我是 Guava。</p>
<p>我由 Google 公司开源，目前在 GitHub 上已经有 39.9k 的铁粉了，由此可以证明我的受欢迎程度。</p>
<p><img src="\assets\note\image-20231012152604524.png" alt="image-20231012152604524"></p>
<p>我的身体里主要包含有这些常用的模块：集合 [collections] 、缓存 [caching] 、原生类型支持 [primitives support] 、并发库 [concurrency libraries] 、通用注解 [common annotations] 、字符串处理 [string processing] 、I/O 等。新版的 JDK 中已经直接把我引入了，可想而知我有多优秀，忍不住骄傲了。</p>
<p>这么说吧，学好如何使用我，能让你在编程中变得更快乐，写出更优雅的代码！</p>
<p><strong>02、引入 Guava </strong></p>
<p>如果你要在 Maven 项目使用我的话，需要先在 pom.xml 文件中引入我的依赖。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.google.guava&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;guava&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;30.1-jre&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>一点要求，JDK 版本需要在 8 以上。</p>
<p><strong>03、基本工具 </strong></p>
<p>Doug Lea，java.util.concurrent 包的作者，曾说过一句话：“null 真糟糕”。Tony Hoare，图灵奖得主、快速排序算法的作者，当然也是 null 的创建者，也曾说过类似的话：“null 的使用，让我损失了十亿美元。”鉴于此，我用 Optional 来表示可能为 null 的对象。</p>
<p><img src="\assets\note\image-20231012152712235.png" alt="image-20231012152712235"></p>
<p>代码示例如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Integer&gt; possible = Optional.of(5);</span><br><span class="line">possible.isPresent(); // returns true</span><br><span class="line">possible.get(); // returns 5</span><br></pre></td></tr></table></figure>
<p>我大哥 Java 在 JDK 8 中新增了 Optional 类，显然是从我这借鉴过去的，不过他的和我的有些不同。</p>
<ul>
<li>我的 Optional 是 abstract 的，意味着我可以有子类对象；我大哥的是 final 的，意味着没有子类对象。</li>
<li>我的 Optional 实现了 Serializable 接口，可以序列化；我大哥的没有。</li>
<li>我的一些方法和我大哥的也不尽相同。</li>
</ul>
<p>使用 Optional 除了赋予 null 语义，增加了可读性，最大的优点在于它是一种傻瓜式的防护。Optional 迫使你积极思考引用缺失的情况，因为你必须显式地从 Optional 获取引用。</p>
<p>除了 Optional 之外，我还提供了：</p>
<ul>
<li>参数校验</li>
<li>常见的 Object 方法，比如说 Objects.equals、Objects.hashCode，JDK 7 引入的 Objects 类提供同样的方法，当然也是从我这借鉴的灵感。</li>
<li>更强大的比较器</li>
</ul>
<p><strong>04、集合 </strong></p>
<p>首先我来说一下，为什么需要不可变集合。</p>
<ul>
<li>保证线程安全。在并发程序中，使用不可变集合既保证线程的安全性，也大大地增强了并发时的效率（跟并发锁方式相比）。</li>
<li>如果一个对象不需要支持修改操作，不可变的集合将会节省空间和时间的开销。</li>
<li>可以当作一个常量来对待，并且集合中的对象在以后也不会被改变。</li>
</ul>
<p>与 JDK 中提供的不可变集合相比，我提供的 Immutable 才是真正的不可变，我为什么这么说呢？来看下面这个示例。</p>
<p>下面的代码利用 JDK 的 Collections.unmodifiableList(list) 得到一个不可修改的集合 unmodifiableList。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List list = new ArrayList();</span><br><span class="line">list.add(&quot;雷军&quot;);</span><br><span class="line">list.add(&quot;乔布斯&quot;);</span><br><span class="line">List unmodifiableList = Collections.unmodifiableList(list);</span><br><span class="line">unmodifiableList.add(&quot;马云&quot;);</span><br></pre></td></tr></table></figure>
<p>运行代码将会出现以下异常：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException</span><br><span class="line">    at </span><br><span class="line">java.base/java.util.Collections$UnmodifiableCollection.add(Collections.java:1060)</span><br><span class="line">    at com.itwanger.guava.NullTest.main(NullTest.java:29)</span><br></pre></td></tr></table></figure>
<p>很好，执行 unmodifiableList.add() 的时候抛出了 UnsupportedOperationException 异常，说明 Collections.unmodifiableList() 返回了一个不可变集合。但真的是这样吗？</p>
<p>你可以把 unmodifiableList.add() 换成 list.add() 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List list = new ArrayList();</span><br><span class="line">list.add(&quot;雷军&quot;);</span><br><span class="line">list.add(&quot;乔布斯&quot;);</span><br><span class="line">List unmodifiableList = Collections.unmodifiableList(list);</span><br><span class="line">list.add(&quot;马云&quot;);</span><br></pre></td></tr></table></figure>
<p>再次执行的话，程序并没有报错，并且你会发现 unmodifiableList 中真的多了一个元素。说明什么呢？</p>
<p>Collections.unmodifiableList(…) 实现的不是真正的不可变集合，当原始集合被修改后，不可变集合里面的元素也是跟着发生变化。</p>
<p>我就不会犯这种错，来看下面的代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringArrayList = Lists.newArrayList(&quot;雷军&quot;,&quot;乔布斯&quot;);</span><br><span class="line">ImmutableList&lt;String&gt; immutableList = ImmutableList.copyOf(stringArrayList);</span><br><span class="line">immutableList.add(&quot;马云&quot;);</span><br></pre></td></tr></table></figure>
<p>尝试 immutableList.add() 的时候会抛出 UnsupportedOperationException 。我在源码中已经把 add() 方法废弃了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * Guaranteed to throw an exception and leave the collection unmodified.</span><br><span class="line">  *</span><br><span class="line">  * @throws UnsupportedOperationException always</span><br><span class="line">  * @deprecated Unsupported operation.</span><br><span class="line">  */</span><br><span class="line">@CanIgnoreReturnValue</span><br><span class="line">@Deprecated</span><br><span class="line">@Override</span><br><span class="line">public final boolean add(E e) &#123;</span><br><span class="line">  throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尝试 stringArrayList.add() 修改原集合的时候 immutableList 并不会因此而发生改变。</p>
<p>除了不可变集合以外，我还提供了新的集合类型，比如说：</p>
<ul>
<li>Multiset，可以多次添加相等的元素。当把 Multiset 看成普通的 Collection 时，它表现得就像无序的 </li>
<li>ArrayList；当把 Multiset 看作 Map<E, Integer> 时，它也提供了符合性能期望的查询操作。</li>
<li>Multimap，可以很容易地把一个键映射到多个值。</li>
<li>BiMap，一种特殊的 Map，可以用 inverse() 反转，BiMap<K, V> 的键值映射；保证值是唯一的，因此 values() 返回 Set 而不是普通的 Collection。</li>
</ul>
<p><strong>05、字符串处理 </strong></p>
<p>字符串表示字符的不可变序列，创建后就不能更改。在我们日常的工作中，字符串的使用非常频繁，熟练的对其操作可以极大的提升我们的工作效率。</p>
<p>我提供了连接器——Joiner，可以用分隔符把字符串序列连接起来。下面的代码将会返回“雷军; 乔布斯”，你可以使用 useForNull(String) 方法用某个字符串来替换 null，而不像 skipNulls() 方法那样直接忽略 null。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Joiner joiner = Joiner.on(&quot;; &quot;).skipNulls();</span><br><span class="line">return joiner.join(&quot;雷军&quot;, null, &quot;乔布斯&quot;);</span><br></pre></td></tr></table></figure>
<p>我还提供了拆分器—— Splitter，可以按照指定的分隔符把字符串序列进行拆分。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Splitter.on(&#x27;,&#x27;)</span><br><span class="line">        .trimResults()</span><br><span class="line">        .omitEmptyStrings()</span><br><span class="line">        .split(&quot;雷军,乔布斯,,   沉默王二&quot;);</span><br></pre></td></tr></table></figure>
<p><strong>06、缓存 </strong></p>
<p>缓存在很多场景下都是相当有用的。你应该知道，检索一个值的代价很高，尤其是需要不止一次获取值的时候，就应当考虑使用缓存。</p>
<p>我提供的 Cache 和 ConcurrentMap 很相似，但也不完全一样。最基本的区别是 ConcurrentMap 会一直保存所有添加的元素，直到显式地移除。相对地，我提供的 Cache 为了限制内存占用，通常都设定为自动回收元素。</p>
<p>如果你愿意消耗一些内存空间来提升速度，你能预料到某些键会被查询一次以上，缓存中存放的数据总量不会超出内存容量，就可以使用 Cache。</p>
<p>来个示例你感受下吧。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testCache() throws ExecutionException, InterruptedException &#123;</span><br><span class="line">    CacheLoader cacheLoader = new CacheLoader&lt;String, Animal&gt;() &#123;</span><br><span class="line">        // 如果找不到元素，会调用这里</span><br><span class="line">        @Override</span><br><span class="line">        public Animal load(String s) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    LoadingCache&lt;String, Animal&gt; loadingCache = CacheBuilder.newBuilder()</span><br><span class="line">        .maximumSize(1000) // 容量</span><br><span class="line">        .expireAfterWrite(3, TimeUnit.SECONDS) // 过期时间</span><br><span class="line">        .removalListener(new MyRemovalListener()) // 失效监听器</span><br><span class="line">        .build(cacheLoader); //</span><br><span class="line">    loadingCache.put(&quot;狗&quot;, new Animal(&quot;旺财&quot;, 1));</span><br><span class="line">    loadingCache.put(&quot;猫&quot;, new Animal(&quot;汤姆&quot;, 3));</span><br><span class="line">    loadingCache.put(&quot;狼&quot;, new Animal(&quot;灰太狼&quot;, 4));</span><br><span class="line">    loadingCache.invalidate(&quot;猫&quot;); // 手动失效</span><br><span class="line">    Animal animal = loadingCache.get(&quot;狼&quot;);</span><br><span class="line">    System.out.println(animal);</span><br><span class="line">    Thread.sleep(4 * 1000);</span><br><span class="line">    // 狼已经自动过去，获取为 null 值报错</span><br><span class="line">    System.out.println(loadingCache.get(&quot;狼&quot;));</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 缓存移除监听器</span><br><span class="line"> */</span><br><span class="line">class MyRemovalListener implements RemovalListener&lt;String, Animal&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onRemoval(RemovalNotification&lt;String, Animal&gt; notification) &#123;</span><br><span class="line">        String reason = String.format(&quot;key=%s,value=%s,reason=%s&quot;, </span><br><span class="line">notification.getKey(), notification.getValue(), notification.getCause());</span><br><span class="line">        System.out.println(reason);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Animal &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private Integer age;</span><br><span class="line">    public Animal(String name, Integer age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CacheLoader 中重写了 load 方法，这个方法会在查询缓存没有命中时被调用，我这里直接返回了 null，其实这样会在没有命中时抛出 CacheLoader returned null for key 异常信息。</p>
<p>MyRemovalListener 作为缓存元素失效时的监听类，在有元素缓存失效时会自动调用 onRemoval 方法，这里需要注意的是这个方法是同步方法，如果这里耗时较长，会阻塞直到处理完成。</p>
<p>LoadingCache 就是缓存的主要操作对象了，常用的就是其中的 put 和 get 方法了。</p>
<p><strong>07、集合工具 </strong></p>
<p>com.google.common.collect包下的集合工具： Lists也非常强大。</p>
<p><strong>创建空集合 </strong></p>
<p>有时候，我们想创建一个空集合。这时可以用Lists的 newArrayList方法，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Lists.newArrayList();</span><br></pre></td></tr></table></figure>
<p><strong>快速初始化集合 </strong></p>
<p>有时候，我们想给一个集合中初始化一些元素。这时可以用Lists的newArrayList方法，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Lists.newArrayList(1, 2, 3);</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3]</span><br></pre></td></tr></table></figure>
<p><strong>笛卡尔积 </strong></p>
<p>如果你想将两个集合做笛卡尔积 ，Lists的 cartesianProduct方法可以帮你实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list1 = Lists.newArrayList(1, 2, 3);</span><br><span class="line">List&lt;Integer&gt; list2 = Lists.newArrayList(4,5);</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; productList = Lists.cartesianProduct(list1,list2);</span><br><span class="line">System.out.println(productList);</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[1, 4], [1, 5], [2, 4], [2, 5], [3, 4], [3, 5]]</span><br></pre></td></tr></table></figure>
<p><strong>分页 </strong></p>
<p>如果你想将一个大集合分成若干个小集合 ，可以使用Lists的 partition方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Lists.newArrayList(1, 2, 3, 4, 5);</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; partitionList = Lists.partition(list, 2);</span><br><span class="line">System.out.println(partitionList);</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[1, 2], [3, 4], [5]]</span><br></pre></td></tr></table></figure>
<p>这个例子中，list有5条数据，我将list集合按大小为2，分成了3页，即变成3个小集合。</p>
<p>这个是我最喜欢的方法之一，经常在项目中使用。</p>
<p>比如有个需求：现在有5000个id，需要调用批量用户查询接口，查出用户数据。但如果你直接查5000个用户，单次接口响应时间可能会非常慢。如果改成分页处理，每次只查500个用户，异步调用10次接口，就不会有单次接口响应慢的问题。</p>
<p><strong>流处理 </strong></p>
<p>如果我们想把某个集合转换成另外一个接口，可以使用Lists的 transform方法。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Lists.newArrayList(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);</span><br><span class="line">List&lt;String&gt; transformList = Lists.transform(list, x -&gt; x.toUpperCase());</span><br><span class="line">System.out.println(transformList);</span><br></pre></td></tr></table></figure>
<p>将小写字母转换成了大写字母。</p>
<p><strong>颠倒顺序 </strong></p>
<p>Lists的有颠倒顺序的方法 reverse 。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Lists.newArrayList(3, 1, 2);</span><br><span class="line">List&lt;Integer&gt; reverseList = Lists.reverse(list);</span><br><span class="line">System.out.println(reverseList);</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2, 1, 3]</span><br></pre></td></tr></table></figure>
<p>list的原始顺序是312，使用 reverse方法颠倒顺序之后，变成了213。</p>
<p>Lists还有其他的好用的工具，我在这里只是抛砖引玉，有兴趣的小伙伴，可以仔细研究一下。</p>
<p><img src="\assets\note\image-20231012153730610.png" alt="image-20231012153730610"></p>
<p><strong>08、尾声 </strong></p>
<p>上面介绍了我认为最常用的功能，作为 Google 公司开源的 Java 开发核心库，个人觉得实用性还是很高的（不然呢？嘿嘿嘿）。引入到你的项目后不仅能快速的实现一些开发中常用的功能，而且还可以让代码更加的优雅简洁。</p>
<p>我觉得适用于每一个 Java 项目，至于其他的一些功能，比如说散列、事件总线、数学运算、反射，就等待你去发掘了。</p>
<h2 id="7-8-其他常用工具类"><a href="#7-8-其他常用工具类" class="headerlink" title="7.8 其他常用工具类"></a>7.8 其他常用工具类</h2><p>除了我们前面提到的 Java 原生工具类，比如说 Arrays、Objects、Collections、Scanner 等，还有一些第三方的工具类，比如说 Hutool、Guava 等，以及我们今天介绍的 IpUtil、CollectionUtils、StringUtils、MDC、ClassUtils、BeanUtils、ReflectionUtils 等等，在很大程度上能够提高我们的生产效率。</p>
<p>当然了，如果能好好看一下它们的源码，对技术功底的提升，也是有很大帮助的。</p>
<p><strong>IpUtil：获取本机 Ip </strong></p>
<p>获取本机 IP 算是比较常见的一个需求场景了，比如业务报警，可能就会带上出问题的机器 IP，方便直接上去看日志定位问题，那么问题来了，如何获取机器 IP 呢？</p>
<p><strong>1.基本方法 </strong></p>
<p>如何获取机器 IP？如果了解 InetAddress 这个工具类，就很容易写出一个简单的工具类，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static String getLocalIP() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        return InetAddress.getLocalHost().getHostAddress();</span><br><span class="line">    &#125; catch (UnknownHostException e) &#123;</span><br><span class="line">        throw new RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的实现有问题么？</p>
<p>当然没问题，拿我本机和阿里服务器执行一下，并没有问题如实的输出了预期的 IP</p>
<p>本机执行后截图如下：</p>
<p><img src="\assets\note\image-20231012154124001.png" alt="image-20231012154124001"></p>
<p>阿里云机器执行后截图如下：</p>
<p><img src="\assets\note\image-20231012154135124.png" alt="image-20231012154135124"></p>
<p><strong>2.进阶版 </strong></p>
<p>做一点简单的改动，获取 IPV4 的地址，源码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public static String getLocalIpByNetcard() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 枚举所有的网络接口</span><br><span class="line">        for (Enumeration&lt;NetworkInterface&gt; e = </span><br><span class="line">NetworkInterface.getNetworkInterfaces(); e.hasMoreElements(); ) &#123;</span><br><span class="line">            // 获取当前网络接口</span><br><span class="line">            NetworkInterface item = e.nextElement();</span><br><span class="line">            // 遍历当前网络接口的所有地址</span><br><span class="line">            for (InterfaceAddress address : item.getInterfaceAddresses()) &#123;</span><br><span class="line">                // 忽略回环地址和未启用的网络接口</span><br><span class="line">                if (item.isLoopback() || !item.isUp()) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                // 如果当前地址是 IPv4 地址，则返回其字符串表示</span><br><span class="line">                if (address.getAddress() instanceof Inet4Address) &#123;</span><br><span class="line">                    Inet4Address inet4Address = (Inet4Address) address.getAddress();</span><br><span class="line">                    return inet4Address.getHostAddress();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果没有找到任何 IPv4 地址，则返回本地主机地址</span><br><span class="line">        return InetAddress.getLocalHost().getHostAddress();</span><br><span class="line">    &#125; catch (SocketException | UnknownHostException e) &#123;</span><br><span class="line">        // 抛出运行时异常</span><br><span class="line">        throw new RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，这段代码只返回本机的 IPv4 地址，并且只返回第一个符合条件的地址。如果本机有多个网络接口或者每个接口有多个地址，则可能无法返回预期的地址。此外，如果找不到任何 IPv4 地址，则会返回本地主机地址。</p>
<p>再次测试，输出如下</p>
<p><img src="\assets\note\image-20231012154246072.png" alt="image-20231012154246072"></p>
<p><strong>3.完整工具类 </strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">import java.net.*;</span><br><span class="line">import java.util.Enumeration;</span><br><span class="line">public class IPUtil &#123;</span><br><span class="line">    public static final String DEFAULT_IP = &quot;127.0.0.1&quot;;</span><br><span class="line">    /**</span><br><span class="line">     * 直接根据第一个网卡地址作为其内网ipv4地址，避免返回 127.0.0.1</span><br><span class="line">     *</span><br><span class="line">     * @return 第一个符合条件的内网 IPv4 地址</span><br><span class="line">     */</span><br><span class="line">    public static String getLocalIpByNetcard() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 枚举所有的网络接口</span><br><span class="line">            for (Enumeration&lt;NetworkInterface&gt; e = </span><br><span class="line">NetworkInterface.getNetworkInterfaces(); e.hasMoreElements(); ) &#123;</span><br><span class="line">                // 获取当前网络接口</span><br><span class="line">                NetworkInterface item = e.nextElement();</span><br><span class="line">                // 遍历当前网络接口的所有地址</span><br><span class="line">                for (InterfaceAddress address : item.getInterfaceAddresses()) &#123;</span><br><span class="line">                    // 忽略回环地址和未启用的网络接口</span><br><span class="line">                    if (item.isLoopback() || !item.isUp()) &#123;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 如果当前地址是 IPv4 地址，则返回其字符串表示</span><br><span class="line">                    if (address.getAddress() instanceof Inet4Address) &#123;</span><br><span class="line">                        Inet4Address inet4Address = (Inet4Address) </span><br><span class="line">address.getAddress();</span><br><span class="line">                        return inet4Address.getHostAddress();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果没有找到符合条件的地址，则返回本地主机地址</span><br><span class="line">            return InetAddress.getLocalHost().getHostAddress();</span><br><span class="line">        &#125; catch (SocketException | UnknownHostException e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 获取本地主机地址</span><br><span class="line">     *</span><br><span class="line">     * @return 本地主机地址</span><br><span class="line">     */</span><br><span class="line">    public static String getLocalIP() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return InetAddress.getLocalHost().getHostAddress();</span><br><span class="line">        &#125; catch (UnknownHostException e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IPUtil 类中定义了两个方法，分别是 getLocalIpByNetcard() 和 getLocalIP() 。前者是获取本机的内网 IPv4 地址，避免了返回 127.0.0.1 的问题。后者是获取本地主机地址，如果本机有多个 IP 地址，则可能返回其中的任意一个。</p>
<p><strong>MDC：一个线程安全的参数传递工具类 </strong></p>
<p>MDC 是 org.slf4j 包下的一个类，它的全称是 Mapped Diagnostic Context，我们可以认为它是一个线程安全的存放诊断日志的容器。</p>
<p>MDC 的底层是用了 ThreadLocal 来保存数据的。</p>
<p>我们可以用它传递参数。</p>
<p>例如现在有这样一种场景：我们使用 RestTemplate调用远程接口时，有时需要在 header中传递信息，比如：traceId，source 等，便于在查询日志时能够串联一次完整的请求链路，快速定位问题。</p>
<p>这种业务场景就能通过 ClientHttpRequestInterceptor接口实现，具体做法如下：</p>
<p>第一步，定义一个 LogFilter 拦截所有接口请求，在 MDC 中设置 traceId：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class LogFilter implements Filter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void init(FilterConfig filterConfig) throws ServletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter(ServletRequest request, ServletResponse response, </span><br><span class="line">FilterChain chain) throws IOException, ServletException &#123;</span><br><span class="line">        MdcUtil.add(UUID.randomUUID().toString());</span><br><span class="line">        System.out.println(&quot;记录请求日志&quot;);</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">        System.out.println(&quot;记录响应日志&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二步，实现 ClientHttpRequestInterceptor接口，MDC 中获取当前请求的 traceId，然后设置到 header 中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class RestTemplateInterceptor implements ClientHttpRequestInterceptor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public ClientHttpResponse intercept(HttpRequest request, byte[] body, </span><br><span class="line">ClientHttpRequestExecution execution) throws IOException &#123;</span><br><span class="line">        request.getHeaders().set(&quot;traceId&quot;, MdcUtil.get());</span><br><span class="line">        return execution.execute(request, body);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三步，定义配置类，配置上面定义的 RestTemplateInterceptor类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class RestTemplateConfiguration &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public RestTemplate restTemplate() &#123;</span><br><span class="line">        RestTemplate restTemplate = new RestTemplate();</span><br><span class="line">       </span><br><span class="line"> restTemplate.setInterceptors(Collections.singletonList(restTemplateInterceptor()));</span><br><span class="line">        return restTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">    @Bean</span><br><span class="line">    public RestTemplateInterceptor restTemplateInterceptor() &#123;</span><br><span class="line">        return new RestTemplateInterceptor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 MdcUtil 其实是利用 MDC 工具在 ThreadLocal 中存储和获取 traceId</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class MdcUtil &#123;</span><br><span class="line">    private static final String TRACE_ID = &quot;TRACE_ID&quot;;</span><br><span class="line">    public static String get() &#123;</span><br><span class="line">        return MDC.get(TRACE_ID);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void add(String value) &#123;</span><br><span class="line">        MDC.put(TRACE_ID, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，这个例子中没有演示 MdcUtil 类的 add 方法具体调的地方，我们可以在 filter 中执行接口方法之前，生成 traceId，调用 MdcUtil 类的 add 方法添加到 MDC 中，然后在同一个请求的其他地方就能通过 MdcUtil 类的 get 方法获取到该 traceId。</p>
<p>能使用 MDC 保存 traceId 等参数的根本原因是，用户请求到应用服务器，Tomcat 会从线程池中分配一个线程去处理该请求。</p>
<p>那么该请求的整个过程中，保存到 MDC 的 ThreadLocal 中的参数，也是该线程独享的，所以不会有线程安全问题。</p>
<p><strong>ClassUtils </strong></p>
<p>spring 的 org.springframework.util包下的 ClassUtils类，它里面有很多让我们惊喜的功能。</p>
<p>它里面包含了类和对象相关的很多非常实用的方法。</p>
<p><strong>获取对象的所有接口 </strong></p>
<p>如果你想获取某个对象的所有接口，可以使用 ClassUtils 的 getAllInterfaces方法。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt;[] allInterfaces = ClassUtils.getAllInterfaces(new User());</span><br></pre></td></tr></table></figure>
<p><strong>获取某个类的包名 </strong></p>
<p>如果你想获取某个类的包名，可以使用 ClassUtils 的 getPackageName方法。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String packageName = ClassUtils.getPackageName(User.class);</span><br><span class="line">System.out.println(packageName);</span><br></pre></td></tr></table></figure>
<p><strong>判断某个类是否内部类 </strong></p>
<p>如果你想判断某个类是否内部类，可以使用 ClassUtils 的 isInnerClass方法。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(ClassUtils.isInnerClass(User.class));</span><br></pre></td></tr></table></figure>
<p><strong>判断对象是否代理对象 </strong></p>
<p>如果你想判断对象是否代理对象，可以使用 ClassUtils 的 isCglibProxy方法。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(ClassUtils.isCglibProxy(new User()));</span><br></pre></td></tr></table></figure>
<p>ClassUtils 还有很多有用的方法，等待着你去发掘。感兴趣的小伙伴，可以看看下面的内容：</p>
<p><img src="\assets\note\image-20231012154737388.png" alt="image-20231012154737388"></p>
<p><strong>BeanUtils </strong></p>
<p>Spring 给我们提供了一个 JavaBean的工具类，它在 org.springframework.beans包下面，它的名字叫做： BeanUtils 。</p>
<p>让我们一起看看这个工具可以带给我们哪些惊喜。</p>
<p><strong>拷贝对象的属性 </strong></p>
<p>曾几何时，你有没有这样的需求：把某个对象中的所有属性，都拷贝到另外一个对象中。这时就能使用 BeanUtils 的 copyProperties方法。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">User user1 = new User();</span><br><span class="line">user1.setId(1L);</span><br><span class="line">user1.setName(&quot;沉默王二&quot;);</span><br><span class="line">user1.setAddress(&quot;中国&quot;);</span><br><span class="line">User user2 = new User();</span><br><span class="line">BeanUtils.copyProperties(user1, user2);</span><br><span class="line">System.out.println(user2);</span><br></pre></td></tr></table></figure>
<p><strong>实例化某个类 </strong></p>
<p>如果你想通过反射实例化一个类的对象，可以使用 BeanUtils 的 instantiateClass方法。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User user = BeanUtils.instantiateClass(User.class);</span><br><span class="line">System.out.println(user);</span><br></pre></td></tr></table></figure>
<p><strong>获取指定类的指定方法 </strong></p>
<p>如果你想获取某个类的指定方法，可以使用 BeanUtils 的 findDeclaredMethod方法。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Method declaredMethod = BeanUtils.findDeclaredMethod(User.class, &quot;getId&quot;);</span><br><span class="line">System.out.println(declaredMethod.getName());</span><br></pre></td></tr></table></figure>
<p><strong>获取指定方法的参数 </strong></p>
<p>如果你想获取某个方法的参数，可以使用 BeanUtils 的 findPropertyForMethod方法。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Method declaredMethod = BeanUtils.findDeclaredMethod(User.class, &quot;getId&quot;);</span><br><span class="line">PropertyDescriptor propertyForMethod = </span><br><span class="line">BeanUtils.findPropertyForMethod(declaredMethod);</span><br><span class="line">System.out.println(propertyForMethod.getName());</span><br></pre></td></tr></table></figure>
<p>如果你对 BeanUtils 比较感兴趣，可以看看下面内容：</p>
<p><img src="\assets\note\image-20231012154931680.png" alt="image-20231012154931680"></p>
<p><strong>ReflectionUtils </strong></p>
<p>有时候，我们需要在项目中使用反射功能，如果使用最原始的方法来开发，代码量会非常多，而且很麻烦，它需要处理一大堆异常以及访问权限等问题。</p>
<p>好消息是 Spring 给我们提供了一个 ReflectionUtils工具，它在 org.springframework.util包下面。</p>
<p><strong>获取方法 </strong></p>
<p>如果你想获取某个类的某个方法，可以使用 ReflectionUtils 类的 findMethod方法。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Method method = ReflectionUtils.findMethod(User.class, &quot;getId&quot;);</span><br></pre></td></tr></table></figure>
<p><strong>获取字段 </strong></p>
<p>如果你想获取某个类的某个字段，可以使用 ReflectionUtils 类的 findField方法。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Field field = ReflectionUtils.findField(User.class, &quot;id&quot;);</span><br></pre></td></tr></table></figure>
<p><strong>执行方法 </strong></p>
<p>如果你想通过反射调用某个方法，传递参数，可以使用 ReflectionUtils 类的 invokeMethod方法。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReflectionUtils.invokeMethod(method, springContextsUtil.getBean(beanName), param);</span><br></pre></td></tr></table></figure>
<p><strong>判断字段是否常量 </strong></p>
<p>如果你想判断某个字段是否常量，可以使用 ReflectionUtils 类的 isPublicStaticFinal方法。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Field field = ReflectionUtils.findField(User.class, &quot;id&quot;);</span><br><span class="line">System.out.println(ReflectionUtils.isPublicStaticFinal(field));</span><br></pre></td></tr></table></figure>
<p><strong>判断是否 equals 方法 </strong></p>
<p>如果你想判断某个方法是否 equals 方法，可以使用 ReflectionUtils 类的 isEqualsMethod方法。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Method method = ReflectionUtils.findMethod(User.class, &quot;getId&quot;);</span><br><span class="line">System.out.println(ReflectionUtils.isEqualsMethod(method));</span><br></pre></td></tr></table></figure>
<p>当然这个类还有不少有趣的方法，感兴趣的朋友，可以看看下面内容：</p>
<p><img src="\assets\note\image-20231012155139162.png" alt="image-20231012155139162"></p>
<h1 id="8-Java新特性"><a href="#8-Java新特性" class="headerlink" title="8 Java新特性"></a>8 Java新特性</h1><h2 id="8-1-掌握Stream流"><a href="#8-1-掌握Stream流" class="headerlink" title="8.1 掌握Stream流"></a>8.1 掌握Stream流</h2><p>两个星期以前，就有读者强烈要求我写一篇 Java Stream 流的文章，我说市面上不是已经有很多了吗，结果你猜他怎么说：“就想看你写的啊！”你看你看，多么苍白的喜欢啊。那就“勉为其难”写一篇吧，嘻嘻。</p>
<p>单从“Stream”这个单词上来看，它似乎和 java.io 包下的 InputStream 和 OutputStream 有些关系。实际上呢，没毛关系。Java 8 新增的 Stream 是为了解放程序员操作集合（Collection）时的生产力，之所以能解放，很大一部分原因可以归功于同时出现的 Lambda 表达式——极大的提高了编程效率和程序可读性。</p>
<p>Stream 究竟是什么呢？</p>
<blockquote>
<p>Stream 就好像一个高级的迭代器，但只能遍历一次，就好像一江春水向东流；在流的过程中，对流中的元素执行一些操作，比如“过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等。</p>
</blockquote>
<p>要想操作流，首先需要有一个数据源，可以是数组或者集合。每次操作都会返回一个新的流对象，方便进行链式操作，但原有的流对象会保持不变。</p>
<p>流的操作可以分为两种类型：</p>
<p>1）中间操作，可以有多个，每次返回一个新的流，可进行链式操作。</p>
<p>2）终端操作，只能有一个，每次执行完，这个流也就用光光了，无法执行下一个操作，因此只能放在最后。</p>
<p>来举个例子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list.add(&quot;武汉加油&quot;);</span><br><span class="line">list.add(&quot;中国加油&quot;);</span><br><span class="line">list.add(&quot;世界加油&quot;);</span><br><span class="line">list.add(&quot;世界加油&quot;);</span><br><span class="line">long count = list.stream().distinct().count();</span><br><span class="line">System.out.println(count);</span><br></pre></td></tr></table></figure>
<p>distinct() 方法是一个中间操作（去重），它会返回一个新的流（没有共同元素）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; distinct();</span><br></pre></td></tr></table></figure>
<p>count() 方法是一个终端操作，返回流中的元素个数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">long count();</span><br></pre></td></tr></table></figure>
<p>中间操作不会立即执行，只有等到终端操作的时候，流才开始真正地遍历，用于映射、过滤等。通俗点说，就是一次遍历执行多个操作，性能就大大提高了。</p>
<p>理论部分就扯这么多，下面直接进入实战部分。</p>
<p><strong>01、创建流 </strong></p>
<p>如果是数组的话，可以使用 Arrays.stream() 或者 Stream.of() 创建流；如果是集合的话，可以直接使用 stream() 方法创建流，因为该方法已经添加到 Collection 接口中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class CreateStreamDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String[] arr = new String[]&#123;&quot;武汉加油&quot;, &quot;中国加油&quot;, &quot;世界加油&quot;&#125;;</span><br><span class="line">        Stream&lt;String&gt; stream = Arrays.stream(arr);</span><br><span class="line">        stream = Stream.of(&quot;武汉加油&quot;, &quot;中国加油&quot;, &quot;世界加油&quot;);</span><br><span class="line">        List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        list.add(&quot;武汉加油&quot;);</span><br><span class="line">        list.add(&quot;中国加油&quot;);</span><br><span class="line">        list.add(&quot;世界加油&quot;);</span><br><span class="line">        stream = list.stream();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看 Stream 源码的话，你会发现 of() 方法内部其实调用了 Arrays.stream() 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static&lt;T&gt; Stream&lt;T&gt; of(T... values) &#123;</span><br><span class="line">    return Arrays.stream(values);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，集合还可以调用 parallelStream() 方法创建并发流，默认使用的是 ForkJoinPool.commonPool()线程池。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Long&gt; aList = new ArrayList&lt;&gt;();</span><br><span class="line">Stream&lt;Long&gt; parallelStream = aList.parallelStream();</span><br></pre></td></tr></table></figure>
<p><strong>02、操作流 </strong></p>
<p>Stream 类提供了很多有用的操作流的方法，我来挑一些常用的给你介绍一下。</p>
<p><strong>1）过滤 </strong></p>
<p>通过 filter() 方法可以从流中筛选出我们想要的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class FilterStreamDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        list.add(&quot;周杰伦&quot;);</span><br><span class="line">        list.add(&quot;王力宏&quot;);</span><br><span class="line">        list.add(&quot;陶喆&quot;);</span><br><span class="line">        list.add(&quot;林俊杰&quot;);</span><br><span class="line">        Stream&lt;String&gt; stream = list.stream().filter(element -&gt; element.contains(&quot;王&quot;));</span><br><span class="line">        stream.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>filter() 方法接收的是一个 Predicate（Java 8 新增的一个函数式接口，接受一个输入参数返回一个布尔值结果）类型的参数，因此，我们可以直接将一个 Lambda 表达式传递给该方法，比如说 element -&gt; element.contains(“王”) 就是筛选出带有“王”的字符串。</p>
<p>forEach() 方法接收的是一个 Consumer（Java 8 新增的一个函数式接口，接受一个输入参数并且无返回的操作）类型的参数，类名 :: 方法名是 Java 8 引入的新语法， System.out 返回 PrintStream 类，println 方法你应该知道是打印的。</p>
<p>stream.forEach(System.out::println); 相当于在 for 循环中打印，类似于下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (String s : strs) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显，一行代码看起来更简洁一些。来看一下程序的输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">王力宏</span><br></pre></td></tr></table></figure>
<p><strong>2）映射 </strong></p>
<p>如果想通过某种操作把一个流中的元素转化成新的流中的元素，可以使用 map() 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class MapStreamDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        list.add(&quot;周杰伦&quot;);</span><br><span class="line">        list.add(&quot;王力宏&quot;);</span><br><span class="line">        list.add(&quot;陶喆&quot;);</span><br><span class="line">        list.add(&quot;林俊杰&quot;);</span><br><span class="line">        Stream&lt;Integer&gt; stream = list.stream().map(String::length);</span><br><span class="line">        stream.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>map() 方法接收的是一个 Function（Java 8 新增的一个函数式接口，接受一个输入参数 T，返回一个结果 R）类型的参数，此时参数 为 String 类的 length 方法，也就是把 Stream<String> 的流转成一个 Stream<Integer> 的流。</p>
<p>程序输出的结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p><strong>3）匹配 </strong></p>
<p>Stream 类提供了三个方法可供进行元素匹配，它们分别是：</p>
<ul>
<li>anyMatch() ，只要有一个元素匹配传入的条件，就返回 true。</li>
<li>allMatch() ，只有有一个元素不匹配传入的条件，就返回 false；如果全部匹配，则返回 true。</li>
<li>noneMatch() ，只要有一个元素匹配传入的条件，就返回 false；如果全部不匹配，则返回 true。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class MatchStreamDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        list.add(&quot;周杰伦&quot;);</span><br><span class="line">        list.add(&quot;王力宏&quot;);</span><br><span class="line">        list.add(&quot;陶喆&quot;);</span><br><span class="line">        list.add(&quot;林俊杰&quot;);</span><br><span class="line">        boolean  anyMatchFlag = list.stream().anyMatch(element -&gt; element.contains(&quot;王&quot;));</span><br><span class="line">        boolean  allMatchFlag = list.stream().allMatch(element -&gt; element.length() &gt; </span><br><span class="line">1);</span><br><span class="line">        boolean  noneMatchFlag = list.stream().noneMatch(element -&gt; </span><br><span class="line">element.endsWith(&quot;沉&quot;));</span><br><span class="line">        System.out.println(anyMatchFlag);</span><br><span class="line">        System.out.println(allMatchFlag);</span><br><span class="line">        System.out.println(noneMatchFlag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为“王力宏”以“王”字开头，所以 anyMatchFlag 应该为 true；因为“周杰伦”、“王力宏”、“陶喆”、“林俊杰”的字符串长度都大于 1，所以 allMatchFlag 为 true；因为 4 个字符串结尾都不是“沉”，所以 noneMatchFlag 为 true。</p>
<p>程序输出的结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">true</span><br><span class="line">true</span><br></pre></td></tr></table></figure>
<p><strong>4）组合 </strong></p>
<p>reduce() 方法的主要作用是把 Stream 中的元素组合起来，它有两种用法：</p>
<ul>
<li>Optional<T> reduce(BinaryOperator<T> accumulator)</li>
</ul>
<p>没有起始值，只有一个参数，就是运算规则，此时返回 Optional。</p>
<ul>
<li>T reduce(T identity, BinaryOperator<T> accumulator)</li>
</ul>
<p>有起始值，有运算规则，两个参数，此时返回的类型和起始值类型一致。</p>
<p>来看下面这个例子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class ReduceStreamDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Integer[] ints = &#123;0, 1, 2, 3&#125;;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(ints);</span><br><span class="line">        Optional&lt;Integer&gt; optional = list.stream().reduce((a, b) -&gt; a + b);</span><br><span class="line">        Optional&lt;Integer&gt; optional1 = list.stream().reduce(Integer::sum);</span><br><span class="line">        System.out.println(optional.orElse(0));</span><br><span class="line">        System.out.println(optional1.orElse(0));</span><br><span class="line">        int reduce = list.stream().reduce(6, (a, b) -&gt; a + b);</span><br><span class="line">        System.out.println(reduce);</span><br><span class="line">        int reduce1 = list.stream().reduce(6, Integer::sum);</span><br><span class="line">        System.out.println(reduce1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运算规则可以是 Lambda 表达式（比如 (a, b) -&gt; a + b ），也可以是类名::方法名（比如 Integer::sum ）。</p>
<p>程序运行的结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">6</span><br><span class="line">12</span><br><span class="line">12</span><br></pre></td></tr></table></figure>
<p>0、1、2、3 在没有起始值相加的时候结果为 6；有起始值 6 的时候结果为 12。</p>
<p><strong>03、转换流 </strong></p>
<p>既然可以把集合或者数组转成流，那么也应该有对应的方法，将流转换回去—— collect() 方法就满足了这种需求。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class CollectStreamDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        list.add(&quot;周杰伦&quot;);</span><br><span class="line">        list.add(&quot;王力宏&quot;);</span><br><span class="line">        list.add(&quot;陶喆&quot;);</span><br><span class="line">        list.add(&quot;林俊杰&quot;);</span><br><span class="line">        String[] strArray = list.stream().toArray(String[]::new);</span><br><span class="line">        System.out.println(Arrays.toString(strArray));</span><br><span class="line">        List&lt;Integer&gt; list1 = </span><br><span class="line">list.stream().map(String::length).collect(Collectors.toList());</span><br><span class="line">        List&lt;String&gt; list2 = </span><br><span class="line">list.stream().collect(Collectors.toCollection(ArrayList::new));</span><br><span class="line">        System.out.println(list1);</span><br><span class="line">        System.out.println(list2);</span><br><span class="line">        String str = list.stream().collect(Collectors.joining(&quot;, &quot;)).toString();</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>toArray() 方法可以将流转换成数组，你可能比较好奇的是 String[]::new ，它是什么东东呢？来看一下 toArray() 方法的源码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator);</span><br></pre></td></tr></table></figure>
<p>也就是说 String[]::new 是一个 IntFunction，一个可以产生所需的新数组的函数，可以通过反编译字节码看看它到底是什么：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] strArray = (String[])list.stream().toArray((x$0) -&gt; &#123;</span><br><span class="line">    return new String[x$0];</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(Arrays.toString(strArray));</span><br></pre></td></tr></table></figure>
<p>也就是相当于返回了一个指定长度的字符串数组。</p>
<p>当我们需要把一个集合按照某种规则转成另外一个集合的时候，就可以配套使用 map() 方法和 collect() 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list1 = </span><br><span class="line">list.stream().map(String::length).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<p>通过 stream() 方法创建集合的流后，再通过 map(String:length) 将其映射为字符串长度的一个新流，最后通过 collect() 方法将其转换成新的集合。</p>
<p>Collectors 是一个收集器的工具类，内置了一系列收集器实现，比如说 toList() 方法将元素收集到一个新的 java.util.List 中；比如说 toCollection() 方法将元素收集到一个新的 java.util.ArrayList 中；比如说 joining() 方法将元素收集到一个可以用分隔符指定的字符串中。</p>
<p>来看一下程序的输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[周杰伦, 王力宏, 陶喆, 林俊杰]</span><br><span class="line">[3, 3, 2, 3]</span><br><span class="line">[周杰伦, 王力宏, 陶喆, 林俊杰]</span><br><span class="line">周杰伦, 王力宏, 陶喆, 林俊杰</span><br></pre></td></tr></table></figure>
<h2 id="8-2-Optional最佳指南"><a href="#8-2-Optional最佳指南" class="headerlink" title="8.2 Optional最佳指南"></a>8.2 Optional最佳指南</h2><p>想学习，永远都不晚，尤其是针对 Java 8 里面的好东西，Optional 就是其中之一，该类提供了一种用于表示可选值而非空引用的类级别解决方案。作为一名 Java 程序员，我真的是烦透了 NullPointerException（NPE），尽管和它熟得就像一位老朋友，知道它也是迫不得已——程序正在使用一个对象却发现这个对象的值为 null，于是 Java 虚拟机就怒发冲冠地把它抛了出来当做替罪羊。</p>
<p>当然了，我们程序员是富有责任心的，不会坐视不管，于是就有了大量的 null 值检查。尽管有时候这种检查完全没有必要，但我们已经习惯了例行公事。终于，Java 8 看不下去了，就引入了 Optional，以便我们编写的代码不再那么刻薄呆板。</p>
<p><img src="\assets\note\image-20231012160955090.png" alt="image-20231012160955090"></p>
<p><strong>01、没有 Optional 会有什么问题 </strong></p>
<p>我们来模拟一个实际的应用场景。小王第一天上班，领导老马就给他安排了一个任务，要他从数据库中根据会员 ID 拉取一个会员的姓名，然后将姓名打印到控制台。虽然是新来的，但这个任务难不倒小王，于是他花了 10 分钟写下了这段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class WithoutOptionalDemo &#123;</span><br><span class="line">    class Member &#123;</span><br><span class="line">        private String name;</span><br><span class="line">        public String getName() &#123;</span><br><span class="line">            return name;</span><br><span class="line">        &#125;</span><br><span class="line">        public void setName(String name) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Member mem = getMemberByIdFromDB();</span><br><span class="line">        if (mem != null) &#123;</span><br><span class="line">            System.out.println(mem.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static Member getMemberByIdFromDB() &#123;</span><br><span class="line">        // 当前 ID 的会员不存在</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于当前 ID 的会员不存在，所以 getMemberByIdFromDB() 方法返回了 null 来作为没有获取到该会员的结果，那就意味着在打印会员姓名的时候要先对 mem 判空，否则就会抛出 NPE 异常，不信？让小王把 if (mem != null) 去掉试试，控制台立马打印错误堆栈给你颜色看看。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.NullPointerException</span><br><span class="line">    at </span><br><span class="line">com.cmower.dzone.optional.WithoutOptionalDemo.main(WithoutOptionalDemo.java:24)</span><br></pre></td></tr></table></figure>
<p><strong>02、Optional 是如何解决这个问题的 </strong></p>
<p>小王把代码提交后，就兴高采烈地去找老马要新的任务了。本着虚心学习的态度，小王请求老马看一下自己的代码，于是老王就告诉他应该尝试一下 Optional，可以避免没有必要的 null 值检查。现在，让我们来看看小王是如何通过 Optional 来解决上述问题的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class OptionalDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Optional&lt;Member&gt; optional = getMemberByIdFromDB();</span><br><span class="line">        optional.ifPresent(mem -&gt; &#123;</span><br><span class="line">            System.out.println(&quot;会员姓名是：&quot; + mem.getName());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static Optional&lt;Member&gt; getMemberByIdFromDB() &#123;</span><br><span class="line">        boolean hasName = true;</span><br><span class="line">        if (hasName) &#123;</span><br><span class="line">            return Optional.of(new Member(&quot;沉默王二&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">        return Optional.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Member &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    // getter / setter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getMemberByIdFromDB() 方法返回了 Optional<Member> 作为结果，这样就表明 Member 可能存在，也可能不存在，这时候就可以在 Optional 的 ifPresent() 方法中使用 Lambda 表达式来直接打印结果。</p>
<p>Optional 之所以可以解决 NPE 的问题，是因为它明确的告诉我们，不需要对它进行判空。它就好像十字路口的路标，明确地告诉你该往哪走。</p>
<p><strong>03、创建 Optional 对象 </strong></p>
<p>1）可以使用静态方法 empty() 创建一个空的 Optional 对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; empty = Optional.empty();</span><br><span class="line">System.out.println(empty); // 输出：Optional.empty</span><br></pre></td></tr></table></figure>
<p>2）可以使用静态方法 of() 创建一个非空的 Optional 对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; opt = Optional.of(&quot;沉默王二&quot;);</span><br><span class="line">System.out.println(opt); // 输出：Optional[沉默王二]</span><br></pre></td></tr></table></figure>
<p>当然了，传递给 of() 方法的参数必须是非空的，也就是说不能为 null，否则仍然会抛出 NullPointerException。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String name = null;</span><br><span class="line">Optional&lt;String&gt; optnull = Optional.of(name);</span><br></pre></td></tr></table></figure>
<p>3）可以使用静态方法 ofNullable() 创建一个即可空又可非空的 Optional 对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String name = null;</span><br><span class="line">Optional&lt;String&gt; optOrNull = Optional.ofNullable(name);</span><br><span class="line">System.out.println(optOrNull); // 输出：Optional.empty</span><br></pre></td></tr></table></figure>
<p>ofNullable() 方法内部有一个三元表达式，如果为参数为 null，则返回私有常量 EMPTY；否则使用 new 关键字创建了一个新的 Optional 对象——不会再抛出 NPE 异常了。</p>
<p><strong>04、判断值是否存在 </strong></p>
<p>可以通过方法 isPresent() 判断一个 Optional 对象是否存在，如果存在，该方法返回 true，否则返回 false——取代了 obj != null 的判断。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; opt = Optional.of(&quot;沉默王二&quot;);</span><br><span class="line">System.out.println(opt.isPresent()); // 输出：true</span><br><span class="line">Optional&lt;String&gt; optOrNull = Optional.ofNullable(null);</span><br><span class="line">System.out.println(opt.isPresent()); // 输出：false</span><br></pre></td></tr></table></figure>
<p>Java 11 后还可以通过方法 isEmpty() 判断与 isPresent() 相反的结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; opt = Optional.of(&quot;沉默王二&quot;);</span><br><span class="line">System.out.println(opt.isPresent()); // 输出：false</span><br><span class="line">Optional&lt;String&gt; optOrNull = Optional.ofNullable(null);</span><br><span class="line">System.out.println(opt.isPresent()); // 输出：true</span><br></pre></td></tr></table></figure>
<p><strong>05、非空表达式 </strong></p>
<p>Optional 类有一个非常现代化的方法—— ifPresent() ，允许我们使用函数式编程的方式执行一些代码，因此，我把它称为非空表达式。如果没有该方法的话，我们通常需要先通过 isPresent() 方法对 Optional 对象进行判空后再执行相应的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; optOrNull = Optional.ofNullable(null);</span><br><span class="line">if (optOrNull.isPresent()) &#123;</span><br><span class="line">    System.out.println(optOrNull.get().length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了 ifPresent() 之后，情况就完全不同了，可以直接将 Lambda 表达式传递给该方法，代码更加简洁，更加直观。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; opt = Optional.of(&quot;沉默王二&quot;);</span><br><span class="line">opt.ifPresent(str -&gt; System.out.println(str.length()));</span><br></pre></td></tr></table></figure>
<p>Java 9 后还可以通过方法 ifPresentOrElse(action, emptyAction) 执行两种结果，非空时执行 action，空时执行 emptyAction。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; opt = Optional.of(&quot;沉默王二&quot;);</span><br><span class="line">opt.ifPresentOrElse(str -&gt; System.out.println(str.length()), () -&gt; </span><br><span class="line">System.out.println(&quot;为空&quot;));</span><br></pre></td></tr></table></figure>
<p><strong>06、设置（获取）默认值 </strong></p>
<p>有时候，我们在创建（获取） Optional 对象的时候，需要一个默认值， orElse() 和 orElseGet() 方法就派上用场了。</p>
<p>orElse() 方法用于返回包裹在 Optional 对象中的值，如果该值不为 null，则返回；否则返回默认值。该方法的参数类型和值得类型一致。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String nullName = null;</span><br><span class="line">String name = Optional.ofNullable(nullName).orElse(&quot;沉默王二&quot;);</span><br><span class="line">System.out.println(name); // 输出：沉默王二</span><br></pre></td></tr></table></figure>
<p>orElseGet() 方法与 orElse() 方法类似，但参数类型不同。如果 Optional 对象中的值为 null，则执行参数中的函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String nullName = null;</span><br><span class="line">String name = Optional.ofNullable(nullName).orElseGet(()-&gt;&quot;沉默王二&quot;);</span><br><span class="line">System.out.println(name); // 输出：沉默王二</span><br></pre></td></tr></table></figure>
<p>从输出结果以及代码的形式上来看，这两个方法极其相似，这不免引起我们的怀疑，Java 类库的设计者有必要这样做吗？</p>
<p>假设现在有这样一个获取默认值的方法，很传统的方式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static String getDefaultValue() &#123;</span><br><span class="line">    System.out.println(&quot;getDefaultValue&quot;);</span><br><span class="line">    return &quot;沉默王二&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，通过 orElse() 方法和 orElseGet() 方法分别调用 getDefaultValue() 方法返回默认值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String name = null;</span><br><span class="line">    System.out.println(&quot;orElse&quot;);</span><br><span class="line">    String name2 = Optional.ofNullable(name).orElse(getDefaultValue());</span><br><span class="line">    System.out.println(&quot;orElseGet&quot;);</span><br><span class="line">    String name3 = </span><br><span class="line">Optional.ofNullable(name).orElseGet(OrElseOptionalDemo::getDefaultValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：类名 :: 方法名是 Java 8 引入的语法，方法名后面是没有 () 的，表明该方法并不一定会被调用。</p>
<p>输出结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">orElse</span><br><span class="line">getDefaultValue</span><br><span class="line">orElseGet</span><br><span class="line">getDefaultValue</span><br></pre></td></tr></table></figure>
<p>输出结果是相似的，没什么太大的不同，这是在 Optional 对象的值为 null 的情况下。假如 Optional 对象的值不为 null 呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String name = &quot;沉默王三&quot;;</span><br><span class="line">    System.out.println(&quot;orElse&quot;);</span><br><span class="line">    String name2 = Optional.ofNullable(name).orElse(getDefaultValue());</span><br><span class="line">    System.out.println(&quot;orElseGet&quot;);</span><br><span class="line">    String name3 = </span><br><span class="line">Optional.ofNullable(name).orElseGet(OrElseOptionalDemo::getDefaultValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">orElse</span><br><span class="line">getDefaultValue</span><br><span class="line">orElseGet</span><br></pre></td></tr></table></figure>
<p>咦， orElseGet() 没有去调用 getDefaultValue() 。哪个方法的性能更佳，你明白了吧？</p>
<p><strong>07、获取值 </strong></p>
<p>直观从语义上来看， get() 方法才是最正宗的获取 Optional 对象值的方法，但很遗憾，该方法是有缺陷的，因为假如 Optional 对象的值为 null，该方法会抛出 NoSuchElementException 异常。这完全与我们使用 Optional 类的初衷相悖。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class GetOptionalDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String name = null;</span><br><span class="line">        Optional&lt;String&gt; optOrNull = Optional.ofNullable(name);</span><br><span class="line">        System.out.println(optOrNull.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段程序在运行时会抛出异常：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.util.NoSuchElementException: No value present</span><br><span class="line">    at java.base/java.util.Optional.get(Optional.java:141)</span><br><span class="line">    at com.cmower.dzone.optional.GetOptionalDemo.main(GetOptionalDemo.java:9)</span><br></pre></td></tr></table></figure>
<p>尽管抛出的异常是 NoSuchElementException 而不是 NPE，但在我们看来，显然是在“五十步笑百步”。建议 orElseGet() 方法获取 Optional 对象的值。</p>
<p><strong>08、过滤值 </strong></p>
<p>小王通过 Optional 类对之前的代码进行了升级，完成后又兴高采烈地跑去找老马要任务了。老马觉得这小伙子不错，头脑灵活，又干活积极，很值得培养，就又交给了小王一个新的任务：用户注册时对密码的长度进行检查。</p>
<p>小王拿到任务后，乐开了花，因为他刚要学习 Optional 类的 filter() 方法，这就派上了用场。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class FilterOptionalDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String password = &quot;12345&quot;;</span><br><span class="line">        Optional&lt;String&gt; opt = Optional.ofNullable(password);</span><br><span class="line">        System.out.println(opt.filter(pwd -&gt; pwd.length() &gt; 6).isPresent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>filter() 方法的参数类型为 Predicate（Java 8 新增的一个函数式接口），也就是说可以将一个 Lambda 表达式传递给该方法作为条件，如果表达式的结果为 false，则返回一个 EMPTY 的 Optional 对象，否则返回过滤后的 Optional 对象。</p>
<p>在上例中，由于 password 的长度为 5 ，所以程序输出的结果为 false。假设密码的长度要求在 6 到 10 位之间，那么还可以再追加一个条件。来看小王增加难度后的代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;String&gt; len6 = pwd -&gt; pwd.length() &gt; 6;</span><br><span class="line">Predicate&lt;String&gt; len10 = pwd -&gt; pwd.length() &lt; 10;</span><br><span class="line">password = &quot;1234567&quot;;</span><br><span class="line">opt = Optional.ofNullable(password);</span><br><span class="line">boolean result = opt.filter(len6.and(len10)).isPresent();</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure>
<p>这次程序输出的结果为 true，因为密码变成了 7 位，在 6 到 10 位之间。想象一下，假如小王使用 if-else 来完成这个任务，代码该有多冗长。</p>
<p><strong>09、转换值 </strong></p>
<p>小王检查完了密码的长度，仍然觉得不够尽兴，觉得要对密码的强度也进行检查，比如说密码不能是“password”，这样的密码太弱了。于是他又开始研究起了 map() 方法，该方法可以按照一定的规则将原有 Optional 对象转换为一个新的 Optional 对象，原有的 Optional 对象不会更改。</p>
<p>先来看小王写的一个简单的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class OptionalMapDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String name = &quot;沉默王二&quot;;</span><br><span class="line">        Optional&lt;String&gt; nameOptional = Optional.of(name);</span><br><span class="line">        Optional&lt;Integer&gt; intOpt = nameOptional</span><br><span class="line">                .map(String::length);</span><br><span class="line">        </span><br><span class="line">        System.out.println( intOpt.orElse(0));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面这个例子中， map() 方法的参数 String::length ，意味着要 将原有的字符串类型的 Optional 按照字符串长度重新生成一个新的 Optional 对象，类型为 Integer。</p>
<p>搞清楚了 map() 方法的基本用法后，小王决定把 map() 方法与 filter() 方法结合起来用，前者用于将密码转化为小写，后者用于判断长度以及是否是“password”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class OptionalMapFilterDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String password = &quot;password&quot;;</span><br><span class="line">        Optional&lt;String&gt;  opt = Optional.ofNullable(password);</span><br><span class="line">        Predicate&lt;String&gt; len6 = pwd -&gt; pwd.length() &gt; 6;</span><br><span class="line">        Predicate&lt;String&gt; len10 = pwd -&gt; pwd.length() &lt; 10;</span><br><span class="line">        Predicate&lt;String&gt; eq = pwd -&gt; pwd.equals(&quot;password&quot;);</span><br><span class="line">        boolean result = opt.map(String::toLowerCase).filter(len6.and(len10 ).and(eq)).isPresent();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，我亲爱的读者朋友，以上就是本文的全部内容了——可以说是史上最佳 Optional 指南了，能看到这里的都是最优秀的程序员，二哥必须要伸出大拇指为你点个赞。</p>
<h2 id="8-3-深入浅出Lambda表达式"><a href="#8-3-深入浅出Lambda表达式" class="headerlink" title="8.3 深入浅出Lambda表达式"></a>8.3 深入浅出Lambda表达式</h2><p>今天分享的主题是《Lambda 表达式入门》，这也是之前一些读者留言强烈要求我写一写的，不好意思，让你们久等了，现在来满足你们，为时不晚吧？</p>
<p><strong>01、初识 Lambda </strong></p>
<p>Lambda 表达式描述了一个代码块（或者叫匿名方法），可以将其作为参数传递给构造方法或者普通方法以便后续执行。考虑下面这段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">() -&gt; System.out.println(&quot;沉默王二&quot;)</span><br></pre></td></tr></table></figure>
<p>来从左到右解释一下， () 为 Lambda 表达式的参数列表（本例中没有参数）， -&gt; 标识这串代码为 Lambda 表达式（也就是说，看到 -&gt; 就知道这是 Lambda）， System.out.println(“沉默王二”) 为要执行的代码，即将“沉默王二”打印到标准输出流。</p>
<p>有点 Java 基础的同学应该不会对 Runnable 接口感到陌生，这是多线程的一个基础接口，它的定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Runnable</span><br><span class="line">&#123;</span><br><span class="line">   public abstract void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Runnable 接口非常简单，仅有一个抽象方法 run() ；细心的同学会发现一个陌生的注解 @FunctionalInterface ，这个注解是什么意思呢？</p>
<p>我看了它的源码，里面有这样一段注释：</p>
<blockquote>
<p>Note that instances of functional interfaces can be created with lambda expressions, method references, or constructor references.</p>
</blockquote>
<p>大致的意思就是说，通过 @FunctionalInterface 标记的接口可以通过 Lambda 表达式创建实例。具体怎么表现呢？</p>
<p>原来我们创建一个线程并启动它是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class LamadaTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;沉默王二&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 Lambda 表达式呢？只需要下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class LamadaTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Thread(() -&gt; System.out.println(&quot;沉默王二&quot;)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是不是很妙！比起匿名内部类，Lambda 表达式不仅易于理解，更大大简化了必须编写的代码数量。</p>
<p><strong>02、Lambda 语法 </strong></p>
<p>每个 Lambda 表达式都遵循以下法则：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( parameter-list ) -&gt; &#123; expression-or-statements &#125;</span><br></pre></td></tr></table></figure>
<p>() 中的 parameter-list 是以逗号分隔的参数。你可以指定参数的类型，也可以不指定（编译器会根据上下文进行推断）。Java 11 后，还可以使用 var 关键字作为参数类型，有点 JavaScript 的味道。</p>
<p>-&gt; 相当于 Lambda 的标识符，就好像见到圣旨就见到了皇上。</p>
<p>{} 中的 expression-or-statements 为 Lambda 的主体，可以是一行语句，也可以多行。</p>
<p>可以通过 Lambda 表达式干很多事情，比如说</p>
<p>1）为变量赋值，示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Runnable r = () -&gt; &#123; System.out.println(&quot;沉默王二&quot;); &#125;;</span><br><span class="line">r.run();</span><br></pre></td></tr></table></figure>
<p>2）作为 return 结果，示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static FileFilter getFilter(String ext)</span><br><span class="line">&#123;</span><br><span class="line">    return (pathname) -&gt; pathname.toString().endsWith(ext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3）作为数组元素，示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">final PathMatcher matchers[] =</span><br><span class="line">&#123;</span><br><span class="line">        (path) -&gt; path.toString().endsWith(&quot;txt&quot;),</span><br><span class="line">        (path) -&gt; path.toString().endsWith(&quot;java&quot;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>4）作为普通方法或者构造方法的参数，示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Thread(() -&gt; System.out.println(&quot;沉默王二&quot;)).start();</span><br></pre></td></tr></table></figure>
<p>需要注意 Lambda 表达式的作用域范围。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    int limit = 10;</span><br><span class="line">    Runnable r = () -&gt; &#123;</span><br><span class="line">        int limit = 5;</span><br><span class="line">        for (int i = 0; i &lt; limit; i++)</span><br><span class="line">            System.out.println(i);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码在编译的时候会提示错误：变量 limit 已经定义过了。</p>
<p>和匿名内部类一样，不要在 Lambda 表达式主体内对方法内的局部变量进行修改，否则编译也不会通过：Lambda 表达式中使用的变量必须是 final 的。</p>
<p><img src="\assets\note\image-20231012164303511.png" alt="image-20231012164303511"></p>
<p>这个问题发生的原因是因为 Java 规范中是这样规定的：</p>
<blockquote>
<p>Any local variable, formal parameter, or exception parameter used but not declared in a lambda expression must either be declared final or be effectively final (§4.12.4), or a compile-time error occurs where the use is attempted.</p>
</blockquote>
<p>大致的意思就是说，Lambda 表达式中要用到的，但又未在 Lambda 表达式中声明的变量，必须声明为 final 或者是 effectively final，否则就会出现编译错误。</p>
<p>关于 final 和 effectively final 的区别，可能有些小伙伴不太清楚，这里多说两句。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">final int a;</span><br><span class="line">a = 1;</span><br><span class="line">// a = 2;</span><br><span class="line">// 由于 a 是 final 的，所以不能被重新赋值</span><br><span class="line">int b;</span><br><span class="line">b = 1;</span><br><span class="line">// b 此后再未更改</span><br><span class="line">// b 就是 effectively final</span><br><span class="line">int c;</span><br><span class="line">c = 1;</span><br><span class="line">// c 先被赋值为 1，随后又被重新赋值为 2</span><br><span class="line">c = 2;</span><br><span class="line">// c 就不是 effectively final</span><br></pre></td></tr></table></figure>
<p>明白了 final 和 effectively final 的区别后，我们了解到，如果把 limit 定义为 final，那就无法在 Lambda 表达式中修改变量的值。那有什么好的解决办法呢？既能让编译器不发出警告，又能修改变量的值。</p>
<p>思前想后，试来试去，我终于找到了 3 个可行的解决方案：</p>
<p>1）把 limit 变量声明为 static。</p>
<p>2）把 limit 变量声明为 AtomicInteger。</p>
<p>3）使用数组。</p>
<p>下面我们来详细地一一介绍下。</p>
<p><strong>01）把 limit 变量声明为 static </strong></p>
<p>要想把 limit 变量声明为 static，就必须将 limit 变量放在 main() 方法外部，因为 main() 方法本身是 static 的。完整的代码示例如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class ModifyVariable2StaticInsideLambda &#123;</span><br><span class="line">    static int limit = 10;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Runnable r = () -&gt; &#123;</span><br><span class="line">            limit = 5;</span><br><span class="line">            for (int i = 0; i &lt; limit; i++) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        new Thread(r).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看一下程序输出的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>OK，该方案是可行的。</p>
<p><strong>02）把 limit 变量声明为 AtomicInteger </strong></p>
<p>AtomicInteger 可以确保 int 值的修改是原子性的，可以使用 set() 方法设置一个新的 int 值， get() 方法获取当前的 int 值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class ModifyVariable2AtomicInsideLambda &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final AtomicInteger limit = new AtomicInteger(10);</span><br><span class="line">        Runnable r = () -&gt; &#123;</span><br><span class="line">            limit.set(5);</span><br><span class="line">            for (int i = 0; i &lt; limit.get(); i++) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        new Thread(r).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看一下程序输出的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<p>OK，该方案也是可行的。</p>
<p><strong>03）使用数组 </strong></p>
<p>使用数组的方式略带一些欺骗的性质，在声明数组的时候设置为 final，但更改 int 的值时却修改的是数组的一个元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class ModifyVariable2ArrayInsideLambda &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final int [] limits = &#123;10&#125;;</span><br><span class="line">        Runnable r = () -&gt; &#123;</span><br><span class="line">            limits[0] = 5;</span><br><span class="line">            for (int i = 0; i &lt; limits[0]; i++) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        new Thread(r).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看一下程序输出的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<p>OK，该方案也是可行的。</p>
<p><strong>03、Lambda 和 this 关键字 </strong></p>
<p>Lambda 表达式并不会引入新的作用域，这一点和匿名内部类是不同的。也就是说，Lambda 表达式主体内使用的 this 关键字和其所在的类实例相同。</p>
<p>来看下面这个示例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class LamadaTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new LamadaTest().work();</span><br><span class="line">    &#125;</span><br><span class="line">    public void work() &#123;</span><br><span class="line">        System.out.printf(&quot;this = %s%n&quot;, this);</span><br><span class="line">        Runnable r = new Runnable()</span><br><span class="line">        &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run()</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.printf(&quot;this = %s%n&quot;, this);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        new Thread(r).start();</span><br><span class="line">        new Thread(() -&gt; System.out.printf(&quot;this = %s%n&quot;, this)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Tips： %s 代表当前位置输出字符串， %n 代表换行符，也可以使用 \n 代替，但 %n 是跨平台的。</p>
<p>work() 方法中的代码可以分为 3 个部分：</p>
<p>1）单独的 this 关键字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.printf(&quot;this = %s%n&quot;, this);</span><br></pre></td></tr></table></figure>
<p>其中 this 为 main() 方法中通过 new 关键字创建的 LamadaTest 对象—— new LamadaTest() 。</p>
<p>2）匿名内部类中的 this 关键字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Runnable r = new Runnable()</span><br><span class="line">&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.printf(&quot;this = %s%n&quot;, this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中 this 为 work() 方法中通过 new 关键字创建的 Runnable 对象—— new Runnable(){…} 。</p>
<p><strong>3）Lambda 表达式中的 this 关键字</strong></p>
<p>其中 this 关键字和 1）中的相同。</p>
<p>我们来看一下程序的输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this = com.cmower.java_demo.journal.LamadaTest@3feba861</span><br><span class="line">this = com.cmower.java_demo.journal.LamadaTest$1@64f033cb</span><br><span class="line">this = com.cmower.java_demo.journal.LamadaTest@3feba861</span><br></pre></td></tr></table></figure>
<p>符合我们分析的预期。</p>
<p><strong>04、最后 </strong></p>
<p>尽管 Lambda 表达式在简化 Java 编程方面做了很多令人惊讶的努力，但在某些情况下，不当的使用仍然会导致不必要的混乱，大家伙慎用。</p>
<p>好了，我亲爱的读者朋友们，以上就是本文的全部内容了。能在疫情期间坚持看技术文，二哥必须要伸出大拇指为你点个赞 。原创不易，如果觉得有点用的话，请不要吝啬你手中点赞的权力——因为这将是我写作的最强动力。</p>
<h2 id="8-4-Java-14-新特性"><a href="#8-4-Java-14-新特性" class="headerlink" title="8.4 Java 14 新特性"></a>8.4 Java 14 新特性</h2><p>Java 14 的时候，新增了记录 Record、模式匹配 instanceof 等新特性，转正了 Java 12 时的 switch 表达式，我们一起来过一遍。</p>
<p><img src="\assets\note\image-20231012165354353.png" alt="image-20231012165354353"></p>
<p><strong>01、下载 JDK 14 </strong></p>
<blockquote>
<p>截止到2023年03月30日，Java 20 已经发布了，不过不是 LTS（长期支持）版本，Java 17、11、8 是目前提供支持的 LTS 版本。</p>
</blockquote>
<p>要想开箱，得先下载 JDK 14（如果你有更高版本，当然也可以），不然拿什么开箱呢，对吧？有 2 处地方可供下载，Oracle 上可以下载商用版， jdk.java.net  上可以下载开源版。我们就选择后者吧。</p>
<p><img src="\assets\note\image-20231012165434591.png" alt="image-20231012165434591"></p>
<p>我目前用的是 Windows 操作系统，所以就选择 Windows 版的 zip 包进行下载，完成后记得解压。</p>
<p><strong>02、升级 IntelliJ IDEA </strong></p>
<blockquote>
<p>截止到 2023年03月30日，Intellij IDEA 的最新版本是 2023.1。 </p>
</blockquote>
<p>需要把 IDEA 升级到抢先体验版 2020.1 EAP（如果你当前使用的版本大于此，当然也可以），否则无法支持 Java 14 的新特性。</p>
<p><img src="\assets\note\image-20231012165509661.png" alt="image-20231012165509661"></p>
<p>社区版的下载地址如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[https://www.jetbrains.com/idea/nextversion/#section=windows]</span><br><span class="line">(https://www.jetbrains.com/idea/nextversion/#section=windows)</span><br></pre></td></tr></table></figure>
<p>安装的时候可以把之前的版本卸载，也可以选择保留。完成后，我们来新建一个 Java 14 的项目。</p>
<p><img src="\assets\note\image-20231012165543125.png" alt="image-20231012165543125"></p>
<p><strong>01、instanceof </strong></p>
<p>按照新特性的顺序，我们就先从 instanceof 说起吧。旧式的 instanceof 的用法如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class OldInstanceOf &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Object str = &quot;Java 14，真香&quot;;</span><br><span class="line">        if (str instanceof String) &#123;</span><br><span class="line">            String s = (String)str;</span><br><span class="line">            System.out.println(s.length());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要先使用 instanceof 在 if 条件中判断 str 的类型是否为 String（第一步），再在  if 语句中将 str 强转为字符串类型（第二步），并且要重新声明一个变量用于强转后的赋值（第三步）。</p>
<p>三个步骤也不算多，但总觉得应该还有更好的语法，这不，Java 14 就想到了这一层。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class NewInstanceOf &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Object str = &quot;Java 14，真香&quot;;</span><br><span class="line">        if (str instanceof String s) &#123;</span><br><span class="line">            System.out.println(s.length());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以直接在 if 条件判断类型的时候添加一个变量，就不需要再强转和声明新的变量了。是不是特别简洁？但模式匹配的 instanceof 在 Java 14 中是预览版的，默认是不启用的，所以这段代码会有一个奇怪的编译错误（Java 14 中不支持模式匹配的 instanceof）。</p>
<p><img src="\assets\note\image-20231012165647328.png" alt="image-20231012165647328"></p>
<p>那怎么解决这个问题呢？需要在项目配置中手动设置一下语言的版本。</p>
<p><img src="\assets\note\image-20231012165705923.png" alt="image-20231012165705923"></p>
<p>设置完成后，编译错误就随风飘走了。程序输出的结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure>
<p>不错不错，真香。想知道 Java 编译器在背后帮我们做了什么吗？看一下反编译后的字节码就明白了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class NewInstanceOf &#123;</span><br><span class="line">    public NewInstanceOf() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Object str = &quot;Java 14，真香&quot;;</span><br><span class="line">        String s;</span><br><span class="line">        if (str instanceof String &amp;&amp; (s = (String)str) == (String)str) &#123;</span><br><span class="line">            System.out.println(s.length());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 if 条件判断前，先声明了变量 s，然后在 if  条件中进行了强转 s = (String)str) ，并且判断了 s 和 str 是否相等。确实是一个解放开放者生产力的好特性，强烈希望这个特性在下个版本中转正。</p>
<p><strong>02、Records </strong></p>
<p>在之前的一篇文章中，我谈到了类的不可变性，它是这样定义的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public final class Writer &#123;</span><br><span class="line">    private final String name;</span><br><span class="line">    private final int age;</span><br><span class="line"></span><br><span class="line">    public Writer(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么，对于 Records 来说，一条 Record 就代表一个不变的状态。尽管它会提供诸如 equals() 、hashCode() 、 toString() 、构造方法，以及字段的 getter，但它无意替代可变对象的类（没有 setter），以及 Lombok 提供的功能。</p>
<p>来用 Records 替代一下上面这个 Writer 类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public record Writer(String name, int age) &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>你看，一行代码就搞定。关键是比之前的代码功能更丰富，来看一下反编译后的字节码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public final class Writer extends java.lang.Record &#123;</span><br><span class="line">    private final java.lang.String name;</span><br><span class="line">    private final int age;</span><br><span class="line">    public Writer(java.lang.String name, int age) &#123; /* compiled code */ &#125;</span><br><span class="line">    public java.lang.String toString() &#123; /* compiled code */ &#125;</span><br><span class="line">    public final int hashCode() &#123; /* compiled code */ &#125;</span><br><span class="line">    public final boolean equals(java.lang.Object o) &#123; /* compiled code */ &#125;</span><br><span class="line">    public java.lang.String name() &#123; /* compiled code */ &#125;</span><br><span class="line">    public int age() &#123; /* compiled code */ &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类是 final 的，字段是 private final 的，构造方法有两个参数， toString() 、 hashCode() 、 equals() 方法也有了，getter 方法也有了，只不过没有 get 前缀。但是没有 setter 方法，也就是说 Records 确实针对的是不可变对象——鉴定完毕。那怎么使用 Records 呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class WriterDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Writer writer = new Writer(&quot;沉默王二&quot;,18);</span><br><span class="line">        System.out.println(&quot;toString：&quot; + writer);</span><br><span class="line">        System.out.println(&quot;hashCode：&quot; + writer.hashCode());</span><br><span class="line">        System.out.println(&quot;name：&quot; + writer.name());</span><br><span class="line">        System.out.println(&quot;age：&quot; + writer.age());</span><br><span class="line">        Writer writer1 = new Writer(&quot;沉默王二&quot;, 18);</span><br><span class="line">        System.out.println(&quot;equals：&quot; + (writer.equals(writer1)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出的结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">toString：Writer[name=沉默王二, age=18]</span><br><span class="line">hashCode：1130697218</span><br><span class="line">name：沉默王二</span><br><span class="line">age：18</span><br><span class="line">equals：true</span><br></pre></td></tr></table></figure>
<p>不错不错，真香，以后定义不可变类时就简单了，强烈希望这个特性在下个版本中转正。</p>
<p><strong>03、switch 表达式 </strong></p>
<p>关于 switch 表达式，我在之前的一篇文章中已经详细说明了，点击传送门可以跳转过去看看。两周时间过去了，switch 表达式终于“媳妇熬成婆”，转正了，恭喜恭喜。</p>
<p>记得这篇文章发表到掘金的时候，被喷子各种无脑 diss，说：“还以为你有什么技巧，没想到用的是 Java 13，可我们还停留在 Java 8 啊！”这显然是一种固步自封的心态，非常不可取，程序员不应该这样。一个最简单的道理就是，Java 6 当年也很经典，不是被 Java 8 取代了吗？随着时间的推移，Java 8 早晚会被更划时代的新版本取代——总要进步嘛。</p>
<p>关于 switch 表达式，这里就简单地搬个例子给你瞧瞧：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class SwitchDemo &#123;</span><br><span class="line">    enum PlayerTypes &#123;</span><br><span class="line">        TENNIS,</span><br><span class="line">        FOOTBALL,</span><br><span class="line">        BASKETBALL,</span><br><span class="line">        PINGPANG,</span><br><span class="line">        UNKNOWN</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(createPlayer(PlayerTypes.BASKETBALL));</span><br><span class="line">    &#125;</span><br><span class="line">    private static String createPlayer(PlayerTypes playerType) &#123;</span><br><span class="line">        return switch (playerType) &#123;</span><br><span class="line">            case TENNIS -&gt; &quot;网球运动员费德勒&quot;;</span><br><span class="line">            case FOOTBALL -&gt; &quot;足球运动员C罗&quot;;</span><br><span class="line">            case BASKETBALL -&gt; &quot;篮球运动员詹姆斯&quot;;</span><br><span class="line">            case PINGPANG -&gt; &quot;乒乓球运动员马龙&quot;;</span><br><span class="line">            case UNKNOWN -&gt; throw new IllegalArgumentException(&quot;未知&quot;);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了可以使用 -&gt; 的新式语法，还可以作为 return 结果，真香。</p>
<p><strong>04、Text Blocks </strong></p>
<p>在文本块（Text Blocks）出现之前，如果我们需要拼接多行的字符串，就需要很多英文双引号和加号，看起来就好像老太婆的裹脚布，非常不雅。如果恰好要拼接一些 HTML 格式的文本（原生 SQL 也是如此）的话，还要通过空格进行排版，通过换行转义符 \n 进行换行，这些繁琐的工作对于一名开发人员来说，简直就是灾难。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class OldTextBlock &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String html = &quot;&lt;html&gt;\n&quot; +</span><br><span class="line">                &quot;    &lt;body&gt;\n&quot; +</span><br><span class="line">                &quot;        &lt;p&gt;Hello, world&lt;/p&gt;\n&quot; +</span><br><span class="line">                &quot;    &lt;/body&gt;\n&quot; +</span><br><span class="line">                &quot;&lt;/html&gt;\n&quot;;</span><br><span class="line">        System.out.println(html);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java 14 就完全不同了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class NewTextBlock &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String html = &quot;&quot;&quot;</span><br><span class="line">              &lt;html&gt;</span><br><span class="line">                  &lt;body&gt;</span><br><span class="line">                      &lt;p&gt;Hello, world&lt;/p&gt;</span><br><span class="line">                  &lt;/body&gt;</span><br><span class="line">              &lt;/html&gt;</span><br><span class="line">              &quot;&quot;&quot;;</span><br><span class="line">        System.out.println(html);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多余的英文双引号、加号、换行转义符，统统不见了。仅仅是通过前后三个英文双引号就实现了。我只能说，香，它真的香！</p>
<h1 id="9-Java-网络编程"><a href="#9-Java-网络编程" class="headerlink" title="9 Java 网络编程"></a>9 Java 网络编程</h1><h2 id="9-1-了解网络编程的基础知识"><a href="#9-1-了解网络编程的基础知识" class="headerlink" title="9.1 了解网络编程的基础知识"></a>9.1 了解网络编程的基础知识</h2><p>   在学习 Java 网络编程之前，我们先来了解什么是计算机网络。</p>
<p>   计算机网络是指两台或更多的计算机组成的网络，在同一个网络中，任意两台计算机都可以直接通信，因为所有计算机都需要遵循同一种网络协议。</p>
<p>   下面是一张简化的网络拓扑图。</p>
<p><img src="\assets\note\image-20231012170657008.png" alt="image-20231012170657008"></p>
<ul>
<li>用户设备：Laptop，用于访问网络资源。</li>
<li>网络交换机：Switch，用于连接局域网内的设备，例如 Laptop 和 Router。</li>
<li>路由器：Router，用于连接不同网络，将局域网与互联网相连。</li>
<li>防火墙：Firewall，用于保护网络内部资源，阻止未经授权的访问。</li>
<li>互联网：Internet，提供连接到其他网络和全球信息资源。</li>
<li><p>服务器：Server，用于托管网络应用程序和数据。</p>
<p>那什么是互联网呢？互联网是网络的网络（Internet），即把很多计算机网络连接起来，形成一个全球统一的互联网。</p>
<p>对某个特定的计算机网络来说，它可能使用网络协议 ABC，而另一个计算机网络可能使用网络协议 XYZ。如果计算机网络各自的通讯协议不统一，就没法把不同的网络连接起来形成互联网。因此，为了把计算机网络接入互联网，就必须使用 TCP/IP 协议。</p>
</li>
</ul>
<p>TCP/IP 协议泛指互联网协议，其中最重要的两个协议是 TCP 协议和 IP 协议。只有使用 TCP/IP 协议的计算机才能够联入互联网，使用其他网络协议（例如 NetBIOS、AppleTalk 协议等）是无法联入互联网的。</p>
<p><strong>IP 地址 </strong></p>
<p>  在互联网中，一个 IP 地址用于唯一标识一个网络接口（Network Interface）。一台联入互联网的计算机肯定有一个 IP 地址，但也可能有多个 IP 地址。</p>
<p> IP 地址分为 IPv4 和 IPv6 两种。IPv4 采用 32 位地址，类似 101.202.99.12 ，而 IPv6 采用 128 位地址，类似 2001:0DA8:100A:0000:0000:1020:F2F3:1428 。IPv4 地址总共有 232 个（大约 42 亿），而 IPv6 地址则总共有 2128 个（大约 340 万亿亿亿亿），IPv4 的地址目前已耗尽，而 IPv6 的地址是根本用不完的。</p>
<p> IP 地址又分为公网 IP 地址和内网 IP 地址。公网 IP 地址可以直接被访问，内网 IP 地址只能在内网访问。内网 IP 地址类似于：</p>
<ul>
<li>192.168.x.x</li>
<li><p>10.x.x.x</p>
<p> 有一个特殊的 IP 地址，称之为本机地址，它总是 127.0.0.1 。</p>
<p> IPv4 地址实际上是一个 32 位整数。例如：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1707762444 = 0x65ca630c</span><br><span class="line">           = 65  ca  63 0c</span><br><span class="line">           = 101.202.99.12</span><br></pre></td></tr></table></figure>
<p>   如果一台计算机只有一个网卡，并且接入了网络，那么，它有一个本机地址 127.0.0.1 ，还有一个 IP 地址，例如 101.202.99.12 ，可以通过这个 IP 地址接入网络。</p>
<p>   如果一台计算机有两块网卡，那么除了本机地址，它可以有两个 IP 地址，可以分别接入两个网络。通常连接两个网络的设备是路由器或者交换机，它至少有两个 IP 地址，分别接入不同的网络，让网络之间连接起来。</p>
<p>  如果两台计算机位于同一个网络，那么他们之间可以直接通信，因为他们的 IP 地址前段是相同的，也就是网络号是相同的。网络号是 IP 地址通过子网掩码过滤后得到的。例如：</p>
<p>   某台计算机的 IP 是 101.202.99.2 ，子网掩码是 255.255.255.0 ，那么计算该计算机的网络号是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IP = 101.202.99.2</span><br><span class="line">Mask = 255.255.255.0</span><br><span class="line">Network = IP &amp; Mask = 101.202.99.0</span><br></pre></td></tr></table></figure>
<p>   每台计算机都需要正确配置 IP 地址和子网掩码，根据这两个就可以计算网络号，如果两台计算机计算出的网络号相同，说明两台计算机在同一个网络，可以直接通信。如果两台计算机计算出的网络号不同，那么两台计算机不在同一个网络，不能直接通信，它们之间必须通过路由器或者交换机这样的网络设备间接通信，我们把这种设备称为网关。</p>
<p>   网关的作用就是连接多个网络，负责把来自一个网络的数据包发到另一个网络，这个过程叫路由。</p>
<p>   所以，一台计算机的一个网卡会有 3 个关键配置：</p>
<ul>
<li>IP 地址，例如： 10.0.2.15</li>
<li>子网掩码，例如： 255.255.255.0</li>
<li>网关的 IP 地址，例如： 10.0.2.2</li>
</ul>
<p><em>域名 *</em></p>
<p>   因为直接记忆 IP 地址非常困难，所以我们通常使用域名访问某个特定的服务。域名解析服务器 DNS 负责把域名翻译成对应的 IP，客户端再根据 IP 地址访问服务器。</p>
<p>   用 nslookup可以查看域名对应的 IP 地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ nslookup www.tobebetterjavaer.com</span><br><span class="line">Server:  xxx.xxx.xxx.xxx</span><br><span class="line">Address: xxx.xxx.xxx.xxx#53</span><br><span class="line">Non-authoritative answer:</span><br><span class="line">Name:    www.tobebetterjavaer.com</span><br><span class="line">Address: 47.98.33.223</span><br></pre></td></tr></table></figure>
<p>有一个特殊的本机域名 localhost ，它对应的 IP 地址总是本机地址 127.0.0.1 。</p>
<p><strong>网络模型 </strong></p>
<p>由于计算机网络从底层的传输到高层的软件设计十分复杂，要合理地设计计算机网络模型，必须采用分层模型，每一层负责处理自己的操作。OSI（Open System Interconnect）网络模型是 ISO 组织定义的一个计算机互联的标准模型，注意它只是一个定义，目的是为了简化网络各层的操作，提供标准接口便于实现和维护。这个模型从上到下依次是：</p>
<ul>
<li>应用层，提供应用程序之间的通信；</li>
<li>表示层：处理数据格式，加解密等等；</li>
<li>会话层：负责建立和维护会话；</li>
<li>传输层：负责提供端到端的可靠传输；</li>
<li>网络层：负责根据目标地址选择路由来传输数据；</li>
<li>链路层和物理层负责把数据进行分片并且真正通过物理网络传输，例如，无线网、光纤等。</li>
</ul>
<p>互联网实际使用的 TCP/IP 模型并不是对应到 OSI 的 7 层模型，而是大致对应 OSI 的 5 层模型：</p>
<p><img src="\assets\note\image-20231012171450388.png" alt="image-20231012171450388"></p>
<p><strong>常用协议 </strong></p>
<p>IP 协议是一个分组交换，它不保证可靠传输。而 TCP 协议是传输控制协议，它是面向连接的协议，支持可靠传输和双向通信。TCP 协议是建立在 IP 协议之上的，简单地说，IP 协议只负责发数据包，不保证顺序和正确性，而 TCP 协议负责控制数据包传输，它在传输数据之前需要先建立连接，建立连接后才能传输数据，传输完后还需要断开连接。TCP 协议之所以能保证数据的可靠传输，是通过接收确认、超时重传这些机制实现的。并且，TCP 协议允许双向通信，即通信双方可以同时发送和接收数据。</p>
<p>TCP 协议也是应用最广泛的协议，许多高级协议都是建立在 TCP 协议之上的，例如 HTTP、SMTP 等。</p>
<p>TCP（传输控制协议）和 IP（互联网协议）通常一起使用，被称为 TCP/IP 协议。</p>
<p>TCP/IP 协议栈分为四层：应用层、传输层、网络层和链路层。IP 协议位于网络层，负责将数据包从源主机路由到目标主机；TCP 协议位于传输层，负责在源主机和目标主机之间建立可靠的连接并确保数据的有序传输。</p>
<p><img src="\assets\note\image-20231012171611979.png" alt="image-20231012171611979"></p>
<p>UDP 协议（User Datagram Protocol）是一种数据报文协议，它是无连接协议，不保证可靠传输。因为 UDP 协议在通信前不需要建立连接，因此它的传输效率比 TCP 高，而且 UDP 协议比 TCP 协议要简单得多。<br><img src="\assets\note\image-20231012171715508.png" alt="image-20231012171715508"></p>
<p>选择 UDP 协议时，传输的数据通常是能容忍丢失的，例如，一些语音视频通信的应用会选择 UDP 协议。</p>
<p><strong>小结 </strong></p>
<p>计算机网络的基本概念主要有：</p>
<ul>
<li>计算机网络：由两台或更多计算机组成的网络；</li>
<li>互联网：连接网络的网络；</li>
<li>IP 地址：计算机的网络接口（通常是网卡）在网络中的唯一标识；</li>
<li>网关：负责连接多个网络，并在多个网络之间转发数据的计算机，通常是路由器或交换机；</li>
<li>网络协议：互联网使用 TCP/IP 协议，它泛指互联网协议簇；</li>
<li>IP 协议：一种分组交换传输协议；</li>
<li>TCP 协议：一种面向连接，可靠传输的协议；</li>
<li>UDP 协议：一种无连接，不可靠传输的协议。</li>
</ul>
<h2 id="9-2-网络编程的核心套接字Socket"><a href="#9-2-网络编程的核心套接字Socket" class="headerlink" title="9.2 网络编程的核心套接字Socket"></a>9.2 网络编程的核心套接字Socket</h2><p>在古代，由于通信不便利，一些聪明的人就利用鸽子会飞且飞得比较快、会辨认方向的优点，对其进行了驯化，用来进行消息的传递——也就是所谓的“飞鸽传书”。而在 Java 中，网络套接字（Socket）扮演了同样的角色。</p>
<p>套接字（Socket）是一个抽象层，应用程序可以通过它发送或接收数据；就像操作文件那样可以打开、读写和关闭。套接字允许应用程序将 I/O 应用于网络中，并与其他应用程序进行通信。网络套接字是 IP 地址与端口的组合。</p>
<p><strong>01、ping 与 telnet </strong></p>
<p>“老王啊，能不能帮我看一下这个问题呢，明明本地可以进行网络通信，可等我部署到服务器上时就通信不了了，搞了半天也不知道什么原因，我看代码是没有问题的。”小二的语气中充满了沮丧。</p>
<p>“ping 过吗？或者 telnet 了吗？”老王头都没回，冷冰冰地扔出去了这句话。</p>
<p>“哦，我去试试。”小二心头掠过一丝愧疚。</p>
<p>ping 与 telnet 这两个命令，对调试网络程序有着非常大的帮助。</p>
<p>ping，一种计算机网络工具，用来测试数据包能否透过 IP 协议到达特定主机。ping 会向目标主机发出一个 ICMP 的请求回显数据包，并等待接收回显响应数据包。</p>
<p>例如，我们 ping 一下博客园。截图如下。</p>
<p><img src="\assets\note\image-20231012172050272.png" alt="image-20231012172050272"></p>
<p>telnet，Internet 远程登录服务的标准协议和主要方式，可以让我们坐在家里的计算机面前，登录到另一台远在天涯海角的远程计算机上。</p>
<p><img src="\assets\note\image-20231012172107961.png" alt="image-20231012172107961"></p>
<p>在 Windows 系统中，telnet 一般是默认安装的，但未激活（可以在控制面板中激活它）。</p>
<p>例如，我们 telnet 一下火（shui）土（mu）社区。截图如下。</p>
<p><img src="\assets\note\image-20231012172144042.png" alt="image-20231012172144042"></p>
<p>使用 telnet 登录远程计算机时，需要远程计算机上运行一个服务，它一直不停地等待那些希望和它进行连接的网络请求；当接收到一个客户端的网络连接时，它便唤醒正在监听网络连接请求的服务器进程，并为两者建立连接。连接会一直保持，直到某一方中止。</p>
<p>不过，需要注意的是，telnet 在格外重视安全的现代网络技术中并不受到重用。因为 telnet 是一个明文传输协议，用户的所有内容（包括用户名和密码）都没有经过加密，安全隐患非常大。</p>
<p><strong>02、Socket 实例 </strong></p>
<p>不知道你有没有体验一下 telnet 火土社区的那条命令，结果非常有趣。我们也可以通过 Java 的客户端套接字（Socket）实现，代码示例如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">try (Socket socket = new Socket(&quot;bbs.newsmth.net&quot;, 23);) &#123;</span><br><span class="line">    InputStream is = socket.getInputStream();</span><br><span class="line">    Scanner scanner = new Scanner(is, &quot;gbk&quot;);</span><br><span class="line">    while (scanner.hasNextLine()) &#123;</span><br><span class="line">        String line = scanner.nextLine();</span><br><span class="line">        System.out.println(line);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; catch (UnknownHostException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1）建立套接字连接非常简单，只需要一行代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Socket socket = new Socket(host, port)</span><br></pre></td></tr></table></figure>
<p>host 为主机名，port 为端口号（23 为默认的 telnet 端口号）。如果无法确定主机的 IP 地址，则抛出 UnknownHostException 异常；如果在创建套接字时发生 IO 错误，则抛出 IOException 异常。</p>
<p>需要注意的是，套接字在建立的时候，如果远程主机不可访问，这段代码就会阻塞很长时间，直到底层操作系统的限制而抛出异常。所以一般会在套接字建立后设置一个超时时间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Socket socket = new Socket(...);</span><br><span class="line">socket.setSoTimeout(10000); // 单位为毫秒</span><br></pre></td></tr></table></figure>
<p>2）套接字连接成功后，可以通过 java.net.Socket 类的 getInputStream() 方法获取输入流。有了 InputStream 对象后，可以借助文本扫描器类（Scanner）将其中的内容打印出来。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">InputStream is = socket.getInputStream();</span><br><span class="line">Scanner scanner = new Scanner(is, &quot;gbk&quot;);</span><br><span class="line">while (scanner.hasNextLine()) &#123;</span><br><span class="line">    String line = scanner.nextLine();</span><br><span class="line">    System.out.println(line);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>部分结果（完整结果自己亲手实践一下哦）如下图所示：</p>
<p><img src="\assets\note\image-20231012172449644.png" alt="image-20231012172449644"></p>
<p><strong>03、ServerSocket 实例 </strong></p>
<p>接下来，我们模拟一个远程服务，通过 java.net.ServerSocket 实现。代码示例如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">try (ServerSocket server = new ServerSocket(8888);</span><br><span class="line">        Socket socket = server.accept();</span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line">        Scanner scanner = new Scanner(is)) &#123;</span><br><span class="line">    PrintWriter pw = new PrintWriter(new OutputStreamWriter(os, &quot;gbk&quot;), true);</span><br><span class="line">    pw.println(&quot;你好啊，欢迎关注「沉默王二」 公众号，回复关键字「2048」 领取程序员进阶必读资料</span><br><span class="line">包&quot;);</span><br><span class="line">    boolean done = false;</span><br><span class="line">    while (!done &amp;&amp; scanner.hasNextLine()) &#123;</span><br><span class="line">        String line = scanner.nextLine();</span><br><span class="line">        System.out.println(line);</span><br><span class="line">        if (&quot;2048&quot;.equals(line)) &#123;</span><br><span class="line">            done = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; catch (UnknownHostException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1）建立服务器端的套接字也比较简单，只需要指定一个能够独占的端口号就可以了（0~1023 这些端口都已经被系统预留了）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerSocket server = new ServerSocket(8888);</span><br></pre></td></tr></table></figure>
<p>2）调用 ServerSocket 对象的 accept() 等待客户端套接字的连接请求。一旦监听到客户端的套接字请求，就会返回一个表示连接已建立的 Socket 对象，可以从中获取到输入流和输出流。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Socket socket = server.accept();</span><br><span class="line">InputStream is = socket.getInputStream();</span><br><span class="line">OutputStream os = socket.getOutputStream();</span><br></pre></td></tr></table></figure>
<p>客户端套接字发送的所有信息都会包裹在服务器端套接字的输入流中；而服务器端套接字发送的所有信息都会包裹在客户端套接字的输出流中。</p>
<p>3）服务器端可以通过以下代码向客户端发送消息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PrintWriter pw = new PrintWriter(new OutputStreamWriter(os, &quot;gbk&quot;), true);</span><br><span class="line">pw.println(&quot;你好啊，欢迎关注「沉默王二」 公众号，回复关键字「2048」 领取程序员进阶必读资料包&quot;);</span><br></pre></td></tr></table></figure>
<p>4）服务器端可以通过以下代码读取客户端发送过来的消息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Scanner scanner = new Scanner(is);</span><br><span class="line">boolean done = false;</span><br><span class="line">while (!done &amp;&amp; scanner.hasNextLine()) &#123;</span><br><span class="line">    String line = scanner.nextLine();</span><br><span class="line">    System.out.println(line);</span><br><span class="line">    if (&quot;2048&quot;.equals(line)) &#123;</span><br><span class="line">        done = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行该服务后，可以通过 telnet localhost 8888 命令连接该远程服务，不出所料，你将会看到以下信息。</p>
<p><img src="\assets\note\image-20231012172655575.png" alt="image-20231012172655575"></p>
<p>PS：可以在当前命令窗口中输入 2048，服务端收到该消息后会中断该套接字连接（当前窗口会显示“遗失对主机的连接”）。</p>
<p><strong>04、为多个客户端服务 </strong></p>
<p>非常遗憾的是，上面的例子中，服务器端只能为一个客户端服务——这不符合服务器端一对多的要求。</p>
<p>优化方案也非常简单（你应该也能想得到）：服务器端接收到客户端的套接字请求时，可以启动一个线程来处理，而主程序继续等待下一个连接。代码示例如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">try (ServerSocket server = new ServerSocket(8888)) &#123;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        Socket socket = server.accept();</span><br><span class="line">        Thread thread = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">              // 套接字处理程序</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程内部（ run(){} 方法里）用来处理套接字，代码示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    InputStream is = socket.getInputStream();</span><br><span class="line">    OutputStream os = socket.getOutputStream();</span><br><span class="line">    Scanner scanner = new Scanner(is);</span><br><span class="line">   // 其他代码省略</span><br><span class="line">   // 向客户端发送消息</span><br><span class="line">   // 读取客户端发送过来的消息</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务器端代码优化后重新运行，你就可以通过 telnet 命令测试了。打开一个命令行窗口输入 telnet localhost 8888 ，再打开一个新的命令行窗口输入 telnet localhost 8888 ，多个窗口都可以和服务器端进行通信，除非服务器端代码中断运行。</p>
<p><strong>05、加入多线程 </strong></p>
<p>多线程我们后面会详细讲，这里就主要是写个例子，好让大家感觉更有趣一些，其实也非常简单。</p>
<p>来看服务端：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">import java.net.ServerSocket;</span><br><span class="line">import java.net.Socket;</span><br><span class="line">public class MultiThreadedServer &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        int port = 12345;</span><br><span class="line">        ServerSocket serverSocket = new ServerSocket(port);</span><br><span class="line">        System.out.println(&quot;Server is listening on port &quot; + port);</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            Socket socket = serverSocket.accept();</span><br><span class="line">            System.out.println(&quot;Client connected&quot;);</span><br><span class="line">            new ClientHandler(socket).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class ClientHandler extends Thread &#123;</span><br><span class="line">    private Socket socket;</span><br><span class="line">    public ClientHandler(Socket socket) &#123;</span><br><span class="line">        this.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            InputStream input = socket.getInputStream();</span><br><span class="line">            BufferedReader reader = new BufferedReader(new InputStreamReader(input));</span><br><span class="line">            OutputStream output = socket.getOutputStream();</span><br><span class="line">            PrintWriter writer = new PrintWriter(output, true);</span><br><span class="line">            String line;</span><br><span class="line">            while ((line = reader.readLine()) != null) &#123;</span><br><span class="line">                System.out.println(&quot;Received: &quot; + line);</span><br><span class="line">                writer.println(&quot;Server: &quot; + line);</span><br><span class="line">            &#125;</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            System.out.println(&quot;Client disconnected&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们使用了一个 ClientHandler 类，该类继承自 Thread 类。这使得每个客户端连接都可以在单独的线程中处理，从而允许服务器同时处理多个客户端连接。当一个新客户端连接到服务器时，服务器会创建一个新的 ClientHandler 对象，并使用 start() 方法启动线程。ClientHandler 类的 run() 方法包含处理客户端请求的逻辑。</p>
<p>来看客户端代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">import java.net.Socket;</span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        String hostname = &quot;localhost&quot;;</span><br><span class="line">        int port = 12345;</span><br><span class="line">        Socket socket = new Socket(hostname, port);</span><br><span class="line">        System.out.println(&quot;Connected to the server&quot;);</span><br><span class="line">        InputStream input = socket.getInputStream();</span><br><span class="line">        BufferedReader reader = new BufferedReader(new InputStreamReader(input));</span><br><span class="line">        OutputStream output = socket.getOutputStream();</span><br><span class="line">        PrintWriter writer = new PrintWriter(output, true);</span><br><span class="line">        writer.println(&quot;Hello, server!&quot;);</span><br><span class="line">        String response = reader.readLine();</span><br><span class="line">        System.out.println(&quot;Server response: &quot; + response);</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动服务器端，然后多启动几个客户端，就可以体验到交互的乐趣了。</p>
<p><img src="\assets\note\image-20231012173056208.png" alt="image-20231012173056208"></p>
<p><strong>08、DatagramSocket 实例 </strong></p>
<p>DatagramSocket 类是 Java 中实现 UDP 协议的核心类。与基于 TCP 的 Socket 和 ServerSocket 类不同，DatagramSocket 类提供了无连接的通信服务，发送和接收数据包。由于无需建立连接，UDP 通常比 TCP 更快，但可能不如 TCP 可靠。</p>
<p>以下是一个简单的 DatagramSocket 示例，展示了如何使用 UDP 协议在客户端和服务器之间发送和接收消息。</p>
<p>服务器端代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.DatagramPacket;</span><br><span class="line">import java.net.DatagramSocket;</span><br><span class="line">public class UDPServer &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        int port = 12345;</span><br><span class="line">        DatagramSocket serverSocket = new DatagramSocket(port);</span><br><span class="line">        System.out.println(&quot;Server is listening on port &quot; + port);</span><br><span class="line">        byte[] buffer = new byte[1024];</span><br><span class="line">        DatagramPacket packet = new DatagramPacket(buffer, buffer.length);</span><br><span class="line">        serverSocket.receive(packet);</span><br><span class="line">        String message = new String(packet.getData(), 0, packet.getLength());</span><br><span class="line">        System.out.println(&quot;Received: &quot; + message);</span><br><span class="line">        serverSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.*;</span><br><span class="line">public class UDPClient &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        String hostname = &quot;localhost&quot;;</span><br><span class="line">        int port = 12345;</span><br><span class="line">        InetAddress address = InetAddress.getByName(hostname);</span><br><span class="line">        DatagramSocket clientSocket = new DatagramSocket();</span><br><span class="line">        String message = &quot;Hello, server!&quot;;</span><br><span class="line">        byte[] buffer = message.getBytes();</span><br><span class="line">        DatagramPacket packet = new DatagramPacket(buffer, buffer.length, address, </span><br><span class="line">port);</span><br><span class="line">        clientSocket.send(packet);</span><br><span class="line">        System.out.println(&quot;Message sent&quot;);</span><br><span class="line">        clientSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，服务器端创建一个 DatagramSocket 对象并监听端口 12345。然后，它创建一个 DatagramPacket 对象，用于存储接收到的数据包。 serverSocket.receive(packet) 方法阻塞，直到收到一个数据包。收到数据包后，服务器从数据包中提取并打印消息。</p>
<p>客户端首先解析服务器的 IP 地址，然后创建一个 DatagramSocket 对象。接着，客户端创建一个包含要发送消息的 DatagramPacket 对象，并指定目标地址和端口。最后，客户端通过调用 clientSocket.send(packet) 方法发送数据包。</p>
<p>运行结果如下所示：</p>
<p><img src="\assets\note\image-20231012173305989.png" alt="image-20231012173305989"></p>
<p><strong>07、最后 </strong></p>
<p>如今大多数基于网络的软件，如浏览器、即时通讯工具甚至是 P2P 下载都是基于 Socket 实现的，所以掌握 Java Socket 编程还是蛮有必要的。Socket 编程也比较有趣，很多初学者都会编写一两个基于“客户端-服务器端”的小程序来提高自己的编程水平，建议你也试一试。</p>
<h2 id="9-3-用Socket实现一个HTTP服务器"><a href="#9-3-用Socket实现一个HTTP服务器" class="headerlink" title="9.3 用Socket实现一个HTTP服务器"></a>9.3 用Socket实现一个HTTP服务器</h2><p>作为一个 Java 后端，提供 HTTP 服务可以说是基本技能之一了，但是你真的了解 HTTP 协议么？你知道知道如何手撸一个 HTTP 服务器么？Tomcat 的底层是怎么支持 HTTP 服务的呢？大名鼎鼎的 Servlet 又是什么东西呢，该怎么使用呢？</p>
<p>在初学 Java 时，Socket 编程是逃不掉的一章；虽然在实际业务项目中，使用这个的可能性基本为 0， 但并不意味着不用学。本篇将主要介绍如何使用 Socket 来实现一个简单的 HTTP 服务器，提供常见的 get/post 请求支持，并在此过程中了解下 HTTP 协议。</p>
<p><strong>I. HTTP 服务器从 0 到 1 </strong></p>
<p>既然我们的目标是借助 Socket 来搭建 HTTP 服务器，那么我们首先需要确认两点，一是如何使用 Socket；另一个则是 HTTP 协议如何解析数据；下面分别进行说明。</p>
<p><strong>1.Socket 编程基础 </strong></p>
<p>我们这里主要是利用 ServerSocket 来绑定端口，提供 TCP 服务，基本使用姿势也比较简单，一般套路如下</p>
<ul>
<li>创建 ServerSocket 对象，绑定监听端口</li>
<li>通过 accept() 方法监听客户端请求</li>
<li>连接建立后，通过输入流读取客户端发送的请求信息</li>
<li>通过输出流向客户端发送响应信息</li>
<li>关闭相关资源</li>
</ul>
<p>对应的伪代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ServerSocket serverSocket = new ServerSocket(port, ip)</span><br><span class="line">serverSocket.accept();</span><br><span class="line">// 接收请求数据</span><br><span class="line">socket.getInputStream();</span><br><span class="line">// 返回数据给请求方</span><br><span class="line">out = socket.getOutputStream()</span><br><span class="line">out.print(xxx)</span><br><span class="line">out.flush();;</span><br><span class="line">// 关闭连接</span><br><span class="line">socket.close()</span><br></pre></td></tr></table></figure>
<p>具体的代码，我们前面的章节详细地讲过了，第一次来的小伙伴可以戳链接去学习一下。</p>
<p><strong>2.HTTP 协议 </strong></p>
<p>ServerSocket 走的是 TCP 协议，HTTP 协议本身是在 TCP 协议之上的一层。</p>
<p>TCP 是一种面向连接的、可靠的、基于字节流的传输层协议。TCP 在两个网络节点之间提供了一条可靠的通信信道，确保数据在传输过程中不会丢失、重复或乱序。TCP 使用握手过程建立连接，通过确认和重传机制确保数据可靠传输，并使用流量控制和拥塞控制算法来优化网络性能。</p>
<p>HTTP 是一个用于在 Web 浏览器和 Web 服务器之间传输超文本、图像、视频和其他媒体资源的应用层协议。HTTP 使用请求-响应模型，即客户端（通常是 Web 浏览器）发送请求给服务器，服务器处理请求并返回响应。HTTP 协议定义了一组方法（如 GET、POST、PUT、DELETE 等），用于指定请求的类型和目的。</p>
<p>此外，HTTP 协议还定义了一组状态代码（如 200、404、500 等），用于表示响应的结果。</p>
<p>HTTP 协议依赖于 TCP 协议来传输数据。当 Web 浏览器向 Web 服务器发送 HTTP 请求时，它首先使用 TCP 协议与服务器建立连接。一旦连接建立，HTTP 请求消息会被封装在 TCP 数据包中，然后通过 TCP 信道发送给服务器。服务器收到 TCP 数据包后，解包提取 HTTP 请求消息，处理请求并生成 HTTP 响应消息。最后，HTTP 响应消息被封装在 TCP 数据包中，并通过相同的 TCP 信道发送回客户端。客户端收到 TCP 数据包后，解包提取 HTTP 响应消息并显示给用户。</p>
<p><img src="\assets\note\image-20231012173621334.png" alt="image-20231012173621334"></p>
<p>这幅图展示了客户端（Web 浏览器）与服务器（Web 服务器）之间的 HTTP 请求和响应，它们通过可靠的、面向连接的 TCP 连接进行数据传输。</p>
<p>好，再说回 HTTP 服务器这件事，最需要关注的无非两点：</p>
<ul>
<li>请求的数据怎么按照 HTTP 协议解析出来</li>
<li>如何按照 HTTP 协议，返回数据</li>
</ul>
<p>所以我们需要知道数据格式的规范。</p>
<p><strong>请求消息</strong></p>
<p>HTTP 请求消息由请求行（Request Line）、请求头（Request Headers）、空行（Empty Line）、请求体（Request Body，可选）几个部分组成。</p>
<p>①、请求行又包含三个部分，HTTP 方法（例如 GET, POST, PUT, DELETE 等）、请求的目标 URL（通常是相对 URL，但也可以是绝对 URL）、HTTP 版本（例如 HTTP/1.1 或 HTTP/2），这些部分用空格分隔，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html HTTP/1.1</span><br></pre></td></tr></table></figure>
<p>②、请求头是一系列以键值对表示的元数据，用于描述请求的附加信息。每个请求头占一行，键和值之间用冒号（:）分隔。请求头包含诸如 Host、User-Agent、Content-Type、Content-Length、Accept 等信息。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Host: www.tobebetterjavaer.com</span><br><span class="line">User-Agent: Mozilla/5.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br></pre></td></tr></table></figure>
<p>③、请求头和请求体之间有一个空行，表示请求头的结束。</p>
<p>④、对于某些 HTTP 方法（例如 POST、PUT 等），还可以在请求消息中包含请求体。请求体用于传输要发送给服务器的数据。请求体的格式和内容取决于 Content-Type 请求头的值。</p>
<p>例如，当提交 HTML 表单时，请求体可能如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username=沉默王二&amp;password=123456</span><br></pre></td></tr></table></figure>
<p>将这些部分放在一起，就构成了一个完整的 HTTP 请求消息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST /login HTTP/1.1</span><br><span class="line">Host: Host: www.tobebetterjavaer.com</span><br><span class="line">User-Agent: Mozilla/5.0</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 29</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">username=沉默王二&amp;password=123456</span><br></pre></td></tr></table></figure>
<p>我用一张思维导图来表示下：</p>
<p><img src="\assets\note\image-20231012173838462.png" alt="image-20231012173838462"></p>
<p><strong>响应消息</strong></p>
<p>一个典型的 HTTP 响应消息由三部分组成：状态行（Status Line）、响应头（Response Headers）、响应体（Response Body）。</p>
<p><img src="\assets\note\image-20231012173958294.png" alt="image-20231012173958294"></p>
<p>上面两张图，可以让你对 HTTP 请求和响应有个直观映象，接下来开始抓重点。</p>
<p>不管是请求消息还是响应消息，都可以划分为三部分，这就为我们后面的处理简化了很多工作。</p>
<ul>
<li>第一行：状态行</li>
<li>第二行到第一个空行：header（请求头/相应头）</li>
<li>剩下所有：正文</li>
</ul>
<p><strong>3.HTTP 服务器设计 </strong></p>
<p>接下来进入正题，基于 Socket 创建一个 HTTP 服务器，使用 Socket 基本没啥太大的问题，我们需要额外关注以下两点：</p>
<ul>
<li>对请求数据进行解析</li>
<li>封装返回结果</li>
</ul>
<p><strong>a. 请求数据解析 </strong></p>
<p>我们从 Socket 中拿到所有的数据，然后解析为对应的 HTTP 请求，我们先定义个 Request 对象，内部保存一些基本的 HTTP 信息，接下来重点就是将 Socket 中的所有数据都捞出来，封装为 request 对象。</p>
<blockquote>
<p>注意 ，这些代码放在 HttpMessageParser 类中，随后会给出完整的代码。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public static class Request &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 请求方法 GET/POST/PUT/DELETE/OPTION...</span><br><span class="line">     */</span><br><span class="line">    private String method;</span><br><span class="line">    /**</span><br><span class="line">     * 请求的uri</span><br><span class="line">     */</span><br><span class="line">    private String uri;</span><br><span class="line">    /**</span><br><span class="line">     * HTTP版本</span><br><span class="line">     */</span><br><span class="line">    private String version;</span><br><span class="line">    /**</span><br><span class="line">     * 请求头</span><br><span class="line">     */</span><br><span class="line">    private Map&lt;String, String&gt; headers;</span><br><span class="line">    /**</span><br><span class="line">     * 请求参数相关</span><br><span class="line">     */</span><br><span class="line">    private String message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据前面的 HTTP 协议介绍，解析过程如下，我们先看请求行的解析过程。</p>
<p>请求行，包含三个基本要素：请求方法 + URI + HTTP 版本，用空格进行分割，所以解析代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 根据标准的HTTP协议，解析请求行</span><br><span class="line"> *</span><br><span class="line"> * @param reader</span><br><span class="line"> * @param request</span><br><span class="line"> */</span><br><span class="line">private static void decodeRequestLine(BufferedReader reader, Request request) throws </span><br><span class="line">IOException &#123;</span><br><span class="line">    String[] strs = StringUtils.split(reader.readLine(), &quot; &quot;);</span><br><span class="line">    assert strs.length == 3;</span><br><span class="line">    request.setMethod(strs[0]);</span><br><span class="line">    request.setUri(strs[1]);</span><br><span class="line">    request.setVersion(strs[2]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请求头的解析，从第二行，到第一个空白行之间的所有数据，都是请求头；请求头的格式也比较清晰，形如 key:value , 具体实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 根据标准 HTTP 协议，解析请求头</span><br><span class="line">    *</span><br><span class="line">    * @param reader  读取请求头的 BufferedReader 对象</span><br><span class="line">    * @param request 存储请求信息的 Request 对象</span><br><span class="line">    * @throws IOException 当读取请求头信息时发生 I/O 异常时，将抛出该异常</span><br><span class="line">    */</span><br><span class="line">private static void decodeRequestHeader(BufferedReader reader, Request request) </span><br><span class="line">throws IOException &#123;</span><br><span class="line">    // 创建一个 Map 对象，用于存储请求头信息</span><br><span class="line">    Map&lt;String, String&gt; headers = new HashMap&lt;&gt;(16);</span><br><span class="line">    // 读取请求头信息，每行都是一个键值对，以空行结束</span><br><span class="line">    String line = reader.readLine();</span><br><span class="line">    String[] kv;</span><br><span class="line">    while (!&quot;&quot;.equals(line)) &#123;</span><br><span class="line">        // 将每行请求头信息按冒号分隔，分别作为键和值存入 Map 中</span><br><span class="line">        kv = StringUtils.split(line, &quot;:&quot;);</span><br><span class="line">        assert kv.length == 2;</span><br><span class="line">        headers.put(kv[0].trim(), kv[1].trim());</span><br><span class="line">        line = reader.readLine();</span><br><span class="line">    &#125;</span><br><span class="line">    // 将解析出来的请求头信息存入 Request 对象中</span><br><span class="line">    request.setHeaders(headers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后就是正文的解析了，这一块需要注意一点，正文可能为空，也可能有数据；有数据时，我们要如何把所有的数据都取出来呢？</p>
<p>先看具体实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 根据标注HTTP协议，解析正文</span><br><span class="line"> *</span><br><span class="line"> * @param reader    输入流读取器，用于读取请求中的数据</span><br><span class="line"> * @param request   Request 对象，表示 HTTP 请求</span><br><span class="line"> * @throws IOException 当发生 I/O 错误时抛出</span><br><span class="line"> */</span><br><span class="line">private static void decodeRequestMessage(BufferedReader reader, Request request) </span><br><span class="line">throws IOException &#123;</span><br><span class="line">    // 从请求头中获取 Content-Length，如果没有，则默认为 0</span><br><span class="line">    int contentLen = Integer.parseInt(request.getHeaders().getOrDefault(&quot;Content-</span><br><span class="line">Length&quot;, &quot;0&quot;));</span><br><span class="line">    // 如果 Content-Length 为 0，表示没有请求正文，直接返回。</span><br><span class="line">    // 例如 GET 和 OPTIONS 请求通常不包含请求正文</span><br><span class="line">    if (contentLen == 0) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 根据 Content-Length 创建一个字符数组来存储请求正文</span><br><span class="line">    char[] message = new char[contentLen];</span><br><span class="line">    // 使用 BufferedReader 读取请求正文</span><br><span class="line">    reader.read(message);</span><br><span class="line">    // 将字符数组转换为字符串，并将其设置为 Request 对象的 message</span><br><span class="line">    request.setMessage(new String(message));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意上面我的使用姿势，首先是根据请求头中的 Content-Type的值，来获得正文的数据大小，因此我们获取的方式是创建一个这么大的 char[] 数组来读取流中所有数据，如果我们的数组比实际的小，则读不完；如果大，则数组中会有一些空的数据；</p>
<p>最后将上面的几个解析封装一下，完成 request 解析：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * HTTP 请求可以分为三部分：</span><br><span class="line"> * 1. 请求行：包括请求方法、URI 和 HTTP 协议版本</span><br><span class="line"> * 2. 请求头：从第二行开始，直到一个空行为止</span><br><span class="line"> * 3. 消息正文：紧跟在空行后的所有内容，长度由请求头中的 Content-Length 决定</span><br><span class="line"> *</span><br><span class="line"> * 本方法将 InputStream 中的 HTTP 请求数据解析为一个 Request 对象</span><br><span class="line"> *</span><br><span class="line"> * @param reqStream  包含 HTTP 请求数据的输入流</span><br><span class="line"> * @return           一个表示 HTTP 请求的 Request 对象</span><br><span class="line"> * @throws IOException 当发生 I/O 错误时抛出</span><br><span class="line"> */</span><br><span class="line">public static Request parse2request(InputStream reqStream) throws IOException &#123;</span><br><span class="line">    // 使用 BufferedReader 和 InputStreamReader 读取输入流中的数据</span><br><span class="line">    BufferedReader httpReader = new BufferedReader(new InputStreamReader(reqStream, </span><br><span class="line">&quot;UTF-8&quot;));</span><br><span class="line">    // 创建一个新的 Request 对象</span><br><span class="line">    Request httpRequest = new Request();</span><br><span class="line">    // 解析请求行并设置到 Request 对象中</span><br><span class="line">    decodeRequestLine(httpReader, httpRequest);</span><br><span class="line">    // 解析请求头并设置到 Request 对象中</span><br><span class="line">    decodeRequestHeader(httpReader, httpRequest);</span><br><span class="line">    // 解析消息正文并设置到 Request 对象中</span><br><span class="line">    decodeRequestMessage(httpReader, httpRequest);</span><br><span class="line">    // 返回解析后的 Request 对象</span><br><span class="line">    return httpRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，是请求结果的封装，给一个简单的进行演示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Response 类表示一个 HTTP 响应，包括版本、状态码、状态信息、响应头和响应正文。</span><br><span class="line">    */</span><br><span class="line">@Data</span><br><span class="line">public static class Response &#123;</span><br><span class="line">    private String version;</span><br><span class="line">    private int code;</span><br><span class="line">    private String status;</span><br><span class="line">    private Map&lt;String, String&gt; headers;</span><br><span class="line">    private String message;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">    * 根据给定的 Request 对象和响应字符串构建一个 HTTP 响应。</span><br><span class="line">    *</span><br><span class="line">    * @param request   用于构建响应的 Request 对象</span><br><span class="line">    * @param response  响应字符串</span><br><span class="line">    * @return          一个表示 HTTP 响应的字符串</span><br><span class="line">    */</span><br><span class="line">public static String buildResponse(Request request, String response) &#123;</span><br><span class="line">    // 创建一个新的 Response 对象，并设置版本、状态码和状态信息</span><br><span class="line">    Response httpResponse = new Response();</span><br><span class="line">    httpResponse.setCode(200);</span><br><span class="line">    httpResponse.setStatus(&quot;ok&quot;);</span><br><span class="line">    httpResponse.setVersion(request.getVersion());</span><br><span class="line">    // 设置响应头</span><br><span class="line">    Map&lt;String, String&gt; headers = new HashMap&lt;&gt;();</span><br><span class="line">    headers.put(&quot;Content-Type&quot;, &quot;application/json&quot;);</span><br><span class="line">    headers.put(&quot;Content-Length&quot;, String.valueOf(response.getBytes().length));</span><br><span class="line">    httpResponse.setHeaders(headers);</span><br><span class="line">    // 设置响应正文</span><br><span class="line">    httpResponse.setMessage(response);</span><br><span class="line">    // 构建响应字符串</span><br><span class="line">    StringBuilder builder = new StringBuilder();</span><br><span class="line">    buildResponseLine(httpResponse, builder);</span><br><span class="line">    buildResponseHeaders(httpResponse, builder);</span><br><span class="line">    buildResponseMessage(httpResponse, builder);</span><br><span class="line">    return builder.toString();</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">    * 构建响应行，包括版本、状态码和状态信息。</span><br><span class="line">    *</span><br><span class="line">    * @param response      用于构建响应行的 Response 对象</span><br><span class="line">    * @param stringBuilder 用于拼接响应字符串的 StringBuilder 对象</span><br><span class="line">    */</span><br><span class="line">private static void buildResponseLine(Response response, StringBuilder </span><br><span class="line">stringBuilder) &#123;</span><br><span class="line">    stringBuilder.append(response.getVersion()).append(&quot; </span><br><span class="line">&quot;).append(response.getCode()).append(&quot; &quot;)</span><br><span class="line">            .append(response.getStatus()).append(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">    * 构建响应头。</span><br><span class="line">    *</span><br><span class="line">    * @param response      用于构建响应头的 Response 对象</span><br><span class="line">    * @param stringBuilder 用于拼接响应字符串的 StringBuilder 对象</span><br><span class="line">    */</span><br><span class="line">private static void buildResponseHeaders(Response response, StringBuilder </span><br><span class="line">stringBuilder) &#123;</span><br><span class="line">    for (Map.Entry&lt;String, String&gt; entry : response.getHeaders().entrySet()) &#123;</span><br><span class="line">       </span><br><span class="line"> stringBuilder.append(entry.getKey()).append(&quot;:&quot;).append(entry.getValue()).append(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    stringBuilder.append(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">    * 构建响应正文。</span><br><span class="line">    *</span><br><span class="line">    * @param response      用于构建响应正文的 Response 对象</span><br><span class="line">    * @param stringBuilder 用于拼接响应字符串的 StringBuilder 对象</span><br><span class="line">    */</span><br><span class="line">private static void buildResponseMessage(Response response, StringBuilder </span><br><span class="line">stringBuilder) &#123;</span><br><span class="line">    stringBuilder.append(response.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>b. 请求任务 HttpTask </strong></p>
<p>每个请求，单独分配一个任务来干这个事情，就是为了支持并发，对于 ServerSocket 而言，接收到了一个请求，那就创建一个 HttpTask 任务来实现 HTTP 通信。</p>
<p>那么这个 httptask 干啥呢？</p>
<ul>
<li>从请求中捞数据</li>
<li>响应请求</li>
<li>封装结果并返回</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * HttpTask 类实现了 Runnable 接口，用于处理一个 HTTP 请求。</span><br><span class="line"> * 当在一个线程中执行时，该任务将处理一个 Socket 连接上的 HTTP 请求，</span><br><span class="line"> * 并发送响应消息。</span><br><span class="line"> */</span><br><span class="line">public class HttpTask implements Runnable &#123;</span><br><span class="line">    // 用于处理 HTTP 请求的 Socket</span><br><span class="line">    private Socket socket;</span><br><span class="line">    /**</span><br><span class="line">     * 构造一个新的 HttpTask，用于处理指定的 Socket 连接。</span><br><span class="line">     *</span><br><span class="line">     * @param socket  用于处理 HTTP 请求的 Socket</span><br><span class="line">     */</span><br><span class="line">    public HttpTask(Socket socket) &#123;</span><br><span class="line">        this.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 实现 Runnable 接口的 run 方法，用于处理 HTTP 请求并发送响应消息。</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        // 检查 socket 是否为 null，如果为 null 则抛出异常</span><br><span class="line">        if (socket == null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;socket can&#x27;t be null.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 获取 Socket 的输出流，并创建一个 PrintWriter 对象</span><br><span class="line">            OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">            PrintWriter out = new PrintWriter(outputStream);</span><br><span class="line">            // 从 Socket 的输入流中解析 HTTP 请求</span><br><span class="line">            HttpMessageParser.Request httpRequest = HttpMessageParser.parse2request(socket.getInputStream());</span><br><span class="line">            try &#123;</span><br><span class="line">                // 根据请求结果进行响应，省略返回</span><br><span class="line">                String result = null;</span><br><span class="line">                </span><br><span class="line">                // 根据请求和结果构建 HTTP 响应</span><br><span class="line">                String httpRes = HttpMessageParser.buildResponse(httpRequest, result);</span><br><span class="line">                // 将 HTTP 响应发送到客户端</span><br><span class="line">                out.print(httpRes);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                // 如果发生异常，构建一个包含异常信息的 HTTP 响应</span><br><span class="line">                String httpRes = HttpMessageParser.buildResponse(httpRequest, e.toString());</span><br><span class="line">                out.print(httpRes);</span><br><span class="line">            &#125;</span><br><span class="line">            // 刷新输出流，确保响应消息被发送</span><br><span class="line">            out.flush();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // 关闭 Socket 连接</span><br><span class="line">            try &#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>c. HTTP 服务搭建 </strong></p>
<p>前面的基本上把该干的事情都干了，剩下的就简单了，创建 ServerSocket ，绑定端口接收请求，我们在线程池中跑这个 HTTP 服务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public class BasicHttpServer &#123;</span><br><span class="line">    // 创建一个单线程执行器，用于启动 HTTP 服务器</span><br><span class="line">    private static ExecutorService bootstrapExecutor = Executors.newSingleThreadExecutor();</span><br><span class="line">    // 创建一个线程池，用于处理来自客户端的 HTTP 请求</span><br><span class="line">    private static ExecutorService taskExecutor;</span><br><span class="line">    // 设置服务器监听的端口号</span><br><span class="line">    private static int PORT = 8999;</span><br><span class="line">    // 启动 HTTP 服务器的方法</span><br><span class="line">    static void startHttpServer() &#123;</span><br><span class="line">        // 获取处理器可用核心数，用于设置线程池大小</span><br><span class="line">        int nThreads = Runtime.getRuntime().availableProcessors();</span><br><span class="line">        // 初始化线程池，设置线程池大小，队列大小和丢弃策略</span><br><span class="line">        taskExecutor =</span><br><span class="line">                new ThreadPoolExecutor(nThreads, nThreads, 0L, </span><br><span class="line">TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;&gt;(100),</span><br><span class="line">                        new ThreadPoolExecutor.DiscardPolicy());</span><br><span class="line">        // 循环尝试启动服务器，如果启动失败，则等待10秒后重试</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                ServerSocket serverSocket = new ServerSocket(PORT);</span><br><span class="line">                bootstrapExecutor.submit(new ServerThread(serverSocket));</span><br><span class="line">                break;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    // 重试，等待 10 秒</span><br><span class="line">                    TimeUnit.SECONDS.sleep(10);</span><br><span class="line">                &#125; catch (InterruptedException ie) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 关闭启动执行器</span><br><span class="line">        bootstrapExecutor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">    // HTTP 服务器主要任务类</span><br><span class="line">    private static class ServerThread implements Runnable &#123;</span><br><span class="line">        // 保存传递给构造函数的 ServerSocket 实例</span><br><span class="line">        private ServerSocket serverSocket;</span><br><span class="line">        // 构造函数</span><br><span class="line">        public ServerThread(ServerSocket s) throws IOException &#123;</span><br><span class="line">            this.serverSocket = s;</span><br><span class="line">        &#125;</span><br><span class="line">        // 任务主体方法</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    // 等待客户端连接</span><br><span class="line">                    Socket socket = this.serverSocket.accept();</span><br><span class="line">                    // 创建一个 HttpTask 实例，将 Socket 实例作为参数传递</span><br><span class="line">                    HttpTask eventTask = new HttpTask(socket);</span><br><span class="line">                    // 将 HttpTask 提交给 taskExecutor 执行</span><br><span class="line">                    taskExecutor.submit(eventTask);</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    try &#123;</span><br><span class="line">                        // 如果发生异常，等待 1 秒后继续尝试</span><br><span class="line">                        TimeUnit.SECONDS.sleep(1);</span><br><span class="line">                    &#125; catch (InterruptedException ie) &#123;</span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码是一个简单的 HTTP 服务器实现。以下是关于这个 HTTP 服务器的主要组件和功能的详细解释：</p>
<p>1、bootstrapExecutor：一个单线程的 ExecutorService，用于执行 HTTP 服务器的启动任务。</p>
<p>2、taskExecutor：一个线程池，用于处理来自客户端的 HTTP 请求。线程池的大小等于处理器可用核心数，队列大小为100，使用 DiscardPolicy 丢弃策略。</p>
<p>3、PORT：服务器侦听的端口号，默认为 8999。</p>
<p>4、startHttpServer() 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- a.创建一个线程池 taskExecutor 用于处理 HTTP 请求。</span><br><span class="line">- b.在一个循环中，尝试创建一个 ServerSocket 实例并绑定到指定端口。如果失败，则等待 10 秒后重试。</span><br><span class="line">- c.当成功创建 ServerSocket 实例后，将其作为参数提交给 bootstrapExecutor 执行 ServerThread </span><br><span class="line">任务。</span><br><span class="line">- d.关闭 bootstrapExecutor。</span><br></pre></td></tr></table></figure>
<p>5、ServerThread 类实现了 Runnable 接口，它是 HTTP 服务器的主要任务： </p>
<ul>
<li>a.serverSocket 成员变量：保存传递给构造函数的 ServerSocket 实例。 </li>
<li>b.run() 方法： </li>
</ul>
<ul>
<li><p>在一个无限循环中，调用 serverSocket.accept() 方法等待客户端的连接。 </p>
</li>
<li><p>当接受到一个新的客户端连接时，创建一个 HttpTask 实例，将 Socket 实例作为参数传递。 </p>
</li>
<li><p>将 HttpTask 提交给 taskExecutor 执行。</p>
</li>
</ul>
<p>这个 HTTP 服务器的主要逻辑是：使用一个线程来监听客户端连接，当有新的客户端连接时，创建一个 HttpTask 来处理客户端的 HTTP 请求，并将这个任务提交给线程池 taskExecutor 执行。这样可以实现多个客户端请求的并发处理。</p>
<p>到这里，一个基于 Socket 实现的 HTTP 服务器基本上就搭建完了，接下来就可以进行测试了</p>
<p><strong>4.测试 </strong></p>
<p>做这个服务器，主要是基于项目 quick-fix 产生的，这个项目主要是为了解决应用内部服务访问与数据订正，我们在这个项目的基础上进行测试。</p>
<p>一个完整的 post 请求如下</p>
<p><img src="\assets\note\image-20231012174944585.png" alt="image-20231012174944585"></p>
<p>接下来我们看下打印出返回头的情况</p>
<p><img src="\assets\note\image-20231012174958703.png" alt="image-20231012174958703"></p>
<p><strong>II. 其他 </strong></p>
<p><strong>0.项目源码 </strong></p>
<ul>
<li>quick-fix</li>
<li>相关代码:</li>
<li>com.git.hui.fix.core.endpoint.BasicHttpServer</li>
<li>com.git.hui.fix.core.endpoint.HttpMessageParser</li>
<li>com.git.hui.fix.core.endpoint.HttpTask</li>
</ul>
<h1 id="10-Java-NIO"><a href="#10-Java-NIO" class="headerlink" title="10 Java NIO"></a>10 Java NIO</h1><h2 id="10-1-NIO比IO强在哪？"><a href="#10-1-NIO比IO强在哪？" class="headerlink" title="10.1 NIO比IO强在哪？"></a>10.1 NIO比IO强在哪？</h2><p>我花了几天时间去了解NIO 的核心知识，期间看了《Java 编程思想》和《疯狂 Java 讲义》中的 NIO 模块。但是，看完之后还是很迷，不知道 NIO 是干嘛用的，网上的资料和书上的知识点没有很好地对应上。</p>
<p>我这里先给大家展示一副传统 IO 和 NIO 的对比图，感受一下。</p>
<p><img src="\assets\note\image-20231012201840907.png" alt="image-20231012201840907"></p>
<p>传统 IO 基于字节流或字符流（如 FileInputStream、BufferedReader 等）进行文件读写，以及使用 Socket 和 ServerSocket 进行网络传输。</p>
<p>NIO 使用通道（Channel）和缓冲区（Buffer）进行文件操作，以及使用 SocketChannel 和 ServerSocketChannel 进行网络传输。</p>
<p>传统 IO 采用阻塞式模型，对于每个连接，都需要创建一个独立的线程来处理读写操作。当一个线程在等待 I/O 操作时，无法执行其他任务。这会导致大量线程的创建和销毁，以及上下文切换，降低了系统性能。</p>
<p>NIO 使用非阻塞模型，允许线程在等待 I/O 时执行其他任务。这种模式通过使用选择器（Selector）来监控多个通道（Channel）上的 I/O 事件，实现了更高的性能和可伸缩性。</p>
<p><strong>01、NIO 和传统 IO 在操作文件时的差异 </strong></p>
<p>JDK 1.4 中， java.nio.<em>包引入新的 Java I/O 库，其目的是<strong>提高速度</strong>。实际上，“旧”的 I/O 包已经使用 NIO<em>*重新实现过，即使我们不显式的使用 NIO 编程，也能从中受益。</em></em></p>
<p>nio 翻译成 no-blocking io 或者 new io 都无所谓啦，都说得通~</p>
<p>在《Java 编程思想》读到“即使我们不显式的使用 NIO 编程，也能从中受益”的时候，我是挺在意的，所以：我们测试一下使用 NIO 复制文件和传统 IO 复制文件 的性能：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleFileTransferTest &#123;</span><br><span class="line">    // 使用传统的 I/O 方法传输文件</span><br><span class="line">    private long transferFile(File source, File des) throws IOException &#123;</span><br><span class="line">        long startTime = System.currentTimeMillis();</span><br><span class="line">        if (!des.exists())</span><br><span class="line">            des.createNewFile();</span><br><span class="line">        // 创建输入输出流</span><br><span class="line">        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(source));</span><br><span class="line">        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(des));</span><br><span class="line">        // 使用数组传输数据</span><br><span class="line">        byte[] bytes = new byte[1024 * 1024];</span><br><span class="line">        int len;</span><br><span class="line">        while ((len = bis.read(bytes)) != -1) &#123;</span><br><span class="line">            bos.write(bytes, 0, len);</span><br><span class="line">        &#125;</span><br><span class="line">        long endTime = System.currentTimeMillis();</span><br><span class="line">        return endTime - startTime;</span><br><span class="line">    &#125;</span><br><span class="line">    // 使用 NIO 方法传输文件</span><br><span class="line">    private long transferFileWithNIO(File source, File des) throws IOException &#123;</span><br><span class="line">        long startTime = System.currentTimeMillis();</span><br><span class="line">        if (!des.exists())</span><br><span class="line">            des.createNewFile();</span><br><span class="line">        // 创建随机存取文件对象</span><br><span class="line">        RandomAccessFile read = new RandomAccessFile(source, &quot;rw&quot;);</span><br><span class="line">        RandomAccessFile write = new RandomAccessFile(des, &quot;rw&quot;);</span><br><span class="line">        // 获取文件通道</span><br><span class="line">        FileChannel readChannel = read.getChannel();</span><br><span class="line">        FileChannel writeChannel = write.getChannel();</span><br><span class="line">        // 创建并使用 ByteBuffer 传输数据</span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(1024 * 1024);</span><br><span class="line">        while (readChannel.read(byteBuffer) &gt; 0) &#123;</span><br><span class="line">            byteBuffer.flip();</span><br><span class="line">            writeChannel.write(byteBuffer);</span><br><span class="line">            byteBuffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        // 关闭文件通道</span><br><span class="line">        writeChannel.close();</span><br><span class="line">        readChannel.close();</span><br><span class="line">        long endTime = System.currentTimeMillis();</span><br><span class="line">        return endTime - startTime;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        SimpleFileTransferTest simpleFileTransferTest = new SimpleFileTransferTest();</span><br><span class="line">        File sourse = new File(&quot;[电影天堂www.dygod.cn]猜火车-cd1.rmvb&quot;);</span><br><span class="line">        File des = new File(&quot;io.avi&quot;);</span><br><span class="line">        File nio = new File(&quot;nio.avi&quot;);</span><br><span class="line">        // 比较传统的 I/O 和 NIO 传输文件的时间</span><br><span class="line">        long time = simpleFileTransferTest.transferFile(sourse, des);</span><br><span class="line">        System.out.println(time + &quot;：普通字节流时间&quot;);</span><br><span class="line">        long timeNio = simpleFileTransferTest.transferFileWithNIO(sourse, nio);</span><br><span class="line">        System.out.println(timeNio + &quot;：NIO时间&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先解释一下这段代码，里面出现的 RandomAccessFile 我们之前讲过，FileChannel 是 Java NIO（New I/O）库中的一个类，它提供了对文件的高效 I/O 操作，支持随机访问文件，允许在文件的任意位置进行读写操作。</p>
<p>与 RandomAccessFile 不同，FileChannel 使用了缓冲区（ByteBuffer）进行数据传输。</p>
<p>好，在我给出实际的结论之前，你是否会有这样的结论：</p>
<ul>
<li>对于较小的文件，NIO 和普通 IO 之间的性能差异可能不会非常明显，因为文件本身较小，复制过程较快。</li>
<li>对于较大的文件，使用 NIO 的性能可能会明显优于普通 IO。因为 NIO 使用了更高效的缓冲区和通道机制，可以在内存中进行更快的数据传输。</li>
</ul>
<p>然而实际的结果，却会令你大跌眼镜：<br>        <img src="\assets\note\image-20231012202156264.png" alt="image-20231012202156264"></p>
<p>文件越大的情况下，竟然普通字节流（传统 IO）的速度更快(当然了，个人测试，或许不是很准)，那还要 NIO 做什么呢？况且 NIO 的学习成本也比传统 IO 要高一些。</p>
<p>那这意味着我们可以不使用/学习 NIO 了吗？</p>
<p>答案是否定的，IO 操作往往在两个场景下会用到：</p>
<ul>
<li>文件 IO</li>
<li>网络 IO</li>
</ul>
<p>而 NIO 的<strong>魅力主要体现在网络中！</strong></p>
<p>NIO（New I/O）的设计目标是解决传统 I/O（BIO，Blocking I/O）在处理大量并发连接时的性能瓶颈。传统 I/O 在网络通信中主要使用阻塞式 I/O，为每个连接分配一个线程。当连接数量增加时，系统性能将受到严重影响，线程资源成为关键瓶颈。而 NIO 提供了非阻塞 I/O 和 I/O 多路复用，可以在单个线程中处理多个并发连接，从而在网络传输中显著提高性能。</p>
<p>以下是 NIO 在网络传输中优于传统 I/O 的原因：</p>
<p>①、NIO 支持非阻塞 I/O，这意味着在执行 I/O 操作时，线程不会被阻塞。这使得在网络传输中可以有效地管理大量并发连接（数千甚至数百万）。而在操作文件时，这个优势没有那么明显，因为文件读写通常不涉及大量并发操作。</p>
<p>②、NIO 支持 I/O 多路复用，这意味着一个线程可以同时监视多个通道（如套接字），并在 I/O 事件（如可读、可写）准备好时处理它们。这大大提高了网络传输中的性能，因为单个线程可以高效地管理多个并发连接。操作文件时这个优势也无法提现出来。</p>
<p>③、NIO 提供了 ByteBuffer 类，可以高效地管理缓冲区。这在网络传输中很重要，因为数据通常是以字节流的形式传输。操作文件的时候，虽然也有缓冲区，但优势仍然不够明显。</p>
<p><strong>02、NIO 和传统 IO 在网络传输中的差异 </strong></p>
<p>来看服务器端代码的差别。</p>
<p>IO，用的套接字，代码比较简单，我就不加注释了，之前学过，应该都能看得懂，用 while 循环监听客户端 Socket：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class IOServer &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            ServerSocket serverSocket = new ServerSocket(8080);</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                Socket client = serverSocket.accept();</span><br><span class="line">                InputStream in = client.getInputStream();</span><br><span class="line">                OutputStream out = client.getOutputStream();</span><br><span class="line">                byte[] buffer = new byte[1024];</span><br><span class="line">                int bytesRead = in.read(buffer);</span><br><span class="line">                out.write(buffer, 0, bytesRead);</span><br><span class="line">                in.close();</span><br><span class="line">                out.close();</span><br><span class="line">                client.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NIO，这部分我加上注释，主要用到的是 ServerSocketChannel 和 Selector：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public class NIOServer &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 创建 ServerSocketChannel</span><br><span class="line">            ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">            // 绑定端口</span><br><span class="line">            serverSocketChannel.bind(new InetSocketAddress(8081));</span><br><span class="line">            // 设置为非阻塞模式</span><br><span class="line">            serverSocketChannel.configureBlocking(false);</span><br><span class="line">            // 创建 Selector</span><br><span class="line">            Selector selector = Selector.open();</span><br><span class="line">            // 将 ServerSocketChannel 注册到 Selector，关注 OP_ACCEPT 事件</span><br><span class="line">            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            // 无限循环，处理事件</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                // 阻塞直到有事件发生</span><br><span class="line">                selector.select();</span><br><span class="line">                // 获取发生事件的 SelectionKey</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">                while (iterator.hasNext()) &#123;</span><br><span class="line">                    SelectionKey key = iterator.next();</span><br><span class="line">                    // 处理完后，从 selectedKeys 集合中移除</span><br><span class="line">                    iterator.remove();</span><br><span class="line">                    // 判断事件类型</span><br><span class="line">                    if (key.isAcceptable()) &#123;</span><br><span class="line">                        // 有新的连接请求</span><br><span class="line">                        ServerSocketChannel server = (ServerSocketChannel) key.channel();</span><br><span class="line">                        // 接受连接</span><br><span class="line">                        SocketChannel client = server.accept();</span><br><span class="line">                        // 设置为非阻塞模式</span><br><span class="line">                        client.configureBlocking(false);</span><br><span class="line">                        // 将新的 SocketChannel 注册到 Selector，关注 OP_READ 事件</span><br><span class="line">                        client.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                    &#125; else if (key.isReadable()) &#123;</span><br><span class="line">                        // 有数据可读</span><br><span class="line">                        SocketChannel client = (SocketChannel) key.channel();</span><br><span class="line">                        // 创建 ByteBuffer 缓冲区</span><br><span class="line">                        ByteBuffer buffer = ByteBuffer.allocate(1024);</span><br><span class="line">                        // 从 SocketChannel 中读取数据并写入 ByteBuffer</span><br><span class="line">                        client.read(buffer);</span><br><span class="line">                        // 翻转 ByteBuffer，准备读取</span><br><span class="line">                        buffer.flip();</span><br><span class="line">                        // 将数据从 ByteBuffer 写回到 SocketChannel</span><br><span class="line">                        client.write(buffer);</span><br><span class="line">                        // 关闭连接</span><br><span class="line">                        client.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码创建了一个基于 Java NIO 的简单 TCP 服务器。它使用 ServerSocketChannel 和 Selector（后面会讲） 实现了非阻塞 I/O 和 I/O 多路复用。服务器循环监听事件，当有新的连接请求时，接受连接并将新的 SocketChannel 注册到 Selector，关注 OP_READ 事件。当有数据可读时，从 SocketChannel 中读取数据并写入 ByteBuffer，然后将数据从 ByteBuffer 写回到 SocketChannel。</p>
<p>这里简单说一下 Socket 和 ServerSocket，以及 ServerSocketChannel 和 SocketChannel。</p>
<p>Socket 和 ServerSocket 是传统的阻塞式 I/O 编程方式，用于建立和管理 TCP 连接。</p>
<ul>
<li>Socket：表示客户端套接字，负责与服务器端建立连接并进行数据的读写。</li>
<li>ServerSocket：表示服务器端套接字，负责监听客户端连接请求。当有新的连接请求时，ServerSocket 会创建一个新的 Socket 实例，用于与客户端进行通信。</li>
</ul>
<p>在传统阻塞式 I/O 编程中，每个连接都需要一个单独的线程进行处理，这导致了在高并发场景下的性能问题。在接下来的客户端测试用例中会看到。</p>
<p>为了解决传统阻塞式 I/O 的性能问题，Java NIO 引入了 ServerSocketChannel 和 SocketChannel。它们是非阻塞 I/O，可以在单个线程中处理多个连接。</p>
<ul>
<li>ServerSocketChannel：类似于 ServerSocket，表示服务器端套接字通道。它负责监听客户端连接请求，并可以设置为非阻塞模式，这意味着在等待客户端连接请求时不会阻塞线程。</li>
<li>SocketChannel：类似于 Socket，表示客户端套接字通道。它负责与服务器端建立连接并进行数据的读写。SocketChannel 也可以设置为非阻塞模式，在读写数据时不会阻塞线程。</li>
</ul>
<p>再来简单说一下 Selector，后面会再细讲。</p>
<p>Selector 是 Java NIO 中的一个关键组件，用于实现 I/O 多路复用。它允许在单个线程中同时监控多个 ServerSocketChannel 和 SocketChannel，并通过 SelectionKey 标识关注的事件。当某个事件发生时，Selector 会将对应的 SelectionKey 添加到已选择的键集合中。通过使用 Selector，可以在单个线程中同时处理多个连接，从而有效地提高 I/O 操作的性能，特别是在高并发场景下。</p>
<p>客户端测试用例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public class TestClient &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        int clientCount = 10000;</span><br><span class="line">        ExecutorService executorServiceIO = Executors.newFixedThreadPool(10);</span><br><span class="line">        ExecutorService executorServiceNIO = Executors.newFixedThreadPool(10);</span><br><span class="line">        // 使用传统 IO 的客户端</span><br><span class="line">        Runnable ioClient = () -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Socket socket = new Socket(&quot;localhost&quot;, 8080);</span><br><span class="line">                OutputStream out = socket.getOutputStream();</span><br><span class="line">                InputStream in = socket.getInputStream();</span><br><span class="line">                out.write(&quot;Hello, 沉默王二 IO!&quot;.getBytes());</span><br><span class="line">                byte[] buffer = new byte[1024];</span><br><span class="line">                in.read(buffer);</span><br><span class="line">                in.close();</span><br><span class="line">                out.close();</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        // 使用 NIO 的客户端</span><br><span class="line">        Runnable nioClient = () -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">                socketChannel.connect(new InetSocketAddress(&quot;localhost&quot;, 8081));</span><br><span class="line">                ByteBuffer buffer = ByteBuffer.wrap(&quot;Hello, 沉默王二 NIO!&quot;.getBytes());</span><br><span class="line">                socketChannel.write(buffer);</span><br><span class="line">                buffer.clear();</span><br><span class="line">                socketChannel.read(buffer);</span><br><span class="line">                socketChannel.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        // 分别测试 NIO 和传统 IO 的服务器性能</span><br><span class="line">        long startTime, endTime;</span><br><span class="line">        startTime = System.currentTimeMillis();</span><br><span class="line">        for (int i = 0; i &lt; clientCount; i++) &#123;</span><br><span class="line">            executorServiceIO.execute(ioClient);</span><br><span class="line">        &#125;</span><br><span class="line">        executorServiceIO.shutdown();</span><br><span class="line">        executorServiceIO.awaitTermination(1, TimeUnit.MINUTES);</span><br><span class="line">        endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;传统 IO 服务器处理 &quot; + clientCount + &quot; 个客户端耗时: &quot; + (endTime - startTime) + &quot;ms&quot;);</span><br><span class="line">        startTime = System.currentTimeMillis();</span><br><span class="line">        for (int i = 0; i &lt; clientCount; i++) &#123;</span><br><span class="line">            executorServiceNIO.execute(nioClient);</span><br><span class="line">        &#125;</span><br><span class="line">        executorServiceNIO.shutdown();</span><br><span class="line">        executorServiceNIO.awaitTermination(1, TimeUnit.MINUTES);</span><br><span class="line">        endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;NIO 服务器处理 &quot; + clientCount + &quot; 个客户端耗时: &quot; + (endTime - startTime) + &quot;ms&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个简单的性能测试中，我们使用固定线程池（10个线程）来模拟客户端并发请求。分别测试 NIO 和传统 IO 服务器处理 10000 个客户端请求所需的时间。来看一下结果。</p>
<p><img src="\assets\note\image-20231012202800164.png" alt="image-20231012202800164"></p>
<p>可以看得出，NIO 比 传统 IO 差不多快一倍的时间。当然了，这是放在我本地测试的，如果服务端放在生产环境下，这个结果会有所不同，但我在本地跑了几次，结果差不多是这样的结果。</p>
<p>这说明 NIO 在网络传输中的性能确实要优于传统 IO 的。   </p>
<p><strong>03、小结 </strong></p>
<p>本篇内容主要讲了 NIO（New IO）和传统 IO 之间的差异，包括 IO 模型、操作文件、网络传输等方面。</p>
<ul>
<li>传统 I/O 采用阻塞式模型，线程在 I/O 操作期间无法执行其他任务。NIO 使用非阻塞模型，允许线程在等待 I/O 时执行其他任务，通过选择器（Selector）监控多个通道（Channel）上的 I/O 事件，提高性能和可伸缩性。</li>
<li>传统 I/O 使用基于字节流或字符流的类（如 FileInputStream、BufferedReader 等）进行文件读写。NIO 使用通道（Channel）和缓冲区（Buffer）进行文件操作，NIO 在性能上的优势并不大。</li>
<li>传统 I/O 使用 Socket 和 ServerSocket 进行网络传输，存在阻塞问题。NIO 提供了 SocketChannel 和 ServerSocketChannel，支持非阻塞网络传输，提高了并发处理能力。</li>
</ul>
<h2 id="10-2-BIO、NIO-和-AIO-的区别"><a href="#10-2-BIO、NIO-和-AIO-的区别" class="headerlink" title="10.2 BIO、NIO 和 AIO 的区别"></a>10.2 BIO、NIO 和 AIO 的区别</h2><p>上篇，我们了解了 NIO 和传统 IO 的区别，那这篇我们来了解 BIO、NIO 和 AIO 的区别，新手也很容易混淆，我们换一个方式来讲，讲给女朋友听 。</p>
<p>周末午后，在家里面进行电话面试，我问了面试者几个关于 IO 的问题，其中包括什么是 BIO、NIO 和 AIO？三者有什么区别？具体如何使用等问题，但是面试者回答的并不是很满意。于是我在面试评价中写道：”对 Java 的 IO 提醒理解不够深入”。恰好被女朋友看到了。</p>
<p><img src="\assets\note\image-20231012203025941.png" alt="image-20231012203025941"></p>
<p><strong>Java IO 与 BIO、NIO </strong></p>
<p>IO，常写作 I/O，是 Input/Output 的简称，即输入/输出。通常指数据在内部存储器（内存）和外部存储器（硬盘、优盘等）或其他周边设备之间的输入和输出。</p>
<p>输入/输出是信息处理系统（例如计算机）与外部世界（可能是人类或另一信息处理系统）之间的通信。</p>
<p>输入是系统接收的信号或数据，输出则是从其发送的信号或数据。</p>
<p>在 Java 中，提供了一系列 API，可以供开发者来读写外部数据或文件。我们称这些 API 为 Java IO。</p>
<p>IO 是 Java 中比较重要，且比较难的知识点，主要是因为随着 Java 的发展，目前有三种 IO 共存。分别是 BIO、NIO 和 AIO。</p>
<p>BIO 全称 Block-IO 是一种同步且阻塞的通信模式。是一个比较传统的通信方式，模式简单，使用方便。但并发处理能力低，通信耗时，依赖网速。</p>
<p>Java NIO，全程 Non-Block IO ，是 Java SE 1.4 版以后，针对网络传输效能优化的新功能。是一种非阻塞同步的通信模式。</p>
<p>NIO 与原来的 I/O 有同样的作用和目的, 他们之间最重要的区别是数据打包和传输的方式。原来的 I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。</p>
<p>面向流的 I/O 系统一次一个字节地处理数据。一个输入流产生一个字节的数据，一个输出流消费一个字节的数据。</p>
<p>面向块的 I/O 系统以块的形式处理数据。每一个操作都在一步中产生或者消费一个数据块。按块处理数据比按(流式的)字节处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。</p>
<p>Java AIO，全称 Asynchronous IO，是异步非阻塞的 IO。是一种非阻塞异步的通信模式。</p>
<p>在 NIO 的基础上引入了新的异步通道的概念，并提供了异步文件通道和异步套接字通道的实现。</p>
<p><img src="\assets\note\image-20231012203409694.png" alt="image-20231012203409694"></p>
<p><strong>三种 IO 的区别 </strong></p>
<p>首先，我们站在宏观的角度，重新画一下重点：</p>
<ul>
<li>BIO （Blocking I/O）：同步阻塞 I/O 模式。</li>
<li>NIO （New I/O）：同步非阻塞模式。</li>
<li>AIO （Asynchronous I/O）：异步非阻塞 I/O 模型。</li>
</ul>
<p>同步阻塞模式：这种模式下，我们的工作模式是先来到厨房，开始烧水，并坐在水壶面前一直等着水烧开。</p>
<p>同步非阻塞模式：这种模式下，我们的工作模式是先来到厨房，开始烧水，但是我们不一直坐在水壶前面等，而是回到客厅看电视，然后每隔几分钟到厨房看一下水有没有烧开。</p>
<p>异步非阻塞 I/O 模型：这种模式下，我们的工作模式是先来到厨房，开始烧水，我们不一直坐在水壶前面等，也不隔一段时间去看一下，而是在客厅看电视，水壶上面有个开关，水烧开之后他会通知我。</p>
<p>阻塞 VS 非阻塞：人是否坐在水壶前面一直等。</p>
<p>同步 VS 异步：水壶是不是在水烧开之后主动通知人。</p>
<p><strong>适用场景 </strong></p>
<p>BIO 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4 以前的唯一选择，但程序直观简单易理解。</p>
<p>NIO 方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4 开始支持。</p>
<p>AIO 方式适用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用 OS 参与并发操作，编程比较复杂，JDK7 开始支持。</p>
<p><strong>使用方式 </strong></p>
<p>使用 BIO 实现文件的读取和写入。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class BioFileDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BioFileDemo demo = new BioFileDemo();</span><br><span class="line">        demo.writeFile();</span><br><span class="line">        demo.readFile();</span><br><span class="line">    &#125;</span><br><span class="line">    // 使用 BIO 写入文件</span><br><span class="line">    public void writeFile() &#123;</span><br><span class="line">        String filename = &quot;logs/itwanger/paicoding.txt&quot;;</span><br><span class="line">        try &#123;</span><br><span class="line">            FileWriter fileWriter = new FileWriter(filename);</span><br><span class="line">            BufferedWriter bufferedWriter = new BufferedWriter(fileWriter);</span><br><span class="line">            bufferedWriter.write(&quot;学编程就上技术派&quot;);</span><br><span class="line">            bufferedWriter.newLine();</span><br><span class="line">            System.out.println(&quot;写入完成&quot;);</span><br><span class="line">            bufferedWriter.close();</span><br><span class="line">            fileWriter.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 使用 BIO 读取文件</span><br><span class="line">    public void readFile() &#123;</span><br><span class="line">        String filename = &quot;logs/itwanger/paicoding.txt&quot;;</span><br><span class="line">        try &#123;</span><br><span class="line">            FileReader fileReader = new FileReader(filename);</span><br><span class="line">            BufferedReader bufferedReader = new BufferedReader(fileReader);</span><br><span class="line">            String line;</span><br><span class="line">            while ((line = bufferedReader.readLine()) != null) &#123;</span><br><span class="line">                System.out.println(&quot;读取的内容: &quot; + line);</span><br><span class="line">            &#125;</span><br><span class="line">            bufferedReader.close();</span><br><span class="line">            fileReader.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个示例展示了如何使用 Java 中的传统阻塞 I/O（BIO）对文件进行读写操作。在 writeFile() 方法中，我们首先创建一个 FileWriter 对象，并使用 BufferedWriter 进行缓冲写入。接着，使用 bufferedWriter.write() 方法将字符串写入文件，然后调用bufferedWriter.newLine() 方法添加换行符。最后，关闭 BufferedWriter 和 FileWriter。在 readFile() 方法中，我们创建一个 FileReader 对象，并使用 BufferedReader 进行缓冲读取。然后通过调用 bufferedReader.readLine() 方法循环读取文件内容，直到返回 null 表示读取完毕。最后，关闭 BufferedReader 和 FileReader。</p>
<p>接下来是 NIO 的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class NioFileDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        NioFileDemo demo = new NioFileDemo();</span><br><span class="line">        demo.writeFile();</span><br><span class="line">        demo.readFile();</span><br><span class="line">    &#125;</span><br><span class="line">    // 使用 NIO 写入文件</span><br><span class="line">    public void writeFile() &#123;</span><br><span class="line">        Path path = Paths.get(&quot;logs/itwanger/paicoding.txt&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            FileChannel fileChannel = FileChannel.open(path, </span><br><span class="line">EnumSet.of(StandardOpenOption.CREATE, StandardOpenOption.WRITE));</span><br><span class="line">            ByteBuffer buffer = StandardCharsets.UTF_8.encode(&quot;学编程就上技术派&quot;);</span><br><span class="line">            fileChannel.write(buffer);</span><br><span class="line">            System.out.println(&quot;写入完成&quot;);</span><br><span class="line">            fileChannel.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 使用 NIO 读取文件</span><br><span class="line">    public void readFile() &#123;</span><br><span class="line">        Path path = Paths.get(&quot;logs/itwanger/paicoding.txt&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            FileChannel fileChannel = FileChannel.open(path, StandardOpenOption.READ);</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(1024);</span><br><span class="line">            int bytesRead = fileChannel.read(buffer);</span><br><span class="line">            while (bytesRead != -1) &#123;</span><br><span class="line">                buffer.flip();</span><br><span class="line">                System.out.println(&quot;读取的内容: &quot; + StandardCharsets.UTF_8.decode(buffer));</span><br><span class="line">                buffer.clear();</span><br><span class="line">                bytesRead = fileChannel.read(buffer);</span><br><span class="line">            &#125;</span><br><span class="line">            fileChannel.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个示例演示了如何使用 NIO 的 FileChannel 对文件进行读写操作。在 writeFile() 方法中，我们首先打开文件通道并指定创建和写入选项。接着，将要写入的字符串转换为 ByteBuffer，然后使用 fileChannel.write() 方法将其写入文件。在 readFile() 方法中，我们打开文件通道并指定读取选项，然后创建一个 ByteBuffer 用于存储读取到的数据。使用 fileChannel.read() 方法循环读取文件内容，直到返回 -1 表示读取完毕。在循环中，我们翻转缓冲区，将其解码为字符串并打印，然后清空缓冲区以进行下一次读取。最后，关闭文件通道。</p>
<p>使用 AIO 实现文件的读取和写入     </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public class AioDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AioDemo demo = new AioDemo();</span><br><span class="line">        demo.writeFile();</span><br><span class="line">        demo.readFile();</span><br><span class="line">    &#125;</span><br><span class="line">    // 使用 AsynchronousFileChannel 写入文件</span><br><span class="line">    public void writeFile() &#123;</span><br><span class="line">        // 使用 Paths.get() 获取文件路径</span><br><span class="line">        Path path = Paths.get(&quot;logs/itwanger/paicoding.txt&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            // 用 AsynchronousFileChannel.open() 打开文件通道，指定写入和创建文件的选项。</span><br><span class="line">            AsynchronousFileChannel fileChannel = AsynchronousFileChannel.open(path, </span><br><span class="line">StandardOpenOption.WRITE, StandardOpenOption.CREATE);</span><br><span class="line">            // 将要写入的字符串（&quot;学编程就上技术派&quot;）转换为 ByteBuffer。</span><br><span class="line">            ByteBuffer buffer = StandardCharsets.UTF_8.encode(&quot;学编程就上技术派&quot;);</span><br><span class="line">            // 调用 fileChannel.write() 方法将 ByteBuffer 中的内容写入文件。这是一个异步操</span><br><span class="line">作，因此需要使用 Future 对象等待写入操作完成。</span><br><span class="line">            Future&lt;Integer&gt; result = fileChannel.write(buffer, 0);</span><br><span class="line">            // 等待写操作完成</span><br><span class="line">            result.get();</span><br><span class="line">            System.out.println(&quot;写入完成&quot;);</span><br><span class="line">            fileChannel.close();</span><br><span class="line">        &#125; catch (IOException | InterruptedException | java.util.concurrent.ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 使用 AsynchronousFileChannel 读取文件</span><br><span class="line">    public void readFile() &#123;</span><br><span class="line">        Path path = Paths.get(&quot;logs/itwanger/paicoding.txt&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            // 指定读取文件的选项。</span><br><span class="line">            AsynchronousFileChannel fileChannel = AsynchronousFileChannel.open(path, StandardOpenOption.READ);</span><br><span class="line">            // 创建一个 ByteBuffer，用于存储从文件中读取的数据。</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(1024);</span><br><span class="line">            // 调用 fileChannel.read() 方法从文件中异步读取数据。该方法接受一个 </span><br><span class="line">CompletionHandler 对象，用于处理异步操作完成后的回调。</span><br><span class="line">            fileChannel.read(buffer, 0, buffer, new CompletionHandler&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void completed(Integer result, ByteBuffer attachment) &#123;</span><br><span class="line">                    // 在 CompletionHandler 的 completed() 方法中，翻转 ByteBuffer</span><br><span class="line">（attachment.flip()），然后使用 Charset.forName(&quot;UTF-8&quot;).decode() 将其解码为字符串并打印。最后，清空缓冲区并关闭文件通道。</span><br><span class="line">                    attachment.flip();</span><br><span class="line">                    System.out.println(&quot;读取的内容: &quot; + </span><br><span class="line">StandardCharsets.UTF_8.decode(attachment));</span><br><span class="line">                    attachment.clear();</span><br><span class="line">                    try &#123;</span><br><span class="line">                        fileChannel.close();</span><br><span class="line">                    &#125; catch (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                @Override</span><br><span class="line">                public void failed(Throwable exc, ByteBuffer attachment) &#123;</span><br><span class="line">                    // 如果异步读取操作失败，CompletionHandler 的 failed() 方法将被调用，打印错误信息。</span><br><span class="line">                    System.out.println(&quot;读取失败&quot;);</span><br><span class="line">                    exc.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            // 等待异步操作完成</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125; catch (IOException | InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码展示了一个名为 AioDemo 的类，包含两个方法： writeFile() 和 readFile() 。这两个方法分别使用 AsynchronousFileChannel 对文件进行异步写入和读取操作。代码的具体含义我都加到注释当中了，注意查看。</p>
<p>滴滴滴，水开了。</p>
<p><img src="\assets\note\image-20231012204156678.png" alt="image-20231012204156678"></p>
<p><strong>小结 </strong></p>
<p>BIO（Blocking I/O）：采用阻塞式 I/O 模型，线程在执行 I/O 操作时被阻塞，无法处理其他任务，适用于连接数较少且稳定的场景。</p>
<p>NIO（New I/O 或 Non-blocking I/O）：使用非阻塞 I/O 模型，线程在等待 I/O 时可执行其他任务，通过 Selector 监控多个 Channel 上的事件，提高性能和可伸缩性，适用于高并发场景。</p>
<p>AIO（Asynchronous I/O）：采用异步 I/O 模型，线程发起 I/O 请求后立即返回，当 I/O 操作完成时通过回调函数通知线程，进一步提高了并发处理能力，适用于高吞吐量场景。</p>
<blockquote>
<p>参考链接：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/QQxrr5yP8X9YdFqIwXDoQQ">https://mp.weixin.qq.com/s/QQxrr5yP8X9YdFqIwXDoQQ</a></p>
</blockquote>
<h2 id="10-3-Buffer和Channel"><a href="#10-3-Buffer和Channel" class="headerlink" title="10.3 Buffer和Channel"></a>10.3 Buffer和Channel</h2><p>首先我们再来回顾一下 IO 和 NIO 的区别：</p>
<ul>
<li>可简单认为：<strong>IO 是面向流的处理，NIO 是面向块(缓冲区)的处理</strong></li>
<li>面向流的 I/O 系统<strong>一次一个字节地处理数据。</strong></li>
<li>一个面向块(缓冲区)的 I/O 系统<strong>以块的形式处理数据。</strong></li>
</ul>
<p>NIO 主要有<strong>两个核心部分组成：</strong></p>
<ul>
<li><strong>Buffer 缓冲区</strong></li>
<li><strong>Channel 通道</strong></li>
</ul>
<p>在 NIO 中，并不是以流的方式来处理数据的，而是以 buffer 缓冲区和 Channel 通道<strong>配合使用</strong>来处理数据的。</p>
<p>简单理解一下：</p>
<p>可以把 Channel 通道比作铁路，buffer 缓冲区比作成火车(运载着货物)</p>
<p>而我们的 NIO 就是通过 Channel 通道运输着存储数据的 Buffer 缓冲区的来实现数据的处理！</p>
<p>要时刻记住：Channel 不与数据打交道，它只负责运输数据。与数据打交道的是 Buffer 缓冲区</p>
<ul>
<li><strong>Channel—&gt;运输</strong></li>
<li><strong>Buffer—&gt;数据</strong></li>
</ul>
<p>相对于传统 IO 而言，<strong>流是单向的</strong>。对于 NIO 而言，有了 Channel 通道这个概念，我们的<strong>读写都是双向</strong>的(铁路上的火车能从广州去北京、自然就能从北京返还到广州)！</p>
<p><strong>Buffer 缓冲区 </strong></p>
<p>我们来看看 Buffer 缓冲区有什么值得我们注意的地方。</p>
<p>Buffer 是缓冲区的抽象类：</p>
<p><img src="\assets\note\image-20231012205023003.png" alt="image-20231012205023003"></p>
<p>其中 ByteBuffer 是用得最多的实现类(在通道中读写字节数据)。</p>
<p><img src="\assets\note\image-20231012205041246.png" alt="image-20231012205041246"></p>
<p>拿到一个缓冲区我们往往会做什么？很简单，就是读取缓冲区的数据/写数据到缓冲区中。所以，缓冲区的核心方法就是 put 和 get：</p>
<p><img src="\assets\note\image-20231012205105823.png" alt="image-20231012205105823"></p>
<p>Buffer 类维护了 4 个核心变量来提供<strong>关于其所包含的数组信息</strong>。它们是：</p>
<p>容量 Capacity <strong>缓冲区能够容纳的数据元素的最大数量</strong>。容量在缓冲区创建时被设定，并且永远不能被改变。(不能被改变的原因也很简单，底层是数组嘛)</p>
<p>上界 Limit <strong>缓冲区里的数据的总数</strong>，代表了当前缓冲区中一共有多少数据。</p>
<p>位置 Position <strong>下一个要被读或写的元素的位置</strong>。Position 会自动由相应的 get()和 put()函数更新。</p>
<p>标记 Mark 一个备忘位置。<strong>用于记录上一次读写的位置</strong>。</p>
<p>首先展示一下<strong>是如何创建缓冲区的，核心变量的值是怎么变化的。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个缓冲区</span><br><span class="line">ByteBuffer byteBuffer = ByteBuffer.allocate(1024);</span><br><span class="line">// 看一下初始时4个核心变量的值</span><br><span class="line">System.out.println(&quot;初始时--&gt;limit---&gt;&quot;+byteBuffer.limit());</span><br><span class="line">System.out.println(&quot;初始时--&gt;position---&gt;&quot;+byteBuffer.position());</span><br><span class="line">System.out.println(&quot;初始时--&gt;capacity---&gt;&quot;+byteBuffer.capacity());</span><br><span class="line">System.out.println(&quot;初始时--&gt;mark---&gt;&quot; + byteBuffer.mark());</span><br><span class="line">System.out.println(&quot;--------------------------------------&quot;);</span><br><span class="line">// 添加一些数据到缓冲区中</span><br><span class="line">String s = &quot;沉默王二&quot;;</span><br><span class="line">byteBuffer.put(s.getBytes());</span><br><span class="line">// 看一下初始时4个核心变量的值</span><br><span class="line">System.out.println(&quot;put完之后--&gt;limit---&gt;&quot;+byteBuffer.limit());</span><br><span class="line">System.out.println(&quot;put完之后--&gt;position---&gt;&quot;+byteBuffer.position());</span><br><span class="line">System.out.println(&quot;put完之后--&gt;capacity---&gt;&quot;+byteBuffer.capacity());</span><br><span class="line">System.out.println(&quot;put完之后--&gt;mark---&gt;&quot; + byteBuffer.mark());</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">初始时--&gt;limit---&gt;1024</span><br><span class="line">初始时--&gt;position---&gt;0</span><br><span class="line">初始时--&gt;capacity---&gt;1024</span><br><span class="line">初始时--&gt;mark---&gt;java.nio.HeapByteBuffer[pos=0 lim=1024 cap=1024]</span><br><span class="line">--------------------------------------</span><br><span class="line">put完之后--&gt;limit---&gt;1024</span><br><span class="line">put完之后--&gt;position---&gt;12</span><br><span class="line">put完之后--&gt;capacity---&gt;1024</span><br><span class="line">put完之后--&gt;mark---&gt;java.nio.HeapByteBuffer[pos=12 lim=1024 cap=1024]</span><br></pre></td></tr></table></figure>
<p>现在<strong>我想要从缓存区拿数据</strong>，怎么拿呀？？NIO 给了我们一个 flip()方法。这个方法可以<strong>改动 position 和 limit 的位置！</strong></p>
<p>在之前代码的基础上，我们 flip() 一下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// flip()方法</span><br><span class="line">byteBuffer.flip();</span><br><span class="line">System.out.println(&quot;flip()方法之后--&gt;limit---&gt;&quot;+byteBuffer.limit());</span><br><span class="line">System.out.println(&quot;flip()方法之后--&gt;position---&gt;&quot;+byteBuffer.position());</span><br><span class="line">System.out.println(&quot;flip()方法之后--&gt;capacity---&gt;&quot;+byteBuffer.capacity());</span><br><span class="line">System.out.println(&quot;flip()方法之后--&gt;mark---&gt;&quot; + byteBuffer.mark());</span><br></pre></td></tr></table></figure>
<p>再看看 4 个核心属性的值会发生什么变化：</p>
<p><img src="\assets\note\image-20231012210003858.png" alt="image-20231012210003858"></p>
<p>在调用 flip() 之后，limit 变为当前 position 的值（12），position 重置为 0。这意味着你可以从缓冲区的开始位置读取刚刚写入的数据，直到 limit 指定的位置。capacity 保持不变（1024）。</p>
<p>假设我们有一个初始容量为 1024 的 ByteBuffer。</p>
<p><strong>初始状态:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">position = 0</span><br><span class="line">limit = 1024</span><br><span class="line">capacity = 1024</span><br></pre></td></tr></table></figure>
<p><strong>添加数据 “沉默王二” 后:</strong></p>
<p>由于 “沉默王二” 为 UTF-8 编码，一个汉字占 3 个字节，共有 4 个汉字，所以占用 12 个字节。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">position = 12</span><br><span class="line">limit = 1024</span><br><span class="line">capacity = 1024</span><br></pre></td></tr></table></figure>
<p>调用flip()方法后:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">position = 0</span><br><span class="line">limit = 12</span><br><span class="line">capacity = 1024</span><br></pre></td></tr></table></figure>
<p>用一幅图来表示就是。</p>
<p><img src="\assets\note\image-20231012210206210.png" alt="image-20231012210206210"></p>
<p>当切换成读模式之后，我们就可以读取缓冲区的数据了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个limit()大小的字节数组(因为就只有limit这么多个数据可读)</span><br><span class="line">byte[] bytes = new byte[byteBuffer.limit()];</span><br><span class="line">// 将读取的数据装进我们的字节数组中</span><br><span class="line">byteBuffer.get(bytes);</span><br><span class="line">// 输出数据</span><br><span class="line">System.out.println(new String(bytes, 0, bytes.length));</span><br></pre></td></tr></table></figure>
<p>输出后的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">沉默王二</span><br></pre></td></tr></table></figure>
<p>随后输出一下核心变量的值看看：</p>
<p><img src="\assets\note\image-20231012210643892.png" alt="image-20231012210643892"></p>
<p><strong>读完如何还想写数据到缓冲区</strong>，那就使用 clear() 方法，这个方法会“清空”缓冲区，数据没有真正被清空，只是被遗忘掉了</p>
<p><img src="\assets\note\image-20231012210710648.png" alt="image-20231012210710648"></p>
<p><strong>Channel 通道 </strong></p>
<p>Channel 通道<strong>只负责传输数据、不直接操作数据</strong>。操作数据都是通过 Buffer 缓冲区来进行操作！通常，通道可以分为两大类：文件通道和套接字通道。</p>
<p>FileChannel：用于文件 I/O 的通道，支持文件的读、写和追加操作。FileChannel 允许在文件的任意位置进行数据传输，支持文件锁定以及内存映射文件等高级功能。FileChannel 无法设置为非阻塞模式，因此它只适用于阻塞式文件操作。</p>
<p>SocketChannel：用于 TCP 套接字 I/O 的通道。SocketChannel 支持非阻塞模式，可以与 Selector（下文会讲）一起使用，实现高效的网络通信。SocketChannel 允许连接到远程主机，进行数据传输。</p>
<p>与之匹配的有ServerSocketChannel：用于监听 TCP 套接字连接的通道。与 SocketChannel 类似，ServerSocketChannel 也支持非阻塞模式，并可以与 Selector 一起使用。ServerSocketChannel 负责监听新的连接请求，接收到连接请求后，可以创建一个新的 </p>
<p>DatagramChannel：用于 UDP 套接字 I/O 的通道。DatagramChannel 支持非阻塞模式，可以发送和接收数据报包，适用于无连接的、不可靠的网络通信。</p>
<p>这篇我们主要来讲 FileChannel，SocketChannel、ServerSocketChannel 和 DatagramChannel 会放到后面的章节中讲解。</p>
<p><strong>文件通道 FileChannel </strong></p>
<p>可以通过下面的方式打开一个通道。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileChannel.open(Paths.get(&quot;docs/配套教程.md&quot;), StandardOpenOption.WRITE);</span><br></pre></td></tr></table></figure>
<p>这里我们用到了 Paths，这个后面也会讲到。</p>
<p>①、使用<strong>FileChannel 配合 ByteBuffer 缓冲区</strong>实现文件复制的功能：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">try (FileChannel sourceChannel = </span><br><span class="line">FileChannel.open(Paths.get(&quot;logs/javabetter/itwanger.txt&quot;), </span><br><span class="line">StandardOpenOption.READ);</span><br><span class="line">    FileChannel destinationChannel = </span><br><span class="line">FileChannel.open(Paths.get(&quot;logs/javabetter/itwanger1.txt&quot;), </span><br><span class="line">StandardOpenOption.WRITE, StandardOpenOption.CREATE)) &#123;</span><br><span class="line">  ByteBuffer buffer = ByteBuffer.allocate(1024);</span><br><span class="line">  while (sourceChannel.read(buffer) != -1) &#123;</span><br><span class="line">      buffer.flip();</span><br><span class="line">      destinationChannel.write(buffer);</span><br><span class="line">      buffer.clear();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们创建一个容量为 1024 的 ByteBuffer 作为缓冲区。在循环中，我们从源文件的 FileChannel 读取数据到缓冲区。当 read() 方法返回 -1 时，表示已经到达文件末尾。</p>
<p>读取数据后，我们调用 flip() 方法，以便在缓冲区中准备好要写入的数据。然后，我们将缓冲区的内容写入目标文件的 FileChannel（ write() 方法）。在写入完成后，我们调用 clear() 方法重置缓冲区，以便在下一次迭代中重用它。</p>
<p>②、使用<strong>内存映射文件（MappedByteBuffer）</strong>的方式实现<strong>文件复制</strong>的功能(直接操作缓冲区)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">try (FileChannel sourceChannel = </span><br><span class="line">FileChannel.open(Paths.get(&quot;logs/javabetter/itwanger.txt&quot;), </span><br><span class="line">StandardOpenOption.READ);</span><br><span class="line">      FileChannel destinationChannel = </span><br><span class="line">FileChannel.open(Paths.get(&quot;logs/javabetter/itwanger2.txt&quot;), </span><br><span class="line">StandardOpenOption.WRITE, StandardOpenOption.CREATE, StandardOpenOption.READ)) &#123;</span><br><span class="line">    long fileSize = sourceChannel.size();</span><br><span class="line">    MappedByteBuffer sourceMappedBuffer = </span><br><span class="line">sourceChannel.map(FileChannel.MapMode.READ_ONLY, 0, fileSize);</span><br><span class="line">    MappedByteBuffer destinationMappedBuffer = </span><br><span class="line">destinationChannel.map(FileChannel.MapMode.READ_WRITE, 0, fileSize);</span><br><span class="line">    for (int i = 0; i &lt; fileSize; i++) &#123;</span><br><span class="line">        byte b = sourceMappedBuffer.get(i);</span><br><span class="line">        destinationMappedBuffer.put(i, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MappedByteBuffer 是 Java NIO 中的一个类，它继承自 java.nio.ByteBuffer 。MappedByteBuffer 用于表示一个内存映射文件，即将文件的一部分或全部映射到内存中，以便通过直接操作内存来实现对文件的读写。这种方式可以提高文件 I/O 的性能，因为操作系统可以直接在内存和磁盘之间传输数据，无需通过 Java 应用程序进行额外的数据拷贝。</p>
<p>通常与 FileChannel 一起使用，可以通过调用 FileChannel 的 map() 方法创建 MappedByteBuffer 对象。map() 方法接受三个参数：映射模式（FileChannel.MapMode）映射起始位置和映射的长度。</p>
<p>映射模式包括只读模式（READ_ONLY）、读写模式（READ_WRITE）和专用模式（PRIVATE）。</p>
<p>我们设置源文件的 MappedByteBuffer 为只读模式（READ_ONLY），目标文件的 MappedByteBuffer 为读写模式（READ_WRITE）。</p>
<p>在循环中，我们逐字节地从源文件的 MappedByteBuffer 读取数据并将其写入目标文件的 MappedByteBuffer。这样就实现了文件复制功能。利用内存映射文件（MappedByteBuffer）实现的文件复制，可能会比使用 ByteBuffer 的方法更快。</p>
<p>需要注意的是，使用 MappedByteBuffer 进行文件操作时，数据的修改可能不会立即写入磁盘。可以通过调用 MappedByteBuffer 的 force() 方法将数据立即写回磁盘。</p>
<p>③、通道之间通过 transfer()实现数据的传输(直接操作缓冲区)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">try (FileChannel sourceChannel = </span><br><span class="line">FileChannel.open(Paths.get(&quot;logs/javabetter/itwanger.txt&quot;), </span><br><span class="line">StandardOpenOption.READ);</span><br><span class="line">      FileChannel destinationChannel = </span><br><span class="line">FileChannel.open(Paths.get(&quot;logs/javabetter/itwanger3.txt&quot;), </span><br><span class="line">StandardOpenOption.WRITE, StandardOpenOption.CREATE, StandardOpenOption.READ)) &#123;</span><br><span class="line">    sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    throw new RuntimeException(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FileChannel 的 transferTo() 方法是一个高效的文件传输方法，它允许将文件的一部分或全部内容直接从源文件通道传输到目标通道（通常是另一个文件通道或网络通道）。这种传输方式可以避免将文件数据在用户空间和内核空间之间进行多次拷贝，提高了文件传输的性能。</p>
<p>transferTo() 方法接受以下三个参数：</p>
<ul>
<li>position：源文件中开始传输的位置。</li>
<li>count：要传输的字节数。</li>
<li>target：接收数据的目标通道。</li>
</ul>
<p>需要注意的是， transferTo() 方法可能无法一次传输所有请求的字节。在实际应用中，你可能需要使用循环来确保所有字节都被传输。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class FileChannelTransferToLoopExampleWithPaths &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Path sourcePath = Paths.get(&quot;logs/itwanger/paicoding.txt&quot;);</span><br><span class="line">        Path destinationPath = Paths.get(&quot;logs/itwanger/paicoding_copy.txt&quot;);</span><br><span class="line">        // 使用 try-with-resources 语句确保通道资源被正确关闭</span><br><span class="line">        try (FileChannel sourceChannel = FileChannel.open(sourcePath, </span><br><span class="line">StandardOpenOption.READ);</span><br><span class="line">             FileChannel destinationChannel = FileChannel.open(destinationPath, </span><br><span class="line">StandardOpenOption.CREATE, StandardOpenOption.WRITE)) &#123;</span><br><span class="line">            long position = 0;</span><br><span class="line">            long count = sourceChannel.size();</span><br><span class="line">            // 循环传输，直到所有字节都被传输</span><br><span class="line">            while (position &lt; count) &#123;</span><br><span class="line">                long transferred = sourceChannel.transferTo(position, count - </span><br><span class="line">position, destinationChannel);</span><br><span class="line">                position += transferred;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外， transferTo() 方法在底层使用了操作系统提供的零拷贝功能（如 Linux 的 sendfile() 系统调用），可以大幅提高文件传输性能。但是，不同操作系统和 JVM 实现可能会影响零拷贝的可用性和性能，因此实际性能可能因环境而异。</p>
<p>零拷贝（Zero-Copy）是一种优化数据传输性能的技术，它最大限度地减少了在数据传输过程中的 CPU 和内存开销。在传统的数据传输过程中，数据通常需要在用户空间和内核空间之间进行多次拷贝，这会导致额外的 CPU 和内存开销。零拷贝技术通过避免这些多余的拷贝操作，实现了更高效的数据传输。</p>
<p>在 Java 中，零拷贝技术主要应用于文件和网络 I/O。FileChannel 类的 transferTo() 和 transferFrom() 方法就利用了零拷贝技术，可以在文件和网络通道之间高效地传输数据。</p>
<p><strong>直接与非直接缓冲区 </strong></p>
<p>直接缓冲区和非直接缓冲区的差别主要在于它们在内存中的存储方式。这里给出了直接缓冲区和非直接缓冲区的简要概述和区别：</p>
<p>非直接缓冲区：</p>
<ul>
<li>分配在 JVM 堆内存中</li>
<li>受到垃圾回收的管理</li>
<li>在读写操作时，需要将数据从堆内存复制到操作系统的本地内存，再进行 I/O 操作</li>
<li>创建： ByteBuffer.allocate(int capacity)</li>
</ul>
<p>直接缓冲区：</p>
<ul>
<li>分配在操作系统的本地内存中</li>
<li>不受垃圾回收的管理</li>
<li>在读写操作时，直接在本地内存中进行，避免了数据复制，提高了性能</li>
<li>创建： ByteBuffer.allocateDirect(int capacity)</li>
<li>还有前面提到的 FileChannel.map() 方法，会返回一个类型为 MappedByteBuffer 的直接缓冲区。</li>
</ul>
<p>ByteBuffer.allocate和ByteBuffer.allocateDirect直接的差异。</p>
<p><img src="\assets\note\image-20231012212248398.png" alt="image-20231012212248398"></p>
<p>直接缓冲区和非直接缓冲区之间的差异。</p>
<p><img src="\assets\note\image-20231012212321462.png" alt="image-20231012212321462"></p>
<p>非直接缓冲区存储在JVM内部，数据需要从应用程序（Java）复制到非直接缓冲区，再复制到内核缓冲区，最后发送到设备（磁盘/网络）。而对于直接缓冲区，数据可以直接从应用程序（Java）复制到内核缓冲区，无需经过JVM的非直接缓冲区。</p>
<p><strong>异步文件通道 AsynchronousFileChannel </strong></p>
<p>AsynchronousFileChannel 是 Java 7 引入的一个异步文件通道类，提供了对文件的异步读、写、打开和关闭等操作。</p>
<p>可以通过 AsynchronousFileChannel.open() 方法打开一个异步文件通道，该方法接受一个 Path 对象和一组打开选项（如 StandardOpenOption.READ、StandardOpenOption.WRITE 等）作为参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Path file = Paths.get(&quot;example.txt&quot;);</span><br><span class="line">AsynchronousFileChannel fileChannel = AsynchronousFileChannel.open(file, </span><br><span class="line">StandardOpenOption.READ, StandardOpenOption.WRITE);</span><br></pre></td></tr></table></figure>
<p>AsynchronousFileChannel 提供了两种异步操作的方式：</p>
<p>①、Future 方式：使用 Future 对象来跟踪异步操作的完成情况。当我们调用一个异步操作（如 read() 或 write() ）时，它会立即返回一个 Future 对象。可以使用这个对象来检查操作是否完成，以及获取操作的结果。这种方式适用于不需要在操作完成时立即执行其他操作的场景。</p>
<p>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.allocate(1024);</span><br><span class="line">long position = 0;</span><br><span class="line">Future&lt;Integer&gt; result = fileChannel.read(buffer, position);</span><br><span class="line">while (!result.isDone()) &#123;</span><br><span class="line">    // 执行其他操作</span><br><span class="line">&#125;</span><br><span class="line">int bytesRead = result.get();</span><br><span class="line">System.out.println(&quot;Bytes read: &quot; + bytesRead);</span><br></pre></td></tr></table></figure>
<p>②、CompletionHandler 方式，使用一个实现了 CompletionHandler 接口的对象来处理异步操作的完成。我们需要提供一个 CompletionHandler 实现类，重写 completed() 和 failed() 方法，分别处理操作成功和操作失败的情况。当异步操作完成时，系统会自动调用相应的方法。这种方式适用于需要在操作完成时立即执行其他操作的场景。</p>
<p>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.allocate(1024);</span><br><span class="line">long position = 0;</span><br><span class="line">fileChannel.read(buffer, position, buffer, new CompletionHandler&lt;Integer, </span><br><span class="line">ByteBuffer&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void completed(Integer result, ByteBuffer attachment) &#123;</span><br><span class="line">        System.out.println(&quot;Bytes read: &quot; + result);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void failed(Throwable exc, ByteBuffer attachment) &#123;</span><br><span class="line">        System.err.println(&quot;Read failed&quot;);</span><br><span class="line">        exc.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>来看完整的示例，采用 Future 的形式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Path path = Paths.get(&quot;docs/配套教程.md&quot;);</span><br><span class="line">try (AsynchronousFileChannel fileChannel = AsynchronousFileChannel.open(path, </span><br><span class="line">StandardOpenOption.READ)) &#123;</span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(1024);</span><br><span class="line">    long position = 0;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        Future&lt;Integer&gt; result = fileChannel.read(buffer, position);</span><br><span class="line">        while (!result.isDone()) &#123;</span><br><span class="line">            // 在这里可以执行其他任务，例如处理其他 I/O 操作</span><br><span class="line">        &#125;</span><br><span class="line">        int bytesRead = result.get();</span><br><span class="line">        if (bytesRead &lt;= 0) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        position += bytesRead;</span><br><span class="line">        buffer.flip();</span><br><span class="line">        byte[] data = new byte[buffer.limit()];</span><br><span class="line">        buffer.get(data);</span><br><span class="line">        System.out.println(new String(data));</span><br><span class="line">        buffer.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们使用 AsynchronousFileChannel.read() 方法发起异步读取操作。这个方法会返回一个 Future<Integer> 对象，表示读取操作的结果。我们可以通过调用 isDone() 方法来检查异步操作是否完成。完成后，我们可以通过调用 get() 方法获取实际读取的字节数。</p>
<p>然后我们来看 CompletionHandler 接口的形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public static void readAllBytes(Path path) throws IOException, InterruptedException </span><br><span class="line">&#123;</span><br><span class="line">    AsynchronousFileChannel fileChannel = AsynchronousFileChannel.open(path, </span><br><span class="line">StandardOpenOption.READ);</span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(1024);</span><br><span class="line">    AtomicLong position = new AtomicLong(0);</span><br><span class="line">    CountDownLatch latch = new CountDownLatch(1);</span><br><span class="line">    fileChannel.read(buffer, position.get(), null, new CompletionHandler&lt;Integer, Object&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void completed(Integer bytesRead, Object attachment) &#123;</span><br><span class="line">            if (bytesRead &gt; 0) &#123;</span><br><span class="line">                position.addAndGet(bytesRead);</span><br><span class="line">                buffer.flip();</span><br><span class="line">                byte[] data = new byte[buffer.limit()];</span><br><span class="line">                buffer.get(data);</span><br><span class="line">                System.out.print(new String(data));</span><br><span class="line">                buffer.clear();</span><br><span class="line">                fileChannel.read(buffer, position.get(), attachment, this);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                latch.countDown();</span><br><span class="line">                try &#123;</span><br><span class="line">                    fileChannel.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public void failed(Throwable exc, Object attachment) &#123;</span><br><span class="line">            System.out.println(&quot;Error: &quot; + exc.getMessage());</span><br><span class="line">            latch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    latch.await();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1、在 readAllBytes 方法中，我们使用 AsynchronousFileChannel.open() 方法以读取模式打开异步文件通道。</p>
<p>2、创建一个大小为 1024 的 ByteBuffer 来存储从文件中读取的数据。</p>
<p>3、使用 AtomicLong 类型的 position 变量来记录当前读取的文件位置。初始值为 0。</p>
<p>4、创建一个 CountDownLatch 对象，用于在异步操作完成时通知主线程。初始值为 1。</p>
<p>5、使用 fileChannel.read() 方法启动异步读取操作。这个方法的参数包括：用于存储数据的缓冲区、当前读取位置、附加对象（在这个例子中不需要，所以传递 null）以及一个实现了 CompletionHandler 接口的对象，用于在读取操作完成时回调。</p>
<p>6、CompletionHandler 接口有两个方法： completed() 和 failed() 。在读取操作成功完成时调用 completed() 方法；如果读取操作失败，调用 failed() 方法。</p>
<p>7、在 completed() 方法中，我们首先检查 bytesRead（本次读取的字节数）是否大于 0。如果大于 0，说明还有数据需要读取。</p>
<ul>
<li>更新 position 变量，将其增加 bytesRead。</li>
<li>将缓冲区翻转（ flip() ），以便我们可以从中读取数据。</li>
<li>创建一个新的字节数组，其大小等于缓冲区的限制（ limit() ）。</li>
<li>从缓冲区中获取数据并将其存储在新创建的字节数组中。</li>
<li>将字节数组转换为字符串并输出。</li>
<li>清除缓冲区，以便我们可以继续读取更多数据。</li>
<li>再次调用 fileChannel.read() 方法，以继续从文件中读取数据。</li>
</ul>
<p>8、如果 bytesRead 等于或小于 0，说明我们已经读取完文件中的所有数据。此时，我们需要：调用 latch.countDown() 方法，以通知主线程异步操作已完成。关闭 fileChannel。</p>
<p>9、如果读取操作失败，我们将在 failed() 方法中输出错误信息并调用 latch.countDown() 方法通知主线程。</p>
<p>10、最后，我们调用 latch.await() 方法来等待异步操作完成。主线程将在此处阻塞，直到 latch 的计数变为 0。 </p>
<p><strong>小结 </strong></p>
<p>Java NIO 中的 Buffer 和 Channel 是 NIO 系统的核心组件。Buffer 负责存储数据，提供了对数据的读写操作。它有多种类型，如 ByteBuffer、CharBuffer、IntBuffer 等，以支持不同的数据类型。</p>
<p>Channel 代表了与 I/O 设备（如文件或套接字）之间的连接。它提供了从源设备到 Buffer 的数据读取能力和从 Buffer 到目标设备的数据写入能力。Channel 可以是可读、可写或同时可读写的，我们详细介绍了文件通道 FileChannel 和异步文件通道 AsynchronousFileChannel。</p>
<p>总之，NIO 使用 Buffer 和 Channel 这两个组件来进行高效的数据传输，以提高 I/O 操作的性能。</p>
<h2 id="10-4-Paths-和-Files"><a href="#10-4-Paths-和-Files" class="headerlink" title="10.4 Paths 和 Files"></a>10.4 Paths 和 Files</h2><p>Paths 和 Files 在 Java 7 的时候引入，作为对 java.io.File 类的补充和改进。</p>
<p><strong>Paths 类 </strong></p>
<p>Paths 类主要用于操作文件和目录路径。它提供了一些静态方法，用于创建 java.nio.file.Path实例，代表文件系统中的路径。</p>
<p>下面是 Paths 的一个示例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个Path实例，表示当前目录下的一个文件</span><br><span class="line">Path path = Paths.get(&quot;example.txt&quot;);</span><br><span class="line">// 创建一个绝对路径</span><br><span class="line">Path absolutePath = Paths.get(&quot;/home/user/example.txt&quot;);</span><br></pre></td></tr></table></figure>
<p>java.nio.file.Path 接口在 Java NIO.2 中代表一个文件系统中的路径。它提供了一系列方法来操作和查询路径。</p>
<p><img src="\assets\note\image-20231012213428186.png" alt="image-20231012213428186"></p>
<p>下面是 Paths 和 Path 一起使用的实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Path path = Paths.get(&quot;docs/配套教程.md&quot;);</span><br><span class="line">// 获取文件名</span><br><span class="line">System.out.println(&quot;File name: &quot; + path.getFileName());</span><br><span class="line">// 获取父目录</span><br><span class="line">System.out.println(&quot;Parent: &quot; + path.getParent());</span><br><span class="line">// 获取根目录</span><br><span class="line">System.out.println(&quot;Root: &quot; + path.getRoot());</span><br><span class="line">// 将路径与另一个路径结合</span><br><span class="line">Path newPath = path.resolve(&quot;config/app.properties&quot;);</span><br><span class="line">System.out.println(&quot;Resolved path: &quot; + newPath);</span><br><span class="line">// 简化路径</span><br><span class="line">Path normalizedPath = newPath.normalize();</span><br><span class="line">System.out.println(&quot;Normalized path: &quot; + normalizedPath);</span><br><span class="line">// 将相对路径转换为绝对路径</span><br><span class="line">Path absolutePath = path.toAbsolutePath();</span><br><span class="line">System.out.println(&quot;Absolute path: &quot; + absolutePath);</span><br><span class="line">// 计算两个路径之间的相对路径</span><br><span class="line">Path basePath = Paths.get(&quot;/docs/&quot;);</span><br><span class="line">Path targetPath = Paths.get(&quot;/docs/imgs/itwanger&quot;);</span><br><span class="line">Path relativePath = basePath.relativize(targetPath);</span><br><span class="line">System.out.println(&quot;Relative path: &quot; + relativePath);</span><br></pre></td></tr></table></figure>
<p><strong>Files 类 </strong></p>
<p>java.nio.file.Files类提供了大量静态方法，用于处理文件系统中的文件和目录。这些方法包括文件的创建、删除、复制、移动等操作，以及读取和设置文件属性。</p>
<p>下面展示一个 Files 和 Paths 一起使用的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个Path实例</span><br><span class="line">Path path = Paths.get(&quot;logs/javabetter/itwanger4.txt&quot;);</span><br><span class="line">// 创建一个新文件</span><br><span class="line">Files.createFile(path);</span><br><span class="line">// 检查文件是否存在</span><br><span class="line">boolean exists = Files.exists(path);</span><br><span class="line">System.out.println(&quot;File exists: &quot; + exists);</span><br><span class="line">// 删除文件</span><br><span class="line">Files.delete(path);</span><br></pre></td></tr></table></figure>
<p>以下是一些常用方法及其示例：</p>
<p>1、 exists(Path path, LinkOption… options) ：检查文件或目录是否存在。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Path path = Paths.get(&quot;file.txt&quot;);</span><br><span class="line">boolean exists = Files.exists(path);</span><br><span class="line">System.out.println(&quot;File exists: &quot; + exists);</span><br></pre></td></tr></table></figure>
<p>LinkOption 是一个枚举类，它定义了如何处理文件系统链接的选项。它位于 java.nio.file 包中。LinkOption 主要在与文件或目录的路径操作相关的方法中使用，以控制这些方法如何处理符号链接。符号链接是一种特殊类型的文件，它在 Unix 和类 Unix 系统（如 Linux 和 macOS）上很常见。在 Windows 上，类似的概念被称为快捷方式。</p>
<p>2、 createFile(Path path, FileAttribute&lt;?&gt;… attrs) ：创建一个新的空文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Path newPath = Paths.get(&quot;newFile.txt&quot;);</span><br><span class="line">Files.createFile(newPath);</span><br></pre></td></tr></table></figure>
<p>FileAttribute 是一个泛型接口，用于处理各种不同类型的属性。在使用 FileAttribute 时，你需要为其提供一个特定的实现。 java.nio.file.attribute 包中的 PosixFileAttributes 类提供了 POSIX（Portable Operating System Interface，定义了许多与文件系统相关的操作，包括文件和目录的创建、删除、读取和修改。）文件属性的实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Path path = Paths.get(&quot;fileWithPermissions.txt&quot;);</span><br><span class="line">Set&lt;PosixFilePermission&gt; permissions = PosixFilePermissions.fromString(&quot;rw-r-----&quot;);</span><br><span class="line">FileAttribute&lt;Set&lt;PosixFilePermission&gt;&gt; fileAttribute = </span><br><span class="line">PosixFilePermissions.asFileAttribute(permissions);</span><br><span class="line">Files.createFile(path, fileAttribute);</span><br></pre></td></tr></table></figure>
<p>PosixFileAttributes 接口提供了获取 POSIX 文件属性的方法，如文件所有者、文件所属的组以及文件的访问权限。以上示例会创建一个读写属性的文件。</p>
<p>3、 createDirectory(Path dir, FileAttribute&lt;?&gt;… attrs) ：创建一个新的目录。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Path newDir = Paths.get(&quot;newDirectory&quot;);</span><br><span class="line">Files.createDirectory(newDir);</span><br></pre></td></tr></table></figure>
<p>4、 delete(Path path) ：删除文件或目录。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Path pathToDelete = Paths.get(&quot;fileToDelete.txt&quot;);</span><br><span class="line">Files.delete(pathToDelete);</span><br></pre></td></tr></table></figure>
<p>5、 copy(Path source, Path target, CopyOption… options) ：复制文件或目录。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Path sourcePath = Paths.get(&quot;sourceFile.txt&quot;);</span><br><span class="line">Path targetPath = Paths.get(&quot;targetFile.txt&quot;);</span><br><span class="line">Files.copy(sourcePath, targetPath, StandardCopyOption.REPLACE_EXISTING);</span><br></pre></td></tr></table></figure>
<p>在 Java NIO 中，有两个实现了 CopyOption 接口的枚举类：StandardCopyOption 和 LinkOption。</p>
<p>StandardCopyOption 枚举类提供了以下两个选项：</p>
<ul>
<li>REPLACE_EXISTING：如果目标文件已经存在，该选项会使 Files.copy() 方法替换目标文件。如果不指定此选项， Files.copy() 方法在目标文件已存在时将抛出 FileAlreadyExistsException。</li>
<li>COPY_ATTRIBUTES：此选项表示在复制文件时，尽可能地复制文件的属性（如文件时间戳、权限等）。如果不指定此选项，那么目标文件将具有默认的属性。</li>
</ul>
<p>6、 move(Path source, Path target, CopyOption… options) ：移动或重命名文件或目录。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Path sourcePath = Paths.get(&quot;sourceFile.txt&quot;);</span><br><span class="line">Path targetPath = Paths.get(&quot;targetFile.txt&quot;);</span><br><span class="line">Files.move(sourcePath, targetPath, StandardCopyOption.REPLACE_EXISTING);</span><br></pre></td></tr></table></figure>
<p>7、 readAllLines(Path path, Charset cs) ：读取文件的所有行到一个字符串列表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ath path = Paths.get(&quot;file.txt&quot;);</span><br><span class="line">List&lt;String&gt; lines = Files.readAllLines(path, StandardCharsets.UTF_8);</span><br><span class="line">lines.forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>8、 write(Path path, Iterable&lt;? extends CharSequence&gt; lines, Charset cs, OpenOption… options) ：将字符串列表写入文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Path path = Paths.get(&quot;file.txt&quot;);</span><br><span class="line">List&lt;String&gt; lines = Arrays.asList(&quot;沉默王二 1&quot;, &quot;沉默王二 2&quot;, &quot;沉默王二 3&quot;);</span><br><span class="line">Files.write(path, lines, StandardCharsets.UTF_8);</span><br></pre></td></tr></table></figure>
<p>OpenOption 是 Java NIO 中一个用于配置文件操作的接口。它提供了在使用 Files.newByteChannel() 、Files.newInputStream() 、 Files.newOutputStream() 、 AsynchronousFileChannel.open() 和 FileChannel.open() 方法时定制行为的选项。</p>
<p>在 Java NIO 中，有两个实现了 OpenOption 接口的枚举类：StandardOpenOption 和 LinkOption。</p>
<p>StandardOpenOption 枚举类提供了以下几个选项：</p>
<ul>
<li>READ：以读取模式打开文件。</li>
<li>WRITE：以写入模式打开文件。</li>
<li>APPEND：以追加模式打开文件。</li>
<li>TRUNCATE_EXISTING：在打开文件时，截断文件的内容，使其长度为 0。仅适用于 WRITE 或 APPEND 模式。</li>
<li>CREATE：当文件不存在时创建文件。如果文件已存在，则打开文件。</li>
<li>CREATE_NEW：当文件不存在时创建文件。如果文件已存在，抛出 FileAlreadyExistsException。</li>
<li>DELETE_ON_CLOSE：在关闭通道时删除文件。</li>
<li>SPARSE：提示文件系统创建一个稀疏文件。</li>
<li>SYNC：要求每次更新文件的内容或元数据时都进行同步。</li>
<li>DSYNC：要求每次更新文件内容时都进行同步。</li>
</ul>
<p>8、 newBufferedReader(Path path, Charset cs) 和 newBufferedWriter(Path path, Charset cs, OpenOption… options) ：创建 BufferedReader 和 BufferedWriter 对象以读取和写入文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Path path = Paths.get(&quot;file.txt&quot;);</span><br><span class="line">// Read file</span><br><span class="line">try (BufferedReader reader = Files.newBufferedReader(path, StandardCharsets.UTF_8)) </span><br><span class="line">&#123;</span><br><span class="line">    String line;</span><br><span class="line">    while ((line = reader.readLine()) != null) &#123;</span><br><span class="line">        System.out.println(line);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// Write file</span><br><span class="line">Path outputPath = Paths.get(&quot;outputFile.txt&quot;);</span><br><span class="line">try (BufferedWriter writer = Files.newBufferedWriter(outputPath, </span><br><span class="line">StandardCharsets.UTF_8)) &#123;</span><br><span class="line">    writer.write(&quot;沉默王二&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Files.walkFileTree() 静态方法 </strong></p>
<p>这个方法可以递归地访问目录结构中的所有文件和目录，并允许您对这些文件和目录执行自定义操作。使用 walkFileTree 方法时，需要提供一个起始路径（起始目录）和一个实现了 FileVisitor 接口的对象。</p>
<p>FileVisitor 接口包含四个方法，它们在遍历过程中的不同阶段被调用：</p>
<ul>
<li>preVisitDirectory：在访问目录之前调用。</li>
<li>postVisitDirectory：在访问目录之后调用。</li>
<li>visitFile：在访问文件时调用。</li>
<li>visitFileFailed：在访问文件失败时调用。</li>
</ul>
<p>来看下面这个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class WalkFileTreeExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Path startingDir = Paths.get(&quot;docs&quot;);</span><br><span class="line">        MyFileVisitor fileVisitor = new MyFileVisitor();</span><br><span class="line">        try &#123;</span><br><span class="line">            Files.walkFileTree(startingDir, fileVisitor);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private static class MyFileVisitor extends SimpleFileVisitor&lt;Path&gt; &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException &#123;</span><br><span class="line">            System.out.println(&quot;准备访问目录: &quot; + dir);</span><br><span class="line">            return FileVisitResult.CONTINUE;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException &#123;</span><br><span class="line">            System.out.println(&quot;正在访问目录: &quot; + dir);</span><br><span class="line">            return FileVisitResult.CONTINUE;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException &#123;</span><br><span class="line">            System.out.println(&quot;访问文件: &quot; + file);</span><br><span class="line">            return FileVisitResult.CONTINUE;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException &#123;</span><br><span class="line">            System.err.println(&quot;访问文件失败: &quot; + file);</span><br><span class="line">            return FileVisitResult.CONTINUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">准备访问目录: docs</span><br><span class="line">访问文件: docs/安装环境.md</span><br><span class="line">准备访问目录: docs/imgs</span><br><span class="line">访问文件: docs/imgs/init_03.jpg</span><br><span class="line">准备访问目录: docs/imgs/itwanger</span><br><span class="line">访问文件: docs/imgs/itwanger/tongzhishu.jpeg</span><br><span class="line">访问文件: docs/imgs/itwanger/tongzhishu1.jpeg</span><br><span class="line">访问文件: docs/imgs/itwanger/tongzhishu1.pdf</span><br><span class="line">正在访问目录: docs/imgs/itwanger</span><br><span class="line">访问文件: docs/imgs/init_02.jpg</span><br><span class="line">访问文件: docs/imgs/init_00.jpg</span><br><span class="line">访问文件: docs/imgs/init_01.jpg</span><br><span class="line">访问文件: docs/imgs/init_04.jpg</span><br><span class="line">正在访问目录: docs/imgs</span><br><span class="line">访问文件: docs/服务器启动教程.md</span><br><span class="line">访问文件: docs/配套教程.md</span><br><span class="line">访问文件: docs/约定.md</span><br><span class="line">访问文件: docs/本地开发环境配置教程.md</span><br><span class="line">访问文件: docs/前端工程结构说明.md</span><br><span class="line">正在访问目录: docs</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们创建了一个名为 MyFileVisitor 的自定义 FileVisitor 类，它扩展了 SimpleFileVisitor 类。SimpleFileVisitor 是 FileVisitor 接口的一个实现，它提供了一些默认的行为。我们可以覆盖 SimpleFileVisitor 中的方法以实现自己的逻辑。在这个例子中，我们只是打印出了访问的文件和目录。然后，我们使用 Files.walkFileTree 方法遍历文件树。这个方法会遍历整个目录结构，并调用 MyFileVisitor 中的相应方法。</p>
<p>其中，FileVisitResult 枚举包含以下四个选项：</p>
<ul>
<li>CONTINUE ： 继续</li>
<li>TERMINATE ： 终止</li>
<li>SKIP_SIBLINGS ： 跳过兄弟节点，然后继续</li>
<li>SKIP_SUBTREE ： 跳过子树（不访问此目录的条目），然后继续，仅在 preVisitDirectory 方法返回时才有意义，除此以外和 CONTINUE 相同。</li>
</ul>
<p><strong>搜索文件 </strong></p>
<p>walkFileTree() 方法还可以用于搜索文件，下面这个例子扩展了 SimpleFileVisitor 来查找一个名为 itwanger.txt 的文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class FindFileWithWalkFileTree &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Path startingDir = Paths.get(&quot;logs&quot;);</span><br><span class="line">        String targetFileName = &quot;itwanger.txt&quot;;</span><br><span class="line">        FindFileVisitor findFileVisitor = new FindFileVisitor(targetFileName);</span><br><span class="line">        try &#123;</span><br><span class="line">            Files.walkFileTree(startingDir, findFileVisitor);</span><br><span class="line">            if (findFileVisitor.isFileFound()) &#123;</span><br><span class="line">                System.out.println(&quot;找到文件了: &quot; + findFileVisitor.getFoundFilePath());</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                System.out.println(&quot;ooh，文件没找到&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private static class FindFileVisitor extends SimpleFileVisitor&lt;Path&gt; &#123;</span><br><span class="line">        private String targetFileName;</span><br><span class="line">        private Path foundFilePath;</span><br><span class="line">        public FindFileVisitor(String targetFileName) &#123;</span><br><span class="line">            this.targetFileName = targetFileName;</span><br><span class="line">        &#125;</span><br><span class="line">        public boolean isFileFound() &#123;</span><br><span class="line">            return foundFilePath != null;</span><br><span class="line">        &#125;</span><br><span class="line">        public Path getFoundFilePath() &#123;</span><br><span class="line">            return foundFilePath;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException &#123;</span><br><span class="line">            String fileName = file.getFileName().toString();</span><br><span class="line">            if (fileName.equals(targetFileName)) &#123;</span><br><span class="line">                foundFilePath = file;</span><br><span class="line">                return FileVisitResult.TERMINATE;</span><br><span class="line">            &#125;</span><br><span class="line">            return FileVisitResult.CONTINUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在主方法中，我们使用 Files.walkFileTree 方法遍历文件树，并传递一个起始目录和 FindFileVisitor 实例。</p>
<p>遍历完成后，我们检查是否找到了目标文件，如果找到了，就打印出它的路径。</p>
<p>搜索结果如下所示：</p>
<p><img src="\assets\note\image-20231012214346676.png" alt="image-20231012214346676"></p>
<p><strong>小结 </strong></p>
<p>Paths 和 Files 是 Java NIO 中的两个核心类。Paths 提供了一系列静态方法，用于操作路径（Path 对象）。它可以将字符串或 URI 转换为 Path 对象，方便后续操作。Files 类提供了丰富的文件操作方法，如文件的创建、删除、移动、复制、读取和写入等。这些方法支持各种选项和属性，如覆盖、保留属性和符号链接处理。Files 还支持文件遍历（如 walkFileTree 方法），可以处理文件目录树。总之，Paths 和 Files 为文件和目录操作提供了简洁、高效的方法。</p>
<h2 id="10-5-NIO-实现简易版聊天室"><a href="#10-5-NIO-实现简易版聊天室" class="headerlink" title="10.5 NIO 实现简易版聊天室"></a>10.5 NIO 实现简易版聊天室</h2><p>在此之前，我们曾利用 Java 的套接字 Socket 和 ServerSocket 完成网络编程，但 Socket 和 ServerSocket 是基于 Java IO 的，在网络编程方面，性能会比较差。原因我们在之前也讲过。</p>
<p>那 Java NIO 的 SocketChannel 和 ServerSocketChannel 性能怎么样呢？</p>
<p><strong>SocketChannel 和 ServerSocketChannel </strong></p>
<p>在学习 NIO 的第一讲里，我们已经介绍过 SocketChannel 和 ServerSocketChannel了，这里再简单补充下。</p>
<p>ServerSocketChannel 用于创建服务器端套接字，而 SocketChannel 用于创建客户端套接字。它们都支持阻塞和非阻塞模式，通过设置其 blocking 属性来切换。阻塞模式下，读/写操作会一直阻塞直到完成，而非阻塞模式下，读/写操作会立即返回。</p>
<p>阻塞模式：</p>
<ul>
<li>优点：编程简单，适合低并发场景。</li>
<li>缺点：性能较差，不适合高并发场景。</li>
</ul>
<p>非阻塞模式：</p>
<ul>
<li>优点：性能更好，适合高并发场景。</li>
<li>缺点：编程相对复杂。</li>
</ul>
<p>我们来看一个简单的示例（阻塞模式下）：</p>
<p>先来看 Server 端的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class BlockingServer &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        // 创建服务器套接字</span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        // 绑定端口</span><br><span class="line">        serverSocketChannel.socket().bind(new InetSocketAddress(8080));</span><br><span class="line">        // 设置为阻塞模式（默认为阻塞模式）</span><br><span class="line">        serverSocketChannel.configureBlocking(true);</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            // 接收客户端连接</span><br><span class="line">            SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">            // 分配缓冲区</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(1024);</span><br><span class="line">            // 读取数据</span><br><span class="line">            int bytesRead = socketChannel.read(buffer);</span><br><span class="line">            while (bytesRead != -1) &#123;</span><br><span class="line">                buffer.flip();</span><br><span class="line">                System.out.println(StandardCharsets.UTF_8.decode(buffer));</span><br><span class="line">                buffer.clear();</span><br><span class="line">                bytesRead = socketChannel.read(buffer);</span><br><span class="line">            &#125;</span><br><span class="line">            // 关闭套接字</span><br><span class="line">            socketChannel.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单解释一下这段代码，也比较好理解。</p>
<p>首先创建服务器端套接字ServerSocketChannel，然后绑定 8080 端口，接着使用 while 循环监听客户端套接字。如果接收到客户端连接 SocketChannel，就从通道里读取数据到缓冲区 ByteBuffer，一直读到通道里没有数据，关闭当前通道。</p>
<p>其中 serverSocketChannel.configureBlocking(true) 用来设置通道为阻塞模式（可以缺省）。</p>
<p>再来看客户端的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class BlockingClient &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        // 创建客户端套接字</span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">        // 连接服务器</span><br><span class="line">        socketChannel.connect(new InetSocketAddress(&quot;localhost&quot;, 8080));</span><br><span class="line">        // 分配缓冲区</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(1024);</span><br><span class="line">        // 向服务器发送数据</span><br><span class="line">        buffer.put(&quot;沉默王二，这是来自客户端的消息。&quot;.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        buffer.flip();</span><br><span class="line">        socketChannel.write(buffer);</span><br><span class="line">        // 清空缓冲区</span><br><span class="line">        buffer.clear();</span><br><span class="line">        // 关闭套接字</span><br><span class="line">        socketChannel.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端代码就更简单了，建立通道 SocketChannel，连接服务器，然后在缓冲区里放一段数据，之后写入到通道中，关闭套接字。</p>
<p>先运行 BlockingServer，再运行 BlockingClient，可以在 Server 端的控制台收到以下信息。</p>
<p><img src="\assets\note\image-20231012214653033.png" alt="image-20231012214653033"></p>
<p>好，我们再来看非阻塞模式下的示例。</p>
<p>先来看 Server 端： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class NonBlockingServer &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        // 创建服务器套接字</span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        // 绑定端口</span><br><span class="line">        serverSocketChannel.socket().bind(new InetSocketAddress(8080));</span><br><span class="line">        // 设置为非阻塞模式</span><br><span class="line">        serverSocketChannel.configureBlocking(false);</span><br><span class="line">        // 创建选择器</span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        // 注册服务器套接字到选择器</span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            selector.select();</span><br><span class="line">            Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selectedKeys.iterator();</span><br><span class="line">            while (iterator.hasNext()) &#123;</span><br><span class="line">                SelectionKey key = iterator.next();</span><br><span class="line">                iterator.remove();</span><br><span class="line">                if (key.isAcceptable()) &#123;</span><br><span class="line">                    // 接收客户端连接</span><br><span class="line">                    SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">                    socketChannel.configureBlocking(false);</span><br><span class="line">                    socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                &#125;</span><br><span class="line">                if (key.isReadable()) &#123;</span><br><span class="line">                    // 读取数据</span><br><span class="line">                    SocketChannel socketChannel = (SocketChannel) key.channel();</span><br><span class="line">                    ByteBuffer buffer = ByteBuffer.allocate(1024);</span><br><span class="line">                    int bytesRead = socketChannel.read(buffer);</span><br><span class="line">                    if (bytesRead != -1) &#123;</span><br><span class="line">                        buffer.flip();</span><br><span class="line">                        System.out.print(StandardCharsets.UTF_8.decode(buffer));</span><br><span class="line">                        buffer.clear();</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        // 客户端已断开连接，取消选择键并关闭通道</span><br><span class="line">                        key.cancel();</span><br><span class="line">                        socketChannel.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与之前阻塞模式相同的，我们就不再赘述了，只说不同的。</p>
<p>①、首先，创建一个 ServerSocketChannel，并将其设置为非阻塞模式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">serverSocketChannel.configureBlocking(false);</span><br></pre></td></tr></table></figure>
<p>②、创建一个 Selector 实例，用于处理多个通道的事件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure>
<p>③、将 ServerSocketChannel 注册到 Selector 上，并设置感兴趣的事件为 OP_ACCEPT。这意味着当有新的客户端连接请求时，Selector 会通知我们。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></figure>
<p>看一下 OP_ACCEPT 的注释：<br>            <img src="\assets\note\image-20231012214842790.png" alt="image-20231012214842790"></p>
<p>④、循环处理 Selector 中的事件。首先调用 selector.select() 方法来等待感兴趣的事件发生。这个方法会阻塞，直到至少有一个感兴趣的事件发生。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while (true) &#123;</span><br><span class="line">    int readyChannels = selector.select();</span><br><span class="line">    if (readyChannels == 0) &#123;</span><br><span class="line">        continue;</span><br><span class="line">    &#125;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>⑤、当 selector.select() 返回时，我们可以通过 selector.selectedKeys() 获取所有已就绪的事件，并对其进行迭代处理。在处理事件时，根据 SelectionKey 的类型来执行相应的操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line">Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();</span><br><span class="line">while (keyIterator.hasNext()) &#123;</span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line">    // 处理事件</span><br><span class="line">    // ...</span><br><span class="line">    keyIterator.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>⑥、当 SelectionKey 的类型为 OP_ACCEPT 时，说明有新的客户端连接请求。此时，我们需要接受新的连接，并将新创建的 SocketChannel 设置为非阻塞模式。然后，将该 SocketChannel 注册到 Selector 上，并设置感兴趣的事件为 OP_READ。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (key.isAcceptable()) &#123;</span><br><span class="line">    ServerSocketChannel server = (ServerSocketChannel) key.channel();</span><br><span class="line">    SocketChannel client = server.accept();</span><br><span class="line">    client.configureBlocking(false);</span><br><span class="line">    client.register(selector, SelectionKey.OP_READ);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>⑦、当 SelectionKey 的类型为 OP_READ 时，说明有客户端发送了数据。我们需要从 SocketChannel 中读取数据，并进行相应的处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (key.isReadable()) &#123;</span><br><span class="line">    SocketChannel client = (SocketChannel) key.channel();</span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(1024);</span><br><span class="line">    int bytesRead = client.read(buffer);</span><br><span class="line">    // 对读取到的数据进行处理</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>⑧、（如果可以的话）当 SelectionKey 的类型为 OP_WRITE 时，说明可以向客户端发送数据。我们可以将要发送的数据写入 SocketChannel。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (key.isWritable()) &#123;</span><br><span class="line">    SocketChannel client = (SocketChannel) key.channel();</span><br><span class="line">    ByteBuffer buffer = ByteBuffer.wrap(&quot;你好，客户端&quot;.getBytes());</span><br><span class="line">   client.write(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过，本例中并没有这一步。如果需要的话，可以按照这样的方式向客户端写入数据。</p>
<p>⑨、在服务器停止运行时，需要关闭 Selector 和 ServerSocketChannel，释放资源。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">key.cancel();</span><br><span class="line">socketChannel.close();</span><br></pre></td></tr></table></figure>
<p>好，接下来，我们来看客户端的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class NonBlockingClient &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        // 创建客户端套接字</span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">        // 设置为非阻塞模式</span><br><span class="line">        socketChannel.configureBlocking(false);</span><br><span class="line">        // 连接服务器</span><br><span class="line">        socketChannel.connect(new InetSocketAddress(&quot;localhost&quot;, 8080));</span><br><span class="line">        while (!socketChannel.finishConnect()) &#123;</span><br><span class="line">            // 等待连接完成</span><br><span class="line">        &#125;</span><br><span class="line">        // 分配缓冲区</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(1024);</span><br><span class="line">        // 向服务器发送数据</span><br><span class="line">        String message = &quot;你好，沉默王二，这是来自客户端的消息。&quot;;</span><br><span class="line">        buffer.put(message.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        buffer.flip();</span><br><span class="line">        socketChannel.write(buffer);</span><br><span class="line">        // 清空缓冲区</span><br><span class="line">        buffer.clear();</span><br><span class="line">        // 关闭套接字</span><br><span class="line">        socketChannel.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端代码依然比较简单，我们直接略过，不再解释。然后运行 Server，再运行 Client。可以运行多次，结果如下：</p>
<p><img src="\assets\note\image-20231012215131916.png" alt="image-20231012215131916"></p>
<p><strong>Scatter 和 Gather </strong></p>
<p>Scatter 和 Gather 是 Java NIO 中两种高效的 I/O 操作，用于将数据分散到多个缓冲区或从多个缓冲区中收集数据。</p>
<p>Scatter（分散）：它将从 Channel 读取的数据分散（写入）到多个缓冲区。这种操作可以在读取数据时将其分散到不同的缓冲区，有助于处理结构化数据。例如，我们可以将消息头、消息体和消息尾分别写入不同的缓冲区。</p>
<p>Gather（聚集）：与 Scatter 相反，它将多个缓冲区中的数据聚集（读取）并写入到一个 Channel。这种操作允许我们在发送数据时从多个缓冲区中聚集数据。例如，我们可以将消息头、消息体和消息尾从不同的缓冲区中聚集到一起并写入到同一个 Channel。</p>
<p>来写一个完整的 demo，先看 Server。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个ServerSocketChannel</span><br><span class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">serverSocketChannel.socket().bind(new InetSocketAddress(9000));</span><br><span class="line">// 接受连接</span><br><span class="line">SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">// Scatter：分散读取数据到多个缓冲区</span><br><span class="line">ByteBuffer headerBuffer = ByteBuffer.allocate(128);</span><br><span class="line">ByteBuffer bodyBuffer = ByteBuffer.allocate(1024);</span><br><span class="line">ByteBuffer[] buffers = &#123;headerBuffer, bodyBuffer&#125;;</span><br><span class="line">long bytesRead = socketChannel.read(buffers);</span><br><span class="line">// 输出缓冲区数据</span><br><span class="line">headerBuffer.flip();</span><br><span class="line">while (headerBuffer.hasRemaining()) &#123;</span><br><span class="line">    System.out.print((char) headerBuffer.get());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">bodyBuffer.flip();</span><br><span class="line">while (bodyBuffer.hasRemaining()) &#123;</span><br><span class="line">    System.out.print((char) bodyBuffer.get());</span><br><span class="line">&#125;</span><br><span class="line">// Gather：聚集数据从多个缓冲区写入到Channel</span><br><span class="line">ByteBuffer headerResponse = ByteBuffer.wrap(&quot;Header Response&quot;.getBytes());</span><br><span class="line">ByteBuffer bodyResponse = ByteBuffer.wrap(&quot;Body Response&quot;.getBytes());</span><br><span class="line">ByteBuffer[] responseBuffers = &#123;headerResponse, bodyResponse&#125;;</span><br><span class="line">long bytesWritten = socketChannel.write(responseBuffers);</span><br><span class="line">// 关闭连接</span><br><span class="line">socketChannel.close();</span><br><span class="line">serverSocketChannel.close();</span><br></pre></td></tr></table></figure>
<p>再来看 Client：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个SocketChannel</span><br><span class="line">SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">socketChannel.connect(new InetSocketAddress(&quot;localhost&quot;, 9000));</span><br><span class="line">// 发送数据到服务器</span><br><span class="line">String header = &quot;Header Content&quot;;</span><br><span class="line">String body = &quot;Body Content&quot;;</span><br><span class="line">ByteBuffer headerBuffer = ByteBuffer.wrap(header.getBytes());</span><br><span class="line">ByteBuffer bodyBuffer = ByteBuffer.wrap(body.getBytes());</span><br><span class="line">ByteBuffer[] buffers = &#123;headerBuffer, bodyBuffer&#125;;</span><br><span class="line">socketChannel.write(buffers);</span><br><span class="line">// 从服务器接收数据</span><br><span class="line">ByteBuffer headerResponseBuffer = ByteBuffer.allocate(128);</span><br><span class="line">ByteBuffer bodyResponseBuffer = ByteBuffer.allocate(1024);</span><br><span class="line">ByteBuffer[] responseBuffers = &#123;headerResponseBuffer, bodyResponseBuffer&#125;;</span><br><span class="line">long bytesRead = socketChannel.read(responseBuffers);</span><br><span class="line">// 输出接收到的数据</span><br><span class="line">headerResponseBuffer.flip();</span><br><span class="line">while (headerResponseBuffer.hasRemaining()) &#123;</span><br><span class="line">    System.out.print((char) headerResponseBuffer.get());</span><br><span class="line">&#125;</span><br><span class="line">bodyResponseBuffer.flip();</span><br><span class="line">while (bodyResponseBuffer.hasRemaining()) &#123;</span><br><span class="line">    System.out.print((char) bodyResponseBuffer.get());</span><br><span class="line">&#125;</span><br><span class="line">// 关闭连接</span><br><span class="line">socketChannel.close();</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们使用了 Scattering 从 SocketChannel 分散读取数据到多个缓冲区，并使用 Gathering 将数据从多个缓冲区聚集写入到 SocketChannel。通过这种方式，我们可以方便地处理多个缓冲区中的数据。</p>
<p><strong>异步套接字通道 AsynchronousSocketChannel 和 AsynchronousServerSocketChannel</strong></p>
<p>AsynchronousSocketChannel 和 AsynchronousServerSocketChannel 是 Java 7 引入的异步 I/O 类，分别用于处理异步客户端 Socket 和服务器端 ServerSocket。异步 I/O 允许在 I/O 操作进行时执行其他任务，并在操作完成时接收通知，提高了并发处理能力。</p>
<p>来看一个简单的示例，先看服务器端。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class AsynchronousServer &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException, InterruptedException </span><br><span class="line">&#123;</span><br><span class="line">        AsynchronousServerSocketChannel server = AsynchronousServerSocketChannel.open();</span><br><span class="line">        server.bind(new InetSocketAddress(&quot;localhost&quot;, 5000));</span><br><span class="line">        System.out.println(&quot;服务器端启动&quot;);</span><br><span class="line">        server.accept(null, new CompletionHandler&lt;AsynchronousSocketChannel, Void&gt;() </span><br><span class="line">&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void completed(AsynchronousSocketChannel client, Void attachment) </span><br><span class="line">&#123;</span><br><span class="line">                // 接收下一个连接请求</span><br><span class="line">                server.accept(null, this);</span><br><span class="line">                ByteBuffer buffer = ByteBuffer.allocate(1024);</span><br><span class="line">                Future&lt;Integer&gt; readResult = client.read(buffer);</span><br><span class="line">                try &#123;</span><br><span class="line">                    readResult.get();</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    String message = new String(buffer.array(), 0, buffer.remaining());</span><br><span class="line">                    System.out.println(&quot;接收到的消息: &quot; + message);</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            @Override</span><br><span class="line">            public void failed(Throwable exc, Void attachment) &#123;</span><br><span class="line">                exc.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        // 为了让服务器继续运行，我们需要阻止 main 线程退出</span><br><span class="line">        Thread.currentThread().join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码结构和之前讲到的异步文件通道 AsynchronousFileChannel 比较相似，异步服务单套接字通道 AsynchronousServerSocketChannel 接收客户端连接，每当收到一个新的连接时，会调用 completed() 方法，然后读取客户端发送的数据并将其打印到控制台。</p>
<p>来简单分析一下吧。</p>
<p>①、创建了一个 AsynchronousServerSocketChannel 实例并将其打开。这个通道将用于监听客户端连接。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AsynchronousServerSocketChannel server = AsynchronousServerSocketChannel.open();</span><br></pre></td></tr></table></figure>
<p>②、调用 accept() 方法来接收客户端连接。这个方法需要一个 CompletionHandler 实例，当客户端连接成功时， completed() 方法会被调用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server.accept(null, new CompletionHandler&lt;AsynchronousSocketChannel, Void&gt;() &#123; ... </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>③、实现 CompletionHandler，I/O 操作成功时，会调用 completed() 方法；当 I/O 操作失败时，会调用 failed() 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new CompletionHandler&lt;AsynchronousSocketChannel, Void&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void completed(AsynchronousSocketChannel client, Void attachment) &#123; ... &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void failed(Throwable exc, Void attachment) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 completed 方法中，我们首先调用 server.accept() 来接收下一个连接请求。然后，我们创建一个缓冲区 ByteBuffer 并使用 client.read() 从客户端读取数据。在这个示例中，我们使用了一个 Future 对象来等待读取操作完成。当读取完成时，我们将缓冲区的内容打印到控制台。           </p>
<p>④、为了让服务器继续运行并接收客户端连接，我们需要阻止 main 线程退出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.currentThread().join();</span><br></pre></td></tr></table></figure>
<p>再来看客户端的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class AsynchronousClient &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            AsynchronousSocketChannel client = AsynchronousSocketChannel.open();</span><br><span class="line">            Future&lt;Void&gt; connectResult = client.connect(new </span><br><span class="line">InetSocketAddress(&quot;localhost&quot;, 5000));</span><br><span class="line">            connectResult.get(); // 等待连接完成</span><br><span class="line">            String message = &quot;沉默王二，在吗？&quot;;</span><br><span class="line">            ByteBuffer buffer = </span><br><span class="line">ByteBuffer.wrap(message.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">            Future&lt;Integer&gt; writeResult = client.write(buffer);</span><br><span class="line">            writeResult.get(); // 等待发送完成</span><br><span class="line">            System.out.println(&quot;消息发送完毕&quot;);</span><br><span class="line">            client.close();</span><br><span class="line">        &#125; catch (IOException | InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是简单的连接和写入数据，就不多做解释了。这里先运行一下 Server 端，然后再运行一下客户端，看一下结果。</p>
<p><img src="\assets\note\image-20231012215719411.png" alt="image-20231012215719411"></p>
<p><strong>简单的聊天室 </strong></p>
<p>我们来通过 SocketChannel 和 ServerSocketChannel 实现一个 0.1 版的聊天室，先说一下需求，比较简单，服务端启动监听客户端请求，当客户端向服务器端发送信息后，服务器端接收到后把客户端消息回显给客户端，比较呆瓜，但可以先来看一下。</p>
<p><img src="\assets\note\image-20231012215746839.png" alt="image-20231012215746839"></p>
<p>我们来看服务器端代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public class ChatServer &#123;</span><br><span class="line">    private Selector selector;</span><br><span class="line">    private ServerSocketChannel serverSocketChannel;</span><br><span class="line">    private static final int PORT = 8080;</span><br><span class="line">    public ChatServer() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">            serverSocketChannel.socket().bind(new InetSocketAddress(PORT));</span><br><span class="line">            serverSocketChannel.configureBlocking(false);</span><br><span class="line">            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            System.out.println(&quot;聊天室服务端启动了 &quot; + PORT);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void start() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                if (selector.select() &gt; 0) &#123;</span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">                    while (iterator.hasNext()) &#123;</span><br><span class="line">                        SelectionKey key = iterator.next();</span><br><span class="line">                        iterator.remove();</span><br><span class="line">                        handleKey(key);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private void handleKey(SelectionKey key) throws IOException &#123;</span><br><span class="line">        if (key.isAcceptable()) &#123;</span><br><span class="line">            SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">            socketChannel.configureBlocking(false);</span><br><span class="line">            socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">            System.out.println(&quot;客户端连接上了: &quot; + socketChannel.getRemoteAddress());</span><br><span class="line">        &#125; else if (key.isReadable()) &#123;</span><br><span class="line">            SocketChannel socketChannel = (SocketChannel) key.channel();</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(1024);</span><br><span class="line">            int read = socketChannel.read(buffer);</span><br><span class="line">            if (read &gt; 0) &#123;</span><br><span class="line">                buffer.flip();</span><br><span class="line">                String msg = new String(buffer.array(), 0, read);</span><br><span class="line">                System.out.println(&quot;客户端说: &quot; + msg);</span><br><span class="line">                socketChannel.write(ByteBuffer.wrap((&quot;服务端回复: &quot; + msg).getBytes()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new ChatServer().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释一下代码逻辑：</p>
<p>1、创建一个 ServerSocketChannel，并将其绑定到指定端口。</p>
<p>2、将 ServerSocketChannel 设置为非阻塞模式。</p>
<p>3、创建一个 Selector，并将 ServerSocketChannel 注册到它上面，监听 OP_ACCEPT 事件（等待客户端连接）。</p>
<p>4、无限循环，等待感兴趣的事件发生。</p>
<p>5、使用 Selector.select() 方法，等待已注册的通道中有事件发生。</p>
<p>6、获取到发生事件的通道的 SelectionKey。</p>
<p>7、判断 SelectionKey 的事件类型：</p>
<ul>
<li>a. 如果是 OP_ACCEPT 事件，说明有新的客户端连接进来。接受新的连接，并将新连接的 SocketChannel 注册到 Selector 上，监听 OP_READ 事件。</li>
<li>b. 如果是 OP_READ 事件，说明客户端发送了消息。读取客户端发送的消息，并将其返回给客户端。 处理完毕后，清除已处理的 SelectionKey。</li>
</ul>
<p>再来看一下客户端的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">public class ChatClient &#123;</span><br><span class="line">    private Selector selector;</span><br><span class="line">    private SocketChannel socketChannel;</span><br><span class="line">    private static final String HOST = &quot;localhost&quot;;</span><br><span class="line">    private static final int PORT = 8080;</span><br><span class="line">    public ChatClient() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            socketChannel = SocketChannel.open(new InetSocketAddress(HOST, PORT));</span><br><span class="line">            socketChannel.configureBlocking(false);</span><br><span class="line">            socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">            System.out.println(&quot;连接到聊天室了&quot;);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void start() &#123;</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                while (true) &#123;</span><br><span class="line">                    if (selector.select() &gt; 0) &#123;</span><br><span class="line">                        for (SelectionKey key : selector.selectedKeys()) &#123;</span><br><span class="line">                            selector.selectedKeys().remove(key);</span><br><span class="line">                            if (key.isReadable()) &#123;</span><br><span class="line">                                readMessage();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        try (BufferedReader reader = new BufferedReader(new InputStreamReader(System.in))) &#123;</span><br><span class="line">            String input;</span><br><span class="line">            while ((input = reader.readLine()) != null) &#123;</span><br><span class="line">                sendMessage(input);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private void sendMessage(String message) throws IOException &#123;</span><br><span class="line">        if (message != null &amp;&amp; !message.trim().isEmpty()) &#123;</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.wrap(message.getBytes());</span><br><span class="line">            socketChannel.write(buffer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private void readMessage() throws IOException &#123;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(1024);</span><br><span class="line">        int read = socketChannel.read(buffer);</span><br><span class="line">        if (read &gt; 0) &#123;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            String msg = new String(buffer.array(), 0, read);</span><br><span class="line">            System.out.println(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new ChatClient().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释一下代码逻辑：</p>
<p>1、创建一个 SocketChannel，并连接到指定的服务器地址和端口。</p>
<p>2、将 SocketChannel 设置为非阻塞模式。</p>
<p>3、创建一个 Selector，并将 SocketChannel 注册到它上面，监听 OP_READ 事件（等待接收服务器的消息）。</p>
<p>4、启动一个新线程用于读取用户在控制台输入的消息，并发送给服务器。</p>
<p>5、无限循环，等待感兴趣的事件发生。</p>
<p>6、使用 Selector.select() 方法，等待已注册的通道中有事件发生。</p>
<p>7、获取到发生事件的通道的 SelectionKey。</p>
<p>8、判断 SelectionKey 的事件类型：</p>
<ul>
<li>a. 如果是 OP_READ 事件，说明服务器发送了消息。读取服务器发送的消息，并在控制台显示。 处理完毕后，清除已处理的 SelectionKey。</li>
</ul>
<p>来看运行后的效果。</p>
<p><img src="\assets\note\image-20231012220110996.png" alt="image-20231012220110996"></p>
<p>好，接下来，我们来升级一下需求，也就是 0.2 版聊天室，要求服务器端也能从控制台敲入信息主动发送给客户端。</p>
<p><img src="\assets\note\image-20231012220139117.png" alt="image-20231012220139117"></p>
<p>来看服务器端代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">public class Chat2Server &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        // 创建一个 ServerSocketChannel</span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        serverSocketChannel.configureBlocking(false);</span><br><span class="line">        serverSocketChannel.bind(new InetSocketAddress(8080));</span><br><span class="line">        // 创建一个 Selector</span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        System.out.println(&quot;聊天室服务端启动了&quot;);</span><br><span class="line">        // 客户端连接</span><br><span class="line">        AtomicReference&lt;SocketChannel&gt; clientRef = new AtomicReference&lt;&gt;();</span><br><span class="line">        // 从控制台读取输入并发送给客户端</span><br><span class="line">        Thread sendMessageThread = new Thread(() -&gt; &#123;</span><br><span class="line">            try (BufferedReader reader = new BufferedReader(new InputStreamReader(System.in))) &#123;</span><br><span class="line">                while (true) &#123;</span><br><span class="line">                    System.out.println(&quot;输入服务器端消息: &quot;);</span><br><span class="line">                    String message = reader.readLine();</span><br><span class="line">                    SocketChannel client = clientRef.get();</span><br><span class="line">                    if (client != null &amp;&amp; client.isConnected()) &#123;</span><br><span class="line">                        ByteBuffer buffer = ByteBuffer.wrap((message + &quot;\n&quot;).getBytes());</span><br><span class="line">                        client.write(buffer);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        sendMessageThread.start();</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            int readyChannels = selector.select();</span><br><span class="line">            if (readyChannels == 0) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();</span><br><span class="line">            while (keyIterator.hasNext()) &#123;</span><br><span class="line">                SelectionKey key = keyIterator.next();</span><br><span class="line">                if (key.isAcceptable()) &#123;</span><br><span class="line">                    // 接受客户端连接</span><br><span class="line">                    SocketChannel client = serverSocketChannel.accept();</span><br><span class="line">                    System.out.println(&quot;客户端已连接&quot;);</span><br><span class="line">                    client.configureBlocking(false);</span><br><span class="line">                    client.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                    clientRef.set(client);</span><br><span class="line">                &#125; else if (key.isReadable()) &#123;</span><br><span class="line">                    // 读取客户端消息</span><br><span class="line">                    SocketChannel channel = (SocketChannel) key.channel();</span><br><span class="line">                    ByteBuffer buffer = ByteBuffer.allocate(1024);</span><br><span class="line">                    int bytesRead = channel.read(buffer);</span><br><span class="line">                    if (bytesRead &gt; 0) &#123;</span><br><span class="line">                        buffer.flip();</span><br><span class="line">                        byte[] bytes = new byte[buffer.remaining()];</span><br><span class="line">                        buffer.get(bytes);</span><br><span class="line">                        String message = new String(bytes).trim();</span><br><span class="line">                        System.out.println(&quot;客户端消息: &quot; + message);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                keyIterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来看客户端代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public class Chat2Client &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        // 创建一个 SocketChannel</span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">        socketChannel.configureBlocking(false);</span><br><span class="line">        socketChannel.connect(new InetSocketAddress(&quot;localhost&quot;, 8080));</span><br><span class="line">        // 创建一个 Selector</span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_CONNECT);</span><br><span class="line">        // 从控制台读取输入并发送给服务器端</span><br><span class="line">        Thread sendMessageThread = new Thread(() -&gt; &#123;</span><br><span class="line">            try (BufferedReader reader = new BufferedReader(new InputStreamReader(System.in))) &#123;</span><br><span class="line">                while (true) &#123;</span><br><span class="line">                    System.out.println(&quot;输入客户端消息: &quot;);</span><br><span class="line">                    String message = reader.readLine();</span><br><span class="line">                    if (socketChannel.isConnected()) &#123;</span><br><span class="line">                        ByteBuffer buffer = ByteBuffer.wrap((message + &quot;\n&quot;).getBytes());</span><br><span class="line">                        socketChannel.write(buffer);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        sendMessageThread.start();</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            int readyChannels = selector.select();</span><br><span class="line">            if (readyChannels == 0) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();</span><br><span class="line">            while (keyIterator.hasNext()) &#123;</span><br><span class="line">                SelectionKey key = keyIterator.next();</span><br><span class="line">                if (key.isConnectable()) &#123;</span><br><span class="line">                    // 连接到服务器</span><br><span class="line">                    socketChannel.finishConnect();</span><br><span class="line">                    socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                    System.out.println(&quot;已连接到服务器&quot;);</span><br><span class="line">                &#125; else if (key.isReadable()) &#123;</span><br><span class="line">                    // 读取服务器端消息</span><br><span class="line">                    ByteBuffer buffer = ByteBuffer.allocate(1024);</span><br><span class="line">                    int bytesRead = socketChannel.read(buffer);</span><br><span class="line">                    if (bytesRead &gt; 0) &#123;</span><br><span class="line">                        buffer.flip();</span><br><span class="line">                        byte[] bytes = new byte[buffer.remaining()];</span><br><span class="line">                        buffer.get(bytes);</span><br><span class="line">                        String message = new String(bytes).trim();</span><br><span class="line">                        System.out.println(&quot;服务器端消息: &quot; + message);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                keyIterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行 Server，再运行 Client，交互信息如下：</p>
<p><img src="\assets\note\image-20231012220341934.png" alt="image-20231012220341934"></p>
<p>我们使用了 Selector 和非阻塞 I/O，这使得服务器可以同时处理多个连接。所以我们在 Intellij IDEA 中可以再配置一个客户端，见下图（填上这四项内容）。</p>
<p><img src="\assets\note\image-20231012220410559.png" alt="image-20231012220410559"></p>
<p>然后启动，就可以完成一个 Server 和多个 Client 交互了。</p>
<p><img src="\assets\note\image-20231012220436009.png" alt="image-20231012220436009"></p>
<p>OK，关于聊天室，我们就先讲到这里。</p>
<p><strong>小结 </strong></p>
<p>前面我们了解到，Java NIO 在文件 IO 上的性能其实和传统 IO 差不多，甚至在处理大文件的时候还有些甘拜下风，但 NIO 的主要作用体现在网络 IO 上，像 Netty 框架底层其实就是 NIO，我们来做一下简单的总结吧。</p>
<p>SocketChannel（用于 TCP 连接）和 ServerSocketChannel（用于监听和接受新的 TCP 连接）可以用来替代传统的 Socket 和 ServerSocket 类，提供非阻塞模式。</p>
<p>NIO 支持阻塞和非阻塞模式。非阻塞模式允许程序在等待 I/O 时执行其他任务，从而提高并发性能。非阻塞模式的实现依赖于 Selector，它可以监控多个通道上的 I/O 事件。</p>
<p>NIO 支持将数据分散到多个 Buffer（Scatter）或从多个 Buffer 收集数据（Gather），提供了更高效的数据传输方式。</p>
<p>Java NIO.2 引入了 AsynchronousSocketChannel 和 AsynchronousServerSocketChannel，这些类提供了基于回调的异步 I/O 操作。异步套接字通道可以在完成 I/O 操作时自动触发回调函数，从而实现高效的异步处理。</p>
<p>最后，我们使用 NIO 实现了简单的聊天室功能。通过 ServerSocketChannel 和 SocketChannel 创建服务端和客户端，实现互相发送和接收消息。在处理多个客户端时，可以使用 Selector 来管理多个客户端连接，提高并发性能。</p>
<p>总之，Java NIO 网络编程实践提供了更高效、灵活且可扩展的 I/O 处理方式，对于大型应用程序和高并发场景具有显著优势。</p>
<h2 id="10-6-Java-IO模型"><a href="#10-6-Java-IO模型" class="headerlink" title="10.6 Java IO模型"></a>10.6 Java IO模型</h2><p>Java 的 IO 分为两大类，一类是传统的 IO（Blocking IO），一类是 NIO （New IO）。</p>
<p>传统的 IO 基于字节流和字符流，以阻塞式 IO 操作为主。常用的类有 FileInputStream、FileOutputStream、InputStreamReader、OutputStreamWriter 等。这些类在读写数据时，会导致执行线程阻塞，直到操作完成。</p>
<p>Java NIO 是 Java 1.4 版本引入的，基于通道（Channel）和缓冲区（Buffer）进行操作，采用非阻塞式 IO 操作，允许线程在等待 IO 时执行其他任务。常见的 NIO 类有 ByteBuffer、FileChannel、SocketChannel、ServerSocketChannel 等。</p>
<p><strong>阻塞 IO 和非阻塞 IO </strong></p>
<p>那什么是阻塞式 IO，什么是非阻塞 IO 呢？</p>
<p>阻塞 I/O（Blocking I/O）：在这种模型中，I/O 操作是阻塞的，即执行 I/O 操作时，线程会被阻塞，直到操作完成。在阻塞 I/O 模型中，每个连接都需要一个线程来处理。因此，对于大量并发连接的场景，阻塞 I/O 模型的性能较差。</p>
<p><img src="\assets\note\image-20231012220627604.png" alt="image-20231012220627604"></p>
<p>非阻塞 I/O（Non-blocking I/O）：在这种模型中，I/O 操作不会阻塞线程。当数据尚未准备好时，I/O 调用会立即返回。线程可以继续执行其他任务，然后在适当的时候再次尝试执行 I/O 操作。非阻塞 I/O 模型允许单个线程同时处理多个连接，但可能需要在应用程序级别进行复杂的调度和管理。</p>
<p><img src="\assets\note\image-20231012220703833.png" alt="image-20231012220703833"></p>
<p><strong>内核空间和用户空间 </strong></p>
<p>在上面的两幅图中，涉及到了两个概念：内核空间和用户空间。我们之前在介绍非直接缓冲区的时候，有这样一副图片。</p>
<p><img src="\assets\note\image-20231012220739570.png" alt="image-20231012220739570"></p>
<p>其中的非直接缓冲区（JVM）就是在用户空间中，内核缓冲区（OS）就是在内核空间上。</p>
<p>内核空间是操作系统内核的专用内存区域，用于存储内核代码、数据结构和运行内核级别的系统调用。内核空间具有较高的权限级别，能够直接访问硬件资源和底层系统服务。一般来说，内核空间是受到严格保护的，用户级别的程序不能直接访问内核空间，以确保操作系统的稳定性和安全性。</p>
<p>用户空间是为用户级别的应用程序和服务分配的内存区域。它包含了应用程序的代码、数据和运行时堆栈。用户空间与内核空间相对隔离，具有较低的权限级别，不能直接访问内核空间或硬件资源。应用程序需要通过系统调用与内核空间进行交互，请求操作系统提供的服务。</p>
<p>内核空间和用户空间的划分有助于操作系统实现内存保护和权限控制，确保系统运行的稳定性和安全性。当用户程序需要访问系统资源或执行特权操作时，它需要通过系统调用切换到内核空间，由内核代理执行相应的操作。这种设计可以防止恶意或错误的用户程序直接访问内核空间，从而破坏系统的稳定性和安全性。同时，这种划分也提高了操作系统的可扩展性，因为内核空间和用户空间可以独立地进行扩展和优化。</p>
<p><img src="\assets\note\image-20231012220823292.png" alt="image-20231012220823292"></p>
<p><strong>多路复用、信号驱动、异步 IO </strong></p>
<p>除了前面提到的阻塞 IO 和非阻塞 IO 模型，还有另外三种 IO 模型，分别是多路复用、信号驱动和异步 IO。</p>
<p><strong>多路复用 </strong></p>
<p>I/O 多路复用（I/O Multiplexing）模型使用操作系统提供的多路复用功能（如 select、poll、epoll 等），使得单个线程可以同时处理多个 I/O 事件。当某个连接上的数据准备好时，操作系统会通知应用程序。这样，应用程序可以在一个线程中处理多个并发连接，而不需要为每个连接创建一个线程。</p>
<ul>
<li>select 是 Unix 系统中最早的 I/O 多路复用技术。它允许一个线程同时监视多个文件描述符（如套接字），并等待某个文件描述符上的 I/O 事件（如可读、可写或异常）。select 的主要问题是性能受限，特别是在处理大量文件描述符时。这是因为它使用一个位掩码来表示文件描述符集，每次调用都需要传递这个掩码，并在内核和用户空间之间进行复制。</li>
<li>poll 是对 select 的改进。它使用一个文件描述符数组而不是位掩码来表示文件描述符集。这样可以避免 select 中的性能问题。然而，poll 仍然需要遍历整个文件描述符数组，以检查每个文件描述符的状态。因此，在处理大量文件描述符时，性能仍然受限。</li>
<li>epoll 是 Linux 中的一种高性能 I/O 多路复用技术。它通过在内核中维护一个事件表来避免遍历文件描述符数组的性能问题。当某个文件描述符上的 I/O 事件发生时，内核会将该事件添加到事件表中。应用程序可以使用 epoll_wait 函数来获取已准备好的 I/O 事件，而无需遍历整个文件描述符集。这种方法大大提高了在大量并发连接下的性能。</li>
</ul>
<p><img src="\assets\note\image-20231012220933110.png" alt="image-20231012220933110"></p>
<p>在 Java NIO 中，I/O 多路复用主要通过 Selector 类实现。Selector 能够监控多个 Channel（通道）上的 I/O 事件，如连接、读取和写入。这使得一个线程可以处理多个并发连接，提高了程序的性能和可伸缩性。</p>
<p>以下是 Java NIO 中 I/O 多路复用的应用：</p>
<p>①、首先，需要创建一个 Selector 对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure>
<p>②、然后，需要将 Channel 注册到 Selector。每个 Channel 必须配置为非阻塞模式，才能与 Selector 一起使用。在注册 Channel 时，还需要指定感兴趣的 I/O 事件，如 SelectionKey.OP_ACCEPT（接受连接）、SelectionKey.OP_READ（读取数据）等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel serverChannel = ServerSocketChannel.open();</span><br><span class="line">serverChannel.configureBlocking(false);</span><br><span class="line">serverChannel.bind(new InetSocketAddress(8080));</span><br><span class="line">// 注册感兴趣的事件</span><br><span class="line">serverChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></figure>
<p>③、接下来，使用 Selector 的 select() 方法等待 I/O 事件。 select() 方法会阻塞，直到至少有一个 Channel 上的事件发生。当有事件发生时，可以通过调用 selectedKeys() 方法获取已准备好进行 I/O 操作的 Channel 的 SelectionKey 集合。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">while (true) &#123;</span><br><span class="line">    int readyChannels = selector.select();</span><br><span class="line">    if (readyChannels == 0) continue;</span><br><span class="line">    Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line">    Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();</span><br><span class="line">    while (keyIterator.hasNext()) &#123;</span><br><span class="line">        SelectionKey key = keyIterator.next();</span><br><span class="line">        if (key.isAcceptable()) &#123;</span><br><span class="line">            // 处理接受连接事件</span><br><span class="line">        &#125; else if (key.isReadable()) &#123;</span><br><span class="line">            // 处理读取数据事件</span><br><span class="line">        &#125; else if (key.isWritable()) &#123;</span><br><span class="line">            // 处理写入数据事件</span><br><span class="line">        &#125;</span><br><span class="line">        keyIterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>④、最后，根据 SelectionKey 的状态，执行相应的 I/O 操作。例如，如果 SelectionKey 表示 Channel 已准备好接受新的连接，可以调用 ServerSocketChannel 的 accept() 方法。如果 SelectionKey 表示 Channel 已准备好读取数据，可以从 SocketChannel 中读取数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (key.isAcceptable()) &#123;</span><br><span class="line">    SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">    socketChannel.configureBlocking(false);</span><br><span class="line">    socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">    System.out.println(&quot;客户端连接上了: &quot; + socketChannel.getRemoteAddress());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>信号驱动 </strong></p>
<p>信号驱动 I/O（Signal-driven I/O）模型中，应用程序可以向操作系统注册一个信号处理函数，当某个 I/O 事件发生时，操作系统会发送一个信号通知应用程序。应用程序在收到信号后处理相应的 I/O 事件。这种模型与非阻塞 I/O 类似，也需要在应用程序级别进行事件管理和调度。</p>
<p><img src="\assets\note\image-20231012221214351.png" alt="image-20231012221214351"></p>
<p>多路复用和信号驱动的差别主要在事件通知机制和引用场景上。</p>
<p>多路复用模型允许一个线程同时管理多个 I/O 连接。这是通过使用特殊的系统调用（如 select、poll 和 epoll）实现的，它们能够监视多个文件描述符上的 I/O 事件。当某个 I/O 事件发生时，这些系统调用会返回，通知应用程序执行相应的 I/O 操作。I/O 多路复用模型适用于高并发、低延迟和高吞吐量的场景，因为它能够有效地减少线程数量和上下文切换开销。</p>
<p>信号驱动模型依赖于信号（如 SIGIO）来通知应用程序 I/O 事件的发生。在这个模型中，应用程序首先设置文件描述符为信号驱动模式，并为相应的信号注册处理函数。当 I/O 事件发生时，内核会发送一个信号给应用程序，触发信号处理函数的执行。然后，应用程序可以在信号处理函数中执行相应的 I/O 操作。I/O 信号驱动模型适用于低并发、低延迟和低吞吐量的场景，因为它需要为每个 I/O 事件创建一个信号和信号处理函数。</p>
<p>Linux 的内核将所有外部设备都看做一个文件来操作，对一个文件的读写操作会调用内核提供的系统命令(api)，返回一个 file descriptor（fd，文件描述符）。而对一个Socket的读写也会有响应的描述符，称为 socket fd（Socket文件描述符），描述符就是一个数字，指向内核中的一个结构体（文件路径，数据区等一些属性）。</p>
<p>在Linux下对文件的操作是利用文件描述符(file descriptor)来实现的。</p>
<p><strong>异步 IO </strong></p>
<p>异步 I/O（Asynchronous I/O）模型与同步 I/O 模型的主要区别在于，异步 I/O 操作会在后台运行，当操作完成时，操作系统会通知应用程序。应用程序不需要等待 I/O 操作的完成，可以继续执行其他任务。这种模型适用于处理大量并发连接，且可以简化应用程序的设计和开发。</p>
<ul>
<li>同步：在执行 I/O 操作时，应用程序需要等待操作的完成。同步操作会导致线程阻塞，直到操作完成。同步 I/O 包括阻塞 I/O、非阻塞 I/O 和 I/O 多路复用。</li>
<li>异步：在执行 I/O 操作时，应用程序不需要等待操作的完成。异步操作允许应用程序在 I/O 操作进行时继续执行其他任务。异步 I/O 模型包括信号驱动 I/O 和异步 I/O。</li>
</ul>
<p><img src="\assets\note\image-20231012221405632.png" alt="image-20231012221405632"></p>
<p>假设你现在是个大厨（炖个老母鸡汤，切点土豆丝/姜丝/葱丝）：</p>
<ul>
<li>同步/阻塞：你站在锅边，一直等到汤炖好，期间不能做其他事情，直到汤炖好才去处理其他任务。</li>
<li>同步/非阻塞：你不断地查看锅里的汤，看是否炖好。在检查的间隙，你可以处理其他任务，如切菜。但你需要不断地切换任务，确保汤炖好了就可以处理。</li>
<li>异步/信号驱动：你给锅安装一个传感器，当汤炖好时，传感器会发出信号提醒你。在此期间，你可以处理其他任务，而不用担心错过汤炖好的时机。</li>
<li>异步 I/O：你请了一个助手，让他负责炖汤。当汤炖好时，助手会通知你。你可以专心处理其他任务，而无需关心炖汤的过程。</li>
</ul>
<p><strong>小结 </strong></p>
<p>简单总结一下，IO 模型主要有五种：阻塞 I/O、非阻塞 I/O、多路复用、信号驱动和异步 I/O。</p>
<ul>
<li>阻塞 I/O：应用程序执行 I/O 操作时，会一直等待数据传输完成，期间无法执行其他任务。</li>
<li>非阻塞 I/O：应用程序执行 I/O 操作时，如果数据未准备好，立即返回错误状态，不等待数据传输完成，可执行其他任务。</li>
<li>多路复用：允许一个线程同时管理多个 I/O 连接，适用于高并发、低延迟和高吞吐量场景，减少线程数量和上下文切换开销。</li>
<li>信号驱动：依赖信号通知应用程序 I/O 事件，适用于低并发、低延迟和低吞吐量场景，需要为每个 I/O 事件创建信号和信号处理函数。</li>
<li>异步 I/O：应用程序发起 I/O 操作后，内核负责数据传输过程，完成后通知应用程序。应用程序无需等待数据传输，可执行其他任务。</li>
</ul>
<h1 id="11-Java-重要知识点"><a href="#11-Java-重要知识点" class="headerlink" title="11 Java 重要知识点"></a>11 Java 重要知识点</h1><h2 id="11-1-Java命名规范"><a href="#11-1-Java命名规范" class="headerlink" title="11.1 Java命名规范"></a>11.1 Java命名规范</h2><p>“二哥，Java 中的命名约定都有哪些呢？”三妹的脸上泛着甜甜的笑容，她开始对接下来要学习的内容充满期待了，这正是我感到欣慰的地方。</p>
<p>“对于我们中国人来说，名字也是有讲究的，比如说我叫沉默王二，你就叫沉默王三，哈哈。”我笑着对三妹说。</p>
<p>命名约定决定我们使用什么样的标识符来命名包、类、字段、方法等等，虽然这个规则不是强制的，可以遵守，也可以不遵守，但如果不遵守的话，就会带来很多不必要的麻烦。</p>
<p>起个好的名字，就好像穿一件得体的衣服，呈现给人的用户体验是完全不一样的。 </p>
<p>好的命名可以让你的代码更易读，包括你自己和你的小伙伴，看一眼，不用想太多，就能明白代码是干嘛的。</p>
<p>拿我这个笔名“沉默王二”来举例吧，读起来我就觉得朗朗上口，读者看到这个笔名就知道我是一个什么样的人——对不熟的人保持沉默，对熟的人妙语连珠，哈哈。</p>
<blockquote>
<p>当然了，如果你暂时记不住也没关系，后面再回头来记一下就好了。</p>
</blockquote>
<p><strong>01、包（package） </strong></p>
<p>包的命名应该遵守以下规则：</p>
<ul>
<li>应该全部是小写字母</li>
<li>点分隔符之间有且仅有一个自然语义的英语单词</li>
<li>包名统一使用单数形式，比如说 com.itwanger.util 不能是 com.itwanger.utils</li>
<li>在最新的 Java 编程规范中，要求开发人员在自己定义的包名前加上唯一的前缀。由于互联网上的域名是不会重复的，所以多数开发人员采用自己公司（或者个人博客）在互联网上的域名称作为包的唯一前缀。比如我文章中出现的代码示例的包名就是 package com.itwanger 。</li>
</ul>
<p><strong>02、类（class） </strong></p>
<p>类的命名应该遵守以下规则：</p>
<ul>
<li>必须以大写字母开头</li>
<li>最好是一个名词，比如说 System</li>
<li>类名使用 UpperCamelCase（驼峰式命名）风格</li>
<li>尽量不要省略成单词的首字母，但以下情形例外：DO/BO/DTO/VO/AO/PO/UID 等</li>
</ul>
<p><img src="\assets\note\image-20231012222200775.png" alt="image-20231012222200775"></p>
<p>另外，如果是抽象类的话，使用 Abstract 或 Base 开头；如果是异常类的话，使用 Exception 结尾；如果是测试类的话，使用 Test 结尾。</p>
<p><strong>03、接口（interface） </strong></p>
<p>接口的命名应该遵守以下规则：</p>
<ul>
<li>必须以大写字母开头</li>
<li>最好是一个形容词，比如说 Runnable</li>
<li>尽量不要省略成单词的首字母</li>
</ul>
<p>来看个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interface Printable &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>接口和实现类之间也有一些规则：</p>
<ul>
<li>实现类用 Impl 的后缀与接口区别，比如说 CacheServiceImpl 实现 CacheService 接口</li>
<li>或者，AbstractTranslator 实现 Translatable 接口</li>
</ul>
<p><strong>04、字段（field）和变量（variable） </strong></p>
<p>字段和变量的命名应该遵守以下规则：</p>
<ul>
<li>必须以小写字母开头</li>
<li>可以包含多个单词，第一个单词的首字母小写，其他的单词首字母大写，比如说 firstName</li>
<li>最好不要使用单个字符，比如说 int a ，除非是局部变量</li>
<li>类型与中括号紧挨相连来表示数组，比如说 int[] arrayDemo ，main 方法中字符串数组参数不应该写成 String args[]</li>
<li>POJO 类中的任何布尔类型的变量，都不要加 is 前缀，否则部分框架解析会引起序列化错误，我自己知道的有 fastjson</li>
<li>避免在子类和父类的成员变量之间、或者不同代码块的局部变量之间采用完全相同的命名，使可理解性降低。子类、父类成员变量名相同，即使是 public 类型的变量也能够通过编译，另外，局部变量在同一方法内的不同代码块中同名也是合法的，这些情况都要避免。</li>
</ul>
<p>反例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class ConfusingName &#123;</span><br><span class="line">    public int stock;</span><br><span class="line">    // 非 setter/getter 的参数名称，不允许与本类成员变量同名</span><br><span class="line">    public void get(String alibaba) &#123;</span><br><span class="line">        if (condition) &#123;</span><br><span class="line">            final int money = 666;</span><br><span class="line">// ...</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">// 在同一方法体中，不允许与其它代码块中的 money 命名相同 final int money = 15978;</span><br><span class="line">// ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Son extends ConfusingName &#123;</span><br><span class="line">// 不允许与父类的成员变量名称相同 public int stock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>05、常量（constant） </strong></p>
<p>常量的命名应该遵守以下规则：</p>
<ul>
<li>应该全部是大写字母</li>
<li>可以包含多个单词，单词之间使用“_”连接，比如说 MAX_PRIORITY ，力求语义表达完整清楚，不要嫌名字长</li>
<li>可以包含数字，但不能以数字开头</li>
</ul>
<p>来看个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static final int MIN_AGE = 18; </span><br></pre></td></tr></table></figure>
<p><strong>06、方法（method） </strong></p>
<p>方法的命名应该遵守以下规则：</p>
<ul>
<li>必须以小写字母开头</li>
<li>最好是一个动词，比如说 print()</li>
<li>可以包含多个单词，第一个单词的首字母小写，其他的单词首字母大写，比如说 actionPerformed()</li>
</ul>
<p>来看个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void writeBook()&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>Service/DAO 层的方法命名规约：</p>
<ul>
<li>获取单个对象的方法用 get 做前缀</li>
<li>获取多个对象的方法用 list 做前缀，复数结尾，如：listObjects</li>
<li>获取统计值的方法用 count 做前缀</li>
<li>插入的方法用 save/insert 做前缀</li>
<li>删除的方法用 remove/delete 做前缀</li>
<li>修改的方法用 update 做前缀</li>
</ul>
<p><strong>07、总结 </strong></p>
<p>除了以上这些规则以外，还有一些共同的规则需要遵守，比如说：</p>
<ul>
<li>代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。反例： _name / __name / $name / name<em> / name$ / name_</em></li>
<li>所有编程相关的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。反例：DaZhePromotion [打折] / getPingfenByName() [评分] / String fw[福娃] / int 某变量 = 3</li>
<li>代码和注释中都要避免使用任何语言的种族歧视性词语。反例： RIBENGUIZI / Asan / blackList / whiteList / slave</li>
<li>方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格。</li>
<li>杜绝完全不规范的缩写，避免望文不知义。反例：AbstractClass “缩写”成 AbsClass；condition “缩写”成 condi；Function 缩写”成 Fu，此类随意缩写严重降低了代码的可阅读性。</li>
<li>为了达到代码自解释的目标，任何自定义编程元素在命名时，使用尽量完整的单词组合来表达。</li>
<li>在常量与变量的命名时，表示类型的名词放在词尾，以提升辨识度。正例： startTime / workQueue / nameList / TERMINATED_THREAD_COUNT</li>
<li>如果模块、接口、类、方法使用了设计模式，在命名时需体现出具体模式。 将设计模式体现在名中，有利于阅读者快速理解架构设计理念。比如说： public class OrderFactory;public class LoginProxy;public class ResourceObserver;</li>
<li>枚举类名带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。枚举其实就是特殊的常量类，且构造方法被默认强制是私有。比如说：枚举名字为 ProcessStatusEnum 的成员名称：SUCCESS / UNKNOWN_REASON 。</li>
</ul>
<h2 id="11-2-中文乱码及字符编码全攻略"><a href="#11-2-中文乱码及字符编码全攻略" class="headerlink" title="11.2 中文乱码及字符编码全攻略"></a>11.2 中文乱码及字符编码全攻略</h2><p>就在昨天，我在二哥的编程星球里看到这样一张截图，有球友反馈说支付宝的理财页面出现了中文乱码，估计不少小伙伴和我一样，都惊呆了 ！阿里这种大厂还能出现这种低级错误？</p>
<p><img src="\assets\note\image-20231013093346340.png" alt="image-20231013093346340"></p>
<p>难道昨天的人力都投入到“通义千问”的突然发布上了？</p>
<p>那借这个机会，我就来和大家探讨一下，中文乱码是怎么出现的，以及如何快速解决乱码问题。</p>
<p><strong>什么是中文乱码 </strong></p>
<p>Q：什么是中文乱码？</p>
<p>GPT4：中文乱码是指在计算机系统或软件中，由于字符编码不一致或处理不当，导致中文字符无法正常显示，出现乱码现象。这种现象通常表现为中文字符被替换成其他不相关的字符、符号或乱码。</p>
<p>比如说，历史上著名的“锟斤拷”同学，就是中文乱码的绝佳代言人。</p>
<p><img src="\assets\note\image-20231013093438726.png" alt="image-20231013093438726"></p>
<p><strong>什么是字符编码 </strong></p>
<p>Q：那什么是字符编码呢？</p>
<p>GPT4：字符编码（Character Encoding）是一种规则或约定，它将字符（如字母、数字、标点符号等）映射到计算机中的二进制数据。简单来说，字符编码就是将人类可读的字符转换为计算机可以处理的二进制数据的过程。</p>
<p>对于计算机来说，只认 0 和 1，所有的信息最终都是一个二进制数。一个二进制数要么是 0，要么是 1。8 个二进制数放在一起是一个字节，就会组合出 256 种状态，也就是 2 的 8 次方（ 2^8 ），从 00000000 到 11111111。</p>
<p>为了让计算机能够识别和处理各种字符，需要使用字符编码来对字符进行编码和解码。常见的字符编码包括 ASCII、UTF-8、UTF-16、GBK、GB2312 等。</p>
<p><img src="\assets\note\image-20231013093522740.png" alt="image-20231013093522740"></p>
<p><strong>1）ASCII </strong></p>
<p>ASCII 码由电报码发展而来，第一版标准发布于 1963 年，最后一次更新则是在 1986 年，至今为止共定义了 128 个字符。其中 33 个字符无法显示在一般的设备上，需要用特殊的设备才能显示。</p>
<p>ASCII 码的局限在于只能显示 26 个基本拉丁字母、阿拉伯数字和英式标点符号，因此只能用于显示现代美国英语，对于其他一些语言则无能无力，比如在法语中，字母上方有注音符号，它就无法用 ASCII 码表示。</p>
<p><img src="\assets\note\image-20231013093559048.png" alt="image-20231013093559048"></p>
<p>PS：拉丁字母（也称为罗马字母）是多数欧洲语言采用的字母系统，是世界上最通行的字母文字系统，是罗马文明的成果之一。</p>
<p>虽然名称上叫作拉丁字母，但拉丁文中并没有用 J、U 和 W 这三个字母。</p>
<p>在我的印象中，可能说拉丁字母多少有些陌生，说英语字母可能就有直观的印象了。</p>
<p><img src="\assets\note\image-20231013093725582.png" alt="image-20231013093725582"></p>
<p>阿拉伯数字，我们都很熟悉了。</p>
<p><img src="\assets\note\image-20231013093755955.png" alt="image-20231013093755955"></p>
<p>但是，阿拉伯数字并非起源于阿拉伯，而是起源于古印度。学过历史的你应该有一些印象，阿拉伯分布于西亚和北非，以阿拉伯语为主要语言，以伊斯兰教为主要信仰。</p>
<p><img src="\assets\note\image-20231013093823964.png" alt="image-20231013093823964"></p>
<p>处在这样的地理位置，做起东亚和欧洲的一些生意就很有优势，于是阿拉伯数字就由阿拉伯人传到了欧洲，因此得名。</p>
<p>英式标点符号，也叫英文标点符号，和中文标点符号很相近。标点符号是辅助文字记录语言的符号，是书面语的组成部分，用来表示停顿、加强语气等。</p>
<p>英文标点符号在 16 世纪时，分为朗诵学派和句法学派，主要由古典时期的希腊文和拉丁文演变而来，在 17 世纪后进入稳定阶段。俄文的标点符号依据希腊文而来，到了 18 世纪后也采用了英文标点符号。</p>
<p>在很多人的印象中，古文是没有标点符号的，但管锡华博士研究指出，中国早在先秦时代就有标点符号了，后来融合了一些英文标点符号后，逐渐形成了现在的中文标点符号。</p>
<p><img src="\assets\note\image-20231013093921594.png" alt="image-20231013093921594"></p>
<p><strong>2）Unicode </strong></p>
<p>这个世界上，除了英语，还有法语、葡萄牙语、西班牙语、德语、俄语、阿拉伯语、韩语、日语等等等等。ASCII 码用来表示英语是绰绰有余的，但其他这些语言就没办法了。</p>
<p>像我的主人二哥的母语——中文，就博大精深，与其对应的汉字数量很多很多，东汉的《说文解字》收字 9353 个，清朝《康熙字典》收字 47035 个，当代的《汉语大字典》收字 60370 个。1994 年中华书局、中国友谊出版公司出版的《中华字海》收字 85568 个。</p>
<blockquote>
<p>常用字大概 2500 个，次常用字 1000 个。</p>
</blockquote>
<p>一个字节只能表示 256 种符号，所以如果拿 ASCII 码来表示汉字的话，是远远不够用的，那就必须要用更多的字节。简体中文常见的编码方式是 GB2312，使用两个字节表示一个汉字，理论上最多可以表示 256 x 256 = 65536 个符号。</p>
<p>要知道，世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。</p>
<ul>
<li>编码就是将原始数据（比如说文本、图像、视频、音频等）转换为二进制形式。</li>
<li>解码就是将二进制数据转换为原始数据，是一个反向的过程。</li>
</ul>
<p>如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会彻底消失。</p>
<p>这个艰巨的任务由谁来完成呢？Unicode，中文译作万国码、国际码、统一码、单一码，就像它的名字都表示的，这是一种所有符号的编码。</p>
<p>Unicode 至今仍在不断增修，每个新版本都会加入更多新的字符。目前最新的版本为 2020 年 3 月公布的 13.0，收录了 13 万个字符。</p>
<p><img src="\assets\note\image-20231013094151302.png" alt="image-20231013094151302"></p>
<p>Unicode 是一个很大的集合，现在的规模可以容纳 100 多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母 Ain ， U+0041 表示英语的大写字母 A ， U+4E25 表示汉字严 。</p>
<p>具体的符号对应表，可以查询：</p>
<blockquote>
<p>unicode.org：<a target="_blank" rel="noopener" href="http://www.unicode.org">http://www.unicode.org</a></p>
<p>汉字对应表：ttp://www.chi2ko.com/tool/CJK.htm</p>
</blockquote>
<p>曾有人这样说：</p>
<blockquote>
<p>Unicode 支持的字符上限是 65536 个，Unicode 字符必须占两个字节。</p>
</blockquote>
<p>但这是一种误解，记住，Unicode 只是一个用来映射字符和数字的标准。它对支持字符的数量没有限制，也不要求字符必须占两个、三个或者其它任意数量的字节，所以它可以无穷大。</p>
<p><strong>3）UTF-8 </strong></p>
<p>Unicode 虽然统一了全世界字符的编码，但没有规定如何存储。如果统一规定的话，每个符号就要用 3 个或 4 个字节表示，因为 2 个字节只能表示 65536 个，根本表示不全。</p>
<p>那怎么办呢？</p>
<p>UTF（Unicode Transformation Formats，Unicode 的编码方式）来了！最常见的就是 UTF-8 和 UTF-16。</p>
<p>在 UTF-8 中，0-127 号的字符用 1 个字节来表示，使用和 ASCII 相同的编码。只有 128 号及以上的字符才用 2 个、3 个或者 4 个字节来表示。</p>
<p>如果只有一个字节，那么最高的比特位为 0；如果有多个字节，那么第一个字节从最高位开始，连续有几个比特位的值为 1，就使用几个字节编码，剩下的字节均以 10 开头。</p>
<p>具体的表现形式为：</p>
<ul>
<li>0xxxxxxx：一个字节；</li>
<li>110xxxxx 10xxxxxx：两个字节编码形式（开始两个 1）；</li>
<li>1110xxxx 10xxxxxx 10xxxxxx：三字节编码形式（开始三个 1）；</li>
<li>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx：四字节编码形式（开始四个 1）。</li>
</ul>
<p>也就是说，UTF-8 是一种可变长度的编码方式——这是它的优势也是劣势。</p>
<p>怎么讲呢？优势就是它包罗万象，劣势就是浪费空间。举例来说吧，UTF-8 采用了 3 个字节（ 256*256*256=16777216 ）来编码常用的汉字，但常用的汉字没有这么多，这对于计算机来说，就是一种严重的资源浪费。</p>
<p><strong>4）GB2312 </strong></p>
<p>基于这样的考虑，中国国家标准总局于 1980 年发布了 GB2312 编码，即中华人民共和国国家标准简体中文字符集。GB2312 标准共收录 6763 个汉字（2 个字节就够用了），其中一级汉字 3755 个，二级汉字 3008 个；同时收录了包括拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母在内的 682 个字符。</p>
<p>GB2312 的出现，基本满足了汉字的计算机处理需求。对于人名、古汉语等方面出现的罕用字和繁体字，GB2312 不能处理，就有了 GBK（K 为“扩展”的汉语拼音（kuòzhǎn）第一个声母）。</p>
<p><strong>中文乱码是如何出现的？ </strong></p>
<p>Q：来一串出现中文乱码的 demo，中文为沉默王二</p>
<p>GPT4：下面是一个可能导致中文乱码的示例。首先使用 GBK 编码将中文字符串 “沉默王二” 转换为字节数组，然后使用 UTF-8 编码将字节数组转回字符串。这将导致字符串在解码时出现乱码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class EncodingDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String originalStr = &quot;沉默王二&quot;;</span><br><span class="line">        String encodedStr = &quot;&quot;;</span><br><span class="line">        try &#123;</span><br><span class="line">            byte[] bytes = originalStr.getBytes(&quot;GBK&quot;);</span><br><span class="line">            encodedStr = new String(bytes, &quot;UTF-8&quot;);</span><br><span class="line">        &#125; catch (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;转码前: &quot; + originalStr);</span><br><span class="line">        System.out.println(&quot;转码后: &quot; + encodedStr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序会输出什么呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">转码前: 沉默王二</span><br><span class="line">转码后: ��Ĭ����</span><br></pre></td></tr></table></figure>
<p>嘿嘿，乱码来了！在 Unicode 中，� 是一个特殊的符号，它用来表示无法显示，它的十六进制是 0xEF 0xBF 0xBD 。那么两个 �� 就是 0xEF 0xBF 0xBD 0xEF 0xBF 0xBD ，如果用 GBK 进行解码的话，就是大名鼎鼎的“锟斤拷”。</p>
<p>可以通过代码来验证一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 输出 efbfbdefbfbd</span><br><span class="line">char[] kuijinkao = HexUtil.encodeHex(&quot;��&quot;, StandardCharsets.UTF_8);</span><br><span class="line">System.out.println(kuijinkao);</span><br><span class="line">// 借助 hutool 转成二进制</span><br><span class="line">byte[] testBytes = HexUtil.decodeHex(kuijinkao);</span><br><span class="line">// 使用 GBK 解码</span><br><span class="line">String testResult = new String(testBytes, Charset.forName(&quot;GBK&quot;));</span><br><span class="line">// 输出锟斤拷</span><br><span class="line">System.out.println(testResult);</span><br></pre></td></tr></table></figure>
<p>来看一下输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">efbfbdefbfbd</span><br><span class="line">锟斤拷</span><br></pre></td></tr></table></figure>
<p>所以，以后再见到锟斤拷，第一时间想到 UTF-8 和 GBK 的转换问题准没错。</p>
<p><strong>如何解决中文乱码呢？ </strong></p>
<p>Q：如何解决中文乱码呢？</p>
<p>GPT4：解决中文乱码问题需要确保在编码和解码过程中使用相同的字符编码。这是一个修改过的示例，展示了如何避免中文乱码问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String originalStr = &quot;沉默王二&quot;;</span><br><span class="line">byte[] bytes = originalStr.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">String encodedStr = new String(bytes, StandardCharsets.UTF_8);</span><br><span class="line">System.out.println(&quot;正确转码前: &quot; + originalStr);</span><br><span class="line">System.out.println(&quot;正确转码后: &quot; + encodedStr);</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">正确转码前: 沉默王二</span><br><span class="line">正确转码后: 沉默王二</span><br></pre></td></tr></table></figure>
<p>除此之外，以下是一些避免乱码的实践：</p>
<ul>
<li>使用统一的字符编码，如 UTF-8。它包含了所有 Unicode 字符，并且广泛支持。确保在所有平台和系统上使用相同的编码。</li>
<li>在处理文本文件时，始终明确指定字符编码。例如，在 Java 中使用 InputStreamReader、OutputStreamWriter 时，指定编码参数。</li>
<li>在 HTML、XML 等文档中，指定字符编码。例如，在 HTML 页面中添加 <meta charset="UTF-8"> 。</li>
<li>对于数据库，确保使用正确的字符集。在创建数据库和表时，明确指定字符集，如 utf8mb4。</li>
</ul>
<p>当与第三方服务通信时，确保双方使用相同的字符编码。在处理 API 请求和响应时，检查字符编码是否匹配。</p>
<p>Q：针对支付宝这种生产环境事故，如何快速定位并解决问题呢？</p>
<p>GPT4：</p>
<p>1、收集信息：了解问题的具体表现，例如哪些页面或功能受到影响，问题的严重程度，以及用户反馈。这将有助于快速定位问题范围。</p>
<p>2、检查日志：查看服务器日志和应用程序日志，检查是否存在异常信息或错误。日志信息有助于识别问题发生的时间和具体原因。</p>
<p>3、复现问题：在测试环境中尝试复现问题，以便更深入地了解问题细节。如果无法复现问题，可能需要进一步收集生产环境的详细信息。</p>
<p>4、定位问题：根据收集到的信息，确定问题可能发生的代码或系统部分。检查相关代码，特别是涉及字符编码、数据传输、数据库操作的部分。</p>
<p>5、解决问题：修复问题代码，确保字符编码在整个系统中保持一致。进行单元测试和集成测试，验证问题是否已解决。</p>
<p>6、部署修复：将修复后的代码部署到生产环境。为了避免影响正常服务，可以考虑先在一个小规模的生产环境中进行验证，然后逐步扩大部署范围。</p>
<p>7、监控：在修复后持续关注系统运行状况，确保问题已得到解决。收集用户反馈，确认用户满意度。</p>
<p>8、总结经验：针对此次问题，总结经验教训，分析问题产生的根本原因，优化开发和测试流程，避免类似问题再次发生。</p>
<h2 id="11-3-深入剖析Java中的拆箱和装箱"><a href="#11-3-深入剖析Java中的拆箱和装箱" class="headerlink" title="11.3 深入剖析Java中的拆箱和装箱"></a>11.3 深入剖析Java中的拆箱和装箱</h2><p>“哥，听说 Java 的每个基本类型都对应了一个包装类型，比如说 int 的包装类型为 Integer，double 的包装类型为 Double，是这样吗？”从三妹这句话当中，能听得出来，她已经提前预习这块内容了。</p>
<p>“是的，三妹。基本类型和包装类型的区别主要有以下 4 点，我来带你学习一下。”我回答说。我们家的斜对面刚好是一所小学，所以时不时还能听到朗朗的读书声，让人心情非常愉快。</p>
<p>“三妹，你准备好了吗？我们开始吧。”</p>
<p>“第一，<strong>包装类型可以为 null，而基本类型不可以。</strong>别小看这一点区别，它使得包装类型可以应用于 POJO 中，而基本类型则不行。”</p>
<p>“POJO 是什么呢？”遇到不会的就问，三妹在这一点上还是非常兢兢业业的。</p>
<p>“POJO 的英文全称是 Plain Ordinary Java Object，翻译一下就是，简单无规则的 Java 对象，只有字段以及对应的 setter 和 getter 方法。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Writer &#123;</span><br><span class="line">    private Integer age;</span><br><span class="line">    private String name;</span><br><span class="line">    public Integer getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setAge(Integer age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和 POJO 类似的，还有数据传输对象 DTO（Data Transfer Object，泛指用于展示层与服务层之间的数据传输对象）、视图对象 VO（View Object，把某个页面的数据封装起来）、持久化对象 PO（Persistant Object，可以看成是与数据库中的表映射的 Java 对象）。<br>“那为什么 POJO 的字段必须要用包装类型呢？”三妹问。</p>
<p>“《阿里巴巴 Java 开发手册》上有详细的说明，你看。”我打开 PDF，并翻到了对应的内容，指着屏幕念道。</p>
<blockquote>
<p>数据库的查询结果可能是 null，如果使用基本类型的话，因为要自动拆箱，就会抛出 NullPointerException 的异常。</p>
</blockquote>
<p>“什么是自动拆箱呢？”</p>
<p>“自动拆箱指的是，将包装类型转为基本类型，比如说把 Integer 对象转换成 int 值；对应的，把基本类型转为包装类型，则称为自动装箱。”</p>
<p>“哦。”</p>
<p>“那接下来，我们来看第二点不同。<strong>包装类型可用于泛型，而基本类型不可以，</strong>否则就会出现编译错误。”一边说着，我一边在 Intellij IDEA 中噼里啪啦地敲了起来。</p>
<p>“三妹，你瞧，编译器提示错误了。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;int&gt; list = new ArrayList&lt;&gt;(); // 提示 Syntax error, insert &quot;Dimensions&quot; to </span><br><span class="line">complete ReferenceType</span><br><span class="line">List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>“为什么呢？”三妹及时地问道。</p>
<p>“因为泛型在编译时会进行类型擦除，最后只保留原始类型，而原始类型只能是 Object 类及其子类——基本类型是个例外。”</p>
<p>“那，接下来，我们来说第三点，<strong>基本类型比包装类型更高效。</strong>”我喝了一口茶继续说道。</p>
<p>“作为局部变量时，基本类型在栈中直接存储的具体数值，而包装类型则存储的是堆中的引用。”我一边说着，一边打开 draw.io 画起了图。</p>
<p><img src="\assets\note\image-20231013095531566.png" alt="image-20231013095531566"></p>
<p>很显然，相比较于基本类型而言，包装类型需要占用更多的内存空间，不仅要存储对象，还要存储引用。假如没有基本类型的话，对于数值这类经常使用到的数据来说，每次都要通过 new 一个包装类型就显得非常笨重。</p>
<p>“三妹，你想知道程序运行时，数据都存储在什么地方吗？”</p>
<p>“嗯嗯，哥，你说说呗。”</p>
<p>“通常来说，有 4 个地方可以用来存储数据。”</p>
<p>1）寄存器。这是最快的存储区，因为它位于 CPU 内部，用来暂时存放参与运算的数据和运算结果。</p>
<p>2）栈。位于 RAM（Random Access Memory，也叫主存，与 CPU 直接交换数据的内部存储器）中，速度仅次于寄存器。但是，在分配内存的时候，存放在栈中的数据大小与生存周期必须在编译时是确定的，缺乏灵活性。基本数据类型的值和对象的引用通常存储在这块域。</p>
<p>3）堆。也位于 RAM 区，可以动态分配内存大小，编译器不必知道要从堆里分配多少存储空间，生存周期也不必事先告诉编译器，Java 的垃圾收集器会自动收走不再使用的数据，因此可以得到更大的灵活性。但是，运行时动态分配内存和销毁对象都需要占用时间，所以效率比栈低一些。new 创建的对象都会存储在这块区域。</p>
<p>4）磁盘。如果数据完全存储在程序之外，就可以不受程序的限制，在程序没有运行时也可以存在。像文件、数据库，就是通过持久化的方式，让对象存放在磁盘上。当需要的时候，再反序列化成程序可以识别的对象。</p>
<p>“能明白吗？三妹？”</p>
<p>“这节讲完后，我再好好消化一下。”</p>
<p>“那好，我们来说第四点，<strong>两个包装类型的值可以相同，但却不相等。”</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer chenmo = new Integer(10);</span><br><span class="line">Integer wanger = new Integer(10);</span><br><span class="line">System.out.println(chenmo == wanger); // false</span><br><span class="line">System.out.println(chenmo.equals(wanger )); // true</span><br></pre></td></tr></table></figure>
<p>“两个包装类型在使用“\==”进行判断的时候，判断的是其指向的地址是否相等，由于是两个对象，所以地址是不同的。”</p>
<p>“而 chenmo.equals(wanger) 的输出结果为 true，是因为 equals() 方法内部比较的是两个 int 值是否相等。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private final int value;</span><br><span class="line">public int intValue() &#123;</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">    if (obj instanceof Integer) &#123;</span><br><span class="line">        return value == ((Integer)obj).intValue();</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然 chenmo 和 wanger 的值都是 10，但他们并不相等。换句话说就是：将“\==”操作符应用于包装类型比较的时候，其结果很可能会和预期的不符。</p>
<p>“三妹，瞧， ((Integer)obj).intValue() 这段代码就是用来自动拆箱的。下面，我们来详细地说一说自动装箱和自动拆箱。”</p>
<p>既然有基本类型和包装类型，肯定有些时候要在它们之间进行转换。把基本类型转换成包装类型的过程叫做装箱（boxing）。反之，把包装类型转换成基本类型的过程叫做拆箱（unboxing）。</p>
<p>在 Java 1.5 之前，开发人员要手动进行装拆箱，比如说：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer chenmo = new Integer(10); // 手动装箱</span><br><span class="line">int wanger = chenmo.intValue();  // 手动拆箱</span><br></pre></td></tr></table></figure>
<p>Java 1.5 为了减少开发人员的工作，提供了自动装箱与自动拆箱的功能。这下就方便了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer chenmo  = 10;  // 自动装箱</span><br><span class="line">int wanger = chenmo;     // 自动拆箱</span><br></pre></td></tr></table></figure>
<p>来看一下反编译后的代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer chenmo = Integer.valueOf(10);</span><br><span class="line">int wanger = chenmo.intValue();</span><br></pre></td></tr></table></figure>
<p>也就是说，自动装箱是通过 Integer.valueOf() 完成的；自动拆箱是通过 Integer.intValue() 完成的。</p>
<p>“嗯，三妹，给你出一道面试题吧。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/ 1）基本类型和包装类型</span><br><span class="line">int a = 100;</span><br><span class="line">Integer b = 100;</span><br><span class="line">System.out.println(a == b);</span><br><span class="line">// 2）两个包装类型</span><br><span class="line">Integer c = 100;</span><br><span class="line">Integer d = 100;</span><br><span class="line">System.out.println(c == d);</span><br><span class="line">// 3）</span><br><span class="line">c = 200;</span><br><span class="line">d = 200;</span><br><span class="line">System.out.println(c == d);</span><br></pre></td></tr></table></figure>
<p>“给你 3 分钟时间，你先思考下，等我回来，然后再来分析一下为什么。”</p>
<p>。。。。。。</p>
<p>“嗯，哥，你过来吧，我说一说我的想法。”</p>
<p>第一段代码，基本类型和包装类型进行 == 比较，这时候 b 会自动拆箱，直接和 a 比较值，所以结果为 true。</p>
<p>第二段代码，两个包装类型都被赋值为了 100，这时候会进行自动装箱，按照你之前说的，将“==”操作符应用于包装类型比较的时候，其结果很可能会和预期的不符，我想结果可能为 false。</p>
<p>第三段代码，两个包装类型重新被赋值为了 200，这时候仍然会进行自动装箱，我想结果仍然为 false。</p>
<p>“嗯嗯，三妹，你分析的很有逻辑，但第二段代码的结果为 true，是不是感到很奇怪？”</p>
<p>“为什么会这样呀？”三妹急切地问。</p>
<p>“你说的没错，自动装箱是通过 Integer.valueOf() 完成的，我们来看看这个方法的源码就明白为什么了。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static Integer valueOf(int i) &#123;</span><br><span class="line">    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        return IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    return new Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是不是看到了一个之前从来没见过的类——IntegerCache？</p>
<p>“难道说是 Integer 的缓存类？”三妹做出了自己的判断。</p>
<p>“是的，来看一下 IntegerCache 的源码吧。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private static class IntegerCache &#123;</span><br><span class="line">    static final int low = -128;</span><br><span class="line">    static final int high;</span><br><span class="line">    static final Integer cache[];</span><br><span class="line">    static &#123;</span><br><span class="line">        // high value may be configured by property</span><br><span class="line">        int h = 127;</span><br><span class="line">        int i = parseInt(integerCacheHighPropValue);</span><br><span class="line">        i = Math.max(i, 127);</span><br><span class="line">        h = Math.min(i, Integer.MAX_VALUE - (-low) -1);</span><br><span class="line">        high = h;</span><br><span class="line">        cache = new Integer[(high - low) + 1];</span><br><span class="line">        int j = low;</span><br><span class="line">        for(int k = 0; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = new Integer(j++);</span><br><span class="line">        // range [-128, 127] must be interned (JLS7 5.1.7)</span><br><span class="line">        assert IntegerCache.high &gt;= 127;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大致瞟一下这段代码你就全明白了。-128 到 127 之间的数会从 IntegerCache 中取，然后比较，所以第二段代码（100 在这个范围之内）的结果是 true，而第三段代码（200 不在这个范围之内，所以 new 出来了两个 Integer 对象）的结果是 false。</p>
<p>“三妹，看完上面的分析之后，我希望你记住一点：<strong>当需要进行自动装箱时，如果数字在 -128 至 127 之间时，会直接使用缓存中的对象，而不是重新创建一个对象。”</strong></p>
<p>“自动装拆箱是一个很好的功能，大大节省了我们开发人员的精力，但也会引发一些麻烦，比如下面这段代码，性能就很差。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">long t1 = System.currentTimeMillis();</span><br><span class="line">Long sum = 0L;</span><br><span class="line">for (int i = 0; i &lt; Integer.MAX_VALUE;i++) &#123;</span><br><span class="line">    sum += i;</span><br><span class="line">&#125;</span><br><span class="line">long t2 = System.currentTimeMillis();        </span><br><span class="line">System.out.println(t2-t1);</span><br></pre></td></tr></table></figure>
<p>“知道为什么吗？三妹。”</p>
<p>“难道是因为 sum 被声明成了包装类型 Long 而不是基本类型 long。”三妹若有所思。</p>
<p>“是滴，由于 sum 是个 Long 型，而 i 为 int 类型， sum += i 在执行的时候，会先把 i 强转为 long 型，然后再把 sum 拆箱为 long 型进行相加操作，之后再自动装箱为 Long 型赋值给 sum。”</p>
<p>“三妹，你可以试一下，把 sum 换成 long 型比较一下它们运行的时间。”</p>
<p>。。。。。。</p>
<p>“哇，sum 为 Long 型的时候，足足运行了 5825 毫秒；sum 为 long 型的时候，只需要 679 毫秒。”</p>
<h2 id="11-4-深入理解Java浅拷贝与深拷贝"><a href="#11-4-深入理解Java浅拷贝与深拷贝" class="headerlink" title="11.4 深入理解Java浅拷贝与深拷贝"></a>11.4 深入理解Java浅拷贝与深拷贝</h2><p>“哥，听说浅拷贝和深拷贝是 Java 面试中经常会被问到的一个问题，是这样吗？”</p>
<p>“还真的是，而且了解浅拷贝和深拷贝的原理，对 Java 是值传递还是引用传递也会有更深的理解。”我肯定地回答。</p>
<p>“不管是浅拷贝还是深拷贝，都可以通过调用 Object 类的 clone() 方法来完成。”我一边说，一边打开 Intellij IDEA，并找到了 clone() 方法的源码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected native Object clone() throws CloneNotSupportedException;</span><br></pre></td></tr></table></figure>
<p>需要注意的是， clone() 方法同时是一个本地（ native ）方法，它的具体实现会交给 HotSpot 虚拟机，那就意味着虚拟机在运行该方法的时候，会将其替换为更高效的 C/C++ 代码，进而调用操作系统去完成对象的克隆工作。</p>
<blockquote>
<p>Java 9 后，该方法会被标注 @HotSpotIntrinsicCandidate 注解，被该注解标注的方法，在 HotSpot 虚拟机中会有一套高效的实现。</p>
</blockquote>
<p>“哥，那你就先说浅拷贝吧！”</p>
<p>“好的呀。直接上实战代码。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Writer implements Cloneable&#123;</span><br><span class="line">    private int age;</span><br><span class="line">    private String name;</span><br><span class="line">    // getter/setter 和构造方法都已省略</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return super.toString().substring(26) + &quot;&#123;&quot; +</span><br><span class="line">                &quot;age=&quot; + age +</span><br><span class="line">                &quot;, name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Writer 类有两个字段，分别是 int 类型的 age，和 String 类型的 name。然后重写了 toString() 方法，方便打印对象的具体信息。</p>
<p>“为什么要实现 Cloneable 接口呢？”三妹开启了十万个为什么的模式。</p>
<p>Cloneable 接口是一个标记接口，它肚子里面是空的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public interface Cloneable &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只是，如果一个类没有实现 Cloneable 接口，即便它重写了 clone() 方法，依然是无法调用该方法进行对象克隆的，程序在执行 clone() 方法的时候会抛出 CloneNotSupportedException 异常。</p>
<p>标记接口的作用其实很简单，用来表示某个功能在执行的时候是合法的。</p>
<p>“哦，我悟了！”三妹看来是彻底明白了我说的内容。</p>
<p>“接着，来测试类。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class TestClone &#123;</span><br><span class="line">    public static void main(String[] args) throws CloneNotSupportedException &#123;</span><br><span class="line">        Writer writer1 = new Writer(18,&quot;二哥&quot;);</span><br><span class="line">        Writer writer2 = (Writer) writer1.clone();</span><br><span class="line">        System.out.println(&quot;浅拷贝后：&quot;);</span><br><span class="line">        System.out.println(&quot;writer1：&quot; + writer1);</span><br><span class="line">        System.out.println(&quot;writer2：&quot; + writer2);</span><br><span class="line">        writer2.setName(&quot;三妹&quot;);</span><br><span class="line">        System.out.println(&quot;调整了 writer2 的 name 后：&quot;);</span><br><span class="line">        System.out.println(&quot;writer1：&quot; + writer1);</span><br><span class="line">        System.out.println(&quot;writer2：&quot; + writer2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>通过 new 关键字声明了一个 Writer 对象（18 岁的二哥），将其赋值给 writer1。</li>
<li>通过调用 clone() 方法进行对象拷贝，并将其赋值给 writer2。</li>
<li>之后打印 writer1 和 writer2。</li>
<li>将 writer2 的 name 字段调整为“三妹”。</li>
<li>再次打印。</li>
</ul>
<p>来看一下输出结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">浅拷贝后：</span><br><span class="line">writer1：Writer@68837a77&#123;age=18, name=&#x27;二哥&#x27;&#125;</span><br><span class="line">writer2：Writer@b97c004&#123;age=18, name=&#x27;二哥&#x27;&#125;</span><br><span class="line">调整了 writer2 的 name 后：</span><br><span class="line">writer1：Writer@68837a77&#123;age=18, name=&#x27;二哥&#x27;&#125;</span><br><span class="line">writer2：Writer@b97c004&#123;age=18, name=&#x27;三妹&#x27;&#125;</span><br></pre></td></tr></table></figure>
<p>可以看得出，浅拷贝后，writer1 和 writer2 引用了不同的对象，但值是相同的，说明拷贝成功。之后，修改了 writer2 的 name 字段，直接上图就明白了。</p>
<p><img src="\assets\note\image-20231013101631263.png" alt="image-20231013101631263"></p>
<p>之前的例子中，Writer 类只有两个字段，没有引用类型字段。那么，我们再来看另外一个例子，为 Writer 类增加一个自定义的引用类型字段 Book，先来看 Book 的定义。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Book &#123;</span><br><span class="line">    private String bookName;</span><br><span class="line">    private int price;</span><br><span class="line">    // getter/setter 和构造方法都已省略</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return super.toString().substring(26) +</span><br><span class="line">                &quot; bookName=&#x27;&quot; + bookName + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, price=&quot; + price +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有两个字段，分别是 String 类型的 bookName 和 int 类型的 price。</p>
<p>然后来看 Writer 类的定义。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Writer implements Cloneable&#123;</span><br><span class="line">    private int age;</span><br><span class="line">    private String name;</span><br><span class="line">    private Book book;</span><br><span class="line">    // getter/setter 和构造方法都已省略</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return super.toString().substring(26) +</span><br><span class="line">                &quot; age=&quot; + age +</span><br><span class="line">                &quot;, name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, book=&quot; + book +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        return super.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比之前的例子多了一个自定义类型的字段 book， clone() 方法并没有任何改变。</p>
<p>再来看测试类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class TestClone &#123;</span><br><span class="line">    public static void main(String[] args) throws CloneNotSupportedException &#123;</span><br><span class="line">        Writer writer1 = new Writer(18,&quot;二哥&quot;);</span><br><span class="line">        Book book1 = new Book(&quot;编译原理&quot;,100);</span><br><span class="line">        writer1.setBook(book1);</span><br><span class="line">        Writer writer2 = (Writer) writer1.clone();</span><br><span class="line">        System.out.println(&quot;浅拷贝后：&quot;);</span><br><span class="line">        System.out.println(&quot;writer1：&quot; + writer1);</span><br><span class="line">        System.out.println(&quot;writer2：&quot; + writer2);</span><br><span class="line">        Book book2 = writer2.getBook();</span><br><span class="line">        book2.setBookName(&quot;永恒的图灵&quot;);</span><br><span class="line">        book2.setPrice(70);</span><br><span class="line">        System.out.println(&quot;writer2.book 变更后：&quot;);</span><br><span class="line">        System.out.println(&quot;writer1：&quot; + writer1);</span><br><span class="line">        System.out.println(&quot;writer2：&quot; + writer2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>通过 new 关键字声明了一个 Writer 对象（18 岁的二哥），将其赋值给 writer1。</li>
<li>通过 new 关键字声明了一个 Book 对象（100 块的编译原理），将其赋值给 book1。</li>
<li>将 writer1 的 book 字段设置为 book1。</li>
<li>通过调用 clone() 方法进行对象拷贝，并将其赋值给 writer2。</li>
<li>之后打印 writer1 和 writer2。</li>
<li>获取 writer2 的 book 字段，并将其赋值给 book2。</li>
<li>将 book2 的 bookName 字段调整为“永恒的图灵”，price 字段调整为 70。</li>
<li>再次打印。</li>
</ul>
<p>来看一下输出结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">浅拷贝后：</span><br><span class="line">writer1：Writer@68837a77 age=18, name=&#x27;二哥&#x27;, book=Book@32e6e9c3 bookName=&#x27;编译原理&#x27;, </span><br><span class="line">price=100&#125;&#125;</span><br><span class="line">writer2：Writer@6d00a15d age=18, name=&#x27;二哥&#x27;, book=Book@32e6e9c3 bookName=&#x27;编译原理&#x27;, </span><br><span class="line">price=100&#125;&#125;</span><br><span class="line">writer2.book 变更后：</span><br><span class="line">writer1：Writer@68837a77 age=18, name=&#x27;二哥&#x27;, book=Book@32e6e9c3 bookName=&#x27;永恒的图灵&#x27;, </span><br><span class="line">price=70&#125;&#125;</span><br><span class="line">writer2：Writer@36d4b5c age=18, name=&#x27;二哥&#x27;, book=Book@32e6e9c3 bookName=&#x27;永恒的图灵&#x27;, </span><br><span class="line">price=70&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>与之前例子不同的是，writer2.book 变更后，writer1.book 也发生了改变。这是因为字符串 String 是不可变对象，一个新的值必须在字符串常量池中开辟一段新的内存空间，而自定义对象的内存地址并没有发生改变，只是对应的字段值发生了改变，见下图。</p>
<p><img src="\assets\note\image-20231013101831462.png" alt="image-20231013101831462"></p>
<p>“哇，哥，果真一图胜千言，我明白了。”三妹似乎对我画的图很感兴趣呢，“那你继续说深拷贝吧！”</p>
<p>“嗯，三妹，你有没有注意到，浅拷贝克隆的对象中，引用类型的字段指向的是同一个，当改变任何一个对象，另外一个对象也会随之改变，除去字符串的特殊性外。”</p>
<p>“深拷贝和浅拷贝不同的，深拷贝中的引用类型字段也会克隆一份，当改变任何一个对象，另外一个对象不会随之改变。”</p>
<p>“明白了这一点后，我们再来看例子。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Book implements Cloneable&#123;</span><br><span class="line">    private String bookName;</span><br><span class="line">    private int price;</span><br><span class="line">    // getter/setter 和构造方法都已省略</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return super.toString().substring(26) +</span><br><span class="line">                &quot; bookName=&#x27;&quot; + bookName + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, price=&quot; + price +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        return super.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，此时的 Book 类和浅拷贝时不同，重写了 clone() 方法，并实现了 Cloneable 接口。为的就是深拷贝的时候也能够克隆该字段。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Writer implements Cloneable&#123;</span><br><span class="line">    private int age;</span><br><span class="line">    private String name;</span><br><span class="line">    private Book book;</span><br><span class="line">    // getter/setter 和构造方法都已省略</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return super.toString().substring(26) +</span><br><span class="line">                &quot; age=&quot; + age +</span><br><span class="line">                &quot;, name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, book=&quot; + book +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        Writer writer = (Writer) super.clone();</span><br><span class="line">        writer.setBook((Book) writer.getBook().clone());</span><br><span class="line">        return writer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，此时 Writer 类也与之前的不同， clone() 方法当中，不再只调用 Object 的 clone() 方法对 Writer 进行克隆了，还对 Book 也进行了克隆。</p>
<p>来看测试类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class TestClone &#123;</span><br><span class="line">    public static void main(String[] args) throws CloneNotSupportedException &#123;</span><br><span class="line">        Writer writer1 = new Writer(18,&quot;二哥&quot;);</span><br><span class="line">        Book book1 = new Book(&quot;编译原理&quot;,100);</span><br><span class="line">        writer1.setBook(book1);</span><br><span class="line">        Writer writer2 = (Writer) writer1.clone();</span><br><span class="line">        System.out.println(&quot;深拷贝后：&quot;);</span><br><span class="line">        System.out.println(&quot;writer1：&quot; + writer1);</span><br><span class="line">        System.out.println(&quot;writer2：&quot; + writer2);</span><br><span class="line">        Book book2 = writer2.getBook();</span><br><span class="line">        book2.setBookName(&quot;永恒的图灵&quot;);</span><br><span class="line">        book2.setPrice(70);</span><br><span class="line">        System.out.println(&quot;writer2.book 变更后：&quot;);</span><br><span class="line">        System.out.println(&quot;writer1：&quot; + writer1);</span><br><span class="line">        System.out.println(&quot;writer2：&quot; + writer2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个测试类和之前的浅拷贝的测试类就完全一样了，但运行结果是不同的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">深拷贝后：</span><br><span class="line">writer1：Writer@6be46e8f age=18, name=&#x27;二哥&#x27;, book=Book@5056dfcb bookName=&#x27;编译原理&#x27;, </span><br><span class="line">price=100&#125;&#125;</span><br><span class="line">writer2：Writer@6d00a15d age=18, name=&#x27;二哥&#x27;, book=Book@51efea79 bookName=&#x27;编译原理&#x27;, </span><br><span class="line">price=100&#125;&#125;</span><br><span class="line">writer2.book 变更后：</span><br><span class="line">writer1：Writer@6be46e8f age=18, name=&#x27;二哥&#x27;, book=Book@5056dfcb bookName=&#x27;编译原理&#x27;, </span><br><span class="line">price=100&#125;&#125;</span><br><span class="line">writer2：Writer@6d00a15d age=18, name=&#x27;二哥&#x27;, book=Book@51efea79 bookName=&#x27;永恒的图灵&#x27;, </span><br><span class="line">price=70&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>不只是 writer1 和 writer2 是不同的对象，它们中的 book 也是不同的对象。所以，改变了 writer2 中的 book 并不会影响到 writer1。</p>
<p><img src="\assets\note\image-20231013102059277.png" alt="image-20231013102059277"></p>
<p>不过，通过 clone() 方法实现的深拷贝比较笨重，因为要将所有的引用类型都重写 clone() 方法，当嵌套的对象比较多的时候，就废了！</p>
<p>“那有没有好的办法呢？”三妹急切的问。</p>
<p>“当然有了，利用序列化。”我胸有成竹的回答，“序列化是将对象写到流中便于传输，而反序列化则是将对象从流中读取出来。”</p>
<p>“写入流中的对象就是对原始对象的拷贝。需要注意的是，每个要序列化的类都要实现 Serializable 接口，该接口和 Cloneable 接口类似，都是标记型接口。”</p>
<p>来看例子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Book implements Serializable &#123;</span><br><span class="line">    private String bookName;</span><br><span class="line">    private int price;</span><br><span class="line">    // getter/setter 和构造方法都已省略</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return super.toString().substring(26) +</span><br><span class="line">                &quot; bookName=&#x27;&quot; + bookName + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, price=&quot; + price +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Book 需要实现 Serializable 接口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Writer implements Serializable &#123;</span><br><span class="line">    private int age;</span><br><span class="line">    private String name;</span><br><span class="line">    private Book book;</span><br><span class="line">    // getter/setter 和构造方法都已省略</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return super.toString().substring(26) +</span><br><span class="line">                &quot; age=&quot; + age +</span><br><span class="line">                &quot;, name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, book=&quot; + book +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    //深度拷贝</span><br><span class="line">    public Object deepClone() throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        // 序列化</span><br><span class="line">        ByteArrayOutputStream bos = new ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = new ObjectOutputStream(bos);</span><br><span class="line">        oos.writeObject(this);</span><br><span class="line">        // 反序列化</span><br><span class="line">        ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">        ObjectInputStream ois = new ObjectInputStream(bis);</span><br><span class="line">        return ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Writer 类也需要实现 Serializable 接口，并且在该类中，增加了一个 deepClone() 的方法，利用 OutputStream 进行序列化，InputStream 进行反序列化，这样就实现了深拷贝。</p>
<p>来看示例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class TestClone &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException, </span><br><span class="line">ClassNotFoundException &#123;</span><br><span class="line">        Writer writer1 = new Writer(18,&quot;二哥&quot;);</span><br><span class="line">        Book book1 = new Book(&quot;编译原理&quot;,100);</span><br><span class="line">        writer1.setBook(book1);</span><br><span class="line">        Writer writer2 = (Writer) writer1.deepClone();</span><br><span class="line">        System.out.println(&quot;深拷贝后：&quot;);</span><br><span class="line">        System.out.println(&quot;writer1：&quot; + writer1);</span><br><span class="line">        System.out.println(&quot;writer2：&quot; + writer2);</span><br><span class="line">        Book book2 = writer2.getBook();</span><br><span class="line">        book2.setBookName(&quot;永恒的图灵&quot;);</span><br><span class="line">        book2.setPrice(70);</span><br><span class="line">        System.out.println(&quot;writer2.book 变更后：&quot;);</span><br><span class="line">        System.out.println(&quot;writer1：&quot; + writer1);</span><br><span class="line">        System.out.println(&quot;writer2：&quot; + writer2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与之前测试类不同的是，调用了 deepClone() 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">深拷贝后：</span><br><span class="line">writer1：Writer@9629756 age=18, name=&#x27;二哥&#x27;, book=Book@735b5592 bookName=&#x27;编译原理&#x27;, </span><br><span class="line">price=100&#125;&#125;</span><br><span class="line">writer2：Writer@544fe44c age=18, name=&#x27;二哥&#x27;, book=Book@31610302 bookName=&#x27;编译原理&#x27;, </span><br><span class="line">price=100&#125;&#125;</span><br><span class="line">writer2.book 变更后：</span><br><span class="line">writer1：Writer@9629756 age=18, name=&#x27;二哥&#x27;, book=Book@735b5592 bookName=&#x27;编译原理&#x27;, </span><br><span class="line">price=100&#125;&#125;</span><br><span class="line">writer2：Writer@544fe44c age=18, name=&#x27;二哥&#x27;, book=Book@31610302 bookName=&#x27;永恒的图灵&#x27;, </span><br><span class="line">price=70&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果和之前用 clone() 方法实现的深拷贝类似。</p>
<p>“不过，三妹，需要注意，由于是序列化涉及到输入流和输出流的读写，在性能上要比 HotSpot 虚拟机实现的 clone() 方法差很多。”我语重心长地说。</p>
<p>“好的，二哥，你先去休息吧，让我来琢磨一会，总结一下浅拷贝和深拷贝之间的差异。”</p>
<p>“嗯嗯。”</p>
<h2 id="11-5-Java-hashCode方法解析"><a href="#11-5-Java-hashCode方法解析" class="headerlink" title="11.5 Java hashCode方法解析"></a>11.5 Java hashCode方法解析</h2><p>今天我们来谈谈 Java 中的 hashCode() 方法。众所周知，Java 是一门面向对象的编程语言，所有的类都会默认继承自 Object 类，而 Object 的中文意思就是“对象”。</p>
<p>Object 类中就包含了 hashCode() 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public native int hashCode();</span><br></pre></td></tr></table></figure>
<p>意味着所有的类都会有一个 hashCode() 方法，该方法会返回一个 int 类型的值。由于 hashCode() 方法是一个本地方法（ native 关键字修饰的方法，用 C/C++ 语言实现，由 Java 调用），意味着 Object 类中并没有给出具体的实现。</p>
<p>具体的实现可以参考 jdk/src/hotspot/share/runtime/synchronizer.cpp （源码可以到 GitHub 上 OpenJDK 的仓库中下载）。 get_next_hash() 方法会根据 hashCode 的取值来决定采用哪一种哈希值的生成策略。</p>
<p><img src="\assets\note\image-20231013102427849.png" alt="image-20231013102427849"></p>
<p>Java 9 之后， hashCode() 方法会被 @HotSpotIntrinsicCandidate 注解修饰，表明它在 HotSpot 虚拟机中有一套高效的实现，基于 CPU 指令。</p>
<p>那大家有没有想过这样一个问题：<strong>为什么 Object 类需要一个 hashCode()方法呢？</strong></p>
<p>在 Java 中， hashCode() 方法的主要作用就是为了配合哈希表使用的。</p>
<p>哈希表（Hash Table），也叫散列表，是一种可以通过关键码值（key-value）直接访问的数据结构，它最大的特点就是可以快速实现查找、插入和删除。其中用到的算法叫做哈希，就是把任意长度的输入，变换成固定长度的输出，该输出就是哈希值。像 MD5、SHA1 都用的是哈希算法。</p>
<p>像 Java 中的 HashSet、Hashtable（注意是小写的 t）、HashMap 都是基于哈希表的具体实现。其中的 HashMap 就是最典型的代表，不仅面试官经常问，工作中的使用频率也非常的高。</p>
<p>大家想一下，如果没有哈希表，但又需要这样一个数据结构，它里面存放的数据是不允许重复的，该怎么办呢？</p>
<p>要不使用 equals() 方法进行逐个比较？这种方案当然是可行的。但如果数据量特别特别大，采用 equals() 方法进行逐个对比的效率肯定很低很低，最好的解决方案就是哈希表。</p>
<p>拿 HashMap 来说吧。当我们要在它里面添加对象时，先调用这个对象的 hashCode() 方法，得到对应的哈希值，然后将哈希值和对象一起放到 HashMap 中。当我们要再添加一个新的对象时：</p>
<ul>
<li>获取对象的哈希值；</li>
<li>和之前已经存在的哈希值进行比较，如果不相等，直接存进去；</li>
<li>如果有相等的，再调用 equals() 方法进行对象之间的比较，如果相等，不存了；</li>
<li>如果不等，说明哈希冲突了，增加一个链表，存放新的对象；</li>
<li>如果链表的长度大于 8，转为红黑树来处理。</li>
</ul>
<p>就这么一套下来，调用 equals() 方法的频率就大大降低了。也就是说，只要哈希算法足够的高效，把发生哈希冲突的频率降到最低，哈希表的效率就特别的高。</p>
<p>来看一下 HashMap 的哈希算法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先调用对象的 hashCode() 方法，然后对该值进行右移运算，然后再进行异或运算。</p>
<p>通常来说，String 会用来作为 HashMap 的键进行哈希运算，因此我们再来看一下 String 的 hashCode() 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public int hashCode() &#123;</span><br><span class="line">    int h = hash;</span><br><span class="line">    if (h == 0 &amp;&amp; value.length &gt; 0) &#123;</span><br><span class="line">        char val[] = value;</span><br><span class="line">        for (int i = 0; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = 31 * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    return h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可想而知，经过这么一系列复杂的运算，再加上 JDK 作者这种大师级别的设计，哈希冲突的概率我相信已经降到了最低（我们在 HashMap 中深入探讨过）。</p>
<p>当然了，从理论上来说，对于两个不同对象，它们通过 hashCode() 方法计算后的值可能相同。因此，不能使用 hashCode() 方法来判断两个对象是否相等，必须得通过 equals() 方法。</p>
<p>也就是说：</p>
<ul>
<li>如果两个对象调用 equals() 方法得到的结果为 true，调用 hashCode() 方法得到的结果必定相等；</li>
<li>如果两个对象调用 hashCode() 方法得到的结果不相等，调用 equals() 方法得到的结果必定为 false；</li>
</ul>
<p>反之：</p>
<ul>
<li>如果两个对象调用 equals() 方法得到的结果为 false，调用 hashCode() 方法得到的结果不一定不相等；</li>
<li>如果两个对象调用 hashCode() 方法得到的结果相等，调用 equals() 方法得到的结果不一定为 true；</li>
</ul>
<p>来看下面这段代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Student s1 = new Student(18, &quot;张三&quot;);</span><br><span class="line">        Map&lt;Student, Integer&gt; scores = new HashMap&lt;&gt;();</span><br><span class="line">        scores.put(s1, 98);</span><br><span class="line">        System.out.println(scores.get(new Student(18, &quot;张三&quot;)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> class Student &#123;</span><br><span class="line">    private int age;</span><br><span class="line">    private String name;</span><br><span class="line">     public Student(int age, String name) &#123;</span><br><span class="line">         this.age = age;</span><br><span class="line">         this.name = name;</span><br><span class="line">     &#125;</span><br><span class="line">     @Override</span><br><span class="line">     public boolean equals(Object o) &#123;</span><br><span class="line">         Student student = (Student) o;</span><br><span class="line">         return age == student.age &amp;&amp;</span><br><span class="line">                 Objects.equals(name, student.name);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>我们重写了 Student 类的 equals() 方法，如果两个学生的年纪和姓名相同，我们就认为是同一个学生，虽然很离谱，但我们就是这么草率。</p>
<p>在 main() 方法中，18 岁的张三考试得了 98 分，很不错的成绩，我们把张三和成绩放到了 HashMap 中，然后准备输出张三的成绩：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">null</span><br></pre></td></tr></table></figure>
<p>很不巧，结果为 null，而不是预期当中的 98。这是为什么呢？</p>
<p>原因就在于重写 equals() 方法的时候没有重写 hashCode() 方法。默认情况下， hashCode() 方法是一个本地方法，会返回对象的存储地址，显然 put() 中的 s1 和 get() 中的 new Student(18, “张三”) 是两个对象，它们的存储地址肯定是不同的。</p>
<p>HashMap 的 get() 方法会调用 hash(key.hashCode()) 计算对象的哈希值，虽然两个不同的 hashCode() 结果经过 hash() 方法计算后有可能得到相同的结果，但这种概率微乎其微，所以就导致 scores.get(new Student(18, “张三”)) 无法得到预期的值 18。</p>
<p>怎么解决这个问题呢？很简单，重写 hashCode() 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"> public int hashCode() &#123;</span><br><span class="line">     return Objects.hash(age, name);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>Objects 类的 hash() 方法可以针对不同数量的参数生成新的 hashCode() 值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static int hashCode(Object a[]) &#123;</span><br><span class="line"> if (a == null)</span><br><span class="line">     return 0;</span><br><span class="line"> int result = 1;</span><br><span class="line"> for (Object element : a)</span><br><span class="line">     result = 31 * result + (element == null ? 0 : element.hashCode());</span><br><span class="line"> return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码似乎很简单，归纳出的数学公式如下所示（n 为字符串长度）。</p>
<p><img src="\assets\note\image-20231013102931782.png" alt="image-20231013102931782"></p>
<p>注意：31 是个奇质数，不大不小，一般质数都非常适合哈希计算，偶数相当于移位运算，容易溢出，造成数据信息丢失。</p>
<p>这就意味着年纪和姓名相同的情况下，会得到相同的哈希值。 scores.get(new Student(18, “张三”)) 就会返回 98 的预期值了。</p>
<p>《Java 编程思想》这本圣经中有一段话，对 hashCode() 方法进行了一段描述。</p>
<blockquote>
<p>设计 hashCode() 时最重要的因素就是：无论何时，对同一个对象调用 hashCode() 都应该生成同样的值。如果在将一个对象用 put() 方法添加进 HashMap 时产生一个 hashCode() 值，而用 get() 方法取出时却产生了另外一个 hashCode() 值，那么就无法重新取得该对象了。所以，如果你的 hashCode() 方法依赖于对象中易变的数据，用户就要当心了，因为此数据发生变化时，hashCode() 就会生成一个不同的哈希值，相当于产生了一个不同的键。</p>
</blockquote>
<p>也就是说，如果在重写 hashCode() 和 equals() 方法时，对象中某个字段容易发生改变，那么最好舍弃这些字段，以免产生不可预期的结果。</p>
<p>好。有了上面这些内容作为基础后，我们回头再来看看本地方法 hashCode() 的 C++ 源码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">static inline intptr_t get_next_hash(Thread* current, oop obj) &#123;</span><br><span class="line">  intptr_t value = 0;</span><br><span class="line">  if (hashCode == 0) &#123;</span><br><span class="line">    // 这种形式使用全局的 Park-Miller 随机数生成器。</span><br><span class="line">    // 在 MP 系统上，我们将对全局变量进行大量的读写访问，因此该机制会引发大量的一致性通信。</span><br><span class="line">    value = os::random();</span><br><span class="line">  &#125; else if (hashCode == 1) &#123;</span><br><span class="line">    // 这种变体在 STW（Stop The World）操作之间具有稳定（幂等）的特性。</span><br><span class="line">    // 在一些 1-0 同步方案中，这可能很有用。</span><br><span class="line">    intptr_t addr_bits = cast_from_oop&lt;intptr_t&gt;(obj) &gt;&gt; 3;</span><br><span class="line">    value = addr_bits ^ (addr_bits &gt;&gt; 5) ^ GVars.stw_random;</span><br><span class="line">  &#125; else if (hashCode == 2) &#123;</span><br><span class="line">    value = 1;            // 用于敏感性测试</span><br><span class="line">  &#125; else if (hashCode == 3) &#123;</span><br><span class="line">    value = ++GVars.hc_sequence;</span><br><span class="line">  &#125; else if (hashCode == 4) &#123;</span><br><span class="line">    value = cast_from_oop&lt;intptr_t&gt;(obj);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // Marsaglia 的异或移位方案，具有线程特定的状态</span><br><span class="line">    // 这可能是最好的整体实现 -- 我们可能会在未来的版本中将其设为默认实现。</span><br><span class="line">    unsigned t = current-&gt;_hashStateX;</span><br><span class="line">    t ^= (t &lt;&lt; 11);</span><br><span class="line">    current-&gt;_hashStateX = current-&gt;_hashStateY;</span><br><span class="line">    current-&gt;_hashStateY = current-&gt;_hashStateZ;</span><br><span class="line">    current-&gt;_hashStateZ = current-&gt;_hashStateW;</span><br><span class="line">    unsigned v = current-&gt;_hashStateW;</span><br><span class="line">    v = (v ^ (v &gt;&gt; 19)) ^ (t ^ (t &gt;&gt; 8));</span><br><span class="line">    current-&gt;_hashStateW = v;</span><br><span class="line">    value = v;</span><br><span class="line">  &#125;</span><br><span class="line">  value &amp;= markWord::hash_mask;</span><br><span class="line">  if (value == 0) value = 0xBAD;</span><br><span class="line">  assert(value != markWord::no_hash, &quot;invariant&quot;);</span><br><span class="line">  return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果没有 C++ 基础的话，不用细致去看每一行代码，我们只通过表面去了解一下 get_next_hash() 这个方法就行。其中的 hashCode 变量是 JVM 启动时的一个全局参数，可以通过它来切换哈希值的生成策略。</p>
<ul>
<li>hashCode==0 ，调用操作系统 OS 的 random() 方法返回随机数。</li>
<li>hashCode == 1 ，在 STW（stop-the-world）操作中，这种策略通常用于同步方案中。利用对象地址进行计算，使用不经常更新的随机数（ GVars.stw_random ）参与其中。</li>
<li>hashCode == 2 ，使用返回 1，用于某些情况下的测试。</li>
<li>hashCode == 3 ，从 0 开始计算哈希值，不是线程安全的，多个线程可能会得到相同的哈希值。</li>
<li>hashCode == 4 ，与创建对象的内存位置有关，原样输出。</li>
<li>hashCode == 5 ，默认值，支持多线程，使用了 Marsaglia 的 xor-shift 算法产生伪随机数。所谓的 xor-shift 算法，简单来说，看起来就是一个移位寄存器，每次移入的位由寄存器中若干位取异或生成。所谓的伪随机数，不是完全随机的，但是真随机生成比较困难，所以只要能通过一定的随机数统计检测，就可以当作真随机数来使用。</li>
</ul>
<p>这里简单总结下。</p>
<p>在 Java 中， hashCode()方法是定义在 java.lang.Object 类中的一个方法，该类是所有 Java 所有类的父类。因此，每个 Java 对象都可以调用 hashCode()方法。 hashCode()方法主要用于支持哈希表（如 java.util.HashMap），这些数据结构使用哈希算法能实现快速查找、插入和删除操作。</p>
<p>hashCode()方法的主要目的是返回一个整数，这个整数称为哈希码，它代表了对象在内存中的一种近似表示。哈希码用于将对象映射到哈希表中的一个特定的位置。两个相等的对象（根据 equals()方法比较）应该具有相同的哈希码。然而，具有相同哈希码的两个对象并不一定相等。</p>
<p>当你创建一个自定义类并覆盖 equals()方法时，通常也需要覆盖 hashCode()方法，以确保相等的对象具有相同的哈希码。这有助于提高哈希表在使用自定义类的对象作为键时的准确性。</p>
<h2 id="11-6-Java是值传递还是引用传递？"><a href="#11-6-Java是值传递还是引用传递？" class="headerlink" title="11.6 Java是值传递还是引用传递？"></a>11.6 Java是值传递还是引用传递？</h2><p>“哥，说说 Java 到底是值传递还是引用传递吧？”三妹一脸的困惑，看得出来她被这个问题折磨得不轻。</p>
<p>“说实在的，我在一开始学 Java 的时候也被这个问题折磨得够呛，总以为基本数据类型在传参的时候是值传递，而引用类型是引用传递。”我对三妹袒露了心声，为的就是让她不再那么焦虑，她哥当年也是这么过来的。</p>
<p>C 语言是很多编程语言的母胎，包括 Java，那么对于 C 语言来说，所有的方法参数都是“通过值”传递的，也就是说，传递给被调用方法的参数值存放在临时变量中，而不是存放在原来的变量中。这就意味着，被调用的方法不能修改调用方法中变量的值，而只能修改其私有变量的临时副本的值。</p>
<p>Java 继承了 C 语言这一特性，因此 Java 是按照值来传递的。</p>
<p>接下来，我们必须得搞清楚，到底什么是值传递（pass by value），什么是引用传递（pass by reference），否则，讨论 Java 到底是值传递还是引用传递就显得毫无意义。</p>
<p>当一个参数按照值的方式在两个方法之间传递时，调用者和被调用者其实是用的两个不同的变量——被调用者中的变量（原始值）是调用者中变量的一份拷贝，对它们当中的任何一个变量修改都不会影响到另外一个变量，据说 Fortran 语言是通过引用传递的。</p>
<p>“Fortran 语言？”三妹睁大了双眼，似乎听见了什么新的名词。</p>
<p>“是的，Fortran 语言，1957 年由 IBM 公司开发，是世界上第一个被正式采用并流传至今的高级编程语言。”当一个参数按照引用传递的方式在两个方法之间传递时，调用者和被调用者其实用的是同一个变量，当该变量被修改时，双方都是可见的。</p>
<p>“我们之所以容易搞不清楚 Java 到底是值传递还是引用传递，主要是因为 Java 中的两类数据类型的叫法容易引发误会，比如说 int 是基本类型，说它是值传递的，我们就很容易理解；但对于引用类型，比如说 String，说它也是值传递的时候，我们就容易弄不明白。”</p>
<p>我们来看看基本数据类型和引用数据类型之间的差别。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int age = 18;</span><br><span class="line">String name = &quot;二哥&quot;;</span><br></pre></td></tr></table></figure>
<p>age 是基本类型，值就保存在变量中，而 name 是引用类型，变量中保存的是对象的地址。一般称这种变量为对象的引用，引用存放在栈中，而对象存放在堆中。</p>
<p>这里说的栈和堆，是指内存中的一块区域，和数据结构中的栈和堆不一样。栈是由编译器自动分配释放的，所以适合存放编译期就确定生命周期的数据；而堆中存放的数据，编译器是不需要知道生命周期的，创建后的回收工作由垃圾收集器来完成。</p>
<p>“画幅图。”</p>
<p><img src="\assets\note\image-20231013103352432.png" alt="image-20231013103352432"></p>
<p>当用 = 赋值运算符改变 age 和 name 的值时。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">age = 16;</span><br><span class="line">name = &quot;三妹&quot;;</span><br></pre></td></tr></table></figure>
<p>对于基本类型 age，赋值运算符会直接改变变量的值，原来的值被覆盖。</p>
<p>对于引用类型 name，赋值运算符会改变对象引用中保存的地址，原来的地址被覆盖，但原来的对象不会被覆盖。</p>
<p><img src="\assets\note\image-20231013103456150.png" alt="image-20231013103456150"></p>
<p>“三妹，注意听，接下来，我们来说说基本数据类型的参数传递。”</p>
<p>Java 有 8 种基本数据类型，分别是 int、long、byte、short、float、double 、char 和 boolean，就拿 int 类型来举例吧。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class PrimitiveTypeDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int age = 18;</span><br><span class="line">        modify(age);</span><br><span class="line">        System.out.println(age);</span><br><span class="line">    &#125;</span><br><span class="line">    private static void modify(int age1) &#123;</span><br><span class="line">        age1 = 30;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1） main() 方法中的 age 为基本类型，所以它的值 18 直接存储在变量中。</p>
<p>2）调用 modify() 方法的时候，将会把 age 的值 18 复制给形参 age1。</p>
<p>3） modify() 方法中，对 age1  做出了修改。</p>
<p>4）回到 main() 方法中，age 的值仍然为 18，并没有发生改变。</p>
<p>如果我们想让 age 的值发生改变，就需要这样做。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class PrimitiveTypeDemo1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int age = 18;</span><br><span class="line">        age = modify(age);</span><br><span class="line">        System.out.println(age);</span><br><span class="line">    &#125;</span><br><span class="line">    private static int modify(int age1) &#123;</span><br><span class="line">        age1 = 30;</span><br><span class="line">        return age1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一，让 modify() 方法有返回值；</p>
<p>第二，使用赋值运算符重新对 age 进行赋值。</p>
<p>“好了，再来说说引用类型的参数传递。”</p>
<p>就以 String 为例吧。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class ReferenceTypeDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String name = &quot;二哥&quot;;</span><br><span class="line">        modify(name);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">    private static void modify(String name1) &#123;</span><br><span class="line">        name1 = &quot;三妹&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在调用 modify() 方法的时候，形参 name1 复制了 name 的地址，指向的是堆中“二哥”的位置。</p>
<p><img src="\assets\note\image-20231013103637589.png" alt="image-20231013103637589"></p>
<p>当 modify() 方法调用结束后，改变了形参 name1 的地址，但 main() 方法中 name 并没有发生改变。</p>
<p><img src="\assets\note\image-20231013103705165.png" alt="image-20231013103705165"></p>
<p>总结：</p>
<ul>
<li>Java 中的参数传递是按值传递的。</li>
<li>如果参数是基本类型，传递的是基本类型的字面量值的拷贝。</li>
<li>如果参数是引用类型，传递的是引用的对象在堆中地址的拷贝。</li>
</ul>
<p>“好了，三妹，今天的学习就到这吧。”</p>
<h2 id="11-7-Java为什么无法实现真正的泛型"><a href="#11-7-Java为什么无法实现真正的泛型" class="headerlink" title="11.7 Java为什么无法实现真正的泛型"></a>11.7 Java为什么无法实现真正的泛型</h2><p>“二哥，为啥 Java 不能实现真正的泛型啊？”三妹开门见山地问。</p>
<p>简单来回顾一下类型擦除，看下面这段代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Cmower &#123;</span><br><span class="line">    public static void method(ArrayList&lt;String&gt; list) &#123;</span><br><span class="line">        System.out.println(&quot;Arraylist&lt;String&gt; list&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void method(ArrayList&lt;Date&gt; list) &#123;</span><br><span class="line">        System.out.println(&quot;Arraylist&lt;Date&gt; list&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“三妹，你是不是认为 ArrayList<String> list 和 ArrayList<Date> list 是两种不同的类型，因为 String 和 Date 是不同的类。”我问。</p>
<p>“嗯。”三妹点点头。</p>
<p>但由于类型擦除的原因，以上代码是不会编译通过的——编译器会提示一个错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&#x27;method(ArrayList&lt;String&gt;)&#x27; clashes with &#x27;method(ArrayList&lt;Date&gt;)&#x27;; both methods </span><br><span class="line">have same erasure</span><br></pre></td></tr></table></figure>
<p>也就是说，两个 method() 方法经过类型擦除后的方法签名是完全相同的，Java 是不允许这样做的。</p>
<p>也就是说，按照我们的假设：如果 Java 能够实现真正意义上的泛型，两个 method() 方法是可以同时存在的，就好像方法重载一样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Cmower &#123;</span><br><span class="line">    public static void method(String list) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void method(Date list) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“为什么 Java 不能实现真正意义上的泛型呢？背后的原因是什么？快告诉我呀！”三妹着急了。</p>
<p>“保持耐心，好不好？”我安慰道。</p>
<p><strong>第一，兼容性</strong></p>
<p>Java 在 2004 年已经积累了较为丰富的生态，如果把现有的类修改为泛型类，需要让所有的用户重新修改源代码并且编译，这就会导致 Java 1.4 之前打下的江山可能会完全覆灭。</p>
<p>想象一下，你的代码原来运行的好好的，就因为 JDK 的升级，导致所有的源代码都无法编译通过并且无法运行，是不是会非常痛苦？</p>
<p>类型擦除就完美实现了兼容性，Java 1.5 之后的类可以使用泛型，而 Java 1.4 之前没有使用泛型的类也可以保留，并且不用做任何修改就能在新版本的 Java 虚拟机上运行。</p>
<p>老用户不受影响，新用户可以自由地选择使用泛型，可谓一举两得。</p>
<p><strong>第二，不是“实现不了”</strong>。Pizza，1996 年的实验语言，在 Java 的基础上扩展了泛型。</p>
<blockquote>
<p>Pizza 教程地址：<a target="_blank" rel="noopener" href="http://pizzacompiler.sourceforge.net/doc/tutorial.html">http://pizzacompiler.sourceforge.net/doc/tutorial.html</a></p>
</blockquote>
<p>“1996 年？”三妹表示很吃惊。</p>
<p>“嗯，你那会还没出生。”我说，“插一下 Java 的版本历史吧，你好有一个时间线上的观念。”</p>
<ul>
<li>1995年5月23日，Java语言诞生</li>
<li>1996年1月，JDK1.0 诞生</li>
<li>1997年2月18日，JDK1.1发布</li>
<li>1998年2月，JDK1.1被下载超过2,000,000次</li>
<li>2000年5月8日，JDK1.3发布</li>
<li>2000年5月29日，JDK1.4发布</li>
<li>2004年9月30日18:00 PM，J2SE1.5 发布</li>
</ul>
<p>也就是说，Pizza 在 JDK 1.0 的版本上就实现了“真正意义上的”泛型，我引过来两段例子，你一看就明白了。</p>
<p>首先是 StoreSomething，一个泛型类，标识符是大写字母 A 而不是我们熟悉的大写字母 T。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class StoreSomething&lt;A&gt; &#123;</span><br><span class="line">     A something;</span><br><span class="line">     StoreSomething(A something) &#123;</span><br><span class="line">         this.something = something;</span><br><span class="line">     &#125;</span><br><span class="line">     void set(A something) &#123;</span><br><span class="line">         this.something = something;</span><br><span class="line">     &#125;</span><br><span class="line">     A get() &#123;</span><br><span class="line">         return something;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 A 呢，可以是任何合法的 Java 类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StoreSomething&lt;String&gt; a = new StoreSomething(&quot;I&#x27;m a string!&quot;);</span><br><span class="line">StoreSomething&lt;int&gt; b = new StoreSomething(17+4);</span><br><span class="line">b.set(9);</span><br><span class="line">int i = b.get();</span><br><span class="line">String s = a.get();</span><br></pre></td></tr></table></figure>
<p>对吧？这就是我们想要的“真正意义上的泛型”，A 不仅仅可以是引用类型 String，还可以是基本数据类型。</p>
<p>要知道，Java 的泛型不允许是基本数据类型，只能是包装器类型。</p>
<p><img src="\assets\note\image-20231013104221817.png" alt="image-20231013104221817"></p>
<p>除此之外，Pizza 的泛型还可以直接使用 new 关键字进行声明，并且 Pizza 编译器会从构造方法的参数上推断出具体的对象类型，究竟是 String 还是 int。要知道，Java 的泛型因为类型擦除的原因，程序员是无法知道一个 ArrayList 究竟是 ArrayList<String> 还是 ArrayList<Integer> 的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; ints = new ArrayList&lt;Integer&gt;();</span><br><span class="line">ArrayList&lt;String&gt; strs = new ArrayList&lt;String&gt;();</span><br><span class="line">System.out.println(ints.getClass());</span><br><span class="line">System.out.println(strs.getClass());</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class java.util.ArrayList</span><br><span class="line">class java.util.ArrayList</span><br></pre></td></tr></table></figure>
<p>都是 ArrayList 而已。</p>
<p>“那 Pizza 这种“真正意义上的泛型”为什么没有被 Java 采纳呢？”三妹很关心这个问题。</p>
<p>事实上，Java 的核心开发组对 Pizza 的泛型设计非常感兴趣，并且与 Pizza 的设计者 Martin 和 Phil 取得了联系，新合作了一个项目 Generic Java，争取在 Java 中添加泛型支持，但不引入 Pizza 的其他功能，比如说函数式编程。</p>
<p>这里再补充一点维基百科上的资料，Martin Odersky 是一名德国计算机科学家，他和其他人一起设计了 Scala 编程语言，以及 Generic Java（还有之前的 Pizza），他实现的 Generic Java 编译器成为了 Java 编译器 javac 的基础。</p>
<p>站在马后炮的思维来看，Pizza 的泛型设计和函数式编程非常具有历史前瞻性。然而 Java 的核心开发组在当时似乎并不想把函数式编程引入到 Java 中。</p>
<p>以至于 Java 在 1.4 之前仍然是不支持泛型的。</p>
<p>“为什么 Java 1.5 的时候又突然支持泛型了呢？”三妹问。</p>
<p>“当然是到了不支持不行的时候了。”我说。</p>
<p>没有泛型之前，我们可以这样写代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList list = new ArrayList();</span><br><span class="line">list.add(&quot;沉默王二&quot;);</span><br><span class="line">list.add(new Date());</span><br></pre></td></tr></table></figure>
<p>不管是 String 类型，还是 Date 类型，都可以一股脑塞进 ArrayList 当中，这看起来似乎很方便，但取的时候就悲剧了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = list.get(1);</span><br></pre></td></tr></table></figure>
<p>这样取行吗？不行。还得加上强制转换。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = (String) list.get(1);</span><br></pre></td></tr></table></figure>
<p>但我们知道，这行代码在运行的时候必然会出错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.ClassCastException: java.util.Date cannot be </span><br><span class="line">cast to java.lang.String</span><br></pre></td></tr></table></figure>
<p>这就又回到“兼容性”的问题了。</p>
<p>Java 语言和其他编程语言不一样，有着沉重的历史包袱，1.5 之前已经有大量的程序部署在生产环境下了，这时候如果一刀切，原来没有使用泛型的代码直接扼杀了，后果不堪想象。</p>
<p>Java 一直以来都强调兼容性，我认为这也是 Java 之所以能被广泛使用的主要原因之一，开发者不必担心Java 版本升级的问题，一个在 JDK 1.4 上可以跑的代码，放在 JDK 1.5 上仍然可以跑。</p>
<p>这里必须得说明一点，J2SE1.5 的发布，是 Java 语言发展史上的重要里程碑，为了表示该版本的重要性，J2SE1.5 也正式更名为 Java SE 5.0，往后去就是 Java SE 6.0，Java SE 7.0。。。。</p>
<p>但 Java 并不支持高版本 JDK 编译生成的字节码文件在低版本的 JRE（Java 运行时环境）上跑。</p>
<p><img src="\assets\note\image-20231013104520606.png" alt="image-20231013104520606"></p>
<p>针对泛型，兼容性具体表现在什么地方呢？来看下面这段代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; ints = new ArrayList&lt;Integer&gt;();</span><br><span class="line">ArrayList&lt;String&gt; strs = new ArrayList&lt;String&gt;();</span><br><span class="line">ArrayList list;</span><br><span class="line">list = ints;</span><br><span class="line">list = strs;</span><br></pre></td></tr></table></figure>
<p>“兼容性表现在上面这段代码必须得能够编译运行。怎么办呢？”我扭头看了一下旁边的三妹，继续说。</p>
<p>“只能搞类型擦除了！”我妹肯定地回答。</p>
<p>“是滴。”</p>
<p>编译前进行泛型检测， ArrayList<Integer> 只能放 Integer， ArrayList<String> 只能放 String，取的时候就不用担心类型强转出错了。</p>
<p>但编译后的字节码文件里，是没有泛型的，放的都是 Object。</p>
<p>Java 神奇就神奇在这，表面上万物皆对象，但为了性能上的考量，又存在 int、double 这种原始类型，但原始类型又没办法和 Object 兼容，于是我们就只能写 ArrayList<Integer> 这样很占用内存空间的代码。</p>
<p>这恐怕也是 Java 泛型被吐槽的原因之一了。</p>
<p><img src="\assets\note\image-20231013104632447.png" alt="image-20231013104632447"></p>
<p>一个好消息是 Valhalla 项目正在努力解决这些因为泛型擦除带来的历史遗留问题。</p>
<p>Project Valhalla：正在进行当中的 OpenJDK 项目，计划给未来的 Java 添加改进的泛型支持。</p>
<blockquote>
<p>源码地址：<a target="_blank" rel="noopener" href="http://openjdk.java.net/projects/valhalla/">http://openjdk.java.net/projects/valhalla/</a></p>
</blockquote>
<p>让我们拭目以待吧！</p>
<p>“怎么样？三妹，这下全部都明白了吧！”我问。</p>
<p>“嗯嗯。二哥，你讲得可真棒 ”三妹夸奖得我有点小开心，嘿嘿。</p>
<h2 id="11-8-掌握-Java-反射"><a href="#11-8-掌握-Java-反射" class="headerlink" title="11.8 掌握 Java 反射"></a>11.8 掌握 Java 反射</h2><p>“二哥，什么是反射呀？”三妹开门见山地问。</p>
<p>“要想知道什么是反射，就需要先来了解什么是‘正射’。”我笑着对三妹说，“一般情况下，我们在使用某个类之前已经确定它到底是个什么类了，拿到手就直接可以使用 new 关键字来调用构造方法进行初始化，之后使用这个类的对象来进行操作。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Writer writer = new Writer();</span><br><span class="line">writer.setName(&quot;沉默王二&quot;);</span><br></pre></td></tr></table></figure>
<p>像上面这个例子，就可以理解为“正射”。而反射就意味着一开始我们不知道要初始化的类到底是什么，也就没法直接使用 new 关键字创建对象了。</p>
<p>我们只知道这个类的一些基本信息，就好像我们看电影的时候，为了抓住一个犯罪嫌疑人，警察就会问一些目击证人，根据这些证人提供的信息，找专家把犯罪嫌疑人的样貌给画出来——这个过程，就可以称之为反射。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(&quot;com.itwanger.s39.Writer&quot;);</span><br><span class="line">Method method = clazz.getMethod(&quot;setName&quot;, String.class);</span><br><span class="line">Constructor constructor = clazz.getConstructor();</span><br><span class="line">Object object = constructor.newInstance();</span><br><span class="line">method.invoke(object,&quot;沉默王二&quot;);</span><br></pre></td></tr></table></figure>
<p>像上面这个例子，就可以理解为“反射”。</p>
<p>“反射的写法比正射复杂得多啊！”三妹感慨地说。</p>
<p>“是的，反射的成本是要比正射的高得多。”我说，“反射的缺点主要有两个。”</p>
<ul>
<li><strong>破坏封装</strong>：由于反射允许访问私有字段和私有方法，所以可能会破坏封装而导致安全问题。</li>
<li><strong>性能开销</strong>：由于反射涉及到动态解析，因此无法执行 Java 虚拟机优化，再加上反射的写法的确要复杂得多，所以性能要比“正射”差很多，在一些性能敏感的程序中应该避免使用反射。</li>
</ul>
<p>“那反射有哪些好处呢？”三妹问。</p>
<p>反射的主要应用场景有：</p>
<ul>
<li><strong>开发通用框架</strong>：像 Spring，为了保持通用性，通过配置文件来加载不同的对象，调用不同的方法。</li>
<li><strong>动态代理</strong>：在面向切面编程中，需要拦截特定的方法，就会选择动态代理的方式，而动态代理的底层技术就是反射。</li>
<li><strong>注解</strong>：注解本身只是起到一个标记符的作用，它需要利用发射机制，根据标记符去执行特定的行为。</li>
</ul>
<p>“好了，来看一下完整的例子吧。”我对三妹说。</p>
<p>Writer 类，有两个字段，然后还有对应的 getter/setter。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Writer &#123;</span><br><span class="line">    private int age;</span><br><span class="line">    private String name;</span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class ReflectionDemo1 &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException, </span><br><span class="line">NoSuchMethodException, IllegalAccessException, InvocationTargetException, </span><br><span class="line">InstantiationException &#123;</span><br><span class="line">        Writer writer = new Writer();</span><br><span class="line">        writer.setName(&quot;沉默王二&quot;);</span><br><span class="line">        System.out.println(writer.getName());</span><br><span class="line">        Class clazz = Class.forName(&quot;com.itwanger.s39.Writer&quot;);</span><br><span class="line">        Constructor constructor = clazz.getConstructor();</span><br><span class="line">        Object object = constructor.newInstance();</span><br><span class="line">        Method setNameMethod = clazz.getMethod(&quot;setName&quot;, String.class);</span><br><span class="line">        setNameMethod.invoke(object, &quot;沉默王二&quot;);</span><br><span class="line">        Method getNameMethod = clazz.getMethod(&quot;getName&quot;);</span><br><span class="line">        System.out.println(getNameMethod.invoke(object));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看一下输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">沉默王二</span><br><span class="line">沉默王二</span><br></pre></td></tr></table></figure>
<p>只不过，反射的过程略显曲折了一些。</p>
<p>第一步，获取反射类的 Class 对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(&quot;com.itwanger.s39.Writer&quot;);</span><br></pre></td></tr></table></figure>
<p>第二步，通过  Class 对象获取构造方法 Constructor 对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Constructor constructor = clazz.getConstructor();</span><br></pre></td></tr></table></figure>
<p>第三步，通过 Constructor 对象初始化反射类对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object object = constructor.newInstance();</span><br></pre></td></tr></table></figure>
<p>第四步，获取要调用的方法的 Method 对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Method setNameMethod = clazz.getMethod(&quot;setName&quot;, String.class);</span><br><span class="line">Method getNameMethod = clazz.getMethod(&quot;getName&quot;);</span><br></pre></td></tr></table></figure>
<p>第五步，通过 invoke() 方法执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setNameMethod.invoke(object, &quot;沉默王二&quot;);</span><br><span class="line">getNameMethod.invoke(object)</span><br></pre></td></tr></table></figure>
<p>“三妹，你看，经过这五个步骤，基本上就掌握了反射的使用方法。”我说。</p>
<p>“好像反射也没什么复杂的啊！”三妹说。</p>
<p>我先对三妹点点头，然后说：“是的，掌握反射的基本使用方法确实不难，但要理解整个反射机制还是需要花一点时间去了解一下 Java 虚拟机的类加载机制的。”</p>
<p>要想使用反射，首先需要获得反射类的 Class 对象，每一个类，不管它最终生成了多少个对象，这些对象只会对应一个 Class 对象，这个 Class 对象是由 Java 虚拟机生成的，由它来获悉整个类的结构信息。</p>
<p>也就是说， java.lang.Class 是所有反射 API 的入口。</p>
<p>而方法的反射调用，最终是由 Method 对象的 invoke() 方法完成的，来看一下源码（JDK 8 环境下）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public Object invoke(Object obj, Object... args)</span><br><span class="line">        throws IllegalAccessException, IllegalArgumentException,</span><br><span class="line">        InvocationTargetException &#123;</span><br><span class="line">    // 如果方法不允许被覆盖，进行权限检查</span><br><span class="line">    if (!override) &#123;</span><br><span class="line">        if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</span><br><span class="line">            Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">            // 检查调用者是否具有访问权限</span><br><span class="line">            checkAccess(caller, clazz, obj, modifiers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取方法访问器（从 volatile 变量中读取）</span><br><span class="line">    MethodAccessor ma = methodAccessor;</span><br><span class="line">    if (ma == null) &#123;</span><br><span class="line">        // 如果访问器为空，尝试获取方法访问器</span><br><span class="line">        ma = acquireMethodAccessor();</span><br><span class="line">    &#125;</span><br><span class="line">    // 使用方法访问器调用方法，并返回结果</span><br><span class="line">    return ma.invoke(obj, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个嵌套的 if 语句是用来进行权限检查的。</p>
<p>invoke() 方法实际上是委派给 MethodAccessor 接口来完成的。</p>
<p><img src="\assets\note\image-20231013105150453.png" alt="image-20231013105150453"></p>
<p>MethodAccessor 接口有三个实现类，其中的 MethodAccessorImpl 是一个抽象类，另外两个具体的实现类继承了这个抽象类。</p>
<p><img src="\assets\note\image-20231013105208523.png" alt="image-20231013105208523"></p>
<ul>
<li>NativeMethodAccessorImpl：通过本地方法来实现反射调用；</li>
<li>DelegatingMethodAccessorImpl：通过委派模式来实现反射调用；</li>
</ul>
<p>通过 debug 的方式进入 invoke() 方法后，可以看到第一次反射调用会生成一个委派实现 DelegatingMethodAccessorImpl，它在生成的时候会传递一个本地实现 NativeMethodAccessorImpl。</p>
<p><img src="\assets\note\image-20231013105254107.png" alt="image-20231013105254107"></p>
<p>也就是说， invoke() 方法在执行的时候，会先调用 DelegatingMethodAccessorImpl，然后调用 NativeMethodAccessorImpl，最后再调用实际的方法。</p>
<p>“为什么不直接调用本地实现呢？”三妹问。</p>
<p>“之所以采用委派实现，是为了能够在本地实现和动态实现之间切换。动态实现是另外一种反射调用机制，它是通过生成字节码的形式来实现的。如果反射调用的次数比较多，动态实现的效率就会更高，因为本地实现需要经过 Java 到 C/C++ 再到 Java 之间的切换过程，而动态实现不需要；但如果反射调用的次数比较少，反而本地实现更快一些。”我说。</p>
<p>“那临界点是多少呢？”三妹问。</p>
<p>“默认是 15 次。”我说，“可以通过 -Dsun.reflect.inflationThreshold 参数类调整。”</p>
<p>来看下面这个例子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Method setAgeMethod = clazz.getMethod(&quot;setAge&quot;, int.class);</span><br><span class="line">for (int i = 0;i &lt; 20; i++) &#123;</span><br><span class="line">    setAgeMethod.invoke(object, 18);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 invoke() 方法处加断点进入 debug 模式，当 i = 15 的时候，也就是第 16 次执行的时候，会进入到 if 条件分支中，改变 DelegatingMethodAccessorImpl 的委派模式 delegate 为 (MethodAccessorImpl)(new MethodAccessorGenerator()).generateMethod() ，而之前的委派模式 delegate 为 NativeMethodAccessorImpl。</p>
<p><img src="\assets\note\image-20231013105403871.png" alt="image-20231013105403871"></p>
<p>“这下明白了吧？三妹。”我说，“接下来，我们再来熟悉一下反射当中常用的 API。”</p>
<p><strong>1）获取反射类的 Class 对象</strong></p>
<p>Class.forName() ，参数为反射类的完全限定名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class c1 = Class.forName(&quot;com.itwanger.s39.ReflectionDemo3&quot;);</span><br><span class="line">System.out.println(c1.getCanonicalName());</span><br><span class="line">Class c2 = Class.forName(&quot;[D&quot;);</span><br><span class="line">System.out.println(c2.getCanonicalName());</span><br><span class="line">Class c3 = Class.forName(&quot;[[Ljava.lang.String;&quot;);</span><br><span class="line">System.out.println(c3.getCanonicalName());</span><br></pre></td></tr></table></figure>
<p>来看一下输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">com.itwanger.s39.ReflectionDemo3</span><br><span class="line">double[]</span><br><span class="line">java.lang.String[][]</span><br></pre></td></tr></table></figure>
<p>类名 + .class ，只适合在编译前就知道操作的 Class。。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class c1 = ReflectionDemo3.class;</span><br><span class="line">System.out.println(c1.getCanonicalName());</span><br><span class="line">Class c2 = String.class;</span><br><span class="line">System.out.println(c2.getCanonicalName());</span><br><span class="line">Class c3 = int[][][].class;</span><br><span class="line">System.out.println(c3.getCanonicalName());</span><br></pre></td></tr></table></figure>
<p>来看一下输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">com.itwanger.s39.ReflectionDemo3</span><br><span class="line">java.lang.String</span><br><span class="line">int[][][]</span><br></pre></td></tr></table></figure>
<p><strong>2）创建反射类的对象</strong></p>
<p>通过反射来创建对象的方式有两种：</p>
<ul>
<li>用 Class 对象的 newInstance() 方法。</li>
<li>用 Constructor 对象的 newInstance() 方法。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class c1 = Writer.class;</span><br><span class="line">Writer writer = (Writer) c1.newInstance();</span><br><span class="line">Class c2 = Class.forName(&quot;com.itwanger.s39.Writer&quot;);</span><br><span class="line">Constructor constructor = c2.getConstructor();</span><br><span class="line">Object object = constructor.newInstance();</span><br></pre></td></tr></table></figure>
<p><strong>3）获取构造方法</strong></p>
<p>Class 对象提供了以下方法来获取构造方法 Constructor 对象：</p>
<ul>
<li>getConstructor() ：返回反射类的特定 public 构造方法，可以传递参数，参数为构造方法参数对应 Class 对象；缺省的时候返回默认构造方法。</li>
<li>getDeclaredConstructor() ：返回反射类的特定构造方法，不限定于 public 的。</li>
<li>getConstructors() ：返回类的所有 public 构造方法。</li>
<li>getDeclaredConstructors() ：返回类的所有构造方法，不限定于 public 的。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class c2 = Class.forName(&quot;com.itwanger.s39.Writer&quot;);</span><br><span class="line">Constructor constructor = c2.getConstructor();</span><br><span class="line">Constructor[] constructors1 = String.class.getDeclaredConstructors();</span><br><span class="line">for (Constructor c : constructors1) &#123;</span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4）获取字段</strong></p>
<p>大体上和获取构造方法类似，把关键字 Constructor 换成 Field 即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Method setNameMethod = clazz.getMethod(&quot;setName&quot;, String.class);</span><br><span class="line">Method getNameMethod = clazz.getMethod(&quot;getName&quot;);</span><br></pre></td></tr></table></figure>
<p><strong>5）获取方法</strong></p>
<p>大体上和获取构造方法类似，把关键字 Constructor 换成 Method 即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Method[] methods1 = System.class.getDeclaredMethods();</span><br><span class="line">Method[] methods2 = System.class.getMethods();</span><br></pre></td></tr></table></figure>
<p>“注意，三妹，如果你想反射访问私有字段和（构造）方法的话，需要使用 Constructor/Field/Method.setAccessible(true) 来绕开 Java 语言的访问限制。”我说。</p>
<p>“好的，二哥。还有资料可以参考吗？”三妹问。</p>
<p>“有的，有两篇文章写得非常不错，你在学习反射的时候可以作为参考。”我说。</p>
<p>第一篇：深入理解 Java 反射和动态代理</p>
<blockquote>
<p>链接：<a target="_blank" rel="noopener" href="https://dunwu.github.io/javacore/basics/java-reflection.html">https://dunwu.github.io/javacore/basics/java-reflection.html</a></p>
</blockquote>
<p>第二篇：大白话说Java反射：入门、使用、原理：</p>
<blockquote>
<p>链接：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/chanshuyi/p/head_first_of_reflection.html">https://www.cnblogs.com/chanshuyi/p/head_first_of_reflection.html</a></p>
</blockquote>
<p>这里简单总结下。</p>
<p>反射是 Java 中的一个强大特性，它允许在运行时检查和操作类、接口、字段和方法。反射是 Java 的核心组件，支持各种框架和库的实现，如 Spring、Hibernate 等。使用反射，可以在运行时动态地创建对象、调用方法和访问字段，而无需在编译时了解这些对象的具体实现。</p>
<p>反射的主要类位于 java.lang.reflect 包中，主要包括以下几个关键类：</p>
<ul>
<li>Class：代表一个类或接口，包含了类的结构信息（如名称、构造函数、方法、字段等）。通过 Class 对象，可以获取类的元数据并操作类的实例。</li>
<li>Constructor：代表类的构造方法，用于创建类的实例。</li>
<li>Method：代表类的方法，可以通过它调用类的实例方法。</li>
<li>Field：代表类的字段，可以获取或修改字段的值。</li>
<li>Modifier：包含方法、字段和类的访问修饰符（如 public、private 等）。</li>
</ul>
<p>使用反射时，需要注意以下几点：</p>
<ul>
<li>性能：反射操作通常比直接操作对象的方法和字段慢，因为涉及到额外的间接调用和动态解析。因此，在关注性能的场景中，慎用反射。</li>
<li>安全性：通过反射，可以访问和操作类的私有字段和方法，这可能导致安全问题。因此，使用反射时要确保代码的安全性。</li>
<li>维护性：反射使代码变得更加复杂，可能导致难以维护。在使用反射时要确保代码的可读性和可维护性。</li>
</ul>
<p>尽管反射存在上述问题，但在某些场景下（如框架开发、动态代理等），它仍然是非常有用的工具。</p>
<p>来一个完整的 demo 示例吧。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    public Person() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public Person(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    private void privateMethod() &#123;</span><br><span class="line">        System.out.println(&quot;私有方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ReflectionDemo &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException,</span><br><span class="line">            IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchFieldException &#123;</span><br><span class="line">        // 获取 Person 类的 Class 对象</span><br><span class="line">        Class&lt;?&gt; personClass = Class.forName(&quot;com.github.paicoding.forum.test.javabetter.importance.Person&quot;);</span><br><span class="line">        // 获取并打印类名</span><br><span class="line">        System.out.println(&quot;类名: &quot; + personClass.getName());</span><br><span class="line">        // 获取构造函数</span><br><span class="line">        Constructor&lt;?&gt; constructor = personClass.getConstructor(String.class, int.class);</span><br><span class="line">        // 使用构造函数创建 Person 对象实例</span><br><span class="line">        Object personInstance = constructor.newInstance(&quot;沉默王二&quot;, 30);</span><br><span class="line">        // 获取并调用 getName 方法</span><br><span class="line">        Method getNameMethod = personClass.getMethod(&quot;getName&quot;);</span><br><span class="line">        String name = (String) getNameMethod.invoke(personInstance);</span><br><span class="line">        System.out.println(&quot;名字: &quot; + name);</span><br><span class="line">        // 获取并调用 setAge 方法</span><br><span class="line">        Method setAgeMethod = personClass.getMethod(&quot;setAge&quot;, int.class);</span><br><span class="line">        setAgeMethod.invoke(personInstance, 35);</span><br><span class="line">        // 获取并访问 age 字段</span><br><span class="line">        Field ageField = personClass.getDeclaredField(&quot;age&quot;);</span><br><span class="line">        ageField.setAccessible(true);</span><br><span class="line">        int age = ageField.getInt(personInstance);</span><br><span class="line">        System.out.println(&quot;年纪: &quot; + age);</span><br><span class="line">        // 获取并调用私有方法</span><br><span class="line">        Method privateMethod = personClass.getDeclaredMethod(&quot;privateMethod&quot;);</span><br><span class="line">        privateMethod.setAccessible(true);</span><br><span class="line">        privateMethod.invoke(personInstance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们首先通过 Class.forName() 方法获取 Person 类的 Class 对象。接着，我们获取了 Person 类的构造方法、方法和字段，并使用这些反射对象来创建实例、调用方法和访问字段。注意，在访问私有方法和字段时，我们需要调用 setAccessible(true) 方法来允许访问。</p>
<p>“好了，三妹，关于反射，就先讲到这里吧。”</p>
<h1 id="12-Java并发编程"><a href="#12-Java并发编程" class="headerlink" title="12 Java并发编程"></a>12 Java并发编程</h1><p>众所周知，Java 并发是 Java 程序员必须懂但又很难懂的一块知识点。一般来说，很少有人敢说自己精通 Java 并发的，一是容易被面试官吊打，二是并发编程涉及到操作系统、内存、CPU 等计算机专业比较核心的内容，比较考验一个程序员的内功。</p>
<p>这里就顺带给你盘点一下 Java 并发到底该如何从入门到精通，请及时用鸡毛掸子把收藏夹里的灰清理一下。在阅读过程中，如果有所帮助，麻烦默默收藏和主动转发，算是对我码字的这份坚持的亿点点鼓励。</p>
<p><strong>一、为什么要学 Java 并发？ </strong></p>
<p>有句话不知道当讲不当讲，先讲了再说，就是“如果你只想 CURD，那么 Java 并发不学也罢！”但其实呢，大家都已经被教育的很有涵养了，工作中拧不拧螺丝不重要，重要的是面试一定要会造火箭，不然面试的机会都很难捞得到。</p>
<p>那作为 Java 体系中非常重要的一环，Java 并发自然是必须要掌握的，最起码也得会起个多线程吧？哈哈哈。高级点的，像平常开发中用到的 Tomcat 服务器、消息中间件、RPC 框架等等，它们的底层都涉及到了并发编程。</p>
<p>当然了，Java 并发涉及到东西实在是不少，包括操作系统的知识，Java 虚拟机的一些知识，Java 线程模型的知识，多线程相关的关键字，比如说 synchronized、volatile 等，还有锁的知识、JDK 提供的工具类等等，学起来还是非常容易令人头大的。</p>
<p>因此，我们需要一些高效的学习路线图，以及一些优质的学习资源，从而减少我们学习Java 并发编程所投入的时间和精力。</p>
<p><strong>二、Java 并发学习路线图 </strong></p>
<p>这是我最近整理的一张关于 Java 并发编程的思维导图，大的方向可以分为三个部分：线程基础、理论基础、工具类 JUC。</p>
<p><img src="\assets\note\image-20231013113116011.png" alt="image-20231013113116011"></p>
<p>线程基础部分包括：</p>
<ul>
<li>线程的创建方式</li>
<li>线程的状态切换</li>
<li>线程的基本操作</li>
<li>线程组和线程优先级</li>
</ul>
<p>理论基础包括：</p>
<ul>
<li>进程和线程的区别</li>
<li>多线程解决了什么问题，又带来了什么问题？</li>
<li>如何解决并发问题？包括 Java 内存模型，以及两个常见的关键字 volatile 和 synchronized</li>
</ul>
<p>工具类 JUC 包括：</p>
<ul>
<li>锁 Lock 系的 AQS、ReentrantLock、ReentrantReadWriteLock、Condition、LockSupport</li>
<li>并发容器系的 ConcurrentHashMap、ConcurrentLinkedQueue、CopyOnWriteArrayList、ThreadLocal、BlockingQueue</li>
<li>线程池系的 ThreadPoolExecutor、ScheduledThreadPoolExecutor</li>
<li>原子系的 AtomicInteger、AtomicIntegerArray、AtomicReference 等等</li>
<li>通信工具系的倒计时器 CountDownLatch、循环栅栏 CyclicBarrier、资源访问控制 Semaphore、数据交换 Exchanger、移相器Phaser</li>
<li>Fork/Join框架</li>
</ul>
<p>最后再来个经典的生产者消费者模式进行实践，整个 Java 并发体系就学得非常扎实了！</p>
<p><strong>三、硬核 Java 并发学习资料</strong></p>
<p><strong>1）Java进阶之路 </strong></p>
<p>学 Java，当然要找二哥的Java进阶之路，网址我贴下面了哈：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://tobebetterjavaer.com/home.html">https://tobebetterjavaer.com/home.html</a></p>
</blockquote>
<p>进去直接找 Java 核心里面的 Java 并发编程就对了。我按照前面的思维导图整理了 29 篇文章，全部都是硬核级别的，跟着学就对了。<br> 学Java，就认准二哥的Java进阶之路</p>
<p><img src="\assets\note\image-20231013115054038.png" alt="image-20231013115054038"></p>
<p><strong>2）视频 </strong> </p>
<p>懂的都懂，看视频到 B 站。黑马的《Java并发编程》评价还不错，300 多个小节，我觉得讲的比较好的有三部分：synchronized优化原理、AQS和线程池。</p>
<p><img src="\assets\note\image-20231013115239365.png" alt="image-20231013115239365"></p>
<blockquote>
<p>视频地址：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV16J411h7Rd">https://www.bilibili.com/video/BV16J411h7Rd</a></p>
</blockquote>
<p>还有尚硅谷宋红康老师讲的这个视频。</p>
<p><img src="\assets\note\image-20231013115301073.png" alt="image-20231013115301073"></p>
<blockquote>
<p>视频地址：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Kw411Z7dF/">https://www.bilibili.com/video/BV1Kw411Z7dF/</a></p>
</blockquote>
<p><strong>3）书籍 </strong></p>
<p>纸质书只推荐一本《Java 并发编程实战》，豆瓣评分 9.0。不过这本书确实有点老了，基本上是按照 Java 6 来讲解的，希望出版社能早点出 2.0 版。</p>
<p><img src="\assets\note\image-20231013115339024.png" alt="image-20231013115339024"></p>
<p>《Java 并发编程实战》这本书从总体上来看，分两条主线：</p>
<ul>
<li>介绍 Java 并发包的重要组件和原理</li>
<li>如何利用这些组件来保证线程安全</li>
</ul>
<p>到底该如何获得线程安全呢？背会并理解下面这段话：</p>
<blockquote>
<p>Writing thread-safe code is, at its core, about managing access to state, and in particular to shared, mutable state.</p>
</blockquote>
<p>如果发现不是很好懂，想从国内作者下手的话，可以尝试一下《Java并发编程的艺术》和《图解Java并发编程》这两本书，虽然豆瓣上评分一般，但对于构建 Java 并发的知识体系还是有很大帮助的。</p>
<p>之后，再去啃《Java 并发编程实战》就会发现没有以前那么费劲了，这本书之所以被誉为 Java 并发编程的圣经，确实可以看得出作者在并发编程方面有着丰富的经验。</p>
<p><strong>4）开源电子书 </strong></p>
<p>推荐 RedSpider社区的深入浅出 Java 多线程，比Java 并发编程实战更通俗易懂一些，因为里面穿插了很多精美的手绘图。</p>
<p><img src="\assets\note\image-20231013115454424.png" alt="image-20231013115454424"></p>
<blockquote>
<p>GitHub地址：<a target="_blank" rel="noopener" href="https://github.com/RedSpider1/concurrent">https://github.com/RedSpider1/concurrent</a></p>
</blockquote>
<p>再推荐一份 GitHub 上星标 3.6k+ 的 Java 并发知识点总结：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/CL0610/Java-concurrency">https://github.com/CL0610/Java-concurrency</a></p>
</blockquote>
<p>仓库里有一句话我非常喜欢，也分享给各位小伙伴：</p>
<p>努力的意义，就是，在以后的日子里，放眼望去全是自己喜欢的人和事！</p>
<p><strong>5）付费专栏 </strong></p>
<p>王宝令老师在极客时间上开了一门《Java 并发编程实战》的付费专栏，质量还是挺高的，喜欢的小伙伴可以去购买。</p>
<p><strong>四、优质八股文 </strong></p>
<p>这里给大家推荐两份 Java 并发编程方面的八股文，一份来自三分恶滴滴的面渣逆袭，一份来自小牛，先截图给大家看一下 Java 并发方面都有哪些高频的面试题。</p>
<p>为了方便大家的阅读和背诵，我已经将其整理到了二哥的小破站《Java进阶之路》上，面渣逆袭 Java 并发篇：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://tobebetterjavaer.com/sidebar/sanfene/javathread.html">https://tobebetterjavaer.com/sidebar/sanfene/javathread.html</a></p>
</blockquote>
<p>Java 并发编程八股文（背诵版）：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://tobebetterjavaer.com/baguwen/java-thread.html">https://tobebetterjavaer.com/baguwen/java-thread.html</a></p>
</blockquote>
<p>这两份八股文的质量都非常高，来看一下AQS了解多少小节下的内容，图文并茂，非常容易消化和吸收。’’</p>
<p>诚实点说，如果能把这两份八股文背会的话，简历上就真的敢写“精通”Java 并发了。</p>
<p><strong>五、Java 并发学习心得 </strong></p>
<p>Java 提供的并发组件，大致可以分为两类：</p>
<ul>
<li>从预防阶段下手，防止错误发生，比如说 synchronized 关键字</li>
<li>一旦发生错误能及时重试，比如说 CAS</li>
</ul>
<p>对于线程数量比较多的并发场景，采用预防的措施会比较合理，这样大部分线程就不会因为小概率时间的 CAS 重试浪费掉大量的 CPU 周期；在线程数量小的时候，CAS 的意义就比较大，因为预防措施带来的线程切换要比 CAS 等待的开销更大。</p>
<p>想要学好 Java 并发编程，就必须得对下图中提到的基础概念进行充分的理解。</p>
<p><img src="\assets\note\image-20231013120107723.png" alt="image-20231013120107723"></p>
<p>在我看来，并发编程主要是用来解决这两个痛点的：</p>
<ul>
<li>多个线程对同一变量造成的不一致问题；</li>
<li>为提高性能，计算机的很多执行单元都配备了缓存，那势必会影响并发编程的数据一致性。</li>
</ul>
<p>需要提醒一点的是，多线程并发虽然是用来解决性能问题的，但并不意味着所有情况下都需要开启多线程，有时候反而会适得其反，那如果不是特别要求，尽量不要过早开启多线程。</p>
<p>并发编程是 Java 体系当中相对难掌握的一块知识点，比较考验一名程序员的内功，其实并发编程最早的应用领域就是操作系统的实现。</p>
<p>如果你已经有一定的编程经验，建议先学一下《计算机组成原理》，对操作系统、内存、CPU 先进行一些大致的了解，然后再来学习 Java 并发编程，可能就会感觉舒服多了！</p>
<p>结合我多年的工作经验来看，并发编程可以抽象成三个核心问题：分工、同步和互斥。</p>
<p>1）分工</p>
<p>分工指的是如何高效地拆解任务并分配给线程，像并发编程领域的一些设计模式，比如说生产者与消费者就是用来进行分工的。</p>
<p>2）同步</p>
<p>同步指的是线程之间如何协作，一个线程执行完了一个任务，要通知另外一个线程开工。还拿生产者-消费者模型来说吧，当队列满的时候，生产者线程等待，当队列不满的时候，生产者线程需要被唤醒重新执行；当队列空的时候，消费者线程开始等待，不空的时候，消费者线程被重新唤醒。</p>
<p>3）互斥</p>
<p>互斥指的是保证同一时刻只有一个线程访问共享资源，是解决线程安全问题的杀手锏。</p>
<p>当多个线程同时访问一个共享变量的时候，很容易出现“线程安全”问题，因为结果可能是不确定的——导致出现这个问题的根源就是可见性、有序性和原子性——为了解决它们，Java 引入了内存模型的概念，可以在一定程度上缓解“线程安全”的问题，但要想完全解决“线程安全”问题，还得靠互斥。</p>
<p>互斥的核心技术就是锁，比如说 synchronized，还有各种 Lock。</p>
<p>锁可以解决线程安全的问题，但同时也就意味着程序的性能要受到影响。</p>
<p>因此，Java 提供了针对不同场景下的锁，比如说读写锁 ReadWriteLock，可以解决多线程同时读，但只有一个线程能写的问题；但 ReadWriteLock 也有自己的问题，就是如果有线程正在读，写线程需要等待度线程释放锁后才能获得写锁，也就是读的过程中不允许写，属于一种悲观的读锁。</p>
<p>为了进一步提升并发执行的效率，Java 8 引入了一个新的读写锁 StampedLock，与ReadWriteLock 相比，StampedLock的优势在于读的过程中也允许获取写锁后写入，但带来的问题就是可能读的数据不一致，需要一点额外的代码来判断读的过程中是否有写入，本质上是一种乐观的锁。</p>
<p>乐观锁的意思就是估计读的过程中大概率不会有写入，而悲观锁则是读的过程中拒绝有写入，两者的区别就在于性能上会有差异，乐观锁需要针对小概率事件进行多一步的检测，但性能也会有所提升；悲观锁更能保证“线程安全性”。</p>
<p>听我这么一说，是不是一下子就清晰多了！</p>
<h1 id="13-JVM（Java-虚拟机）"><a href="#13-JVM（Java-虚拟机）" class="headerlink" title="13 JVM（Java 虚拟机）"></a>13 JVM（Java 虚拟机）</h1><p>2020 年的时候，通读了一遍周志明老师的《深入理解 Java 虚拟机：JVM 高级特性与最佳实践》第三版，读完之后受益匪浅，这让我对 Java 虚拟机有了一个更完整的认识。毫无疑问，《深入理解 Java 虚拟机》是 JVM 书籍中最好的一本书了，国产技术书的天花板。</p>
<p><img src="\assets\note\image-20231013120627618.png" alt="image-20231013120627618"></p>
<p>在金三银四/金九银十的跳槽季中，很多小伙伴都会忍不住蠢蠢欲动，其中 JVM 更是面试中不可或缺的一部分，所以我花了几天的时间整理了一条 JVM 的学习路线，希望能帮助到大家。</p>
<p><strong>一、为什么要学习 JVM？ </strong></p>
<p>曾经我对 JVM 也是感到非常的头痛，完全搞不懂该怎么入门，只是听说《深入理解 Java 虚拟机》这本书很吊，但真读起来，却需要极大的耐心和定力，否则很快就会在读完第一章 JVM 的简史后放弃。</p>
<p>那首先，我们就要搞清楚，为什么要学习 JVM ？</p>
<p>第一，当然是面试要考，这一点毫无疑问，尤其是对于要参加校招的应届生来说，JVM 是绕不过去的，必须得学。</p>
<p>第二，如果你想成为公司不可或缺的顶梁柱，那 JVM 你得学，因为一般情况下，遇到的问题基本上 Google 下就能解决了，可一旦遇到 JVM 性能调优，就必须得有能查 OOM 的原因、能看懂字节码的老鸟出马了。</p>
<p>应用程序一旦上线，出问题是板上钉钉的事，除了数据库、网络、代码逻辑上的问题，剩下的就有内存溢出啊，频繁 GC 导致的性能瓶颈啊等棘手问题。</p>
<p>遇到这种问题，你就必须得能看懂 GC 日志，明白什么是老年代、永久代、元数据区等，这些都是 Java 虚拟机方面的知识。</p>
<p>明白了学习 JVM 的重要性，那我们就开搞吧！</p>
<p><strong>二、JVM 学习路线图 </strong></p>
<p>这是我最近整理的一张关于 JVM 的思维导图，大的方向可以分为三个部分：字节码与类的加载、内存与垃圾回收、性能监控和调优。</p>
<p><img src="\assets\note\image-20231013121027362.png" alt="image-20231013121027362"></p>
<p><img src="\assets\note\image-20231013121309134.png" alt="image-20231013121309134"></p>
<p>字节码与类的加载包括：</p>
<ul>
<li>类的加载机制（类的加载过程、类加载器、双亲委派模型）</li>
<li>字节码（类文件结构、字节码指令、字节码执行引擎、实战字节码）</li>
</ul>
<p>内存与垃圾回收包括：</p>
<ul>
<li>JVM 内存结构</li>
<li>垃圾回收算法</li>
<li>垃圾回收机制</li>
<li>垃圾收集器</li>
</ul>
<p>性能监控和调优包括：</p>
<ul>
<li>调优指标</li>
<li>调优对象</li>
<li>调优工具</li>
<li>JIT 优化</li>
</ul>
<p>有理论知识，有动手实战，基本上可以把 JVM 这块学的非常扎实了。</p>
<p><strong>四、学习 JVM 的一点小心得 </strong></p>
<p>和 C++ 相比，Java 的内存管理机制可以说是一大特色，Java 开发不再需要自己去写代码手动释放内存，甚至你想自己干，JVM 都不给你这个机会，虚拟机完全掌握了 Java 内存的控制权。</p>
<p>这看起来挺美好的，但并不意味着Java 开发就可以随意写代码，随意使用内存，从我多年的使用体验来看，内存溢出和内存泄露还是会时不时发生的，尤其是初学阶段，尤其在开启多线程的情况下。</p>
<p>一旦出现内存溢出或者内存泄露，排查问题还是挺困难的，所以知道逊尼基到底是怎么管理内存的就变得十分重要了。</p>
<p>JVM 的垃圾回收，其实就是收拾那些不再使用的 Java 对象，把他们曾经占用的内存重新释放出来。所以我们要搞清楚：</p>
<p>对象是如何创建的？对象是如何被访问的？到底哪些对象是废弃的？于是我们就需要搞清楚对象的生和死。</p>
<p>这些废弃了的对象到底放在哪？于是就需要了解JVM 的内存结构：方法区、堆、程序计数器、虚拟机栈和本地方法栈。</p>
<p>这些废弃了的对象会不会造成内存泄露（OOM，OutOfMemoryError）？于是我们就需要了解每个分区的 OOM。</p>
<p>这些废弃了对象什么时候被回收？于是我们就需要了解垃圾回收算法，比如说清除算法、复制算法、标记整理算法和分代收集算法。</p>
<p>知道了一个对象在内存中的生和死，我们还需要知道类是如何在内存中变成对象的？对象的方法是如何执行的？</p>
<p>于是我们开始学习 Java 虚拟机的执行过程，学习字节码文件（ .class 文件），学习类的加载机制，学习虚拟机栈的栈帧结构，学习方法的调用过程，学习字节码指令等等。</p>
<p>为了监控虚拟机和故障排查，我们需要学习常用的 JDK 命令行工具，掌握必要的线上问题排查方法；此外，还需要了解 JIT (Just In Time)并不是简单的将热点代码编译成机器码就收工的，它还会对代码的执行进行优化（方法内联和逃逸分析）。</p>
<p>JVM 相关的知识已经成为面试必考的科目了，但老实讲，JVM 相关的知识还真的不太好用在项目中，或者说不太好在项目中体现出来。</p>
<p>那这里给大家推荐一个实战项目，基于 Spring Boot 的在线 Java IDE，可以远程执行 Java 代码并将程序的运行结果反馈出来。涉及了 Java 类文件的结构、Java 类加载器和 Java 类的热替换等 JVM 相关的技术。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/TangBean/OnlineExecutor">https://github.com/TangBean/OnlineExecutor</a></p>
</blockquote>
<p>听我这么一说，是不是一下子就清晰多了！</p>
<p>Java 虚拟机虽然难学，但如果你能坚持学下去，内功自然而然就提升了一大截。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://htx-rest.github.io">鲸落</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://htx-rest.github.io/posts/7ec90956.html">https://htx-rest.github.io/posts/7ec90956.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://htx-rest.github.io" target="_blank">鲸落</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a><a class="post-meta__tags" href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">基础知识</a></div><div class="post_share"><div class="social-share" data-image="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/assets/weplay.png" target="_blank"><img class="post-qr-code-img" src="/assets/weplay.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/assets/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/assets/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/aeeccc.html" title="携程校招笔试编程真题及其解析（2023.3.7）"><img class="cover" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">携程校招笔试编程真题及其解析（2023.3.7）</div></div></a></div><div class="next-post pull-right"><a href="/posts/815405c2.html" title="科大讯飞校招笔试编程真题及其解析（2023.8.13）"><img class="cover" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">科大讯飞校招笔试编程真题及其解析（2023.8.13）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/82287452.html" title="华为校招笔试编程真题及其解析（2022.10.12）"><img class="cover" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2023-10-11</div><div class="title">华为校招笔试编程真题及其解析（2022.10.12）</div></div></a></div><div><a href="/posts/b477f365.html" title="华为校招笔试编程真题及其解析（2022.11.2）"><img class="cover" src="https://source.fomal.cc/img/default_cover_14.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2023-10-11</div><div class="title">华为校招笔试编程真题及其解析（2022.11.2）</div></div></a></div><div><a href="/posts/e1169d40.html" title="华为校招笔试编程真题及其解析（2022.8.30）"><img class="cover" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2023-10-11</div><div class="title">华为校招笔试编程真题及其解析（2022.8.30）</div></div></a></div><div><a href="/posts/c2bdd821.html" title="华为校招笔试编程真题及其解析（2022.9.21）"><img class="cover" src="https://source.fomal.cc/img/default_cover_14.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2023-10-11</div><div class="title">华为校招笔试编程真题及其解析（2022.9.21）</div></div></a></div><div><a href="/posts/68b410aa.html" title="华为校招笔试编程真题及其解析（2022.9.23）"><img class="cover" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2023-10-11</div><div class="title">华为校招笔试编程真题及其解析（2022.9.23）</div></div></a></div><div><a href="/posts/7d093ba9.html" title="小红书校招笔试编程真题（2023.4.23）"><img class="cover" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2023-09-24</div><div class="title">小红书校招笔试编程真题（2023.4.23）</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://tuchuang.voooe.cn/images/2023/01/02/avatar.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">鲸落</div><div class="author-info__description">随波不逐流</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">92</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">125</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/htx-rest"><i class="fab fa-github"></i><span>前往小窝</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="/assets/wenxin.jpg" target="_blank" title="微信"><i class="iconfont icon-weixin" style="color: #24292e;"></i></a><a class="social-icon" href="/assets/weixingongzhonghao.jpg" target="_blank" title="微信公众号"><i class="iconfont icon-weixingongzhonghao" style="color: #24292e;"></i></a><a class="social-icon" href="https://res.abeim.cn/api/qq/?qq=1656855152" target="_blank" title="QQ"><i class="iconfont icon-QQ" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:1656855152@qq.com" target="_blank" title="QQ邮箱"><i class="iconfont icon-youxiang" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">摸鱼中！！！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-Java%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80"><span class="toc-text">1 Java语法基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-Java%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C%E4%BF%9D%E7%95%99%E5%AD%97"><span class="toc-text">1.1 Java关键字和保留字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-Java%E6%B3%A8%E9%87%8A"><span class="toc-text">1.2 Java注释</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text"> ，因为 javadoc 会插入自己的标题，容易发生冲突。
3）文档注释中可以插入一些 @ 注解，比如说 @see 引用其他类， @version 版本号， @param 参数标识符， @author 作者标识符， @deprecated 已废弃标识符，等等。
05、注释规约 
1）类、字段、方法必须使用文档注释，不能使用单行注释和多行注释。因为注释文档在 IDE 编辑窗口中可以悬浮提示，提高编码效率。
比如说，在使用 String 类的时候，鼠标悬停在 String 上时可以得到以下提示。

2）所有的抽象方法(包括接口中的方法)必须要用 Javadoc 注释、除了返回值、参数、 异常说明外，还必须指出该方法做什么事情，实现什么功能。
3）所有的类都必须添加创建者和创建日期。
Intellij IDEA 中可以在「File and Code Templates」中设置。

语法如下所示：
12345&#x2F;*** 微信搜索「二哈进阶之路」* @author 二哈* @date ${DATE}*&#x2F;
设置好后，在新建一个类的时候就可以自动生成了。
12345678&#x2F;** * 微信搜索「二哈进阶之路」 * * @author 二哈 * @date 2020&#x2F;11&#x2F;16 *&#x2F;public class Test {}
4）所有的枚举类型字段必须要有注释，说明每个数据项的用途。
5）代码修改的同时，注释也要进行相应的修改。
“记住一点，注释是程序固有的一部分。”

第一、注释要能够准确反映设计思想和代码逻辑;
第二、注释要能够描述业务含 义，使别的程序员能够迅速了解到代码背后的信息。

完全没有注释的大段代码对于阅读者形同 天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路;注释也是给继任者看 的，使其能够快速接替自己的工作。
1.3 Java数据类型Java 中的数据类型可分为 2 种：
1）基本数据类型。
基本数据类型是 Java 语言操作数据的基础，包括 boolean、char、byte、short、int、long、float 和 double，共 8 种。
2）引用数据类型。
除了基本数据类型以外的类型，都是所谓的引用类型。常见的有数组（对，没错，数组是引用类型，后面我们会讲）、class（也就是类），以及接口（指向的是实现接口的类的对象）。来个思维导图，感受下。

变量可以分为局部变量、成员变量、静态变量。
当变量是局部变量的时候，必须得先初始化，否则编译器不允许你使用它。拿 int 来举例吧，看下图。

当变量是成员变量或者静态变量时，可以不进行初始化，它们会有一个默认值，仍然以 int 为例，来看代码：
123456789101112&#x2F;** * @author 微信搜「二哈进阶之路」 *&#x2F;public class LocalVar {    private int a;    static int b;    public static void main(String[] args) {        LocalVar lv &#x3D; new LocalVar();        System.out.println(lv.a);        System.out.println(b);    }}
来看输出结果：
1200
瞧见没，int 作为成员变量时或者静态变量时的默认值是 0。那不同的基本数据类型，是有不同的默认值和大小的，来个表格感受下。




数据类型
默认值
大小




boolean
false
1 比特


char
‘\u0000’
2 字节


byte
0
1 字节


short
0
2 字节


int
0
4 字节


long
0L
8 字节


float
0.0f
4 字节


double
0.0
8 字节




01、比特和字节 
比特币（Bitcoin）听说过吧？字节跳动（Byte Dance）听说过吧？这些名字当然不是乱起的，确实和比特、字节有关系。
1）bit（比特） 
比特作为信息技术的最基本存储单位，非常小，但大名鼎鼎的比特币就是以此命名的，它的简写为小写字母“b”。
大家都知道，计算机是以二进制存储数据的，二进制的一位，就是 1 比特，也就是说，比特要么为 0 要么为 1。
2）Byte（字节） 
通常来说，一个英文字符是一个字节，一个中文字符是两个字节。字节与比特的换算关系是：1 字节 &#x3D; 8 比特。
在往上的单位就是 KB，并不是 1000 字节，因为计算机只认识二进制，因此是 2 的 10 次方，也就是 1024个字节。（终于知道 1024 和程序员的关系了吧？狗头保命）

02、基本数据类型 
接下来，我们再来详细地了解一下 8 种基本数据类型。
1）布尔 
布尔（boolean）仅用于存储两个值：true 和 false，也就是真和假，通常用于条件的判断。代码示例：
12boolean hasMoney &#x3D; true;boolean hasGirlFriend &#x3D; false;
2）byte 
一个字节可以表示 2^8 &#x3D; 256 个不同的值。由于 byte 是有符号的，它的值可以是负数或正数，其取值范围是 -128 到 127（包括 -128 和 127）。
在网络传输、大文件读写时，为了节省空间，常用字节来作为数据的传输方式。代码示例：
123byte b; &#x2F;&#x2F; 声明一个 byte 类型变量b &#x3D; 10; &#x2F;&#x2F; 将值 10 赋给变量 bbyte c &#x3D; -100; &#x2F;&#x2F; 声明并初始化一个 byte 类型变量 c，赋值为 -100
3）short 
short 的取值范围在 -32,768 和 32,767 之间，包含 32,767。代码示例：
123short s; &#x2F;&#x2F; 声明一个 short 类型变量s &#x3D; 1000; &#x2F;&#x2F; 将值 1000 赋给变量 sshort t &#x3D; -2000; &#x2F;&#x2F; 声明并初始化一个 short 类型变量 t，赋值为 -2000
实际开发中，short 比较少用，整型用 int 就 OK。
4）int 
int 的取值范围在 -2,147,483,648（-2 ^ 31）和 2,147,483,647（2 ^ 31 -1）（含）之间。如果没有特殊需求，整型数据就用 int。代码示例：
123int i; &#x2F;&#x2F; 声明一个 int 类型变量i &#x3D; 1000000; &#x2F;&#x2F; 将值 1000000 赋给变量 iint j &#x3D; -2000000; &#x2F;&#x2F; 声明并初始化一个 int 类型变量 j，赋值为 -2000000
5）long 
long 的取值范围在 -9,223,372,036,854,775,808(-2^63) 和 9,223,372,036,854,775,807(2^63 -1)（含）之间。如果 int 存储不下，就用 long。代码示例：
123long l; &#x2F;&#x2F; 声明一个 long 类型变量l &#x3D; 100000000000L; &#x2F;&#x2F; 将值 100000000000L 赋给变量 l（注意要加上 L 后缀）long m &#x3D; -20000000000L; &#x2F;&#x2F; 声明并初始化一个 long 类型变量 m，赋值为 -20000000000L
为了和 int 作区分，long 型变量在声明的时候，末尾要带上大写的“L”。不用小写的“l”，是因为小写的“l”容易和数字“1”混淆。
6）float 
float 是单精度的浮点数（单精度浮点数的有效数字大约为 6 到 7 位），32 位（4 字节），遵循 IEEE 754（二进制浮点数算术标准），取值范围为 1.4E-45 到 3.4E+38。float 不适合用于精确的数值，比如说金额。
代码示例：
123float f; &#x2F;&#x2F; 声明一个 float 类型变量f &#x3D; 3.14159f; &#x2F;&#x2F; 将值 3.14159f 赋给变量 f（注意要加上 f 后缀）float g &#x3D; -2.71828f; &#x2F;&#x2F; 声明并初始化一个 float 类型变量 g，赋值为 -2.71828f
为了和 double 作区分，float 型变量在声明的时候，末尾要带上小写的“f”。不需要使用大写的“F”，是因为小写的“f”很容易辨别。
7）double 
double 是双精度浮点数（双精度浮点数的有效数字大约为 15 到 17 位），占 64 位（8 字节），也遵循 IEEE 754 标准，取值范围大约 ±4.9E-324 到 ±1.7976931348623157E308。double 同样不适合用于精确的数值，比如说金额。
代码示例：
1double myDouble &#x3D; 3.141592653589793;
在进行金融计算或需要精确小数计算的场景中，可以使用 BigDecimal 类来避免浮点数舍入误差。
BigDecimal 可以表示一个任意大小且精度完全准确的浮点数。

在实际开发中，如果不是特别大的金额（精确到 0.01 元，也就是一分钱），一般建议乘以 100 转成整型进行处理。

8）char 
char 用于表示 Unicode 字符，占 16 位（2 字节）的存储空间，取值范围为 0 到 65,535。
代码示例：
1char letterA &#x3D; &#39;A&#39;; &#x2F;&#x2F; 用英文的单引号包裹住。
注意，字符字面量应该用单引号（’’）包围，而不是双引号（””），因为双引号表示字符串字面量。
03、单精度和双精度 
单精度（single-precision）和双精度（double-precision）是指两种不同精度的浮点数表示方法。单精度是这样的格式，1 位符号，8 位指数，23 位小数。

单精度浮点数通常占用 32 位（4 字节）存储空间。数值范围大约是 ±1.4E-45 到 ±3.4028235E38，精度大约为 6 到 9 位有效数字。
双精度是这样的格式，1 位符号，11 位指数，52 为小数。

双精度浮点数通常占用 64 位（8 字节）存储空间，数值范围大约是 ±4.9E-324 到 ±1.7976931348623157E308，精度大约为 15 到 17 位有效数字。
计算精度取决于小数位（尾数）。小数位越多，则能表示的数越大，那么计算精度则越高。
一个数由若干位数字组成，其中影响测量精度的数字称作有效数字，也称有效数位。有效数字指科学计算中用以表示一个浮点数精度的那些数字。一般地，指一个用小数形式表示的浮点数中，从第一个非零的数字算起的所有数字。如 1.24 和 0.00124 的有效数字都有 3 位。
以下是确定有效数字的一些基本规则：

非零数字总是有效的。
位于两个非零数字之间的零是有效的。
对于小数，从左侧开始的第一个非零数字之前的零是无效的。
对于整数，从右侧开始的第一个非零数字之后的零是无效的。

下面是一些示例，说明如何确定有效数字：

1234：4 个有效数字（所有数字都是非零数字）
1002：4 个有效数字（零位于两个非零数字之间）
0.00234：3 个有效数字（从左侧开始的前两个零是无效的）
1200：2 个有效数字（从右侧开始的两个零是无效的）

04、int 和 char 类型互转 
int 和 char 之间比较特殊，可以互转，也会在以后的学习当中经常遇到。
1）可以通过强制类型转换将整型 int 转换为字符 char。
123int value_int &#x3D; 65;char value_char  &#x3D; (char) value_int;System.out.println(value_char);
输出 A (其 ASCII 值可以通过整数 65 来表示)。
2）可以使用 Character.forDigit() 方法将整型 int 转换为字符 char，参数 radix 为基数，十进制为 10，十六进制为 16。
1234int radix &#x3D; 10;int value_int &#x3D; 6;char value_char &#x3D; Character.forDigit(value_int , radix);System.out.println(value_char );
Character 为 char 的包装器类型。我们随后会讲。
3）可以使用 int 的包装器类型 Integer 的 toString() 方法+String 的 charAt() 方法转成 char。
123int value_int &#x3D; 1;char value_char &#x3D; Integer.toString(value_int).charAt(0);System.out.println(value_char );
4）char 转 int
当然了，如果只是简单的 char 转 int，直接赋值就可以了。
1int a &#x3D; &#39;a&#39;;
因为发生了自动类型转换，后面会细讲。
05、包装器类型 
包装器类型（Wrapper Types）是 Java 中的一种特殊类型，用于将基本数据类型（如 int、float、char 等）转换为对应的对象类型。

Java 提供了以下包装器类型，与基本数据类型一一对应：
Byte（对应 byte）
Short（对应 short）
Integer（对应 int）
Long（对应 long）
Float（对应 float）
Double（对应 double）
Character（对应 char）
Boolean（对应 boolean）

包装器类型允许我们使用基本数据类型提供的各种实用方法，并兼容需要对象类型的场景。例如，我们可以使用 Integer 类的 parseInt 方法将字符串转换为整数，或使用 Character 类的 isDigit 方法检查字符是否为数字，还有前面提到的 Character.forDigit() 方法。
下面是一个简单的示例，演示了如何使用包装器类型：
123456789101112131415&#x2F;&#x2F; 使用 Integer 包装器类型Integer integerValue &#x3D; new Integer(42);System.out.println(&quot;整数值: &quot; + integerValue);&#x2F;&#x2F; 将字符串转换为整数String numberString &#x3D; &quot;123&quot;;int parsedNumber &#x3D; Integer.parseInt(numberString);System.out.println(&quot;整数值: &quot; + parsedNumber);&#x2F;&#x2F; 使用 Character 包装器类型Character charValue &#x3D; new Character(&#39;A&#39;);System.out.println(&quot;字符: &quot; + charValue);&#x2F;&#x2F; 检查字符是否为数字char testChar &#x3D; &#39;9&#39;;if (Character.isDigit(testChar)) {System.out.println(&quot;字符是个数字.&quot;);}
上面的示例中，我们创建了一个 Integer 类型的对象 integerValue 并为其赋值 42。然后，我们将其值打印到控制台。
我们有一个包含数字的字符串 numberString。我们使用 Integer.parseInt() 方法将其转换为整数 parsedNumber。然后，我们将转换后的值打印到控制台。
我们有一个字符变量 testChar，并为其赋值字符 ‘9’。我们使用 Character.isDigit() 方法检查 testChar 是否为数字字符。如果是数字字符，我们将输出一条消息到控制台。
从 Java 5 开始，自动装箱（Autoboxing）和自动拆箱（Unboxing）机制允许我们在基本数据类型和包装器类型之间自动转换，无需显式地调用构造方法或转换方法。
12Integer integerValue &#x3D; 42; &#x2F;&#x2F; 自动装箱，等同于 new Integer(42)int primitiveValue &#x3D; integerValue; &#x2F;&#x2F; 自动拆箱，等同于 integerValue.intValue()
06、引用数据类型 
基本数据类型在作为成员变量和静态变量的时候有默认值，引用数据类型也有的（学完数组&amp;字符串，以及面向对象编程后会更加清楚，这里先简单过一下）。
String 是最典型的引用数据类型，所以我们就拿 String 类举例，看下面这段代码：
123456789101112&#x2F;** * @author 微信搜「二哈进阶之路」 *&#x2F;public class LocalRef {    private String a;    static String b;    public static void main(String[] args) {        LocalRef lv &#x3D; new LocalRef();        System.out.println(lv.a);        System.out.println(b);    }}
输出结果如下所示：
12nullnull
null 在 Java 中是一个很神奇的存在，在你以后的程序生涯中，见它的次数不会少，尤其是伴随着令人烦恼的“空指针异常”，也就是所谓的 NullPointerException 。
也就是说，引用数据类型的默认值为 null，包括数组和接口。
那你是不是很好奇，为什么数组和接口也是引用数据类型啊？
先来看数组：
12int [] arrays &#x3D; {1,2,3};System.out.println(arrays);
arrays 是一个 int 类型的数组，对吧？打印结果如下所示：
1[I@2d209079
[I 表示数组是 int 类型的，@ 后面是十六进制的 hashCode——这样的打印结果太“人性化”了，一般人表示看不懂！为什么会这样显示呢？查看一下 java.lang.Object 类的 toString() 方法就明白了。

数组虽然没有显式定义成一个类，但它的确是一个对象，继承了祖先类 Object 的所有方法。那为什么数组不单独定义一个类来表示呢？就像字符串 String 类那样呢？
一个合理的解释是 Java 将其隐藏了。假如真的存在一个 Array.java，我们也可以假想它真实的样子，它必须要定义一个容器来存放数组的元素，就像 String 类那样。
12345public final class String    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {    &#x2F;** The value is used for character storage. *&#x2F;    private final char value[];}
数组内部定义数组？没必要的！
再来看接口：
12List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();System.out.println(list);
List 是一个非常典型的接口：
1public interface List&lt;E&gt; extends Collection&lt;E&gt; {}
而 ArrayList 是 List 接口的一个实现：
123public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable{}
对于接口类型的引用变量来说，你没法直接 new 一个：

只能 new 一个实现它的类的对象——那自然接口也是引用数据类型了。
来看一下基本数据类型和引用数据类型之间最大的差别。
基本数据类型：

变量名指向具体的数值。
基本数据类型存储在栈上。

引用数据类型：

变量名指向的是存储对象的内存地址，在栈上。
内存地址指向的对象存储在堆上。

07、堆和栈 
堆是堆（heap），栈是栈（stack），如果看到“堆栈”的话，请不要怀疑自己，那是翻译的错，堆栈也是栈，反正我很不喜欢“堆栈”这种叫法，容易让新人掉坑里。
堆是在程序运行时在内存中申请的空间（可理解为动态的过程）；切记，不是在编译时；因此，Java 中的对象就放在这里，这样做的好处就是：

当需要一个对象时，只需要通过 new 关键字写一行代码即可，当执行这行代码时，会自动在内存的“堆”区分配空间——这样就很灵活。

栈，能够和处理器（CPU，也就是脑子）直接关联，因此访问速度更快。既然访问速度快，要好好利用啊！Java 就把对象的引用放在栈里。为什么呢？因为引用的使用频率高吗？
不是的，因为 Java 在编译程序时，必须明确的知道存储在栈里的东西的生命周期，否则就没法释放旧的内存来开辟新的内存空间存放引用——空间就那么大，前浪要把后浪拍死在沙滩上啊。
这么说就理解了吧？
用图来表示一下，左侧是栈，右侧是堆。

这里再补充一些额外的知识点，能看懂就继续吸收，看不懂可以先去学下一节，以后再来补，没关系的。学习就是这样，可以跳过，可以温故。
举个例子。
1String a &#x3D; new String(&quot;沉默&quot;)
这段代码会先在堆里创建一个 沉默的字符串对象，然后再把对象的引用 a 放到栈里面。这里面还会涉及到字符串常量池，后面会讲。
那么对于这样一段代码，有基本数据类型的变量，有引用类型的变量，堆和栈都是如何存储他们的呢？
123456public void test(){    int i &#x3D; 4;    int y &#x3D; 2;    Object o1 &#x3D; new Object();}
我来画个图表示下。

08、小结 
本文详细探讨了 Java 数据类型，包括比特与字节、基本数据类型、单精度与双精度、int 与 char 互转、包装器类型、引用数据类型以及堆与栈的内存模型。通过阅读本文，你将全面了解 Java 数据类型的概念与使用方法，为 Java 编程打下坚实基础。
1.4 Java数据类型转换数据类型转换的目的是确保在表达式求值时，不同类型的数据能够相互兼容。
01、自动类型转换 
自动类型转换（自动类型提升）是 Java 编译器在不需要显式转换的情况下，将一种基本数据类型自动转换为另一种基本数据类型的过程。这种转换通常发生在表达式求值期间，当不同类型的数据需要相互兼容时。自动类型转换遵循以下规则：

如果任何操作数是 double 类型，其他操作数将被转换为 double 类型。
否则，如果任何操作数是 float 类型，其他操作数将被转换为 float 类型。
否则，如果任何操作数是 long 类型，其他操作数将被转换为 long 类型。
否则，所有操作数将被转换为 int 类型。

需要注意的是，自动类型转换只发生在兼容类型之间。例如，从较小的数据类型（如 int）到较大的数据类型（如 long 或 double）的转换是安全的，因为较大的数据类型可以容纳较小数据类型的所有可能值。
12byte -&gt; short -&gt; int -&gt; long -&gt; float -&gt; doublechar -&gt; int -&gt; long -&gt; float -&gt; double
下面是一个简单的示例，演示了自动类型转换：
12345int intValue &#x3D; 5;double doubleValue &#x3D; 2.5;&#x2F;&#x2F; 自动类型转换：intValue 被转换为 double 类型double result &#x3D; intValue * doubleValue;System.out.println(&quot;结果: &quot; + result); &#x2F;&#x2F; 输出：结果: 12.5
在这个示例中，我们有一个 int 类型的变量 intValue 和一个 double 类型的变量 doubleValue。当我们将它们相乘时，根据自动类型转换的规则，intValue 将被转换为 double 类型，以便将两个 double 类型的操作数相乘。最终结果将是一个 double 类型的值：12.5。
再来举个例子，顾客到超市购物，购买牙膏 2 盒，面巾纸 4 盒。其中牙膏的价格是 10.9 元，面巾纸的价格是 5.8 元，求商品总价格。实现代码如下：
123456float price1 &#x3D; 10.9f; &#x2F;&#x2F; 定义牙膏的价格，单精度浮点型floatdouble price2 &#x3D; 5.8; &#x2F;&#x2F; 定义面巾纸的价格，双精度浮点型doubleint num1 &#x3D; 2; &#x2F;&#x2F; 定义牙膏的数量，整型 intint num2 &#x3D; 4; &#x2F;&#x2F; 定义面巾纸的数量double res &#x3D; price1 * num1 + price2 * num2; &#x2F;&#x2F; 计算总价System.out.println(&quot;一共付给收银员&quot; + res + &quot;元&quot;); &#x2F;&#x2F; 输出总价
上述代码中首先定义了一个 float 类型的变量存储牙膏的价格，然后定义了一个 double 类型的变量存储面巾纸的价格，再定义两个 int 类型的变量存储物品的数量，最后进行了乘运算以及和运算之后，将结果储存在一个 double 类型的变量中进行输出。
1一共付给收银员44.99999923706055元
从执行结果看出，float、int 和 double 三种数据类型参与运算，最后输出的结果为 double 类型的数据。这种转换一般称为“表达式中类型的自动提升”。
自动类型提升有好处，但它也会引起令人疑惑的编译错误。例如，下面看起来正确的程序却会引起问题：
12byte b &#x3D; 50;b &#x3D; b * 2; &#x2F;&#x2F; Type mismatch: cannot convert from int to byte
如上所示，第二行会报“类型不匹配：无法从int转换为byte”错误。
该程序试图将一个完全合法的 byte 型的值 50*2 存储给一个 byte 型的变量。但是当表达式求值的时候，操作数被自动的提升为 int 型，计算结果也被提升为 int 型。这样表达式的结果现在是 int 型，不强制转换它就不能被赋为 byte 型。
所以应该使用一个显示的强制类型转换，例如：
12byte b &#x3D; 50;b &#x3D; (byte)(b*2);
这样就能产生正确的值 100。
注意：char 类型比较特殊，char 自动转换成 int、long、float 和 double，但 byte 和 short 不能自动转换为 char，而且 char 也不能自动转换为 byte 或 short。
02、强制类型转换 
强制类型转换是 Java 中将一种数据类型显式转换为另一种数据类型的过程。与自动类型转换不同，强制类型转换需要程序员显式地指定要执行的转换。强制类型转换在以下情况中可能需要：

将较大的数据类型转换为较小的数据类型。
将浮点数转换为整数。
将字符类型转换为数值类型。

需要注意的是，强制类型转换可能会导致数据丢失或精度降低，因为目标类型可能无法容纳原始类型的所有可能值。因此，在进行强制类型转换时，需要确保转换后的值仍然在目标类型的范围内。
1double -&gt; float -&gt; long -&gt; int -&gt; char -&gt; short -&gt; byte
以下是一个简单的示例，演示了强制类型转换：
1234double doubleValue &#x3D; 42.8;&#x2F;&#x2F; 强制类型转换：将 double 类型转换为 int 类型int intValue &#x3D; (int) doubleValue;System.out.println(&quot;整数值: &quot; + intValue); &#x2F;&#x2F; 输出：整数值: 42
在这个示例中，我们有一个 double 类型的变量 doubleValue。我们希望将其转换为 int 类型的变量 intValue。为此，我们使用强制类型转换语法，即在要转换的变量之前加上目标类型的括号（如 (int)）。
需要注意的是，将 doubleValue 转换为 int 类型时，小数部分将被截断。因此，输出结果将是：Integer value: 42。在这种情况下，精度丢失是可以接受的，但在其他情况下，我们可能需要更加小心地处理类型转换以避免数据丢失。
顾客到超市购物，购买牙膏 2 盒，面巾纸 4 盒。其中牙膏的价格是 10.9 元，面巾纸的价格是 5.8 元，求商品总价格，在计算总价时采用 int 类型的数据进行存储。实现代码如下：
123456float price1 &#x3D; 10.9f;double price2 &#x3D; 5.8;int num1 &#x3D; 2;int num2 &#x3D; 4;int res2 &#x3D; (int) (price1 * num1 + price2 * num2);System.out.println(&quot;一共付给收银员&quot; + res2 + &quot;元&quot;);
在上述实例中，有 double 类型、float 类型和 int 类型的数据参与运算，其运算结果默认为 double 类型，题目要求的结果为 int 类型，因为 int 类型的取值范围要小于 double 类型的取值范围，所以需要进行强制类型转换。
1一共付给收银员44元
1.5 Java基本数据类型缓存池“考你一个问题哈： new Integer(18) 与 Integer.valueOf(18) 的区别是什么？”
new Integer(18) 每次都会新建一个对象;
Integer.valueOf(18) 会使⽤用缓存池中的对象，多次调用只会取同⼀一个对象的引用。
来看下面这段代码：
123456789Integer x &#x3D; new Integer(18);Integer y &#x3D; new Integer(18);System.out.println(x &#x3D;&#x3D; y);Integer z &#x3D; Integer.valueOf(18);Integer k &#x3D; Integer.valueOf(18);System.out.println(z &#x3D;&#x3D; k);Integer m &#x3D; Integer.valueOf(300);Integer p &#x3D; Integer.valueOf(300);System.out.println(m &#x3D;&#x3D; p);
来看一下输出结果吧：
123falsetruefalse
“第一个 false，我知道原因，因为 new 出来的是不同的对象，地址不同。”“第二个和第三个我认为都应该是 true 啊，为什么第三个会输出 false 呢？这个我理解不了。”
“其实原因也很简单。”我胸有成竹地说。
基本数据类型的包装类除了 Float 和 Double 之外，其他六个包装器类（Byte、Short、Integer、Long、Character、Boolean）都有常量缓存池。

Byte：-128~127，也就是所有的 byte 值
Short：-128~127
Long：-128~127
Character：\u0000 - \u007F
Boolean：true 和 false

拿 Integer 来举例子，Integer 类内部中内置了 256 个 Integer 类型的缓存数据，当使用的数据范围在 -128~127 之间时，会直接返回常量池中数据的引用，而不是创建对象，超过这个范围时会创建新的对象。
18 在 -128~127 之间，300 不在。
来看一下 valueOf 方法的源码吧。
12345public static Integer valueOf(int i) {    if (i &gt;&#x3D;IntegerCache.low &amp;&amp; i &lt;&#x3D;IntegerCache.high)        return IntegerCache.cache[i + (-IntegerCache.low)];    return new Integer(i);}
“哦，原来是因为 Integer.IntegerCache 这个内部类的原因啊！”
“是滴。来看一下 IntegerCache 这个静态内部类的源码吧。”
1234567891011121314151617181920212223242526272829private static class IntegerCache {    static final int low &#x3D; -128;    static final int high;    static final Integer cache[];    static {        &#x2F;&#x2F; high value may be configured by property        int h &#x3D; 127;        String integerCacheHighPropValue &#x3D;                sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);        if (integerCacheHighPropValue !&#x3D; null) {            try {                int i &#x3D; parseInt(integerCacheHighPropValue);                i &#x3D; Math.max(i, 127);                &#x2F;&#x2F; Maximum array size is Integer.MAX_VALUE                h &#x3D; Math.min(i, Integer.MAX_VALUE - (-low) -1);            } catch( NumberFormatException nfe) {                &#x2F;&#x2F; If the property cannot be parsed into an int, ignore it.            }        }        high &#x3D; h;        cache &#x3D; new Integer[(high - low) + 1];        int j &#x3D; low;        for(int k &#x3D; 0; k &lt; cache.length; k++)            cache[k] &#x3D; new Integer(j++);        &#x2F;&#x2F; range [-128, 127] must be interned (JLS7 5.1.7)        assert Integer.IntegerCache.high &gt;&#x3D; 127;    }    private IntegerCache() {}}
详细解释下：当我们通过 Integer.valueOf() 方法获取整数对象时，会先检查该整数是否在 IntegerCache 中，如果在，则返回缓存中的对象，否则创建一个新的对象并缓存起来。
需要注意的是，如果使用 new Integer() 创建对象，即使值在 -128 到 127 范围内，也不会被缓存，每次都会创建新的对象。因此，推荐使用 Integer.valueOf() 方法获取整数对象。
学习 static 关键字的时候，会详细解释静态代码块，你暂时先记住，静态代码块通常用来初始化一些静态变量，它会优先于 main() 方法执行。
在静态代码块中，low 为 -128，也就是缓存池的最小值；high 默认为 127，也就是缓存池的最大值，共计 256 个。
可以在 JVM 启动的时候，通过 -XX:AutoBoxCacheMax&#x3D;NNN来设置缓存池的大小，当然了，不能无限大，最大到 Integer.MAX_VALUES - 129
之后，初始化 cache 数组的大小，然后遍历填充，下标从 0 开始。
“这段代码不难理解，难理解的是 assert Integer.IntegerCache.high &gt;&#x3D; 127; ，这行代码是干嘛的呀？”
assert 是 Java 中的一个关键字，寓意是断言，为了方便调试程序，并不是发布程序的组成部分。
默认情况下，断言是关闭的，可以在命令行运行 Java 程序的时候加上 -ea 参数打开断言。
来看这段代码。
123456public class AssertTest {    public static void main(String[] args) {        int high &#x3D; 126;        assert high &gt;&#x3D; 127;    }}
假设手动设置的缓存池大小为 126，显然不太符合缓存池的预期值 127，结果会输出什么呢？直接在 Intellij IDEA 中打开命令行终端，进入 classes 文件，执行：
1&#x2F;usr&#x2F;libexec&#x2F;java_home -v 1.8 --exec java -ea com.itwanger.s51.AssertTest
我用的 macOS 环境，装了好多个版本的 JDK，该命令可以切换到 JDK 8
也可以不指定 Java 版本直接执行（加上 -ea 参数）：
1java -ea com.itwanger.s51.AssertTest
“呀，报错了呀。”
12Exception in thread &quot;main&quot; java.lang.AssertionError        at com.itwanger.s51.AssertTest.main(AssertTest.java:9)
“是滴，因为 126 小于 127。”
“原来 assert 是这样用的啊，我明白了。”
在 Java 中，针对一些基本数据类型（如 Integer、Long、Boolean 等），Java 会在程序启动时创建一些常用的对象并缓存在内存中，以提高程序的性能和节省内存开销。这些常用对象被缓存在一个固定的范围内，超出这个范围的值会被重新创建新的对象。
使用数据类型缓存池可以有效提高程序的性能和节省内存开销，但需要注意的是，在特定的业务场景下，缓存池可能会带来一些问题，例如缓存池中的对象被不同的线程同时修改，导致数据错误等问题。因此，在实际开发中，需要根据具体的业务需求来决定是否使用数据类型缓存池。
1.6 Java运算符运算符在 Java 中占据着重要的位置，对程序的执行有着很大的帮助。除了常见的加减乘除，还有许多其他类型的运算符，来看下面这张思维导图。”

01、算术运算符 
算术运算符除了最常见的加减乘除，还有一个取余的运算符，用于得到除法运算后的余数，来串代码感受下。
12345678910111213int a &#x3D; 10;int b &#x3D; 5;System.out.println(a + b);&#x2F;&#x2F;15System.out.println(a - b);&#x2F;&#x2F;5System.out.println(a * b);&#x2F;&#x2F;50System.out.println(a &#x2F; b);&#x2F;&#x2F;2System.out.println(a % b);&#x2F;&#x2F;0b &#x3D; 3;System.out.println(a + b);&#x2F;&#x2F;13System.out.println(a - b);&#x2F;&#x2F;7System.out.println(a * b);&#x2F;&#x2F;30System.out.println(a &#x2F; b);&#x2F;&#x2F;3System.out.println(a % b);&#x2F;&#x2F;1
对于初学者来说，加法（+）、减法（-）、乘法（*）很好理解，但除法（&#x2F;）和取余（%）会有一点点疑惑。在以往的认知里，10&#x2F;3 是除不尽的，结果应该是 3.333333…，而不应该是 3。相应的，余数也不应该是 1。这是为什么呢？
因为数字在程序中可以分为两种，一种是整型，一种是浮点型（不清楚的同学可以回头看看数据类型那篇），整型和整型的运算结果就是整型，不会出现浮点型。否则，就会出现浮点型。
1234567int a &#x3D; 10;float c &#x3D; 3.0f;double d &#x3D; 3.0;System.out.println(a &#x2F; c); &#x2F;&#x2F; 3.3333333System.out.println(a &#x2F; d); &#x2F;&#x2F; 3.3333333333333335System.out.println(a % c); &#x2F;&#x2F; 1.0System.out.println(a % d); &#x2F;&#x2F; 1.0
需要注意的是，当浮点数除以 0 的时候，结果为 Infinity 或者 NaN。
12System.out.println(10.0 &#x2F; 0.0); &#x2F;&#x2F; InfinitySystem.out.println(0.0 &#x2F; 0.0); &#x2F;&#x2F; NaN
Infinity 的中文意思是无穷大，NaN 的中文意思是这不是一个数字（Not a Number）。
当整数除以 0 的时候（ 10 &#x2F; 0 ），会抛出异常：
12Exception in thread &quot;main&quot; java.lang.ArithmeticException: &#x2F; by zero    at com.itwanger.eleven.ArithmeticOperator.main(ArithmeticOperator.java:32)
所以整数在进行除法运算时，需要先判断除数是否为 0，以免程序抛出异常。
算术运算符中还有两种特殊的运算符，自增运算符（++）和自减运算符（—），它们也叫做一元运算符，只有一个操作数。
12345int x &#x3D; 10;System.out.println(x++);&#x2F;&#x2F;10 (11)  System.out.println(++x);&#x2F;&#x2F;12  System.out.println(x--);&#x2F;&#x2F;12 (11)  System.out.println(--x);&#x2F;&#x2F;10 
一元运算符可以放在数字的前面或者后面，放在前面叫前自增（前自减），放在后面叫后自增（后自减）。
前自增和后自增是有区别的，拿 int y &#x3D; ++x 这个表达式来说（x &#x3D; 10），它可以拆分为 x &#x3D; x+1 &#x3D; 11; y &#x3D; x &#x3D; 11 ，所以表达式的结果为 x &#x3D; 11, y &#x3D; 11 。拿 int y &#x3D; x++ 这个表达式来说（x &#x3D; 10），它可以拆分为 y &#x3D; x &#x3D; 10; x &#x3D; x+1 &#x3D; 11 ，所以表达式的结果为 x &#x3D; 11, y &#x3D; 10 。
123456int x &#x3D; 10;int y &#x3D; ++x;System.out.println(y + &quot; &quot; + x);&#x2F;&#x2F; 11 11x &#x3D; 10;y &#x3D; x++;System.out.println(y + &quot; &quot; + x);&#x2F;&#x2F; 10 11
对于前自减和后自减来说，你可以自己试一把。
02、关系运算符 
关系运算符用来比较两个操作数，返回结果为 true 或者 false。

来看示例：
1234567int a &#x3D; 10, b &#x3D; 20;System.out.println(a &#x3D;&#x3D; b); &#x2F;&#x2F; falseSystem.out.println(a !&#x3D; b); &#x2F;&#x2F; trueSystem.out.println(a &gt; b); &#x2F;&#x2F; falseSystem.out.println(a &lt; b); &#x2F;&#x2F; trueSystem.out.println(a &gt;&#x3D; b); &#x2F;&#x2F; falseSystem.out.println(a &lt;&#x3D; b); &#x2F;&#x2F; true
03、位运算符 
在学习位运算符之前，需要先学习一下二进制，因为位运算符操作的不是整型数值（int、long、short、char、byte）本身，而是整型数值对应的二进制。
12System.out.println(Integer.toBinaryString(60)); &#x2F;&#x2F; 111100System.out.println(Integer.toBinaryString(13)); &#x2F;&#x2F; 1101
从程序的输出结果可以看得出来，60 的二进制是 0011 1100（用 0 补到 8 位），13 的二进制是 0000 1101。
PS：现代的二进制记数系统由戈特弗里德·威廉·莱布尼茨于 1679 年设计。莱布尼茨是德意志哲学家、数学家，历史上少见的通才。

来看示例：
1234567891011121314151617int a &#x3D; 60, b &#x3D; 13;System.out.println(&quot;a 的二进制：&quot; + Integer.toBinaryString(a)); &#x2F;&#x2F; 111100System.out.println(&quot;b 的二进制：&quot; + Integer.toBinaryString(b)); &#x2F;&#x2F; 1101int c &#x3D; a &amp; b;System.out.println(&quot;a &amp; b：&quot; + c + &quot;，二进制是：&quot; + Integer.toBinaryString(c));c &#x3D; a | b;System.out.println(&quot;a | b：&quot; + c + &quot;，二进制是：&quot; + Integer.toBinaryString(c));c &#x3D; a ^ b;System.out.println(&quot;a ^ b：&quot; + c + &quot;，二进制是：&quot; + Integer.toBinaryString(c));c &#x3D; ~a;System.out.println(&quot;~a：&quot; + c + &quot;，二进制是：&quot; + Integer.toBinaryString(c));c &#x3D; a &lt;&lt; 2;System.out.println(&quot;a &lt;&lt; 2：&quot; + c + &quot;，二进制是：&quot; + Integer.toBinaryString(c));c &#x3D; a &gt;&gt; 2;System.out.println(&quot;a &gt;&gt; 2：&quot; + c + &quot;，二进制是：&quot; + Integer.toBinaryString(c));c &#x3D; a &gt;&gt;&gt; 2;System.out.println(&quot;a &gt;&gt;&gt; 2：&quot; + c + &quot;，二进制是：&quot; + Integer.toBinaryString(c));
对于初学者来说，位运算符无法从直观上去计算出结果，不像加减乘除那样。因为我们日常接触的都是十进制，位运算的时候需要先转成二进制，然后再计算出结果。
鉴于此，初学者在写代码的时候其实很少会用到位运算。对于编程高手来说，为了提高程序的性能，会在一些地方使用位运算。比如说，HashMap 在计算哈希值的时候：
1234static final int hash(Object key) {    int h;    return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);}
如果对位运算一点都不懂的话，遇到这样的源码就很吃力。所以说，虽然位运算用的少，但还是要懂。
1）按位左移运算符：
1234System.out.println(10&lt;&lt;2);&#x2F;&#x2F;10*2^2&#x3D;10*4&#x3D;40  System.out.println(10&lt;&lt;3);&#x2F;&#x2F;10*2^3&#x3D;10*8&#x3D;80  System.out.println(20&lt;&lt;2);&#x2F;&#x2F;20*2^2&#x3D;20*4&#x3D;80  System.out.println(15&lt;&lt;4);&#x2F;&#x2F;15*2^4&#x3D;15*16&#x3D;240 
10&lt;&lt;2 等于 10 乘以 2 的 2 次方； 10&lt;&lt;3 等于 10 乘以 2 的 3 次方。
2）按位右移运算符：
123System.out.println(10&gt;&gt;2);&#x2F;&#x2F;10&#x2F;2^2&#x3D;10&#x2F;4&#x3D;2System.out.println(20&gt;&gt;2);&#x2F;&#x2F;20&#x2F;2^2&#x3D;20&#x2F;4&#x3D;5System.out.println(20&gt;&gt;3);&#x2F;&#x2F;20&#x2F;2^3&#x3D;20&#x2F;8&#x3D;2
10&gt;&gt;2 等于 10 除以 2 的 2 次方； 20&gt;&gt;2 等于 20 除以 2 的 2 次方。
04、逻辑运算符 
逻辑与运算符（&amp;&amp;）：多个条件中只要有一个为 false 结果就为 false。
逻辑或运算符（||）：多个条件只要有一个为 true 结果就为 true。
12345int a&#x3D;10;int b&#x3D;5;int c&#x3D;20;System.out.println(a&lt;b&amp;&amp;a&lt;c);&#x2F;&#x2F;false &amp;&amp; true &#x3D; falseSystem.out.println(a&gt;b||a&lt;c);&#x2F;&#x2F;true || true &#x3D; true
逻辑非运算符（!）：用来反转条件的结果，如果条件为 true，则逻辑非运算符将得到 false。
单逻辑与运算符（&amp;）：很少用，因为不管第一个条件为 true 还是 false，依然会检查第二个。
单逻辑或运算符（|）：也会检查第二个条件。
也就是说，&amp; 和 | 性能不如 &amp;&amp; 和 ||，但用法一样：
12345int a&#x3D;10;int b&#x3D;5;int c&#x3D;20;System.out.println(a&lt;b&amp;a&lt;c);&#x2F;&#x2F;false &amp; true &#x3D; falseSystem.out.println(a&gt;b|a&lt;c);&#x2F;&#x2F;true | true &#x3D; true  
05、赋值运算符 
赋值操作符恐怕是 Java 中使用最频繁的操作符了，它就是把操作符右侧的值赋值给左侧的变量。来看示例：
123456int a&#x3D;10;int b&#x3D;20;a+&#x3D;4;&#x2F;&#x2F;a&#x3D;a+4 (a&#x3D;10+4)  b-&#x3D;4;&#x2F;&#x2F;b&#x3D;b-4 (b&#x3D;20-4)  System.out.println(a);System.out.println(b);
不过在进行数值的赋值时，需要小点心，比如说下面这种情况：

编译器之所以提示错误，是因为 &#x3D; 右侧的算术表达式默认为 int 类型，左侧是 short 类型的时候需要进行强转。
12345short a &#x3D; 10;short b &#x3D; 10;&#x2F;&#x2F;a+&#x3D;b;&#x2F;&#x2F;a&#x3D;a+b internally so finea &#x3D; (short)(a + b);System.out.println(a);
除此之外，还会有边界问题，比如说，两个非常大的 int 相乘，结果可能就超出了 int 的范围：
1234int a &#x3D; Integer.MAX_VALUE;int b &#x3D; 10000;int c &#x3D; a * b;System.out.println(c); &#x2F;&#x2F; -10000
程序输出的结果为 -10000，这个答案很明显不是我们想要的结果，虽然可以通过右侧表达式强转 long 的方法解决：
1234int a &#x3D; Integer.MAX_VALUE;int b &#x3D; 10000;long c &#x3D; (long)a * b;System.out.println(c); &#x2F;&#x2F; 21474836470000
但尽量不要这样做，结果非常大的时候，尽量提前使用相应的类型进行赋值。
1234long a &#x3D; Integer.MAX_VALUE - 1;long b &#x3D; 10000;long c &#x3D; a * b;System.out.println(c); &#x2F;&#x2F; 21474836460000
06、三元运算符 
三元运算符用于替代 if-else，可以使用一行代码完成条件判断的要求。来看示例：
1234int a&#x3D;2;int b&#x3D;5;int min&#x3D;(a&lt;b)?a:b;System.out.println(min);
如果 ? 前面的条件为 true，则结果为 : 前的值，否则为 : 后的值。
07、小结 
本文全面介绍了Java运算符，包括算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符等。通过阅读本文，您将了解到Java运算符的分类、用法和优先级，以及如何在实际开发中灵活运用各类运算符提高编程效率。
1.7 Java流程控制语句“流程控制语句都有哪些呢？”
“比如说 if-else、switch、for、while、do-while、return、break、continue 等等，接下来，我们一个个来了解下。”
01、if-else 相关

1）if 语句 
if 语句的格式如下：
123if(布尔表达式){  &#x2F;&#x2F; 如果条件为 true，则执行这块代码}
画个流程图表示一下：

来写个示例：
1234int age &#x3D; 20;if (age &lt; 30) {    System.out.println(&quot;青春年华&quot;);}
输出：
1青春年华
2）if-else 语句 
if-else 语句的格式如下:
12345if(布尔表达式){  &#x2F;&#x2F; 条件为 true 时执行的代码块}else{  &#x2F;&#x2F; 条件为 false  时执行的代码块} 
画个流程图表示一下：

来写个示例：
123456int age &#x3D; 31;if (age &lt; 30) {    System.out.println(&quot;青春年华&quot;);} else {    System.out.println(&quot;而立之年&quot;);}
输出：
1而立之年
除了这个例子之外，还有一个判断闰年（被 4 整除但不能被 100 整除或者被 400 整除）的例子：
123456int year &#x3D; 2020;if (((year % 4 &#x3D;&#x3D; 0) &amp;&amp; (year % 100 !&#x3D; 0)) || (year % 400 &#x3D;&#x3D; 0)) {    System.out.println(&quot;闰年&quot;);} else {    System.out.println(&quot;普通年份&quot;);}
输出：
1闰年
如果执行语句比较简单的话，可以使用三元运算符来代替 if-else 语句，如果条件为 true，返回 ? 后面 : 前面的值；如果条件为 false，返回 : 后面的值。
123int num &#x3D; 13;String result &#x3D; (num % 2 &#x3D;&#x3D; 0) ? &quot;偶数&quot; : &quot;奇数&quot;;System.out.println(result);
输出：
1奇数
3）if-else-if 语句 
if-else-if 语句的格式如下：
123456789101112if(条件1){  &#x2F;&#x2F; 条件1 为 true 时执行的代码}else if(条件2){  &#x2F;&#x2F; 条件2 为 true 时执行的代码}  else if(条件3){  &#x2F;&#x2F; 条件3 为 true 时执行的代码}  ...  else{  &#x2F;&#x2F; 以上条件均为 false 时执行的代码} 
画个流程图表示一下：

来写个示例：
12345678910int age &#x3D; 31;if (age &lt; 30) {    System.out.println(&quot;青春年华&quot;);} else if (age &gt;&#x3D; 30 &amp;&amp; age &lt; 40 ) {    System.out.println(&quot;而立之年&quot;);} else if (age &gt;&#x3D; 40 &amp;&amp; age &lt; 50 ) {    System.out.println(&quot;不惑之年&quot;);} else {    System.out.println(&quot;知天命&quot;);}
输出：
1而立之年
4）if 嵌套语句 
if 嵌套语句的格式如下：
123456if(外侧条件){         &#x2F;&#x2F; 外侧条件为 true 时执行的代码     if(内侧条件){          &#x2F;&#x2F; 内侧条件为 true 时执行的代码    }    } 
画个流程图表示一下：

来写个示例：
1234567int age &#x3D; 20;boolean isGirl &#x3D; true;if (age &gt;&#x3D; 20) {    if (isGirl) {        System.out.println(&quot;女生法定结婚年龄&quot;);    }}
输出：
1女生法定结婚年龄
02、switch 语句 
switch 语句用来判断变量与多个值之间的相等性。变量的类型可以是 byte、short、int 或者 char，或者对应的包装器类型 Byte、Short、Integer、Character，以及字符串和枚举类型。
来看一下 switch 语句的格式：
123456789101112switch(变量) {    case 可选值1:     &#x2F;&#x2F; 可选值1匹配后执行的代码;     break;  &#x2F;&#x2F; 该关键字是可选项case 可选值2:     &#x2F;&#x2F; 可选值2匹配后执行的代码;     break;  &#x2F;&#x2F; 该关键字是可选项......        default: &#x2F;&#x2F; 该关键字是可选项      &#x2F;&#x2F; 所有可选值都不匹配后执行的代码 }    

变量可以有 1 个或者 N 个值。
值类型必须和变量类型是一致的，并且值是确定的。
值必须是唯一的，不能重复，否则编译会出错。
break 关键字是可选的，如果没有，则执行下一个 case，如果有，则跳出 switch 语句。
default 关键字也是可选的。

画个流程图：

来个示例：
123456789101112131415int age &#x3D; 20;switch (age) {    case 20 :        System.out.println(&quot;上学&quot;);        break;    case 24 :        System.out.println(&quot;苏州工作&quot;);        break;    case 30 :        System.out.println(&quot;洛阳工作&quot;);        break;    default:        System.out.println(&quot;未知&quot;);        break; &#x2F;&#x2F; 可省略}
输出：
1上学
当两个值要执行的代码相同时，可以把要执行的代码写在下一个 case 语句中，而上一个 case 语句中什么也没有，来看一下示例：
12345678910111213141516String name &#x3D; &quot;沉默王二&quot;;switch (name) {    case &quot;詹姆斯&quot;:        System.out.println(&quot;篮球运动员&quot;);        break;    case &quot;穆里尼奥&quot;:        System.out.println(&quot;足球教练&quot;);        break;    case &quot;沉默王二&quot;:    case &quot;沉默王三&quot;:        System.out.println(&quot;乒乓球爱好者&quot;);        break;    default:        throw new IllegalArgumentException(                &quot;名字没有匹配项&quot;);}
输出：
1乒乓球爱好者
枚举作为 switch 语句的变量也很常见，来看例子：
1234567891011121314151617181920212223242526public class SwitchEnumDemo {    public enum PlayerTypes {        TENNIS,        FOOTBALL,        BASKETBALL,        UNKNOWN    }    public static void main(String[] args) {        System.out.println(createPlayer(PlayerTypes.BASKETBALL));    }    private static String createPlayer(PlayerTypes playerType) {        switch (playerType) {            case TENNIS:                return &quot;网球运动员费德勒&quot;;            case FOOTBALL:                return &quot;足球运动员C罗&quot;;            case BASKETBALL:                return &quot;篮球运动员詹姆斯&quot;;            case UNKNOWN:                throw new IllegalArgumentException(&quot;未知&quot;);            default:                throw new IllegalArgumentException(                        &quot;运动员类型: &quot; + playerType);        }    }}
输出：
1篮球运动员詹姆斯
03、for 循环

1）普通 for 循环 
普通的 for 循环可以分为 4 个部分：
1）初始变量：循环开始执行时的初始条件。
2）条件：循环每次执行时要判断的条件，如果为 true，就执行循环体；如果为 false，就跳出循环。当然了，条件是可选的，如果没有条件，则会一直循环。
3）循环体：循环每次要执行的代码块，直到条件变为 false。
4）自增&#x2F;自减：初始变量变化的方式。
来看一下普通 for 循环的格式：
123for(初始变量;条件;自增&#x2F;自减){  &#x2F;&#x2F; 循环体} 
画个流程图：

来个示例：
123for (int i &#x3D; 0; i &lt; 5; i++) {    System.out.println(&quot;沉默好美啊&quot;);}
输出：
12345沉默好美啊沉默好美啊沉默好美啊沉默好美啊沉默好美啊
循环语句还可以嵌套呢，这样就可以打印出更好玩的呢
123456for (int i &#x3D; 0; i &lt; 5; i++) {    for (int j &#x3D; 0;j&lt;&#x3D; i;j++) {        System.out.print(&quot;❤&quot;);    }    System.out.println();}
打印出什么玩意呢？
12345❤❤❤❤❤❤❤❤❤❤❤❤❤❤❤
2）for-each 
for-each 循环通常用于遍历数组和集合，它的使用规则比普通的 for 循环还要简单，不需要初始变量，不需要条件，不需要下标来自增或者自减。来看一下语法：
123for(元素类型 元素 : 数组或集合){  &#x2F;&#x2F; 要执行的代码}  
来看一下示例：
1234String[] strs &#x3D; {&quot;沉默&quot;, &quot;一枚有趣的程序员&quot;};for (String str : strs) {    System.out.println(str);}
输出：
12沉默一枚有趣的程序员
3）无限 for 循环 
“你想不想体验一下无限 for 循环的威力，也就是死循环。”
123for(;;){    System.out.println(&quot;停不下来。。。。&quot;);}
输出：
1234停不下来。。。。停不下来。。。。停不下来。。。。停不下来。。。。
一旦运行起来，就停不下来了，除非强制停止。
04、while 循环 
来看一下 while 循环的格式：

来个示例：
12345678int i &#x3D; 0;while (true) {    System.out.println(&quot;沉默&quot;);    i++;    if (i &#x3D;&#x3D; 5) {        break;    }}
输出：
12345沉默沉默沉默沉默沉默
“你想不想体验一下无限 while 循环的威力，也就是死循环。”
123while (true) {    System.out.println(&quot;停不下来。。。。&quot;);}
输出：
1234停不下来。。。。停不下来。。。。停不下来。。。。停不下来。。。。
把 while 的条件设置为 true，并且循环体中没有 break 关键字的话，程序一旦运行起来，就根本停不下来了，除非强制停止。
05、do-while 循环 
来看一下 do-while 循环的格式：
123do{  &#x2F;&#x2F; 循环体}while(提交);  
画个流程图：

来个示例：
12345678int i &#x3D; 0;do {    System.out.println(&quot;沉默&quot;);    i++;    if (i &#x3D;&#x3D; 5) {        break;    }} while (true);
输出：
12345沉默沉默沉默沉默沉默
“你想不想体验一下无限 do-while 循环的威力……”
123do {    System.out.println(&quot;停不下来。。。。&quot;);} while (true);
输出：
1234停不下来。。。。停不下来。。。。停不下来。。。。停不下来。。。。
把 do-while 的条件设置为 true，并且循环体中没有 break 关键字的话，程序一旦运行起来，就根本停不下来了，除非强制停止。

06、break 
break 关键字通常用于中断循环或 switch 语句，它在指定条件下中断程序的当前流程。如果是内部循环，则仅中断内部循环。
可以将 break 关键字用于所有类型循环语句中，比如说 for 循环、while 循环，以及 do-while 循环。
来画个流程图感受一下：

用在 for 循环中的示例：
123456for (int i &#x3D; 1; i &lt;&#x3D; 10; i++) {    if (i &#x3D;&#x3D; 5) {        break;    }    System.out.println(i);}
用在嵌套 for 循环中的示例：
12345678for (int i &#x3D; 1; i &lt;&#x3D; 3; i++) {    for (int j &#x3D; 1; j &lt;&#x3D; 3; j++) {        if (i &#x3D;&#x3D; 2 &amp;&amp; j &#x3D;&#x3D; 2) {            break;        }        System.out.println(i + &quot; &quot; + j);    }}
用在 while 循环中的示例：
123456789int i &#x3D; 1;while (i &lt;&#x3D; 10) {    if (i &#x3D;&#x3D; 5) {        i++;        break;    }    System.out.println(i);    i++;}
用在 do-while 循环中的示例：
123456789int j &#x3D; 1;do {    if (j &#x3D;&#x3D; 5) {         j++;        break;    }    System.out.println(j);    j++;} while (j &lt;&#x3D; 10);
用在 switch 语句中的示例：
1234567891011121314switch (age) {    case 20 :        System.out.println(&quot;上学&quot;);        break;    case 24 :        System.out.println(&quot;苏州工作&quot;);        break;    case 30 :        System.out.println(&quot;洛阳工作&quot;);        break;    default:        System.out.println(&quot;未知&quot;);        break; &#x2F;&#x2F; 可省略}
07、continue 
当我们需要在 for 循环或者 （do）while 循环中立即跳转到下一个循环时，就可以使用 continue 关键字，通常用于跳过指定条件下的循环体，如果循环是嵌套的，仅跳过当前循环。
来个示例：
1234567for (int i &#x3D; 1; i &lt;&#x3D; 10; i++) {    if (i &#x3D;&#x3D; 5) {        &#x2F;&#x2F; 使用 continue 关键字        continue;&#x2F;&#x2F; 5 将会被跳过    }    System.out.println(i);}
输出：
1234567891234678910
再来个循环嵌套的例子。
123456789for (int i &#x3D; 1; i &lt;&#x3D; 3; i++) {    for (int j &#x3D; 1; j &lt;&#x3D; 3; j++) {        if (i &#x3D;&#x3D; 2 &amp;&amp; j &#x3D;&#x3D; 2) {            &#x2F;&#x2F;  当i&#x3D;2，j&#x3D;2时跳过            continue;        }        System.out.println(i + &quot; &quot; + j);    }}
打印出什么玩意呢？
123456781 11 21 32 12 33 13 23 3
“2 2” 没有输出，被跳过了。
再来看一下 while 循环时 continue 的使用示例：
123456789int i &#x3D; 1;while (i &lt;&#x3D; 10) {    if (i &#x3D;&#x3D; 5) {        i++;        continue;    }    System.out.println(i);    i++;}
输出：
1234567891234678910
注意：如果把 if 条件中的“i++”省略掉的话，程序就会进入死循环，一直在 continue。
最后，再来看一下 do-while 循环时 continue 的使用示例：
123456789int i&#x3D;1;do{    if(i&#x3D;&#x3D;5){        i++;        continue;    }    System.out.println(i);    i++;}while(i&lt;&#x3D;10);
输出：
1234567891234678910
注意：同样的，如果把 if 条件中的“i++”省略掉的话，程序就会进入死循环，一直在 continue。
08、小结 
本文全面讲解了Java流程控制语句，包括if、switch、while、for等结构。通过学习本文，你将了解到Java流程控制语句的基本概念、语法结构和使用场景，帮助你在实际编程过程中更加灵活地运用各类控制结构。
2 数组&amp;字符串2.1 掌握Java数组“ArrayList 的内部是用数组实现的”
“的确是的，看 ArrayList 的源码就一清二楚了。”我一边说，一边打开 Intellij IDEA，并找到了 ArrayList 的源码。
12345678910111213&#x2F;** * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData &#x3D;&#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA * will be expanded to DEFAULT_CAPACITY when the first element is added. *&#x2F;transient Object[] elementData; &#x2F;&#x2F; non-private to simplify nested class access&#x2F;** * The size of the ArrayList (the number of elements it contains). * * @serial *&#x2F;private int size;
“瞧见没？ Object[] elementData 就是数组。”我指着显示屏上这串代码继续说。
数组是一个对象，它包含了一组固定数量的元素，并且这些元素的类型是相同的。数组会按照索引的方式将元素放在指定的位置上，意味着我们可以通过索引来访问这些元素。在 Java 中，索引是从 0 开始的。
“能说一下为什么索引从 0 开始吗？”
“哦，Java 是基于 C&#x2F;C++ 语言实现的，而 C 语言的下标是从 0 开始的，所以 Java 就继承了这个良好的传统习惯。C语言有一个很重要概念，叫做指针，它实际上是一个偏移量，距离开始位置的偏移量，第一个元素就在开始的位置，它的偏移量就为 0，所以索引就为 0。”此刻，我很自信。
“此外，还有另外一种说法。早期的计算机资源比较匮乏，0 作为起始下标相比较于 1 作为起始下标，编译的效率更高。”
我们可以将数组理解为一个个整齐排列的单元格，每个单元格里面存放着一个元素。
数组元素的类型可以是基本数据类型（比如说 int、double），也可以是引用数据类型（比如说 String），包括自定义类型。
数组的声明方式分两种。
先来看第一种：
1int[] anArray;
再来看第二种：
1int anOtherArray[];
不同之处就在于中括号的位置，是跟在类型关键字的后面，还是跟在变量的名称的后面。前一种的使用频率更高一些，像 ArrayList 的源码中就用了第一种方式。
同样的，数组的初始化方式也有多种，最常见的是：
1int[] anArray &#x3D; new int[10];
看到了没？上面这行代码中使用了 new 关键字，这就意味着数组的确是一个对象，只有对象的创建才会用到 new 关键字，基本数据类型是不用的。然后，我们需要在方括号中指定数组的长度。
这时候，数组中的每个元素都会被初始化为默认值，int 类型的就为 0，Object 类型的就为 null。 不同数据类型的默认值不同。
另外，还可以使用大括号的方式，直接初始化数组中的元素：
1int anOtherArray[] &#x3D; new int[] {1, 2, 3, 4, 5};
这时候，数组的元素分别是 1、2、3、4、5，索引依次是 0、1、2、3、4，长度是 5。
“怎么访问数组呢？”
前面提到过，可以通过索引来访问数组的元素，就像下面这样：
1anArray[0] &#x3D; 10;
变量名，加上中括号，加上元素的索引，就可以访问到数组，通过“&#x3D;”操作符可以对元素进行赋值。
如果索引的值超出了数组的界限，就会抛出 ArrayIndexOutOfBoundException 。
既然数组的索引是从 0 开始，那就是到数组的 length - 1 结束，不要使用超出这个范围内的索引访问数组，就不会抛出数组越界的异常了。 
当数组的元素非常多的时候，逐个访问数组就太辛苦了，所以需要通过遍历的方式。
第一种，使用 for 循环：
1234int anOtherArray[] &#x3D; new int[] {1, 2, 3, 4, 5};for (int i &#x3D; 0; i &lt; anOtherArray.length; i++) {    System.out.println(anOtherArray[i]);}
通过 length 属性获取到数组的长度，然后从 0 开始遍历，就得到了数组的所有元素。
第二种，使用 for-each 循环：
123for (int element : anOtherArray) {    System.out.println(element);}
如果不需要关心索引的话（意味着不需要修改数组的某个元素），使用 for-each 遍历更简洁一些。当然，也可以使用 while 和 do-while 循环。
在 Java 中，可变参数用于将任意数量的参数传递给方法，来看 varargsMethod() 方法：
1void varargsMethod(String... varargs) {}
该方法可以接收任意数量的字符串参数，可以是 0 个或者 N 个，本质上，可变参数就是通过数组实现的。为了证明这一点，我们可以看一下反编译一后的字节码：
123456789public class VarargsDemo{    public VarargsDemo()    {    }    transient void varargsMethod(String as[])    {    }}
所以，我们其实可以直接将数组作为参数传递给该方法：
123VarargsDemo demo &#x3D; new VarargsDemo();String[] anArray &#x3D; new String[] {&quot;沉默&quot;, &quot;一枚有趣的程序员&quot;};demo.varargsMethod(anArray);
也可以直接传递多个字符串，通过逗号隔开的方式：
1demo.varargsMethod(&quot;沉默&quot;, &quot;一枚有趣的程序员&quot;);
在 Java 中，数组与 List 关系非常密切。List 封装了很多常用的方法，方便我们对集合进行一些操作，而如果直接操作数组的话，有很多不便，因为数组本身没有提供这些封装好的操作，所以有时候我们需要把数组转成 List。
“怎么转呢？”
最原始的方式，就是通过遍历数组的方式，一个个将数组添加到 List 中。
12345int[] anArray &#x3D; new int[] {1, 2, 3, 4, 5};List&lt;Integer&gt; aList &#x3D; new ArrayList&lt;&gt;();for (int element : anArray) {    aList.add(element);}
更优雅的方式是通过 Arrays 类的 asList() 方法：
1List&lt;Integer&gt; aList &#x3D; Arrays.asList(anArray);
不过需要注意的是，Arrays.asList 的参数需要是 Integer 数组，而 anArray 目前是 int 类型，我们需要换另外一种方式。
1List&lt;Integer&gt; aList &#x3D; Arrays.stream(anArray).boxed().collect(Collectors.toList());
这又涉及到了 Java 流的知识，后面会讲到。
还有一个需要注意的是，Arrays.asList 方法返回的 ArrayList 并不是 java.util.ArrayList ，它其实是Arrays 类的一个内部类：
12private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;        implements RandomAccess, java.io.Serializable{}
如果需要添加元素或者删除元素的话，需要把它转成 java.util.ArrayList 。
1new ArrayList&lt;&gt;(Arrays.asList(anArray));
Java 8 新增了 Stream 流的概念，这就意味着我们也可以将数组转成 Stream 进行操作。
12String[] anArray &#x3D; new String[] {&quot;沉默&quot;, &quot;一枚有趣的程序员&quot;, &quot;好好珍重他&quot;};Stream&lt;String&gt; aStream &#x3D; Arrays.stream(anArray);
如果想对数组进行排序的话，可以使用 Arrays 类提供的 sort() 方法。

基本数据类型按照升序排列
实现了 Comparable 接口的对象按照 compareTo() 的排序

来看第一个例子：
12int[] anArray &#x3D; new int[] {5, 2, 1, 4, 8};Arrays.sort(anArray);
排序后的结果如下所示：
1[1, 2, 4, 5, 8]
来看第二个例子：
123String[] yetAnotherArray &#x3D; new String[] {&quot;A&quot;, &quot;E&quot;, &quot;Z&quot;, &quot;B&quot;, &quot;C&quot;};Arrays.sort(yetAnotherArray, 1, 3,                Comparator.comparing(String::toString).reversed());
只对 1-3 位置上的元素进行反序，所以结果如下所示：
1[A, Z, E, B, C]
有时候，我们需要从数组中查找某个具体的元素，最直接的方式就是通过遍历的方式：
1234567int[] anArray &#x3D; new int[] {5, 2, 1, 4, 8};for (int i &#x3D; 0; i &lt; anArray.length; i++) {    if (anArray[i] &#x3D;&#x3D; 4) {        System.out.println(&quot;找到了 &quot; + i);        break;    }}
上例中从数组中查询元素 4，找到后通过 break 关键字退出循环。
如果数组提前进行了排序，就可以使用二分查找法，这样效率就会更高一些。 Arrays.binarySearch() 方法可供我们使用，它需要传递一个数组，和要查找的元素。
12int[] anArray &#x3D; new int[] {1, 2, 3, 4, 5};int index &#x3D; Arrays.binarySearch(anArray, 4);
2.2 掌握Java二维数组01、什么是二维数组 
二维数组是一种数据类型，可以存储多行和多列的数据。它由一系列的行和列组成，每个元素都可以通过一个行索引和列索引来访问。例如，一个3行4列的二维数组可以表示为以下形式：
12345array &#x3D; [  [a, b, c, d],  [e, f, g, h],  [i, j, k, l]]
在这个例子中，第一行有4个元素，第二行有4个元素，第三行有4个元素，每个元素都有一个行索引和一个列索引。例如，元素 array[1][2] 是第2行第3列的元素，它的值是 g。
使用二维数组可以有效地存储和处理表格数据，如矩阵、图像、地图等等。
02、创建二维数组 
要在 Java 中创建二维数组，你必须指定要存储在数组中的数据类型，后跟两个方括号和数组的名称。
语法如下所示：
1data_type[][] array_name;
让我们看一个代码示例。
1int[][] oddNumbers &#x3D; { {1, 3, 5, 7}, {9, 11, 13, 15} };
03、访问二维数组中的元素 
我们可以使用两个方括号来访问二维中的元素。
第一个表示我们要从中访问元素的数组，而第二个表示我们要访问的元素索引。
让我们用一个例子来简化上面的解释：
123int[][] oddNumbers &#x3D; { {1, 3, 5, 7}, {9, 11, 13, 15} };System.out.println(oddNumbers[0][0]);&#x2F;&#x2F; 1
在上面的示例中， oddNumbers 数组中有两个数组—— {1, 3, 5, 7} 和 {9, 11, 13, 15} 。
第一个数组—— {1, 3, 5, 7} ——用 0 表示。
第二个数组—— {9, 11, 13, 15} ——用 1 表示。
第一个数组是 0，第二个是 1，第三个是 2，依此类推。
因此，要访问第一个数组中的项目，我们将 0 分配给第一个方括号。由于我们试图访问数组中的第一项，我们将使用它的索引，即 0： oddNumbers[0][0] 。
让我们进一步分解它。
这是访问元素的代码： oddNumbers[?][?] 。
我在两个方括号中都加上了问号——随着进展填写它们。
假设我们要访问第二个数组中的元素，我们的代码将如下所示： oddNumbers[1][?] 。
现在我们要在第二个数组（ {9, 11, 13, 15} ）中尝试访问其中一个元素。就像一维数组一样，每个元素都有一个从零开始的索引。
因此，要访问第三个元素 13 ，我们将其索引号传递给第二个方括号： oddNumbers[1][2] 。
来看这样一个例子：
1int[][] oddNumbers &#x3D; { {1, 3, 5, 7}, {9, 11, 13, 15}, {17, 19, 21, 23} };
我们的目标是访问第三个数组中的 21。访问方式仍然通过问号来表示： oddNumbers[?][?] 。
我们首先给第一个问号一个指向要访问的特定数组的值。
数组 0 &#x3D;&gt; {1, 3, 5, 7}
数组 1 &#x3D;&gt; {9, 11, 13, 15}
数组 2 &#x3D;&gt; {17, 19, 21, 23}
我们要查找的数字在第三个数组中，所以是： oddNumbers[2][?] 。
第二个方括号的值将指向要访问的元素。为此，我们必须指定元素的索引。以下是该数组中的索引：
17 &#x3D;&gt; 索引 0
19 &#x3D;&gt; 索引 1
21 &#x3D;&gt; 索引 2
23 &#x3D;&gt; 索引 3
21 的索引为 2，因此我们可以将其添加到第二个方括号： oddNumbers[2][2] 。当你将其打印到控制台时，将会打印出 21。
代码如下所示：
123int[][] oddNumbers &#x3D; { {1, 3, 5, 7}, {9, 11, 13, 15}, {17, 19, 21, 23} };System.out.println(oddNumbers[2][2]);&#x2F;&#x2F; 21
你可以使用嵌套循环，遍历二维数组中的所有项目。这是一个例子：
123456789101112131415161718int[][] oddNumbers &#x3D; { {1, 3, 5, 7}, {9, 11, 13, 15}, {17, 19, 21, 23} };for(int i &#x3D; 0; i &lt; oddNumbers.length; i++){    for(int j &#x3D; 0; j &lt; oddNumbers[i].length; j++){        System.out.println(oddNumbers[i][j]);    }   }&#x2F;&#x2F; 1&#x2F;&#x2F; 3&#x2F;&#x2F; 5&#x2F;&#x2F; 7&#x2F;&#x2F; 9&#x2F;&#x2F; 11&#x2F;&#x2F; 13&#x2F;&#x2F; 15&#x2F;&#x2F; 17&#x2F;&#x2F; 19&#x2F;&#x2F; 21&#x2F;&#x2F; 23
上面的代码将会打印出 oddNumbers 数组中的所有项目。
04、二维数组打印杨辉三角
12345678910111213141516171819202122232425262728import java.util.Scanner;public class YangHuiTriangle {    public static void main(String[] args) {        Scanner input &#x3D; new Scanner(System.in);        System.out.print(&quot;请输入要打印的行数：&quot;);        int n &#x3D; input.nextInt();        printYangHuiTriangle(n);    }    public static void printYangHuiTriangle(int n) {        int[][] triangle &#x3D; new int[n][n];        for (int i &#x3D; 0; i &lt; n; i++) {            &#x2F;&#x2F; 每行的第一个和最后一个数字都是1            triangle[i][0] &#x3D; 1;            triangle[i][i] &#x3D; 1;            for (int j &#x3D; 1; j &lt; i; j++) {                &#x2F;&#x2F; 其他数字是上一行的两个数字之和                triangle[i][j] &#x3D; triangle[i - 1][j - 1] + triangle[i - 1][j];            }        }        &#x2F;&#x2F; 打印杨辉三角        for (int i &#x3D; 0; i &lt; n; i++) {            for (int j &#x3D; 0; j &lt;&#x3D; i; j++) {                System.out.print(triangle[i][j] + &quot; &quot;);            }            System.out.println();        }    }}
“这段代码使用了一个二维数组来存储杨辉三角中的数字。首先，程序要求用户输入要打印的行数，然后调用 printYangHuiTriangle 方法来生成和打印杨辉三角。在 printYangHuiTriangle 方法中，程序使用了一个嵌套的 for 循环来计算杨辉三角中的每个数字，并将结果存储在二维数组 triangle 中。最后，程序再次使用循环来遍历数组并打印出杨辉三角中的数字。”
输出：
1234567请输入要打印的行数：61 1 1 1 2 1 1 3 3 1 1 4 6 4 1 1 5 10 10 5 1 
2.3 打印Java数组“数组也是一个对象，但 Java 中并未明确的定义这样一个类。”
“是的，因此数组也就没有机会覆盖 Object.toString() 方法。如果尝试直接打印数组的话，输出的结果并不是我们预期的结果。”
“那怎么打印数组呢？”
为什么不能直接打印数组
“首先，我们来看一下，为什么不能直接打印数组，直接打印的话，会出现什么问题。”
来看这样一个例子。
12String [] cmowers &#x3D; {&quot;沉默&quot;,&quot;一枚有趣的程序员&quot;};System.out.println(cmowers);
程序打印的结果是：
1[Ljava.lang.String;@3d075dc0
[Ljava.lang.String; 表示字符串数组的 Class 名，@ 后面的是十六进制的 hashCode——这样的打印结果太“人性化”了，一般人表示看不懂！为什么会这样显示呢？查看一下 java.lang.Object 类的 toString() 方法就明白了。
12String [] cmowers &#x3D; {&quot;沉默&quot;,&quot;王二&quot;,&quot;一枚有趣的程序员&quot;};System.out.println(cmowers);
再次证明，数组虽然没有显式定义成一个类，但它的确是一个对象，继承了祖先类 Object 的所有方法。
“那为什么数组不单独定义一个类来表示呢？就像字符串 String 类那样呢？”
“一个合理的说法是 Java 将其隐藏了。假如真的存在这么一个类，就叫 Array.java 吧，我们假想一下它真实的样子，必须得有一个容器来存放数组的每一个元素，就像 String 类那样。”
12345public final class String    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {    &#x2F;** The value is used for character storage. *&#x2F;    private final char value[];}
“最终还是要用类似一种数组的形式来存放数组的元素，对吧？这就变得很没有必要了，不妨就把数组当做是一个没有形体的对象吧！”
stream 流打印 Java 数组 
“我们来看第一种打印数组的方法，使用时髦一点的Stream 流。”
第一种形式：
1Arrays.asList(cmowers).stream().forEach(s -&gt; System.out.println(s));
第二种形式：
1Stream.of(cmowers).forEach(System.out::println);
第三种形式：
1Arrays.stream(cmowers).forEach(System.out::println);
打印的结果如下所示。
12沉默一枚有趣的程序员
没错，这三种方式都可以轻松胜任本职工作，并且显得有点高大上，毕竟用到了 Stream，以及 lambda 表达式。
for 循环打印 Java 数组 
“当然了，也可以使用传统的方式，for 循环。甚至 for-each 也行。”
123456for(int i &#x3D; 0; i &lt; cmowers.length; i++){    System.out.println(cmowers[i]);}for (String s : cmowers) {    System.out.println(s);}
Arrays 工具类打印 Java 数组 
“当然没有了，我认为 Arrays.toString() 是打印数组的最佳方式，没有之一。”Arrays.toString() 可以将任意类型的数组转成字符串，包括基本类型数组和引用类型数组。该方法有多种重载形式。

使用 Arrays.toString() 方法来打印数组再优雅不过了，就像，就像，就像蒙娜丽莎的微笑。

12String [] cmowers &#x3D; {&quot;沉默&quot;,&quot;一枚有趣的程序员&quot;};System.out.println(Arrays.toString(cmowers));
程序打印结果：
1[沉默, 一枚有趣的程序员]
哇，打印格式不要太完美，不多不少！完全是我们预期的结果： [] 表明是一个数组， , 点和空格用来分割元素。
Arrays工具类打印二维数组 
“那如果我想打印二维数组呢？”
“可以使用 Arrays.deepToString() 方法。”
12String[][] deepArray &#x3D; new String[][] {{&quot;沉默&quot;}, {&quot;一枚有趣的程序员&quot;}};System.out.println(Arrays.deepToString(deepArray));
打印结果如下所示。
1[[沉默], [一枚有趣的程序员]]
POJO 的打印规约 
“说到打印，哥给你提醒一点。阿里巴巴的 Java 开发手册上有这样一条规约，你看。”

“什么是 POJO 呢，就是 Plain Ordinary Java Object 的缩写，一般在 Web 应用程序中建立一个数据库的映射对象时，我们称它为 POJO，这类对象不继承或不实现任何其它 Java 框架的类或接口。”
“对于这样的类，最好是重写一下它的 toString() 方法，方便查看这个对象到底包含了什么字段，好排查问题。”
“如果不重写的话，打印出来的 Java 对象就像直接打印数组的那样，一串谁也看不懂的字符序列。”
“可以借助 Intellij IDEA 生成重写的  toString() 方法，特别方便。”
2.4 解读String类源码 
String 类的声明 
123public final class String    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {}
“第一，String 类是 final 的，意味着它不能被子类继承。”
“第二，String 类实现了 Serializable 接口，意味着它可以序列化。”
“第三，String 类实现了 Comparable 接口，意味着最好不要用‘&#x3D;&#x3D;’来比较两个字符串是否相等，而应该用 compareTo() 方法去比较。”
因为 &#x3D;&#x3D; 是用来比较两个对象的地址，这个在讲字符串比较的时候会详细讲。如果只是说比较字符串内容的话，可以使用 String 类的 equals 方法：
123456789101112131415161718192021public boolean equals(Object anObject) {    if (this &#x3D;&#x3D; anObject) {        return true;    }    if (anObject instanceof String) {        String anotherString &#x3D; (String) anObject;        int n &#x3D; value.length;        if (n &#x3D;&#x3D; anotherString.value.length) {            char v1[] &#x3D; value;            char v2[] &#x3D; anotherString.value;            int i &#x3D; 0;            while (n-- !&#x3D; 0) {                if (v1[i] !&#x3D; v2[i])                    return false;                i++;            }            return true;        }    }    return false;}
“第四，StringBuffer、StringBuilder 和 String 一样，都实现了 CharSequence 接口，所以它们仨属于近亲。由于 String 是不可变的，所以遇到字符串拼接的时候就可以考虑一下 String 的另外两个好兄弟，StringBuffer 和 StringBuilder，它俩是可变的。”
String 类的底层实现 
“第五，Java 9 以前，String 是用 char 型数组实现的，之后改成了 byte 型数组实现，并增加了 coder 来表示编码。这样做的好处是在 Latin1 字符为主的程序里，可以把 String 占用的内存减少一半。当然，天下没有免费的午餐，这个改进在节省内存的同时引入了编码检测的开销。”

Latin1（Latin-1）是一种单字节字符集（即每个字符只使用一个字节的编码方式），也称为ISO-8859-1（国际标准化组织8859-1），它包含了西欧语言中使用的所有字符，包括英语、法语、德语、西班牙语、葡萄牙语、意大利语等等。在Latin1编码中，每个字符使用一个8位（即一个字节）的编码，可以表示256种不同的字符，其中包括ASCII字符集中的所有字符，即0x00到0x7F，以及其他西欧语言中的特殊字符，例如é、ü、ñ等等。由于Latin1只使用一个字节表示一个字符，因此在存储和传输文本时具有较小的存储空间和较快的速度

1234567public final class String    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {    @Stable    private final byte[] value;    private final byte coder;    private int hash;}
接下来，我们来详细地说一下。
从 char[] 到 byte[] ，最主要的目的是节省字符串占用的内存空间。内存占用减少带来的另外一个好处，就是 GC 次数也会减少。
我们使用 jmap -histo:live pid | head -n 10 命令就可以查看到堆内对象示例的统计信息、查看 ClassLoader 的信息以及 finalizer 队列。
以我正在运行着的编程喵项目实例（基于 Java 8）来说，结果是这样的。

其中 String 对象有 17638 个，占用了 423312 个字节的内存，排在第三位。
由于 Java 8 的 String 内部实现仍然是 char[] ，所以我们可以看到内存占用排在第 1 位的就是 char 数组。char[] 对象有 17673 个，占用了 1621352 个字节的内存，排在第一位。
那也就是说优化 String 节省内存空间是非常有必要的，如果是去优化一个使用频率没有 String 这么高的类，就没什么必要，对吧？
众所周知，char 类型的数据在 JVM 中是占用两个字节的，并且使用的是 UTF-8 编码，其值范围在 ‘\u0000’（0）和 ‘\uffff’（65,535）（包含）之间。
也就是说，使用 char[] 来表示 String 就会导致，即使 String 中的字符只用一个字节就能表示，也得占用两个字节。

PS：在计算机中，单字节字符通常指的是一个字节（8位）可以表示的字符，而双字节字符则指需要两个字节（16位）才能表示的字符。单字节字符和双字节字符的定义是相对的，不同的编码方式对应的单字节和双字节字符集也不同。常见的单字节字符集有ASCII（美国信息交换标准代码）、ISO-8859（国际标准化组织标准编号8859）、GBK（汉字内码扩展规范）、GB2312（中国国家标准，现在已经被GBK取代），像拉丁字母、数字、标点符号、控制字符都是单字节字符。双字节字符集包括 Unicode、UTF-8、GB18030（中国国家标准），中文、日文、韩文、拉丁文扩展字符属于双字节字符。

当然了，仅仅将 char[] 优化为 byte[] 是不够的，还要配合 Latin-1 的编码方式，该编码方式是用单个字节来表示字符的，这样就比 UTF-8 编码节省了更多的空间。
换句话说，对于：
1String name &#x3D; &quot;jack&quot;;
这样的，使用 Latin-1 编码，占用 4 个字节就够了。
但对于：
1String name &#x3D; &quot;小二&quot;;
这种，木的办法，只能使用 UTF16 来编码。
针对 JDK 9 的 String 源码里，为了区别编码方式，追加了一个 coder 字段来区分。
123456789101112&#x2F;** * The identifier of the encoding used to encode the bytes in * {@code value}. The supported values in this implementation are * * LATIN1 * UTF16 * * @implNote This field is trusted by the VM, and is a subject to * constant folding if String instance is constant. Overwriting this * field after construction will cause problems. *&#x2F;private final byte coder;
Java 会根据字符串的内容自动设置为相应的编码，要么 Latin-1 要么 UTF16。
也就是说，从 char[] 到 byte[] ，中文是两个字节，纯英文是一个字节，在此之前呢，中文是两个字节，英文也是两个字节。
在 UTF-8 中，0-127 号的字符用 1 个字节来表示，使用和 ASCII 相同的编码。只有 128 号及以上的字符才用 2 个、3 个或者 4 个字节来表示。

如果只有一个字节，那么最高的比特位为 0；
如果有多个字节，那么第一个字节从最高位开始，连续有几个比特位的值为 1，就使用几个字节编码，剩下的字节均以 10 开头。

具体的表现形式为：

0xxxxxxx：一个字节；
110xxxxx 10xxxxxx：两个字节编码形式（开始两个 1）；
1110xxxx 10xxxxxx 10xxxxxx：三字节编码形式（开始三个 1）；
11110xxx 10xxxxxx 10xxxxxx 10xxxxxx：四字节编码形式（开始四个 1）。

也就是说，UTF-8 是变长的，那对于 String 这种有随机访问方法的类来说，就很不方便。所谓的随机访问，就是charAt、subString这种方法，随便指定一个数字，String要能给出结果。如果字符串中的每个字符占用的内存是不定长的，那么进行随机访问的时候，就需要从头开始数每个字符的长度，才能找到你想要的字符。
那你可能会问，UTF-16也是变长的呢？一个字符还可能占用 4 个字节呢？
的确，UTF-16 使用 2 个或者 4 个字节来存储字符。

对于 Unicode 编号范围在 0 ~ FFFF 之间的字符，UTF-16 使用两个字节存储。
对于 Unicode 编号范围在 10000 ~ 10FFFF 之间的字符，UTF-16 使用四个字节存储，具体来说就是：将字符编号的所有比特位分成两部分，较高的一些比特位用一个值介于 D800~DBFF 之间的双字节存储，较低的一些比特位（剩下的比特位）用一个值介于 DC00~DFFF 之间的双字节存储。

但是在 Java 中，一个字符（char）就是 2 个字节，占 4 个字节的字符，在 Java 里也是用两个 char 来存储的，而String的各种操作，都是以Java的字符（char）为单位的，charAt是取得第几个char，subString取的也是第几个到第几个char组成的子串，甚至length返回的都是char的个数。
所以UTF-16在Java的世界里，就可以视为一个定长的编码。
String 类的 hashCode 方法 
“第六，每一个字符串都会有一个 hash 值，这个哈希值在很大概率是不会重复的，因此 String 很适合来作为 HashMap 的键值。”
来看 String 类的 hashCode 方法。
123456789101112private int hash; &#x2F;&#x2F; Cache the hash code for the stringpublic int hashCode() {    int h &#x3D; hash;    if (h &#x3D;&#x3D; 0 &amp;&amp; value.length &gt; 0) {        char val[] &#x3D; value;        for (int i &#x3D; 0; i &lt; value.length; i++) {            h &#x3D; 31 * h + val[i];        }        hash &#x3D; h;    }    return h;}
hashCode 方法首先检查是否已经计算过哈希码，如果已经计算过，则直接返回缓存的哈希码。否则，方法将使用一个循环遍历字符串的所有字符，并使用一个乘法和加法的组合计算哈希码。这种计算方法被称为“31 倍哈希法”。计算完成后，将得到的哈希值存储在 hash 成员变量中，以便下次调用 hashCode 方法时直接返回该值，而不需要重新计算。这是一种缓存优化，称为“惰性计算”。
31倍哈希法（31-Hash）是一种简单有效的字符串哈希算法，常用于对字符串进行哈希处理。该算法的基本思想是将字符串中的每个字符乘以一个固定的质数31的幂次方，并将它们相加得到哈希值。具体地，假设字符串为s，长度为n，则31倍哈希值计算公式如下：
1H(s) &#x3D; (s[0] * 31^(n-1)) + (s[1] * 31^(n-2)) + ... + (s[n-1] * 31^0)
其中，s[i]表示字符串s中第i个字符的ASCII码值， ^表示幂运算。31倍哈希法的优点在于简单易实现，计算速度快，同时也比较均匀地分布在哈希表中。
hashCode 方法，我们会在另外一个章节里详细讲。
我们可以通过以下方法模拟 String 的 hashCode 方法：
123456789101112131415public class HashCodeExample {    public static void main(String[] args) {        String text &#x3D; &quot;沉默王二&quot;;        int hashCode &#x3D; computeHashCode(text);        System.out.println(&quot;字符串 \&quot;&quot; + text + &quot;\&quot; 的哈希码是: &quot; + hashCode);        System.out.println(&quot;String 的 hashCode &quot; + text.hashCode());    }    public static int computeHashCode(String text) {        int h &#x3D; 0;        for (int i &#x3D; 0; i &lt; text.length(); i++) {            h &#x3D; 31 * h + text.charAt(i);        }        return h;    }}
看一下结果：
12字符串 &quot;沉默&quot; 的哈希码是: 867758096String 的 hashCode 867758096
结果是一样的，又学到了吧？
String 类的 substring 方法 
String 类中还有一个方法比较常用 substring，用来截取字符串的，来看源码。
12345678910public String substring(int beginIndex) {    if (beginIndex &lt; 0) {        throw new StringIndexOutOfBoundsException(beginIndex);    }    int subLen &#x3D; value.length - beginIndex;    if (subLen &lt; 0) {        throw new StringIndexOutOfBoundsException(subLen);    }    return (beginIndex &#x3D;&#x3D; 0) ? this : new String(value, beginIndex, subLen);}
substring 方法首先检查参数的有效性，如果参数无效，则抛出 StringIndexOutOfBoundsException 异常。
接下来，方法根据参数计算子字符串的长度。如果子字符串长度小于零，抛出StringIndexOutOfBoundsException异常。
如果 beginIndex 为 0，且 endIndex 等于字符串的长度，说明子串与原字符串相同，因此直接返回原字符串。否则，使用 value 数组（原字符串的字符数组）的一部分创建一个新的 String 对象并返回。
下面是几个使用 substring 方法的示例：
①、提取字符串中的一段子串：
123String str &#x3D; &quot;Hello, world!&quot;;String subStr &#x3D; str.substring(7, 12);  &#x2F;&#x2F; 从第7个字符（包括）提取到第12个字符（不包括）System.out.println(subStr);  &#x2F;&#x2F; 输出 &quot;world&quot;
②、提取字符串中的前缀或后缀：
123String str &#x3D; &quot;Hello, world!&quot;;String prefix &#x3D; str.substring(0, 5);  &#x2F;&#x2F; 提取前5个字符，即 &quot;Hello,&quot;String suffix &#x3D; str.substring(7);     &#x2F;&#x2F; 提取从第7个字符开始的所有字符，即 &quot;world!&quot;
③、处理字符串中的空格和分隔符：
12345String str &#x3D; &quot;   Hello,   world!  &quot;;String trimmed &#x3D; str.trim();                  &#x2F;&#x2F; 去除字符串开头和结尾的空格String[] words &#x3D; trimmed.split(&quot;\\s+&quot;);       &#x2F;&#x2F; 将字符串按照空格分隔成单词数组String firstWord &#x3D; words[0].substring(0, 1);  &#x2F;&#x2F; 提取第一个单词的首字母System.out.println(firstWord);  
④、处理字符串中的数字和符号：
1234String str &#x3D; &quot;1234-5678-9012-3456&quot;;String[] parts &#x3D; str.split(&quot;-&quot;);             &#x2F;&#x2F; 将字符串按照连字符分隔成四个部分String last4Digits &#x3D; parts[3].substring(1);  &#x2F;&#x2F; 提取最后一个部分的后三位数字System.out.println(last4Digits);             &#x2F;&#x2F; 输出 &quot;456&quot;
总之，substring 方法可以根据需求灵活地提取字符串中的子串，为字符串处理提供了便利。
String 类的 indexOf 方法 
indexOf 方法用于查找一个子字符串在原字符串中第一次出现的位置，并返回该位置的索引。来看该方法的源码：
1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&#x2F;* * 查找字符数组 target 在字符数组 source 中第一次出现的位置。 * sourceOffset 和 sourceCount 参数指定 source 数组中要搜索的范围， * targetOffset 和 targetCount 参数指定 target 数组中要搜索的范围， * fromIndex 参数指定开始搜索的位置。 * 如果找到了 target 数组，则返回它在 source 数组中的位置索引（从0开始）， * 否则返回-1。 *&#x2F;static int indexOf(char[] source, int sourceOffset, int sourceCount,        char[] target, int targetOffset, int targetCount,        int fromIndex) {    &#x2F;&#x2F; 如果开始搜索的位置已经超出 source 数组的范围，则直接返回-1（如果 target 数组为空，则返回 sourceCount）    if (fromIndex &gt;&#x3D; sourceCount) {        return (targetCount &#x3D;&#x3D; 0 ? sourceCount : -1);    }    &#x2F;&#x2F; 如果开始搜索的位置小于0，则从0开始搜索    if (fromIndex &lt; 0) {        fromIndex &#x3D; 0;    }    &#x2F;&#x2F; 如果 target 数组为空，则直接返回开始搜索的位置    if (targetCount &#x3D;&#x3D; 0) {        return fromIndex;    }    &#x2F;&#x2F; 查找 target 数组的第一个字符在 source 数组中的位置    char first &#x3D; target[targetOffset];    int max &#x3D; sourceOffset + (sourceCount - targetCount);    &#x2F;&#x2F; 循环查找 target 数组在 source 数组中的位置    for (int i &#x3D; sourceOffset + fromIndex; i &lt;&#x3D; max; i++) {        &#x2F;* Look for first character. *&#x2F;        &#x2F;&#x2F; 如果 source 数组中当前位置的字符不是 target 数组的第一个字符，则在 source 数组中继续查找 target 数组的第一个字符        if (source[i] !&#x3D; first) {            while (++i &lt;&#x3D; max &amp;&amp; source[i] !&#x3D; first);        }        &#x2F;* Found first character, now look at the rest of v2 *&#x2F;        &#x2F;&#x2F; 如果在 source 数组中找到了 target 数组的第一个字符，则继续查找 target 数组的剩余部分是否匹配        if (i &lt;&#x3D; max) {            int j &#x3D; i + 1;            int end &#x3D; j + targetCount - 1;            for (int k &#x3D; targetOffset + 1; j &lt; end &amp;&amp; source[j]                    &#x3D;&#x3D; target[k]; j++, k++);            &#x2F;&#x2F; 如果 target 数组全部匹配，则返回在 source 数组中的位置索引            if (j &#x3D;&#x3D; end) {                &#x2F;* Found whole string. *&#x2F;                return i - sourceOffset;            }        }    }    &#x2F;&#x2F; 没有找到 target 数组，则返回-1    return -1;}
来看示例。
①、示例1：查找子字符串的位置
123String str &#x3D; &quot;Hello, world!&quot;;int index &#x3D; str.indexOf(&quot;world&quot;);  &#x2F;&#x2F; 查找 &quot;world&quot; 子字符串在 str 中第一次出现的位置System.out.println(index);        &#x2F;&#x2F; 输出 7
②、示例2：查找字符串中某个字符的位置
123String str &#x3D; &quot;Hello, world!&quot;;int index &#x3D; str.indexOf(&quot;,&quot;);     &#x2F;&#x2F; 查找逗号在 str 中第一次出现的位置System.out.println(index);        &#x2F;&#x2F; 输出 5
③、示例3：查找子字符串的位置（从指定位置开始查找）
123String str &#x3D; &quot;Hello, world!&quot;;int index &#x3D; str.indexOf(&quot;l&quot;, 3);  &#x2F;&#x2F; 从索引为3的位置开始查找 &quot;l&quot; 子字符串在 str 中第一次出现的位置System.out.println(index);        &#x2F;&#x2F; 输出 3
④、示例4：查找多个子字符串
12345String str &#x3D; &quot;Hello, world!&quot;;int index1 &#x3D; str.indexOf(&quot;o&quot;);    &#x2F;&#x2F; 查找 &quot;o&quot; 子字符串在 str 中第一次出现的位置int index2 &#x3D; str.indexOf(&quot;o&quot;, 5); &#x2F;&#x2F; 从索引为5的位置开始查找 &quot;o&quot; 子字符串在 str 中第一次出现的位置System.out.println(index1);       &#x2F;&#x2F; 输出 4System.out.println(index2);       &#x2F;&#x2F; 输出 8
String 类的其他方法 
比如说 length() 用于返回字符串长度。
比如说 isEmpty() 用于判断字符串是否为空。
比如说 charAt() 用于返回指定索引处的字符。
比如说 getBytes() 用于返回字符串的字节数组，可以指定编码方式，比如说：
12String text &#x3D; &quot;沉默&quot;;System.out.println(Arrays.toString(text.getBytes(StandardCharsets.UTF_8)));
比如说 trim() 用于去除字符串两侧的空白字符，来看源码：
123456789101112public String trim() {    int len &#x3D; value.length;    int st &#x3D; 0;    char[] val &#x3D; value;    &#x2F;* avoid getfield opcode *&#x2F;    while ((st &lt; len) &amp;&amp; (val[st] &lt;&#x3D; &#39; &#39;)) {        st++;    }    while ((st &lt; len) &amp;&amp; (val[len - 1] &lt;&#x3D; &#39; &#39;)) {        len--;    }    return ((st &gt; 0) || (len &lt; value.length)) ? substring(st, len) : this;}
举例： “  沉默   “.trim() 会返回”沉默”
除此之外，还有 split、equals、join 等这些方法，我们后面会一一来细讲。
2.5 String为什么不可变String 可能是 Java 中使用频率最高的引用类型了，因此 String 类的设计者可以说是用心良苦。比如说 String 的不可变性。
String 类被 final 关键字修饰，所以它不会有子类，这就意味着没有子类可以重写它的方法，改变它的行为。
String 类的数据存储在 char[] 数组中，而这个数组也被 final 关键字修饰了，这就表示 String 对象是没法被修改的，只要初始化一次，值就确定了。
“为什么要这样设计呢？”
“我先简单来说下，能懂最好，不能懂后面再细说。”
第一，可以保证 String 对象的安全性，避免被篡改，毕竟像密码这种隐私信息一般就是用字符串存储的。
以下是一个简单的 Java 示例，演示了字符串的不可变性如何有助于保证 String 对象的安全性。在本例中，我们创建了一个简单的 User 类，该类使用 String 类型的字段存储用户名和密码。同时，我们使用一个静态方法 getUserCredentials 从外部获取用户凭据。
123456789101112131415161718192021222324252627282930313233343536class User {    private String username;    private String password;    public User(String username, String password) {        this.username &#x3D; username;        this.password &#x3D; password;    }    public String getUsername() {        return username;    }    public String getPassword() {        return password;    }}public class StringSecurityExample {    public static void main(String[] args) {        String username &#x3D; &quot;沉默&quot;;        String password &#x3D; &quot;123456&quot;;        User user &#x3D; new User(username, password);        &#x2F;&#x2F; 获取用户凭据        String[] credentials &#x3D; getUserCredentials(user);        &#x2F;&#x2F; 尝试修改从 getUserCredentials 返回的用户名和密码字符串        credentials[0] &#x3D; &quot;陈清扬&quot;;        credentials[1] &#x3D; &quot;612311&quot;;        &#x2F;&#x2F; 输出原始 User 对象中的用户名和密码        System.out.println(&quot;原始用户名: &quot; + user.getUsername()); &#x2F;&#x2F; 输出 &quot;JohnDoe&quot;        System.out.println(&quot;原始密码: &quot; + user.getPassword()); &#x2F;&#x2F; 输出 &quot;mySecurePassword&quot;    }    public static String[] getUserCredentials(User user) {        String[] credentials &#x3D; new String[2];        credentials[0] &#x3D; user.getUsername();        credentials[1] &#x3D; user.getPassword();        return credentials;    }}
在这个示例中，尽管我们尝试修改 getUserCredentials 返回的字符串数组（即用户名和密码），但原始 User 对象中的用户名和密码保持不变。这证明了字符串的不可变性有助于保护 String 对象的安全性。
第二，保证哈希值不会频繁变更。毕竟要经常作为哈希表的键值，经常变更的话，哈希表的性能就会很差劲。
在 String 类中，哈希值是在第一次计算时缓存的，后续对该哈希值的请求将直接使用缓存值。这有助于提高哈希表等数据结构的性能。以下是一个简单的示例，演示了字符串的哈希值缓存机制：
123456789101112String text1 &#x3D; &quot;沉默&quot;;String text2 &#x3D; &quot;沉默&quot;;&#x2F;&#x2F; 计算字符串 text1 的哈希值，此时会进行计算并缓存哈希值int hashCode1 &#x3D; text1.hashCode();System.out.println(&quot;第一次计算 text1 的哈希值: &quot; + hashCode1);&#x2F;&#x2F; 再次计算字符串 text1 的哈希值，此时直接返回缓存的哈希值int hashCode1Cached &#x3D; text1.hashCode();System.out.println(&quot;第二次计算: &quot; + hashCode1Cached);&#x2F;&#x2F; 计算字符串 text2 的哈希值，由于字符串常量池的存在，实际上 text1 和 text2 指向同一个字符串对象&#x2F;&#x2F; 所以这里直接返回缓存的哈希值int hashCode2 &#x3D; text2.hashCode();System.out.println(&quot;text2 直接使用缓存: &quot; + hashCode2);
在这个示例中，我们创建了两个具有相同内容的字符串 text1 和 text2。首次计算 text1 的哈希值时，会进行实际计算并缓存该值。当我们再次计算 text1 的哈希值或计算具有相同内容的 text2 的哈希值时，将直接返回缓存的哈希值，而不进行重新计算。
由于 String 对象是不可变的，其哈希值在创建后不会发生变化。这使得 String 类可以缓存哈希值，提高哈希表等数据结构的性能。如果 String 是可变的，那么在每次修改时都需要重新计算哈希值，这会降低性能。
第三，可以实现字符串常量池，Java 会将相同内容的字符串存储在字符串常量池中。这样，具有相同内容的字符串变量可以指向同一个 String 对象，节省内存空间。
“由于字符串的不可变性，String 类的一些方法实现最终都返回了新的字符串对象。”
“就拿 substring() 方法来说。”
12345678910public String substring(int beginIndex) {    if (beginIndex &lt; 0) {        throw new StringIndexOutOfBoundsException(beginIndex);    }    int subLen &#x3D; value.length - beginIndex;    if (subLen &lt; 0) {        throw new StringIndexOutOfBoundsException(subLen);    }    return (beginIndex &#x3D;&#x3D; 0) ? this : new String(value, beginIndex, subLen);}
substring() 方法用于截取字符串，最终返回的都是 new 出来的新字符串对象。
“还有 concat() 方法。”
12345678910111213141516171819public String concat(String str) {    int olen &#x3D; str.length();    if (olen &#x3D;&#x3D; 0) {        return this;    }    if (coder() &#x3D;&#x3D; str.coder()) {        byte[] val &#x3D; this.value;        byte[] oval &#x3D; str.value;        int len &#x3D; val.length + oval.length;        byte[] buf &#x3D; Arrays.copyOf(val, len);        System.arraycopy(oval, 0, buf, val.length, oval.length);        return new String(buf, coder);    }    int len &#x3D; length();    byte[] buf &#x3D; StringUTF16.newBytesFor(len + olen);    getBytes(buf, 0, UTF16);    str.getBytes(buf, len, UTF16);    return new String(buf, UTF16);}
concat() 方法用于拼接字符串，不管编码是否一致，最终也返回的是新的字符串对象。
“ replace() 替换方法其实也一样，三妹，你可以自己一会看一下源码，也是返回新的字符串对象。”
“这就意味着，不管是截取、拼接，还是替换，都不是在原有的字符串上进行的，而是重新生成了新的字符串对象。也就是说，这些操作执行过后，原来的字符串对象并没有发生改变。”
“String 对象一旦被创建后就固定不变了，对 String 对象的任何修改都不会影响到原来的字符串对象，都会生成新的字符串对象。”
2.6 深入理解Java字符串常量池 
“今天我们来学习一下字符串常量池，这是字符串中非常关键的一个知识点。”
new String(“二哥”)创建了几个对象 
“先从这道面试题开始吧！”
“这行代码创建了几个对象？”
“不就一个吗？”
“不，两个！”“使用 new 关键字创建一个字符串对象时，Java 虚拟机会先在字符串常量池中查找有没有‘二哥’这个字符串对象，如果有，就不会在字符串常量池中创建‘二哥’这个对象了，直接在堆中创建一个‘二哥’的字符串对象，然后将堆中这个‘二哥’的对象地址返回赋值给变量 s。”
“如果没有，先在字符串常量池中创建一个‘二哥’的字符串对象，然后再在堆中创建一个‘二哥’的字符串对象，然后将堆中这个‘二哥’的字符串对象地址返回赋值给变量 s。”
我画图表示一下，会更加清楚。

在Java中，栈上存储的是基本数据类型的变量和对象的引用，而对象本身则存储在堆上。
对于这行代码 String s &#x3D; new String(“二哥”); ，它创建了两个对象：一个是字符串对象 “二哥”，它被添加到了字符串常量池中，另一个是通过 new String() 构造函数创建的字符串对象 “二哥”，它被分配在堆内存中，同时引用变量 s 存储在栈上，它指向堆内存中的字符串对象 “二哥”。
“为什么要先在字符串常量池中创建对象，然后再在堆上创建呢？这样不就多此一举了？”
我回答，“是的。由于字符串的使用频率实在是太高了，所以 Java 虚拟机为了提高性能和减少内存开销，在创建字符串对象的时候进行了一些优化，特意为字符串开辟了一块空间——也就是字符串常量池。”
字符串常量池的作用 
通常情况下，我们会采用双引号的方式来创建字符串对象，而不是通过 new 关键字的方式，就像下面 这样，这样就不会多此一举：
当执行 String s &#x3D; “三妹” 时，Java 虚拟机会先在字符串常量池中查找有没有“三妹”这个字符串对象，如果有，则不创建任何对象，直接将字符串常量池中这个“三妹”的对象地址返回，赋给变量 s；如果没有，在字符串常量池中创建“三妹”这个对象，然后将其地址返回，赋给变量 s。

Java 虚拟机创建了一个字符串对象 “三妹”，它被添加到了字符串常量池中，同时引用变量 s 存储在栈上，它指向字符串常量池中的字符串对象 “三妹”。你看，是不是省了一步，比之前高效了。
““有了字符串常量池，就可以通过双引号的方式直接创建字符串对象，不用再通过 new 的方式在堆中创建对象了，对吧？”
“是滴。new 的方式始终会创建一个对象，不管字符串的内容是否已经存在，而双引号的方式会重复利用字符串常量池中已经存在的对象。”我说。
来看下面这个例子：
12String s &#x3D; new String(&quot;二哥&quot;);String s1 &#x3D; new String(&quot;二哥&quot;);
按照我们之前的分析，这两行代码会创建三个对象，字符串常量池中一个，堆上两个。
再来看下面这个例子：
12String s &#x3D; &quot;三妹&quot;;String s1 &#x3D; &quot;三妹&quot;;
这两行代码只会创建一个对象，就是字符串常量池中的那个。这样的话，性能肯定就提高了！
字符串常量池在内存中的什么位置呢？ 
分为三个阶段。
Java 7 之前 
在 Java 7 之前，字符串常量池位于永久代（Permanent Generation）的内存区域中，主要用来存储一些字符串常量（静态数据的一种）。永久代是 Java 堆（Java Heap）的一部分，用于存储类信息、方法信息、常量池信息等静态数据。
而 Java 堆是 JVM 中存储对象实例和数组的内存区域，也就是说，永久代是 Java 堆的一个子区域。换句话说，永久代中存储的静态数据与堆中存储的对象实例和数组是分开的，它们有不同的生命周期和分配方式。
但是，永久代和堆的大小是相互影响的，因为它们都使用了 JVM 堆内存，因此它们的大小都受到 JVM 堆大小的限制。
于是，当我们创建一个字符串常量时，它会被储存在永久代的字符串常量池中。如果我们创建一个普通字符串对象，则它将被储存在堆中。如果字符串对象的内容是一个已经存在于字符串常量池中的字符串常量，那么这个对象会指向已经存在的字符串常量，而不是重新创建一个新的字符串对象。
画幅图，大概就是这个样子。

Java 7 
需要注意的是，永久代的大小是有限的，并且很难准确地确定一个应用程序需要多少永久代空间。如果我们在应用程序中使用了大量的类、方法、常量等静态数据，就有可能导致永久代空间不足。这种情况下，JVM 就会抛出 OutOfMemoryError 错误。
因此，从 Java 7 开始，为了解决永久代空间不足的问题，将字符串常量池从永久代中移动到堆中。这个改变也是为了更好地支持动态语言的运行时特性。
再画幅图，大概就是这样子。

Java 8 
到了 Java 8，永久代（PermGen）被取消，并由元空间（Metaspace）取代。元空间是一块本机内存区域，和 JVM 内存区域是分开的。不过，元空间的作用依然和之前的永久代一样，用于存储类信息、方法信息、常量池信息等静态数据。
与永久代不同，元空间具有一些优点，例如：

它不会导致 OutOfMemoryError 错误，因为元空间的大小可以动态调整。
元空间使用本机内存，而不是 JVM 堆内存，这可以避免堆内存的碎片化问题。
元空间中的垃圾收集与堆中的垃圾收集是分离的，这可以避免应用程序在运行过程中因为进行类加载和卸载而频繁地触发 Full GC。

再画幅图，对比来看一下，就会一目了然。

永久代、方法区、元空间 
“能再简单给我解释一下方法区，永久代和元空间的概念吗？有点模糊。”
“可以呀。”

方法区是 Java 虚拟机规范中的一个概念，就像是一个接口吧；
永久代是 HotSpot 虚拟机中对方法区的一个实现，就像是接口的实现类；
Java 8 的时候，移除了永久代，取而代之的是元空间，是方法区的另外一种实现，更灵活了。

永久代是放在运行时数据区中的，所以它的大小受到 Java 虚拟机本身大小的限制，所以 Java 8 之前，会经常遇到 java.lang.OutOfMemoryError: PremGen Space 的异常，PremGen Space 就是方法区的意思；而元空间是直接放在内存中的，所以只受本机可用内存的限制。
2.7 详解 String.intern() 方法“看一下美团技术团队深入解析 String.intern() 文章”
要理解美团技术团队的这篇文章，你只需要记住这几点内容：
第一，使用双引号声明的字符串对象会保存在字符串常量池中。
第二，使用 new 关键字创建的字符串对象会先从字符串常量池中找，如果没找到就创建一个，然后再在堆中创建字符串对象；如果找到了，就直接在堆中创建字符串对象。
第三，针对没有使用双引号声明的字符串对象来说，就像下面代码中的 s1 那样：
1String s1 &#x3D; new String(&quot;二哥&quot;) + new String(&quot;三妹&quot;);
如果想把 s1 的内容也放入字符串常量池的话，可以调用 intern() 方法来完成。
不过，需要注意的是，Java 7 的时候，字符串常量池从永久代中移动到了堆中，虽然此时永久代还没有完全被移除。Java 8 的时候，永久代被彻底移除。
这个变化也直接影响了  String.intern() 方法在执行时的策略，Java 7 之前，执行 String.intern() 方法的时候，不管对象在堆中是否已经创建，字符串常量池中仍然会创建一个内容完全相同的新对象； Java 7 之后呢，由于字符串常量池放在了堆中，执行 String.intern() 方法的时候，如果对象在堆中已经创建了，字符串常量池中就不需要再创建新的对象了，而是直接保存堆中对象的引用，也就节省了一部分的内存空间。
“先来猜猜这段代码输出的结果吧。”
123String s1 &#x3D; new String(&quot;二哥三妹&quot;);String s2 &#x3D; s1.intern();System.out.println(s1 &#x3D;&#x3D; s2);
第一行代码，字符串常量池中会先创建一个“二哥三妹”的对象，然后堆中会再创建一个“二哥三妹”的对象，s1 引用的是堆中的对象。
第二行代码，对 s1 执行 intern() 方法，该方法会从字符串常量池中查找“二哥三妹”这个字符串是否存在，此时是存在的，所以 s2 引用的是字符串常量池中的对象。
也就意味着 s1 和 s2 的引用地址是不同的，一个来自堆，一个来自字符串常量池，所以输出的结果为 false。
“来看一下运行结果。”
1false
“我来画幅图，帮助你理解下。”

“好，我们再来看下面这段代码。”
123String s1 &#x3D; new String(&quot;二哥&quot;) + new String(&quot;三妹&quot;);String s2 &#x3D; s1.intern();System.out.println(s1 &#x3D;&#x3D; s2);
“难道也输出 false ？”
“不，这段代码会输出 true。”
“为啥呀？”
第一行代码，会在字符串常量池中创建两个对象，一个是“二哥”，一个是“三妹”，然后在堆中会创建两个匿名对象“二哥”和“三妹”，最后还有一个“二哥三妹”的对象（稍后会解释），s1 引用的是堆中“二哥三妹”这个对象。
第二行代码，对 s1 执行 intern() 方法，该方法会从字符串常量池中查找“二哥三妹”这个对象是否存在，此时不存在的，但堆中已经存在了，所以字符串常量池中保存的是堆中这个“二哥三妹”对象的引用，也就是说，s2 和 s1 的引用地址是相同的，所以输出的结果为 true。
“来看一下运行结果。”
1true
“我再来画幅图，帮助你理解下。”

“不过，我有一个疑惑，“二哥三妹”这个对象是什么时候创建的呢？”
“不错嘛，能抓住问题的关键。再来解释一下 String s1 &#x3D; new String(“二哥”) + new String(“三妹”) 这行代码。”

创建 “二哥” 字符串对象，存储在字符串常量池中。
创建 “三妹” 字符串对象，存储在字符串常量池中。
执行 new String(“二哥”) ，在堆上创建一个字符串对象，内容为 “二哥”。
执行 new String(“三妹”) ，在堆上创建一个字符串对象，内容为 “三妹”。
执行 new String(“二哥”) + new String(“三妹”) ，会创建一个 StringBuilder 对象，并将 “二哥” 和 “三妹” 追加到其中，然后调用 StringBuilder 对象的 toString() 方法，将其转换为一个新的字符串对象，内容为 “二哥三妹”。这个新的字符串对象存储在堆上。

也就是说，当编译器遇到 + 号这个操作符的时候，会将 new String(“二哥”) + new String(“三妹”) 这行代码编译为以下代码：
1new StringBuilder().append(&quot;二哥&quot;).append(&quot;三妹&quot;).toString();
实际执行过程如下：

创建一个 StringBuilder 对象。
在 StringBuilder 对象上调用 append(“二哥”)，将 “二哥” 追加到 StringBuilder 中。
在 StringBuilder 对象上调用 append(“三妹”)，将 “三妹” 追加到 StringBuilder 中。
在 StringBuilder 对象上调用 toString() 方法，将 StringBuilder 转换为一个新的字符串对象，内容为 “二哥三妹”。

关于 StringBuilder，我们随后会详细地讲到。今天先了解到这。
不过需要注意的是，尽管 intern 可以确保所有具有相同内容的字符串共享相同的内存空间，但也不要烂用 intern，因为任何的缓存池都是有大小限制的，不能无缘无故就占用了相对稀缺的缓存空间，导致其他字符串没有坑位可占。
另外，字符串常量池本质上是一个固定大小的 StringTable，如果放进去的字符串过多，就会造成严重的哈希冲突，从而导致链表变长，链表变长也就意味着字符串常量池的性能会大幅下降，因为要一个一个找是需要花费时间的。
2.8 String、StringBuilder、StringBuffer“上一篇深入理解 String.intern() 讲到了 StringBuilder，这一节我们就来聊聊吧！”
由于字符串是不可变的，所以当遇到字符串拼接（尤其是使用 +号操作符）的时候，就需要考量性能的问题，你不能毫无顾虑地生产太多 String 对象，对珍贵的内存造成不必要的压力。
于是 Java 就设计了一个专门用来解决此问题的 StringBuffer 类。
123456789101112131415public final class StringBuffer extends AbstractStringBuilder implements Serializable, CharSequence {    public StringBuffer() {        super(16);    }        public synchronized StringBuffer append(String str) {        super.append(str);        return this;    }    public synchronized String toString() {        return new String(value, 0, count);    }    &#x2F;&#x2F; 其他方法}
不过，由于 StringBuffer 操作字符串的方法加了 synchronized 关键字进行了同步，主要是考虑到多线程环境下的安全问题，所以执行效率会比较低。
于是 Java 就给 StringBuffer “生了个兄弟”，名叫 StringBuilder，说，“孩子，你别管线程安全了，你就在单线程环境下使用，这样效率会高得多，如果要在多线程环境下修改字符串，你到时候可以使用 ThreadLocal 来避免多线程冲突。”
1234567891011121314public final class StringBuilder extends AbstractStringBuilder    implements java.io.Serializable, CharSequence{    &#x2F;&#x2F; ...    public StringBuilder append(String str) {        super.append(str);        return this;    }    public String toString() {        &#x2F;&#x2F; Create a copy, don&#39;t share the array        return new String(value, 0, count);    }    &#x2F;&#x2F; ...}
除了类名不同，方法没有加 synchronized，基本上完全一样。
实际开发中，StringBuilder 的使用频率也是远高于 StringBuffer，甚至可以这么说，StringBuilder 完全取代了 StringBuffer。
之前我们也曾聊过，Java 是一门解释型的编程语言，所以当编译器遇到 + 号这个操作符的时候，会将 new String(“二哥”) + new String(“三妹”) 这行代码编译为以下代码：
1new StringBuilder().append(&quot;二哥&quot;).append(&quot;三妹&quot;).toString();
这个过程是我们看不见的，但这正是 Java 的“智能”之处，它可以在编译的时候偷偷地帮我们做很多优化，这样既可以提高我们的开发效率（ + 号写起来比创建 StringBuilder 对象便捷得多），也不会影响 JVM 的执行效率。
当然了，如果我们使用 javap 反编译 new String(“二哥”) + new String(“三妹”) 的字节码的时候，也是能看出 StringBuilder 的影子的。
12345678910111213141516171819200: new           #2                  &#x2F;&#x2F; class java&#x2F;lang&#x2F;StringBuilder3: dup4: invokespecial #3                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.&quot;&lt;init&gt;&quot;:()V7: new           #4                  &#x2F;&#x2F; class java&#x2F;lang&#x2F;String10: dup11: ldc           #5                  &#x2F;&#x2F; String 二哥13: invokespecial #6                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;String.&quot;&lt;init&gt;&quot;:(Ljava&#x2F;lang&#x2F;String;)V16: invokevirtual #7                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;19: new           #4                  &#x2F;&#x2F; class java&#x2F;lang&#x2F;String22: dup23: ldc           #8                  &#x2F;&#x2F; String 三妹25: invokespecial #6                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;String.&quot;&lt;init&gt;&quot;:(Ljava&#x2F;lang&#x2F;String;)V28: invokevirtual #7                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;31: invokevirtual #9                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.toString:()Ljava&#x2F;lang&#x2F;String;34: areturn
可以看到 Java 编译器将字符串拼接操作（ + ）转换为了 StringBuilder 对象的 append 方法，然后再调用 StringBuilder 对象的 toString 方法返回拼接后的字符串。
来看一下 StringBuilder 的 toString 方法：
123public String toString() {    return new String(value, 0, count);}
value 是一个 char 类型的数组：
1234&#x2F;** * The value is used for character storage. *&#x2F;char[] value;
在 StringBuilder 对象创建时，会为 value 分配一定的内存空间（初始容量 16），用于存储字符串。
1234567&#x2F;** * Constructs a string builder with no characters in it and an * initial capacity of 16 characters. *&#x2F;public StringBuilder() {    super(16);}
随着字符串的拼接，value 数组的长度会不断增加，因此在 StringBuilder 对象的实现中，value 数组的长度是可以动态扩展的，就像ArrayList那样。
继续来看 StringBuilder 的 toString 方法：
123public String toString() {    return new String(value, 0, count);}
value 用于存储 StringBuilder 对象中包含的字符序列。count 是一个 int 类型的变量，表示字符序列的长度。toString() 方法会调用 new String(value, 0, count) ，使用 value 数组中从 0 开始的前 count 个元素创建一个新的字符串对象，并将其返回。
再来看一下 append 方法：
1234public StringBuilder append(String str) {    super.append(str);    return this;}
实际上是调用了 AbstractStringBuilder 中的 append(String str) 方法。在 AbstractStringBuilder 中，append(String str) 方法会检查当前字符序列中的字符是否够用，如果不够用则会进行扩容，并将指定字符串追加到字符序列的末尾。
123456789101112131415161718192021222324252627&#x2F;** * Appends the specified string to this character sequence. * &lt;p&gt; * The characters of the {@code String} argument are appended, in order, * increasing the length of this sequence by the length of the argument. * If {@code str} is {@code null}, then the four characters {@code &quot;null&quot;} * are appended. * &lt;p&gt; * Let &lt;i&gt;n&lt;&#x2F;i&gt; be the length of this character sequence just prior to * execution of the {@code append} method. Then the character at index * &lt;i&gt;k&lt;&#x2F;i&gt; in this character sequence is equal to the character at index * &lt;i&gt;k&lt;&#x2F;i&gt; in the argument {@code str}, if &lt;i&gt;k&lt;&#x2F;i&gt; is less than * &lt;i&gt;n&lt;&#x2F;i&gt;; otherwise, it is equal to the character at index * &lt;i&gt;k-n&lt;&#x2F;i&gt; in the argument {@code str}. * * @param   str   a string. * @return  a reference to this object. *&#x2F;public AbstractStringBuilder append(String str) {    if (str &#x3D;&#x3D; null)        return appendNull();    int len &#x3D; str.length();    ensureCapacityInternal(count + len);    str.getChars(0, len, value, count);    count +&#x3D; len;    return this;}
append(String str) 方法将指定字符串追加到当前字符序列中。如果指定字符串为 null，则追加字符串 “null”；否则会检查指定字符串的长度，然后根据当前字符序列中的字符数和指定字符串的长度来判断是否需要扩容。
如果需要扩容，则会调用 ensureCapacityInternal(int minimumCapacity)方法进行扩容。扩容之后，将指定字符串的字符拷贝到字符序列中。
来看一下 ensureCapacityInternal 方法：
12345678910111213141516private void ensureCapacityInternal(int minimumCapacity) {    &#x2F;&#x2F; overflow-conscious code    if (minimumCapacity - value.length &gt; 0)        expandCapacity(minimumCapacity);}void expandCapacity(int minimumCapacity) {    int newCapacity &#x3D; value.length * 2 + 2;    if (newCapacity - minimumCapacity &lt; 0)        newCapacity &#x3D; minimumCapacity;    if (newCapacity &lt; 0) {        if (minimumCapacity &lt; 0) &#x2F;&#x2F; overflow            throw new OutOfMemoryError();        newCapacity &#x3D; Integer.MAX_VALUE;    }    value &#x3D; Arrays.copyOf(value, newCapacity);}
ensureCapacityInternal(int minimumCapacity) 方法用于确保当前字符序列的容量至少等于指定的最小容量 minimumCapacity。如果当前容量小于指定的容量，就会为字符序列分配一个新的内部数组。新容量的计算方式如下：

如果指定的最小容量大于当前容量，则新容量为两倍的旧容量加上 2；
如果指定的最小容量小于等于当前容量，则不会进行扩容，直接返回当前对象。

在进行扩容之前， ensureCapacityInternal(int minimumCapacity) 方法会先检查当前字符序列的容量是否足够，如果不足就会调用 expandCapacity(int minimumCapacity) 方法进行扩容。
expandCapacity(int minimumCapacity) 方法首先计算出新容量，然后使用 Arrays.copyOf(char[] original, int newLength) 方法将原字符数组扩容到新容量的大小。
关于扩容，后面在讲ArrayList的时候会再次说明，今天就先聊到这吧。
2.9 String相等判断“如何比较两个字符串相等啊？”
“这个问题看似简单，却在 Stack Overflow 上有超过 370 万+的访问量。”我说，“这个问题也可以引申为 .equals() 和 ‘\&#x3D;&#x3D;’ 操作符有什么区别。”

“\&#x3D;&#x3D;”操作符用于比较两个对象的地址是否相等。
.equals() 方法用于比较两个对象的内容是否相等。

“我来举个不恰当又很恰当的例子，一看你就明白了。”
有一对双胞胎，姐姐叫阿丽塔，妹妹叫洛丽塔。我们普通人可能完全无法分辨谁是姐姐谁是妹妹，可她们的妈妈却可以轻而易举地辨认出。

.equals() 就好像我们普通人，看见阿丽塔以为是洛丽塔，看见洛丽塔以为是阿丽塔，看起来一样就觉得她们是同一个人；“\&#x3D;&#x3D;”操作符就好像她们的妈妈，要求更严格，观察更细致，一眼就能分辨出谁是姐姐谁是妹妹。
1234String alita &#x3D; new String(&quot;小萝莉&quot;);String luolita &#x3D; new String(&quot;小萝莉&quot;);System.out.println(alita.equals(luolita)); &#x2F;&#x2F; trueSystem.out.println(alita &#x3D;&#x3D; luolita); &#x2F;&#x2F; false
就上面这段代码来说， .equals() 输出的结果为 true，而“\&#x3D;&#x3D;”操作符输出的结果为 false——前者要求内容相等就可以，后者要求必须是同一个对象。
“之前已经学过了，Java 的所有类都默认地继承 Object 这个超类，该类有一个名为 .equals() 的方法。”一边说，我一边打开了 Object 类的源码。
123public boolean equals(Object obj) {    return (this &#x3D;&#x3D; obj);}
你看，Object 类的 .equals() 方法默认采用的是“\&#x3D;&#x3D;”操作符进行比较。假如子类没有重写该方法的话，那么“\&#x3D;&#x3D;”操作符和 .equals() 方法的功效就完全一样——比较两个对象的内存地址是否相等。
但实际情况中，有不少类重写了 .equals() 方法，因为比较内存地址的要求比较严格，不太符合现实中所有的场景需求。拿 String 类来说，我们在比较字符串的时候，的确只想判断它们俩的内容是相等的就可以了，并不想比较它们俩是不是同一个对象。
况且，字符串有字符串常量池的概念，本身就推荐使用 String s &#x3D; “字符串” 这种形式来创建字符串对象，而不是通过 new 关键字的方式，因为可以把字符串缓存在字符串常量池中，方便下次使用，不用遇到 new 就在堆上开辟一块新的空间。
“那就来看一下 String 类的 .equals() 方法的源码吧。”
12345678910111213public boolean equals(Object anObject) {    if (this &#x3D;&#x3D; anObject) {        return true;    }    if (anObject instanceof String) {        String aString &#x3D; (String)anObject;        if (coder() &#x3D;&#x3D; aString.coder()) {            return isLatin1() ? StringLatin1.equals(value, aString.value)                    : StringUTF16.equals(value, aString.value);        }    }    return false;}
首先，如果两个字符串对象的可以“\&#x3D;&#x3D;”，那就直接返回 true 了，因为这种情况下，字符串内容是必然相等的。否则就按照字符编码进行比较，分为 UTF16 和 Latin1，差别不是很大，就拿 Latin1 的来说吧。
123456789101112@HotSpotIntrinsicCandidatepublic static boolean equals(byte[] value, byte[] other) {    if (value.length &#x3D;&#x3D; other.length) {        for (int i &#x3D; 0; i &lt; value.length; i++) {            if (value[i] !&#x3D; other[i]) {                return false;            }        }        return true;    }    return false;}
这个 JDK 版本是 Java 17，也就是最新的 LTS（长期支持）版本。该版本中，String 类使用字节数组实现的，所以比较两个字符串的内容是否相等时，可以先比较字节数组的长度是否相等，不相等就直接返回 false；否则就遍历两个字符串的字节数组，只有有一个字节不相等，就返回 false。
这是 Java 8 中的 equals 方法源码：
12345678910111213141516171819202122232425public boolean equals(Object anObject) {    &#x2F;&#x2F; 判断是否为同一对象    if (this &#x3D;&#x3D; anObject) {        return true;    }    &#x2F;&#x2F; 判断对象是否为 String 类型    if (anObject instanceof String) {        String anotherString &#x3D; (String)anObject;        int n &#x3D; value.length;        &#x2F;&#x2F; 判断字符串长度是否相等        if (n &#x3D;&#x3D; anotherString.value.length) {            char v1[] &#x3D; value;            char v2[] &#x3D; anotherString.value;            int i &#x3D; 0;            &#x2F;&#x2F; 判断每个字符是否相等            while (n-- !&#x3D; 0) {                if (v1[i] !&#x3D; v2[i])                    return false;                i++;            }            return true;        }    }    return false;}
JDK 8 比 JDK 17 更容易懂一些：首先判断两个对象是否为同一个对象，如果是，则返回 true。接着，判断对象是否为 String 类型，如果不是，则返回 false。如果对象为 String 类型，则比较两个字符串的长度是否相等，如果长度不相等，则返回 false。如果长度相等，则逐个比较每个字符是否相等，如果都相等，则返回 true，否则返回 false。
“那出几道题考考你吧！”
第一题：
1new String(&quot;小萝莉&quot;).equals(&quot;小萝莉&quot;)
“输出什么呢？”我问。
“ .equals() 比较的是两个字符串对象的内容是否相等，所以结果为 true。”
第二题：
1new String(&quot;小萝莉&quot;) &#x3D;&#x3D; &quot;小萝莉&quot;
“&#x3D;&#x3D;操作符左侧的是在堆中创建的对象，右侧是在字符串常量池中的对象，尽管内容相同，但内存地址不同，所以返回 false。”
第三题：
1new String(&quot;小萝莉&quot;) &#x3D;&#x3D; new String(&quot;小萝莉&quot;)
“new 出来的对象肯定是完全不同的内存地址，所以返回 false。”
第四题：
1&quot;小萝莉&quot; &#x3D;&#x3D; &quot;小萝莉&quot;
“字符串常量池中只会有一个相同内容的对象，所以返回 true。”
第五题：
1&quot;小萝莉&quot; &#x3D;&#x3D; &quot;小&quot; + &quot;萝莉&quot;
“由于‘小’和‘萝莉’都在字符串常量池，所以编译器在遇到‘+’操作符的时候将其自动优化为“小萝莉”，所以返回 true。”
PS：至于为什么，查看这篇String、StringBuilder、StringBuffer
第六题：
1new String(&quot;小萝莉&quot;).intern() &#x3D;&#x3D; &quot;小萝莉&quot;
“ new String(“小萝莉”) 在执行的时候，会先在字符串常量池中创建对象，然后再在堆中创建对象；执行 intern() 方法的时候发现字符串常量池中已经有了‘小萝莉’这个对象，所以就直接返回字符串常量池中的对象引用了，那再与字符串常量池中的‘小萝莉’比较，当然会返回 true 了。”
PS：intern 方法我们之前已经深究过了。
“哥再给你补充一点。”
“如果要进行两个字符串对象的内容比较，除了 .equals() 方法，还有其他两个可选的方案。”
1） Objects.equals()
Objects.equals() 这个静态方法的优势在于不需要在调用之前判空。
123public static boolean equals(Object a, Object b) {    return (a &#x3D;&#x3D; b) || (a !&#x3D; null &amp;&amp; a.equals(b));}
如果直接使用 a.equals(b) ，则需要在调用之前对 a 进行判空，否则可能会抛出空指针 java.lang.NullPointerException 。 Objects.equals() 用起来就完全没有这个担心。
12345Objects.equals(&quot;小萝莉&quot;, new String(&quot;小&quot; + &quot;萝莉&quot;)) &#x2F;&#x2F; --&gt; trueObjects.equals(null, new String(&quot;小&quot; + &quot;萝莉&quot;)); &#x2F;&#x2F; --&gt; falseObjects.equals(null, null) &#x2F;&#x2F; --&gt; trueString a &#x3D; null;a.equals(new String(&quot;小&quot; + &quot;萝莉&quot;)); &#x2F;&#x2F; throw exception
2）String 类的 .contentEquals()
.contentEquals() 的优势在于可以将字符串与任何的字符序列（StringBuffer、StringBuilder、String、CharSequence）进行比较。
12345678910111213141516171819202122232425262728293031323334public boolean contentEquals(CharSequence cs) {    &#x2F;&#x2F; Argument is a StringBuffer, StringBuilder    if (cs instanceof AbstractStringBuilder) {        if (cs instanceof StringBuffer) {            synchronized(cs) {                return nonSyncContentEquals((AbstractStringBuilder)cs);            }        } else {            return nonSyncContentEquals((AbstractStringBuilder)cs);        }    }    &#x2F;&#x2F; Argument is a String    if (cs instanceof String) {        return equals(cs);    }    &#x2F;&#x2F; Argument is a generic CharSequence    int n &#x3D; cs.length();    if (n !&#x3D; length()) {        return false;    }    byte[] val &#x3D; this.value;    if (isLatin1()) {        for (int i &#x3D; 0; i &lt; n; i++) {            if ((val[i] &amp; 0xff) !&#x3D; cs.charAt(i)) {                return false;            }        }    } else {        if (!StringUTF16.contentEquals(val, cs, n)) {            return false;        }    }    return true;}
从源码上可以看得出，如果 cs 是 StringBuffer，该方法还会进行同步，非常的智能化；如果是 String 的话，其实调用的还是 equals() 方法。当然了，这也就意味着使用该方法进行比较的时候，多出来了很多步骤，性能上有些损失。
同样来看一下 JDK 8 的源码：
1234567891011121314151617181920212223242526272829303132public boolean contentEquals(CharSequence cs) {    &#x2F;&#x2F; argument can be any CharSequence implementation    if (cs.length() !&#x3D; value.length) {        return false;    }    &#x2F;&#x2F; Argument is a StringBuffer, StringBuilder or String    if (cs instanceof AbstractStringBuilder) {        char v1[] &#x3D; value;        char v2[] &#x3D; ((AbstractStringBuilder)cs).getValue();        int i &#x3D; 0;        int n &#x3D; value.length;        while (n-- !&#x3D; 0) {            if (v1[i] !&#x3D; v2[i])                return false;            i++;        }        return true;    }    &#x2F;&#x2F; Argument is a String    if (cs.equals(this))        return true;    &#x2F;&#x2F; Argument is a non-String, non-AbstractStringBuilder CharSequence    char v1[] &#x3D; value;    int i &#x3D; 0;    int n &#x3D; value.length;    while (n-- !&#x3D; 0) {        if (v1[i] !&#x3D; cs.charAt(i))            return false;        i++;    }    return true;}
   同样更容易理解一些：首先判断参数长度是否相等，不相等则返回 false。如果参数是 AbstractStringBuilder 的实例，则取出其 char 数组，遍历比较两个 char 数组的每个元素是否相等。如果参数是 String 的实例，则直接调用 equals 方法比较两个字符串是否相等。如果参数是其他实现了 CharSequence 接口的对象，则遍历比较两个对象的每个字符是否相等。    
2.10 String拼接“《Java 开发手册》上有这么一段内容：循环体内，拼接字符串最好使用 StringBuilder 的 append() 方法，而不是 + 号操作符。这是为什么呀？”
“其实这个问题，我们之前已经聊过。”
javap 探究+号操作符拼接字符串的本质 
“+ 号操作符其实被 Java 在编译的时候重新解释了，换一种说法就是，+ 号操作符是一种语法糖，让字符串的拼接变得更简便了。”
1234567class Demo {    public static void main(String[] args) {        String chenmo &#x3D; &quot;沉默&quot;;        String wanger &#x3D; &quot;王二&quot;;        System.out.println(chenmo + wanger);    }}
在 Java 8 的环境下，使用 javap -c Demo.class 反编译字节码后，可以看到以下内容：
12345678910111213141516171819202122232425262728293031Compiled from &quot;Demo.java&quot;class Demo {  Demo();    Code:       0: aload_0       1: invokespecial #1                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V       4: return  public static void main(java.lang.String[]);    Code:       0: ldc           #2                  &#x2F;&#x2F; String 沉默       2: astore_1       3: ldc           #3                  &#x2F;&#x2F; String 王二       5: astore_2       6: getstatic     #4                  &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;       9: new           #5                  &#x2F;&#x2F; class java&#x2F;lang&#x2F;StringBuilder      12: dup      13: invokespecial #6                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.&quot;&lt;init&gt;&quot;:()V      16: aload_1      17: invokevirtual #7                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;      20: aload_2      21: invokevirtual #7                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;      24: invokevirtual #8                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.toString:()Ljava&#x2F;lang&#x2F;String;      27: invokevirtual #9                  &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.println:(Ljava&#x2F;lang&#x2F;String;)V      30: return}
“这里有一个 new 关键字，并且 class 类型为 java&#x2F;lang&#x2F;StringBuilder 。”我指着标号为 9 的那行说，“这意味着新建了一个 StringBuilder 的对象。”
“然后看标号为 17 的这行，是一个 invokevirtual 指令，用于调用对象的方法，也就是 StringBuilder 对象的 append() 方法。”
“也就意味着把 chenmo（”沉默”）这个字符串添加到 StringBuilder 对象中了。”
“再往下看，标号为 21 的这行，又调用了一次 append() 方法，意味着把 wanger（”王二”）这个字符串添加到 StringBuilder 对象中了。”
换成 Java 代码来表示的话，大概是这个样子：
1234567class Demo {    public static void main(String[] args) {        String chenmo &#x3D; &quot;沉默&quot;;        String wanger &#x3D; &quot;王二&quot;;        System.out.println((new StringBuilder(chenmo)).append(wanger).toString());    }}
“哦，原来编译的时候把“+”号操作符替换成了 StringBuilder 的 append() 方法啊。”
“是的，不过到了 Java 9（不是长期支持版本，所以我会拿 Java 11 来演示），情况发生了一些改变，同样的代码，字节码指令完全不同了。”我说。
同样的代码，在 Java 11 的环境下，字节码指令是这样的：
1234567891011121314151617181920212223242526272829303132333435Compiled from &quot;Demo.java&quot;public class com.itwanger.thirtyseven.Demo {  public com.itwanger.thirtyseven.Demo();    Code:       0: aload_0       1: invokespecial #1                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V       4: return  public static void main(java.lang.String[]);    Code:       0: ldc           #2                  &#x2F;&#x2F; String       2: astore_1       3: iconst_0       4: istore_2       5: iload_2       6: bipush        10       8: if_icmpge     41      11: new           #3                  &#x2F;&#x2F; class java&#x2F;lang&#x2F;String      14: dup      15: ldc           #4                  &#x2F;&#x2F; String 沉默      17: invokespecial #5                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;String.&quot;&lt;init&gt;&quot;:(Ljava&#x2F;lang&#x2F;String;)V      20: astore_3      21: ldc           #6                  &#x2F;&#x2F; String 王二      23: astore        4      25: aload_1      26: aload_3      27: aload         4      29: invokedynamic #7,  0              &#x2F;&#x2F; InvokeDynamic #0:makeConcatWithConstants:(Ljava&#x2F;lang&#x2F;String;Ljava&#x2F;lang&#x2F;String;Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;String;      34: astore_1      35: iinc          2, 1      38: goto          5      41: return}
看标号为 29 的这行，字节码指令为 invokedynamic ，该指令允许由应用级的代码来决定方法解析，所谓的应用级的代码其实是一个方法——被称为引导方法（Bootstrap Method），简称 BSM，BSM 会返回一个 CallSite（调用点） 对象，这个对象就和 invokedynamic 指令链接在一起。以后再执行这条 invokedynamic 指令时就不会创建新的 CallSite 对象。CallSite 其实就是一个 MethodHandle（方法句柄）的 holder，指向一个调用点真正执行的方法——此时就是 StringConcatFactory.makeConcatWithConstants() 方法。
“好吧，总之就是 Java 9 以后，JDK 用了另外一种方法来动态解释 + 号操作符，具体的实现方式在字节码指令层面已经看不到了，所以我就以 Java 8 来继续讲解吧。”
为什么要编译为 StringBuilder.append 
“再回到《Java 开发手册》上的那段内容：循环体内，拼接字符串最好使用 StringBuilder 的 append() 方法，而不是 + 号操作符。原因就在于循环体内如果用 + 号操作符的话，就会产生大量的 StringBuilder 对象，不仅占用了更多的内存空间，还会让 Java 虚拟机不停的进行垃圾回收，从而降低了程序的性能。”
更好的写法就是在循环的外部新建一个 StringBuilder 对象，然后使用 append() 方法将循环体内的字符串添加进来：
123456789101112class Demo {    public static void main(String[] args) {        StringBuilder sb &#x3D; new StringBuilder();        for (int i &#x3D; 1; i &lt; 10; i++) {            String chenmo &#x3D; &quot;沉默&quot;;            String wanger &#x3D; &quot;王二&quot;;            sb.append(chenmo);            sb.append(wanger);        }        System.out.println(sb);    }}
来做个小测试。
第一个，for 循环中使用”+”号操作符。
1234String result &#x3D; &quot;&quot;;for (int i &#x3D; 0; i &lt; 100000; i++) {    result +&#x3D; &quot;六六六&quot;;}
第二个，for 循环外部新建 StringBuilder，循环体内使用 append() 方法。
1234StringBuilder sb &#x3D; new StringBuilder();for (int i &#x3D; 0; i &lt; 100000; i++) {    sb.append(&quot;六六六&quot;);}
“这两个小测试分别会耗时多长时间呢？”
“哇，第一个小测试的执行时间是 6212 毫秒，第二个只用了不到 1 毫秒，差距也太大了吧！”
“是的，这下明白了原因吧？”我说。
append方法源码解析 
“好了，来看一下 StringBuilder 类的 append() 方法的源码吧！”
1234public StringBuilder append(String str) {    super.append(str);    return this;}
这 3 行代码其实没啥看的。我们来看父类 AbstractStringBuilder 的 append() 方法：
123456789public AbstractStringBuilder append(String str) {    if (str &#x3D;&#x3D; null)        return appendNull();    int len &#x3D; str.length();    ensureCapacityInternal(count + len);    str.getChars(0, len, value, count);    count +&#x3D; len;    return this;}
1）判断拼接的字符串是不是 null，如果是，当做字符串“null”来处理。 appendNull() 方法的源码如下：
1234567891011private AbstractStringBuilder appendNull() {    int c &#x3D; count;    ensureCapacityInternal(c + 4);    final char[] value &#x3D; this.value;    value[c++] &#x3D; &#39;n&#39;;    value[c++] &#x3D; &#39;u&#39;;    value[c++] &#x3D; &#39;l&#39;;    value[c++] &#x3D; &#39;l&#39;;    count &#x3D; c;    return this;}
2）获取字符串的长度。
3） ensureCapacityInternal() 方法的源码如下：
1234567private void ensureCapacityInternal(int minimumCapacity) {    &#x2F;&#x2F; overflow-conscious code    if (minimumCapacity - value.length &gt; 0) {        value &#x3D; Arrays.copyOf(value,                newCapacity(minimumCapacity));    }}
由于字符串内部是用数组实现的，所以需要先判断拼接后的字符数组长度是否超过当前数组的长度，如果超过，先对数组进行扩容，然后把原有的值复制到新的数组中。
 4）将拼接的字符串 str 复制到目标数组 value 中。
1str.getChars(0, len, value, count)
5）更新数组的长度 count。
String.concat 拼接字符串 
“除了可以使用 + 号操作符，StringBuilder 的 append() 方法，还有其他的字符串拼接方法吗？”
“有啊，比如说 String 类的 concat() 方法，有点像 StringBuilder 类的 append() 方法。”
123String chenmo &#x3D; &quot;沉默&quot;;String wanger &#x3D; &quot;王二&quot;;System.out.println(chenmo.concat(wanger));
可以来看一下 concat() 方法的源码。
12345678910public String concat(String str) {    int otherLen &#x3D; str.length();    if (otherLen &#x3D;&#x3D; 0) {        return this;    }    int len &#x3D; value.length;    char buf[] &#x3D; Arrays.copyOf(value, len + otherLen);    str.getChars(buf, len);    return new String(buf, true);}
1）如果拼接的字符串的长度为 0，那么返回拼接前的字符串。
2）将原字符串的字符数组 value 复制到变量 buf 数组中。
3）把拼接的字符串 str 复制到字符数组 buf 中，并返回新的字符串对象。
我一行一行地解释着。
“和 + 号操作符相比， concat() 方法在遇到字符串为 null 的时候，会抛出 NullPointerException，而“+”号操作符会把 null 当做是“null”字符串来处理。”
如果拼接的字符串非常多， concat() 的效率就会下降，因为创建的字符串对象越来越多。
“还有吗？”
“有，当然有。”
String.join 拼接字符串 
String 类有一个静态方法 join() ，可以这样来使用。
1234String chenmo &#x3D; &quot;沉默&quot;;String wanger &#x3D; &quot;王二&quot;;String cmower &#x3D; String.join(&quot;&quot;, chenmo, wanger);System.out.println(cmower);
第一个参数为字符串连接符，比如说：
1String message &#x3D; String.join(&quot;-&quot;, &quot;王二&quot;, &quot;太特么&quot;, &quot;有趣了&quot;);
输出结果为：王二-太特么-有趣了 。
来看一下 join 方法的源码：
12345678910public static String join(CharSequence delimiter, CharSequence... elements) {    Objects.requireNonNull(delimiter);    Objects.requireNonNull(elements);    &#x2F;&#x2F; Number of elements not likely worth Arrays.stream overhead.    StringJoiner joiner &#x3D; new StringJoiner(delimiter);    for (CharSequence cs: elements) {        joiner.add(cs);    }    return joiner.toString();}
里面新建了一个叫 StringJoiner 的对象，然后通过 for-each 循环把可变参数添加了进来，最后调用 toString() 方法返回 String。
StringUtils.join 拼接字符串 
“实际的工作中， org.apache.commons.lang3.StringUtils 的 join() 方法也经常用来进行字符串拼接。”
123String chenmo &#x3D; &quot;沉默&quot;;String wanger &#x3D; &quot;王二&quot;;StringUtils.join(chenmo, wanger);
该方法不用担心 NullPointerException。
12345StringUtils.join(null)            &#x3D; nullStringUtils.join([])              &#x3D; &quot;&quot;StringUtils.join([null])          &#x3D; &quot;&quot;StringUtils.join([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]) &#x3D; &quot;abc&quot;StringUtils.join([null, &quot;&quot;, &quot;a&quot;]) &#x3D; &quot;a&quot;
来看一下源码：
12345678910111213141516171819public static String join(final Object[] array, String separator, final int startIndex, final int endIndex) {    if (array &#x3D;&#x3D; null) {        return null;    }    if (separator &#x3D;&#x3D; null) {        separator &#x3D; EMPTY;    }    final StringBuilder buf &#x3D; new StringBuilder(noOfItems * 16);    for (int i &#x3D; startIndex; i &lt; endIndex; i++) {        if (i &gt; startIndex) {            buf.append(separator);        }        if (array[i] !&#x3D; null) {            buf.append(array[i]);        }    }    return buf.toString();}
内部使用的仍然是 StringBuilder。
“好了，关于字符串拼接的知识点我们就讲到这吧。注意 Java 9 以后，对 + 号操作符的解释和之前发生了变化，字节码指令已经不同了，等后面你学了字节码指令后我们再详细地讲一次。”
2.11 String拆分“哥，我感觉字符串拆分没什么可讲的呀，直接上 String 类的 split() 方法不就可以了！”三妹毫不客气地说。
“假如你真的这么觉得，那可要注意了，事情远没这么简单。”我微笑着说。
假如现在有这样一串字符序列“沉默王二，一枚有趣的程序员”，需要按照中文逗号“，”进行拆分，这意味着第一串字符序列为逗号前面的“沉默王二”，第二串字符序列为逗号后面的“一枚有趣的程序员”。
“这不等于没说吗？哥！”还没等我说，三妹就打断了我。
“别着急嘛，等哥说完。”我依然保持着微笑继续说，“在拆分之前，要先进行检查，判断一下这串字符是否包含逗号，否则应该抛出异常。”
1234567891011public class Test {    public static void main(String[] args) {        String cmower &#x3D; &quot;沉默王二，一枚有趣的程序员&quot;;        if (cmower.contains(&quot;，&quot;)) {            String [] parts &#x3D; cmower.split(&quot;，&quot;);            System.out.println(&quot;第一部分：&quot; + parts[0] +&quot; 第二部分：&quot; + parts[1]);        } else {            throw new IllegalArgumentException(&quot;当前字符串没有包含逗号&quot;);        }    }}
“三妹你看，这段代码挺严谨的吧？”我说，“来看一下程序的输出结果。”
1第一部分：沉默王二 第二部分：一枚有趣的程序员
“的确和预期完全一致。”三妹说。
“这是建立在字符串是确定的情况下，最重要的是分隔符是确定的。否则，麻烦就来了。”我说，“大约有 12 种英文特殊符号，如果直接拿这些特殊符号替换上面代码中的分隔符（中文逗号），这段程序在运行的时候就会出现以下提到的错误。”

反斜杠 \ （ArrayIndexOutOfBoundsException）
插入符号 ^ （同上）
美元符号 $ （同上）
逗点 . （同上）
竖线 | （正常，没有出错）
问号 ? （PatternSyntaxException）
星号 * （同上）
加号 + （同上）
左小括号或者右小括号 () （同上）
左方括号或者右方括号 [] （同上）
左大括号或者右大括号 {} （同上）

“那遇到这些特殊符号该怎么办呢？”三妹问。
“用正则表达式。”我说，“正则表达式是一组由字母和符号组成的特殊文本，它可以用来从文本中找出满足你想要的格式的句子。”
我在 GitHub 上找打了一个开源的正则表达式学习文档，非常详细。一开始写正则表达式的时候难免会感觉到非常生疏，你可以查看一下这份文档。记不住没关系，遇到就查。

https:&#x2F;&#x2F;github.com&#x2F;cdoco&#x2F;learn-regex-zh

除了这份文档，还有一份：

https:&#x2F;&#x2F;github.com&#x2F;cdoco&#x2F;common-regex

作者收集了一些在平时项目开发中经常用到的正则表达式，可以直接拿来用。
“哥，你真周到。”三妹笑着说。
“好了，来用英文逗点 . 替换一下分隔符。”我说。
12345String cmower &#x3D; &quot;沉默王二.一枚有趣的程序员&quot;;if (cmower.contains(&quot;.&quot;)) {    String [] parts &#x3D; cmower.split(&quot;\\.&quot;);    System.out.println(&quot;第一部分：&quot; + parts[0] +&quot; 第二部分：&quot; + parts[1]);}
由于英文逗点属于特殊符号，所以在使用 split() 方法的时候，就需要使用正则表达式 \. 而不能直接使用 . 。
“为什么用两个反斜杠呢？”三妹问。
“因为反斜杠本身就是一个特殊字符，需要用反斜杠来转义。”我说。
当然了，你也可以使用 [] 来包裹住英文逗点“.”， [] 也是一个正则表达式，用来匹配方括号中包含的任意字符。
1cmower.split(&quot;[.]&quot;);
除此之外， 还可以使用 Pattern 类的 quote() 方法来包裹英文逗点“.”，该方法会返回一个使用 \Q\E 包裹的字符串。

来看示例：
1String [] parts &#x3D; cmower.split(Pattern.quote(&quot;.&quot;));
当 split() 方法的参数是正则表达式的时候，方法最终会执行下面这行代码：
1return Pattern.compile(regex).split(this, limit);
也就意味着，拆分字符串有了新的选择，可以不使用 String 类的 split() 方法，直接用下面的方式。
1234567public class TestPatternSplit {    private static Pattern twopart &#x3D; Pattern.compile(&quot;\\.&quot;);    public static void main(String[] args) {        String [] parts &#x3D; twopart.split(&quot;沉默王二.一枚有趣的程序员&quot;);        System.out.println(&quot;第一部分：&quot; + parts[0] +&quot; 第二部分：&quot; + parts[1]);    }}
“为什么要把 Pattern 表达式声明称 static 的呢？”三妹问。
“由于模式是确定的，通过 static 的预编译功能可以提高程序的效率。”我说，“除此之外，还可以使用 Pattern 配合 Matcher 类进行字符串拆分，这样做的好处是可以对要拆分的字符串进行一些严格的限制，来看这段示例代码。”
12345678910111213141516171819public class TestPatternMatch {    &#x2F;**     * 使用预编译功能，提高效率     *&#x2F;    private static Pattern twopart &#x3D; Pattern.compile(&quot;(.+)\\.(.+)&quot;);    public static void main(String[] args) {        checkString(&quot;沉默王二.一枚有趣的程序员&quot;);        checkString(&quot;沉默王二.&quot;);        checkString(&quot;.一枚有趣的程序员&quot;);    }    private static void checkString(String str) {        Matcher m &#x3D; twopart.matcher(str);        if (m.matches()) {            System.out.println(&quot;第一部分：&quot; + m.group(1) + &quot; 第二部分：&quot; + m.group(2));        } else {            System.out.println(&quot;不匹配&quot;);        }    }}
正则表达式 (.+)\.(.+) 的意思是，不仅要把字符串按照英文标点的方式拆成两部分，并且英文逗点的前后要有内容。
来看一下程序的输出结果：
123第一部分：沉默王二 第二部分：一枚有趣的程序员不匹配不匹配
不过，使用 Matcher 来匹配一些简单的字符串时相对比较沉重一些，使用 String 类的 split() 仍然是首选，因为该方法还有其他一些牛逼的功能。比如说，如果你想把分隔符包裹在拆分后的字符串的第一部分，可以这样做：
12345String cmower &#x3D; &quot;沉默王二，一枚有趣的程序员&quot;;if (cmower.contains(&quot;，&quot;)) {    String [] parts &#x3D; cmower.split(&quot;(?&lt;&#x3D;，)&quot;);    System.out.println(&quot;第一部分：&quot; + parts[0] +&quot; 第二部分：&quot; + parts[1]);}
程序输出的结果如下所示：
1第一部分：沉默王二， 第二部分：一枚有趣的程序员
可以看到分隔符“，”包裹在了第一部分，如果希望包裹在第二部分，可以这样做：
1String [] parts &#x3D; cmower.split(&quot;(?&#x3D;，)&quot;);
“ ?&lt;&#x3D; 和 ?&#x3D; 是什么东东啊？”三妹好奇地问。
“它其实是正则表达式中的断言模式。”我说，“你有时间的话，可以看看前面我推荐的两份开源文档。”

“ split() 方法可以传递 2 个参数，第一个为分隔符，第二个为拆分的字符串个数。”我说。
12345String cmower &#x3D; &quot;沉默王二，一枚有趣的程序员，宠爱他&quot;;if (cmower.contains(&quot;，&quot;)) {    String [] parts &#x3D; cmower.split(&quot;，&quot;, 2);    System.out.println(&quot;第一部分：&quot; + parts[0] +&quot; 第二部分：&quot; + parts[1]);}
进入 debug 模式的话，可以看到以下内容：

也就是说，传递 2 个参数的时候，会直接调用 substring() 进行截取，第二个分隔符后的就不再拆分了。
来看一下程序输出的结果：
1第一部分：沉默王二 第二部分：一枚有趣的程序员，宠爱他
“没想到啊，这个字符串拆分还挺讲究的呀！”三妹感慨地说。
“是的，其实字符串拆分在实际的工作当中还是挺经常用的。前端经常会按照规则传递一长串字符序列到后端，后端就需要按照规则把字符串拆分再做处理。”我说。
3 面向对象编程3.1 Java中的类和对象“二哥，那天我在图书馆复习《Java进阶之路》的时候，刚好碰见一个学长，他问我有没有‘对象’，我说还没有啊。结果你猜他说什么，‘要不要我给你 new 一个啊？’我当时就懵了，new 是啥意思啊，二哥？”三妹满是疑惑的问我。
“哈哈，三妹，你学长还挺幽默啊。new 是 Java 中的一个关键字，用来把类变成对象。”我笑着对三妹说，“对象和类是 Java 中最基本的两个概念，可以说撑起了面向对象编程（OOP）的一片天。”
01、面向过程和面向对象
三妹是不是要问，什么是 OOP？
OOP 的英文全称是 Object Oriented Programming，要理解它的话，就要先理解面向对象，要想理解面向对象的话，就要先理解面向过程，因为一开始没有面向对象的编程语言，都是面向过程。
举个简单点的例子来区分一下面向过程和面向对象
有一天，你想吃小碗汤了，怎么办呢？有两个选择：
1）自己买食材，豆腐皮啊、肉啊、蒜苔啊等等，自己动手做。
2）到饭店去，只需要对老板喊一声，“来份小碗汤。”
第一种就是面向过程，第二种就是面向对象。
面向过程有什么劣势呢？假如你买了小碗汤的食材，临了又想吃宫保鸡丁了，你是不是还得重新买食材？
面向对象有什么优势呢？假如你不想吃小碗汤了，你只需要对老板说，“我那个小碗汤如果没做的话，换成宫保鸡丁吧！”
面向过程是流程化的，一步一步，上一步做完了，再做下一步。
面向对象是模块化的，我做我的，你做你的，我需要你做的话，我就告诉你一声。我不需要知道你到底怎么做，只看功劳不看苦劳。
不过，如果追到底的话，面向对象的底层其实还是面向过程，只不过把面向过程进行了抽象化，封装成了类，方便我们的调用。
02、类
对象可以是现实中看得见的任何物体，比如说，一只特立独行的猪；也可以是想象中的任何虚拟物体，比如说能七十二变的孙悟空。
Java 通过类（class）来定义这些物体，这些物体有什么状态，通过字段来定义，比如说比如说猪的颜色是纯色还是花色；这些物体有什么行为，通过方法来定义，比如说猪会吃，会睡觉。
来，定义一个简单的类给你看看。
1234567891011121314&#x2F;** * 微信搜索「二哈进阶之路」 *&#x2F;public class Person {    private String name;    private int age;    private int sex;    private void eat() {    }    private void sleep() {    }    private void dadoudou() {    }}
一个类可以包含：

字段（Filed）
方法（Method）
构造方法（Constructor）

在 Person 类中，字段有 3 个，分别是 name、age 和 sex，它们也称为成员变量——在类内部但在方法外部，方法内部的叫临时变量。
成员变量有时候也叫做实例变量，在编译时不占用内存空间，在运行时获取内存，也就是说，只有在对象实例化（ new Person() ）后，字段才会获取到内存，这也正是它被称作“实例”变量的原因。
方法有 3 个，分别是 eat() 、 sleep() 和 dadoudou() ，表示 Person 这个对象可以做什么，也就是吃饭睡觉打豆豆。
那三妹是不是要问，“怎么没有构造方法呢？”
的确在 Person 类的源码文件（.java）中没看到，但在反编译后的字节码文件（.class）中是可以看得到的。
123456789101112131415161718&#x2F;&#x2F;&#x2F;&#x2F; Source code recreated from a .class file by IntelliJ IDEA&#x2F;&#x2F; (powered by Fernflower decompiler)&#x2F;&#x2F;package com.itwanger.twentythree;public class Person {    private String name;    private int age;    private int sex;    public Person() {    }    private void eat() {    }    private void sleep() {    }    private void dadoudou() {    }}
public Person(){} 就是默认的构造方法，因为是空的构造方法（方法体中没有内容），所以可以缺省。
Java 聪明就聪明在这，有些很死板的代码不需要开发人员添加，它会偷偷地做了。
03、new 一个对象
创建 Java 对象时，需要用到 new 关键字。
1Person person &#x3D; new Person();
这行代码就通过 Person 类创建了一个 Person 对象。所有对象在创建的时候都会在堆内存中分配空间。
创建对象的时候，需要一个 main() 方法作为入口， main() 方法可以在当前类中，也可以在另外一个类中。
第一种： main() 方法直接放在 Person 类中。
1234567891011121314public class Person {    private String name;    private int age;    private int sex;    private void eat() {}    private void sleep() {}    private void dadoudou() {}    public static void main(String[] args) {        Person person &#x3D; new Person();        System.out.println(person.name);        System.out.println(person.age);        System.out.println(person.sex);    }}
输出结果如下所示：
123null00
第二种： main() 方法不在 Person 类中，而在另外一个类中。

实际开发中，我们通常不在当前类中直接创建对象并使用它，而是放在使用对象的类中，比如说上图中的PersonTest 类。
可以把 PersonTest 类和 Person 类放在两个文件中，也可以放在一个文件（命名为 PersonTest.java）中，就像下面这样。
12345678910111213141516&#x2F;** * @author 微信搜「二哈进阶之路」 *&#x2F;public class PersonTest {    public static void main(String[] args) {        Person person &#x3D; new Person();    }}class Person {    private String name;    private int age;    private int sex;    private void eat() {}    private void sleep() {}    private void dadoudou() {}}
04、初始化对象
在之前的例子中，程序输出结果为：
123null00
为什么会有这样的输出结果呢？因为 Person 对象没有初始化，因此输出了 String 的默认值 null，int 的默认值 0。
那怎么初始化 Person 对象（对字段赋值）呢？
第一种：通过对象的引用变量。
123456789101112131415public class Person {    private String name;    private int age;    private int sex;    public static void main(String[] args) {        Person person &#x3D; new Person();        person.name &#x3D; &quot;沉默王二&quot;;        person.age &#x3D; 18;        person.sex &#x3D; 1;                System.out.println(person.name);        System.out.println(person.age);        System.out.println(person.sex);    }}
person 被称为对象 Person 的引用变量，见下图：

通过对象的引用变量，可以直接对字段进行初始化（ person.name &#x3D; “沉默” ），所以以上代码输出结果如下所示：
123沉默181
第二种：通过方法初始化。
1234567891011121314151617public class Person {    private String name;    private int age;    private int sex;    public void initialize(String n, int a, int s) {        name &#x3D; n;        age &#x3D; a;        sex &#x3D; s;    }    public static void main(String[] args) {        Person person &#x3D; new Person();        person.initialize(&quot;沉默王二&quot;,18,1);        System.out.println(person.name);        System.out.println(person.age);        System.out.println(person.sex);    }}
在 Person 类中新增方法 initialize() ，然后在新建对象后传参进行初始化（ person.initialize(“沉默”, 18, 1) ）。
第三种：通过构造方法初始化。
12345678910111213141516public class Person {    private String name;    private int age;    private int sex;    public Person(String name, int age, int sex) {        this.name &#x3D; name;        this.age &#x3D; age;        this.sex &#x3D; sex;    }    public static void main(String[] args) {        Person person &#x3D; new Person(&quot;沉默王二&quot;, 18, 1);        System.out.println(person.name);        System.out.println(person.age);        System.out.println(person.sex);    }}
这也是最标准的一种做法，直接在 new 的时候把参数传递过去。
补充一点知识，匿名对象。匿名对象意味着没有引用变量，它只能在创建的时候被使用一次。
1new Person();
可以直接通过匿名对象调用方法：
1new Person().initialize(&quot;沉默王二&quot;, 18, 1);
05、关于对象
1）抽象的历程
所有编程语言都是一种抽象，甚至可以说，我们能够解决的问题的复杂程度取决于抽象的类型和质量。
Smalltalk 是历史上第一门获得成功的面向对象语言，也为 Java 提供了灵感。它有 5 个基本特征：

万物皆对象。
一段程序实际上就是多个对象通过发送消息的方式来告诉彼此该做什么。
通过组合的方式，可以将多个对象封装成其他更为基础的对象。
对象是通过类实例化的。
同一类型的对象可以接收相同的消息。

总结一句话就是：

状态+行为+标识&#x3D;对象，每个对象在内存中都会有一个唯一的地址。

2）对象具有接口
所有的对象，都可以被归为一类，并且同一类对象拥有一些共同的行为和特征。在 Java 中，class 关键字用来定义一个类型。
创建抽象数据类型是面向对象编程的一个基本概念。你可以创建某种类型的变量，Java 中称之为对象或者实例，然后你就可以操作这些变量，Java 中称之为发送消息或者发送请求，最后对象决定自己该怎么做。
类描述了一系列具有相同特征和行为的对象，从宽泛的概念上来说，类其实就是一种自定义的数据类型。
一旦创建了一个类，就可以用它创建任意多个对象。面向对象编程语言遇到的最大一个挑战就是，如何把现实&#x2F;虚拟的元素抽象为 Java 中的对象。
对象能够接收什么样的请求是由它的接口定义的。具体是怎么做到的，就由它的实现方法来实现。
3）访问权限修饰符
类的创建者有时候也被称为 API 提供者，对应的，类的使用者就被称为 API 调用者。
JDK 就给我们提供了 Java 的基础实现，JDK 的作者也就是基础 API 的提供者（Java 多线程部分的作者 Doug Lea 是被 Java 程序员敬佩的一个大佬），我们这些 Java 语言的使用者，说白了就是 JDK 的调用者。

当然了，假如我们也提供了新的类给其他调用者，我们也就成为了新的创建者。
API 创建者在创建新的类的时候，只暴露必要的接口，而隐藏其他所有不必要的信息，之所以要这么做，是因为如果这些信息对调用者是不可见的，那么创建者就可以随意修改隐藏的信息，而不用担心对调用者的影响。
这里就必须要讲到 Java 的权限修饰符。
访问权限修饰符的第一个作用是，防止类的调用者接触到他们不该接触的内部实现；第二个作用是，让类的创建者可以轻松修改内部机制而不用担心影响到调用者的使用。

public
private
protected

还有一种“默认”的权限修饰符，是缺省的，它修饰的类可以访问同一个包下面的其他类。
4）组合
我们可以把一个创建好的类作为另外一个类的成员变量来使用，利用已有的类组成成一个新的类，被称为“复用”，组合代表的关系是 has-a 的关系。
5）继承
继承是 Java 中非常重要的一个概念，子类继承父类，也就拥有了父类中 protected 和 public 修饰的方法和字段，同时，子类还可以扩展一些自己的方法和字段，也可以重写继承过来方法。
常见的例子，就是形状可以有子类圆形、方形、三角形，它们的基础接口是相同的，比如说都有一个draw() 的方法，子类可以继承这个方法实现自己的绘制方法。
如果子类只是重写了父类的方法，那么它们之间的关系就是 is-a 的关系，但如果子类增加了新的方法，那么它们之间的关系就变成了 is-like-a 的关系。
6）多态
比如说有一个父类Shape
12345public class Shape {    public void draw() {        System.out.println(&quot;形状&quot;);    }}
子类Circle
123456public class Circle extends Shape{    @Override    public void draw() {        System.out.println(&quot;圆形&quot;);    }}
子类Line
123456public class Line extends Shape {    @Override    public void draw() {        System.out.println(&quot;线&quot;);    }}
测试类
12345678public class Test {    public static void main(String[] args) {        Shape shape1 &#x3D; new Line();        shape1.draw();        Shape shape2 &#x3D; new Circle();        shape2.draw();    }}
运行结果：
12线圆形
在测试类中，shape1 的类型为 Shape，shape2 的类型也为 Shape，但调用 draw() 方法后，却能自动调用子类 Line 和 Circle 的 draw() 方法，这是为什么呢？
其实就是 Java 中的多态。
06、小结
“怎么样，三妹，是不是对 Java 有了更深入更清晰的理解？”终于讲完了，我深呼了一口气，好舒畅啊！
“是的，哥，感觉 Java 也就那么回事嘛。”哎呀，三妹有点狂了起来，“万物皆对象，除了基本数据类型。”
“哇，三妹，你可以啊，都会自己梳理总结了。”我倍感欣慰，觉得果然是劳有所获，你讲的认真，听众就能理解和 get，满足了。
3.2 Java中的包“三妹，这一节，我们简单过一下 Java 中的包，也就是 package，这个一点就透，很好掌握。”我放下手中的雪碧，翻开笔记本，点开《Java 进阶之路》，找到这篇「Java 中的包」，开始滔滔不绝起来。
“二哥，你等一下。”让我打开思维导图做一下笔记 。
关于包
在前面的代码中，我们把类和接口命名为 Person 、 Student 、 Hello 等简单的名字。
在团队开发中，如果小明写了一个 Person 类，小红也写了一个 Person 类，现在，小白既想用小明的Person ，也想用小红的 Person ，怎么办？
如果小军写了一个 Arrays 类，恰好 JDK 也自带了一个 Arrays 类，如何解决类名冲突？
在 Java 中，我们使用 package 来解决名字冲突。
Java 定义了一种名字空间，称之为包： package 。一个类总是属于某个包，类名（比如 Person ）只是一个简写，真正的完整类名是 包名.类名 。
例如：
小明的 Person 类存放在包 ming 下面，因此，完整类名是 ming.Person ；
小红的 Person 类存放在包 hong 下面，因此，完整类名是 hong.Person ；
小军的 Arrays 类存放在包 mr.jun 下面，因此，完整类名是 mr.jun.Arrays ；
JDK 的 Arrays 类存放在包 java.util 下面，因此，完整类名是 java.util.Arrays 。
在定义 class 的时候，我们需要在第一行声明这个 class 属于哪个包。
小明的 Person.java 文件：
123package ming; &#x2F;&#x2F; 申明包名mingpublic class Person {}
小军的 Arrays.java 文件：
123package mr.jun; &#x2F;&#x2F; 申明包名mr.junpublic class Arrays {}
在 Java 虚拟机执行的时候，JVM 只看完整类名，因此，只要包名不同，类就不同。
包可以是多层结构，用 . 隔开。例如： java.util 。

要特别注意：包没有父子关系。java.util和java.util.zip是不同的包，两者没有任何继承关系。

没有定义包名的 class ，它使用的是默认包，非常容易引起名字冲突，因此，不推荐不写包名的做法。
我们还需要按照包结构把上面的 Java 文件组织起来。假设以 package_sample 作为根目录， src 作为源码目录，那么所有文件结构就是：
123456789package_sample└─ src    ├─ hong    │  └─ Person.java    │  ming    │  └─ Person.java    └─ mr       └─ jun          └─ Arrays.java
即所有 Java 文件对应的目录层次要和包的层次一致。
编译后的 .class 文件也需要按照包结构存放。如果使用 IDE，把编译后的 .class 文件放到 bin 目录下，那么，编译的文件结构就是：
123456789package_sample└─ bin   ├─ hong   │  └─ Person.class   │  ming   │  └─ Person.class   └─ mr      └─ jun         └─ Arrays.class
编译的命令相对比较复杂，我们需要在 src 目录下执行 javac 命令：
1javac -d ..&#x2F;bin ming&#x2F;Person.java hong&#x2F;Person.java mr&#x2F;jun&#x2F;Arrays.java
在 IDE 中，会自动根据包结构编译所有 Java 源码，所以不必担心使用命令行编译的复杂命令。
包的作用域
位于同一个包的类，可以访问包作用域的字段和方法。
不用 public 、 protected 、 private 修饰的字段和方法就是包作用域。例如， Person 类定义在 hello 包
下面：
1234567package hello;public class Person {    &#x2F;&#x2F; 包作用域:    void hello() {        System.out.println(&quot;Hello!&quot;);    }}
Main 类也定义在 hello 包下面，就可以直接访问 Person 类：
1234567package hello;public class Main {    public static void main(String[] args) {        Person p &#x3D; new Person();        p.hello(); &#x2F;&#x2F; 可以调用，因为Main和Person在同一个包    }}
导入包
在一个 class 中，我们总会引用其他的 class 。例如，小明的 ming.Person 类，如果要引用小军的mr.jun.Arrays 类，他有三种写法：
第一种，直接写出完整类名，例如：
1234567&#x2F;&#x2F; Person.javapackage ming;public class Person {    public void run() {        mr.jun.Arrays arrays &#x3D; new mr.jun.Arrays();    }}
很显然，每次都要写完整的类名比较痛苦。
因此，第二种写法是用 import 语句，导入小军的 Arrays ，然后写简单类名：
123456789&#x2F; Person.javapackage ming;&#x2F;&#x2F; 导入完整类名:import mr.jun.Arrays;public class Person {    public void run() {        Arrays arrays &#x3D; new Arrays();    }}
在写 import 的时候，可以使用 * ，表示把这个包下面的所有 class 都导入进来（但不包括子包的class ）：
123456789&#x2F;&#x2F; Person.javapackage ming;&#x2F;&#x2F; 导入mr.jun包的所有class:import mr.jun.*;public class Person {    public void run() {        Arrays arrays &#x3D; new Arrays();    }}
我们一般不推荐这种写法，因为在导入了多个包后，很难看出 Arrays 类属于哪个包。
还有一种 import static 的语法，它可以导入一个类的静态字段和静态方法：
123456789package main;&#x2F;&#x2F; 导入System类的所有静态字段和静态方法:import static java.lang.System.*;public class Main {    public static void main(String[] args) {        &#x2F;&#x2F; 相当于调用System.out.println(…)        out.println(&quot;Hello, world!&quot;);    }}
import static 很少使用。
Java 编译器最终编译出的 .class 文件只使用 完整类名，因此，在代码中，当编译器遇到一个 class 名称时：

如果是完整类名，就直接根据完整类名查找这个 class ；
如果是简单类名，按下面的顺序依次查找：

查找当前 package 是否存在这个 class ；

查找 import 的包是否包含这个 class ；

查找 java.lang 包是否包含这个 class 。




如果按照上面的规则还无法确定类名，则编译报错。
我们来看一个例子：
12345678910111213&#x2F;&#x2F; Main.javapackage test;import java.text.Format;public class Main {    public static void main(String[] args) {        java.util.List list; &#x2F;&#x2F; ok，使用完整类名 -&gt; java.util.List        Format format &#x3D; null; &#x2F;&#x2F; ok，使用import的类 -&gt; java.text.Format        String s &#x3D; &quot;hi&quot;; &#x2F;&#x2F; ok，使用java.lang包的String -&gt; java.lang.String        System.out.println(s); &#x2F;&#x2F; ok，使用java.lang包的System -&gt; java.lang.System        MessageFormat mf &#x3D; null; &#x2F;&#x2F; 编译错误：无法找到MessageFormat: MessageFormat cannot be resolved to a type    }}
因此，编写 class 的时候，编译器会自动帮我们做两个 import 动作：

默认自动 import 当前 package 的其他 class ；
默认自动 import java.lang.* 。


注意：自动导入的是java.lang包，但类似java.lang.reflect这些包仍需要手动导入。

如果有两个 class 名称相同，例如， mr.jun.Arrays 和 java.util.Arrays ，那么只能 import 其中一个，另一个必须写完整类名。
包的最佳实践
为了避免名字冲突，我们需要确定唯一的包名。推荐的做法是使用倒置的域名来确保唯一性。例如：

org.apache
org.apache.commons.log
com.tobebetterjavaer.sample

子包就可以根据功能自行命名。
要注意不要和 java.lang 包的类重名，即自己的类不要使用这些名字：

String
System
Runtime
…

要注意也不要和 JDK 常用类重名：

java.util.List
java.text.Format
java.math.BigInteger
…

小结
Java 内建的 package 机制是为了避免 class 命名冲突；
JDK 的核心类使用 java.lang 包，编译器会自动导入；
JDK 的其它常用类定义在 java.util. ， java.math. ， java.text.* ，……；
包名推荐使用倒置的域名，例如 org.apache 。
3.3 Java中的变量“二哥，听说 Java 变量在以后的日子里经常用，能不能提前给我透露透露？”三妹咪了一口麦香可可奶茶后对我说。
“三妹啊，搬个凳子坐我旁边，听二哥来给你慢慢说啊。”
Java 变量就好像一个容器，可以保存程序在运行过程中的值，它在声明的时候会定义对应的数据类型（Java分为两种数据类型：基本数据类型和引用数据类型）。变量按照作用域的范围又可分为三种类型：局部变量，成员变量和静态变量。
比如说， int data &#x3D; 88; ，其中 data 就是一个变量，它的值为 88，类型为整型（int）。
01、局部变量

在方法体内声明的变量被称为局部变量，该变量只能在该方法内使用，类中的其他方法并不知道该变量。来看下面这个示例：
其中 a、b、c 就是局部变量，它们只能在当前这个 main 方法中使用。
声明局部变量时的注意事项：
局部变量声明在方法、构造方法或者语句块中。
局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，将会被销毁。
访问修饰符不能用于局部变量。
局部变量只在声明它的方法、构造方法或者语句块中可见。
局部变量是在栈上分配的。
局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。

02、成员变量
在类内部但在方法体外声明的变量称为成员变量，或者实例变量，或者字段。之所以称为实例变量，是因为该变量只能通过类的实例（对象）来访问。来看下面这个示例：
1234567public class InstanceVariable {    int data &#x3D; 88;    public static void main(String[] args) {        InstanceVariable iv &#x3D; new InstanceVariable();        System.out.println(iv.data); &#x2F;&#x2F; 88    }}
其中 iv 是一个变量，它是一个引用类型的变量。 new 关键字可以创建一个类的实例（也称为对象），通过“&#x3D;”操作符赋值给 iv 这个变量，iv 就成了这个对象的引用，通过 iv.data 就可以访问成员变量了。

声明成员变量时的注意事项：
成员变量声明在一个类中，但在方法、构造方法和语句块之外。
当一个对象被实例化之后，每个成员变量的值就跟着确定。
成员变量在对象创建的时候创建，在对象被销毁的时候销毁。
成员变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息。
成员变量可以声明在使用前或者使用后。
访问修饰符可以修饰成员变量。
成员变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把成员变量设为私有。通过使用访问修饰符可以使成员变量对子类可见；成员变量具有默认值。数值型变量的默认值是 0，布尔型变量的默认值是 false，引用类型变量的默认值是 null。变量的值可以在声明时指定，也可以在构造方法中指定。

03、静态变量
通过 static 关键字声明的变量被称为静态变量（类变量），它可以直接被类访问，来看下面这个示例：
123456public class StaticVariable {    static int data &#x3D; 99;    public static void main(String[] args) {        System.out.println(StaticVariable.data); &#x2F;&#x2F; 99    }}
其中 data 就是静态变量，通过 类名.静态变量 就可以访问了，不需要创建类的实例。
声明静态变量时的注意事项：

静态变量在类中以 static 关键字声明，但必须在方法构造方法和语句块之外。
无论一个类创建了多少个对象，类只拥有静态变量的一份拷贝。
静态变量除了被声明为常量外很少使用。
静态变量储存在静态存储区。
静态变量在程序开始时创建，在程序结束时销毁。
与成员变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为 public 类型。
静态变量的默认值和实例变量相似。
静态变量还可以在静态语句块中初始化。

04、常量
在 Java 中，有些数据的值是不会发生改变的，这些数据被叫做常量——使用 final 关键字修饰的成员变量。
常量的值一旦给定就无法改变！
常量在程序运行过程中主要有 2 个作用：

代表常数，便于修改（例如：圆周率的值， final double PI &#x3D; 3.14 ）
增强程序的可读性（例如：常量 UP、DOWN 用来代表上和下， final int UP &#x3D; 0 ）

Java 要求常量名必须大写。来看下面这个示例：
123456789public class FinalVariable {    final String CHEN &#x3D; &quot;沉&quot;;    static final String MO &#x3D; &quot;默&quot;;    public static void main(String[] args) {        FinalVariable fv &#x3D; new FinalVariable();        System.out.println(fv.CHEN);        System.out.println(MO);    }}
“好了，三妹，关于 Java 变量就先说这么多吧，你是不是已经清楚了？”转动了一下僵硬的脖子后，我对三妹说。
“是啊，二哥，我想以后还会再见到它们吧？”
“那见的次数可就多了，就好像你每天眨眼的次数一样多。”
3.4 Java中的方法“二哥，这一节我们学什么呢？”三妹满是期待的问我。
“这一节我们来了解一下 Java 中的方法——什么是方法？如何声明方法？方法有哪几种？什么是实例方法？
什么是静态方法？什么是抽象方法？什么是本地方法？”我笑着对三妹说，“我开始了啊，你要注意力集中啊。”
01、Java中的方法是什么？
方法用来实现代码的可重用性，我们编写一次方法，并多次使用它。通过增加或者删除方法中的一部分代码，就可以提高整体代码的可读性。
只有方法被调用时，它才会执行。Java 中最有名的方法当属 main() 方法，这是程序的入口。
02、如何声明方法？
方法的声明反映了方法的一些信息，比如说可见性、返回类型、方法名和参数。如下图所示。

访问权限：它指定了方法的可见性。Java 提供了四种访问权限修饰符：

public：该方法可以被所有类访问。
private：该方法只能在定义它的类中访问。
protected：该方法可以被同一个包中的类，或者不同包中的子类访问。
default：如果一个方法没有使用任何访问权限修饰符，那么它是 package-private 的，意味着该方法只能被同一个包中的类可见。

返回类型：方法返回的数据类型，可以是基本数据类型、对象和集合，如果不需要返回数据，则使用 void 关键字。
方法名：方法名最好反应出方法的功能，比如，我们要创建一个将两个数字相减的方法，那么方法名最好是subtract。
方法名最好是一个动词，并且以小写字母开头。如果方法名包含两个以上单词，那么第一个单词最好是动词，然后是形容词或者名词，并且要以驼峰式的命名方式命名。比如：

一个单词的方法名： sum()
多个单词的方法名： stringComparision()

一个方法可能与同一个类中的另外一个方法同名，这被称为方法重载。
参数：参数被放在一个圆括号内，如果有多个参数，可以使用逗号隔开。参数包含两个部分，参数类型和参数名。如果方法没有参数，圆括号是空的。
方法签名：每一个方法都有一个签名，包括方法名和参数。
方法体：方法体放在一对花括号内，把一些代码放在一起，用来执行特定的任务。
03、方法有哪几种？
方法可以分为两种，一种叫标准类库方法，一种叫用户自定义方法。
1）预先定义方法
Java 提供了大量预先定义好的方法供我们调用，也称为标准类库方法，或者内置方法。比如说 String 类的length() 、 equals() 、 compare() 方法，以及我们在初学 Java 阶段最常用的 println() 方法，用来在控制台打印信息。
12345public class PredefinedMethodDemo {    public static void main(String[] args) {        System.out.println(&quot;沉默王二，一枚有趣的程序员&quot;);    }}
在上面的代码中，我们使用了两个预先定义的方法， main() 方法是程序运行的入口， println() 方法是PrintStream 类的一个方法。这些方法已经提前定义好了，所以我们可以直接使用它们。
我们可以通过集成开发工具查看预先定义方法的方法签名，当我们把鼠标停留在 println() 方法上面时，就会显示下图中的内容：

println() 方法的访问权限修饰符是 public，返回类型为 void，方法名为 println，参数为 String x ，以及 Javadoc（方法是干嘛的）。
预先定义方法让编程变得简单了起来，我们只需要在实现某些功能的时候直接调用这些方法即可，不需要重新编写。
Java 的一个非常大的优势，就是，JDK 的设计者（开发者）为我们提供了大量的标准类库方法，这对于初学编程的新手来说极其友好；不仅如此，GitHub&#x2F;码云上也有大量可以直接拿到生产环境下使用的第三方类库，比如说 hutool 啊、Apache 包啊、一线大厂或者顶级开发大佬贡献的类库，比如说 Druid、Gson 等等。
但如果你想从一个初级开发者（俗称调包侠）晋升为一名优秀的 Java 工程师，那就需要深入研究这些源码，并掌握，最好是能自己写出来这些源码，最起码能自定义一些源码，以便为我们所用。
2）用户自定义方法
当预先定义方法无法满足我们的要求时，就需要自定义一些方法，比如说，我们来定义这样一个方法，用来检查数字是偶数还是奇数。
1234567public static void findEvenOdd(int num) {    if (num % 2 &#x3D;&#x3D; 0) {        System.out.println(num + &quot; 是偶数&quot;);    } else {        System.out.println(num + &quot; 是奇数&quot;);    }}
方法名叫做 findEvenOdd ，访问权限修饰符是 public，并且是静态的（static），返回类型是 void，参数有一个整型（int）的 num。方法体中有一个 if else 语句，如果 num 可以被 2 整除，那么就打印这个数字是偶数，否则就打印这个数字是奇数。
方法被定义好后，如何被调用呢？
12345678910111213public class EvenOddDemo {    public static void main(String[] args) {        findEvenOdd(10);        findEvenOdd(11);    }    public static void findEvenOdd(int num) {        if (num % 2 &#x3D;&#x3D; 0) {            System.out.println(num + &quot; 是偶数&quot;);        } else {            System.out.println(num + &quot; 是奇数&quot;);        }    }}
main() 方法是程序的入口，并且是静态的，那么就可以直接调用同样是静态方法的 findEvenOdd() 。
当一个方法被 static 关键字修饰时，它就是一个静态方法。换句话说，静态方法是属于类的，不属于类实例的（不需要通过 new 关键字创建对象来调用，直接通过类名就可以调用）。
04、什么是实例方法？
没有使用 static 关键字修饰，但在类中声明的方法被称为实例方法，在调用实例方法之前，必须创建类的对象。
123456789public class InstanceMethodExample {    public static void main(String[] args) {        InstanceMethodExample instanceMethodExample &#x3D; new InstanceMethodExample();        System.out.println(instanceMethodExample.add(1, 2));    }    public int add(int a, int b) {        return a + b;    }}
add() 方法是一个实例方法，需要创建 InstanceMethodExample 对象来访问。
实例方法有两种特殊类型：

getter 方法
setter 方法

getter 方法用来获取私有变量（private 修饰的字段）的值，setter 方法用来设置私有变量的值。
1234567891011121314151617181920212223public class Person {    private String name;    private int age;    private int sex;    public String getName() {        return name;    }    public void setName(String name) {        this.name &#x3D; name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age &#x3D; age;    }    public int getSex() {        return sex;    }    public void setSex(int sex) {        this.sex &#x3D; sex;    }}
getter 方法以 get 开头，setter 方法以 set 开头。
05、什么是静态方法？
相应的，有 static 关键字修饰的方法就叫做静态方法。
12345678public class StaticMethodExample {    public static void main(String[] args) {        System.out.println(add(1,2));    }    public static int add(int a, int b) {        return a + b;    }}
StaticMethodExample 类中，mian 和 add 方法都是静态方法，不同的是，main 方法是程序的入口。当我们调用静态方法的时候，就不需要 new 出来类的对象，就可以直接调用静态方法了，一些工具类的方法都是静态方法，比如说 hutool 工具类库，里面有大量的静态方法可以直接调用。

Hutool 的目标是使用一个工具方法代替一段复杂代码，从而最大限度的避免“复制粘贴”代码的问题，彻底改变我们写代码的方式。

以计算 MD5 为例：

【以前】打开搜索引擎 -&gt; 搜“Java MD5 加密” -&gt; 打开某篇博客-&gt; 复制粘贴 -&gt; 改改好用
【现在】引入 Hutool -&gt; SecureUtil.md5()

Hutool 的存在就是为了减少代码搜索成本，避免网络上参差不齐的代码出现导致的 bug。
06、什么是抽象方法？
没有方法体的方法被称为抽象方法，它总是在抽象类中声明。这意味着如果类有抽象方法的话，这个类就必须是抽象的。可以使用 atstract 关键字创建抽象方法和抽象类。
123abstract class AbstractDemo {    abstract void display();}
当一个类继承了抽象类后，就必须重写抽象方法：
12345678910public class MyAbstractDemo extends AbstractDemo {    @Override    void display() {        System.out.println(&quot;重写了抽象方法&quot;);    }    public static void main(String[] args) {        MyAbstractDemo myAbstractDemo &#x3D; new MyAbstractDemo();        myAbstractDemo.display();    }}
输出结果如下所示：
1重写了抽象方法
“关于方法，我们就讲到这里吧，学会了类&#x2F;变量&#x2F;方法，基本上就可以做一个入门级的 Java 程序员了。”我面露微笑，继续对三妹说，“继续加油吧！”
“好的，谢谢二哥你的细心帮助。”
3.5 Java可变参数为了让铁粉们能白票到阿里云的服务器，我当了整整两天的客服，真正体验到了什么叫做“为人民群众谋福利”的不易和辛酸。正在我眼睛红肿打算要休息之际，三妹跑过来问：“Java 的可变参数究竟是怎么一回事？”
我一下子又清醒了，我爱 Java，我爱传道解惑，也享受三妹的赞许（ ）。
可变参数是 Java 1.5 的时候引入的功能，它允许方法使用任意多个、类型相同（ is-a ）的值作为参数。就像下面这样。
1234567891011public static void main(String[] args) {    print(&quot;沉&quot;);    print(&quot;沉&quot;, &quot;默&quot;);    print(&quot;沉&quot;, &quot;默&quot;, &quot;王&quot;);    print(&quot;沉&quot;, &quot;默&quot;, &quot;王&quot;, &quot;二&quot;);}public static void print(String... strs) {    for (String s : strs)        System.out.print(s);    System.out.println();}
静态方法 print() 就使用了可变参数，所以 print(“沉”) 可以， print(“沉”, “默”) 也可以，甚至 3个、 4 个或者更多个字符串都可以作为参数传递给 print() 方法。
说到可变参数，我想起来阿里巴巴开发手册上有这样一条规约。

意思就是尽量不要使用可变参数，如果要用的话，可变参数必须要在参数列表的最后一位。既然坑位有限，只能在最后，那么可变参数就只能有一个（悠着点，悠着点）。如果可变参数不在最后一位，IDE 就会提示对应的错误，如下图所示。

可变参数看起来就像是个语法糖，它背后究竟隐藏了什么呢？让我们来一探究竟，在追求真理这条路上我们要执着。
其实也很简单。当使用可变参数的时候，实际上是先创建了一个数组，该数组的大小就是可变参数的个数，然后将参数放入数组当中，再将数组传递给被调用的方法。
这就是为什么可以使用数组作为参数来调用带有可变参数的方法的根本原因。代码如下所示。
1234567891011public static void main(String[] args) {    print(new String[]{&quot;沉&quot;});    print(new String[]{&quot;沉&quot;, &quot;默&quot;});    print(new String[]{&quot;沉&quot;, &quot;默&quot;, &quot;王&quot;});    print(new String[]{&quot;沉&quot;, &quot;默&quot;, &quot;王&quot;, &quot;二&quot;});}public static void print(String... strs) {    for (String s : strs)        System.out.print(s);    System.out.println();}
那如果方法的参数是一个数组，然后像使用可变参数那样去调用方法的时候，能行得通吗？
“三妹，给你留个思考题：一般什么时候使用可变参数呢？”
可变参数，可变参数，顾名思义，当一个方法需要处理任意多个相同类型的对象时，就可以定义可变参数。
Java 中有一个很好的例子，就是 String 类的 format() 方法，就像下面这样。
12System.out.println(String.format(&quot;年纪是: %d&quot;, 18));System.out.println(String.format(&quot;年纪是: %d 名字是: %s&quot;, 18, &quot;沉默王二&quot;));
%d 表示将整数格式化为 10 进制整数， %s 表示输出字符串。
如果不使用可变参数，那需要格式化的参数就必须使用“+”号操作符拼接起来了。麻烦也就惹上身了。
在实际的项目代码中，slf4j 的日志输出就经常要用到可变参数（log4j 就没法使用可变参数，日志中需要记录多个参数时就痛苦不堪了）。就像下面这样。
123protected Logger logger &#x3D; LoggerFactory.getLogger(getClass());logger.debug(&quot;名字是{}&quot;, mem.getName());logger.debug(&quot;名字是{}，年纪是{}&quot;, mem.getName(), mem.getAge());
查看源码就可以发现， debug() 方法使用了可变参数。
1public void debug(String format, Object... arguments);
“那在使用可变参数的时候有什么注意事项吗？”三妹问。
有的。我们要避免重载带有可变参数的方法——这样很容易让编译器陷入自我怀疑中。
12345678910111213public static void main(String[] args) {    print(null);}public static void print(String... strs) {    for (String a : strs)        System.out.print(a);    System.out.println();}public static void print(Integer... ints) {    for (Integer i : ints)        System.out.print(i);    System.out.println();}
这时候，编译器完全不知道该调用哪个 print() 方法， print(String… strs) 还是print(Integer… ints) ，傻傻分不清。

假如真的需要重载带有可变参数的方法，就必须在调用方法的时候给出明确的指示，不要让编译器去猜。
12345678910public static void main(String[] args) {    String [] strs &#x3D; null;    print(strs);    Integer [] ints &#x3D; null;    print(ints);}public static void print(String... strs) {}public static void print(Integer... ints) {}
上面这段代码是可以编译通过的。因为编译器知道参数是 String 类型还是 Integer 类型，只不过为了运行时不抛出 NullPointerException ，两个 print() 方法的内部要做好判空操作。
“好了，关于可变参数，我们就先讲到这里吧。三妹，你都理解了吧？”
“嗯嗯，不难，我理解了，哥。”三妹最近的学习状态真不错，能看得出来，她有在认真地做笔记 。
3.6 Java native方法“三妹，之前我们学习了 Java 中的基本方法，其实 Java 还有一种方法，本地方法，或者叫 native 方法，它与之前的方法有很大的不同。”我放下手中的手机，扭过脸来对三妹说。
“听起来挺有意思的。”三妹很期待。
“我会教你用 C语言实现一个 native 方法。”我继续说到，“C语言是另外一种编程语言，让我们开始吧”
类似 Thread 类中的 private native start0() 方法；
又或者 Object.class 类中的 getClass() 方法、hashCode()方法、clone() 方法，其中方法签名如下：
123public final native Class&lt;?&gt; getClass();public native int hashCode();protected native Object clone() throws CloneNotSupportedException;
也就是用【native】关键词修饰的方法，多数情况下不需要用 Java 语言实现。
“二哥，为什么要用 native 来修饰方法呢，这样做有什么用？”三妹很乖，但这个问题也问的很掷地有声。
“好的，三妹，我们一步步来扒拉”。
1、JNI：Java Native Interface
在介绍 native 之前，我们先了解什么是 JNI。
一般情况下，我们完全可以使用 Java 语言编写程序，但某些情况下，Java 可能满足不了需求，或者不能更好的满足需求，比如：
①、标准的 Java 类库不支持。
②、我们已经用另一种语言，比如说 C&#x2F;C++ 编写了一个类库，如何用 Java 代码调用呢？
③、某些运行次数特别多的方法，为了加快性能，需要用更接近硬件的语言（比如汇编）编写。
上面这三种需求，说到底就是如何用 Java 代码调用不同语言编写的代码。那么 JNI 应运而生了。
从 Java 1.1 开始，Java Native Interface (JNI)标准就成为 Java 平台的一部分，它允许 Java 代码和其他语言编写的代码进行交互。
JNI 一开始是为了本地已编译语言，尤其是 C 和 C++而设计的，但是它并不妨碍你使用其他语言，只要调用约定受支持就可以了。使用 Java 与本地已编译的代码交互，通常会丧失平台可移植性，但是，有些情况下这样做是可以接受的，甚至是必须的，比如，使用一些旧的库，与硬件、操作系统进行交互，或者为了提高程序的性能。JNI 标准至少保证本地代码能工作能在任何 Java 虚拟机实现下。

通过 JNI，我们就可以通过 Java 程序（代码）调用到操作系统相关的技术实现的库函数，从而与其他技术和系统交互；同时其他技术和系统也可以通过 JNI 提供的相应原生接口调用 Java 应用系统内部实现的功能。
“二哥，等一下，Java 不是跨平台的吗？如果用 JNI，那么程序不就失去了跨平台的优点？”不得不说，三妹这个问题起到好处。
“确实是这样的。”我掐灭了中指和无名指之间的烟头，继续娓娓道来。
JNI 的缺点：
①、程序不再跨平台。要想跨平台，必须在不同的系统环境下重新编译本地语言部分。
②、程序不再是绝对安全的，本地代码的不当使用可能导致整个程序崩溃。一个通用规则是，你应该让本地方法集中在少数几个类当中。这样就降低了 Java 和 C&#x2F;C++ 之间的耦合性。
目前来讲使用 JNI 的缺点相对于优点还是可以接受的，可能后面随着 Java 的技术发展，我们不在需要 JNI，
但是目前 JDK 还是一直提供了对 JNI 标准的支持。
2、用 C 语言编写程序本地方法
“上面讲解了什么是 JNI，接下来我们来写个例子：如何用 Java 代码调用本地的 C 程序。”我扭头对三妹说，
“你注意 看。”

官方文档如下：https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;8&#x2F;docs&#x2F;technotes&#x2F;guides&#x2F;jni&#x2F;spec&#x2F;jniTOC.html

步骤如下：

编写带有 native 方法的 Java 类，生成.java 文件；
使用 javac 命令编译所编写的 Java 类，生成.class 文件；
使用 javah -jni java 类名 生成扩展名为 h 的头文件，也即生成 .h 文件；
使用 C&#x2F;C++（或者其他编程想语言）实现本地方法，创建 .h 文件的实现，也就是创建 .cpp 文件实现.h文件中的方法；
将 C&#x2F;C++ 编写的文件生成动态连接库，生成 dll 文件；

下面我们通过一个 HelloWorld 程序的调用来完成这几个步骤。
01）编写带有 native 方法的 Java 类 HelloJNI.java
在 &#x2F;Users&#x2F;itwanger&#x2F;Documents&#x2F;Github&#x2F;javabetter&#x2F;testjni 目录下创建 HelloJNI.java 文件，内容如下所示。
12345678910public class HelloJNI {    static {        System.loadLibrary(&quot;hello&quot;); &#x2F;&#x2F; 加载名为 libhello.dylib 的动态链接库    }    &#x2F;&#x2F; 定义本地方法    private native void helloJNI();    public static void main(String[] args) {        new HelloJNI().helloJNI(); &#x2F;&#x2F; 调用本地方法    }}
PS：后面执行的命令都将在 testjni 的目录下。
解释一下这段代码：
private native void helloJNI() ：用 native 声明的方法告知 JVM 调用该方法在外部定义，也就是我们会用 C 语言去实现。
System.loadLibrary(“hello”) ：加载动态库，参数 hello 是动态库的名字。我们可以这样理解：程序中的方法 helloJNI() 在程序中没有实现，但是我们下面要调用这个方法，怎么办呢？
我们就需要对这个方法进行初始化，所以用了 static 代码块进行初始化，后面会讲到。
02）编译 HelloJNI.java
在命令行通过 javac HelloJNI.java 来编译源代码。

03）使用 生成扩展名为 h 的头文件


PS：Java 9 以后，javah 被弃用，取而代之的是使用 -h 选项来生成头文件，例如 javac -h .ClassName.java 。

执行完毕后，会在 HelloJNI.java 所在目录下生成一个名为 HelloJNI.h 的头文件。打开 HelloJNI.h 文件，可以看到如下代码。

看不懂没关系，无所谓，直到它是自动生成的就好。
04）使用 C 语言实现本地方法
创建一个 C 文件 HelloJNI.c，实现本地方法 sayHello。
1234567#include &lt;stdio.h&gt;#include &lt;jni.h&gt;#include &quot;HelloJNI.h&quot;JNIEXPORT void JNICALL Java_HelloJNI_helloJNI(JNIEnv *env, jobject obj) {    printf(&quot;Hello, JNI!\n&quot;);    return;}
注意，这里需要引入 JNI 头文件，并且实现的方法名称需要与在 Java 中声明的名称一致（ HelloJNI_helloJNI HelloJNI 类的 helloJNI 方法）。
05）编写编译脚本 compile.sh
123456#!&#x2F;bin&#x2F;bash# 编译 HelloJNI.c 文件gcc -I&quot;$JAVA_HOME&#x2F;include&quot; -I&quot;$JAVA_HOME&#x2F;include&#x2F;darwin&quot; -shared -o libhello.dylib HelloJNI.c# 把生成的 libhello.dylib 文件拷贝到当前目录cp libhello.dylib .
注意事项：

$JAVA_HOME 是 JDK 的安装路径，需要根据实际情况修改。
在 macOS 上，动态链接库（hello）的后缀是 .dylib，而不是 Linux 上的 .so。

这里的 -I 选项是为了告诉编译器头文件的位置， $​JAVA_HOME 是 Java 安装目录的路径。
06）执行编译脚本
1sh compile.sh
执行完毕后，会在当前目录下生成一个名为 libhello.dylib 的动态链接库。

07）运行 HelloJNI
执行 java HelloJNI 命令运行 HelloJNI，如果一切正常，就会在终端上输出 Hello, JNI!。

3、JNI 调用 C 的流程图

4、native 关键字
“三妹，现在应该知道什么是 native 了吧？”我问三妹。
“嗯嗯，我来简述一下，二哥你看看我说的是否正确。”
native 用来修饰方法，用 native 声明的方法表示该方法的实现在外部定义，可以用任何语言去实现它，比如说 C&#x2F;C++。 简单地讲，一个 native Method 就是一个 Java 调用非 Java 代码的接口。
native 语法：
①、修饰方法的位置必须在返回类型之前，和其余的方法控制符前后关系不受限制。
②、不能用 abstract 修饰，也没有方法体，也没有左右大括号。
③、返回值可以是任意类型
“三妹，你学的不错嘛。”我对三妹的学习能力感到非常的欣慰，“我们在日常编程中看到 native 修饰的方法，只需要知道这个方法的作用是什么，至于别的就不用管了，操作系统会给我们实现，初学的时候也不需要太过深入。”
3.7 Java构造方法“三妹，上一节学了 Java 中的方法，接着学构造方法的话，难度就小很多了。”刚吃完中午饭，虽然有些困意，但趁机学个 10 分钟也是不错的，睡眠会更心满意足一些，于是我面露微笑地对三妹说。
“在 Java 中，构造方法是一种特殊的方法，当一个类被实例化的时候，就会调用构造方法。只有在构造方法被调用的时候，对象才会被分配内存空间。每次使用 new 关键字创建对象的时候，构造方法至少会被调用一次。”
“如果你在一个类中没有看见构造方法，并不是因为构造方法不存在，而是被缺省了，编译器会给这个类提供一个默认的构造方法。就是说，Java 有两种类型的构造方法：无参构造方法和有参构造方法。”
“注意，之所以叫它构造方法，是因为对象在创建的时候，需要通过构造方法初始化值——描写对象有哪些初始化状态。”
“哥，你缓缓，一口气说这么多，也真有你的。”三妹听得聚精会神，但也知道关心她这个既当哥又当老师的二哥了。
01、创建构造方法的规则
构造方法必须符合以下规则：

构造方法的名字必须和类名一样；
构造方法没有返回类型，包括 void；
构造方法不能是抽象的（abstract）、静态的（static）、最终的（final）、同步的（synchronized）。

简单解析一下最后一条规则。

由于构造方法不能被子类继承，所以用 final 和 abstract 关键字修饰没有意义；
构造方法用于初始化一个对象，所以用 static 关键字修饰没有意义；
多个线程不会同时创建内存地址相同的同一个对象，所以用 synchronized 关键字修饰没有必要。

构造方法的语法格式如下：
123456class class_name {    public class_name(){}    &#x2F;&#x2F; 默认无参构造方法    public ciass_name([paramList]){}    &#x2F;&#x2F; 定义有参数列表的构造方法    …    &#x2F;&#x2F; 类主体}
值得注意的是，如果用 void 声明构造方法的话，编译时不会报错，但 Java 会把这个所谓的“构造方法”当成普通方法来处理。
123public class Demo {    void Demo(){ }}
void Demo(){} 看起来很符合构造方法的写法（与类名相同），但其实只是一个不符合规范的普通方法，方法名的首字母使用了大写，方法体为空，它并不是默认的无参构造方法，可以通过反编译后的字节码验证。class class_name {
123456public class Demo {    public Demo() {    }    void Demo() {    }}
public Demo() {} 才是真正的无参构造方法。
不过，可以使用访问权限修饰符（private、protected、public、default）来修饰构造方法，访问权限修饰符决定了构造方法的创建方式。
02、默认构造方法
如果一个构造方法中没有任何参数，那么它就是一个默认构造方法，也称为无参构造方法。
12345678public class Bike {    Bike(){        System.out.println(&quot;一辆自行车被创建&quot;);    }    public static void main(String[] args) {        Bike bike &#x3D; new Bike();    }}
在上面这个例子中，我们为 Bike 类中创建了一个无参的构造方法，它在我们创建对象的时候被调用。
程序输出结果如下所示：
1一辆自行车被创建
通常情况下，无参构造方法是可以缺省的，我们开发者并不需要显式的声明无参构造方法，把这项工作交给编译器就可以了。

“二哥，默认构造方法的目的是什么？它为什么是一个空的啊？”三妹疑惑地看着我，提出了这个尖锐的问题。
“三妹啊，默认构造方法的目的主要是为对象的字段提供默认值，看下面这个例子你就明白了。”我胸有成竹地回答道。
12345678public class Person {    private String name;    private int age;    public static void main(String[] args) {        Person p &#x3D; new Person();        System.out.println(&quot;姓名 &quot; + p.name + &quot; 年龄 &quot; + p.age);    }}
输出结果如下所示：
1姓名 null 年龄 0
在上面的例子中，默认构造方法初始化了 name 和 age 的值，name 是 String 类型，所以默认值为 null，age 是 int 类型，所以默认值为 0。如果没有默认构造方法的话，这项工作就无法完成了。
**03、有参构造方法
有参数的构造方法被称为有参构造方法，参数可以有一个或多个。有参构造方法可以为不同的对象提供不同的值。当然，也可以提供相同的值。
1234567891011121314151617public class ParamConstructorPerson {    private String name;    private int age;    public ParamConstructorPerson(String name, int age) {        this.name &#x3D; name;        this.age &#x3D; age;    }    public void out() {        System.out.println(&quot;姓名 &quot; + name + &quot; 年龄 &quot; + age);    }    public static void main(String[] args) {        ParamConstructorPerson p1 &#x3D; new ParamConstructorPerson(&quot;沉默王二&quot;,18);        p1.out();        ParamConstructorPerson p2 &#x3D; new ParamConstructorPerson(&quot;沉默王三&quot;,16);        p2.out();    }}
在上面的例子中，构造方法有两个参数（name 和 age），这样的话，我们在创建对象的时候就可以直接为name 和 age 赋值了。
12new ParamConstructorPerson(&quot;沉默&quot;,18);new ParamConstructorPerson(&quot;沉默&quot;,16);
如果没有有参构造方法的话，就需要通过 setter 方法给字段赋值了。
04、重载构造方法
在 Java 中，构造方法和方法类似，只不过没有返回类型。它也可以像方法一样被重载。构造方法的重载也很简单，只需要提供不同的参数列表即可。编译器会通过参数的数量来决定应该调用哪一个构造方法。
12345678910111213141516171819202122232425public class OverloadingConstrutorPerson {    private String name;    private int age;    private int sex;    public OverloadingConstrutorPerson(String name, int age, int sex) {        this.name &#x3D; name;        this.age &#x3D; age;        this.sex &#x3D; sex;    }    public OverloadingConstrutorPerson(String name, int age) {        this.name &#x3D; name;        this.age &#x3D; age;    }    public void out() {        System.out.println(&quot;姓名 &quot; + name + &quot; 年龄 &quot; + age + &quot; 性别 &quot; + sex);    }    public static void main(String[] args) {        OverloadingConstrutorPerson p1 &#x3D; new OverloadingConstrutorPerson(&quot;沉默王二&quot;,18, 1);        p1.out();        OverloadingConstrutorPerson p2 &#x3D; new OverloadingConstrutorPerson(&quot;沉默王三&quot;,16);        p2.out();    }}
创建对象的时候，如果传递的是三个参数，那么就会调用 OverloadingConstrutorPerson(String name, int age, int sex) 这个构造方法；如果传递的是两个参数，那么就会调用OverloadingConstrutorPerson(String name, int age) 这个构造方法。
05、构造方法和方法的区别
构造方法和方法之间的区别还是蛮多的，比如说下面这些：




方法
构造方法




方法反映了对象的行为
构造方法用于初始化对象的字段


方法可以有返回类型
构造方法没有返回类型


方法的调用是明确的，开发者通过代码决定调用哪一个
构造方法的调用是隐式的，通过编译器完成


方法在任何情况下都不能由编译器提供
如果没有明确提供无参构造方法，编译器会提供


方法名可以和类名相同，也可以不同
构造方法的名称必须和类名相同




06、复制对象
复制一个对象可以通过下面三种方式完成：

通过构造方法
通过对象的值
通过 Object 类的 clone() 方法

1）通过构造方法
12345678910111213141516171819202122232425public class CopyConstrutorPerson {    private String name;    private int age;    public CopyConstrutorPerson(String name, int age) {        this.name &#x3D; name;        this.age &#x3D; age;    }        public CopyConstrutorPerson(CopyConstrutorPerson person) {        this.name &#x3D; person.name;        this.age &#x3D; person.age;    }        public void out() {        System.out.println(&quot;姓名 &quot; + name + &quot; 年龄 &quot; + age);    }        public static void main(String[] args) {        CopyConstrutorPerson p1 &#x3D; new CopyConstrutorPerson(&quot;沉默王二&quot;,18);        p1.out();        CopyConstrutorPerson p2 &#x3D; new CopyConstrutorPerson(p1);        p2.out();    }}
在上面的例子中，有一个参数为 CopyConstrutorPerson 的构造方法，可以把该参数的字段直接复制到新的对象中，这样的话，就可以在 new 关键字创建新对象的时候把之前的 p1 对象传递过去。
2）通过对象的值
1234567891011121314151617181920212223242526public class CopyValuePerson {    private String name;    private int age;        public CopyValuePerson(String name, int age) {        this.name &#x3D; name;        this.age &#x3D; age;    }        public CopyValuePerson() {    }        public void out() {        System.out.println(&quot;姓名 &quot; + name + &quot; 年龄 &quot; + age);    }        public static void main(String[] args) {        CopyValuePerson p1 &#x3D; new CopyValuePerson(&quot;沉默王二&quot;,18);        p1.out();        CopyValuePerson p2 &#x3D; new CopyValuePerson();        p2.name &#x3D; p1.name;        p2.age &#x3D; p1.age;                p2.out();    }}
这种方式比较粗暴，直接拿 p1 的字段值复制给 p2 对象（ p2.name &#x3D; p1.name ）。
3）通过 Object 类的 方法
12345678910111213141516171819202122232425public class ClonePerson implements Cloneable {    private String name;    private int age;        public ClonePerson(String name, int age) {        this.name &#x3D; name;        this.age &#x3D; age;    }        @Override    protected Object clone() throws CloneNotSupportedException {        return super.clone();    }        public void out() {        System.out.println(&quot;姓名 &quot; + name + &quot; 年龄 &quot; + age);    }        public static void main(String[] args) throws CloneNotSupportedException {        ClonePerson p1 &#x3D; new ClonePerson(&quot;沉默王二&quot;,18);        p1.out();        ClonePerson p2 &#x3D; (ClonePerson) p1.clone();        p2.out();    }}
通过 clone() 方法复制对象的时候，ClonePerson 必须先实现 Cloneable 接口的 clone() 方法，然后再调用 clone() 方法（ ClonePerson p2 &#x3D; (ClonePerson) p1.clone() ）。
07、ending
“二哥，我能问一些问题吗？”三妹精神焕发，没有丝毫的疲惫。
“当然可以啊，你问。”我很欣赏三妹孜孜不倦的态度。
“构造方法真的不返回任何值吗？”
“构造方法虽然没有返回值，但返回的是类的对象。”
“构造方法只能完成字段初始化的工作吗？”
“初始化字段只是构造方法的一种工作，它还可以做更多，比如启动线程，调用其他方法等。”
“好的，二哥，我的问题问完了，今天的学习可以结束了！”三妹一脸得意的样子。
“那你记得复习下一节的内容哦。”感受到三妹已经学到了知识，我也很欣慰。
3.8 Java访问权限修饰符“我们先来讨论一下为什么需要访问权限控制。其实之前我们在讲类和对象的时候有提到，今天我们来详细地聊一聊，三妹。”我开门见山地说，“三妹，你打开思维导图，记得做笔记哦。”
“好的。”三妹应声回答。
考虑两个场景：
场景 1：工程师 A 编写了一个类 ClassA，但是工程师 A 并不希望 ClassA 被其他类都访问到，该如何处理呢？
场景 2：工程师 A 编写了一个类 ClassA，其中有两个方法 fun1、fun2，工程师只想让 fun1 对外可见，也就是说，如果别的工程师来调用 ClassA，只可以调用方法 fun1，该怎么处理呢？
此时，访问权限控制便可以起到作用了。
在 Java 中，提供了四种访问权限控制：

默认访问权限（包访问权限）
public
private
protected

类只可以用默认访问权限和 public 修饰。比如说：
1public class Wanger{}
或者
1class Wanger{}
但变量和方法则都可以修饰。
1.修饰类

默认访问权限（包访问权限）：用来修饰类的话，表示该类只对同一个包中的其他类可见。
public：用来修饰类的话，表示该类对其他所有的类都可见。

例 1：
Main.java:
1234567package com.tobetterjavaer.test1;public class Main {    public static void main(String\[\] args) {        People people &#x3D; new People(&quot;Tom&quot;);        System.out.println(people.getName());    }}
People.java
12345678910111213141516package com.tobetterjavaer.test1;class People {&#x2F;&#x2F;默认访问权限（包访问权限）    private String name &#x3D; null;        public People(String name) {        this.name &#x3D; name;    }        public String getName() {        return name;    }        public void setName(String name) {        this.name &#x3D; name;    }}
从代码可以看出，修饰 People 类采用的是默认访问权限，而由于 People 类和 Main 类在同一个包中，因此People 类对于 Main 类是可见的。
例子 2：
People.java
12345678910111213141516package com.tobetterjavaer.test2;class People {&#x2F;&#x2F;默认访问权限（包访问权限）    private String name &#x3D; null;        public People(String name) {        this.name &#x3D; name;    }        public String getName() {        return name;    }        public void setName(String name) {        this.name &#x3D; name;    }}
此时 People 类和 Main 类不在同一个包中，会发生什么情况呢？
下面是 Main 类中的提示的错误：

提示 Peolple 类在 Main 类中不可见。从这里就可以看出，如果用默认访问权限去修饰一个类，该类只对同一个包中的其他类可见，对于不同包中的类是不可见的。
正如上图的快速修正提示所示，将 People 类的默认访问权限更改为 public 的话，People 类对于 Main 类便可见了。
2.修饰方法和变量

默认访问权限（包访问权限）：如果一个类的方法或变量被包访问权限修饰，也就意味着只能在同一个包中的其他类中显示地调用该类的方法或者变量，在不同包中的类中不能显式地调用该类的方法或变量。
private：如果一个类的方法或者变量被 private 修饰，那么这个类的方法或者变量只能在该类本身中被访问，在类外以及其他类中都不能显式的进行访问。
protected：如果一个类的方法或者变量被 protected 修饰，对于同一个包的类，这个类的方法或变量是可以被访问的。对于不同包的类，只有继承于该类的类才可以访问到该类的方法或者变量。
public：被 public 修饰的方法或者变量，在任何地方都是可见的。

例 3：
Main.java 没有变化
People.java
12345678910111213141516package com.tobebetterjavaer.test1;public class People {    private String name &#x3D; null;        public People(String name) {        this.name &#x3D; name;    }        String getName() {    &#x2F;&#x2F;默认访问权限（包访问权限）        return name;    }        void setName(String name) {   &#x2F;&#x2F;默认访问权限（包访问权限）        this.name &#x3D; name;    }}
此时在 Main 类是可以显示调用方法 getName 和 setName 的。
但是如果 People 类和 Main 类不在同一个包中：
12345678910111213package com.tobebetterjavaer.test2;    &#x2F;&#x2F;与Main类处于不同包中public class People {    private String name &#x3D; null;    public People(String name) {        this.name &#x3D; name;    }    String getName() {    &#x2F;&#x2F;默认访问权限（包访问权限）        return name;    }    void setName(String name) {   &#x2F;&#x2F;默认访问权限（包访问权限）        this.name &#x3D; name;    }}
此时在 Main 类中会提示错误：

由此可以看出，如果用默认访问权限来修饰类的方法或者变量，则只能在同一个包的其他类中进行访问。
例 4:
People.java
12345678910111213141516package com.tobebetterjavaer.test1;public class People {    private String name &#x3D; null;        public People(String name) {        this.name &#x3D; name;    }    protected String getName() {        return name;    }        protected void setName(String name) {        this.name &#x3D; name;    }}
此时是可以在 Main 中显示调用方法 getName 和 setName 的。
如果 People 类和 Main 类处于不同包中：
12345678910111213package com.tobebetterjavaer.test2;public class People {    private String name &#x3D; null;    public People(String name) {        this.name &#x3D; name;    }    protected String getName() {        return name;    }    protected void setName(String name) {        this.name &#x3D; name;    }}
则会在 Main 中报错：

如果在 com.cxh.test1 中定一个类 Man 继承 People，则可以在类 Man 中显示调用方法 getName 和setName：
1234567891011package com.tobebetterjavaer.test1;import com.tobebetterjavaer.test2.People;public class Man extends People {    public Man(String name){        super(name);    }        public String toString() {        return getName();    }}
补充一些关于 Java 包和类文件的知识：
1）Java 中的包主要是为了防止类文件命名冲突以及方便进行代码组织和管理；
2）对于一个 Java 源代码文件，如果存在 public 类的话，只能有一个 public 类，且此时源代码文件的名称必须和 public 类的名称完全相同。
另外，如果还存在其他类，这些类在包外是不可见的。如果源代码文件没有 public 类，则源代码文件的名称可以随意命名。
“三妹，理解了吧？”我问三妹。
“是的，很简单，换句话说，不想让别人看的就 private，想让人看的就 public，想同一个班级&#x2F;部门看的就默认，想让下一级看的就 protected，对吧？哥”三妹很自信地回答。
“不错不错，总结得有那味了。”
3.9 Java代码初始化块“哥，今天我们要学习的内容是‘代码初始化块’，对吧？”看来三妹已经提前预习了我上次留给她的作业。
“是的，三妹。代码初始化块用于初始化一些成员变量。 ”我面带着朴实无华的微笑回答着她，“对象在创建的时候会执行代码初始化块，又称实例初始化块，主要和静态初始化块做区分。”
“可以直接通过‘&#x3D;’操作符对成员变量进行初始化，但通过代码初始化块可以做更多的事情，比如说打印出成员变量初始化后的值。”
“三妹，来看下面的代码，我们可以直接通过 &#x3D; 操作符对成员变量进行初始化。”
123class Bike{      int speed&#x3D;100;  } 
“哥，那为什么还需要代码初始化块呢？”三妹眨了眨眼睛，不解地问。
“我们可以通过代码初始化块执行一个更复杂的操作，比如为集合填充值。来看下面这段代码。”
123456789101112public class Bike {    List&lt;String&gt; list;    {        list &#x3D; new ArrayList&lt;&gt;();        list.add(&quot;沉默&quot;);        list.add(&quot;沉默&quot;);    }        public static void main(String[] args) {        System.out.println(new Bike().list);    }}
“如果只使用‘&#x3D;’操作符的话，是没办法完成集合初始化的，对吧？‘&#x3D;’ 后面只能 new 出集合，却没办法填充值，代码初始化就可以完成这项工作。”
“构造方法执行得早还是代码初始化块啊，哥？”三妹这个问题问的还是挺有水平的。
“不要着急，三妹，先来看下面这个例子。”
12345678910111213public class Car {    Car() {        System.out.println(&quot;构造方法&quot;);    }        {        System.out.println(&quot;代码初始化块&quot;);    }        public static void main(String[] args) {        new Car();    }}
“我们来看一下程序的输出结果就一下子明白了。”
12代码初始化块构造方法
“从输出结果看上去，仿佛代码初始化块执行得更早，对吧？事实上是这样子吗？”我露出神秘的微笑，问三妹。
“难道我看到的是假象吗？”三妹睁大了眼睛。
“不是的，对象在初始化的时候会先调用构造方法，这是毫无疑问的，只不过，构造方法在执行的时候会把代码初始化块放在构造方法中其他代码之前，所以，先看到了‘代码初始化块’，后看到了‘’构造方法’。”
说完这句话，我打开 draw.io，使上了吃奶的劲，画出了下面这幅图。

“哦，原来如此啊！”三妹仿佛发现了新大陆，意味深长地说，“编译器把代码初始化块放到了构造方法中，怪不得。”
等三妹明白彻底搞明白后，我对她继续说道：“对于代码初始化来说，它有三个规则。”

类实例化的时候执行代码初始化块；
实际上，代码初始化块是放在构造方法中执行的，只不过比较靠前；
代码初始化块里的执行顺序是从前到后的。

“这些规则不用死记硬背，大致了解一下就行了。我们继续来看下面这段代码。”话音刚落，我就在新版的IDEA 中噼里啪啦地敲了起来，新版真香。
123456789101112131415161718class A {    A () {        System.out.println(&quot;父类构造方法&quot;);    }}public class B extends A{    B() {        System.out.println(&quot;子类构造方法&quot;);    }        {        System.out.println(&quot;代码初始化块&quot;);    }        public static void main(String[] args) {        new B();    }}
“来看一下输出结果。”
123父类构造方法代码初始化块子类构造方法
“在默认情况下，子类的构造方法在执行的时候会主动去调用父类的构造方法。也就是说，其实是构造方法先执行的，再执行的代码初始化块。”
“这个例子再次印证了之前的第二条规则：代码初始化块是放在构造方法中执行的，只不过比较靠前。”
除了这种实例化代码初始化块，还有静态初始化，不过我们会放到 static 关键字中去讲，这里先大致了解一下。
下面是一个 Java 示例代码，演示实例初始化块和静态初始化块的用法：
123456789101112131415161718192021222324252627282930313233public class Example {    &#x2F;&#x2F; 静态变量    public static int staticVar &#x3D; 1;    &#x2F;&#x2F; 实例变量    public int instanceVar &#x3D; 2;        &#x2F;&#x2F; 静态初始化块    static {        System.out.println(&quot;执行静态初始化块&quot;);        staticVar &#x3D; 3;    }        &#x2F;&#x2F; 实例初始化块    {        System.out.println(&quot;执行实例初始化块&quot;);        instanceVar &#x3D; 4;    }        &#x2F;&#x2F; 构造方法    public Example() {        System.out.println(&quot;执行构造方法&quot;);    }        public static void main(String[] args) {        System.out.println(&quot;执行main方法&quot;);        Example e1 &#x3D; new Example();        Example e2 &#x3D; new Example();        System.out.println(&quot;e1的静态变量：&quot; + e1.staticVar);        System.out.println(&quot;e1的实例变量：&quot; + e1.instanceVar);        System.out.println(&quot;e2的静态变量：&quot; + e2.staticVar);        System.out.println(&quot;e2的实例变量：&quot; + e2.instanceVar);    }}
在这个示例代码中，有一个静态变量 staticVar 和一个实例变量 instanceVar，以及一个静态初始化块和一个实例初始化块。在静态初始化块中，我们打印了一条消息并修改了静态变量的值；在实例初始化块中，我们也打印了一条消息并修改了实例变量的值。
来看一下执行结果：
12345678910执行静态初始化块执行main方法执行实例初始化块执行构造方法执行实例初始化块执行构造方法e1的静态变量：3e1的实例变量：4e2的静态变量：3e2的实例变量：4
从输出结果可以看出，静态初始化块在类加载时执行，只会执行一次，并且优先于实例初始化块和构造方法的执行；实例初始化块在每次创建对象时执行，在构造方法之前执行。
“好了，今天就先讲到这吧，中午休息一下，下午的精神会更足。”刚对三妹说完这句话，我的哈欠就上来了，好困。
3.10 Java抽象类“二哥，你这明显加快了更新的频率呀！”三妹对于我最近的肝劲由衷的佩服了起来。
“哈哈，是呀，我要给广大的学弟学妹们一个完整的 Java 学习体系，记住我们的口号，学 Java 就上二哥的Java 进阶之路。”我对未来充满了信心。
“那就开始吧。”三妹说。
01、定义抽象类
定义抽象类的时候需要用到关键字 abstract ，放在 class 关键字前，就像下面这样。
12abstract class AbstractPlayer {}
关于抽象类的命名，《阿里的 Java 开发手册》上有强调，“抽象类命名要使用 Abstract 或 Base 开头”，这条规约还是值得遵守的，真正做到名如其意。
02、抽象类的特征
抽象类是不能实例化的，尝试通过 new 关键字实例化的话，编译器会报错，提示“类是抽象的，不能实例化”。

虽然抽象类不能实例化，但可以有子类。子类通过 extends 关键字来继承抽象类。就像下面这样。
12public class BasketballPlayer extends AbstractPlayer {}
如果一个类定义了一个或多个抽象方法，那么这个类必须是抽象类。
当我们尝试在一个普通类中定义抽象方法的时候，编译器会有两处错误提示。第一处在类级别上，提示“这个类必须通过 abstract 关键字定义”，见下图。

第二处在尝试定义 abstract 的方法上，提示“抽象方法所在的类不是抽象的”，见下图。

抽象类中既可以定义抽象方法，也可以定义普通方法，就像下面这样：
1234567public abstract class AbstractPlayer {    abstract void play();        public void sleep() {        System.out.println(&quot;运动员也要休息而不是挑战极限&quot;);    }}
抽象类派生的子类必须实现父类中定义的抽象方法。比如说，抽象类 AbstractPlayer 中定义了 play() 方法，子类 BasketballPlayer 中就必须实现。
123456public class BasketballPlayer extends AbstractPlayer {    @Override    void play() {        System.out.println(&quot;我是张伯伦，篮球场上得过 100 分&quot;);    }}
如果没有实现的话，编译器会提示“子类必须实现抽象方法”，见下图。

03、抽象类的应用场景
“二哥，抽象方法我明白了，那什么时候使用抽象方法呢？能给我讲讲它的应用场景吗？”三妹及时的插话道。
“这问题问的恰到好处呀！”我扶了扶眼镜继续说。
01）第一种场景
当我们希望一些通用的功能被多个子类复用的时候，就可以使用抽象类。比如说，AbstractPlayer 抽象类中有一个普通的方法 sleep() ，表明所有运动员都需要休息，那么这个方法就可以被子类复用。
12345abstract class AbstractPlayer {    public void sleep() {        System.out.println(&quot;运动员也要休息而不是挑战极限&quot;);    }}
子类 BasketballPlayer 继承了 AbstractPlayer 类：
12class BasketballPlayer extends AbstractPlayer {}
也就拥有了 sleep() 方法。BasketballPlayer 的对象可以直接调用父类的 sleep() 方法：
12BasketballPlayer basketballPlayer &#x3D; new BasketballPlayer();basketballPlayer.sleep();
子类 FootballPlayer 继承了 AbstractPlayer 类：
12class FootballPlayer extends AbstractPlayer {}
也拥有了 sleep() 方法，FootballPlayer 的对象也可以直接调用父类的 sleep() 方法：
12FootballPlayer footballPlayer &#x3D; new FootballPlayer();footballPlayer.sleep();
这样是不是就实现了代码的复用呢？
02）第二种场景
当我们需要在抽象类中定义好 API，然后在子类中扩展实现的时候就可以使用抽象类。比如说，AbstractPlayer 抽象类中定义了一个抽象方法 play() ，表明所有运动员都可以从事某项运动，但需要对应子类去扩展实现，表明篮球运动员打篮球，足球运动员踢足球。
123abstract class AbstractPlayer {    abstract void play();}
BasketballPlayer 继承了 AbstractPlayer 类，扩展实现了自己的 play() 方法。
123456public class BasketballPlayer extends AbstractPlayer {    @Override    void play() {        System.out.println(&quot;我是张伯伦，我篮球场上得过 100 分，&quot;);    }}
FootballPlayer 继承了 AbstractPlayer 类，扩展实现了自己的 play() 方法。
123456public class FootballPlayer extends AbstractPlayer {    @Override    void play() {        System.out.println(&quot;我是C罗，我能接住任意高度的头球&quot;);    }}
为了进一步展示抽象类的特性，我们再来看一个具体的示例。

PS：网站评论区说涉及到了文件的读写以及 Java 8 的新特性，不适合新人，如果觉得自己实在是看不懂，跳过，等学了 IO 流再来看也行。如果说是为了复习 Java 基础知识，就不存在这个问题了。

假设现在有一个文件，里面的内容非常简单，只有一个“Hello World”，现在需要有一个读取器将内容从文件中读取出来，最好能按照大写的方式，或者小写的方式来读。
这时候，最好定义一个抽象类 BaseFileReader：
1234567891011121314151617181920212223242526272829303132&#x2F;** * 抽象类，定义了一个读取文件的基础框架，其中 mapFileLine 是一个抽象方法，具体实现需要由子类来完成 *&#x2F;abstract class BaseFileReader {    protected Path filePath; &#x2F;&#x2F; 定义一个 protected 的 Path 对象，表示读取的文件路径        &#x2F;**     * 构造方法，传入读取的文件路径     * @param filePath 读取的文件路径     *&#x2F;    protected BaseFileReader(Path filePath) {        this.filePath &#x3D; filePath;    }        &#x2F;**     * 读取文件的方法，返回一个字符串列表     * @return 字符串列表，表示文件的内容     * @throws IOException 如果文件读取出错，抛出该异常     *&#x2F;    public List&lt;String&gt; readFile() throws IOException {        return Files.lines(filePath) &#x2F;&#x2F; 使用 Files 类的 lines 方法，读取文件的每一行                .map(this::mapFileLine) &#x2F;&#x2F; 对每一行应用 mapFileLine 方法，将其转化为指定的格式                .collect(Collectors.toList()); &#x2F;&#x2F; 将处理后的每一行收集到一个字符串列表中，返回    }        &#x2F;**     * 抽象方法，子类需要实现该方法，将文件中的每一行转化为指定的格式     * @param line 文件中的每一行     * @return 转化后的字符串     *&#x2F;    protected abstract String mapFileLine(String line);}

filePath 为文件路径，使用 protected 修饰，表明该成员变量可以在需要时被子类访问到。
readFile() 方法用来读取文件，方法体里面调用了抽象方法 mapFileLine() ——需要子类来扩展实现大小写的不同读取方式。

在我看来，BaseFileReader 类设计的就非常合理，并且易于扩展，子类只需要专注于具体的大小写实现方式就可以了。
小写的方式：
123456789class LowercaseFileReader extends BaseFileReader {    protected LowercaseFileReader(Path filePath) {        super(filePath);    }    @Override    protected String mapFileLine(String line) {        return line.toLowerCase();    }}
大写的方式：
123456789class UppercaseFileReader extends BaseFileReader {    protected UppercaseFileReader(Path filePath) {        super(filePath);    }    @Override    protected String mapFileLine(String line) {        return line.toUpperCase();    }}
从文件里面一行一行读取内容的代码被子类复用了。与此同时，子类只需要专注于自己该做的工作，LowercaseFileReader 以小写的方式读取文件内容，UppercaseFileReader 以大写的方式读取文件内容。
来看一下测试类 FileReaderTest：
1234567891011public class FileReaderTest {    public static void main(String[] args) throws URISyntaxException, IOException {        URL location &#x3D; FileReaderTest.class.getClassLoader().getResource(&quot;helloworld.txt&quot;);        Path path &#x3D; Paths.get(location.toURI());        BaseFileReader lowercaseFileReader &#x3D; new LowercaseFileReader(path);        BaseFileReader uppercaseFileReader &#x3D; new UppercaseFileReader(path);        System.out.println(lowercaseFileReader.readFile());        System.out.println(uppercaseFileReader.readFile());    }}
在项目的 resource 目录下建一个文本文件，名字叫 helloworld.txt，里面的内容就是“Hello World”。文件的具体位置如下图所示，我用的集成开发环境是 Intellij IDEA。

在 resource 目录下的文件可以通过 ClassLoader.getResource() 的方式获取到 URI 路径，然后就可以取到文本内容了。
输出结果如下所示：
12[hello world][HELLO WORLD]
04、抽象类总结
好了，对于抽象类我们简单总结一下：

抽象类不能被实例化。
抽象类应该至少有一个抽象方法，否则它没有任何意义。
抽象类中的抽象方法没有方法体。
抽象类的子类必须给出父类中的抽象方法的具体实现，除非该子类也是抽象类。

“完了吗？二哥”三妹似乎还沉浸在聆听教诲的快乐中。
“是滴，这次我们系统化的学习了抽象类，可以说面面俱到了。三妹你可以把代码敲一遍，加强了一些印象，电脑交给你了。”
3.11 Java接口“今天开始讲 Java 的接口。”我对三妹说，“对于面向对象编程来说，抽象是一个极具魅力的特征。如果一个程序员的抽象思维很差，那他在编程中就会遇到很多困难，无法把业务变成具体的代码。在 Java 中，可以通过两种形式来达到抽象的目的，一种上一篇的主角——抽象类，另外一种就是今天的主角——接口。”
“是呀是呀，让我们开始吧！”
01、定义接口
“接口是什么呀？”三妹顺着我的话题及时的插话到。
接口通过 interface 关键字来定义，它可以包含一些常量和方法，来看下面这个示例。
1234567891011121314public interface Electronic {    &#x2F;&#x2F; 常量    String LED &#x3D; &quot;LED&quot;;    &#x2F;&#x2F; 抽象方法    int getElectricityUse();    &#x2F;&#x2F; 静态方法    static boolean isEnergyEfficient(String electtronicType) {        return electtronicType.equals(LED);    }    &#x2F;&#x2F; 默认方法    default void printDescription() {        System.out.println(&quot;电子&quot;);    }}
来看一下这段代码反编译后的字节码。
12345678910111213public interface Electronic{    public abstract int getElectricityUse();    public static boolean isEnergyEfficient(String electtronicType)    {        return electtronicType.equals(&quot;LED&quot;);    }    public void printDescription()    {        System.out.println(&quot;\u7535\u5B50&quot;);    }    public static final String LED &#x3D; &quot;LED&quot;;}
发现没？接口中定义的所有变量或者方法，都会自动添加上 public 关键字。
接下来，我来一一解释下 Electronic 接口中的核心知识点。
1）接口中定义的变量会在编译的时候自动加上 public static final修饰符（注意看一下反编译后的字节码），也就是说上例中的 LED 变量其实就是一个常量。
Java 官方文档上有这样的声明：

Every field declaration in the body of an interface is implicitly public, static, and final.

换句话说，接口可以用来作为常量类使用，还能省略掉 public static final ，看似不错的一种选择，对吧？
不过，这种选择并不可取。因为接口的本意是对方法进行抽象，而常量接口会对子类中的变量造成命名空间上的“污染”。
2）没有使用 private、 default或者 static关键字修饰的方法是隐式抽象的，在编译的时候会自动加上 public abstract 修饰符。也就是说上例中的 getElectricityUse() 其实是一个抽象方法，没有方法体——这是定义接口的本意。
3）从 Java 8 开始，接口中允许有静态方法，比如说上例中的 isEnergyEfficient() 方法。
静态方法无法由（实现了该接口的）类的对象调用，它只能通过接口名来调用，比如说Electronic.isEnergyEfficient(“LED”) 。
接口中定义静态方法的目的是为了提供一种简单的机制，使我们不必创建对象就能调用方法，从而提高接口的竞争力。
4）接口中允许定义 方法也是从 Java 8 开始的，比如说上例中的 printDescription() 方法，它始终由一个代码块组成，为实现该接口而不覆盖该方法的类提供默认实现。既然要提供默认实现，就要有方法体，换句话说，默认方法后面不能直接使用“;”号来结束——编译器会报错。

“为什么要在接口中定义默认方法呢？”三妹好奇地问到。
允许在接口中定义默认方法的理由很充分，因为一个接口可能有多个实现类，这些类就必须实现接口中定义的抽象类，否则编译器就会报错。假如我们需要在所有的实现类中追加某个具体的方法，在没有 default方法的帮助下，我们就必须挨个对实现类进行修改。
由之前的例子我们就可以得出下面这些结论：

接口中允许定义变量
接口中允许定义抽象方法
接口中允许定义静态方法（Java 8 之后）
接口中允许定义默认方法（Java 8 之后）

除此之外，我们还应该知道：
1）接口不允许直接实例化，否则编译器会报错。

需要定义一个类去实现接口，见下例。
12345678910public class Computer implements Electronic {    public static void main(String[] args) {        new Computer();    }        @Override    public int getElectricityUse() {        return 0;    }}
然后再实例化。
1Electronic e &#x3D; new Computer();
2）接口可以是空的，既可以不定义变量，也可以不定义方法。最典型的例子就是 Serializable 接口，在java.io 包下。
12public interface Serializable {}
Serializable 接口用来为序列化的具体实现提供一个标记，也就是说，只要某个类实现了 Serializable 接口，那么它就可以用来序列化了。
3）不要在定义接口的时候使用 final 关键字，否则会报编译错误，因为接口就是为了让子类实现的，而final 阻止了这种行为。

4）接口的抽象方法不能是 private、protected 或者 final，否则编译器都会报错。

5）接口的变量是隐式 public static final（常量），所以其值无法改变。
02、接口的作用
“接口可以做什么呢？”三妹见缝插针，问的很及时。
第一，使某些实现类具有我们想要的功能，比如说，实现了 Cloneable 接口的类具有拷贝的功能，实现了Comparable 或者 Comparator 的类具有比较功能。
Cloneable 和 Serializable 一样，都属于标记型接口，它们内部都是空的。实现了 Cloneable 接口的类可以使用 Object.clone() 方法，否则会抛出 CloneNotSupportedException。
12345678910public class CloneableTest implements Cloneable {    @Override    protected Object clone() throws CloneNotSupportedException {        return super.clone();    }    public static void main(String[] args) throws CloneNotSupportedException {        CloneableTest c1 &#x3D; new CloneableTest();        CloneableTest c2 &#x3D; (CloneableTest) c1.clone();    }}
运行后没有报错。现在把 implements Cloneable 去掉。
12345678910public class CloneableTest {    @Override    protected Object clone() throws CloneNotSupportedException {        return super.clone();    }    public static void main(String[] args) throws CloneNotSupportedException {        CloneableTest c1 &#x3D; new CloneableTest();        CloneableTest c2 &#x3D; (CloneableTest) c1.clone();    }}
运行后抛出 CloneNotSupportedException：
12345Exception in thread &quot;main&quot; java.lang.CloneNotSupportedException: com.cmower.baeldung.interface1.CloneableTest    at java.base&#x2F;java.lang.Object.clone(Native Method)    at com.cmower.baeldung.interface1.CloneableTest.clone(CloneableTest.java:6)    at com.cmower.baeldung.interface1.CloneableTest.main(CloneableTest.java:11)
第二，Java 原则上只支持单一继承，但通过接口可以实现多重继承的目的。
如果有两个类共同继承（extends）一个父类，那么父类的方法就会被两个子类重写。然后，如果有一个新类同时继承了这两个子类，那么在调用重写方法的时候，编译器就不能识别要调用哪个类的方法了。这也正是著名的菱形问题，见下图。

简单解释下，ClassC 同时继承了 ClassA 和 ClassB，ClassC 的对象在调用 ClassA 和 ClassB 中重写的方法时，就不知道该调用 ClassA 的方法，还是 ClassB 的方法。
接口没有这方面的困܃。来定义两个接口，Fly 接口会飞，Run 接口会跑。
1234567public interface Fly {    void fly();}public interface Run {    void run();}
然后让 Pig 类同时实现这两个接口。
1234567891011public class Pig implements Fly,Run{    @Override    public void fly() {        System.out.println(&quot;会飞的猪&quot;);    }        @Override    public void run() {        System.out.println(&quot;会跑的猪&quot;);    }}
在某种形式上，接口实现了多重继承的目的：现实世界里，猪的确只会跑，但在雷军的眼里，站在风口的猪就会飞，这就需要赋予这只猪更多的能力，通过抽象类是无法实现的，只能通过接口。
第三，实现多态。
什么是多态呢？通俗的理解，就是同一个事件发生在不同的对象上会产生不同的结果，鼠标左键点击窗口上的 X 号可以关闭窗口，点击超链接却可以打开新的网页。
多态可以通过继承（ extends ）的关系实现，也可以通过接口的形式实现。
Shape 接口表示一个形状。
123public interface Shape {    String name();}
Circle 类实现了 Shape 接口，并重写了 name() 方法。
123456public class Circle implements Shape {    @Override    public String name() {        return &quot;圆&quot;;    }}
Square 类也实现了 Shape 接口，并重写了 name() 方法。
123456public class Square implements Shape {    @Override    public String name() {        return &quot;正方形&quot;;    }}
然后来看测试类。
12345678List&lt;Shape&gt; shapes &#x3D; new ArrayList&lt;&gt;();Shape circleShape &#x3D; new Circle();Shape squareShape &#x3D; new Square();shapes.add(circleShape);shapes.add(squareShape);for (Shape shape : shapes) {    System.out.println(shape.name());}
这就实现了多态，变量 circleShape、squareShape 的引用类型都是 Shape，但执行 shape.name() 方法的时候，Java 虚拟机知道该去调用 Circle 的 name() 方法还是 Square 的 name() 方法。
说一下多态存在的 3 个前提：

要有继承关系，比如说 Circle 和 Square 都实现了 Shape 接口。
子类要重写父类的方法，Circle 和 Square 都重写了 name() 方法。
父类引用指向子类对象，circleShape 和 squareShape 的类型都为 Shape，但前者指向的是 Circle对象，后者指向的是 Square 对象。

然后，我们来看一下测试结果：
12圆正方形
也就意味着，尽管在 for 循环中，shape 的类型都为 Shape，但在调用 name() 方法的时候，它知道 Circle对象应该调用 Circle 类的 name() 方法，Square 对象应该调用 Square 类的 name() 方法。
03、接口的三种模式
在编程领域，好的设计模式能够让我们的代码事半功倍。在使用接口的时候，经常会用到三种模式，分别是策略模式、适配器模式和工厂模式。
1）策略模式
策略模式的思想是，针对一组算法，将每一种算法封装到具有共同接口的实现类中，接口的设计者可以在不影响调用者的情况下对算法做出改变。示例如下：
12345678910111213141516171819202122232425262728293031323334&#x2F;&#x2F; 接口：教练interface Coach {    &#x2F;&#x2F; 方法：防守    void defend();}&#x2F;&#x2F; 何塞·穆里尼奥class Hesai implements Coach {    @Override    public void defend() {        System.out.println(&quot;防守赢得冠军&quot;);    }}&#x2F;&#x2F; 德普·瓜迪奥拉class Guatu implements Coach {    @Override    public void defend() {        System.out.println(&quot;进攻就是最好的防守&quot;);    }}public class Demo {    &#x2F;&#x2F; 参数为接口    public static void defend(Coach coach) {        coach.defend();    }        public static void main(String[] args) {        &#x2F;&#x2F; 为同一个方法传递不同的对象        defend(new Hesai());        defend(new Guatu());    }}
Demo.defend() 方法可以接受不同风格的 Coach，并根据所传递的参数对象的不同而产生不同的行为，这被称为“策略模式”。
2）适配器模式
适配器模式的思想是，针对调用者的需求对原有的接口进行转接。生活当中最常见的适配器就是HDMI（英语： High Definition Multimedia Interface ，中文：高清多媒体接口）线，可以同时发送音频和视频信号。适配器模式的示例如下：
123456789101112131415161718192021222324interface Coach {    void defend();    void attack();}&#x2F;&#x2F; 抽象类实现接口，并置空方法abstract class AdapterCoach implements Coach {    public void defend() {};    public void attack() {};}&#x2F;&#x2F; 新类继承适配器class Hesai extends AdapterCoach {    public void defend() {        System.out.println(&quot;防守赢得冠军&quot;);    }}public class Demo {    public static void main(String[] args) {        Coach coach &#x3D; new Hesai();        coach.defend();    }}
Coach 接口中定义了两个方法（ defend() 和 attack() ），如果类直接实现该接口的话，就需要对两个方法进行实现。
如果我们只需要对其中一个方法进行实现的话，就可以使用一个抽象类作为中间件，即适配器（AdapterCoach），用这个抽象类实现接口，并对抽象类中的方法置空（方法体只有一对花括号），这时候，新类就可以绕过接口，继承抽象类，我们就可以只对需要的方法进行覆盖，而不是接口中的所有方法。
3）工厂模式
所谓的工厂模式理解起来也不难，就是什么工厂生产什么，比如说宝马工厂生产宝马，奔驰工厂生产奔驰，A 级学院毕业 A 级教练，C 级学院毕业 C 级教练。示例如下：
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&#x2F;&#x2F; 教练interface Coach {    void command();}&#x2F;&#x2F; 教练学院interface CoachFactory {    Coach createCoach();}&#x2F;&#x2F; A级教练class ACoach implements Coach {    @Override    public void command() {        System.out.println(&quot;我是A级证书教练&quot;);    }    }&#x2F;&#x2F; A级教练学院class ACoachFactory implements CoachFactory {    @Override    public Coach createCoach() {        return new ACoach();    }    }&#x2F;&#x2F; C级教练class CCoach implements Coach {    @Override    public void command() {        System.out.println(&quot;我是C级证书教练&quot;);    }    }&#x2F;&#x2F; C级教练学院class CCoachFactory implements CoachFactory {    @Override    public Coach createCoach() {        return new CCoach();    }}public class Demo {    public static void create(CoachFactory factory) {        factory.createCoach().command();    }        public static void main(String[] args) {        &#x2F;&#x2F; 对于一支球队来说，需要什么样的教练就去找什么样的学院        &#x2F;&#x2F; 学院会介绍球队对应水平的教练。        create(new ACoachFactory());        create(new CCoachFactory());    }}
有两个接口，一个是 Coach（教练），可以 command() （指挥球队）；另外一个是 CoachFactory（教练学院），能 createCoach() （教出一名优秀的教练）。然后 ACoach 类实现 Coach 接口，ACoachFactory 类实现 CoachFactory 接口；CCoach 类实现 Coach 接口，CCoachFactory 类实现 CoachFactory 接口。当需要 A 级教练时，就去找 A 级教练学院；当需要 C 级教练时，就去找 C 级教练学院。
依次类推，我们还可以用 BCoach 类实现 Coach 接口，BCoachFactory 类实现 CoachFactory 接口，从而不断地丰富教练的梯队。
“怎么样三妹，一下子接收这么多知识点不容易吧？”
“其实还好啊，二哥你讲的这么细致，我都做好笔记 了，学习嘛，认真一点，效果就会好很多了。”
三妹这种积极乐观的态度真的让我感觉到“付出就会有收获。
04、抽象类和接口的区别
简单总结一下抽象类和接口的区别。
在 Java 中，通过关键字 abstract 定义的类叫做抽象类。Java 是一门面向对象的语言，因此所有的对象都是通过类来描述的；但反过来，并不是所有的类都是用来描述对象的，抽象类就是其中的一种。
以下示例展示了一个简单的抽象类：
12345&#x2F;&#x2F; 个人认为，一名教练必须攻守兼备abstract class Coach {    public abstract void defend();    public abstract void attack();}
我们知道，有抽象方法的类被称为抽象类，也就意味着抽象类中还能有不是抽象方法的方法。这样的类就不能算作纯粹的接口，尽管它也可以提供接口的功能——只能说抽象类是普通类与接口之间的一种中庸之道。
接口（英文：Interface），在 Java 中是一个抽象类型，是抽象方法的集合；接口通过关键字 interface来定义。接口与抽象类的不同之处在于：

抽象类可以有方法体的方法，但接口没有（Java 8 以前）。
接口中的成员变量隐式为 static final ，但抽象类不是的。
一个类可以实现多个接口，但只能继承一个抽象类。

以下示例展示了一个简单的接口：
123456&#x2F;&#x2F; 隐式的abstractinterface Coach {    &#x2F;&#x2F; 隐式的public    void defend();    void attack();}

接口是隐式抽象的，所以声明时没有必要使用 abstract 关键字；
接口的每个方法都是隐式抽象的，所以同样不需要使用 abstract 关键字；
接口中的方法都是隐式 public 的。

“哦，我理解了哥。那我再问一下，抽象类和接口有什么差别呢？”
“哇，三妹呀，你这个问题恰到好处，问到了点子上。”我不由得为三妹竖起了大拇指。
1）语法层面上

抽象类可以提供成员方法的实现细节，而接口中只能存在 public abstract 方法；
抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的；
接口中不能含有静态代码块，而抽象类可以有静态代码块；
一个类只能继承一个抽象类，而一个类却可以实现多个接口。

2）设计层面上
抽象类是对一种事物的抽象，即对类抽象，继承抽象类的子类和抽象类本身是一种 is-a 的关系。而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。
举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类 Airplane，将鸟设计为一个类 Bird，但是不能将 飞行 这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。
此时可以将 飞行 设计为一个接口 Fly，包含方法 fly()，然后 Airplane 和 Bird 分别根据自己的需要实现 Fly这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承 Airplane 即可，对于鸟也是类似的，不同种类的鸟直接继承 Bird 类即可。从这里可以看出，继承是一个 “是不是”的关系，而 接口 实现则是”有没有”的关系。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。
接口是对类的某种行为的一种抽象，接口和类之间并没有很强的关联关系，举个例子来说，所有的类都可以实现 Serializable 接口，从而具有序列化的功能，但不能说所有的类和 Serializable 之间是 is-a 的关系。
抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。什么是模板式设计？最简单例子，大家都用过 ppt 里面的模板，如果用模板 A 设计了 ppt B 和 ppt C，ppt B 和ppt C 公共的部分就是模板 A 了，如果它们的公共部分需要改动，则只需要改动模板 A 就可以了，不需要重新对 ppt B 和 ppt C 进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。
3.12 Java内部类“在 Java 中，可以将一个类定义在另外一个类里面或者一个方法里面，这样的类叫做内部类。”我放下手中的枸杞杯，对三妹说，“一般来说，内部类分为成员内部类、局部内部类、匿名内部类和静态内部类。”
1）成员内部类
成员内部类是最常见的内部类，看下面的代码：
1234567class Wanger {    int age &#x3D; 18;        class Wangxiaoer {        int age &#x3D; 81;    }}
看起来内部类 Wangxiaoer 就好像 Wanger 的一个成员，成员内部类可以无限制访问外部类的所有成员属性。
1234567891011121314public class Wanger {    int age &#x3D; 18;    private String name &#x3D; &quot;沉默&quot;;    static double money &#x3D; 1;        class Wangxiaoer {        int age &#x3D; 81;                public void print() {            System.out.println(name);            System.out.println(money);        }    }}
内部类可以随心所欲地访问外部类的成员，但外部类想要访问内部类的成员，就不那么容易了，必须先创建一个成员内部类的对象，再通过这个对象来访问：
1234567891011121314151617public class Wanger {    int age &#x3D; 18;    private String name &#x3D; &quot;沉默&quot;;    static double money &#x3D; 1;        public Wanger () {        new Wangxiaoer().print();    }        class Wangxiaoer {        int age &#x3D; 81;        public void print() {            System.out.println(name);            System.out.println(money);        }    }}
这也就意味着，如果想要在静态方法中访问成员内部类的时候，就必须先得创建一个外部类的对象，因为内部类是依附于外部类的。
123456789101112131415161718192021222324public class Wanger {    int age &#x3D; 18;    private String name &#x3D; &quot;沉默&quot;;    static double money &#x3D; 1;        public Wanger () {        new Wangxiaoer().print();    }        public static void main(String[] args) {        Wanger wanger &#x3D; new Wanger();        Wangxiaoer xiaoer &#x3D; wanger.new Wangxiaoer();        xiaoer.print();    }        class Wangxiaoer {        int age &#x3D; 81;                public void print() {            System.out.println(name);            System.out.println(money);        }    }}
这种创建内部类的方式在实际开发中并不常用，因为内部类和外部类紧紧地绑定在一起，使用起来非常不便。
2）局部内部类
局部内部类是定义在一个方法或者一个作用域里面的类，所以局部内部类的生命周期仅限于作用域内。
12345678public class Wangsan {    public Wangsan print() {        class Wangxiaosan extends Wangsan{            private int age &#x3D; 18;        }        return new Wangxiaosan();    }}
局部内部类就好像一个局部变量一样，它是不能被权限修饰符修饰的，比如说 public、protected、private和 static 等。

3）匿名内部类
匿名内部类是我们平常用得最多的，尤其是启动多线程的时候，会经常用到，并且 IDE 也会帮我们自动生成。
1234567891011public class ThreadDemo {    public static void main(String[] args) {        Thread t &#x3D; new Thread(new Runnable() {            @Override            public void run() {                System.out.println(Thread.currentThread().getName());            }        });        t.start();    }}
匿名内部类就好像一个方法的参数一样，用完就没了，以至于我们都不需要为它专门写一个构造方法，它的名字也是由系统自动命名的。仔细观察编译后的字节码文件也可以发现，匿名内部类连名字都不配拥有，哈哈，直接借用的外部类，然后 $1 就搞定了。

匿名内部类是唯一一种没有构造方法的类。就上面的写法来说，匿名内部类也不允许我们为其编写构造方法，因为它就像是直接通过 new 关键字创建出来的一个对象。
匿名内部类的作用主要是用来继承其他类或者实现接口，并不需要增加额外的方法，方便对继承的方法进行实现或者重写。
4）静态内部类
静态内部类和成员内部类类似，只是多了一个 static 关键字。
12345678910public class Wangsi {    static int age;    double money;        static class Wangxxiaosi {        public Wangxxiaosi (){            System.out.println(age);        }    }}
由于 static 关键字的存在，静态内部类是不允许访问外部类中非 static 的变量和方法的，这一点也非常好理解：你一个静态的内部类访问我非静态的成员变量干嘛？

“为什么要使用内部类呢？”三妹问。
三妹这个问题问的非常妙，是时候引经据典了。
在《Think in java》中有这样一句话：

使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。

在我们程序设计中有时候会存在一些使用接口很难解决的问题，这个时候我们可以利用内部类提供的、可以继承多个具体的或者抽象的类的能力来解决这些程序设计问题。可以这样说，接口只是解决了部分问题，而内部类使得多重继承的解决方案变得更加完整。
使用内部类还能够为我们带来如下特性：

内部类可以使用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。
在单个外部类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。
创建内部类对象的时刻并不依赖于外部类对象的创建。
内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。
内部类提供了更好的封装，除了该外围类，其他类都不能访问。

3.13 Java封装继承多态在谈 Java 面向对象的时候，不得不提到面向对象的三大特征：封装、继承、多态。三大特征紧密联系而又有区别，合理使用继承能大大减少重复代码，提高代码复用性。
**1）封装
“三妹，准备好了没，我们来讲 Java 封装，算是 Java 的三大特征之一，理清楚了，对以后的编程有较大的帮助。”我对三妹说。
“好的，哥，准备好了。”三妹一边听我说，一边迅速地打开了 XMind，看来一边学习一边总结思维导图这个高效的学习方式三妹已经牢记在心了。
封装从字面上来理解就是包装的意思，专业点就是信息隐藏，是指利用抽象将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。
数据被保护在类的内部，尽可能地隐藏内部的实现细节，只保留一些对外接口使之与外部发生联系。
其他对象只能通过已经授权的操作来与这个封装的对象进行交互。也就是说用户是无需知道对象内部的细节（当然也无从知道），但可以通过该对象对外的提供的接口来访问该对象。
使用封装有 4 大好处：

良好的封装能够减少耦合。
类内部的结构可以自由修改。
可以对成员进行更精确的控制。
隐藏信息，实现细节。

首先我们先来看两个类。
Husband.java
123456789101112131415161718192021222324252627282930313233343536373839404142public class Husband {        &#x2F;*     * 对属性的封装     * 一个人的姓名、性别、年龄、妻子都是这个人的私有属性     *&#x2F;    private String name ;    private String sex ;    private int age ;    private Wife wife;        &#x2F;*     * setter()、getter()是该对象对外开发的接口     *&#x2F;    public String getName() {        return name;    }        public void setName(String name) {        this.name &#x3D; name;    }        public String getSex() {        return sex;    }     public void setSex(String sex) {        this.sex &#x3D; sex;    }        public int getAge() {        return age;    }        public void setAge(int age) {        this.age &#x3D; age;    }        public void setWife(Wife wife) {        this.wife &#x3D; wife;    }}
Wife.java
12345678910111213141516171819202122232425262728293031323334public class Wife {    private String name;    private int age;    private String sex;    private Husband husband;        public String getName() {        return name;    }        public void setName(String name) {        this.name &#x3D; name;    }        public String getSex() {        return sex;    }        public void setSex(String sex) {        this.sex &#x3D; sex;    }        public void setAge(int age) {        this.age &#x3D; age;    }        public void setHusband(Husband husband) {        this.husband &#x3D; husband;    }        public Husband getHusband() {        return husband;    }}
可以看得出， Husband 类里面的 wife 属性是没有 getter() 的，同时 Wife 类的 age 属性也是没有getter() 方法的。至于理由我想三妹你是懂的。
没有哪个女人愿意别人知道她的年龄。
所以封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果不想被外界方法，我们大可不必提供方法给外界访问。
但是如果一个类没有提供给外界任何可以访问的方法，那么这个类也没有什么意义了。
比如我们将一个房子看做是一个对象，里面有漂亮的装饰，如沙发、电视剧、空调、茶桌等等都是该房子的私有属性，但是如果我们没有那些墙遮挡，是不是别人就会一览无余呢？没有一点儿隐私！
因为存在那个遮挡的墙，我们既能够有自己的隐私而且我们可以随意的更改里面的摆设而不会影响到外面的人。
但是如果没有门窗，一个包裹的严严实实的黑盒子，又有什么存在的意义呢？所以通过门窗别人也能够看到里面的风景。所以说门窗就是房子对象留给外界访问的接口。
通过这个我们还不能真正体会封装的好处。现在我们从程序的角度来分析封装带来的好处。如果我们不使用封装，那么该对象就没有 setter() 和 getter() ，那么 Husband 类应该这样写：
123456public class Husband {    public String name ;    public String sex ;    public int age ;    public Wife wife;}
我们应该这样来使用它：
1234Husband husband &#x3D; new Husband();husband.age &#x3D; 30;husband.name &#x3D; &quot;张三&quot;;husband.sex &#x3D; &quot;男&quot;;    &#x2F;&#x2F;貌似有点儿多余
但是哪天如果我们需要修改 Husband，例如将 age 修改为 String 类型的呢？你只有一处使用了这个类还好，如果你有几十个甚至上百个这样地方，你是不是要改到崩溃。如果使用了封装，我们完全可以不需要做任何修改，只需要稍微改变下 Husband 类的 setAge() 方法即可。
1234567891011121314151617181920212223public class Husband {        &#x2F;*     * 对属性的封装     * 一个人的姓名、性别、年龄、妻子都是这个人的私有属性     *&#x2F;    private String name ;    private String sex ;    private String age ;    &#x2F;* 改成 String类型的*&#x2F;    private Wife wife;        public String getAge() {        return age;    }        public void setAge(int age) {        &#x2F;&#x2F;转换即可        this.age &#x3D; String.valueOf(age);    }        &#x2F;** 省略其他属性的setter、getter **&#x2F;    }
其他的地方依然这样引用( husband.setAge(22) )保持不变。
到了这里我们确实可以看出，封装确实可以使我们更容易地修改类的内部实现，而无需修改使用了该类的代码。
我们再看这个好处：封装可以对成员变量进行更精确的控制。
还是那个 Husband，一般来说我们在引用这个对象的时候是不容易出错的，但是有时你迷糊了，写成了这样：
12Husband husband &#x3D; new Husband();husband.age &#x3D; 300;
也许你是因为粗心写成了这样，你发现了还好，如果没有发现那就麻烦大了，谁见过 300 岁的老妖怪啊！但是使用封装我们就可以避免这个问题，我们对 age 的访问入口做一些控制(setter)如：
123456789101112131415161718192021222324252627public class Husband {        &#x2F;*     * 对属性的封装     * 一个人的姓名、性别、年龄、妻子都是这个人的私有属性     *&#x2F;    private String name ;    private String sex ;    private int age ;    &#x2F;* 改成 String类型的*&#x2F;    private Wife wife;        public int getAge() {        return age;    }        public void setAge(int age) {        if(age &gt; 120){            System.out.println(&quot;ERROR：error age input....&quot;);    &#x2F;&#x2F;提示錯誤信息        }else{            this.age &#x3D; age;        }            }        &#x2F;** 省略其他属性的setter、getter **&#x2F;    }
上面都是对 setter 方法的控制，其实通过封装我们也能够对对象的出口做出很好的控制。例如性别在数据库中一般都是以 1、0 的方式来存储的，但是在前台我们又不能展示 1、0，这里我们只需要在 getter() 方法里面做一些转换即可。
12345678public String getSexName() {    if(&quot;0&quot;.equals(sex)){        sexName &#x3D; &quot;女&quot;;    }else if(&quot;1&quot;.equals(sex)){        sexName &#x3D; &quot;男&quot;;    }    return sexName;}
在使用的时候我们只需要使用 sexName 即可实现正确的性别显示。同理也可以用于针对不同的状态做出不同的操作。
“好了，关于封装我们就暂时就聊这么多吧。”我喝了一口普洱茶后，对三妹说。
“好的，哥，我懂了。”
2）继承
01、什么是继承
继承（英语：inheritance）是面向对象软件技术中的一个概念。它使得复用以前的代码非常容易。
Java 语言是非常典型的面向对象的语言，在 Java 语言中继承就是子类继承父类的属性和方法，使得子类对象（实例）具有父类的属性和方法，或子类从父类继承方法，使得子类具有父类相同的方法。
我们来举个例子：动物有很多种，是一个比较大的概念。在动物的种类中，我们熟悉的有猫(Cat)、狗(Dog)等动物，它们都有动物的一般特征（比如能够吃东西，能够发出声音），不过又在细节上有区别（不同动物的吃的不同，叫声不一样）。
在 Java 语言中实现 Cat 和 Dog 等类的时候，就需要继承 Animal 这个类。继承之后 Cat、Dog 等具体动物类就是子类，Animal 类就是父类。

02、为什么需要继承
三妹，你可能会问为什么需要继承？
如果仅仅只有两三个类，每个类的属性和方法很有限的情况下确实没必要实现继承，但事情并非如此，事实上一个系统中往往有很多个类并且有着很多相似之处，比如猫和狗同属动物，或者学生和老师同属人。各个类可能又有很多个相同的属性和方法，这样的话如果每个类都重新写不仅代码显得很乱，代码工作量也很大。
这时继承的优势就出来了：可以直接使用父类的属性和方法，自己也可以有自己新的属性和方法满足拓展，父类的方法如果自己有需求更改也可以重写。这样使用继承不仅大大的减少了代码量，也使得代码结构更加清晰可见。

所以这样从代码的层面上来看我们设计这个完整的 Animal 类是这样的：
123456789101112131415161718192021222324252627282930class Animal{    public int id;    public String name;    public int age;    public int weight;        public Animal(int id, String name, int age, int weight) {        this.id &#x3D; id;        this.name &#x3D; name;        this.age &#x3D; age;        this.weight &#x3D; weight;    }        &#x2F;&#x2F;这里省略get set方法    public void sayHello()    {        System.out.println(&quot;hello&quot;);    }        public void eat()    {        System.out.println(&quot;I&#39;m eating&quot;);    }        public void sing()    {        System.out.println(&quot;sing&quot;);    }}
而 Dog，Cat，Chicken 类可以这样设计：
123456789101112131415161718192021222324class Dog extends Animal&#x2F;&#x2F;继承animal{    public Dog(int id, String name, int age, int weight) {        super(id, name, age, weight);&#x2F;&#x2F;调用父类构造方法    }}class Cat extends Animal{    public Cat(int id, String name, int age, int weight) {        super(id, name, age, weight);&#x2F;&#x2F;调用父类构造方法    }}class Chicken extends Animal{    public Chicken(int id, String name, int age, int weight) {        super(id, name, age, weight);&#x2F;&#x2F;调用父类构造方法    }        &#x2F;&#x2F;鸡下蛋    public void layEggs()    {        System.out.println(&quot;我是老母鸡下蛋啦，咯哒咯！咯哒咯！&quot;);    }}
各自的类继承 Animal 后可以直接使用 Animal 类的属性和方法而不需要重复编写，各个类如果有自己的方法也可很容易地拓展。
03、继承的分类
继承分为单继承和多继承，Java 语言只支持类的单继承，但可以通过实现接口的方式达到多继承的目的。这个我们之前在讲接口的时候就提到过，这里我们再聊一下。




继承
定义
优缺点




单继承
一个子类只拥有一个父类
优点：在类层次结构上比较清晰缺点：结构的丰富度有时不能满足使用需求


多继承（Java 不支持，但可以用其它方式满足多继承使用需求）
一个子类拥有多个直接的父类
优点：子类的丰富度很高缺点：容易造成混乱




单继承
单继承，一个子类只有一个父类，如我们上面讲过的 Animal 类和它的子类。单继承在类层次结构上比较清晰，但缺点是结构的丰富度有时不能满足使用需求。
多继承
多继承，一个子类有多个直接的父类。这样做的好处是子类拥有所有父类的特征，子类的丰富度很高，但是缺点就是容易造成混乱。下图为一个混乱的例子。

Java 虽然不支持多继承，但是 Java 有三种实现多继承效果的方式，分别是内部类、多层继承和实现接口。
内部类可以继承一个与外部类无关的类，保证了内部类的独立性，正是基于这一点，可以达到多继承的效果。
多层继承：子类继承父类，父类如果还继承其他的类，那么这就叫多层继承。这样子类就会拥有所有被继承类的属性和方法。

实现接口无疑是满足多继承使用需求的最好方式，一个类可以实现多个接口满足自己在丰富性和复杂环境的使用需求。
类和接口相比，类就是一个实体，有属性和方法，而接口更倾向于一组方法。举个例子，就拿斗罗大陆的唐三来看，他存在的继承关系可能是这样的：

04、如何实现继承
extends 关键字
在 Java 中，类的继承是单一继承，也就是说一个子类只能拥有一个父类，所以extends只能继承一个类。其使用语法为：
1class 子类名 extends 父类名{}
例如 Dog 类继承 Animal 类，它是这样的：
12class Animal{} &#x2F;&#x2F;定义Animal类class Dog extends Animal{} &#x2F;&#x2F;Dog类继承Animal类
子类继承父类后，就拥有父类的非私有的属性和方法。如果不明白，请看这个案例，在 IDEA 下创建一个项目，创建一个 test 类做测试，分别创建 Animal 类和 Dog 类，Animal 作为父类写一个 sayHello()方法，Dog 类继承 Animal 类之后就可以调用 sayHello()方法。具体代码为：
12345678910111213141516class Animal {    public void  sayHello()&#x2F;&#x2F;父类的方法    {        System.out.println(&quot;hello,everybody&quot;);    }}class Dog extends Animal&#x2F;&#x2F;继承animal{ }public class test {    public static void main(String[] args) {       Dog dog&#x3D;new Dog();       dog.sayHello();    }}
点击运行的时候 Dog 子类可以直接使用 Animal 父类的方法。

implements 关键字
使用 implements 关键字可以变相使 Java 拥有多继承的特性，使用范围为类实现接口的情况，一个类可以实现多个接口(接口与接口之间用逗号分开)。
我们来看一个案例，创建一个 test2 类做测试，分别创建 doA 接口和 doB 接口，doA 接口声明 sayHello()方法，doB 接口声明 eat()方法，创建 Cat2 类实现 doA 和 doB 接口，并且在类中需要重写 sayHello()方法和eat()方法。具体代码为：
12345678910111213141516171819202122232425262728interface doA{     void sayHello();}interface doB{     void eat();    &#x2F;&#x2F;以下会报错 接口中的方法不能具体定义只能声明    &#x2F;&#x2F;public void eat(){System.out.println(&quot;eating&quot;);}}class Cat2 implements  doA,doB{    @Override&#x2F;&#x2F;必须重写接口内的方法    public void sayHello() {        System.out.println(&quot;hello!&quot;);    }    @Override    public void eat() {        System.out.println(&quot;I&#39;m eating&quot;);    }}public class test2 {    public static void main(String[] args) {        Cat2 cat&#x3D;new Cat2();        cat.sayHello();        cat.eat();    }}
Cat 类实现 doA 和 doB 接口的时候，需要实现其声明的方法，点击运行结果如下，这就是一个类实现接口的简单案例：

05、继承的特点
继承的主要内容就是子类继承父类，并重写父类的方法。使用子类的属性或方法时候，首先要创建一个对象，而对象通过构造方法去创建，在构造方法中我们可能会调用子父类的一些属性和方法，所以就需要提前掌握 this 和 super关键字。
创建完这个对象之后，再调用重写父类后的方法，注意重写和重载的区别。
this 和 super 关键字
后面会详细讲，这里先来简单了解一下。
this 和 super 关键字是继承中非常重要的知识点，分别表示当前对象的引用和父类对象的引用，两者有很大相似又有一些区别。
this 表示当前对象，是指向自己的引用。
123this.属性 &#x2F;&#x2F; 调用成员变量，要区别成员变量和局部变量this.() &#x2F;&#x2F; 调用本类的某个方法this() &#x2F;&#x2F; 表示调用本类构造方法
super 表示父类对象，是指向父类的引用。
123super.属性 &#x2F;&#x2F; 表示父类对象中的成员变量super.方法() &#x2F;&#x2F; 表示父类对象中定义的方法super() &#x2F;&#x2F; 表示调用父类构造方法
构造方法
构造方法是一种特殊的方法，它是一个与类同名的方法。在继承中构造方法是一种比较特殊的方法（比如不能继承），所以要了解和学习在继承中构造方法的规则和要求。
继承中的构造方法有以下几点需要注意：
父类的构造方法不能被继承：
因为构造方法语法是与类同名，而继承则不更改方法名，如果子类继承父类的构造方法，那明显与构造方法的语法冲突了。比如 Father 类的构造方法名为 Father()，Son 类如果继承 Father 类的构造方法 Father()，那就和构造方法定义：构造方法与类同名冲突了，所以在子类中不能继承父类的构造方法，但子类会调用父类的构造方法。
子类的构造过程必须调用其父类的构造方法：
Java 虚拟机构造子类对象前会先构造父类对象，父类对象构造完成之后再来构造子类特有的属性，这被称为内存叠加。而 Java 虚拟机构造父类对象会执行父类的构造方法，所以子类构造方法必须调用 super()即父类的构造方法。就比如一个简单的继承案例应该这么写：
1234567891011121314151617181920class A{    public String name;        public A() {&#x2F;&#x2F;无参构造    }        public A (String name){&#x2F;&#x2F;有参构造    }}class B extends A{    public B() {&#x2F;&#x2F;无参构造       super();    }        public B(String name) {&#x2F;&#x2F;有参构造      &#x2F;&#x2F;super();       super(name);    }}
如果子类的构造方法中没有显示地调用父类构造方法，则系统默认调用父类无参数的构造方法。
你可能有时候在写继承的时候子类并没有使用 super()调用，程序依然没问题，其实这样是为了节省代码，系统执行时会自动添加父类的无参构造方式，如果不信的话我们对上面的类稍作修改执行：

方法重写(Override)
方法重写也就是子类中出现和父类中一模一样的方法(包括返回值类型，方法名，参数列表)，它建立在继承的基础上。你可以理解为方法的外壳不变，但是核心内容重写。
在这里提供一个简单易懂的方法重写案例：
123456789101112class E1{    public void doA(int a){        System.out.println(&quot;这是父类的方法&quot;);    }}class E2 extends E1{    @Override    public void doA(int a) {        System.out.println(&quot;我重写父类方法，这是子类的方法&quot;);    }}
其中 @Override 注解显示声明该方法为注解方法，可以帮你检查重写方法的语法正确性，当然如果不加也是可以的，但建议加上。
方法重载(Overload)
如果有两个方法的方法名相同，但参数不一致，那么可以说一个方法是另一个方法的重载。
重载可以通常理解为完成同一个事情的方法名相同，但是参数列表不同其他条件也可能不同。一个简单的方法重载的例子，类 E3 中的 add()方法就是一个重载方法。
12345678910111213class E3{    public int add(int a,int b){        return a+b;    }        public double add(double a,double b) {        return a+b;    }        public int add(int a,int b,int c) {        return a+b+c;    }}
06、继承与修饰符
Java 修饰符的作用就是对类或类成员进行修饰或限制，每个修饰符都有自己的作用，而在继承中可能有些特殊修饰符使得被修饰的属性或方法不能被继承，或者继承需要一些其他的条件。
Java 语言提供了很多修饰符，修饰符用来定义类、方法或者变量，通常放在语句的最前端。主要分为以下两类：

访问权限修饰符，也就是 public、private、protected 等
非访问修饰符，也就是 static、final、abstract 等

访问修饰符
Java 子类重写继承的方法时，不可以降低方法的访问权限，子类继承父类的访问修饰符作用域不能比父类小，也就是更加开放，假如父类是 protected 修饰的，其子类只能是 protected 或者 public，绝对不能是default(默认的访问范围)或者 private。所以在继承中需要重写的方法不能使用 private 修饰词修饰。
如果还是不太清楚可以看几个小案例就很容易搞懂，写一个 A1 类中用四种修饰词实现四个方法，用子类 A2继承 A1，重写 A1 方法时候你就会发现父类私有方法不能重写，非私有方法重写使用的修饰符作用域不能变小(大于等于)。

正确的案例应该为：
1234567891011121314151617class A1 {    private void doA(){ }    void doB(){}&#x2F;&#x2F;default    protected void doC(){}    public void doD(){}}class A2 extends A1{    @Override    public void doB() { }&#x2F;&#x2F;继承子类重写的方法访问修饰符权限可扩大        @Override    protected void doC() { }&#x2F;&#x2F;继承子类重写的方法访问修饰符权限可和父类一致        @Override    public void doD() { }&#x2F;&#x2F;不可用protected或者default修饰}
还要注意的是，继承当中子类抛出的异常必须是父类抛出的异常或父类抛出异常的子异常。下面的一个案例四种方法测试可以发现子类方法的异常不可大于父类对应方法抛出异常的范围。

正确的案例应该为：
1234567891011121314151617181920212223class B1{    public void doA() throws Exception{}    public void doB() throws Exception{}    public void doC() throws IOException{}    public void doD() throws IOException{}}class B2 extends B1{    &#x2F;&#x2F;异常范围和父类可以一致    @Override    public void doA() throws Exception { }        &#x2F;&#x2F;异常范围可以比父类更小    @Override    public void doB() throws IOException { }        &#x2F;&#x2F;异常范围 不可以比父类范围更大    @Override    public void doC() throws IOException { }&#x2F;&#x2F;不可抛出Exception等比IOException更大的异常        @Override    public void doD() throws IOException { }}
非访问修饰符
访问修饰符用来控制访问权限，而非访问修饰符每个都有各自的作用，下面针对 static、final、abstract 修饰符进行介绍。
static 修饰符
static 翻译为“静态的”，能够与变量，方法和类一起使用，称为静态变量，静态方法(也称为类变量、类方法)。如果在一个类中使用 static 修饰变量或者方法的话，它们可以直接通过类访问，不需要创建一个类的对象来访问成员。
我们在设计类的时候可能会使用静态方法，有很多工具类比如 Math ， Arrays 等类里面就写了很多静态方法。
可以看以下的案例证明上述规则：

源代码为：
1234567891011121314151617class C1{    public  int a;    public C1(){}   &#x2F;&#x2F; public static C1(){}&#x2F;&#x2F; 构造方法不允许被声明为static    public static void doA() {}    public static void doB() {}}class C2 extends C1{    public static  void doC()&#x2F;&#x2F;静态方法中不存在当前对象，因而不能使用this和super。    {        &#x2F;&#x2F;System.out.println(super.a);    }        public static void doA(){}&#x2F;&#x2F;静态方法能被静态方法重写   &#x2F;&#x2F; public void doB(){}&#x2F;&#x2F;静态方法不能被非静态方法重写}
final 修饰符
final 变量：

final 表示”最后的、最终的”含义，变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显式指定初始值(即不能只声明)。final 修饰符通常和 static 修饰符一起使用来创建类常量。

final 方法：

父类中的 final 方法可以被子类继承，但是不能被子类重写。声明 final 方法的主要目的是防止该方法的内容被修改。

final 类：

final 类不能被继承，没有类能够继承 final 类的任何特性。

所以无论是变量、方法还是类被 final 修饰之后，都有代表最终、最后的意思。内容无法被修改。
abstract 修饰符
abstract 英文名为“抽象的”，主要用来修饰类和方法，称为抽象类和抽象方法。
抽象方法：有很多不同类的方法是相似的，但是具体内容又不太一样，所以我们只能抽取他的声明，没有具体的方法体，即抽象方法可以表达概念但无法具体实现。
抽象类：有抽象方法的类必须是抽象类，抽象类可以表达概念但是无法构造实体的类。

比如我们可以这样设计一个 People 抽象类以及一个抽象方法，在子类中具体完成：
123456789101112131415161718192021222324abstract class People{    public abstract void sayHello();&#x2F;&#x2F;抽象方法}class Chinese extends People{    @Override    public void sayHello() {&#x2F;&#x2F;实现抽象方法        System.out.println(&quot;你好&quot;);    }}class Japanese extends People{    @Override    public void sayHello() {&#x2F;&#x2F;实现抽象方法        System.out.println(&quot;口你七哇&quot;);    }}class American extends People{    @Override    public void sayHello() {&#x2F;&#x2F;实现抽象方法        System.out.println(&quot;hello&quot;);    }}
07、Object 类和转型
提到 Java 继承，不得不提及所有类的根类：Object(java.lang.Object)类，如果一个类没有显式声明它的父类（即没有写 extends xx），那么默认这个类的父类就是 Object 类，任何类都可以使用 Object 类的方法，创建的类也可和 Object 进行向上、向下转型，所以 Object 类是掌握和理解继承所必须的知识点。
Java 向上和向下转型在 Java 中运用很多，也是建立在继承的基础上，所以 Java 转型也是掌握和理解继承所必须的知识点。
Object 类概述

Object 是类层次结构的根类，所有的类都隐式的继承自 Object 类。
Java 中，所有的对象都拥有 Object 的默认方法。
Object 类有一个构造方法，并且是无参构造方法。

Object 是 Java 所有类的父类，是整个类继承结构的顶端，也是最抽象的一个类。
像 toString()、equals()、hashCode()、wait()、notify()、getClass()等都是 Object 的方法。你以后可能会经常碰到，但其中遇到更多的就是 toString()方法和 equals()方法，我们经常需要重写这两种方法满足我们的使用需求。
toString()方法表示返回该对象的字符串，由于各个对象构造不同所以需要重写，如果不重写的话默认返回 类名@hashCode 格式。
如果重写 toString()方法后直接调用 toString()方法就可以返回我们自定义的该类转成字符串类型的内容输出，而不需要每次都手动的拼凑成字符串内容输出，大大简化输出操作。
equals()方法主要比较两个对象是否相等，因为对象的相等不一定非要严格要求两个对象地址上的相同，有时内容上的相同我们就会认为它相等，比如 String 类就重写了euqals()方法，通过字符串的内容比较是否相等。

向上转型
向上转型 : 通过子类对象(小范围)实例化父类对象(大范围)，这种属于自动转换。用一张图就能很好地表示向上转型的逻辑：

父类引用变量指向子类对象后，只能使用父类已声明的方法，但方法如果被重写会执行子类的方法，如果方法未被重写那么将执行父类的方法。
向下转型
向下转型 : 通过父类对象(大范围)实例化子类对象(小范围)，在书写上父类对象需要加括号 () 强制转换为子类类型。但父类引用变量实际引用必须是子类对象才能成功转型，这里也用一张图就能很好表示向下转型的逻辑：

子类引用变量指向父类引用变量指向的对象后(一个 Son()对象)，就完成向下转型，就可以调用一些子类特有而父类没有的方法 。
在这里写一个向上转型和向下转型的案例：
123Object object&#x3D;new Integer(666);&#x2F;&#x2F;向上转型Integer i&#x3D;(Integer)object;&#x2F;&#x2F;向下转型Object-&gt;Integer，object的实质还是指向IntegerString str&#x3D;(String)object;&#x2F;&#x2F;错误的向下转型，虽然编译器不会报错但是运行会报错
08、子父类初始化顺序
在 Java 继承中，父子类初始化先后顺序为：

父类中静态成员变量和静态代码块
子类中静态成员变量和静态代码块
父类中普通成员变量和代码块，父类的构造方法
子类中普通成员变量和代码块，子类的构造方法

总的来说，就是静态&gt;非静态，父类&gt;子类，非构造方法&gt;构造方法。同一类别（例如普通变量和普通代码块）成员变量和代码块执行从前到后，需要注意逻辑。
这个也不难理解，静态变量也称类变量，可以看成一个全局变量，静态成员变量和静态代码块在类加载的时候就初始化，而非静态变量和代码块在对象创建的时候初始化。所以静态快于非静态初始化。
而在创建子类对象的时候需要先创建父类对象，所以父类优先于子类。
而在调用构造方法的时候，是对成员变量进行一些初始化操作，所以普通成员变量和代码块优于构造方法执行。
至于更深层次为什么这个顺序，就要更深入了解 JVM 执行流程啦。下面一个测试代码为：
123456789101112131415161718192021222324252627282930313233343536373839class Father{    public Father() {        System.out.println(++b1+&quot;父类构造方法&quot;);    }&#x2F;&#x2F;父类构造方法 第四        static int a1&#x3D;0;&#x2F;&#x2F;父类static 第一 注意顺序        static {        System.out.println(++a1+&quot;父类static&quot;);    }        int b1&#x3D;a1;&#x2F;&#x2F;父类成员变量和代码块 第三        {        System.out.println(++b1+&quot;父类代码块&quot;);    }}class Son extends Father{    public Son() {        System.out.println(++b2+&quot;子类构造方法&quot;);    }&#x2F;&#x2F;子类构造方法 第六        static {&#x2F;&#x2F;子类static第二步        System.out.println(++a1+&quot;子类static&quot;);    }        int b2&#x3D;b1;&#x2F;&#x2F;子类成员变量和代码块 第五        {        System.out.println(++b2 + &quot;子类代码块&quot;);    }}public class test9 {    public static void main(String[] args) {        Son son&#x3D;new Son();    }}
执行结果：

3）多态
Java 多态是指在面向对象编程中，同一个类的对象在不同情况下表现出不同的行为和状态。

子类可以继承父类的属性和方法，子类对象可以直接使用父类中的方法和变量。
子类可以对从父类继承的方法进行重新实现，使得子类对象调用这个方法时表现出不同的行为。
可以将子类对象赋给父类类型的变量，这样就可以通过父类类型的变量调用子类中重写的方法，实现多态。

“很枯燥，有没有？再具体的分析一下。”
01、多态是什么
在我刻板的印象里，西游记里的那段孙悟空和二郎神的精彩对战就能很好的解释“多态”这个词：一个孙悟空，能七十二变；一个二郎神，也能七十二变；他们都可以变成不同的形态，但只需要悄悄地喊一声“变”。
Java的多态是什么呢？其实就是一种能力——同一个行为具有不同的表现形式；换句话说就是，执行一段代码，Java 在运行时能根据对象的不同产生不同的结果。和孙悟空和二郎神都只需要喊一声“变”，然后就变了，并且每次变得还不一样；一个道理。
多态的前提条件有三个：

子类继承父类
子类覆盖父类的方法
父类引用指向子类对象

多态的一个简单应用，来看程序清单1-1：
1234567891011121314151617181920&#x2F;&#x2F;子类继承父类public class Wangxiaoer extends Wanger {    public void write() { &#x2F;&#x2F; 子类覆盖父类方法        System.out.println(&quot;记住仇恨，表明我们要奋发图强的心智&quot;);    }    public static void main(String[] args) {        &#x2F;&#x2F; 父类引用指向子类对象        Wanger[] wangers &#x3D; { new Wanger(), new Wangxiaoer() };        for (Wanger wanger : wangers) {            &#x2F;&#x2F; 对象是王二的时候输出：勿忘国耻            &#x2F;&#x2F; 对象是王小二的时候输出：记住仇恨，表明我们要奋发图强的心智            wanger.write();        }    }}class Wanger {    public void write() {        System.out.println(&quot;勿忘国耻&quot;);    }}
02、多态与后期绑定
现在，我们来思考一个问题：程序清单1-1在执行 wanger.write() 时，由于编译器只有一个 Wanger 引用，它怎么知道究竟该调用父类 Wanger 的 write() 方法，还是子类 Wangxiaoer 的 write() 方法呢？
答案是在运行时根据对象的类型进行后期绑定，编译器在编译阶段并不知道对象的类型，但是Java的方法调用机制能找到正确的方法体，然后执行出正确的结果。
多态机制提供的一个重要的好处程序具有良好的扩展性。来看程序清单2-1：
123456789101112131415161718192021222324252627282930&#x2F;&#x2F;子类继承父类public class Wangxiaoer extends Wanger {    public void write() { &#x2F;&#x2F; 子类覆盖父类方法        System.out.println(&quot;记住仇恨，表明我们要奋发图强的心智&quot;);    }        public void eat() {        System.out.println(&quot;我不喜欢读书，我就喜欢吃&quot;);    }        public static void main(String[] args) {        &#x2F;&#x2F; 父类引用指向子类对象        Wanger[] wangers &#x3D; { new Wanger(), new Wangxiaoer() };        for (Wanger wanger : wangers) {            &#x2F;&#x2F; 对象是王二的时候输出：勿忘国耻            &#x2F;&#x2F; 对象是王小二的时候输出：记住仇恨，表明我们要奋发图强的心智            wanger.write();        }    }}class Wanger {    public void write() {        System.out.println(&quot;勿忘国耻&quot;);    }        public void read() {        System.out.println(&quot;每周读一本好书&quot;);    }}
在程序清单 2-1 中，我们在 Wanger 类中增加了 read() 方法，在 Wangxiaoer 类中增加了eat()方法，但这丝毫不会影响到 write() 方法的调用。write() 方法忽略了周围代码发生的变化，依然正常运行。这让我想起了金庸《倚天屠龙记》里九阳真经的口诀：“他强由他强，清风拂山岗；他横由他横，明月照大江。”
多态的这个优秀的特性，让我们在修改代码的时候不必过于紧张，因为多态是一项让程序员“将改变的与未改变的分离开来”的重要特性。
03、多态与构造方法
在构造方法中调用多态方法，会产生一个奇妙的结果，我们来看程序清单3-1：
12345678910111213141516171819202122232425262728293031public class Wangxiaosan extends Wangsan {    private int age &#x3D; 3;    public Wangxiaosan(int age) {        this.age &#x3D; age;        System.out.println(&quot;王小三的年龄：&quot; + this.age);    }        public void write() { &#x2F;&#x2F; 子类覆盖父类方法        System.out.println(&quot;我小三上幼儿园的年龄是：&quot; + this.age);    }    public static void main(String[] args) {        new Wangxiaosan(4);&#x2F;&#x2F;      上幼儿园之前&#x2F;&#x2F;      我小三上幼儿园的年龄是：0&#x2F;&#x2F;      上幼儿园之后&#x2F;&#x2F;      王小三的年龄：4    }}class Wangsan {    Wangsan () {        System.out.println(&quot;上幼儿园之前&quot;);        write();        System.out.println(&quot;上幼儿园之后&quot;);    }        public void write() {        System.out.println(&quot;老子上幼儿园的年龄是3岁半&quot;);    }}
从输出结果上看，是不是有点诧异？明明在创建 Wangxiaosan 对象的时候，年龄传递的是 4，但输出结果既不是“老子上幼儿园的年龄是 3 岁半”，也不是“我小三上幼儿园的年龄是：4”。
为什么？
因为在创建子类对象时，会先去调用父类的构造方法，而父类构造方法中又调用了被子类覆盖的多态方法，由于父类并不清楚子类对象中的属性值是什么，于是把int类型的属性暂时初始化为 0，然后再调用子类的构造方法（子类构造方法知道王小二的年龄是 4）。
04、多态与向下转型
向下转型是指将父类引用强转为子类类型；这是不安全的，因为有的时候，父类引用指向的是父类对象，向下转型就会抛出 ClassCastException，表示类型转换失败；但如果父类引用指向的是子类对象，那么向下转型就是成功的。
来看程序清单4-1：
123456789101112131415161718192021222324252627public class Wangxiaosi extends Wangsi {    public void write() {        System.out.println(&quot;记住仇恨，表明我们要奋发图强的心智&quot;);    }        public void eat() {        System.out.println(&quot;我不喜欢读书，我就喜欢吃&quot;);    }        public static void main(String[] args) {        Wangsi[] wangsis &#x3D; { new Wangsi(), new Wangxiaosi() };        &#x2F;&#x2F; wangsis[1]能够向下转型        ((Wangxiaosi) wangsis[1]).write();        &#x2F;&#x2F; wangsis[0]不能向下转型        ((Wangxiaosi)wangsis[0]).write();    }}class Wangsi {    public void write() {        System.out.println(&quot;勿忘国耻&quot;);    }        public void read() {        System.out.println(&quot;每周读一本好书&quot;);    }}
“好了，三妹，到此为止，我们就将 Java 的三大特性，封装继承多态全部讲完了，希望你能重新把他们梳理一下。”
“好的，二哥，遵命。”三妹顽皮地笑了。
4）小结
好啦，三妹，本次继承就介绍到这里啦，Java 面向对象三大特征之一继承——优秀的你已经掌握。
封装：是对类的封装，封装是对类的属性和方法进行封装，只对外暴露方法而不暴露具体使用细节，所以我们一般设计类成员变量时候大多设为私有而通过一些 get、set 方法去读写。
继承：子类继承父类，即“子承父业”，子类拥有父类除私有的所有属性和方法，自己还能在此基础上拓展自己新的属性和方法。主要目的是复用代码。
多态：多态是同一个行为具有多个不同表现形式或形态的能力。即一个父类可能有若干子类，各子类实现父类方法有多种多样，调用父类方法时，父类引用变量指向不同子类实例而执行不同方法，这就是所谓父类方法是多态的。
最后送你一张图捋一捋其中的关系吧。

3.14 Java this和super关键字“今天来学习一下 Java 中的 this 关键字吧。”喝了一口农夫山泉后，我对三妹说。
“this 关键字有很多种用法，其中最常用的一个是，它可以作为引用变量，指向当前对象。”我面带着朴实无华的微笑继续说，“除此之外， this 关键字还可以完成以下工作。”

调用当前类的方法；
this() 可以调用当前类的构造方法；
this 可以作为参数在方法中传递；
this 可以作为参数在构造方法中传递；
this 可以作为方法的返回值，返回当前类的对象。

01、 指向当前对象
“三妹，来看下面这段代码。”话音刚落，我就在键盘上噼里啪啦一阵敲。
1234567891011121314151617181920public class WithoutThisStudent {    String name;    int age;        WithoutThisStudent(String name, int age) {        name &#x3D; name;        age &#x3D; age;    }        void out() {        System.out.println(name+&quot; &quot; + age);    }        public static void main(String[] args) {        WithoutThisStudent s1 &#x3D; new WithoutThisStudent(&quot;沉默二&quot;, 18);        WithoutThisStudent s2 &#x3D; new WithoutThisStudent(&quot;沉默三&quot;, 16);        s1.out();        s2.out();    }}
“在上面的例子中，构造方法的参数名和实例变量名相同，由于没有使用 this 关键字，所以无法为实例变量赋值。”我抬起右手的食指，指着屏幕上的 name 和 age 对着三妹说。
“来看一下程序的输出结果。”
12null 0null 0
“从结果中可以看得出来，尽管创建对象的时候传递了参数，但实例变量并没有赋值。这是因为如果构造方法中没有使用 this 关键字的话，name 和 age 指向的并不是实例变量而是参数本身。”我把脖子扭向右侧，看着三妹说。
“那怎么解决这个问题呢？哥。”三妹着急地问。
“如果参数名和实例变量名产生了冲突…..”我正准备给出答案，三妹打断了我。
“难道用 this 吗？”三妹脱口而出。
“哇，越来越棒了呀，你。”我感觉三妹在学习 Java 这条道路上逐渐有了自己主动思考的意愿。
“是的，来看加上 this 关键字后的代码。”
安静的屋子里又响起了一阵噼里啪啦的键盘声。
1234567891011121314151617public class WithThisStudent {    String name;    int age;    WithThisStudent(String name, int age) {        this.name &#x3D; name;        this.age &#x3D; age;    }    void out() {        System.out.println(name+&quot; &quot; + age);    }    public static void main(String[] args) {        WithThisStudent s1 &#x3D; new WithThisStudent(&quot;沉默二&quot;, 18);        WithThisStudent s2 &#x3D; new WithThisStudent(&quot;沉默三&quot;, 16);        s1.out();        s2.out();    }}
“再来看一下程序的输出结果。”
12沉默二 18沉默三 16
“这次，实例变量有值了，在构造方法中， this.xxx 指向的就是实例变量，而不再是参数本身了。”我慢吞吞地说着，“当然了，如果参数名和实例变量名不同的话，就不必使用 this 关键字，但我建议使用 this 关键字，这样的代码更有意义。”
02、调用当前类的方法
“仔细听，三妹，看我敲键盘的速度是不是够快。”
12345678910public class InvokeCurrentClassMethod {    void method1() {}    void method2() {        method1();    }        public static void main(String[] args) {        new InvokeCurrentClassMethod().method1();    }}
“仔细瞧，三妹，上面这段代码中没有见到 this 关键字吧？”我面带着神秘的微笑，准备给三妹变个魔术。
“确实没有，哥，我确认过了。”
“那接下来，神奇的事情就要发生了。”我突然感觉刘谦附身了。
我快速的在 classes 目录下找到 InvokeCurrentClassMethod.class 文件，然后双击打开（IDEA 默认会使用FernFlower 打开字节码文件）。
123456789101112131415public class InvokeCurrentClassMethod {    public InvokeCurrentClassMethod() {    }        void method1() {    }        void method2() {        this.method1();    }        public static void main(String[] args) {        (new InvokeCurrentClassMethod()).method1();    }}
“瞪大眼睛仔细瞧，三妹， this 关键字是不是出现了？”
“哇，真的呢，好神奇啊！”三妹为了配合我的演出，也是十二分的卖力。
“我们可以在一个类中使用 this 关键字来调用另外一个方法，如果没有使用的话，编译器会自动帮我们加上。”我对自己深厚的编程功底充满自信，“在源代码中， method2() 在调用 method1() 的时候并没有使用this 关键字，但通过反编译后的字节码可以看得到。”
03、调用当前类的构造方法
“再来看下面这段代码。”
1234567891011121314public class InvokeConstrutor {    InvokeConstrutor() {        System.out.println(&quot;hello&quot;);    }        InvokeConstrutor(int count) {        this();        System.out.println(count);    }        public static void main(String[] args) {        InvokeConstrutor invokeConstrutor &#x3D; new InvokeConstrutor(10);    }}
“在有参构造方法 InvokeConstrutor(int count) 中，使用了 this() 来调用无参构造方法InvokeConstrutor() 。”这次，我换成了左手的食指，指着屏幕对三妹说，“ this() 可用于调用当前类的构造方法——构造方法可以重用了。”
“来看一下输出结果。”
12hello10
“真的啊，无参构造方法也被调用了，所以程序输出了 hello。”三妹看到输出结果后不假思索地说。
“也可以在无参构造方法中使用 this() 并传递参数来调用有参构造方法。”话音没落，我就在键盘上敲了起来，“来看下面这段代码。”
1234567891011121314public class InvokeParamConstrutor {    InvokeParamConstrutor() {        this(10);        System.out.println(&quot;hello&quot;);    }        InvokeParamConstrutor(int count) {        System.out.println(count);    }        public static void main(String[] args) {        InvokeParamConstrutor invokeConstrutor &#x3D; new InvokeParamConstrutor();    }}
“再来看一下程序的输出结果。”
12hello10
“不过，需要注意的是， this() 必须放在构造方法的第一行，否则就报错了。”

04、作为参数在方法中传递
“来看下面这段代码。”
123456789101112131415public class ThisAsParam {    void method1(ThisAsParam p) {        System.out.println(p);    }        void method2() {        method1(this);    }        public static void main(String[] args) {        ThisAsParam thisAsParam &#x3D; new ThisAsParam();        System.out.println(thisAsParam);        thisAsParam.method2();    }}
“ this 关键字可以作为参数在方法中传递，此时，它指向的是当前类的对象。”一不小心，半个小时过去了，我感到嗓子冒烟，于是赶紧又喝了一口水，润润嗓子后继续说道。
“来看一下输出结果，你就明白了，三妹。”
12com.itwanger.twentyseven.ThisAsParam@77459877com.itwanger.twentyseven.ThisAsParam@77459877
“ method2() 调用了 method1() ，并传递了参数 this， method1() 中打印了当前对象的字符串。 main()方法中打印了 thisAsParam 对象的字符串。从输出结果中可以看得出来，两者是同一个对象。”
05、作为参数在构造方法中传递
“继续来看代码。”
123456789101112131415161718192021222324public class ThisAsConstrutorParam {    int count &#x3D; 10;        ThisAsConstrutorParam() {        Data data &#x3D; new Data(this);        data.out();    }        public static void main(String[] args) {        new ThisAsConstrutorParam();    }}class Data {    ThisAsConstrutorParam param;        Data(ThisAsConstrutorParam param) {        this.param &#x3D; param;    }        void out() {        System.out.println(param.count);    }}
“在构造方法 ThisAsConstrutorParam() 中，我们使用 this 关键字作为参数传递给了 Data 对象，它其实指向的就是 new ThisAsConstrutorParam() 这个对象。”
“ this 关键字也可以作为参数在构造方法中传递，它指向的是当前类的对象。当我们需要在多个类中使用一个对象的时候，这非常有用。”
“来看一下输出结果。”
110
06、作为方法的返回值
“需要休息会吗？三妹”
“没事的，哥，我的注意力还是很集中的，你继续讲吧。”
“好的，那来继续看代码。”
12345678910111213public class ThisAsMethodResult {    ThisAsMethodResult getThisAsMethodResult() {        return this;    }        void out() {        System.out.println(&quot;hello&quot;);    }        public static void main(String[] args) {        new ThisAsMethodResult().getThisAsMethodResult().out();    }}
“ getThisAsMethodResult() 方法返回了 this 关键字，指向的就是 new ThisAsMethodResult() 这个对象，所以可以紧接着调用 out() 方法——达到了链式调用的目的，这也是 this 关键字非常经典的一种用法。”
“链式调用的形式在 JavaScript 代码更加常见。”为了向三妹证实这一点，我打开了 jQuery 的源码。
“原来这么多链式调用啊！”三妹感叹到。
“是的。”我点点头，然后指着 getThisAsMethodResult() 方法的返回值对三妹说，“需要注意的是， this关键字作为方法的返回值的时候，方法的返回类型为类的类型。”
“来看一下输出结果。”
1hello
“那么，关于 this 关键字的介绍，就到此为止了。”我活动了一下僵硬的脖子后，对三妹说，“如果你学习劲头还可以的话，我们顺带把 super 关键字捎带着过一下，怎么样？”
“不用了吧，听说 super 关键字更简单，我自己看看就行了，不用你讲了！”
“不不不，三妹啊，你得假装听一下，不然我怎么向读者们交差。”
“噢噢噢噢。”三妹意味深长地笑了。
07、super 关键字
“super 关键字的用法主要有三种。”

指向父类对象；
调用父类的方法；
super() 可以调用父类的构造方法。

“其实和 this 有些相似，只不过用意不大相同。”我端起水瓶，咕咚咕咚又喝了几大口，好渴。“每当创建一个子类对象的时候，也会隐式的创建父类对象，由 super 关键字引用。”
“如果父类和子类拥有同样名称的字段，super 关键字可以用来访问父类的同名字段。”
“来看下面这段代码。”
123456789101112131415161718public class ReferParentField {    public static void main(String[] args) {        new Dog().printColor();    }}class Animal {    String color &#x3D; &quot;白色&quot;;}class Dog extends Animal {    String color &#x3D; &quot;黑色&quot;;        void printColor() {        System.out.println(color);        System.out.println(super.color);    }}
“父类 Animal 中有一个名为 color 的字段，子类 Dog 中也有一个名为 color 的字段，子类的 printColor()方法中，通过 super 关键字可以访问父类的 color。”
“来看一下输出结果。”
12黑色白色
“当子类和父类的方法名相同时，可以使用 super 关键字来调用父类的方法。换句话说，super 关键字可以用于方法重写时访问到父类的方法。”
123456789101112131415161718192021222324252627public class ReferParentMethod {    public static void main(String[] args) {        new Dog().work();    }}class Animal {    void eat() {        System.out.println(&quot;吃...&quot;);    }}class Dog extends Animal {    @Override    void eat() {        System.out.println(&quot;吃...&quot;);    }        void bark() {        System.out.println(&quot;汪汪汪...&quot;);    }        void work() {        super.eat();        bark();    }} 
“瞧，三妹。父类 Animal 和子类 Dog 中都有一个名为 eat() 的方法，通过 super.eat() 可以访问到父类的 eat() 方法。”
等三妹在自我消化的时候，我在键盘上又敲完了一串代码。
123456789101112131415161718public class ReferParentConstructor {    public static void main(String[] args) {        new Dog();    }}class Animal {    Animal(){        System.out.println(&quot;动物来了&quot;);    }}class Dog extends Animal {    Dog() {        super();        System.out.println(&quot;狗狗来了&quot;);    }}
“子类 Dog 的构造方法中，第一行代码为 super() ，它就是用来调用父类的构造方法的。”
“来看一下输出结果。”
12动物来了狗狗来了
“当然了，在默认情况下， super() 是可以省略的，编译器会主动去调用父类的构造方法。也就是说，子类即使不使用 super() 主动调用父类的构造方法，父类的构造方法仍然会先执行。”
1234567891011121314151617public class ReferParentConstructor {    public static void main(String[] args) {        new Dog();    }}class Animal {    Animal(){        System.out.println(&quot;动物来了&quot;);    }}class Dog extends Animal {    Dog() {        System.out.println(&quot;狗狗来了&quot;);    }}
“输出结果和之前一样。”
12动物来了狗狗来了
“ super() 也可以用来调用父类的有参构造方法，这样可以提高代码的可重用性。”
12345678910111213141516171819202122232425262728class Person {    int id;    String name;        Person(int id, String name) {        this.id &#x3D; id;        this.name &#x3D; name;    }}class Emp extends Person {    float salary;        Emp(int id, String name, float salary) {        super(id, name);        this.salary &#x3D; salary;    }        void display() {        System.out.println(id + &quot; &quot; + name + &quot; &quot; + salary);    }}public class CallParentParamConstrutor {    public static void main(String[] args) {        new Emp(1, &quot;沉默王二&quot;, 20000f).display();    }}
“Emp 类继承了 Person 类，也就继承了 id 和 name 字段，当在 Emp 中新增了 salary 字段后，构造方法中就可以使用 super(id, name) 来调用父类的有参构造方法。”
“来看一下输出结果。”
11 沉默王二 20000.0
三妹点了点头，所有所思。
3.15 Java static关键字我面带着微笑对三妹说，“学习可不能落下，今天我们来学 Java 中 static 关键字吧。”
“static 是 Java 中比较难以理解的一个关键字，也是各大公司的面试官最喜欢问到的一个知识点之一。”我喝了一口咖啡继续说道。
“既然是面试重点，那我可得好好学习下。”三妹连忙说。
“static 关键字的作用可以用一句话来描述：‘方便在没有创建对象的情况下进行调用，包括变量和方法’。也就是说，只要类被加载了，就可以通过类名进行访问。”我扶了扶沉重眼镜，继续说到，“static 可以用来修饰类的成员变量，以及成员方法。我们一个个来看。”
01、静态变量
“如果在声明变量的时候使用了 static 关键字，那么这个变量就被称为静态变量。静态变量只在类加载的时候获取一次内存空间，这使得静态变量很节省内存空间。”家里的暖气有点足，我跑去开了一点窗户后继续说道。
“来考虑这样一个 Student 类。”话音刚落，我就在键盘上噼里啪啦一阵敲。
12345public class Student {    String name;    int age;    String school &#x3D; &quot;郑州大学&quot;;}
这段代码敲完后，我对三妹说：“假设郑州大学录取了一万名新生，那么在创建一万个 Student 对象的时候，所有的字段（name、age 和 school）都会获取到一块内存。学生的姓名和年纪不尽相同，但都属于郑州大学，如果每创建一个对象，school 这个字段都要占用一块内存的话，就很浪费，对吧？三妹。”
“因此，最好将 school 这个字段设置为 static，这样就只会占用一块内存，而不是一万块。”
安静的房子里又响起了一阵噼里啪啦的键盘声。
123456789101112131415public class Student {    String name;    int age;    static String school &#x3D; &quot;郑州大学&quot;;        public Student(String name, int age) {        this.name &#x3D; name;        this.age &#x3D; age;    }        public static void main(String[] args) {        Student s1 &#x3D; new Student(&quot;沉默王二&quot;, 18);        Student s2 &#x3D; new Student(&quot;沉默王三&quot;, 16);    }}
“瞧，三妹。s1 和 s2 这两个引用变量存放在栈区（stack），沉默王二+18 这个对象和沉默王三+16 这个对象存放在堆区（heap），school 这个静态变量存放在静态区。”
“等等，哥，栈、堆、静态区？”三妹的脸上塞满了疑惑。
“哦哦，别担心，三妹，画幅图你就全明白了。”说完我就打开 draw.io 这个网址，认真地画起了图。

“现在，是不是一下子就明白了？”看着这幅漂亮的手绘图，我心里有点小开心。
“哇，哥，惊艳了呀！”三妹也不忘拍马屁，给我了一个大大的赞。
“好了，三妹，我们来看下面这串代码。”
1234567891011121314public class Counter {    int count &#x3D; 0;        Counter() {        count++;        System.out.println(count);    }        public static void main(String args[]) {        Counter c1 &#x3D; new Counter();        Counter c2 &#x3D; new Counter();        Counter c3 &#x3D; new Counter();    }}
“我们创建一个成员变量 count，并且在构造函数中让它自增。因为成员变量会在创建对象的时候获取内存，因此每一个对象都会有一个 count 的副本， count 的值并不会随着对象的增多而递增。”
我在侃侃而谈，而三妹似乎有些不太明白。
“没关系，三妹，你先盲猜一下，这段代码输出的结果是什么？”
“按照你的逻辑，应该输出三个 1？是这样吗？”三妹眨眨眼，有点不太自信地回答。
“哎呀，不错哟。”
我在 IDEA 中点了一下运行按钮，程序跑了起来。
123111
“每创建一个 Counter 对象，count 的值就从 0 自增到 1。三妹，想一下，如果 count 是静态的呢？”
“我不知道啊。”
“嗯，来看下面这段代码。”
1234567891011121314public class StaticCounter {    static int count &#x3D; 0;        StaticCounter() {        count++;        System.out.println(count);    }        public static void main(String args[]) {        StaticCounter c1 &#x3D; new StaticCounter();        StaticCounter c2 &#x3D; new StaticCounter();        StaticCounter c3 &#x3D; new StaticCounter();    }}
“来看一下输出结果。”
123123
“简单解释一下哈，由于静态变量只会获取一次内存空间，所以任何对象对它的修改都会得到保留，所以每创建一个对象，count 的值就会加 1，所以最终的结果是 3，明白了吧？三妹。这就是静态变量和成员变量之间的差别。”
“另外，需要注意的是，由于静态变量属于一个类，所以不要通过对象引用来访问，而应该直接通过类名来访问，否则编译器会发出警告。”

02、静态方法
“好吧。”我只好喝了一口咖啡继续说，“如果方法上加了 static 关键字，那么它就是一个静态方法。”
“静态方法有以下这些特征。”

静态方法属于这个类而不是这个类的对象；
调用静态方法的时候不需要创建这个类的对象；
静态方法可以访问静态变量。

“来，继续上代码”
123456789101112131415161718192021222324252627public class StaticMethodStudent {    String name;    int age;    static String school &#x3D; &quot;郑州大学&quot;;        public StaticMethodStudent(String name, int age) {        this.name &#x3D; name;        this.age &#x3D; age;    }        static void change() {        school &#x3D; &quot;河南大学&quot;;    }        void out() {        System.out.println(name + &quot; &quot; + age + &quot; &quot; + school);    }    public static void main(String[] args) {        StaticMethodStudent.change();                StaticMethodStudent s1 &#x3D; new StaticMethodStudent(&quot;沉默王二&quot;, 18);        StaticMethodStudent s2 &#x3D; new StaticMethodStudent(&quot;沉默王三&quot;, 16);                s1.out();        s2.out();    }}
“仔细听，三妹。 change() 方法就是一个静态方法，所以它可以直接访问静态变量 school，把它的值更改为河南大学；并且，可以通过类名直接调用 change() 方法，就像 StaticMethodStudent.change() 这样。”
“来看一下程序的输出结果吧。”
12沉默王二 18 河南大学沉默王三 16 河南大学
“需要注意的是，静态方法不能访问非静态变量和调用非静态方法。你看，三妹，我稍微改动一下代码，编译器就会报错。”
“先是在静态方法中访问非静态变量，编译器不允许。”

“然后在静态方法中访问非静态方法，编译器同样不允许。”

“关于静态方法的使用，这下清楚了吧，三妹？”
看着三妹点点头，我欣慰地笑了。
“哥，我想到了一个问题，为什么 main 方法是静态的啊？”没想到，三妹串联知识点的功力还是不错的。
“如果 main 方法不是静态的，就意味着 Java 虚拟机在执行的时候需要先创建一个对象才能调用 main 方法，而 main 方法作为程序的入口，创建一个额外的对象显得非常多余。”我不假思索的回答令三妹感到非常的钦佩。
“java.lang.Math 类的几乎所有方法都是静态的，可以直接通过类名来调用，不需要创建类的对象。”

03、静态代码块
“除了静态变量和静态方法，static 关键字还有一个重要的作用。”我心情愉悦地对三妹说，“用一个 static 关键字，外加一个大括号括起来的代码被称为静态代码块。”
“就像下面这串代码。”
12345678public class StaticBlock {    static {        System.out.println(&quot;静态代码块&quot;);    }    public static void main(String[] args) {        System.out.println(&quot;main 方法&quot;);    }}
“静态代码块通常用来初始化一些静态变量，它会优先于 main() 方法执行。”
“来看一下程序的输出结果吧。”
12静态代码块main 方法
“二哥，既然静态代码块先于 main() 方法执行，那没有 main() 方法的 Java 类能执行成功吗？”三妹的脑回路越来越令我敬佩了。
“Java 1.6 是可以的，但 Java 7 开始就无法执行了。”我胸有成竹地回答到。
12345public class StaticBlockNoMain {    static {        System.out.println(&quot;静态代码块，没有 main&quot;);    }}
“在命令行中执行 java StaticBlockNoMain 的时候，会抛出 NoClassDefFoundError 的错误。”

“三妹，来看下面这个例子。”
12345678910111213141516public class StaticBlockDemo {    public static List&lt;String&gt; writes &#x3D; new ArrayList&lt;&gt;();        static {        writes.add(&quot;沉默王二&quot;);        writes.add(&quot;沉默王三&quot;);        writes.add(&quot;沉默王四&quot;);        System.out.println(&quot;第一块&quot;);    }        static {        writes.add(&quot;沉默王五&quot;);        writes.add(&quot;沉默王六&quot;);        System.out.println(&quot;第二块&quot;);    }}
“writes 是一个静态的 ArrayList，所以不太可能在声明的时候完成初始化，因此需要在静态代码块中完成初始化。”
“静态代码块在初始集合的时候，真的非常有用。在实际的项目开发中，通常使用静态代码块来加载配置文件到内存当中。”
04、静态内部类
“三妹啊，除了以上只写，static 还有一个不太常用的功能——静态内部类。”
“Java 允许我们在一个类中声明一个内部类，它提供了一种令人信服的方式，允许我们只在一个地方使用一些变量，使代码更具有条理性和可读性。”
“常见的内部类有四种，成员内部类、局部内部类、匿名内部类和静态内部类，限于篇幅原因，前三种不在我们本次的讨论范围之内，以后有机会再细说。”
“来看下面这个例子。”三妹有点走神，我敲了敲她的脑袋后继续说。
1234567891011public class Singleton {    private Singleton() {}        private static class SingletonHolder {        public static final Singleton instance &#x3D; new Singleton();    }        public static Singleton getInstance() {        return SingletonHolder.instance;    }}
“三妹，打起精神，马上就结束了。”
“哦哦，这段代码看起来很别致啊，哥。”
“是的，三妹，这段代码在以后创建单例的时候还会见到。”
“第一次加载 Singleton 类时并不会初始化 instance，只有第一次调用 getInstance() 方法时 Java 虚拟机才开始加载 SingletonHolder 并初始化 instance，这样不仅能确保线程安全，也能保证 Singleton 类的唯一性。不过，创建单例更优雅的一种方式是使用枚举，以后再讲给你听。”
“需要注意的是。第一，静态内部类不能访问外部类的所有成员变量；第二，静态内部类可以访问外部类的所有静态变量，包括私有静态变量。第三，外部类不能声明为 static。”
“三妹，你看，在 Singleton 类上加 static 后，编译器就提示错误了。”

三妹点了点头，所有所思。
3.16 Java final关键字“哥，今天学什么呢？”
“今天学一个重要的关键字——final。 ”我面带着朴实无华的微笑回答着她，“对了，三妹，你打算考研吗？”
“还没想过，我今年才大一呢，到时候再说吧，你决定。”
“好吧。”我摊摊手，表示很无辜，真的是所有的决定都交给我这个哥哥了，如果决定错了，锅得背上。
01、final 变量
“好了，我们先来看 final 修饰的变量吧！”
“被 final 修饰的变量无法重新赋值。换句话说，final 变量一旦初始化，就无法更改。”
“来看这行代码。”
1final int age &#x3D; 18;
“当尝试将 age 的值修改为 30 的时候，编译器就生气了。”

“再来看这段代码。”
1234567891011public class Pig {    private String name;        public String getName() {        return name;    }        public void setName(String name) {        this.name &#x3D; name;    }}
“这是一个很普通的 Java 类，它有一个字段 name。”
“然后，我们创建一个测试类，并声明一个 final 修饰的 Pig 对象。”
1final Pig pig &#x3D; new Pig();
“如果尝试将 pig 重新赋值的话，编译器同样会生气。”

“但我们仍然可以去修改 pig 对象的 name。”
123final Pig pig &#x3D; new Pig();pig.setName(&quot;特立独行&quot;);System.out.println(pig.getName()); &#x2F;&#x2F; 特立独行
“另外，final 修饰的成员变量必须有一个默认值，否则编译器将会提醒没有初始化。”

“final 和 static 一起修饰的成员变量叫做常量，常量名必须全部大写。”
1234public class Pig {   private final int age &#x3D; 1;   public static final double PRICE &#x3D; 36.5;}
“有时候，我们还会用 final 关键字来修饰参数，它意味着参数在方法体内不能被再修改。”
“来看下面这段代码。”
1234567public class ArgFinalTest {    public void arg(final int age) {    }        public void arg1(final String name) {    }}
“如果尝试去修改它的话，编译器会提示以下错误。”

02、final 方法
“被 final 修饰的方法不能被重写。如果我们在设计一个类的时候，认为某些方法不应该被重写，就应该把它设计成 final 的。”
“Thread 类就是一个例子，它本身不是 final 的，这意味着我们可以扩展它，但它的 isAlive() 方法是final 的。”
123public class Thread implements Runnable {    public final native boolean isAlive();}
“需要注意的是，该方法是一个本地（native）方法，用于确认线程是否处于活跃状态。而本地方法是由操作系统决定的，因此重写该方法并不容易实现。”
“来看这段代码。”
1234public class Actor {    public final void show() {    }}
“当我们想要重写该方法的话，就会出现编译错误。”

“三妹，来问你一个问题吧。”正想趁三妹回答问题的时候喝口水。
“你说吧，哥。”
“一个类是 final 的，和一个类不是 final，但它所有的方法都是 final 的，考虑一下，它们之间有什么区别？”
“我能想到的一点，就是前者不能被继承，也就是说方法无法被重写；后者呢，可以被继承，然后追加一些非final 的方法。”还没等我把水咽下去，三妹就回答好了，着实惊呆了我。
“嗯嗯嗯，没毛病没毛病，进步很大啊！”
“那必须啊，谁叫我是你妹呢。”
03、final 类
“如果一个类使用了 final 关键字修饰，那么它就无法被继承…..”
“等等，哥，我知道，String 类就是一个 final 类。”还没等我说完，三妹就抢着说到。
“说得没毛病。”
123public final class String    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence,               Constable, ConstantDesc {}
“那三妹你知道为什么 String 类要设计成 final 吗？”
“这个还真不知道。”三妹的表情透露出这种无奈。
“原因大致有 3 个。”

为了实现字符串常量池
为了线程安全
为了 HashCode 的不可变性

“任何尝试从 final 类继承的行为将会引发编译错误。来看这段代码。”
1234567891011public final class Writer {    private String name;        public String getName() {        return name;    }        public void setName(String name) {        this.name &#x3D; name;    }}
“尝试去继承它，编译器会提示以下错误，Writer 类是 final 的，无法继承。”

“不过，类是 final 的，并不意味着该类的对象是不可变的。”
“来看这段代码。”
123Writer writer &#x3D; new Writer();writer.setName(&quot;沉默王二&quot;);System.out.println(writer.getName()); &#x2F;&#x2F; 沉默王二
“Writer 的 name 字段的默认值是 null，但可以通过 settter 方法将其更改为沉默王二。也就是说，如果一个类只是 final 的，那么它并不是不可变的全部条件。”
“关于不可变类，我们留到后面来细讲。”
不可变类
“把一个类设计成 final 的，有其安全方面的考虑，但不应该故意为之，因为把一个类定义成 final 的，意味着它没办法继承，假如这个类的一些方法存在一些问题的话，我们就无法通过重写的方式去修复它。”
“三妹，final 关键字我们就学到这里吧，你一会再学习一下 Java 字符串为什么是不可变的和不可变类。”我揉一揉犯困的双眼，疲惫地给三妹说，“学完这两个知识点，你会对 final 的认知更清晰一些。”
“好的，二哥，我这就去学习去。你去休息会。”
3.17 Java instanceof关键字“三妹，今天我们来过一个非常简单的知识点，instanceof关键字。”
“用不着哥你来讲了，今天就换个形式，我来讲给你听。”三妹雄赳赳气昂昂地说。
instanceof 关键字的用法其实很简单：
1(object) instanceof (type)
用意也非常简单，判断对象是否符合指定的类型，结果要么是 true，要么是 false。在反序列化的时候，instanceof 操作符还是蛮常用的，因为这时候我们不太确定对象属不属于指定的类型，如果不进行判断的话，就容易抛出 ClassCastException 异常。
我们来建这样一个简单的类 Round：
12class Round {}
然后新增一个扩展类 Ring：
12class Ring extends Round {}
这时候，我们就可以通过 instanceof 来检查 Ring 对象是否属于 Round 类型。
12Ring ring &#x3D; new Ring();System.out.println(ring instanceof Round);
结果会输出 true，因为 Ring 继承了 Round，也就意味着 Ring 和 Round 符合 is-a 的关系，而 instanceof操作符正是基于类与类之间的继承关系，以及类与接口之间的实现关系的。
我们再来新建一个接口 Shape：
12interface Shape {}
然后新建 Circle 类实现 Shape 接口并继承 Round 类：
12class Circle extends Round implements Shape {}
如果对象是由该类创建的，那么 instanceof 的结果肯定为 true。
12Circle circle &#x3D; new Circle();System.out.println(circle instanceof Circle);
这个肯定没毛病，instanceof 就是干这个活的，大家也很好理解。那如果类型是父类呢？
1System.out.println(circle instanceof Round);
结果肯定还是 true，因为依然符合 is-a 的关系。那如果类型为接口呢？
1System.out.println(circle instanceof Shape);
结果仍然为 true， 因为也符合 is-a 的关系。如果要比较的对象和要比较的类型之间没有关系，当然是不能使用 instanceof 进行比较的。
为了验证这一点，我们来创建一个实现了 Shape 但与 Circle 无关的 Triangle 类：
12class Triangle implements Shape {}
这时候，再使用 instanceof 进行比较的话，编译器就报错了。
1System.out.println(circle instanceof Triangle);
错误信息如下所示：
12Inconvertible types; cannot cast &#39;com.itwanger.twentyfour.instanceof1.Circle&#39; to&#39;com.itwanger.twentyfour.instanceof1.Triangle&#39;
意思就是类型不匹配，不能转换，我们使用 instanceof 比较的目的，也就是希望如果结果为 true 的时候能进行类型转换。但显然 Circle 不能转为 Triangle。
编译器已经提前帮我们预知了，很聪明。
Java 是一门面向对象的编程语言，也就意味着除了基本数据类型，所有的类都会隐式继承 Object 类。所以下面的结果肯定也会输出 true。
12Thread thread &#x3D; new Thread();System.out.println(thread instanceof Object);
“那如果对象为 null 呢？”我这时候插话了。
“这个还真的是一个好问题啊。”三妹忍不住对我竖了一个大拇指。
1System.out.println(null instanceof Object);
只有对象才会有 null 值，所以编译器是不会报错的，只不过，对于 null 来说，instanceof 的结果为 false。
因为所有的对象都可以为 null，所以也不好确定 null 到底属于哪一个类。
通常，我们是这样使用 instanceof 操作符的。
123456&#x2F;&#x2F; 先判断类型if (obj instanceof String) {    &#x2F;&#x2F; 然后强制转换    String s &#x3D; (String) obj;    &#x2F;&#x2F; 然后才能使用}
先用 instanceof 进行类型判断，然后再把 obj 强制转换成我们期望的类型再进行使用。
JDK 16 的时候，instanceof 模式匹配转了正，意味着使用 instanceof 的时候更便捷了。
123if (obj instanceof String s) {    &#x2F;&#x2F; 如果类型匹配 直接使用 s}
可以直接在 if 条件判断类型的时候添加一个变量，就不需要再强转和声明新的变量了。
“哇，这样就简洁了呀！”为了配合三妹，我不仅惊叹到！
“好了，关于 instanceof 操作符我们就先讲到这吧，难是一点都不难，希望哥也能够很好的掌握。”三妹笑嘻嘻地说，看来她很享受这个讲的过程嘛。
3.18 Java不可变对象“二哥，你能给我说说为什么 String 是 immutable 类（不可变对象）吗？我想研究它，想知道为什么它就不可变了，这种强烈的愿望就像想研究浩瀚的星空一样。但无奈自身功力有限，始终觉得雾里看花终隔一层。”
三妹的这句话里满是彩虹屁的味道。
“既然三妹你说话这么好听，那我们就开始吧！”我愉快的心情就好像吃了两罐蜂蜜一样。
01、什么是不可变类
一个类的对象在通过构造方法创建后如果状态不会再被改变，那么它就是一个不可变（immutable）类。它的所有成员变量的赋值仅在构造方法中完成，不会提供任何 setter 方法供外部类去修改。
还记得《神雕侠侣》中小龙女的古墓吗？随着那一声巨响，仅有的通道就被无情地关闭了。别较真那个密道，我这么说只是为了打开你的想象力，让你对不可变类有一个更直观的印象。
自从有了多线程，生产力就被无限地放大了，所有的程序员都爱它，因为强大的硬件能力被充分地利用了。但与此同时，所有的程序员都对它心生忌惮，因为一不小心，多线程就会把对象的状态变得混乱不堪。
为了保护状态的原子性、可见性、有序性，我们程序员可以说是竭尽所能。其中，synchronized（同步）关键字是最简单最入门的一种解决方案。
假如说类是不可变的，那么对象的状态就也是不可变的。这样的话，每次修改对象的状态，就会产生一个新的对象供不同的线程使用，我们程序员就不必再担心并发问题了。
02、常见的不可变类
提到不可变类，几乎所有的程序员第一个想到的，就是 String 类。那为什么 String 类要被设计成不可变的呢？
1）常量池的需要
字符串常量池是 Java 堆内存中一个特殊的存储区域，当创建一个 String 对象时，假如此字符串在常量池中不存在，那么就创建一个；假如已经存，就不会再创建了，而是直接引用已经存在的对象。这样做能够减少JVM 的内存开销，提高效率。
2）hashCode 需要
因为字符串是不可变的，所以在它创建的时候，其 hashCode 就被缓存了，因此非常适合作为哈希值（比如说作为 HashMap 的键），多次调用只返回同一个值，来提高效率。
3）线程安全
就像之前说的那样，如果对象的状态是可变的，那么在多线程环境下，就很容易造成不可预期的结果。而String 是不可变的，就可以在多个线程之间共享，不需要同步处理。
因此，当我们调用 String 类的任何方法（比如说 trim() 、 substring() 、 toLowerCase() ）时，总会返回一个新的对象，而不影响之前的值。
123String cmower &#x3D; &quot;沉默王二，一枚有趣的程序员&quot;;cmower.substring(0,4);System.out.println(cmower);&#x2F;&#x2F; 沉默王二，一枚有趣的程序员
虽然调用 substring() 方法对 cmower 进行了截取，但 cmower 的值没有改变。
除了 String 类，包装器类 Integer、Long 等也是不可变类。
03、手撸一个不可变类
看懂一个不可变类也许容易，但要创建一个自定义的不可变类恐怕就有点难了。但知难而进是我们作为一名优秀的程序员不可或缺的品质，正因为不容易，我们才能真正地掌握它。
接下来，就请和我一起，来自定义一个不可变类吧。一个不可变类，必须要满足以下 4 个条件：
1）确保类是 final 的，不允许被其他类继承。
2）确保所有的成员变量（字段）是 final 的，这样的话，它们就只能在构造方法中初始化值，并且不会在随后被修改。
3）不要提供任何 setter 方法。
4）如果要修改类的状态，必须返回一个新的对象。
按照以上条件，我们来自定义一个简单的不可变类 Writer。
1234567891011121314151617public final class Writer {    private final String name;    private final int age;        public Writer(String name, int age) {        this.name &#x3D; name;        this.age &#x3D; age;    }     public int getAge() {        return age;    }        public String getName() {        return name;    }}
Writer 类是 final 的，name 和 age 也是 final 的，没有 setter 方法。
OK，据说这个作者分享了很多博客，广受读者的喜爱，因此某某出版社找他写了一本书（Book）。Book 类是这样定义的：
12345678910111213141516171819202122232425262728public class Book {    private String name;    private int price;        public String getName() {        return name;    }        public void setName(String name) {        this.name &#x3D; name;    }        public int getPrice() {        return price;    }        public void setPrice(int price) {        this.price &#x3D; price;    }        @Override    public String toString() {        return &quot;Book{&quot; +                &quot;name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, price&#x3D;&quot; + price +                &#39;}&#39;;    }}
2 个字段，分别是 name 和 price，以及 getter 和 setter，重写后的 toString() 方法。然后，在 Writer类中追加一个可变对象字段 book。
1234567891011121314151617181920212223public final class Writer {    private final String name;    private final int age;    private final Book book;    public Writer(String name, int age, Book book) {        this.name &#x3D; name;        this.age &#x3D; age;        this.book &#x3D; book;    }        public int getAge() {        return age;    }        public String getName() {        return name;    }        public Book getBook() {        return book;    }}
并在构造方法中追加了 Book 参数，以及 Book 的 getter 方法。
完成以上工作后，我们来新建一个测试类，看看 Writer 类的状态是否真的不可变。
1234567891011public class WriterDemo {    public static void main(String[] args) {        Book book &#x3D; new Book();        book.setName(&quot;二哥的 Java 进阶之路&quot;);        book.setPrice(79);        Writer writer &#x3D; new Writer(&quot;沉默王二&quot;,18, book);        System.out.println(&quot;定价：&quot; + writer.getBook());        writer.getBook().setPrice(59);        System.out.println(&quot;促销价：&quot; + writer.getBook());    }}
程序输出的结果如下所示：
12定价：Book{name&#x3D;&#39;二哥的 Java 进阶之路&#39;, price&#x3D;79}促销价：Book{name&#x3D;&#39;二哥的 Java 进阶之路&#39;, price&#x3D;59}
糟糕，Writer 类的不可变性被破坏了，价格发生了变化。为了解决这个问题，我们需要为不可变类的定义规则追加一条内容：
如果一个不可变类中包含了可变类的对象，那么就需要确保返回的是可变对象的副本。也就是说，Writer 类中的 getBook() 方法应该修改为：
123456public Book getBook() {    Book clone &#x3D; new Book();    clone.setPrice(this.book.getPrice());    clone.setName(this.book.getName());    return clone;}
这样的话，构造方法初始化后的 Book 对象就不会再被修改了。此时，运行 WriterDemo，就会发现价格不再发生变化了。
04、总结
不可变类有很多优点，就像之前提到的 String 类那样，尤其是在多线程环境下，它非常的安全。尽管每次修改都会创建一个新的对象，增加了内存的消耗，但这个缺点相比它带来的优点，显然是微不足道的——无非就是捡了西瓜，丢了芝麻。
“好了，三妹，你应该理解了吧？”
3.19 Java方法重写和方法重载“今天要学习 Java 中的方法重载与方法重写。”我迅速地走到电脑前面，打开一份 Excel 文档，看了一下《教妹学 Java（二哥的 Java 进阶之路前身）》的进度，然后对三妹说。
“如果一个类有多个名字相同但参数个数不同的方法，我们通常称这些方法为方法重载。 ”我面带着朴实无华的微笑继续说，“如果方法的功能是一样的，但参数不同，使用相同的名字可以提高程序的可读性。”
“如果子类具有和父类一样的方法（参数相同、返回类型相同、方法名相同，但方法体可能不同），我们称之为方法重写。 方法重写用于提供父类已经声明的方法的特殊实现，是实现多态的基础条件。”
“只不过，方法重载与方法重写在名字上很相似，就像是兄弟俩，导致初学者经常把它们俩搞混。”
“方法重载的英文名叫 Overloading，方法重写的英文名叫 Overriding，因此，不仅中文名很相近，英文名之间也很相近，这就更容易让初学者搞混了。”
“但两者其实是完全不同的！通过下面这张图，你就能看得一清二楚。”
话音刚落，我就在 IDEA 中噼里啪啦地敲了起来。两段代码，分别是方法重写和方法重载。然后，把这两段代码截图到 draw.io（一个很漂亮的在线画图网站）上，加了一些文字说明。最后，打开 Photoscape X，把两张图片合并到了一起。
01、方法重载
“三妹，你仔细听哦。”我缓了一口气后继续说道。
“在 Java 中，有两种方式可以达到方法重载的目的。”
“第一，改变参数的数目。来看下面这段代码。”
12345678910111213141516public class OverloadingByParamNum {    public static void main(String[] args) {        System.out.println(Adder.add(10, 19));        System.out.println(Adder.add(10, 19, 20));    }}class Adder {    static int add(int a, int b) {        return a + b;    }        static int add(int a, int b, int c) {        return a + b + c;    }}  
“Adder 类有两个方法，第一个 add() 方法有两个参数，在调用的时候可以传递两个参数；第二个 add()方法有三个参数，在调用的时候可以传递三个参数。”
“二哥，这样的代码不会显得啰嗦吗？如果有四个参数的时候就再追加一个方法？”三妹突然提了一个很尖锐的问题。
“那倒是，这个例子只是为了说明方法重载的一种类型。如果参数类型相同的话，Java 提供了可变参数的方式，就像下面这样。”
1234567static int add(int ... args) {    int sum &#x3D; 0;    for ( int a: args) {        sum +&#x3D; a;    }    return sum;}
“第二，通过改变参数类型，也可以达到方法重载的目的。来看下面这段代码。”
12345678910111213141516public class OverloadingByParamType {    public static void main(String[] args) {        System.out.println(Adder.add(10, 19));        System.out.println(Adder.add(10.1, 19.2));    }}class Adder {    static int add(int a, int b) {        return a + b;    }        static double add(double a, double b) {        return a + b;    }}
“Adder 类有两个方法，第一个 add() 方法的参数类型为 int，第二个 add() 方法的参数类型为 double。”
“二哥，改变参数的数目和类型都可以实现方法重载，为什么改变方法的返回值类型就不可以呢？”三妹很能抓住问题的重点嘛。
“因为仅仅改变返回值类型的话，会把编译器搞懵逼的。”我略带调皮的口吻回答她。
“编译时报错优于运行时报错，所以当两个方法的名字相同，参数个数和类型也相同的时候，虽然返回值类型不同，但依然会提示方法已经被定义的错误。”

“你想啊，三妹。我们在调用一个方法的时候，可以指定返回值类型，也可以不指定。当不指定的时候，直接指定 add(1, 2) 的时候，编译器就不知道该调用返回 int 的 add() 方法还是返回 double 的 add() 方法，产生了歧义。”
“方法的返回值只是作为方法运行后的一个状态，它是保持方法的调用者和被调用者进行通信的一个纽带，但并不能作为某个方法的‘标识’。”
“二哥，我想到了一个点， main() 方法可以重载吗？”
“三妹，这是个好问题啊！答案是肯定的，毕竟 main() 方法也是个方法，只不过，Java 虚拟机在运行的时候只会调用带有 String 数组的那个 main() 方法。”
12345678910111213public class OverloadingMain {    public static void main(String[] args) {        System.out.println(&quot;String[] args&quot;);    }        public static void main(String args) {        System.out.println(&quot;String args&quot;);    }        public static void main() {        System.out.println(&quot;无参&quot;);    }}
“第一个 main() 方法的参数形式为 String[] args ，是最标准的写法；第二个 main() 方法的参数形式为 String args ，少了中括号；第三个 main() 方法没有参数。”
“来看一下程序的输出结果。”
1String[] args
“从结果中，我们可以看得出，尽管 main() 方法可以重载，但程序只认标准写法。”
“由于可以通过改变参数类型的方式实现方法重载，那么当传递的参数没有找到匹配的方法时，就会发生隐式的类型转换。”

“如上图所示，byte 可以向上转换为 short、int、long、float 和 double，short 可以向上转换为 int、long、float 和 double，char 可以向上转换为 int、long、float 和 double，依次类推。”
“三妹，来看下面这个示例。”
123456789101112131415public class OverloadingTypePromotion {    void sum(int a, long b) {        System.out.println(a + b);    }        void sum(int a, int b, int c) {        System.out.println(a + b + c);    }        public static void main(String args[]) {        OverloadingTypePromotion obj &#x3D; new OverloadingTypePromotion();        obj.sum(20, 20);        obj.sum(20, 20, 20);    }}
“执行 obj.sum(20, 20) 的时候，发现没有 sum(int a, int b) 的方法，所以此时第二个 20 向上转型为long，所以调用的是 sum(int a, long b) 的方法。”
“再来看一个示例。”
1234567891011121314public class OverloadingTypePromotion1 {    void sum(int a, int b) {        System.out.println(&quot;int&quot;);    }        void sum(long a, long b) {        System.out.println(&quot;long&quot;);    }        public static void main(String args[]) {        OverloadingTypePromotion1 obj &#x3D; new OverloadingTypePromotion1();        obj.sum(20, 20);    }}
“执行 obj.sum(20, 20) 的时候，发现有 sum(int a, int b) 的方法，所以就不会向上转型为 long，调用 sum(long a, long b) 。”
“来看一下程序的输出结果。”
1int
“继续来看示例。”
1234567891011121314public class OverloadingTypePromotion2 {    void sum(long a, int b) {        System.out.println(&quot;long int&quot;);    }        void sum(int a, long b) {        System.out.println(&quot;int long&quot;);    }        public static void main(String args[]) {        OverloadingTypePromotion2 obj &#x3D; new OverloadingTypePromotion2();        obj.sum(20, 20);    }}
“二哥，我又想到一个问题。当有两个方法 sum(long a, int b) 和 sum(int a, long b) ，参数个数相同，参数类型相同，只不过位置不同的时候，会发生什么呢？”
“当通过 obj.sum(20, 20) 来调用 sum 方法的时候，编译器会提示错误。”

“不明确，编译器会很为难，究竟是把第一个 20 从 int 转成 long 呢，还是把第二个 20 从 int 转成 long，智障了！所以，不能写这样让编译器左右为难的代码。”
02、方法重写
“三妹，累吗？我们稍微休息一下吧。”我把眼镜摘下来，放到桌子上，闭上了眼睛，开始胡思乱想起来。
“哥，醒醒，你就说休息一会，没说睡着啊。赶紧，我还有半个小时就要走了。”
我戴上眼镜，对三妹继续说道：“在 Java 中，方法重写需要满足以下三个规则。”

重写的方法必须和父类中的方法有着相同的名字；
重写的方法必须和父类中的方法有着相同的参数；
必须是 is-a 的关系（继承关系）。

“来看下面这段代码。”
“来看一下程序的输出结果。”
123456789101112public class Bike extends Vehicle {    public static void main(String[] args) {        Bike bike &#x3D; new Bike();        bike.run();    }}class Vehicle {    void run() {        System.out.println(&quot;车辆在跑&quot;);    }}
“来看一下程序的输出结果。”
1车辆在跑
“Bike is-a Vehicle，自行车是一种车，没错。Vehicle 类有一个 run() 的方法，也就是说车辆可以跑，Bike继承了 Vehicle，也可以跑。但如果 Bike 没有重写 run() 方法的话，自行车就只能是‘车辆在跑’，而不是‘自行车在跑’，对吧？”
“如果有了方法重写，一切就好办了。”
12345678910111213141516public class Bike extends Vehicle {    @Override    void run() {        System.out.println(&quot;自行车在跑&quot;);    }        public static void main(String[] args) {        Bike bike &#x3D; new Bike();        bike.run();    }}class Vehicle {    void run() {        System.out.println(&quot;车辆在跑&quot;);    }}
我把鼠标移动到 Bike 类的 run() 方法，对三妹说：“你看，在方法重写的时候，IDEA 会建议使用@Override 注解，显式的表示这是一个重写后的方法，尽管可以缺省。”
“来看一下程序的输出结果。”
1自行车在跑
“Bike 重写了 run() 方法，也就意味着，Bike 可以跑出自己的风格。”
好，接下来说一下重写时应当遵守的 12 条规则，应当谨记哦。
规则一：只能重写继承过来的方法。
因为重写是在子类重新实现从父类继承过来的方法时发生的，所以只能重写继承过来的方法，这很好理解。这就意味着，只能重写那些被 public、protected 或者 default 修饰的方法，private 修饰的方法无法被重写。
Animal 类有 move() 、 eat() 和 sleep() 三个方法：
123456public class Animal {    public void move() { }    protected void eat() { }        void sleep(){ }}
Dog 类来重写这三个方法：
12345public class Dog extends Animal {    public void move() { }    protected void eat() { }    void sleep(){ }}
OK，完全没有问题。但如果父类中的方法是 private 的，就行不通了。
123public class Animal {    private void move() { }}
此时，Dog 类中的 move() 方法就不再是一个重写方法了，因为父类的 move() 方法是 private 的，对子类并不可见。
123public class Dog extends Animal {    public void move() { }}
规则二：final、static 的方法不能被重写。
一个方法是 final 的就意味着它无法被子类继承到，所以就没办法重写。
123public class Animal {    final void move() { }}
由于父类 Animal 中的 move() 是 final 的，所以子类在尝试重写该方法的时候就出现编译错误了！

同样的，如果一个方法是 static 的，也不允许重写，因为静态方法可用于父类以及子类的所有实例。
123public class Animal {    final void move() { }}
重写的目的在于根据对象的类型不同而表现出多态，而静态方法不需要创建对象就可以使用。没有了对象，重写所需要的“对象的类型”也就没有存在的意义了。

规则三：重写的方法必须有相同的参数列表。
123public class Animal {    void eat(String food) { }}
Dog 类中的 eat() 方法保持了父类方法 eat() 的同一个调调，都有一个参数——String 类型的 food。
123public class Dog extends Animal {    public void eat(String food) { }}
一旦子类没有按照这个规则来，比如说增加了一个参数：
123public class Dog extends Animal {    public void eat(String food, int amount) { }}
这就不再是重写的范畴了，当然也不是重载的范畴，因为重载考虑的是同一个类。
规则四：重写的方法必须返回相同的类型。
父类没有返回类型：
123public class Animal {    void eat(String food) { }}
子类尝试返回 String：
12345public class Dog extends Animal {    public String eat(String food) {        return null;    }}
于是就编译出错了（返回类型不兼容）。

规则五：重写的方法不能使用限制等级更严格的权限修饰符。
可以这样来理解：

如果被重写的方法是 default，那么重写的方法可以是 default、protected 或者 public。
如果被重写的方法是 protected，那么重写的方法只能是 protected 或者 public。
如果被重写的方法是 public， 那么重写的方法就只能是 public。

举个例子，父类中的方法是 protected：
123public class Animal {    protected void eat() { }}
子类中的方法可以是 public：
123public class Dog extends Animal {    public void eat() { }}
如果子类中的方法用了更严格的权限修饰符，编译器就报错了。

规则六：重写后的方法不能抛出比父类中更高级别的异常。
举例来说，如果父类中的方法抛出的是 IOException，那么子类中重写的方法不能抛出 Exception，可以是IOException 的子类或者不抛出任何异常。这条规则只适用于可检查的异常。
可检查（checked）异常必须在源代码中显式地进行捕获处理，不检查（unchecked）异常就是所谓的运行时异常，比如说 NullPointerException、ArrayIndexOutOfBoundsException 之类的，不会在编译器强制要求。
父类抛出 IOException：
123public class Animal {    protected void eat() throws IOException { }}
子类抛出 FileNotFoundException 是可以满足重写的规则的，因为 FileNotFoundException 是 IOException的子类。
123public class Dog extends Animal {   public void eat() throws FileNotFoundException { }}
如果子类抛出了一个新的异常，并且是一个 checked 异常：
123public class Dog extends Animal {   public void eat() throws FileNotFoundException, InterruptedException { }}
那编译器就会提示错误：
123Error:(9, 16) java: com.itwanger.overriding.Dog中的eat()无法覆盖com.itwanger.overriding.Animal中的eat()  被覆盖的方法未抛出java.lang.InterruptedException
但如果子类抛出的是一个 unchecked 异常，那就没有冲突：
123public class Dog extends Animal {   public void eat() throws FileNotFoundException, IllegalArgumentException { }}
如果子类抛出的是一个更高级别的异常：
123public class Dog extends Animal {   public void eat() throws Exception { }}
编译器同样会提示错误，因为 Exception 是 IOException 的父类。
123Error:(9, 16) java: com.itwanger.overriding.Dog中的eat()无法覆盖com.itwanger.overriding.Animal中的eat()  被覆盖的方法未抛出java.lang.Exception
规则七：可以在子类中通过 super 关键字来调用父类中被重写的方法。
子类继承父类的方法而不是重新实现是很常见的一种做法，在这种情况下，可以按照下面的形式调用父类的方法：
1super.overriddenMethodName();
来看例子。
123public class Animal {    protected void eat() { }}
子类重写了 eat() 方法，然后在子类的 eat() 方法中，可以在方法体的第一行通过 super.eat() 调用父类的方法，然后再增加属于自己的代码。
123456public class Dog extends Animal {   public void eat() {       super.eat();       &#x2F;&#x2F; Dog-eat   }}
规则八：构造方法不能被重写。
因为构造方法很特殊，而且子类的构造方法不能和父类的构造方法同名（类名不同），所以构造方法和重写之间没有任何关系。
规则九：如果一个类继承了抽象类，抽象类中的抽象方法必须在子类中被重写。
先来看这样一个接口：
123public interface Animal {    void move();}
接口中的方法默认都是抽象方法，通过反编译是可以看得到的：
1234public interface Animal{    public abstract void move();}
如果一个抽象类实现了 Animal 接口， move() 方法不是必须被重写的：
123public abstract class AbstractDog implements Animal {    protected abstract void bark();}
但如果一个类继承了抽象类 AbstractDog，那么 Animal 接口中的 move() 方法和抽象类 AbstractDog 中的抽象方法 bark() 都必须被重写：
123456public class BullDog extends AbstractDog {     public void move() {}     protected void bark() {}}
规则十：synchronized 关键字对重写规则没有任何影响。
synchronized 关键字用于在多线程环境中获取和释放监听对象，因此它对重写规则没有任何影响，这就意味着 synchronized 方法可以去重写一个非同步方法。
规则十一：strictfp 关键字对重写规则没有任何影响。
如果你想让浮点运算更加精确，而且不会因为硬件平台的不同导致执行的结果不一致的话，可以在方法上添加 strictfp 关键字，之前讲过。因此 strictfp 关键字和重写规则无关。
03、总结
“好了，三妹，我来简单做个总结。”我瞥了一眼电脑右上角的时钟，离三妹离开的时间不到 10 分钟了。
“首先来说一下方法重载时的注意事项，‘两同一不同’。”
“‘两同’：在同一个类，方法名相同。”
“‘一不同’：参数不同。”
“再来说一下方法重写时的注意事项，‘两同一小一大’。”
“‘两同’：方法名相同，参数相同。”
“‘一小’：子类方法声明的异常类型要比父类小一些或者相等。”
“‘一大’：子类方法的访问权限应该比父类的更大或者相等。”
3.20 Java注解“二哥，这节讲注解吗？”三妹问。
“是的。”我说，“注解是 Java 中非常重要的一部分，但经常被忽视也是真的。之所以这么说是因为我们更倾向成为一名注解的使用者而不是创建者。 @Override 注解用过吧？方法重写的时候用到过。但你知道怎么自定义一个注解吗？”
三妹毫不犹豫地摇摇头，摆摆手，不好意思地承认自己的确没有自定义过。
“好吧，哥来告诉你吧。”
注解（Annotation）是在 Java 1.5 时引入的概念，同 class 和 interface 一样，也属于一种类型。注解提供了一系列数据用来装饰程序代码（类、方法、字段等），但是注解并不是所装饰代码的一部分，它对代码的运行效果没有直接影响，由编译器决定该执行哪些操作。
来看一段代码。
1234567public class AutowiredTest {    @Autowired    private String name;    public static void main(String[] args) {        System.out.println(&quot;沉默王二，一枚有趣的程序员&quot;);    }}
注意到 @Autowired 这个注解了吧？它本来是为 Spring（后面会讲）容器注入 Bean 的，现在被我无情地扔在了字段 name 的身上，但这段代码所在的项目中并没有启用 Spring，意味着 @Autowired 注解此时只是一个摆设。
“既然只是个摆设，那你这个地方为什么还要用 @Autowired 呢？”三妹好奇地问。
“傻呀你，就是给你举个例子，证明：注解对代码的运行效果没有直接影响，明白我的用意了吧？”我毫不客气地说。
“哦。”三妹若有所思地说。
“认真听哈，接下来给你讲讲注解的生命周期。”我瞅了瞅三妹，看她是否在专注的听，然后继续说，“注解的生命周期有 3 种策略，定义在 RetentionPolicy 枚举中。”
1）SOURCE：在源文件中有效，被编译器丢弃。
2）CLASS：在编译器生成的字节码文件中有效，但在运行时会被处理类文件的 JVM 丢弃。
3）RUNTIME：在运行时有效。这也是注解生命周期中最常用的一种策略，它允许程序通过反射的方式访问注解，并根据注解的定义执行相应的代码。
“然后我们来讲注解装饰的目标。”我看三妹还在线，就继续说。
注解的目标定义了注解将适用于哪一种级别的 Java 代码上，有些注解只适用于方法，有些只适用于成员变量，有些只适用于类，有些则都适用。截止到 Java 9，注解的类型一共有 11 种，定义在 ElementType 枚举中。
1）TYPE：用于类、接口、注解、枚举
2）FIELD：用于字段（类的成员变量），或者枚举常量
3）METHOD：用于方法
4）PARAMETER：用于普通方法或者构造方法的参数
5）CONSTRUCTOR：用于构造方法
6）LOCAL_VARIABLE：用于变量
7）ANNOTATION_TYPE：用于注解
8）PACKAGE：用于包
9）TYPE_PARAMETER：用于泛型参数
10）TYPE_USE：用于声明语句、泛型或者强制转换语句中的类型
11）MODULE：用于模块
“哥，你将这些我都记不住，能不能直接开撸注解呀！！！！！”三妹不耐烦了。
“确实哈，说再多，都不如撸个注解来得让人心动。撸个什么样的注解呢？一个字段注解吧，它用来标记对象在序列化成 JSON 的时候要不要包含这个字段。”我笑着对三妹说，“怎么样？”
“好呀！”
“来看下面这段代码。”
12345@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.FIELD)public @interface JsonField {    public String value() default &quot;&quot;;}
1）JsonField 注解的生命周期是 RUNTIME，也就是运行时有效。
2）JsonField 注解装饰的目标是 FIELD，也就是针对字段的。
3）创建注解需要用到 @interface 关键字。
4）JsonField 注解有一个参数，名字为 value，类型为 String，默认值为一个空字符串。
“为什么参数名要为 value 呢？有什么特殊的含义吗？”三妹问。
“当然是有的，value 允许注解的使用者提供一个无需指定名字的参数。举个例子，我们可以在一个字段上使用 @JsonField(value &#x3D; “沉默王二”) ，也可以把 value &#x3D; 省略，变成 @JsonField(“沉默王二”) 。”我说。
“那 default “” 有什么特殊含义吗？”三妹继续问。
“当然也是有的，它允许我们在一个字段上直接使用 @JsonField ，而无需指定参数的名和值。”我回答说。
“明白了，那 @JsonField 注解已经撸好了，是不是可以使用它了呀？”三妹激动地说。
“嗯，假设有一个 Writer 类，他有 3 个字段，分别是 age、name 和 bookName，后 2 个是必须序列化的字段。就可以这样来用 @JsonField 注解。”我说。
123456789101112131415161718192021public class Writer {    private int age;    @JsonField(&quot;writerName&quot;)    private String name;    @JsonField    private String bookName;    public Writer(int age, String name, String bookName) {        this.age &#x3D; age;        this.name &#x3D; name;        this.bookName &#x3D; bookName;    }    &#x2F;&#x2F; getter &#x2F; setter    @Override    public String toString() {        return &quot;Writer{&quot; +                &quot;age&#x3D;&quot; + age +                &quot;, name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, bookName&#x3D;&#39;&quot; + bookName + &#39;\&#39;&#39; +                &#39;}&#39;;    }}
1）name 上的 @JsonField 注解提供了显式的字符串值。
2）bookName 上的 @JsonField 注解使用了缺省项。
接下来，我们来编写序列化类 JsonSerializer，内容如下：
123456789101112131415161718192021222324252627282930public class JsonSerializer {    public static String serialize(Object object) throws IllegalAccessException {        Class&lt;?&gt; objectClass &#x3D; object.getClass();        Map&lt;String, String&gt; jsonElements &#x3D; new HashMap&lt;&gt;();        for (Field field : objectClass.getDeclaredFields()) {            field.setAccessible(true);            if (field.isAnnotationPresent(JsonField.class)) {                jsonElements.put(getSerializedKey(field), (String) field.get(object));            }        }        return toJsonString(jsonElements);    }    private static String getSerializedKey(Field field) {        String annotationValue &#x3D; field.getAnnotation(JsonField.class).value();        if (annotationValue.isEmpty()) {            return field.getName();        } else {            return annotationValue;        }    }    private static String toJsonString(Map&lt;String, String&gt; jsonMap) {        String elementsString &#x3D; jsonMap.entrySet()                .stream()                .map(entry -&gt; &quot;\&quot;&quot; + entry.getKey() + &quot;\&quot;:\&quot;&quot; + entry.getValue() + &quot;\&quot;&quot;)                .collect(Collectors.joining(&quot;,&quot;));        return &quot;{&quot; + elementsString + &quot;}&quot;;    }}
“JsonSerializer 类的内容看起来似乎有点多啊，二哥，我有点看不懂。”三妹说。
“不要怕，我一点点来解释，直到你搞明白为止。”
1） serialize() 方法是用来序列化对象的，它接收一个 Object 类型的参数。
objectClass.getDeclaredFields() 通过反射的方式获取对象声明的所有字段，然后进行 for 循环遍历。在 for 循环中，先通过 field.setAccessible(true) 将反射对象的可访问性设置为 true，供序列化使用（如果没有这个步骤的话，private 字段是无法获取的，会抛出 IllegalAccessException 异常）；再通过isAnnotationPresent() 判断字段是否装饰了 JsonField 注解，如果是的话，调用getSerializedKey() 方法，以及获取该对象上由此字段表示的值，并放入 jsonElements 中。
2） getSerializedKey() 方法用来获取字段上注解的值，如果注解的值是空的，则返回字段名。
3） toJsonString() 方法借助 Stream 流的方式返回格式化后的 JSON 字符串。Stream 流你还没有接触过，不过没关系，后面我再给你讲。
“现在是不是豁然开朗了？”我问三妹，看到三妹点了点头，我继续说，“接下来，我们来写一个测试类
123456public class JsonFieldTest {    public static void main(String[] args) throws IllegalAccessException {        Writer cmower &#x3D; new Writer(18,&quot;沉默王二&quot;,&quot;Web全栈开发进阶之路&quot;);        System.out.println(JsonSerializer.serialize(cmower));    }}
程序输出结果如下：
1{&quot;bookName&quot;:&quot;Web全栈开发进阶之路&quot;,&quot;writerName&quot;:&quot;沉默王二&quot;}
从结果上来看：
1）Writer 类的 age 字段没有装饰 @JsonField 注解，所以没有序列化。
2）Writer 类的 name 字段装饰了 @JsonField 注解，并且显示指定了字符串“writerName”，所以序列化后变成了 writerName。
3）Writer 类的 bookName 字段装饰了 @JsonField 注解，但没有显式指定值，所以序列化后仍然是bookName。
“怎么样，三妹，是不是也不是特别难？”我对三妹说。
“撸个注解好像真没什么难度，但你接下来的那个 JsonSerializer 我还需要再消化一下。”三妹很认真地说。
“嗯，你好好复习下，我看会《编译原理》。”说完我拿起桌子边上的一本书就走了。
3.21 Java枚举（enum）“今天我们来学习枚举吧，三妹！”我说，“同学让你去她家玩了两天，感觉怎么样呀？”
“心情放松了不少。”三妹说，“可以开始学 Java 了，二哥。”
“OK。”
“枚举（enum），是 Java 1.5 时引入的关键字，它表示一种特殊类型的类，继承自 java.lang.Enum。”
“我们来新建一个枚举 PlayerType。”
12345public enum PlayerType {    TENNIS,    FOOTBALL,    BASKETBALL}
“二哥，我没看到有继承关系呀！”
“别着急，看一下反编译后的字节码，你就明白了。”
1234567891011121314151617181920212223242526272829303132public final class PlayerType extends Enum{    public static PlayerType[] values()    {        return (PlayerType[])$VALUES.clone();    }        public static PlayerType valueOf(String name)    {        return (PlayerType)Enum.valueOf(com&#x2F;cmower&#x2F;baeldung&#x2F;enum1&#x2F;PlayerType, name);    }        private PlayerType(String s, int i)    {        super(s, i);    }        public static final PlayerType TENNIS;    public static final PlayerType FOOTBALL;    public static final PlayerType BASKETBALL;    private static final PlayerType $VALUES[];        static     {        TENNIS &#x3D; new PlayerType(&quot;TENNIS&quot;, 0);        FOOTBALL &#x3D; new PlayerType(&quot;FOOTBALL&quot;, 1);        BASKETBALL &#x3D; new PlayerType(&quot;BASKETBALL&quot;, 2);        $VALUES &#x3D; (new PlayerType[] {            TENNIS, FOOTBALL, BASKETBALL        });    }}
“看到没？Java 编译器帮我们做了很多隐式的工作，不然手写一个枚举就没那么省心省事了。”

要继承 Enum 类；
要写构造方法；
要声明静态变量和数组；
要用 static 块来初始化静态变量和数组；
要提供静态方法，比如说 values() 和 valueOf(String name) 。

“确实，作为开发者，我们的代码量减少了，枚举看起来简洁明了。”三妹说。
“既然枚举是一种特殊的类，那它其实是可以定义在一个类的内部的，这样它的作用域就可以限定于这个外部类中使用。”我说。
1234567891011121314151617181920public class Player {    private PlayerType type;    public enum PlayerType {        TENNIS,        FOOTBALL,        BASKETBALL    }        public boolean isBasketballPlayer() {      return getType() &#x3D;&#x3D; PlayerType.BASKETBALL;    }        public PlayerType getType() {        return type;    }        public void setType(PlayerType type) {        this.type &#x3D; type;    }}
PlayerType 就相当于 Player 的内部类。
由于枚举是 final 的，所以可以确保在 Java 虚拟机中仅有一个常量对象，基于这个原因，我们可以使用“&#x3D;&#x3D;”运算符来比较两个枚举是否相等，参照 isBasketballPlayer() 方法。
“那为什么不使用 equals() 方法判断呢？”三妹问。
1if(player.getType().equals(Player.PlayerType.BASKETBALL)){};
“我来给你解释下。”
“&#x3D;&#x3D;”运算符比较的时候，如果两个对象都为 null，并不会发生 NullPointerException ，而 equals() 方法则会。
另外， “&#x3D;&#x3D;”运算符会在编译时进行检查，如果两侧的类型不匹配，会提示错误，而 equals() 方法则不会。

“枚举还可用于 switch 语句，和基本数据类型的用法一致。”我说。
12345678910111213switch (playerType) {    case TENNIS:        return &quot;网球运动员费德勒&quot;;    case FOOTBALL:        return &quot;足球运动员C罗&quot;;    case BASKETBALL:        return &quot;篮球运动员詹姆斯&quot;;    case UNKNOWN:        throw new IllegalArgumentException(&quot;未知&quot;);    default:        throw new IllegalArgumentException(                &quot;运动员类型: &quot; + playerType);}
“如果枚举中需要包含更多信息的话，可以为其添加一些字段，比如下面示例中的 name，此时需要为枚举添加一个带参的构造方法，这样就可以在定义枚举时添加对应的名称了。”我继续说。
123456789public enum PlayerType {    TENNIS(&quot;网球&quot;),    FOOTBALL(&quot;足球&quot;),    BASKETBALL(&quot;篮球&quot;);    private String name;    PlayerType(String name) {        this.name &#x3D; name;    }}
“get 了吧，三妹？”
“嗯，比较好理解。”
“那接下来，我就来说点不一样的。”
“来吧，我准备好了。”
“EnumSet 是一个专门针对枚举类型的 Set 接口（后面会讲）的实现类，它是处理枚举类型数据的一把利器，非常高效。”我说，“从名字上就可以看得出，EnumSet 不仅和 Set 有关系，和枚举也有关系。”
“因为 EnumSet 是一个抽象类，所以创建 EnumSet 时不能使用 new 关键字。不过，EnumSet 提供了很多有用的静态工厂方法。”

“来看下面这个例子，我们使用 noneOf() 静态工厂方法创建了一个空的 PlayerType 类型的 EnumSet；使用 allOf() 静态工厂方法创建了一个包含所有 PlayerType 类型的 EnumSet。”
1234567891011121314public class EnumSetTest {    public enum PlayerType {        TENNIS,        FOOTBALL,        BASKETBALL    }    public static void main(String[] args) {        EnumSet&lt;PlayerType&gt; enumSetNone &#x3D; EnumSet.noneOf(PlayerType.class);        System.out.println(enumSetNone);        EnumSet&lt;PlayerType&gt; enumSetAll &#x3D; EnumSet.allOf(PlayerType.class);        System.out.println(enumSetAll);    }}
“来看一下输出结果。”
12[][TENNIS, FOOTBALL, BASKETBALL]
有了 EnumSet 后，就可以使用 Set 的一些方法了，见下图。

“除了 EnumSet，还有 EnumMap，是一个专门针对枚举类型的 Map 接口的实现类，它可以将枚举常量作为键来使用。EnumMap 的效率比 HashMap 还要高，可以直接通过数组下标（枚举的 ordinal 值）访问到元素。”
“和 EnumSet 不同，EnumMap 不是一个抽象类，所以创建 EnumMap 时可以使用 new 关键字。”
1EnumMap&lt;PlayerType, String&gt; enumMap &#x3D; new EnumMap&lt;&gt;(PlayerType.class);
有了 EnumMap 对象后就可以使用 Map 的一些方法了，见下图。

和 HashMap（后面会讲）的使用方法大致相同，来看下面的例子。
12345678EnumMap&lt;PlayerType, String&gt; enumMap &#x3D; new EnumMap&lt;&gt;(PlayerType.class);enumMap.put(PlayerType.BASKETBALL,&quot;篮球运动员&quot;);enumMap.put(PlayerType.FOOTBALL,&quot;足球运动员&quot;);enumMap.put(PlayerType.TENNIS,&quot;网球运动员&quot;);System.out.println(enumMap);System.out.println(enumMap.get(PlayerType.BASKETBALL));System.out.println(enumMap.containsKey(PlayerType.BASKETBALL));System.out.println(enumMap.remove(PlayerType.BASKETBALL));
“来看一下输出结果。”
1234{TENNIS&#x3D;网球运动员, FOOTBALL&#x3D;足球运动员, BASKETBALL&#x3D;篮球运动员}篮球运动员true篮球运动员
“除了以上这些，《Effective Java》这本书里还提到了一点，如果要实现单例的话，最好使用枚举的方式。”我说。
“等等二哥，单例是什么？”三妹没等我往下说，就连忙问道。
“单例（Singleton）用来保证一个类仅有一个对象，并提供一个访问它的全局访问点，在一个进程中。因为这个类只有一个对象，所以就不能再使用 new 关键字来创建新的对象了。”
“Java 标准库有一些类就是单例，比如说 Runtime 这个类。”
1Runtime runtime &#x3D; Runtime.getRuntime();
“Runtime 类可以用来获取 Java 程序运行时的环境。”
“关于单例，懂了些吧？”我问三妹。
“噢噢噢噢。”三妹点了点头。
“通常情况下，实现单例并非易事，来看下面这种写法。”
1234567891011121314public class Singleton {      private volatile static Singleton singleton;     private Singleton (){}      public static Singleton getSingleton() {      if (singleton &#x3D;&#x3D; null) {        synchronized (Singleton.class) {         if (singleton &#x3D;&#x3D; null) {              singleton &#x3D; new Singleton();         }          }      }      return singleton;      }  }
“要用到 volatile、synchronized 关键字等等，但枚举的出现，让代码量减少到极致。”
123public enum EasySingleton{    INSTANCE;}
“就这？”三妹睁大了眼睛。
“对啊，枚举默认实现了 Serializable 接口，因此 Java 虚拟机可以保证该类为单例，这与传统的实现方式不大相同。传统方式中，我们必须确保单例在反序列化期间不能创建任何新实例。”我说。
“好了，关于枚举就讲这么多吧，三妹，你把这些代码都手敲一遍吧！”
“好勒，这就安排。二哥，你去休息吧。”
4 Java 集合框架4.1 List、Set、Map、队列，全面解析眼瞅着三妹的王者荣耀杀得正嗨，我趁机喊到：“别打了，三妹，我们来一起学习 Java 的集合框架吧。”
“才不要呢，等我打完这一局啊。”三妹倔强地说。
“好吧。”我只好摊摊手地说，“那我先画张集合框架的结构图等着你。”

“完了没？三妹。”
“完了好一会儿了，二哥，你图画得真慢，让我瞧瞧怎么样？”
“害，图要画得清晰明了，不容易的。三妹，你瞧，不错吧。”
“哇，果然很棒，哥，你可真认真！”
“我来简单介绍一下吧，Java 集合框架可以分为两条大的支线：”

Collection，主要由 List、Set、Queue 组成，List 代表有序、可重复的集合，典型代表就是封装了动态数组的 ArrayList 和封装了链表的 LinkedList；Set 代表无序、不可重复的集合，典型代表就是 HashSet 和 TreeSet；Queue 代表队列，典型代表就是双端队列 ArrayDeque，以及优先级队列 PriorityQueue。
Map，代表键值对的集合，典型代表就是 HashMap。

01、List 
List 的特点是存取有序，可以存放重复的元素，可以用下标对元素进行操作。
1）ArrayList 
先来一段 ArrayList 的增删改查，学会用。
123456789101112131415161718192021222324252627&#x2F;&#x2F; 创建一个集合ArrayList&lt;String&gt; list &#x3D; new ArrayList&lt;String&gt;();&#x2F;&#x2F; 添加元素list.add(&quot;王二&quot;);list.add(&quot;沉默&quot;);list.add(&quot;陈清扬&quot;);&#x2F;&#x2F; 遍历集合 for 循环for (int i &#x3D; 0; i &lt; list.size(); i++) {    String s &#x3D; list.get(i);    System.out.println(s);}&#x2F;&#x2F; 遍历集合 for eachfor (String s : list) {    System.out.println(s);}&#x2F;&#x2F; 删除元素list.remove(1);&#x2F;&#x2F; 遍历集合for (String s : list) {    System.out.println(s);}&#x2F;&#x2F; 修改元素list.set(1, &quot;王二狗&quot;);&#x2F;&#x2F; 遍历集合for (String s : list) {    System.out.println(s);}
简单介绍一下 ArrayList 的特征，后面还会详细讲。

ArrayList 是由数组实现的，支持随机存取，也就是可以通过下标直接存取元素；
从尾部插入和删除元素会比较快捷，从中间插入和删除元素会比较低效，因为涉及到数组元素的复制和移动；
如果内部数组的容量不足时会自动扩容，因此当元素非常庞大的时候，效率会比较低。

2）LinkedList 
同样先来一段 LinkedList 的增删改查，和 ArrayList 几乎没什么差别。
123456789101112131415161718192021222324252627&#x2F;&#x2F; 创建一个集合LinkedList&lt;String&gt; list &#x3D; new LinkedList&lt;String&gt;();&#x2F;&#x2F; 添加元素list.add(&quot;王二&quot;);list.add(&quot;沉默&quot;);list.add(&quot;陈清扬&quot;);&#x2F;&#x2F; 遍历集合 for 循环for (int i &#x3D; 0; i &lt; list.size(); i++) {    String s &#x3D; list.get(i);    System.out.println(s);}&#x2F;&#x2F; 遍历集合 for eachfor (String s : list) {    System.out.println(s);}&#x2F;&#x2F; 删除元素list.remove(1);&#x2F;&#x2F; 遍历集合for (String s : list) {    System.out.println(s);}&#x2F;&#x2F; 修改元素list.set(1, &quot;王二狗&quot;);&#x2F;&#x2F; 遍历集合for (String s : list) {    System.out.println(s);}
不过，LinkedList 和 ArrayList 仍然有较大的不同，后面也会详细地讲。

LinkedList 是由双向链表实现的，不支持随机存取，只能从一端开始遍历，直到找到需要的元素后返回；
任意位置插入和删除元素都很方便，因为只需要改变前一个节点和后一个节点的引用即可，不像 ArrayList 那样需要复制和移动数组元素；
因为每个元素都存储了前一个和后一个节点的引用，所以相对来说，占用的内存空间会比 ArrayList 多一些。

3）Vector 和 Stack 
List 的实现类还有一个 Vector，是一个元老级的类，比 ArrayList 出现得更早。ArrayList 和 Vector 非常相似，只不过 Vector 是线程安全的，像 get、set、add 这些方法都加了 synchronized 关键字，就导致执行执行效率会比较低，所以现在已经很少用了。
我就不写太多代码了，只看一下 add 方法的源码就明白了。
1234public synchronized boolean add(E e) {    elementData[elementCount++] &#x3D; e;    return true;}
这种加了同步方法的类，注定会被淘汰掉，就像StringBuilder取代StringBuffer那样。JDK 源码也说了：

如果不需要线程安全，建议使用ArrayList代替Vector。


Stack 是 Vector 的一个子类，本质上也是由动态数组实现的，只不过还实现了先进后出的功能（在 get、set、add 方法的基础上追加了 pop「返回并移除栈顶的元素」、peek「只返回栈顶元素」等方法），所以叫栈。
下面是这两个方法的源码，增删改查我就不写了，和 ArrayList 和 LinkedList 几乎一样。
12345678910111213public synchronized E pop() {    E       obj;    int     len &#x3D; size();    obj &#x3D; peek();    removeElementAt(len - 1);    return obj;}public synchronized E peek() {    int     len &#x3D; size();    if (len &#x3D;&#x3D; 0)        throw new EmptyStackException();    return elementAt(len - 1);}
不过，由于 Stack 执行效率比较低（方法上同样加了 synchronized 关键字），就被双端队列 ArrayDeque 取代了（下面会介绍）。
02、Set 
Set 的特点是存取无序，不可以存放重复的元素，不可以用下标对元素进行操作，和 List 有很多不同。
1）HashSet 
HashSet 其实是由 HashMap 实现的，只不过值由一个固定的 Object 对象填充，而键用于操作。来简单看一下它的源码。
1234567891011121314151617public class HashSet&lt;E&gt;    extends AbstractSet&lt;E&gt;    implements Set&lt;E&gt;, Cloneable, java.io.Serializable{    private transient HashMap&lt;E,Object&gt; map;    &#x2F;&#x2F; Dummy value to associate with an Object in the backing Map    private static final Object PRESENT &#x3D; new Object();    public HashSet() {        map &#x3D; new HashMap&lt;&gt;();    }    public boolean add(E e) {        return map.put(e, PRESENT)&#x3D;&#x3D;null;    }    public boolean remove(Object o) {        return map.remove(o)&#x3D;&#x3D;PRESENT;    }}
实际开发中，HashSet 并不常用，比如，如果我们需要按照顺序存储一组元素，那么ArrayList和LinkedList可能更适合；如果我们需要存储键值对并根据键进行查找，那么HashMap可能更适合。
当然，在某些情况下，HashSet仍然是最好的选择。例如，当我们需要快速查找一个元素是否存在于某个集合中，并且我们不需要对元素进行排序时，HashSet可以提供高效的性能。
来一段增删改查体验一下：
1234567891011121314151617181920&#x2F;&#x2F; 创建一个新的HashSetHashSet&lt;String&gt; set &#x3D; new HashSet&lt;&gt;();&#x2F;&#x2F; 添加元素set.add(&quot;沉默&quot;);set.add(&quot;王二&quot;);set.add(&quot;陈清扬&quot;);&#x2F;&#x2F; 输出HashSet的元素个数System.out.println(&quot;HashSet size: &quot; + set.size()); &#x2F;&#x2F; output: 3&#x2F;&#x2F; 判断元素是否存在于HashSet中boolean containsWanger &#x3D; set.contains(&quot;王二&quot;);System.out.println(&quot;Does set contain &#39;王二&#39;? &quot; + containsWanger); &#x2F;&#x2F; output: true&#x2F;&#x2F; 删除元素boolean removeWanger &#x3D; set.remove(&quot;王二&quot;);System.out.println(&quot;Removed &#39;王二&#39;? &quot; + removeWanger); &#x2F;&#x2F; output: true&#x2F;&#x2F; 修改元素，需要先删除后添加boolean removeChenmo &#x3D; set.remove(&quot;沉默&quot;);boolean addBuChenmo &#x3D; set.add(&quot;不沉默&quot;);System.out.println(&quot;Modified set? &quot; + (removeChenmo &amp;&amp; addBuChenmo)); &#x2F;&#x2F; output: true&#x2F;&#x2F; 输出修改后的HashSetSystem.out.println(&quot;HashSet after modification: &quot; + set); &#x2F;&#x2F; output: [陈清扬, 不沉默]
2）LinkedHashSet 
LinkedHashSet 虽然继承自 HashSet，其实是由 LinkedHashMap 实现的。
这是 LinkedHashSet 的无参构造方法：
123public LinkedHashSet() {    super(16, .75f, true);}
super 的意思是它将调用父类的 HashSet 的一个有参构造方法：
123HashSet(int initialCapacity, float loadFactor, boolean dummy) {    map &#x3D; new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);}
看到 LinkedHashMap 了吧，这个我们后面会去讲。
好吧，来看一段 LinkedHashSet 的增删改查吧。
1234567891011121314151617LinkedHashSet&lt;String&gt; set &#x3D; new LinkedHashSet&lt;&gt;();&#x2F;&#x2F; 添加元素set.add(&quot;沉默&quot;);set.add(&quot;王二&quot;);set.add(&quot;陈清扬&quot;);&#x2F;&#x2F; 删除元素set.remove(&quot;王二&quot;);&#x2F;&#x2F; 修改元素set.remove(&quot;沉默&quot;);set.add(&quot;沉默的力量&quot;);&#x2F;&#x2F; 查找元素boolean hasChenQingYang &#x3D; set.contains(&quot;陈清扬&quot;);System.out.println(&quot;set包含陈清扬吗？&quot; + hasChenQingYang);
在以上代码中，我们首先创建了一个LinkedHashSet对象，然后使用add方法依次添加了三个元素：沉默、王二和陈清扬。接着，我们使用remove方法删除了王二这个元素，并使用remove和add方法修改了沉默这个元素。最后，我们使用contains方法查找了陈清扬这个元素是否存在于set中，并打印了结果。
LinkedHashSet是一种基于哈希表实现的Set接口，它继承自HashSet，并且使用链表维护了元素的插入顺序。因此，它既具有HashSet的快速查找、插入和删除操作的优点，又可以维护元素的插入顺序。
3）TreeSet 
“二哥，不用你讲了，我能猜到，TreeSet 是由 TreeMap（后面会讲） 实现的，只不过同样操作的键位，值由一个固定的 Object 对象填充。”
哇，三妹都学会了推理。
是的，与 TreeMap 相似，TreeSet 是一种基于红黑树实现的有序集合，它实现了 SortedSet 接口，可以自动对集合中的元素进行排序。按照键的自然顺序或指定的比较器顺序进行排序。
123456789101112131415161718192021&#x2F;&#x2F; 创建一个 TreeSet 对象TreeSet&lt;String&gt; set &#x3D; new TreeSet&lt;&gt;();&#x2F;&#x2F; 添加元素set.add(&quot;沉默&quot;);set.add(&quot;王二&quot;);set.add(&quot;陈清扬&quot;);System.out.println(set); &#x2F;&#x2F; 输出 [沉默, 王二, 陈清扬]&#x2F;&#x2F; 删除元素set.remove(&quot;王二&quot;);System.out.println(set); &#x2F;&#x2F; 输出 [沉默, 陈清扬]&#x2F;&#x2F; 修改元素：TreeSet 中的元素不支持直接修改，需要先删除再添加set.remove(&quot;陈清扬&quot;);set.add(&quot;陈青阳&quot;);System.out.println(set); &#x2F;&#x2F; 输出 [沉默, 陈青阳]&#x2F;&#x2F; 查找元素System.out.println(set.contains(&quot;沉默&quot;)); &#x2F;&#x2F; 输出 trueSystem.out.println(set.contains(&quot;王二&quot;)); &#x2F;&#x2F; 输出 false
需要注意的是，TreeSet 不允许插入 null 元素，否则会抛出 NullPointerException 异常。
“总体上来说，Set 集合不是关注的重点，因为底层都是由 Map 实现的，为什么要用 Map 实现呢？三妹你能猜到原因吗？”
“让我想想。”
“嗯？难道是因为 Map 的键不允许重复、无序吗？”老天，竟然被三妹猜到了。
“是的，你这水平长进了呀，三妹。”
03、Queue 
Queue，也就是队列，通常遵循先进先出（FIFO）的原则，新元素插入到队列的尾部，访问元素返回队列的头部。
1）ArrayDeque 
从名字上可以看得出，ArrayDeque 是一个基于数组实现的双端队列，为了满足可以同时在数组两端插入或删除元素的需求，数组必须是循环的，也就是说数组的任何一点都可以被看作是起点或者终点。
这是一个包含了 4 个元素的双端队列，和一个包含了 5 个元素的双端队列。

head 指向队首的第一个有效的元素，tail 指向队尾第一个可以插入元素的空位，因为是循环数组，所以 head 不一定从是从 0 开始，tail 也不一定总是比 head 大。
来一段ArrayDeque的增删改查吧。
123456789101112131415161718&#x2F;&#x2F; 创建一个ArrayDequeArrayDeque&lt;String&gt; deque &#x3D; new ArrayDeque&lt;&gt;();&#x2F;&#x2F; 添加元素deque.add(&quot;沉默&quot;);deque.add(&quot;王二&quot;);deque.add(&quot;陈清扬&quot;);&#x2F;&#x2F; 删除元素deque.remove(&quot;王二&quot;);&#x2F;&#x2F; 修改元素deque.remove(&quot;沉默&quot;);deque.add(&quot;沉默的力量&quot;);&#x2F;&#x2F; 查找元素boolean hasChenQingYang &#x3D; deque.contains(&quot;陈清扬&quot;);System.out.println(&quot;deque包含陈清扬吗？&quot; + hasChenQingYang);
2）LinkedList 
LinkedList 一般应该归在 List 下，只不过，它也实现了 Deque 接口，可以作为队列来使用。等于说，LinkedList 同时实现了 Stack、Queue、PriorityQueue 的所有功能。
1234public class LinkedList&lt;E&gt;    extends AbstractSequentialList&lt;E&gt;    implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable{}
换句话说，LinkedList 和 ArrayDeque 都是 Java 集合框架中的双向队列（deque），它们都支持在队列的两端进行元素的插入和删除操作。不过，LinkedList 和 ArrayDeque 在实现上有一些不同：

底层实现方式不同：LinkedList 是基于链表实现的，而 ArrayDeque 是基于数组实现的。
随机访问的效率不同：由于底层实现方式的不同，LinkedList 对于随机访问的效率较低，时间复杂度为 O(n)，而 ArrayDeque 可以通过下标随机访问元素，时间复杂度为 O(1)。
迭代器的效率不同：LinkedList 对于迭代器的效率比较低，因为需要通过链表进行遍历，时间复杂度为 O(n)，而 ArrayDeque 的迭代器效率比较高，因为可以直接访问数组中的元素，时间复杂度为 O(1)。
内存占用不同：由于 LinkedList 是基于链表实现的，它在存储元素时需要额外的空间来存储链表节点，因此内存占用相对较高，而 ArrayDeque 是基于数组实现的，内存占用相对较低。

因此，在选择使用 LinkedList 还是 ArrayDeque 时，需要根据具体的业务场景和需求来选择。如果需要在双向队列的两端进行频繁的插入和删除操作，并且需要随机访问元素，可以考虑使用 ArrayDeque；如果需要在队列中间进行频繁的插入和删除操作，可以考虑使用 LinkedList。
来一段 LinkedList 作为队列时候的增删改查吧，注意和它作为 List 的时候有很大的不同。
1234567891011121314151617181920212223242526272829303132&#x2F;&#x2F; 创建一个 LinkedList 对象LinkedList&lt;String&gt; queue &#x3D; new LinkedList&lt;&gt;();&#x2F;&#x2F; 添加元素queue.offer(&quot;沉默&quot;);queue.offer(&quot;王二&quot;);queue.offer(&quot;陈清扬&quot;);System.out.println(queue); &#x2F;&#x2F; 输出 [沉默, 王二, 陈清扬]&#x2F;&#x2F; 删除元素queue.poll();System.out.println(queue); &#x2F;&#x2F; 输出 [王二, 陈清扬]&#x2F;&#x2F; 修改元素：LinkedList 中的元素不支持直接修改，需要先删除再添加String first &#x3D; queue.poll();queue.offer(&quot;王大二&quot;);System.out.println(queue); &#x2F;&#x2F; 输出 [陈清扬, 王大二]&#x2F;&#x2F; 查找元素：LinkedList 中的元素可以使用 get() 方法进行查找System.out.println(queue.get(0)); &#x2F;&#x2F; 输出 陈清扬System.out.println(queue.contains(&quot;沉默&quot;)); &#x2F;&#x2F; 输出 false&#x2F;&#x2F; 查找元素：使用迭代器的方式查找陈清扬&#x2F;&#x2F; 使用迭代器依次遍历元素并查找Iterator&lt;String&gt; iterator &#x3D; queue.iterator();while (iterator.hasNext()) {    String element &#x3D; iterator.next();    if (element.equals(&quot;陈清扬&quot;)) {        System.out.println(&quot;找到了：&quot; + element);        break;    }}
在使用 LinkedList 作为队列时，可以使用 offer() 方法将元素添加到队列的末尾，使用 poll() 方法从队列的头部删除元素。另外，由于 LinkedList 是链表结构，不支持随机访问元素，因此不能使用下标访问元素，需要使用迭代器或者 poll() 方法依次遍历元素。
3）PriorityQueue 
PriorityQueue 是一种优先级队列，它的出队顺序与元素的优先级有关，执行 remove 或者 poll 方法，返回的总是优先级最高的元素。
1234567891011121314151617181920212223242526272829&#x2F;&#x2F; 创建一个 PriorityQueue 对象PriorityQueue&lt;String&gt; queue &#x3D; new PriorityQueue&lt;&gt;();&#x2F;&#x2F; 添加元素queue.offer(&quot;沉默&quot;);queue.offer(&quot;王二&quot;);queue.offer(&quot;陈清扬&quot;);System.out.println(queue); &#x2F;&#x2F; 输出 [沉默, 王二, 陈清扬]&#x2F;&#x2F; 删除元素queue.poll();System.out.println(queue); &#x2F;&#x2F; 输出 [王二, 陈清扬]&#x2F;&#x2F; 修改元素：PriorityQueue 不支持直接修改元素，需要先删除再添加String first &#x3D; queue.poll();queue.offer(&quot;张三&quot;);System.out.println(queue); &#x2F;&#x2F; 输出 [张三, 陈清扬]&#x2F;&#x2F; 查找元素：PriorityQueue 不支持随机访问元素，只能访问队首元素System.out.println(queue.peek()); &#x2F;&#x2F; 输出 张三System.out.println(queue.contains(&quot;陈清扬&quot;)); &#x2F;&#x2F; 输出 true&#x2F;&#x2F; 通过 for 循环的方式查找陈清扬for (String element : queue) {    if (element.equals(&quot;陈清扬&quot;)) {        System.out.println(&quot;找到了：&quot; + element);        break;    }}
要想有优先级，元素就需要实现 Comparable 接口或者 Comparator 接口（我们后面会讲）。
这里先来一段通过实现 Comparator 接口按照年龄姓名排序的优先级队列吧。
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import java.util.Comparator;import java.util.PriorityQueue;class Student {    private String name;    private int chineseScore;    private int mathScore;        public Student(String name, int chineseScore, int mathScore) {        this.name &#x3D; name;        this.chineseScore &#x3D; chineseScore;        this.mathScore &#x3D; mathScore;    }        public String getName() {        return name;    }        public int getChineseScore() {        return chineseScore;    }        public int getMathScore() {        return mathScore;    }        @Override    public String toString() {        return &quot;Student{&quot; +                &quot;name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, 总成绩&#x3D;&quot; + (chineseScore + mathScore) +                &#39;}&#39;;    }}class StudentComparator implements Comparator&lt;Student&gt; {    @Override    public int compare(Student s1, Student s2) {        &#x2F;&#x2F; 比较总成绩        return Integer.compare(s2.getChineseScore() + s2.getMathScore(),                s1.getChineseScore() + s1.getMathScore());    }}public class PriorityQueueComparatorExample {    public static void main(String[] args) {        &#x2F;&#x2F; 创建一个按照总成绩排序的优先级队列        PriorityQueue&lt;Student&gt; queue &#x3D; new PriorityQueue&lt;&gt;(new StudentComparator());        &#x2F;&#x2F; 添加元素        queue.offer(new Student(&quot;王二&quot;, 80, 90));        System.out.println(queue);        queue.offer(new Student(&quot;陈清扬&quot;, 95, 95));        System.out.println(queue);        queue.offer(new Student(&quot;小驼铃&quot;, 90, 95));        System.out.println(queue);        queue.offer(new Student(&quot;沉默&quot;, 90, 80));        while (!queue.isEmpty()) {            System.out.print(queue.poll() + &quot; &quot;);        }    }}
Student 是一个学生对象，包含姓名、语文成绩和数学成绩。
StudentComparator 实现了 Comparator 接口，对总成绩做了一个排序。
PriorityQueue 是一个优先级队列，参数为 StudentComparator，然后我们添加了 4 个学生对象进去。
来看一下输出结果：
123456[Student{name&#x3D;&#39;王二&#39;, 总成绩&#x3D;170}][Student{name&#x3D;&#39;陈清扬&#39;, 总成绩&#x3D;190}, Student{name&#x3D;&#39;王二&#39;, 总成绩&#x3D;170}][Student{name&#x3D;&#39;陈清扬&#39;, 总成绩&#x3D;190}, Student{name&#x3D;&#39;王二&#39;, 总成绩&#x3D;170}, Student{name&#x3D;&#39;小驼铃&#39;, 总成绩&#x3D;185}]Student{name&#x3D;&#39;陈清扬&#39;, 总成绩&#x3D;190} Student{name&#x3D;&#39;小驼铃&#39;, 总成绩&#x3D;185} Student{name&#x3D;&#39;沉默&#39;, 总成绩&#x3D;170} Student{name&#x3D;&#39;王二&#39;, 总成绩&#x3D;170} 
我们使用 offer 方法添加元素，最后用 while 循环遍历元素（通过 poll 方法取出元素），从结果可以看得出，PriorityQueue按照学生的总成绩由高到低进行了排序。
04、Map 
Map 保存的是键值对，键要求保持唯一性，值可以重复。
1）HashMap 
HashMap 实现了 Map 接口，可以根据键快速地查找对应的值——通过哈希函数将键映射到哈希表中的一个索引位置，从而实现快速访问。后面会详细聊到。
这里先大致了解一下 HashMap 的特点：

HashMap 中的键和值都可以为 null。如果键为 null，则将该键映射到哈希表的第一个位置。
可以使用迭代器或者 forEach 方法遍历 HashMap 中的键值对。
HashMap 有一个初始容量和一个负载因子。初始容量是指哈希表的初始大小，负载因子是指哈希表在扩容之前可以存储的键值对数量与哈希表大小的比率。默认的初始容量是 16，负载因子是 0.75。

来个简单的增删改查吧。
12345678910111213141516171819202122232425&#x2F;&#x2F; 创建一个 HashMap 对象HashMap&lt;String, String&gt; hashMap &#x3D; new HashMap&lt;&gt;();&#x2F;&#x2F; 添加键值对hashMap.put(&quot;沉默&quot;, &quot;cenzhong&quot;);hashMap.put(&quot;王二&quot;, &quot;wanger&quot;);hashMap.put(&quot;陈清扬&quot;, &quot;chenqingyang&quot;);&#x2F;&#x2F; 获取指定键的值String value1 &#x3D; hashMap.get(&quot;沉默&quot;);System.out.println(&quot;沉默对应的值为：&quot; + value1);&#x2F;&#x2F; 修改键对应的值hashMap.put(&quot;沉默&quot;, &quot;chenmo&quot;);String value2 &#x3D; hashMap.get(&quot;沉默&quot;);System.out.println(&quot;修改后沉默对应的值为：&quot; + value2);&#x2F;&#x2F; 删除指定键的键值对hashMap.remove(&quot;王二&quot;);&#x2F;&#x2F; 遍历 HashMapfor (String key : hashMap.keySet()) {    String value &#x3D; hashMap.get(key);    System.out.println(key + &quot; 对应的值为：&quot; + value);}
2）LinkedHashMap 
HashMap 已经非常强大了，但它是无序的。如果我们需要一个有序的Map，就要用到 LinkedHashMap。
LinkedHashMap 是 HashMap 的子类，它使用链表来记录插入&#x2F;访问元素的顺序。
LinkedHashMap 可以看作是 HashMap + LinkedList 的合体，它使用了哈希表来存储数据，又用了双向链表来维持顺序。
来一个简单的例子。
1234567891011&#x2F;&#x2F; 创建一个 LinkedHashMap，插入的键值对为 沉默 王二 陈清扬LinkedHashMap&lt;String, String&gt; linkedHashMap &#x3D; new LinkedHashMap&lt;&gt;();linkedHashMap.put(&quot;沉默&quot;, &quot;cenzhong&quot;);linkedHashMap.put(&quot;王二&quot;, &quot;wanger&quot;);linkedHashMap.put(&quot;陈清扬&quot;, &quot;chenqingyang&quot;);&#x2F;&#x2F; 遍历 LinkedHashMapfor (String key : linkedHashMap.keySet()) {    String value &#x3D; linkedHashMap.get(key);    System.out.println(key + &quot; 对应的值为：&quot; + value);}
来看输出结果：
123沉默 对应的值为：cenzhong王二 对应的值为：wanger陈清扬 对应的值为：chenqingyang
从结果中可以看得出来，LinkedHashMap 维持了键值对的插入顺序，对吧？为了和 LinkedHashMap 做对比，我们用同样的数据试验一下 HashMap。
123456789101112&#x2F;&#x2F; 创建一个HashMap，插入的键值对为 沉默 王二 陈清扬HashMap&lt;String, String&gt; hashMap &#x3D; new HashMap&lt;&gt;();hashMap.put(&quot;沉默&quot;, &quot;cenzhong&quot;);hashMap.put(&quot;王二&quot;, &quot;wanger&quot;);hashMap.put(&quot;陈清扬&quot;, &quot;chenqingyang&quot;);&#x2F;&#x2F; 遍历 HashMapfor (String key : hashMap.keySet()) {    String value &#x3D; hashMap.get(key);    System.out.println(key + &quot; 对应的值为：&quot; + value);}
来看输出结果：
123沉默 对应的值为：cenzhong陈清扬 对应的值为：chenqingyang王二 对应的值为：wanger
HashMap 没有维持键值对的插入顺序，对吧？
3）TreeMap 
TreeMap 实现了 SortedMap 接口，可以自动将键按照自然顺序或指定的比较器顺序排序，并保证其元素的顺序。内部使用红黑树来实现键的排序和查找。
同样来一个增删改查的 demo：
12345678910111213141516171819202122232425262728293031323334353637383940&#x2F;&#x2F; 创建一个 TreeMap 对象Map&lt;String, String&gt; treeMap &#x3D; new TreeMap&lt;&gt;();&#x2F;&#x2F; 向 TreeMap 中添加键值对treeMap.put(&quot;沉默&quot;, &quot;cenzhong&quot;);treeMap.put(&quot;王二&quot;, &quot;wanger&quot;);treeMap.put(&quot;陈清扬&quot;, &quot;chenqingyang&quot;);&#x2F;&#x2F; 查找键值对String name &#x3D; &quot;沉默&quot;;if (treeMap.containsKey(name)) {    System.out.println(&quot;找到了 &quot; + name + &quot;: &quot; + treeMap.get(name));} else {    System.out.println(&quot;没有找到 &quot; + name);}&#x2F;&#x2F; 修改键值对name &#x3D; &quot;王二&quot;;if (treeMap.containsKey(name)) {    System.out.println(&quot;修改前的 &quot; + name + &quot;: &quot; + treeMap.get(name));    treeMap.put(name, &quot;newWanger&quot;);    System.out.println(&quot;修改后的 &quot; + name + &quot;: &quot; + treeMap.get(name));} else {    System.out.println(&quot;没有找到 &quot; + name);}&#x2F;&#x2F; 删除键值对name &#x3D; &quot;陈清扬&quot;;if (treeMap.containsKey(name)) {    System.out.println(&quot;删除前的 &quot; + name + &quot;: &quot; + treeMap.get(name));    treeMap.remove(name);    System.out.println(&quot;删除后的 &quot; + name + &quot;: &quot; + treeMap.get(name));} else {    System.out.println(&quot;没有找到 &quot; + name);}&#x2F;&#x2F; 遍历 TreeMapfor (Map.Entry&lt;String, String&gt; entry : treeMap.entrySet()) {    System.out.println(entry.getKey() + &quot;: &quot; + entry.getValue());}
与 HashMap 不同的是，TreeMap 会按照键的顺序来进行排序。
123456789101112&#x2F;&#x2F; 创建一个 TreeMap 对象Map&lt;String, String&gt; treeMap &#x3D; new TreeMap&lt;&gt;();&#x2F;&#x2F; 向 TreeMap 中添加键值对treeMap.put(&quot;c&quot;, &quot;cat&quot;);treeMap.put(&quot;a&quot;, &quot;apple&quot;);treeMap.put(&quot;b&quot;, &quot;banana&quot;);&#x2F;&#x2F; 遍历 TreeMapfor (Map.Entry&lt;String, String&gt; entry : treeMap.entrySet()) {    System.out.println(entry.getKey() + &quot;: &quot; + entry.getValue());}
来看输出结果：
123a: appleb: bananac: cat
默认情况下，已经按照键的自然顺序排过了。
“好了，三妹，关于集合框架，我们就先聊到这，随后我们会针对常用的容器进行详细地讲解，比如说 ArrayList、LinkedList、HashMap 等。”
“哇，二哥，这篇讲的东西可真不少，虽然都是比较基础的，但对于我一个小白来说，还是需要花点时间去消化的。”三妹嘟嘟嘴说到。
4.2 时间复杂度，了解下“二哥，为什么要讲时间复杂度呀？”三妹问。
“因为接下来要用到啊。后面我们学习 ArrayList、LinkedList 的时候，会比较两者在增删改查时的执行效率，而时间复杂度是衡量执行效率的一个重要标准。”我说。
“到时候跑一下代码，统计一下前后的时间差不更准确吗？”三妹反问道。
“实际上，你说的是另外一种评估方法，这种评估方法可以得出非常准确的数值，但也有很大的局限性。”我不急不慢地说。
第一，测试结果会受到测试环境的影响。你比如说，同样的代码，在我这台 iMac 上跑出来的时间和在你那台华为的 MacBook 上跑出的时间可能就差别很大。
第二，测试结果会受到测试数据的影响。你比如说，一个排序后的数组和一个没有排序后的数组，调用了同一个查询方法，得出来的结果可能会差别特别大。
“因此，我们需要这种不依赖于具体测试环境和测试数据就能粗略地估算出执行效率的方法，时间复杂度就是其中的一种，还有一种是空间复杂度。”我继续补充道，“如果你后面刷 LeetCode的话，对时间复杂度这个概念也会比较依赖。”
来看下面这段代码：
1234567public static int sum(int n) {    int sum &#x3D; 0; &#x2F;&#x2F; 第 1 行    for (int i&#x3D;0;i&lt;n;i++) { &#x2F;&#x2F; 第 2 行        sum &#x3D; sum + 1; &#x2F;&#x2F; 第 3 行    } &#x2F;&#x2F; 第 4 行    return sum; &#x2F;&#x2F; 第 5 行}
这段代码非常简单，方法体里总共 5 行代码，包括“}”那一行。每段代码的执行时间可能都不大一样，但假设我们认为每行代码的执行时间是一样的，比如说 unit_time，那么这段代码总的执行时间为多少呢？
“这个我知道呀！”三妹喊道，“第 1、5 行需要 2 个 unit_time，第 2、3 行需要 2nunit_time，总的时间就是 2(n+1)*unit_time。”
“对，一段代码的执行时间 T(n) 和总的执行次数成正比，也就是说，代码执行的次数越多，花费的时间就越多。”我总结道，“这个规律可以用一个公式来表达：”

T(n) &#x3D; O(f(n))

f(n) 表示代码总的执行次数，大写 O 表示代码的执行时间 T(n) 和 f(n) 成正比。
这也就是大 O 表示法，它不关心代码具体的执行时间是多少，它关心的是代码执行时间的变化趋势，这也就是时间复杂度这个概念的由来。
对于上面那段代码 sum() 来说，影响时间复杂度的主要是第 2 行代码，其余的，像系数 2、常数 2 都是可以忽略不计的，我们只关心影响最大的那个，所以时间复杂度就表示为 O(n) 。
常见的时间复杂度有这么 3 个：
1） O(1)
代码的执行时间，和数据规模 n 没有多大关系。
括号中的 1 可以是 3，可以是 5，可以 100，我们习惯用 1 来表示，表示这段代码的执行时间是一个常数级别。比如说下面这段代码：
123int i &#x3D; 0;int j &#x3D; 0;int k &#x3D; i + j;
实际上执行了 3 次，但我们也认为这段代码的时间复杂度为 O(1) 。
再举一个简单的例子。当我们访问数组中的一个元素时，它的时间复杂度就是常数时间复杂度 O(1)。
12int[] nums &#x3D; {1, 2, 3, 4, 5};int x &#x3D; nums[2]; &#x2F;&#x2F; 访问数组中下标为2的元素，时间复杂度为 O(1)
2） O(n)
时间复杂度和数据规模 n 是线性关系。换句话说，数据规模增大 K 倍，代码执行的时间就大致增加 K 倍。
当我们遍历一个数组时，它的时间复杂度就是线性时间复杂度 O(n)。
1234int[] nums &#x3D; {1, 2, 3, 4, 5};for (int i &#x3D; 0; i &lt; nums.length; i++) { &#x2F;&#x2F; 遍历整个数组，时间复杂度为 O(n)    System.out.println(nums[i]);}
3） O(logn)
时间复杂度和数据规模 n 是对数关系。换句话说，数据规模大幅增加时，代码执行的时间只有少量增加。
来看一下代码示例，
123456public static void logn(int n) {     int i &#x3D; 1;    while (i &lt; n) {        i *&#x3D; 2;    }}
换句话说，当数据量 n 从 2 增加到 2^64 时，代码执行的时间只增加了 64 倍。
12345678遍历次数 |   i----------+-------    0     |   i    1     |  i*2    2     |  i*4   ...    |  ...   ...    |  ...    k     |  i*2^k 
再举个例子。当我们对一个已排序的数组进行二分查找时，它的时间复杂度就是对数时间复杂度 O(log n)。
1234567891011121314int[] nums &#x3D; {1, 2, 3, 4, 5};int target &#x3D; 3;int left &#x3D; 0, right &#x3D; nums.length - 1;while (left &lt;&#x3D; right) {    int mid &#x3D; left + (right - left) &#x2F; 2;    if (nums[mid] &#x3D;&#x3D; target) {        System.out.println(&quot;找到了，下标为&quot; + mid);        break;    } else if (nums[mid] &lt; target) {        left &#x3D; mid + 1;    } else {        right &#x3D; mid - 1;    }}
4）平方时间复杂度O(n^2)  
当我们对一个数组进行嵌套循环时，它的时间复杂度就是平方时间复杂度 O(n^2)。
123456int[] nums &#x3D; {1, 2, 3, 4, 5};for (int i &#x3D; 0; i &lt; nums.length; i++) {    for (int j &#x3D; 0; j &lt; nums.length; j++) {        System.out.println(nums[i] + &quot; &quot; + nums[j]);    }}
5）指数时间复杂度O(2^n)  
当我们递归求解一个问题时，每一次递归都会分成两个子问题，这种情况下，它的时间复杂度就是指数时间复杂度 O(2^n)。
123456public static int fib(int n) {    if (n &lt;&#x3D; 1) {        return n;    }    return fib(n - 1) + fib(n - 2);}
上面的代码是递归求解斐波那契数列的方法，它的时间复杂度是指数级别的。
“好了，三妹，这节就讲到这吧，理解了上面 5 个时间复杂度，后面我们学习 ArrayList、LinkedList 的时候，两者在增删改查时的执行效率就很容易对比清楚了。”我伸了个懒腰后对三妹说。
“好的，二哥。”三妹重新回答沙发上，一盘王者荣耀即将开始。
4.3 ArrayList详解（附源码）“二哥，听说今天我们开讲 ArrayList 了？好期待哦！”三妹明知故问，这个托配合得依然天衣无缝。
“是的呀，三妹。”我肯定地点了点头，继续说道，“ArrayList 可以称得上是集合框架方面最常用的类了，可以和 HashMap 一较高下。”
从名字就可以看得出来，ArrayList 实现了 List 接口，并且是基于数组实现的。
数组的大小是固定的，一旦创建的时候指定了大小，就不能再调整了。也就是说，如果数组满了，就不能再添加任何元素了。ArrayList 在数组的基础上实现了自动扩容，并且提供了比数组更丰富的预定义方法（各种增删改查），非常灵活。
Java 这门编程语言和别的编程语言，比如说 C语言的不同之处就在这里，如果是 C语言的话，你就必须得动手实现自己的 ArrayList，原生的库函数里面是没有的。
01、创建 ArrayList 
“二哥，如何创建一个 ArrayList 啊？”三妹问。
1ArrayList&lt;String&gt; alist &#x3D; new ArrayList&lt;String&gt;();
可以通过上面的语句来创建一个字符串类型的 ArrayList（通过尖括号来限定 ArrayList 中元素的类型，如果尝试添加其他类型的元素，将会产生编译错误），更简化的写法如下：
1List&lt;String&gt; alist &#x3D; new ArrayList&lt;&gt;();
由于 ArrayList 实现了 List 接口，所以 alist 变量的类型可以是 List 类型；new 关键字声明后的尖括号中可以不再指定元素的类型，因为编译器可以通过前面尖括号中的类型进行智能推断。
此时会调用无参构造方法（见下面的代码）创建一个空的数组，常量DEFAULTCAPACITY_EMPTY_ELEMENTDATA的值为 {} 。
123public ArrayList() {    this.elementData &#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA;}
如果非常确定 ArrayList 中元素的个数，在创建的时候还可以指定初始大小。
1List&lt;String&gt; alist &#x3D; new ArrayList&lt;&gt;(20);
这样做的好处是，可以有效地避免在添加新的元素时进行不必要的扩容。
02、向 ArrayList 中添加元素 
“二哥，那怎么向 ArrayList 中添加一个元素呢？”三妹继续问。
可以通过 add() 方法向 ArrayList 中添加一个元素。
1alist.add(&quot;沉默王二&quot;);
我们来跟一下源码，看看 add 方法到底执行了哪些操作。跟的过程中，我们也可以偷师到 Java 源码的作者（大师级程序员）是如何优雅地写代码的。
我先给个结论，全当抛砖引玉。
12345678堆栈过程图示：add(element)└── if (size &#x3D;&#x3D; elementData.length) &#x2F;&#x2F; 判断是否需要扩容    ├── grow(minCapacity) &#x2F;&#x2F; 扩容    │   └── newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1) &#x2F;&#x2F; 计算新的数组容量    │   └── Arrays.copyOf(elementData, newCapacity) &#x2F;&#x2F; 创建新的数组    ├── elementData[size++] &#x3D; element; &#x2F;&#x2F; 添加新元素    └── return true; &#x2F;&#x2F; 添加成功
来具体看一下，先是 add() 方法的源码（已添加好详细地注释）
12345678910&#x2F;** * 将指定元素添加到 ArrayList 的末尾 * @param e 要添加的元素 * @return 添加成功返回 true *&#x2F;public boolean add(E e) {    ensureCapacityInternal(size + 1);  &#x2F;&#x2F; 确保 ArrayList 能够容纳新的元素    elementData[size++] &#x3D; e; &#x2F;&#x2F; 在 ArrayList 的末尾添加指定元素    return true;}
参数 e 为要添加的元素，此时的值为“沉默王二”，size 为 ArrayList 的长度，此时为 0。
继续跟下去，来看看 ensureCapacityInternal()方法：
123456789101112&#x2F;** * 确保 ArrayList 能够容纳指定容量的元素 * @param minCapacity 指定容量的最小值 *&#x2F;private void ensureCapacityInternal(int minCapacity) {    if (elementData &#x3D;&#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { &#x2F;&#x2F; 如果 elementData 还是默认的空数组        minCapacity &#x3D; Math.max(DEFAULT_CAPACITY, minCapacity); &#x2F;&#x2F; 使用 DEFAULT_CAPACITY 和指定容量的最小值中的较大值    }    ensureExplicitCapacity(minCapacity); &#x2F;&#x2F; 确保容量能够容纳指定容量的元素}
 此时：

参数 minCapacity 为 1（size+1 传过来的）
elementData 为存放 ArrayList 元素的底层数组，前面声明 ArrayList 的时候讲过了，此时为空 {}
DEFAULTCAPACITY_EMPTY_ELEMENTDATA 前面也讲过了，为 {}
所以，if 条件此时为 true，if 语句 minCapacity &#x3D; Math.max(DEFAULT_CAPACITY, minCapacity)要执行。
DEFAULT_CAPACITY 为 10（见下面的代码），所以执行完这行代码后，minCapacity 为 10， Math.max() 方法的作用是取两个当中最大的那个。
接下来执行 ensureExplicitCapacity() 方法，来看一下源码：


1234567891011&#x2F;** * 检查并确保集合容量足够，如果需要则增加集合容量。 * * @param minCapacity 所需最小容量 *&#x2F;private void ensureExplicitCapacity(int minCapacity) {    &#x2F;&#x2F; 检查是否超出了数组范围，确保不会溢出    if (minCapacity - elementData.length &gt; 0)        &#x2F;&#x2F; 如果需要增加容量，则调用 grow 方法        grow(minCapacity);}
 此时：

参数 minCapacity 为 10
elementData.length 为 0（数组为空）
所以 10-0&gt;0，if 条件为 true，进入 if 语句执行 grow() 方法，来看源码：


123456789101112131415&#x2F;** * 扩容 ArrayList 的方法，确保能够容纳指定容量的元素 * @param minCapacity 指定容量的最小值 *&#x2F;private void grow(int minCapacity) {    &#x2F;&#x2F; 检查是否会导致溢出，oldCapacity 为当前数组长度    int oldCapacity &#x3D; elementData.length;    int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1); &#x2F;&#x2F; 扩容至原来的1.5倍    if (newCapacity - minCapacity &lt; 0) &#x2F;&#x2F; 如果还是小于指定容量的最小值        newCapacity &#x3D; minCapacity; &#x2F;&#x2F; 直接扩容至指定容量的最小值    if (newCapacity - MAX_ARRAY_SIZE &gt; 0) &#x2F;&#x2F; 如果超出了数组的最大长度        newCapacity &#x3D; hugeCapacity(minCapacity); &#x2F;&#x2F; 扩容至数组的最大长度    &#x2F;&#x2F; 将当前数组复制到一个新数组中，长度为 newCapacity    elementData &#x3D; Arrays.copyOf(elementData, newCapacity);}
 此时：

参数 minCapacity 为 10
变量 oldCapacity 为 0

所以 newCapacity 也为 0，于是 newCapacity - minCapacity 等于 -10 小于 0，于是第一个 if 条件为 true，执行第一个 if 语句 newCapacity &#x3D; minCapacity ，然后 newCapacity 为 10。
紧接着执行 elementData &#x3D; Arrays.copyOf(elementData, newCapacity); ，也就是进行数组的第一次扩容，长度为 10。
回到 add() 方法：
12345public boolean add(E e) {    ensureCapacityInternal(size + 1);    elementData[size++] &#x3D; e;    return true;}
执行 elementData[size++] &#x3D; e 。
此时：

size 为 0
e 为 “沉默王二”
所以数组的第一个元素（下标为 0） 被赋值为“沉默王二”，接着返回 true，第一次 add 方法执行完毕。
PS：add 过程中会遇到一个令新手感到困惑的右移操作符 &gt;&gt; ，借这个机会来解释一下。
ArrayList 在第一次执行 add 后会扩容为 10，那 ArrayList 第二次扩容发生在什么时候呢？
答案是添加第 11 个元素时，大家可以尝试分析一下这个过程。


03、右移操作符 
 “oldCapacity 等于 10， oldCapacity &gt;&gt; 1 这个表达式等于多少呢？三妹你知道吗？”我问三妹。
 “不知道啊， &gt;&gt; 是什么意思呢？”三妹很疑惑。
 “ &gt;&gt; 是右移运算符， oldCapacity &gt;&gt; 1 相当于 oldCapacity 除以 2。”我给三妹解释道，“在计算机内部，都是按照二进制存储的，10 的二进制就是 1010，也就是 $02^0 + 12^1 + 02^2 + 12^3 &#x3D;0+2+0+8&#x3D;10 $。”
 还没等我解释完，三妹就打断了我，“二哥，能再详细解释一下到底为什么吗？”
 “当然可以啊。”我拍着胸脯对三妹说。
 先从位权的含义说起吧。
 平常我们使用的是十进制数，比如说 39，并不是简单的 3 和 9，3 表示的是 3*10 &#x3D; 30 ，9 表示的是 9*1 &#x3D; 9 ，和 3 相乘的 10，和 9 相乘的 1，就是位权。位数不同，位权就不同，第 1 位是 10 的 0 次方（也就是 $10^0&#x3D;1$ ），第 2 位是 10 的 1 次方（ $10^1&#x3D;10$ ），第 3 位是 10 的 2 次方（ $10^2&#x3D;100$ ），最右边的是第一位，依次类推。
 位权这个概念同样适用于二进制，第 1 位是 2 的 0 次方（也就是 $2^0&#x3D;1$ ），第 2 位是 2 的 1 次方（ $2^1&#x3D;2$ ），第 3 位是 2 的 2 次方（ $2^2&#x3D;4$ ），第 4 位是 2 的 3 次方（ $2^3&#x3D;8$ ）。
 十进制的情况下，10 是基数，二进制的情况下，2 是基数。
 10 在十进制的表示法是 $010^0+110^1 &#x3D;0+10&#x3D;10$。
 10 的二进制数是 1010，也就是 $02^0 + 12^1 + 02^2 + 12^3 &#x3D;0+2+0+8&#x3D;10$。
 然后是移位运算，移位分为左移和右移，在 Java 中，左移的运算符是 &lt;&lt; ，右移的运算符 &gt;&gt; 。
 拿 oldCapacity &gt;&gt; 1 来说吧， &gt;&gt; 左边的是被移位的值，此时是 10，也就是二进制 1010 ； &gt;&gt; 右边的是要移位的位数，此时是 1。
 1010 向右移一位就是 101，空出来的最高位此时要补 0，也就是 0101。
 “那为什么不补 1 呢？”三妹这个问题很尖锐。
 “因为是算术右移，并且是正数，所以最高位补 0；如果表示的是负数，就需要补 1。”我慢吞吞地回答道，
 “0101 的十进制就刚好是 $12^0 + 02^1 + 12^2 + 02^3 &#x3D;1+0+4+0&#x3D;5$，如果多移几个数来找规律的话，就会发现，右移1 位是原来的 1&#x2F;2，右移 2 位是原来的 1&#x2F;4，诸如此类。”
 也就是说，ArrayList 的大小会扩容为原来的大小+原来大小&#x2F;2，也就是 1.5 倍。
 这下明白了吧？
 你可以通过在 ArrayList 中添加第 11 个元素来 debug 验证一下。

 04、向 ArrayList 的指定位置添加元素 
 除了 add(E e) 方法，还可以通过 add(int index, E element) 方法把元素添加到 ArrayList 的指定位置：
1alist.add(0, &quot;沉默王三&quot;);
 add(int index, E element) 方法的源码如下：
123456789101112131415&#x2F;** * 在指定位置插入一个元素。 * * @param index   要插入元素的位置 * @param element 要插入的元素 * @throws IndexOutOfBoundsException 如果索引超出范围，则抛出此异常 *&#x2F;public void add(int index, E element) {    rangeCheckForAdd(index); &#x2F;&#x2F; 检查索引是否越界    ensureCapacityInternal(size + 1);  &#x2F;&#x2F; 确保容量足够，如果需要扩容就扩容    System.arraycopy(elementData, index, elementData, index + 1,            size - index); &#x2F;&#x2F; 将 index 及其后面的元素向后移动一位    elementData[index] &#x3D; element; &#x2F;&#x2F; 将元素插入到指定位置    size++; &#x2F;&#x2F; 元素个数加一}
 add(int index, E element)方法会调用到一个非常重要的本地方法 System.arraycopy() ，它会对数组进行复制（要插入位置上的元素往后复制）。
 来细品一下。
 这是 arraycopy() 的语法：
1System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length);
 在 ArrayList.add(int index, E element) 方法中，具体用法如下：
1System.arraycopy(elementData, index, elementData, index + 1, size - index);

elementData：表示要复制的源数组，即 ArrayList 中的元素数组。
index：表示源数组中要复制的起始位置，即需要将 index 及其后面的元素向后移动一位。
elementData：表示要复制到的目标数组，即 ArrayList 中的元素数组。
index + 1：表示目标数组中复制的起始位置，即将 index 及其后面的元素向后移动一位后，应该插入到的位置。
size - index：表示要复制的元素个数，即需要将 index 及其后面的元素向后移动一位，需要移动的元素个数为 size - index。
“三妹，注意看，我画幅图来表示下。”我认真地做起了图。



05、更新 ArrayList 中的元素 
 “二哥，那怎么更新 ArrayList 中的元素呢？”三妹继续问。
 可以使用 set() 方法来更改 ArrayList 中的元素，需要提供下标和新元素。
1alist.set(0, &quot;沉默王四&quot;);
 假设原来 0 位置上的元素为“沉默王三”，现在可以将其更新为“沉默王四”。
 来看一下 set() 方法的源码：
1234567891011121314&#x2F;** * 用指定元素替换指定位置的元素。 * * @param index   要替换的元素的索引 * @param element 要存储在指定位置的元素 * @return 先前在指定位置的元素 * @throws IndexOutOfBoundsException 如果索引超出范围，则抛出此异常 *&#x2F;public E set(int index, E element) {    rangeCheck(index); &#x2F;&#x2F; 检查索引是否越界    E oldValue &#x3D; elementData(index); &#x2F;&#x2F; 获取原来在指定位置上的元素    elementData[index] &#x3D; element; &#x2F;&#x2F; 将新元素替换到指定位置上    return oldValue; &#x2F;&#x2F; 返回原来在指定位置上的元素}
该方法会先对指定的下标进行检查，看是否越界，然后替换新值并返回旧值。
06、删除 ArrayList 中的元素 
“二哥，那怎么删除 ArrayList 中的元素呢？”三妹继续问。
remove(int index) 方法用于删除指定下标位置上的元素， remove(Object o) 方法用于删除指定值的元素。
12alist.remove(1);alist.remove(&quot;沉默王四&quot;);
先来看 remove(int index) 方法的源码：
1234567891011121314151617&#x2F;** * 删除指定位置的元素。 * * @param index 要删除的元素的索引 * @return 先前在指定位置的元素 * @throws IndexOutOfBoundsException 如果索引超出范围，则抛出此异常 *&#x2F;public E remove(int index) {    rangeCheck(index); &#x2F;&#x2F; 检查索引是否越界    E oldValue &#x3D; elementData(index); &#x2F;&#x2F; 获取要删除的元素    int numMoved &#x3D; size - index - 1; &#x2F;&#x2F; 计算需要移动的元素个数    if (numMoved &gt; 0) &#x2F;&#x2F; 如果需要移动元素，就用 System.arraycopy 方法实现        System.arraycopy(elementData, index+1, elementData, index,                numMoved);    elementData[--size] &#x3D; null; &#x2F;&#x2F; 将数组末尾的元素置为 null，让 GC 回收该元素占用的空间    return oldValue; &#x2F;&#x2F; 返回被删除的元素}
需要注意的是，在 ArrayList 中，删除元素时，需要将删除位置后面的元素向前移动一位，以填补删除位置留下的空缺。如果需要移动元素，则需要使用 System.arraycopy 方法将删除位置后面的元素向前移动一位。最后，将数组末尾的元素置为 null，以便让垃圾回收机制回收该元素占用的空间。
再来看 remove(Object o) 方法的源码：
12345678910111213141516171819202122&#x2F;** * 删除列表中第一次出现的指定元素（如果存在）。 * * @param o 要删除的元素 * @return 如果列表包含指定元素，则返回 true；否则返回 false *&#x2F;public boolean remove(Object o) {    if (o &#x3D;&#x3D; null) { &#x2F;&#x2F; 如果要删除的元素是 null        for (int index &#x3D; 0; index &lt; size; index++) &#x2F;&#x2F; 遍历列表            if (elementData[index] &#x3D;&#x3D; null) { &#x2F;&#x2F; 如果找到了 null 元素                fastRemove(index); &#x2F;&#x2F; 调用 fastRemove 方法快速删除元素                return true; &#x2F;&#x2F; 返回 true，表示成功删除元素            }    } else { &#x2F;&#x2F; 如果要删除的元素不是 null        for (int index &#x3D; 0; index &lt; size; index++) &#x2F;&#x2F; 遍历列表            if (o.equals(elementData[index])) { &#x2F;&#x2F; 如果找到了要删除的元素                fastRemove(index); &#x2F;&#x2F; 调用 fastRemove 方法快速删除元素                return true; &#x2F;&#x2F; 返回 true，表示成功删除元素            }    }    return false; &#x2F;&#x2F; 如果找不到要删除的元素，则返回 false}
 该方法通过遍历的方式找到要删除的元素，null 的时候使用 &#x3D;&#x3D; 操作符判断，非 null 的时候使用 equals() 方法，然后调用fastRemove() 方法。
 注意：

有相同元素时，只会删除第一个。
判断两个元素是否相等，可以参考Java如何判断两个字符串是否相等
继续往后面跟，来看一下 fastRemove() 方法：


123456789101112&#x2F;** * 快速删除指定位置的元素。 * * @param index 要删除的元素的索引 *&#x2F;private void fastRemove(int index) {    int numMoved &#x3D; size - index - 1; &#x2F;&#x2F; 计算需要移动的元素个数    if (numMoved &gt; 0) &#x2F;&#x2F; 如果需要移动元素，就用 System.arraycopy 方法实现        System.arraycopy(elementData, index+1, elementData, index,                numMoved);    elementData[--size] &#x3D; null; &#x2F;&#x2F; 将数组末尾的元素置为 null，让 GC 回收该元素占用的空间}
 同样是调用 System.arraycopy() 方法对数组进行复制和移动。
 “三妹，注意看，我画幅图来表示下。”我认真地做起了图。

 07、查找 ArrayList 中的元素 
 “二哥，那怎么查找 ArrayList 中的元素呢？”三妹继续问。
 如果要正序查找一个元素，可以使用 indexOf() 方法；如果要倒序查找一个元素，可以使用 lastIndexOf() 方法。
12alist.indexOf(&quot;沉默王二&quot;);alist.lastIndexOf(&quot;沉默王二&quot;);
 来看一下 indexOf() 方法的源码：
12345678910111213141516171819&#x2F;** * 返回指定元素在列表中第一次出现的位置。 * 如果列表不包含该元素，则返回 -1。 * * @param o 要查找的元素 * @return 指定元素在列表中第一次出现的位置；如果列表不包含该元素，则返回 -1 *&#x2F;public int indexOf(Object o) {    if (o &#x3D;&#x3D; null) { &#x2F;&#x2F; 如果要查找的元素是 null        for (int i &#x3D; 0; i &lt; size; i++) &#x2F;&#x2F; 遍历列表            if (elementData[i]&#x3D;&#x3D;null) &#x2F;&#x2F; 如果找到了 null 元素                return i; &#x2F;&#x2F; 返回元素的索引    } else { &#x2F;&#x2F; 如果要查找的元素不是 null        for (int i &#x3D; 0; i &lt; size; i++) &#x2F;&#x2F; 遍历列表            if (o.equals(elementData[i])) &#x2F;&#x2F; 如果找到了要查找的元素                return i; &#x2F;&#x2F; 返回元素的索引    }    return -1; &#x2F;&#x2F; 如果找不到要查找的元素，则返回 -1}
 如果元素为 null 的时候使用“&#x3D;&#x3D;”操作符，否则使用 equals() 方法。
 lastIndexOf() 方法和 indexOf() 方法类似，不过遍历的时候从最后开始。
12345678910111213141516171819&#x2F;** * 返回指定元素在列表中最后一次出现的位置。 * 如果列表不包含该元素，则返回 -1。 * * @param o 要查找的元素 * @return 指定元素在列表中最后一次出现的位置；如果列表不包含该元素，则返回 -1 *&#x2F;public int lastIndexOf(Object o) {    if (o &#x3D;&#x3D; null) { &#x2F;&#x2F; 如果要查找的元素是 null        for (int i &#x3D; size-1; i &gt;&#x3D; 0; i--) &#x2F;&#x2F; 从后往前遍历列表            if (elementData[i]&#x3D;&#x3D;null) &#x2F;&#x2F; 如果找到了 null 元素                return i; &#x2F;&#x2F; 返回元素的索引    } else { &#x2F;&#x2F; 如果要查找的元素不是 null        for (int i &#x3D; size-1; i &gt;&#x3D; 0; i--) &#x2F;&#x2F; 从后往前遍历列表            if (o.equals(elementData[i])) &#x2F;&#x2F; 如果找到了要查找的元素                return i; &#x2F;&#x2F; 返回元素的索引    }    return -1; &#x2F;&#x2F; 如果找不到要查找的元素，则返回 -1}
 contains() 方法可以判断 ArrayList 中是否包含某个元素，其内部就是通过 indexOf() 方法实现的：
123public boolean contains(Object o) {    return indexOf(o) &gt;&#x3D; 0;}
 08、二分查找法 
 如果 ArrayList 中的元素是经过排序的，就可以使用二分查找法，效率更快。
 Collections 类的 sort() 方法可以对 ArrayList 进行排序，该方法会按照字母顺序对 String 类型的列表进行排序。如果是自定义类型的列表，还可以指定 Comparator 进行排序。
 这里先简单地了解一下，后面会详细地讲。
1234567List&lt;String&gt; copy &#x3D; new ArrayList&lt;&gt;(alist);copy.add(&quot;a&quot;);copy.add(&quot;c&quot;);copy.add(&quot;b&quot;);copy.add(&quot;d&quot;);Collections.sort(copy);System.out.println(copy);
 输出结果如下所示：
1[a, b, c, d]
 排序后就可以使用二分查找法了：
1int index &#x3D; Collections.binarySearch(copy, &quot;b&quot;);
09、ArrayList增删改查时的时间复杂度 
 “最后，三妹，我们来简单总结一下 ArrayList 的时间复杂度吧，方便后面学习 LinkedList 时对比。”我喝了一口水后补充道。
1）查询 
 时间复杂度为 O(1)，因为 ArrayList 内部使用数组来存储元素，所以可以直接根据索引来访问元素。
123456789101112131415161718192021&#x2F;** * 返回列表中指定位置的元素。 * * @param index 要返回的元素的索引 * @return 列表中指定位置的元素 * @throws IndexOutOfBoundsException 如果索引超出范围（index &lt; 0 || index &gt;&#x3D; size()） *&#x2F;public E get(int index) {    rangeCheck(index); &#x2F;&#x2F; 检查索引是否合法    return elementData(index); &#x2F;&#x2F; 调用 elementData 方法获取元素}&#x2F;** * 返回列表中指定位置的元素。 * 此方法不进行边界检查，因此只应由内部方法和迭代器调用。 * * @param index 要返回的元素的索引 * @return 列表中指定位置的元素 *&#x2F;E elementData(int index) {    return (E) elementData[index]; &#x2F;&#x2F; 返回指定索引位置上的元素}
 2）插入 
 添加一个元素（调用 add() 方法时）的时间复杂度最好情况为 O(1)，最坏情况为 O(n)。

如果在列表末尾添加元素，时间复杂度为 O(1)。
如果要在列表的中间或开头插入元素，则需要将插入位置之后的元素全部向后移动一位，时间复杂度为 O(n)。

3）删除 
 删除一个元素（调用 remove(Object) 方法时）的时间复杂度最好情况 O(1)，最坏情况 O(n)。

如果要删除列表末尾的元素，时间复杂度为 O(1)。
如果要删除列表中间或开头的元素，则需要将删除位置之后的元素全部向前移动一位，时间复杂度为 O(n)。
4）修改 
修改一个元素（调用 set()方法时）与查询操作类似，可以直接根据索引来访问元素，时间复杂度为 O(1)。


1234567891011121314&#x2F;** * 用指定元素替换列表中指定位置的元素。 * * @param index 要替换元素的索引 * @param element 要放入列表中的元素 * @return 原来在指定位置上的元素 * @throws IndexOutOfBoundsException 如果索引超出范围（index &lt; 0 || index &gt;&#x3D; size()） *&#x2F;public E set(int index, E element) {    rangeCheck(index); &#x2F;&#x2F; 检查索引是否合法    E oldValue &#x3D; elementData(index); &#x2F;&#x2F; 获取原来在指定位置上的元素    elementData[index] &#x3D; element; &#x2F;&#x2F; 将指定位置上的元素替换为新元素    return oldValue; &#x2F;&#x2F; 返回原来在指定位置上的元素}
10、总结 
 ArrayList，如果有个中文名的话，应该叫动态数组，也就是可增长的数组，可调整大小的数组。动态数组克服了静态数组的限制，静态数组的容量是固定的，只能在首次创建的时候指定。而动态数组会随着元素的增加自动调整大小，更符合实际的开发需求。
 学习集合框架，ArrayList 是第一课，也是新手进阶的重要一课。要想完全掌握 ArrayList，扩容这个机制是必须得掌握，也是面试中经常考察的一个点。
 要想掌握扩容机制，就必须得读源码，也就肯定会遇到 oldCapacity &gt;&gt; 1 ，有些初学者会选择跳过，虽然不影响整体上的学习，但也错过了一个精进的机会。
 计算机内部是如何表示十进制数的，右移时又发生了什么，静下心来去研究一下，你就会发现，哦，原来这么有趣呢？
 “好了，三妹，这一节我们就学到这里，收工！”
4.4 LinkedList详解（附源码） 这篇换个表达方式，一起来欣赏。
 大家好，我是 LinkedList，和 ArrayList 是同门师兄弟，但我俩练的内功却完全不同。师兄练的是动态数组，我练的是链表。
 问大家一个问题，知道我为什么要练链表这门内功吗？
 举个例子来讲吧，假如你们手头要管理一推票据，可能有一张，也可能有一亿张。
 该怎么办呢？
 申请一个 10G 的大数组等着？那万一票据只有 100 张呢？
 申请一个默认大小的数组，随着数据量的增大扩容？要知道扩容是需要重新复制数组的，很耗时间。
 关键是，数组还有一个弊端就是，假如现在有 500 万张票据，现在要从中间删除一个票据，就需要把 250 万张票据往前移动一格。
 遇到这种情况的时候，我师兄几乎情绪崩溃，难受的要命。师父不忍心看到师兄这样痛苦，于是打我进入师门那一天，就强迫我练链表这门内功，一开始我很不理解，害怕师父偏心，不把师门最厉害的内功教我。
 直到有一天，我亲眼目睹师兄差点因为移动数据而走火入魔，我才明白师父的良苦用心。从此以后，我苦练“链表”这门内功，取得了显著的进步，师父和师兄都夸我有天赋。
 链表这门内功大致分为三个层次：

第一层叫做“单向链表”，我只有一个后指针，指向下一个数据；
第二层叫做“双向链表”，我有两个指针，后指针指向下一个数据，前指针指向上一个数据。
第三层叫做“二叉树”，把后指针去掉，换成左右指针。
但我现在的功力还达不到第三层，不过师父说我有这个潜力，练成神功是早晚的事。


01、LinkedList的内功心法 
 好了，经过我这么样的一个剖白后，大家对我应该已经不陌生了。那么接下来，我给大家展示一下我的内功心法。
 我的内功心法主要是一个私有的静态内部类，叫 Node，也就是节点。
1234567891011121314151617181920&#x2F;** * 链表中的节点类。 *&#x2F;private static class Node&lt;E&gt; {    E item; &#x2F;&#x2F; 节点中存储的元素    Node&lt;E&gt; next; &#x2F;&#x2F; 指向下一个节点的指针    Node&lt;E&gt; prev; &#x2F;&#x2F; 指向上一个节点的指针    &#x2F;**     * 构造一个新的节点。     *     * @param prev 前一个节点     * @param element 节点中要存储的元素     * @param next 后一个节点     *&#x2F;    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) {        this.item &#x3D; element; &#x2F;&#x2F; 存储元素        this.next &#x3D; next; &#x2F;&#x2F; 设置下一个节点        this.prev &#x3D; prev; &#x2F;&#x2F; 设置上一个节点    }}
 它由三部分组成：

节点上的元素
下一个节点
上一个节点
我画幅图给你们展示下吧。




对于第一个节点来说，prev 为 null；
对于最后一个节点来说，next 为 null；
其余的节点呢，prev 指向前一个，next 指向后一个。
我的内功心法就这么简单，其实我早已经牢记在心了。但师父叮嘱我，每天早上醒来的时候，每天晚上睡觉的时候，一定要默默地背诵一遍。虽然我有些厌烦，但我对师父的教诲从来都是言听计从。
02、LinkedList的招式 
和师兄 ArrayList 一样，我的招式也无外乎“增删改查”这 4 种。在此之前，我们都必须得初始化。
师兄在初始化的时候可以指定大小，也可以不指定，等到添加第一个元素的时候进行第一次扩容。而我，没有大小，只要内存够大，我就可以无穷大。


1）招式一：增 
  可以调用 add 方法添加元素：
123list.add(&quot;沉默王二&quot;);list.add(&quot;沉默王三&quot;);list.add(&quot;沉默王四&quot;);
  add 方法内部其实调用的是 linkLast 方法：
12345678910&#x2F;** * 将指定的元素添加到列表的尾部。 * * @param e 要添加到列表的元素 * @return 始终为 true（根据 Java 集合框架规范） *&#x2F;public boolean add(E e) {    linkLast(e); &#x2F;&#x2F; 在列表的尾部添加元素    return true; &#x2F;&#x2F; 添加元素成功，返回 true}
  linkLast，顾名思义，就是在链表的尾部添加元素：
12345678910111213141516&#x2F;** * 在列表的尾部添加指定的元素。 * * @param e 要添加到列表的元素 *&#x2F;void linkLast(E e) {    final Node&lt;E&gt; l &#x3D; last; &#x2F;&#x2F; 获取链表的最后一个节点    final Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(l, e, null); &#x2F;&#x2F; 创建一个新的节点，并将其设置为链表的最后一个节点    last &#x3D; newNode; &#x2F;&#x2F; 将新的节点设置为链表的最后一个节点    if (l &#x3D;&#x3D; null) &#x2F;&#x2F; 如果链表为空，则将新节点设置为头节点        first &#x3D; newNode;    else        l.next &#x3D; newNode; &#x2F;&#x2F; 否则将新节点链接到链表的尾部    size++; &#x2F;&#x2F; 增加链表的元素个数}

添加第一个元素的时候，first 和 last 都为 null。
然后新建一个节点 newNode，它的 prev 和 next 也为 null。
然后把 last 和 first 都赋值为 newNode。
此时还不能称之为链表，因为前后节点都是断裂的。




添加第二个元素的时候，first 和 last 都指向的是第一个节点。
然后新建一个节点 newNode，它的 prev 指向的是第一个节点，next 为 null。
然后把第一个节点的 next 赋值为 newNode。
此时的链表还不完整。




添加第三个元素的时候，first 指向的是第一个节点，last 指向的是最后一个节点。
然后新建一个节点 newNode，它的 prev 指向的是第二个节点，next 为 null。
然后把第二个节点的 next 赋值为 newNode。
此时的链表已经完整了。
我这个增的招式，还可以演化成另外两个版本：

addFirst() 方法将元素添加到第一位；

addLast() 方法将元素添加到末尾。
addFirst 内部其实调用的是 linkFirst：


12345678&#x2F;** * 在列表的开头添加指定的元素。 * * @param e 要添加到列表的元素 *&#x2F;public void addFirst(E e) {    linkFirst(e); &#x2F;&#x2F; 在列表的开头添加元素}
 linkFirst 负责把新的节点设为 first，并将新的 first 的 next 更新为之前的 first。
12345678910111213141516&#x2F;** * 在列表的开头添加指定的元素。 * * @param e 要添加到列表的元素 *&#x2F;private void linkFirst(E e) {    final Node&lt;E&gt; f &#x3D; first; &#x2F;&#x2F; 获取链表的第一个节点    final Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(null, e, f); &#x2F;&#x2F; 创建一个新的节点，并将其设置为链表的第一个节点    first &#x3D; newNode; &#x2F;&#x2F; 将新的节点设置为链表的第一个节点    if (f &#x3D;&#x3D; null) &#x2F;&#x2F; 如果链表为空，则将新节点设置为尾节点        last &#x3D; newNode;    else        f.prev &#x3D; newNode; &#x2F;&#x2F; 否则将新节点链接到链表的头部    size++; &#x2F;&#x2F; 增加链表的元素个数}
 addLast 的内核其实和 addFirst 差不多，内部调用的是 linkLast 方法，前面分析过了。
12345678910&#x2F;** * 在列表的尾部添加指定的元素。 * * @param e 要添加到列表的元素 * @return 始终为 true（根据 Java 集合框架规范） *&#x2F;public boolean addLast(E e) {    linkLast(e); &#x2F;&#x2F; 在列表的尾部添加元素    return true; &#x2F;&#x2F; 添加元素成功，返回 true}
2）招式二：删 
 我这个删的招式还挺多的：

remove() ：删除第一个节点
remove(int) ：删除指定位置的节点
remove(Object) ：删除指定元素的节点
removeFirst() ：删除第一个节点
removeLast() ：删除最后一个节点
remove() 内部调用的是 removeFirst() ，所以这两个招式的功效一样。
remove(int) 内部其实调用的是 unlink 方法。


1234567891011&#x2F;** * 删除指定位置上的元素。 * * @param index 要删除的元素的索引 * @return 从列表中删除的元素 * @throws IndexOutOfBoundsException 如果索引越界（index &lt; 0 || index &gt;&#x3D; size()） *&#x2F;public E remove(int index) {    checkElementIndex(index); &#x2F;&#x2F; 检查索引是否越界    return unlink(node(index)); &#x2F;&#x2F; 删除指定位置的节点，并返回节点的元素}
 unlink 方法其实很好理解，就是更新当前节点的 next 和 prev，然后把当前节点上的元素设为 null。
1234567891011121314151617181920212223242526&#x2F;** * 从链表中删除指定节点。 * * @param x 要删除的节点 * @return 从链表中删除的节点的元素 *&#x2F;E unlink(Node&lt;E&gt; x) {    final E element &#x3D; x.item; &#x2F;&#x2F; 获取要删除节点的元素    final Node&lt;E&gt; next &#x3D; x.next; &#x2F;&#x2F; 获取要删除节点的下一个节点    final Node&lt;E&gt; prev &#x3D; x.prev; &#x2F;&#x2F; 获取要删除节点的上一个节点    if (prev &#x3D;&#x3D; null) { &#x2F;&#x2F; 如果要删除节点是第一个节点        first &#x3D; next; &#x2F;&#x2F; 将链表的头节点设置为要删除节点的下一个节点    } else {        prev.next &#x3D; next; &#x2F;&#x2F; 将要删除节点的上一个节点指向要删除节点的下一个节点        x.prev &#x3D; null; &#x2F;&#x2F; 将要删除节点的上一个节点设置为空    }    if (next &#x3D;&#x3D; null) { &#x2F;&#x2F; 如果要删除节点是最后一个节点        last &#x3D; prev; &#x2F;&#x2F; 将链表的尾节点设置为要删除节点的上一个节点    } else {        next.prev &#x3D; prev; &#x2F;&#x2F; 将要删除节点的下一个节点指向要删除节点的上一个节点        x.next &#x3D; null; &#x2F;&#x2F; 将要删除节点的下一个节点设置为空    }    x.item &#x3D; null; &#x2F;&#x2F; 将要删除节点的元素设置为空    size--; &#x2F;&#x2F; 减少链表的元素个数    return element; &#x2F;&#x2F; 返回被删除节点的元素}
 remove(Object) 内部也调用了 unlink 方法，只不过在此之前要先找到元素所在的节点：
123456789101112131415161718192021222324&#x2F;** * 从链表中删除指定元素。 * * @param o 要从链表中删除的元素 * @return 如果链表包含指定元素，则返回 true；否则返回 false *&#x2F;public boolean remove(Object o) {    if (o &#x3D;&#x3D; null) { &#x2F;&#x2F; 如果要删除的元素为 null        for (Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; x &#x3D; x.next) { &#x2F;&#x2F; 遍历链表            if (x.item &#x3D;&#x3D; null) { &#x2F;&#x2F; 如果节点的元素为 null                unlink(x); &#x2F;&#x2F; 删除节点                return true; &#x2F;&#x2F; 返回 true 表示删除成功            }        }    } else { &#x2F;&#x2F; 如果要删除的元素不为 null        for (Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; x &#x3D; x.next) { &#x2F;&#x2F; 遍历链表            if (o.equals(x.item)) { &#x2F;&#x2F; 如果节点的元素等于要删除的元素                unlink(x); &#x2F;&#x2F; 删除节点                return true; &#x2F;&#x2F; 返回 true 表示删除成功            }        }    }    return false; &#x2F;&#x2F; 如果链表中不包含要删除的元素，则返回 false 表示删除失败}
 元素为 null 的时候，必须使用 &#x3D;&#x3D; 来判断；元素为非 null 的时候，要使用 equals 来判断。
 removeFirst 内部调用的是 unlinkFirst 方法：
12345678910111213&#x2F;** * 从链表中删除第一个元素并返回它。 * 如果链表为空，则抛出 NoSuchElementException 异常。 * * @return 从链表中删除的第一个元素 * @throws NoSuchElementException 如果链表为空 *&#x2F;public E removeFirst() {    final Node&lt;E&gt; f &#x3D; first; &#x2F;&#x2F; 获取链表的第一个节点    if (f &#x3D;&#x3D; null) &#x2F;&#x2F; 如果链表为空        throw new NoSuchElementException(); &#x2F;&#x2F; 抛出 NoSuchElementException 异常    return unlinkFirst(f); &#x2F;&#x2F; 调用 unlinkFirst 方法删除第一个节点并返回它的元素}
 unlinkFirst 负责的就是把第一个节点毁尸灭迹，并且捎带把后一个节点的 prev 设为 null。
12345678910111213141516171819&#x2F;** * 删除链表中的第一个节点并返回它的元素。 * * @param f 要删除的第一个节点 * @return 被删除节点的元素 *&#x2F;private E unlinkFirst(Node&lt;E&gt; f) {    final E element &#x3D; f.item; &#x2F;&#x2F; 获取要删除的节点的元素    final Node&lt;E&gt; next &#x3D; f.next; &#x2F;&#x2F; 获取要删除的节点的下一个节点    f.item &#x3D; null; &#x2F;&#x2F; 将要删除的节点的元素设置为 null    f.next &#x3D; null; &#x2F;&#x2F; 将要删除的节点的下一个节点设置为 null    first &#x3D; next; &#x2F;&#x2F; 将链表的头节点设置为要删除的节点的下一个节点    if (next &#x3D;&#x3D; null) &#x2F;&#x2F; 如果链表只有一个节点        last &#x3D; null; &#x2F;&#x2F; 将链表的尾节点设置为 null    else        next.prev &#x3D; null; &#x2F;&#x2F; 将要删除节点的下一个节点的前驱设置为 null    size--; &#x2F;&#x2F; 减少链表的大小    return element; &#x2F;&#x2F; 返回被删除节点的元素}
 3）招式三：改 
 可以调用 set() 方法来更新元素：
1list.set(0, &quot;沉默王五&quot;);
 来看一下 set() 方法：
123456789101112131415&#x2F;** * 将链表中指定位置的元素替换为指定元素，并返回原来的元素。 * * @param index 要替换元素的位置（从 0 开始） * @param element 要插入的元素 * @return 替换前的元素 * @throws IndexOutOfBoundsException 如果索引超出范围（index &lt; 0 || index &gt;&#x3D; size()） *&#x2F;public E set(int index, E element) {    checkElementIndex(index); &#x2F;&#x2F; 检查索引是否超出范围    Node&lt;E&gt; x &#x3D; node(index); &#x2F;&#x2F; 获取要替换的节点    E oldVal &#x3D; x.item; &#x2F;&#x2F; 获取要替换节点的元素    x.item &#x3D; element; &#x2F;&#x2F; 将要替换的节点的元素设置为指定元素    return oldVal; &#x2F;&#x2F; 返回替换前的元素}
 来看一下node方法：
123456789101112131415161718192021&#x2F;** * 获取链表中指定位置的节点。 * * @param index 节点的位置（从 0 开始） * @return 指定位置的节点 * @throws IndexOutOfBoundsException 如果索引超出范围（index &lt; 0 || index &gt;&#x3D; size()） *&#x2F;Node&lt;E&gt; node(int index) {    if (index &lt; (size &gt;&gt; 1)) { &#x2F;&#x2F; 如果索引在链表的前半部分        Node&lt;E&gt; x &#x3D; first;        for (int i &#x3D; 0; i &lt; index; i++) &#x2F;&#x2F; 从头节点开始向后遍历链表，直到找到指定位置的节点            x &#x3D; x.next;        return x; &#x2F;&#x2F; 返回指定位置的节点    } else { &#x2F;&#x2F; 如果索引在链表的后半部分        Node&lt;E&gt; x &#x3D; last;        for (int i &#x3D; size - 1; i &gt; index; i--) &#x2F;&#x2F; 从尾节点开始向前遍历链表，直到找到指定位置的节点            x &#x3D; x.prev;        return x; &#x2F;&#x2F; 返回指定位置的节点    }}
 size &gt;&gt; 1 ：也就是右移一位，相当于除以 2。对于计算机来说，移位比除法运算效率更高，因为数据在计算机内部都是以二进制存的。
 换句话说，node 方法会对下标进行一个初步判断，如果靠近前半截，就从下标 0 开始遍历；如果靠近后半截，就从末尾开始遍历，这样可以提高效率，最大能提高一半的效率。
 找到指定下标的节点就简单了，直接把原有节点的元素替换成新的节点就 OK 了，prev 和 next 都不用改动。
4）招式四：查 
 我这个查的招式可以分为两种：

indexOf(Object)：查找某个元素所在的位置
get(int)：查找某个位置上的元素
来看一下 indexOf 方法的源码。


1234567891011121314151617181920212223&#x2F;** * 返回链表中首次出现指定元素的位置，如果不存在该元素则返回 -1。 * * @param o 要查找的元素 * @return 首次出现指定元素的位置，如果不存在该元素则返回 -1 *&#x2F;public int indexOf(Object o) {    int index &#x3D; 0; &#x2F;&#x2F; 初始化索引为 0    if (o &#x3D;&#x3D; null) { &#x2F;&#x2F; 如果要查找的元素为 null        for (Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; x &#x3D; x.next) { &#x2F;&#x2F; 从头节点开始向后遍历链表            if (x.item &#x3D;&#x3D; null) &#x2F;&#x2F; 如果找到了要查找的元素                return index; &#x2F;&#x2F; 返回该元素的索引            index++; &#x2F;&#x2F; 索引加 1        }    } else { &#x2F;&#x2F; 如果要查找的元素不为 null        for (Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; x &#x3D; x.next) { &#x2F;&#x2F; 从头节点开始向后遍历链表            if (o.equals(x.item)) &#x2F;&#x2F; 如果找到了要查找的元素                return index; &#x2F;&#x2F; 返回该元素的索引            index++; &#x2F;&#x2F; 索引加 1        }    }    return -1; &#x2F;&#x2F; 如果没有找到要查找的元素，则返回 -1}
 get 方法的内核其实还是 node 方法，node 方法之前已经说明过了，这里略过。
1234public E get(int index) {    checkElementIndex(index);    return node(index).item;}
 其实，查这个招式还可以演化为其他的一些，比如说：

getFirst() 方法用于获取第一个元素；
getLast() 方法用于获取最后一个元素；
poll() 和 pollFirst() 方法用于删除并返回第一个元素（两个方法尽管名字不同，但方法体是完全相同的）；
pollLast() 方法用于删除并返回最后一个元素；
peekFirst() 方法用于返回但不删除第一个元素。

03、LinkedList 的挑战 
 说句实在话，我不是很喜欢和师兄 ArrayList 拿来比较，因为我们各自修炼的内功不同，没有孰高孰低。虽然师兄经常喊我一声师弟，但我们之间其实挺和谐的。但我知道，在外人眼里，同门师兄弟，总要一较高下的。
 比如说，我们俩在增删改查时候的时间复杂度。
 也许这就是命运吧，从我进入师门的那天起，这种争论就一直没有停息过。
 无论外人怎么看待我们，在我眼里，师兄永远都是一哥，我敬重他，他也愿意保护我。
 好戏在后头，等着瞧吧。
 我这里先简单聊一下，权当抛砖引玉。
 想象一下，你在玩一款游戏，游戏中有一个道具栏，你需要不断地往里面添加、删除道具。如果你使用的是我的师兄 ArrayList，那么每次添加、删除道具时都需要将后面的道具向后移动或向前移动，这样就会非常耗费时间。但是如果你使用的是我 LinkedList，那么只需要将新道具插入到链表中的指定位置，或者将要删除的道具从链表中删除即可，这样就可以快速地完成道具栏的更新。
 除了游戏中的道具栏，我 LinkedList 还可以用于实现 LRU（Least Recently Used）缓存淘汰算法。LRU 缓存淘汰算法是一种常用的缓存淘汰策略，它的基本思想是，当缓存空间不够时，优先淘汰最近最少使用的缓存数据。在实现 LRU 缓存淘汰算法时，你可以使用我LinkedList 来存储缓存数据，每次访问缓存数据时，将该数据从链表中删除并移动到链表的头部，这样链表的尾部就是最近最少使用的缓存数据，当缓存空间不够时，只需要将链表尾部的缓存数据淘汰即可。
4.5 ArrayList和LinkedList的区别 “终于，二哥，我们要聊 LinkedList 和 ArrayList 之间的差别了，我期待了很久。”三妹嘟囔着说。
 “其实经过前面两节的分析，差别已经很清晰了。”我喃喃道。
 “哥，你再说点吧，深挖一下，OK？”
 “好吧，那就让我们出发吧！”

PS：为了和前面两节的源码做适当的区分，这里采用的是 Java 11 的源码，请务必注意。但整体上差别很小。

 01、ArrayList 是如何实现的？ 
 ArrayList 实现了 List 接口，继承了 AbstractList 抽象类。

 底层是基于数组实现的，并且实现了动态扩容（当需要添加新元素时，如果 elementData 数组已满，则会自动扩容，新的容量将是原来的 1.5 倍），来看一下 ArrayList 的部分源码。
1234567public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable{    private static final int DEFAULT_CAPACITY &#x3D; 10; &#x2F;&#x2F; 默认容量为 10    transient Object[] elementData; &#x2F;&#x2F; 存储元素的数组，数组类型为 Object    private int size; &#x2F;&#x2F; 列表的大小，即列表中元素的个数}
 ArrayList 还实现了 RandomAccess 接口，这是一个标记接口：
12public interface RandomAccess {}
 内部是空的，标记“实现了这个接口的类支持快速（通常是固定时间）随机访问”。快速随机访问是什么意思呢？就是说不需要遍历，就可以通过下标（索引）直接访问到内存地址。而 LinkedList 没有实现该接口，表示它不支持高效的随机访问，需要通过遍历来访问元素。
123456789101112131415161718192021&#x2F;** * 返回列表中指定位置的元素。 * * @param index 要返回的元素的索引 * @return 列表中指定位置的元素 * @throws IndexOutOfBoundsException 如果索引越界（index &lt; 0 || index &gt;&#x3D; size()） *&#x2F;public E get(int index) {    Objects.checkIndex(index, size); &#x2F;&#x2F; 检查索引是否越界    return elementData(index); &#x2F;&#x2F; 调用 elementData 方法获取元素}&#x2F;** * 返回列表中指定位置的元素。 * 注意：该方法并没有检查索引是否越界，调用该方法前需要先检查索引是否越界。 * * @param index 要返回的元素的索引 * @return 列表中指定位置的元素 *&#x2F;E elementData(int index) {    return (E) elementData[index]; &#x2F;&#x2F; 强制类型转换，将 Object 类型转换为 E 类型}
 ArrayList 还实现了 Cloneable 接口，这表明 ArrayList 是支持拷贝的。ArrayList 内部的确也重写了 Object 类的 clone() 方法。
1234567891011121314151617&#x2F;** * 返回该列表的浅表副本。 * （元素本身不会被复制。） * * @return 该列表的副本 *&#x2F;public Object clone() {    try {        ArrayList&lt;?&gt; v &#x3D; (ArrayList&lt;?&gt;) super.clone(); &#x2F;&#x2F; 调用 Object 类的 clone 方法，得到一个浅表副本        v.elementData &#x3D; Arrays.copyOf(elementData, size); &#x2F;&#x2F; 复制 elementData 数组，创建一个新数组作为副本        v.modCount &#x3D; 0; &#x2F;&#x2F; 将 modCount 置为 0        return v; &#x2F;&#x2F; 返回副本    } catch (CloneNotSupportedException e) {        &#x2F;&#x2F; this shouldn&#39;t happen, since we are Cloneable        throw new InternalError(e);    }}
 ArrayList 还实现了 Serializable 接口，同样是一个标记接口：
12public interface Serializable {}
 内部也是空的，标记“实现了这个接口的类支持序列化”。序列化是什么意思呢？Java 的序列化是指，将对象转换成以字节序列的形式来表示，这些字节序中包含了对象的字段和方法。序列化后的对象可以被写到数据库、写到文件，也可用于网络传输。
 眼睛雪亮的小伙伴可能会注意到，ArrayList 中的关键字段 elementData 使用了 transient 关键字修饰，这个关键字的作用是，让它修饰的字段不被序列化。
 这不前后矛盾吗？一个类既然实现了 Serilizable 接口，肯定是想要被序列化的，对吧？那为什么保存关键数据的 elementData 又不想被序列化呢?
 这还得从 “ArrayList 是基于数组实现的”开始说起。大家都知道，数组是定长的，就是说，数组一旦声明了，长度（容量）就是固定的，不能像某些东西一样伸缩自如。这就很麻烦，数组一旦装满了，就不能添加新的元素进来了。
 ArrayList 不想像数组这样活着，它想能屈能伸，所以它实现了动态扩容。一旦在添加元素的时候，发现容量用满了 s &#x3D;&#x3D; elementData.length ，就按照原来数组的 1.5 倍（ oldCapacity &gt;&gt; 1 ）进行扩容。扩容之后，再将原有的数组复制到新分配的内存地址上 Arrays.copyOf(elementData, newCapacity) 。
 这部分源码我们在之前讲 ArrayList 的时候就已经讲的很清楚了，这里就一笔带过。
 动态扩容意味着什么？
 意味着数组的实际大小可能永远无法被填满的，总有多余出来空置的内存空间。
 比如说，默认的数组大小是 10，当添加第 11 个元素的时候，数组的长度扩容了 1.5 倍，也就是 15，意味着还有 4 个内存空间是闲置的，对吧？
 序列化的时候，如果把整个数组都序列化的话，是不是就多序列化了 4 个内存空间。当存储的元素数量非常非常多的时候，闲置的空间就非常非常大，序列化耗费的时间就会非常非常多。
 于是，ArrayList 做了一个愉快而又聪明的决定，内部提供了两个私有方法 writeObject 和 readObject 来完成序列化和反序列化。
1234567891011121314151617&#x2F;** * 将此列表实例的状态序列写入指定的 ObjectOutputStream。 * （即，保存这个列表实例到一个流中。） * * @param s 要写入的流 * @throws java.io.IOException 如果写入流时发生异常 *&#x2F;private void writeObject(java.io.ObjectOutputStream s)        throws java.io.IOException {    s.defaultWriteObject(); &#x2F;&#x2F; 写出对象的默认字段    &#x2F;&#x2F; Write out size as capacity for behavioral compatibility with clone()    s.writeInt(size); &#x2F;&#x2F; 写出 size    &#x2F;&#x2F; Write out all elements in the proper order.    for (int i&#x3D;0; i&lt;size; i++) {        s.writeObject(elementData[i]); &#x2F;&#x2F; 依次写出 elementData 数组中的元素    }}
 从 writeObject 方法的源码中可以看得出，它使用了 ArrayList 的实际大小 size 而不是数组的长度（ elementData.length ）来作为元素的上限进行序列化。
 此处应该有掌声啊！不是为我，为 Java 源码的作者们，他们真的是太厉害了，可以用两个词来形容他们——殚精竭虑、精益求精。
 666
 这是readObject方法的源码：
12345678910111213141516171819202122232425&#x2F;** * 从指定的 ObjectInputStream 中读取此列表实例的状态序列。 * （即，从流中恢复这个列表实例。） * * @param s 从中读取此列表实例的状态序列的流 * @throws java.io.IOException 如果读取流时发生异常 * @throws ClassNotFoundException 如果在读取流时找不到类 *&#x2F;private void readObject(java.io.ObjectInputStream s)        throws java.io.IOException, ClassNotFoundException {    elementData &#x3D; EMPTY_ELEMENTDATA; &#x2F;&#x2F; 初始化 elementData 数组为空数组    &#x2F;&#x2F; 读取默认字段    s.defaultReadObject();    &#x2F;&#x2F; 读取容量，这个值被忽略，因为在 ArrayList 中，容量和长度是两个不同的概念    s.readInt();    if (size &gt; 0) {        &#x2F;&#x2F; 分配一个新的 elementData 数组，大小为 size        ensureCapacityInternal(size);        Object[] a &#x3D; elementData;        &#x2F;&#x2F; 依次从输入流中读取元素，并将其存储在数组中        for (int i&#x3D;0; i&lt;size; i++) {            a[i] &#x3D; s.readObject(); &#x2F;&#x2F; 读取对象并存储在 elementData 数组中        }    }}
 02、LinkedList 是如何实现的？ 
 LinkedList 是一个继承自 AbstractSequentialList 的双向链表，因此它也可以被当作堆栈、队列或双端队列进行操作。

 来看一下部分源码：
123456789public class LinkedList&lt;E&gt;    extends AbstractSequentialList&lt;E&gt;    implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable{    transient int size &#x3D; 0; &#x2F;&#x2F; 非序列化字段，表示链表中的节点个数    transient Node&lt;E&gt; first; &#x2F;&#x2F; 非序列化字段，指向链表中的第一个节点    transient Node&lt;E&gt; last; &#x2F;&#x2F; 非序列化字段，指向链表中的最后一个节点    &#x2F;&#x2F; ...}
  LinkedList 内部定义了一个 Node 节点，它包含 3 个部分：元素内容 item，前引用 prev 和后引用 next。
 这个在讲 LinkedList 的时候也讲过了，这里略过。
 LinkedList 还实现了 Cloneable 接口，这表明 LinkedList 是支持拷贝的。
 LinkedList 还实现了 Serializable 接口，这表明 LinkedList 是支持序列化的。眼睛雪亮的小伙伴可能又注意到了，LinkedList 中的关键字段 size、first、last 都使用了 transient 关键字修饰，这不又矛盾了吗？到底是想序列化还是不想序列化？
 答案是 LinkedList 想按照自己的方式序列化，来看它自己实现的 writeObject() 方法：
12345678910private void writeObject(java.io.ObjectOutputStream s)        throws java.io.IOException {    &#x2F;&#x2F; 写入默认的序列化标记    s.defaultWriteObject();    &#x2F;&#x2F; 写入链表的节点个数    s.writeInt(size);    &#x2F;&#x2F; 按正确的顺序写入所有元素    for (LinkedList.Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; x &#x3D; x.next)        s.writeObject(x.item);}
 发现没？LinkedList 在序列化的时候只保留了元素的内容 item，并没有保留元素的前后引用。这样就节省了不少内存空间，对吧？
 那有些小伙伴可能就疑惑了，只保留元素内容，不保留前后引用，那反序列化的时候怎么办？
123456789101112131415161718192021private void readObject(java.io.ObjectInputStream s)        throws java.io.IOException, ClassNotFoundException {    &#x2F;&#x2F; 读取默认的序列化标记    s.defaultReadObject();    &#x2F;&#x2F; 读取链表的节点个数    int size &#x3D; s.readInt();    &#x2F;&#x2F; 按正确的顺序读取所有元素    for (int i &#x3D; 0; i &lt; size; i++)        linkLast((E)s.readObject()); &#x2F;&#x2F; 读取元素并将其添加到链表末尾}void linkLast(E e) {    final LinkedList.Node&lt;E&gt; l &#x3D; last;    final LinkedList.Node&lt;E&gt; newNode &#x3D; new LinkedList.Node&lt;&gt;(l, e, null);    last &#x3D; newNode; &#x2F;&#x2F; 将新节点作为链表尾节点    if (l &#x3D;&#x3D; null)        first &#x3D; newNode; &#x2F;&#x2F; 如果链表为空，将新节点作为链表头节点    else        l.next &#x3D; newNode; &#x2F;&#x2F; 否则将新节点链接到链表尾部    size++; &#x2F;&#x2F; 增加节点个数}
 注意 for 循环中的 linkLast() 方法，它可以把链表重新链接起来，这样就恢复了链表序列化之前的顺序。
 很妙，对吧？
 和 ArrayList 相比，LinkedList 没有实现 RandomAccess 接口，这是因为 LinkedList 存储数据的内存地址是不连续的，所以不支持随机访问。
03、新增元素时究竟谁快？ 
 前面我们已经从多个维度了解了 ArrayList 和 LinkedList 的实现原理和各自的特点。那接下来，我们就来聊聊 ArrayList 和 LinkedList 在新增元素时究竟谁快？
1）ArrayList 
 ArrayList 新增元素有两种情况，一种是直接将元素添加到数组末尾，一种是将元素插入到指定位置。
 添加到数组末尾的源码（这部分前面讲 ArrayList 的时候讲过了，这里再温故一下）：
12345678910public boolean add(E e) {    add(e, elementData, size);    return true;}private void add(E e, Object[] elementData, int s) {    if (s &#x3D;&#x3D; elementData.length)        elementData &#x3D; grow(); &#x2F;&#x2F; 扩容数组    elementData[s] &#x3D; e; &#x2F;&#x2F; 将元素添加到数组末尾    size &#x3D; s + 1; &#x2F;&#x2F; 增加元素个数}
 很简单，先判断是否需要扩容，然后直接通过索引将元素添加到末尾。
 插入到指定位置的源码：
123456789101112 public void add(int index, E element) {    rangeCheckForAdd(index); &#x2F;&#x2F; 检查插入位置是否越界    final int s; &#x2F;&#x2F; 当前元素个数    Object[] elementData; &#x2F;&#x2F; 元素数组    if ((s &#x3D; size) &#x3D;&#x3D; (elementData &#x3D; this.elementData).length) &#x2F;&#x2F; 如果数组已满，则扩容        elementData &#x3D; grow();    System.arraycopy(elementData, index,            elementData, index + 1,            s - index); &#x2F;&#x2F; 将插入位置后的元素向右移动一位    elementData[index] &#x3D; element; &#x2F;&#x2F; 将新元素插入到指定位置    size &#x3D; s + 1; &#x2F;&#x2F; 增加元素个数}
 先检查插入的位置是否在合理的范围之内，然后判断是否需要扩容，再把该位置以后的元素复制到新添加元素的位置之后，最后通过索引将元素添加到指定的位置。
2）LinkedList 
 LinkedList 新增元素也有两种情况，一种是直接将元素添加到队尾，一种是将元素插入到指定位置。
 添加到队尾的源码：
1234567891011121314public boolean add(E e) {    linkLast(e); &#x2F;&#x2F; 将元素添加到链表末尾    return true;}void linkLast(E e) {    final LinkedList.Node&lt;E&gt; l &#x3D; last; &#x2F;&#x2F; 获取链表的尾节点    final LinkedList.Node&lt;E&gt; newNode &#x3D; new LinkedList.Node&lt;&gt;(l, e, null); &#x2F;&#x2F; 创建新节点    last &#x3D; newNode; &#x2F;&#x2F; 将新节点作为链表的尾节点    if (l &#x3D;&#x3D; null)        first &#x3D; newNode; &#x2F;&#x2F; 如果链表为空，则将新节点作为链表的头节点    else        l.next &#x3D; newNode; &#x2F;&#x2F; 否则将新节点链接到链表的尾部    size++; &#x2F;&#x2F; 增加节点个数}
 先将队尾的节点 last 存放到临时变量 l 中，然后生成新的 Node 节点，并赋给 last，如果 l  为 null，说明是第一次添加，所以 first 为新的节点；否则将新的节点赋给之前 last 的 next。
 插入到指定位置的源码：
123456789101112131415161718192021222324252627282930public void add(int index, E element) {    checkPositionIndex(index); &#x2F;&#x2F; 检查插入位置是否越界    if (index &#x3D;&#x3D; size)        linkLast(element); &#x2F;&#x2F; 如果插入位置为链表末尾，则将元素添加到链表末尾    else        linkBefore(element, node(index)); &#x2F;&#x2F; 否则将元素插入到指定位置的前面的节点后面}LinkedList.Node&lt;E&gt; node(int index) {    if (index &lt; (size &gt;&gt; 1)) { &#x2F;&#x2F; 如果插入位置在链表前半部分，则从头节点开始查找        LinkedList.Node&lt;E&gt; x &#x3D; first;        for (int i &#x3D; 0; i &lt; index; i++)            x &#x3D; x.next;        return x;    } else { &#x2F;&#x2F; 否则从尾节点开始查找        LinkedList.Node&lt;E&gt; x &#x3D; last;        for (int i &#x3D; size - 1; i &gt; index; i--)            x &#x3D; x.prev;        return x;    }}void linkBefore(E e, LinkedList.Node&lt;E&gt; succ) {    final LinkedList.Node&lt;E&gt; pred &#x3D; succ.prev; &#x2F;&#x2F; 获取插入位置的前驱节点    final LinkedList.Node&lt;E&gt; newNode &#x3D; new LinkedList.Node&lt;&gt;(pred, e, succ); &#x2F;&#x2F; 创建新节点    succ.prev &#x3D; newNode; &#x2F;&#x2F; 将新节点链接到后继节点    if (pred &#x3D;&#x3D; null)        first &#x3D; newNode; &#x2F;&#x2F; 如果前驱节点为空，则将新节点作为头节点    else        pred.next &#x3D; newNode; &#x2F;&#x2F; 否则将新节点链接到前驱节点    size++; &#x2F;&#x2F; 增加节点个数}
 先检查插入的位置是否在合理的范围之内，然后判断插入的位置是否是队尾，如果是，添加到队尾；否则执行 linkBefore() 方法。
 在执行 linkBefore() 方法之前，会调用 node() 方法查找指定位置上的元素，这一步是需要遍历 LinkedList 的。如果插入的位置靠前前半段，就从队头开始往后找；否则从队尾往前找。也就是说，如果插入的位置越靠近 LinkedList 的中间位置，遍历所花费的时间就越多。
 找到指定位置上的元素（参数succ）之后，就开始执行 linkBefore() 方法，先将 succ 的前一个节点（prev）存放到临时变量 pred 中，然后生成新的 Node 节点（newNode），并将 succ 的前一个节点变更为 newNode，如果 pred 为 null，说明插入的是队头，所以 first 为新节点；否则将 pred 的后一个节点变更为 newNode。

 经过源码分析以后，你是不是在想：“好像 ArrayList 在新增元素的时候效率并不一定比 LinkedList 低啊！”
 当两者的起始长度是一样的情况下：

如果是从集合的头部新增元素，ArrayList 花费的时间应该比 LinkedList 多，因为需要对头部以后的元素进行复制。
我们来测试一下：


123456789101112131415161718192021222324252627public class ArrayListTest {    public static void addFromHeaderTest(int num) {        ArrayList&lt;String&gt; list &#x3D; new ArrayList&lt;String&gt;(num);        int i &#x3D; 0;        long timeStart &#x3D; System.currentTimeMillis();        while (i &lt; num) {            list.add(0, i + &quot;沉默王二&quot;);            i++;        }        long timeEnd &#x3D; System.currentTimeMillis();        System.out.println(&quot;ArrayList从集合头部位置新增元素花费的时间&quot; + (timeEnd - timeStart));    }} public class LinkedListTest {    public static void addFromHeaderTest(int num) {        LinkedList&lt;String&gt; list &#x3D; new LinkedList&lt;String&gt;();        int i &#x3D; 0;        long timeStart &#x3D; System.currentTimeMillis();        while (i &lt; num) {            list.addFirst(i + &quot;沉默王二&quot;);            i++;        }        long timeEnd &#x3D; System.currentTimeMillis();        System.out.println(&quot;LinkedList从集合头部位置新增元素花费的时间&quot; + (timeEnd - timeStart));    }}
 num 为 10000，代码实测后的时间如下所示：
12ArrayList从集合头部位置新增元素花费的时间595LinkedList从集合头部位置新增元素花费的时间15
 此时，ArrayList 花费的时间比 LinkedList 要多很多。

如果是从集合的中间位置新增元素，ArrayList 花费的时间搞不好要比 LinkedList 少，因为 LinkedList 需要遍历。
来看测试代码。


1234567891011121314151617181920212223242526272829public class ArrayListTest {    public static void addFromMidTest(int num) {        ArrayList&lt;String&gt; list &#x3D; new ArrayList&lt;String&gt;(num);        int i &#x3D; 0;        long timeStart &#x3D; System.currentTimeMillis();        while (i &lt; num) {            int temp &#x3D; list.size();            list.add(temp &#x2F; 2, i + &quot;沉默王二&quot;);            i++;        }        long timeEnd &#x3D; System.currentTimeMillis();        System.out.println(&quot;ArrayList从集合中间位置新增元素花费的时间&quot; + (timeEnd - timeStart));    }}public class LinkedListTest {    public static void addFromMidTest(int num) {        LinkedList&lt;String&gt; list &#x3D; new LinkedList&lt;String&gt;();        int i &#x3D; 0;        long timeStart &#x3D; System.currentTimeMillis();        while (i &lt; num) {            int temp &#x3D; list.size();            list.add(temp &#x2F; 2, i + &quot;沉默王二&quot;);            i++;        }        long timeEnd &#x3D; System.currentTimeMillis();        System.out.println(&quot;LinkedList从集合中间位置新增元素花费的时间&quot; + (timeEnd - timeStart));    }}
num 为 10000，代码实测后的时间如下所示：
12ArrayList从集合中间位置新增元素花费的时间16LinkedList从集合中间位置新增元素花费的时间114
ArrayList 花费的时间比 LinkedList 要少很多很多。

如果是从集合的尾部新增元素，ArrayList 花费的时间应该比 LinkedList 少，因为数组是一段连续的内存空间，也不需要复制数组；而链表需要创建新的对象，前后引用也要重新排列。

来看测试代码：
123456789101112131415161718192021222324252627public class LinkedListTest {    public static void addFromTailTest(int num) {        LinkedList&lt;String&gt; list &#x3D; new LinkedList&lt;String&gt;();        int i &#x3D; 0;        long timeStart &#x3D; System.currentTimeMillis();        while (i &lt; num) {            list.add(i + &quot;沉默王二&quot;);            i++;        }        long timeEnd &#x3D; System.currentTimeMillis();        System.out.println(&quot;LinkedList从集合尾部位置新增元素花费的时间&quot; + (timeEnd - timeStart));    }}public class ArrayListTest {    public static void addFromTailTest(int num) {        ArrayList&lt;String&gt; list &#x3D; new ArrayList&lt;String&gt;(num);        int i &#x3D; 0;        long timeStart &#x3D; System.currentTimeMillis();        while (i &lt; num) {            list.add(i + &quot;沉默王二&quot;);            i++;        }        long timeEnd &#x3D; System.currentTimeMillis();        System.out.println(&quot;ArrayList从集合尾部位置新增元素花费的时间&quot; + (timeEnd - timeStart));    }}
num 为 10000，代码实测后的时间如下所示：
12ArrayList从集合尾部位置新增元素花费的时间69LinkedList从集合尾部位置新增元素花费的时间193
ArrayList 花费的时间比 LinkedList 要少一些。
这样的结论和预期的是不是不太相符？ArrayList 在添加元素的时候如果不涉及到扩容，性能在两种情况下（中间位置新增元素、尾部新增元素）比 LinkedList 好很多，只有头部新增元素的时候比 LinkedList 差，因为数组复制的原因。
当然了，如果涉及到数组扩容的话，ArrayList 的性能就没那么可观了，因为扩容的时候也要复制数组。
04、删除元素时究竟谁快？ 
1）ArrayList 
ArrayList 删除元素的时候，有两种方式，一种是直接删除元素（ remove(Object) ），需要直先遍历数组，找到元素对应的索引；一种是按照索引删除元素（ remove(int) ）。
来看一下源码（其实前面也讲过了，这里温习一下）：
123456789101112131415161718192021222324252627public boolean remove(Object o) {    final Object[] es &#x3D; elementData; &#x2F;&#x2F; 获取数组元素    final int size &#x3D; this.size; &#x2F;&#x2F; 获取数组大小    int i &#x3D; 0;    found: {        if (o &#x3D;&#x3D; null) {            for (; i &lt; size; i++)                if (es[i] &#x3D;&#x3D; null)                    break found;        } else {            for (; i &lt; size; i++)                if (o.equals(es[i]))                    break found;        }        return false;    }    fastRemove(es, i); &#x2F;&#x2F; 调用 fastRemove 方法快速移除元素    return true;}public E remove(int index) {    Objects.checkIndex(index, size); &#x2F;&#x2F; 检查索引是否越界    final Object[] es &#x3D; elementData; &#x2F;&#x2F; 获取数组元素    oldValue &#x3D; (E) es[index]; &#x2F;&#x2F; 获取要删除的元素    fastRemove(es, index); &#x2F;&#x2F; 调用 fastRemove 方法快速移除元素    return oldValue; &#x2F;&#x2F; 返回被删除的元素}
本质上讲，两个方法是一样的，它们最后调用的都是 fastRemove(Object, int) 方法。
123456private void fastRemove(Object[] es, int i) {    final int newSize;    if ((newSize &#x3D; size - 1) &gt; i) &#x2F;&#x2F; 如果要删除的不是最后一个元素        System.arraycopy(es, i + 1, es, i, newSize - i); &#x2F;&#x2F; 将要删除元素后面的元素向前移动一位    es[size &#x3D; newSize] &#x3D; null; &#x2F;&#x2F; 将最后一个元素置为 null，帮助垃圾回收}
从源码可以看得出，只要删除的不是最后一个元素，都需要重新移动数组。删除的元素位置越靠前，代价就越大。
2）LinkedList 
LinkedList 删除元素的时候，有四种常用的方式：

remove(int) ，删除指定位置上的元素

1234public E remove(int index) {    checkElementIndex(index);    return unlink(node(index));}
先检查索引，再调用 node(int) 方法（ 前后半段遍历，和新增元素操作一样）找到节点 Node，然后调用 unlink(Node) 解除节点的前后引用，同时更新前节点的后引用和后节点的前引用：
1234567891011121314151617181920E unlink(Node&lt;E&gt; x) {    final E element &#x3D; x.item; &#x2F;&#x2F; 获取要删除的节点的元素    final Node&lt;E&gt; next &#x3D; x.next; &#x2F;&#x2F; 获取要删除的节点的后继节点    final Node&lt;E&gt; prev &#x3D; x.prev; &#x2F;&#x2F; 获取要删除的节点的前驱节点    if (prev &#x3D;&#x3D; null) { &#x2F;&#x2F; 如果要删除的节点是第一个节点        first &#x3D; next; &#x2F;&#x2F; 将头节点更新为要删除的节点的后继节点    } else {        prev.next &#x3D; next; &#x2F;&#x2F; 将要删除的节点的前驱节点的后继节点指向要删除的节点的后继节点        x.prev &#x3D; null; &#x2F;&#x2F; 将要删除的节点的前驱节点置为 null，帮助垃圾回收    }    if (next &#x3D;&#x3D; null) { &#x2F;&#x2F; 如果要删除的节点是最后一个节点        last &#x3D; prev; &#x2F;&#x2F; 将尾节点更新为要删除的节点的前驱节点    } else {        next.prev &#x3D; prev; &#x2F;&#x2F; 将要删除的节点的后继节点的前驱节点指向要删除的节点的前驱节点        x.next &#x3D; null; &#x2F;&#x2F; 将要删除的节点的后继节点置为 null，帮助垃圾回收    }    x.item &#x3D; null; &#x2F;&#x2F; 将要删除的节点的元素置为 null，帮助垃圾回收    size--; &#x2F;&#x2F; 将链表的长度减一    return element; &#x2F;&#x2F; 返回被删除的元素}

remove(Object) ，直接删除元素

123456789101112131415161718public boolean remove(Object o) {    if (o &#x3D;&#x3D; null) { &#x2F;&#x2F; 如果要删除的元素为 null        for (LinkedList.Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; x &#x3D; x.next) {            if (x.item &#x3D;&#x3D; null) { &#x2F;&#x2F; 如果找到了要删除的节点                unlink(x); &#x2F;&#x2F; 调用 unlink 方法删除指定节点                return true; &#x2F;&#x2F; 返回删除成功            }        }    } else {        for (LinkedList.Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; x &#x3D; x.next) {            if (o.equals(x.item)) { &#x2F;&#x2F; 如果找到了要删除的节点                unlink(x); &#x2F;&#x2F; 调用 unlink 方法删除指定节点                return true; &#x2F;&#x2F; 返回删除成功            }        }    }    return false; &#x2F;&#x2F; 没有找到要删除的节点，返回删除失败}
也是先前后半段遍历，找到要删除的元素后调用 unlink(Node) 。

removeFirst() ，删除第一个节点

12345678910111213141516171819public E removeFirst() {    final LinkedList.Node&lt;E&gt; f &#x3D; first;    if (f &#x3D;&#x3D; null)        throw new NoSuchElementException();    return unlinkFirst(f);}private E unlinkFirst(LinkedList.Node&lt;E&gt; f) {    final E element &#x3D; f.item; &#x2F;&#x2F; 获取要删除的节点的元素    final LinkedList.Node&lt;E&gt; next &#x3D; f.next; &#x2F;&#x2F; 获取要删除的节点的后继节点    f.item &#x3D; null; &#x2F;&#x2F; 将要删除的节点的元素置为 null，帮助垃圾回收    f.next &#x3D; null; &#x2F;&#x2F; 将要删除的节点的后继节点置为 null，帮助垃圾回收    first &#x3D; next; &#x2F;&#x2F; 将头节点更新为要删除的节点的后继节点    if (next &#x3D;&#x3D; null) &#x2F;&#x2F; 如果链表已经为空        last &#x3D; null; &#x2F;&#x2F; 将尾节点置为 null    else        next.prev &#x3D; null; &#x2F;&#x2F; 将要删除的节点的后继节点的前驱节点置为 null，帮助垃圾回收    size--; &#x2F;&#x2F; 将链表的长度减一    return element; &#x2F;&#x2F; 返回被删除的元素}
删除第一个节点就不需要遍历了，只需要把第二个节点更新为第一个节点即可。

removeLast() ，删除最后一个节点

删除最后一个节点和删除第一个节点类似，只需要把倒数第二个节点更新为最后一个节点即可。
可以看得出，LinkedList 在删除比较靠前和比较靠后的元素时，非常高效，但如果删除的是中间位置的元素，效率就比较低了。
这里就不再做代码测试了，感兴趣的话可以自己试试，结果和新增元素保持一致：

从集合头部删除元素时，ArrayList 花费的时间比 LinkedList 多很多；
从集合中间位置删除元素时，ArrayList 花费的时间比 LinkedList 少很多；
从集合尾部删除元素时，ArrayList 花费的时间比 LinkedList 少一点。

我本地的统计结果如下所示，可以作为参考：
123456ArrayList从集合头部位置删除元素花费的时间380LinkedList从集合头部位置删除元素花费的时间4ArrayList从集合中间位置删除元素花费的时间381LinkedList从集合中间位置删除元素花费的时间5922ArrayList从集合尾部位置删除元素花费的时间8LinkedList从集合尾部位置删除元素花费的时间12
05、遍历元素时究竟谁快？ 
1）ArrayList 
遍历 ArrayList 找到某个元素的话，通常有两种形式：

get(int) ，根据索引找元素

1234public E get(int index) {    Objects.checkIndex(index, size);    return elementData(index);}
由于 ArrayList 是由数组实现的，所以根据索引找元素非常的快，一步到位。

indexOf(Object) ，根据元素找索引

123456789101112131415161718192021public int indexOf(Object o) {    return indexOfRange(o, 0, size);} int indexOfRange(Object o, int start, int end) {    Object[] es &#x3D; elementData; &#x2F;&#x2F; 获取 ArrayList 中的元素数组    if (o &#x3D;&#x3D; null) { &#x2F;&#x2F; 如果要查找的元素为 null        for (int i &#x3D; start; i &lt; end; i++) {            if (es[i] &#x3D;&#x3D; null) { &#x2F;&#x2F; 如果找到了要查找的元素                return i; &#x2F;&#x2F; 返回元素在 ArrayList 中的索引            }        }    } else {        for (int i &#x3D; start; i &lt; end; i++) {            if (o.equals(es[i])) { &#x2F;&#x2F; 如果找到了要查找的元素                return i; &#x2F;&#x2F; 返回元素在 ArrayList 中的索引            }        }    }    return -1; &#x2F;&#x2F; 没有找到要查找的元素，返回 -1}
根据元素找索引的话，就需要遍历整个数组了，从头到尾依次找。
2）LinkedList 
遍历 LinkedList 找到某个元素的话，通常也有两种形式：

get(int) ，找指定位置上的元素

1234public E get(int index) {    checkElementIndex(index);    return node(index).item;}
既然需要调用 node(int) 方法，就意味着需要前后半段遍历了。

indexOf(Object) ，找元素所在的位置

1234567891011121314151617public int indexOf(Object o) {    int index &#x3D; 0; &#x2F;&#x2F; 初始化索引为 0    if (o &#x3D;&#x3D; null) { &#x2F;&#x2F; 如果要查找的元素为 null        for (LinkedList.Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; x &#x3D; x.next) { &#x2F;&#x2F; 从头节点开始遍历链表            if (x.item &#x3D;&#x3D; null) &#x2F;&#x2F; 如果找到了要查找的元素                return index; &#x2F;&#x2F; 返回元素在 LinkedList 中的索引            index++; &#x2F;&#x2F; 索引加一        }    } else {        for (LinkedList.Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; x &#x3D; x.next) { &#x2F;&#x2F; 从头节点开始遍历链表            if (o.equals(x.item)) &#x2F;&#x2F; 如果找到了要查找的元素                return index; &#x2F;&#x2F; 返回元素在 LinkedList 中的索引            index++; &#x2F;&#x2F; 索引加一        }    }    return -1; &#x2F;&#x2F; 没有找到要查找的元素，返回 -1}
需要遍历整个链表，和 ArrayList 的 indexOf() 类似。
那在我们对集合遍历的时候，通常有两种做法，一种是使用 for 循环，一种是使用迭代器（Iterator）。
如果使用的是 for 循环，可想而知 LinkedList 在 get 的时候性能会非常差，因为每一次外层的 for 循环，都要执行一次 node(int) 方法进行前后半段的遍历。
1234567891011121314LinkedList.Node&lt;E&gt; node(int index) {    &#x2F;&#x2F; assert isElementIndex(index);    if (index &lt; (size &gt;&gt; 1)) { &#x2F;&#x2F; 如果要查找的元素在链表的前半部分        LinkedList.Node&lt;E&gt; x &#x3D; first; &#x2F;&#x2F; 从头节点开始遍历链表        for (int i &#x3D; 0; i &lt; index; i++) &#x2F;&#x2F; 循环查找元素            x &#x3D; x.next;        return x; &#x2F;&#x2F; 返回要查找的元素节点    } else { &#x2F;&#x2F; 如果要查找的元素在链表的后半部分        LinkedList.Node&lt;E&gt; x &#x3D; last; &#x2F;&#x2F; 从尾节点开始遍历链表        for (int i &#x3D; size - 1; i &gt; index; i--) &#x2F;&#x2F; 循环查找元素            x &#x3D; x.prev;        return x; &#x2F;&#x2F; 返回要查找的元素节点    }}
那如果使用的是迭代器呢？
1234LinkedList&lt;String&gt; list &#x3D; new LinkedList&lt;String&gt;();for (Iterator&lt;String&gt; it &#x3D; list.iterator(); it.hasNext();) {    it.next();}
迭代器只会调用一次 node(int) 方法，在执行 list.iterator() 的时候：先调用 AbstractSequentialList 类的 iterator() 方法，再调用 AbstractList 类的 listIterator() 方法，再调用 LinkedList 类的 listIterator(int) 方法，如下图所示。

最后返回的是 LinkedList 类的内部私有类 ListItr 对象：
12345678910111213141516171819202122232425262728public ListIterator&lt;E&gt; listIterator(int index) {    checkPositionIndex(index); &#x2F;&#x2F; 检查索引是否在有效范围内    return new LinkedList.ListItr(index); &#x2F;&#x2F; 创建一个新的 ListItr 对象并返回}private class ListItr implements ListIterator&lt;E&gt; {    private LinkedList.Node&lt;E&gt; lastReturned; &#x2F;&#x2F; 上一个已返回的节点    private LinkedList.Node&lt;E&gt; next; &#x2F;&#x2F; 下一个节点    private int nextIndex; &#x2F;&#x2F; 下一个节点的索引    private int expectedModCount &#x3D; modCount; &#x2F;&#x2F; 链表被修改的次数    ListItr(int index) {        &#x2F;&#x2F; assert isPositionIndex(index);        next &#x3D; (index &#x3D;&#x3D; size) ? null : node(index); &#x2F;&#x2F; 如果 index 等于 size，next 为 null，否则返回 node(index)        nextIndex &#x3D; index; &#x2F;&#x2F; 设置 nextIndex 为 index    }    public boolean hasNext() {        return nextIndex &lt; size; &#x2F;&#x2F; 如果下一个节点的索引小于链表的长度，返回 true，否则返回 false    }    public E next() {        checkForComodification(); &#x2F;&#x2F; 检查链表是否已经被修改        if (!hasNext()) &#x2F;&#x2F; 如果没有下一个节点，抛出 NoSuchElementException 异常            throw new NoSuchElementException();        lastReturned &#x3D; next; &#x2F;&#x2F; 将下一个节点设置为上一个已返回节点        next &#x3D; next.next; &#x2F;&#x2F; 将下一个节点设置为当前节点的下一个节点        nextIndex++; &#x2F;&#x2F; 将下一个节点的索引增加 1        return lastReturned.item; &#x2F;&#x2F; 返回上一个已返回节点的元素    }}
执行 ListItr 的构造方法时调用了一次 node(int) 方法，返回第一个节点。在此之后，迭代器就执行 hasNext() 判断有没有下一个，执行 next() 方法下一个节点。
由此，可以得出这样的结论：遍历 LinkedList 的时候，千万不要使用 for 循环，要使用迭代器。
也就是说，for 循环遍历的时候，ArrayList 花费的时间远小于 LinkedList；迭代器遍历的时候，两者性能差不多。
06、两者的使用场景 
当需要频繁随机访问元素的时候，例如读取大量数据并进行处理或者需要对数据进行排序或查找的场景，可以使用 ArrayList。例如一个学生管理系统，需要对学生列表进行排序或查找操作，可以使用 ArrayList 存储学生信息，以便快速访问和处理。
当需要频繁插入和删除元素的时候，例如实现队列或栈，或者需要在中间插入或删除元素的场景，可以使用 LinkedList。例如一个实时聊天系统，需要实现一个消息队列，可以使用 LinkedList 存储消息，以便快速插入和删除消息。
在一些特殊场景下，可能需要同时支持随机访问和插入&#x2F;删除操作。例如一个在线游戏系统，需要实现一个玩家列表，需要支持快速查找和遍历玩家，同时也需要支持玩家的加入和离开。在这种情况下，可以使用 LinkedList 和 ArrayList 的组合，例如使用 LinkedList 存储玩家，以便快速插入和删除玩家，同时使用 ArrayList 存储玩家列表，以便快速查找和遍历玩家。
“好了，三妹，关于 LinkedList 和 ArrayList 的差别，我们就先聊到这，你也不用太去扣细节，直到其中的差别就好了。”
“好的，二哥。”
4.6 Java泛型，深入解析“二哥，为什么要设计泛型啊？”三妹开门见山地问。
“三妹啊，听哥慢慢给你讲啊。”我说。
Java 在 1.5 时增加了泛型机制，据说专家们为此花费了 5 年左右的时间（听起来是相当不容易）。有了泛型之后，尤其是对集合类的使用，就变得更规范了。
看下面这段简单的代码。
123ArrayList&lt;String&gt; list &#x3D; new ArrayList&lt;String&gt;();list.add(&quot;沉默王二&quot;);String str &#x3D; list.get(0);
“三妹，你能想象到在没有泛型之前该怎么办吗？”
“嗯，想不到，还是二哥你说吧。”
嗯，我们可以使用 Object 数组来设计 Arraylist 类。
1234567891011class Arraylist {    private Object[] objs;    private int i &#x3D; 0;    public void add(Object obj) {        objs[i++] &#x3D; obj;    }        public Object get(int i) {        return objs[i];    }}
然后，我们向 Arraylist 中存取数据。
1234Arraylist list &#x3D; new Arraylist();list.add(&quot;沉默王二&quot;);list.add(new Date());String str &#x3D; (String)list.get(0);
“三妹，你有没有发现这两个问题？”

Arraylist 可以存放任何类型的数据（既可以存字符串，也可以混入日期），因为所有类都继承自 Object 类。
从 Arraylist 取出数据的时候需要强制类型转换，因为编译器并不能确定你取的是字符串还是日期。

“嗯嗯，是的呢。”三妹说。
对比一下，你就能明显地感受到泛型的优秀之处：使用类型参数解决了元素的不确定性——参数类型为 String 的集合中是不允许存放其他类型元素的，取出数据的时候也不需要强制类型转换了。
动手设计一个泛型 
“二哥，那怎么才能设计一个泛型呢？”
“三妹啊，你一个小白只要会用泛型就行了，还想设计泛型啊？！不过，既然你想了解，哥义不容辞。”
首先，我们来按照泛型的标准重新设计一下 Arraylist 类。
12345678910111213141516class Arraylist&lt;E&gt; {    private Object[] elementData;    private int size &#x3D; 0;    public Arraylist(int initialCapacity) {        this.elementData &#x3D; new Object[initialCapacity];    }        public boolean add(E e) {        elementData[size++] &#x3D; e;        return true;    }        E elementData(int index) {        return (E) elementData[index];    }}
一个泛型类就是具有一个或多个类型变量的类。Arraylist 类引入的类型变量为 E（Element，元素的首字母），使用尖括号 &lt;&gt; 括起来，放在类名的后面。
然后，我们可以用具体的类型（比如字符串）替换类型变量来实例化泛型类。
123Arraylist&lt;String&gt; list &#x3D; new Arraylist&lt;String&gt;();list.add(&quot;沉默王三&quot;);String str &#x3D; list.get(0);
Date 类型也可以的。
123Arraylist&lt;Date&gt; list &#x3D; new Arraylist&lt;Date&gt;();list.add(new Date());Date date &#x3D; list.get(0);
其次，我们还可以在一个非泛型的类（或者泛型类）中定义泛型方法。
12345class Arraylist&lt;E&gt; {    public &lt;T&gt; T[] toArray(T[] a) {        return (T[]) Arrays.copyOf(elementData, size, a.getClass());    }}
不过，说实话，泛型方法的定义看起来略显晦涩。来一副图吧（注意：方法返回类型和方法参数类型至少需要一个）。

现在，我们来调用一下泛型方法。
12345678910Arraylist&lt;String&gt; list &#x3D; new Arraylist&lt;&gt;(4);list.add(&quot;沉&quot;);list.add(&quot;默&quot;);list.add(&quot;王&quot;);list.add(&quot;二&quot;);String [] strs &#x3D; new String [4];strs &#x3D; list.toArray(strs);for (String str : strs) {    System.out.println(str);}
泛型限定符 
然后，我们再来说说泛型变量的限定符 extends 。
在解释这个限定符之前，我们假设有三个类，它们之间的定义是这样的。
123456789101112131415class Wanglaoer {    public String toString() {        return &quot;王老二&quot;;    }}class Wanger extends Wanglaoer{    public String toString() {        return &quot;王二&quot;;    }}class Wangxiaoer extends Wanger{    public String toString() {        return &quot;王小二&quot;;    }}
我们使用限定符 extends 来重新设计一下 Arraylist 类。
12class Arraylist&lt;E extends Wanger&gt; {}
当我们向 Arraylist 中添加 Wanglaoer 元素的时候，编译器会提示错误： Arraylist 只允许添加 Wanger 及其子类 Wangxiaoer 对象，不允许添加其父类 Wanglaoer 。
1234567Arraylist&lt;Wanger&gt; list &#x3D; new Arraylist&lt;&gt;(3);list.add(new Wanger());list.add(new Wanglaoer());&#x2F;&#x2F; The method add(Wanger) in the type Arraylist&lt;Wanger&gt; is not applicable for the arguments &#x2F;&#x2F; (Wanglaoer)list.add(new Wangxiaoer());
也就是说，限定符 extends 可以缩小泛型的类型范围。
类型擦除 
“哦，明白了。”三妹若有所思的点点头，“二哥，听说虚拟机没有泛型？”
“三妹，你功课做得可以啊。哥可以肯定地回答你，虚拟机是没有泛型的。”
“怎么确定虚拟机有没有泛型呢？”三妹问。
“只要我们把泛型类的字节码进行反编译就看到了！”用反编译工具（我写这篇文章的时候用的是 jad，你也可以用其他的工具）将 class 文件反编译后，我说，“三妹，你看。”
12345678910111213141516171819202122232425&#x2F;&#x2F; Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.&#x2F;&#x2F; Jad home page: http:&#x2F;&#x2F;www.kpdus.com&#x2F;jad.html&#x2F;&#x2F; Decompiler options: packimports(3) &#x2F;&#x2F; Source File Name:   Arraylist.javapackage com.cmower.java_demo.fanxing;import java.util.Arrays;class Arraylist{    public Arraylist(int initialCapacity)    {        size &#x3D; 0;        elementData &#x3D; new Object[initialCapacity];    }    public boolean add(Object e)    {        elementData[size++] &#x3D; e;        return true;    }    Object elementData(int index)    {        return elementData[index];    }    private Object elementData[];    private int size;}
类型变量  消失了，取而代之的是 Object ！
“既然如此，那如果泛型类使用了限定符 extends ，结果会怎么样呢？”三妹这个问题问的很巧妙。
来看这段代码。
1234567891011121314class Arraylist2&lt;E extends Wanger&gt; {    private Object[] elementData;    private int size &#x3D; 0;    public Arraylist2(int initialCapacity) {        this.elementData &#x3D; new Object[initialCapacity];    }    public boolean add(E e) {        elementData[size++] &#x3D; e;        return true;    }    E elementData(int index) {        return (E) elementData[index];    }}
反编译后的结果如下。
1234567891011121314151617181920212223242526&#x2F;&#x2F; Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.&#x2F;&#x2F; Jad home page: http:&#x2F;&#x2F;www.kpdus.com&#x2F;jad.html&#x2F;&#x2F; Decompiler options: packimports(3) &#x2F;&#x2F; Source File Name:   Arraylist2.javapackage com.cmower.java_demo.fanxing;&#x2F;&#x2F; Referenced classes of package com.cmower.java_demo.fanxing:&#x2F;&#x2F;            Wangerclass Arraylist2{    public Arraylist2(int initialCapacity)    {        size &#x3D; 0;        elementData &#x3D; new Object[initialCapacity];    }    public boolean add(Wanger e)    {        elementData[size++] &#x3D; e;        return true;    }    Wanger elementData(int index)    {        return (Wanger)elementData[index];    }    private Object elementData[];    private int size;}
“你看，类型变量  不见了，E 被替换成了 Wanger ”，我说，“通过以上两个例子说明，Java 虚拟机会将泛型的类型变量擦除，并替换为限定类型（没有限定的话，就用 Object ）”
“二哥，类型擦除会有什么问题吗？”三妹又问了一个很有水平的问题。
“三妹啊，你还别说，类型擦除真的会有一些问题。”我说，“来看一下这段代码。”
123456789public class Cmower {        public static void method(Arraylist&lt;String&gt; list) {        System.out.println(&quot;Arraylist&lt;String&gt; list&quot;);    }    public static void method(Arraylist&lt;Date&gt; list) {        System.out.println(&quot;Arraylist&lt;Date&gt; list&quot;);    }}
在浅层的意识上，我们会想当然地认为 Arraylist list 和 Arraylist list 是两种不同的类型，因为 String 和 Date 是不同的类。
但由于类型擦除的原因，以上代码是不会通过编译的——编译器会提示一个错误（这正是类型擦除引发的那些“问题”）：
12345&gt;Erasure of method method(Arraylist&lt;String&gt;) is the same as another method in type  Cmower&gt;&gt;Erasure of method method(Arraylist&lt;Date&gt;) is the same as another method in type  Cmower
大致的意思就是，这两个方法的参数类型在擦除后是相同的。
也就是说， method(Arraylist list) 和 method(Arraylist list) 是同一种参数类型的方法，不能同时存在。类型变量 String 和 Date 在擦除后会自动消失，method 方法的实际参数是 Arraylist list 。
有句俗话叫做：“百闻不如一见”，但即使见到了也未必为真——泛型的擦除问题就可以很好地佐证这个观点。      泛型通配符 
“哦，明白了。二哥，听说泛型还有通配符？”
“三妹啊，哥突然觉得你很适合作一枚可爱的程序媛啊！你这预习的功课做得可真到家啊，连通配符都知道！”
通配符使用英文的问号 （?）来表示。在我们创建一个泛型对象时，可以使用关键字 extends 限定子类，也可以使用关键字 super 限定父类。
我们来看下面这段代码。
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&#x2F;&#x2F; 定义一个泛型类 Arraylist&lt;E&gt;，E 表示元素类型class Arraylist&lt;E&gt; {    &#x2F;&#x2F; 私有成员变量，存储元素数组和元素数量    private Object[] elementData;    private int size &#x3D; 0;    &#x2F;&#x2F; 构造函数，传入初始容量 initialCapacity，创建一个指定容量的 Object 数组    public Arraylist(int initialCapacity) {        this.elementData &#x3D; new Object[initialCapacity];    }    &#x2F;&#x2F; 添加元素到数组末尾，返回添加成功与否    public boolean add(E e) {        elementData[size++] &#x3D; e;        return true;    }    &#x2F;&#x2F; 获取指定下标的元素    public E get(int index) {        return (E) elementData[index];    }    &#x2F;&#x2F; 查找指定元素第一次出现的下标，如果找不到则返回 -1    public int indexOf(Object o) {        if (o &#x3D;&#x3D; null) {            for (int i &#x3D; 0; i &lt; size; i++)                if (elementData[i]&#x3D;&#x3D;null)                    return i;        } else {            for (int i &#x3D; 0; i &lt; size; i++)                if (o.equals(elementData[i]))                    return i;        }        return -1;    }    &#x2F;&#x2F; 判断指定元素是否在数组中出现    public boolean contains(Object o) {        return indexOf(o) &gt;&#x3D; 0;    }     &#x2F;&#x2F; 将数组中的元素转化成字符串输出    public String toString() {        StringBuilder sb &#x3D; new StringBuilder();                for (Object o : elementData) {            if (o !&#x3D; null) {                E e &#x3D; (E)o;                sb.append(e.toString());                sb.append(&#39;,&#39;).append(&#39; &#39;);            }        }        return sb.toString();    }    &#x2F;&#x2F; 返回数组中元素的数量    public int size() {        return size;    }    &#x2F;&#x2F; 修改指定下标的元素，返回修改前的元素    public E set(int index, E element) {        E oldValue &#x3D; (E) elementData[index];        elementData[index] &#x3D; element;        return oldValue;    }}
1）新增 indexOf(Object o) 方法，判断元素在 Arraylist 中的位置。注意参数为 Object 而不是泛型 E 。
2）新增 contains(Object o) 方法，判断元素是否在 Arraylist 中。注意参数为 Object 而不是泛型 E 。
3）新增 toString() 方法，方便对 Arraylist 进行打印。
4）新增 set(int index, E element) 方法，方便对 Arraylist 元素的更改。
因为泛型擦除的原因， Arraylist list &#x3D; new Arraylist(); 这样的语句是无法通过编译的，尽管 Wangxiaoer 是 Wanger 的子类。但如果我们确实需要这种 “向上转型” 的关系，该怎么办呢？这时候就需要通配符来发挥作用了。
利用 &lt;? extends Wanger&gt; 形式的通配符，可以实现泛型的向上转型，来看例子。
123456Arraylist&lt;? extends Wanger&gt; list2 &#x3D; new Arraylist&lt;&gt;(4);list2.add(null);&#x2F;&#x2F; list2.add(new Wanger());&#x2F;&#x2F; list2.add(new Wangxiaoer());Wanger w2 &#x3D; list2.get(0);&#x2F;&#x2F; Wangxiaoer w3 &#x3D; list2.get(1);
list2 的类型是 Arraylist&lt;? extends Wanger&gt; ，翻译一下就是，list2 是一个 Arraylist ，其类型是 Wanger 及其子类。
注意，“关键”来了！list2 并不允许通过 add(E e) 方法向其添加 Wanger 或者 Wangxiaoer 的对象，唯一例外的是 null 。
“那就奇了怪了，既然不让存放元素，那要 Arraylist&lt;? extends Wanger&gt; 这样的 list2 有什么用呢？”三妹好奇地问。
虽然不能通过 add(E e) 方法往 list2 中添加元素，但可以给它赋值。
12345678910Arraylist&lt;Wanger&gt; list &#x3D; new Arraylist&lt;&gt;(4);Wanger wanger &#x3D; new Wanger();list.add(wanger);Wangxiaoer wangxiaoer &#x3D; new Wangxiaoer();list.add(wangxiaoer);Arraylist&lt;? extends Wanger&gt; list2 &#x3D; list;Wanger w2 &#x3D; list2.get(1);System.out.println(w2);System.out.println(list2.indexOf(wanger));System.out.println(list2.contains(new Wangxiaoer()));
Arraylist&lt;? extends Wanger&gt; list2 &#x3D; list; 语句把 list 的值赋予了 list2，此时 list2 &#x3D;&#x3D; list 。
由于 list2 不允许往其添加其他元素，所以此时它是安全的——我们可以从容地对 list2 进行 get() 、indexOf() 和 contains() 。想一想，如果可以向 list2 添加元素的话，这 3 个方法反而变得不太安全，它们的值可能就会变。
利用 &lt;? super Wanger&gt; 形式的通配符，可以向 Arraylist 中存入父类是 Wanger 的元素，来看例子。
1234Arraylist&lt;? super Wanger&gt; list3 &#x3D; new Arraylist&lt;&gt;(4);list3.add(new Wanger());list3.add(new Wangxiaoer());&#x2F;&#x2F; Wanger w3 &#x3D; list3.get(0);
需要注意的是，无法从 Arraylist&lt;? super Wanger&gt; 这样类型的 list3 中取出数据。
小结 
好了，三妹，关于泛型，我们再来做一个简单的总结。
在 Java 中，泛型是一种强类型约束机制，可以在编译期间检查类型安全性，并且可以提高代码的复用性和可读性。
1）类型参数化 
泛型的本质是参数化类型，也就是说，在定义类、接口或方法时，可以使用一个或多个类型参数来表示参数化类型。
例如这样可以定义一个泛型类。
123456789101112public class Box&lt;T&gt; {    private T value;    public Box(T value) {        this.value &#x3D; value;    }    public T getValue() {        return value;    }    public void setValue(T value) {        this.value &#x3D; value;    }}
在这个例子中，  表示类型参数，可以在类中任何需要使用类型的地方使用 T 代替具体的类型。通过使用泛型，我们可以创建一个可以存储任何类型对象的盒子。
12Box&lt;Integer&gt; intBox &#x3D; new Box&lt;&gt;(123);Box&lt;String&gt; strBox &#x3D; new Box&lt;&gt;(&quot;Hello, world!&quot;);
泛型在实际开发中的应用非常广泛，例如集合框架中的 List、Set、Map 等容器类，以及并发框架中的 Future、Callable 等工具类都使用了泛型。
2）类型擦除 
在 Java 的泛型机制中，有两个重要的概念：类型擦除和通配符。
泛型在编译时会将泛型类型擦除，将泛型类型替换成 Object 类型。这是为了向后兼容，避免对原有的 Java 代码造成影响。
例如，对于下面的代码：
123List&lt;Integer&gt; intList &#x3D; new ArrayList&lt;&gt;();intList.add(123);int value &#x3D; intList.get(0);
在编译时，Java 编译器会将泛型类型 List 替换成 List ，将 get 方法的返回值类型 Integer 替换成 Object，生成的字节码与下面的代码等价：
123List intList &#x3D; new ArrayList();intList.add(Integer.valueOf(123));int value &#x3D; (Integer) intList.get(0);
Java 泛型只在编译时起作用，运行时并不会保留泛型类型信息。
3）通配符 
通配符用于表示某种未知的类型，例如 List&lt;?&gt; 表示一个可以存储任何类型对象的 List，但是不能对其中的元素进行添加操作。通配符可以用来解决类型不确定的情况，例如在方法参数或返回值中使用。
使用通配符可以使方法更加通用，同时保证类型安全。
例如，定义一个泛型方法：
123456public static void printList(List&lt;?&gt; list) {    for (Object obj : list) {        System.out.print(obj + &quot; &quot;);    }    System.out.println();}
这个方法可以接受任意类型的 List，例如 List 、 List 等等。
上限通配符 
泛型还提供了上限通配符 &lt;? extends T&gt; ，表示通配符只能接受 T 或 T 的子类。使用上限通配符可以提高程序的类型安全性。
例如，定义一个方法，只接受 Number 及其子类的 List：
123456public static void printNumberList(List&lt;? extends Number&gt; list) {    for (Number num : list) {        System.out.print(num + &quot; &quot;);    }    System.out.println();}
这个方法可以接受 List 、 List 等等。
下限通配符 
下限通配符（Lower Bounded Wildcards）用 super 关键字来声明，其语法形式为 &lt;? super T&gt; ，其中 T 表示类型参数。它表示的是该类型参数必须是某个指定类的超类（包括该类本身）。
当我们需要往一个泛型集合中添加元素时，如果使用的是上限通配符，集合中的元素类型可能会被限制，从而无法添加某些类型的元素。但是，如果我们使用下限通配符，可以将指定类型的子类型添加到集合中，保证了元素的完整性。
举个例子，假设有一个类 Animal，以及两个子类 Dog 和 Cat。现在我们有一个 List&lt;? super Dog&gt; 集合，它的类型参数必须是 Dog 或其父类类型。我们可以向该集合中添加 Dog 类型的元素，也可以添加它的子类。但是，不能向其中添加 Cat 类型的元素，因为 Cat 不是 Dog 的子类。
下面是一个使用下限通配符的示例：
123456List&lt;? super Dog&gt; animals &#x3D; new ArrayList&lt;&gt;();&#x2F;&#x2F; 可以添加 Dog 类型的元素和其子类型元素animals.add(new Dog());animals.add(new Bulldog());&#x2F;&#x2F; 不能添加 Cat 类型的元素animals.add(new Cat()); &#x2F;&#x2F; 编译报错
需要注意的是，虽然使用下限通配符可以添加某些子类型元素，但是在读取元素时，我们只能确保其是 Object 类型的，无法确保其是指定类型或其父类型。因此，在读取元素时需要进行类型转换，如下所示：
12345List&lt;? super Dog&gt; animals &#x3D; new ArrayList&lt;&gt;();animals.add(new Dog());&#x2F;&#x2F; 读取元素时需要进行类型转换Object animal &#x3D; animals.get(0);Dog dog &#x3D; (Dog) animal;
总的来说，Java 的泛型机制是一种非常强大的类型约束机制，可以在编译时检查类型安全性，并提高代码的复用性和可读性。但是，在使用泛型时也需要注意类型擦除和通配符等问题，以确保代码的正确性。
4.7 Iterator和Iterable的区别PS: 这篇同样来换一个风格，一起来欣赏。
那天，小二去海康威视面试，面试官老王一上来就甩给了他一道面试题：请问 Iterator与Iterable有什么区别？
小二表示很开心，因为他3 天前刚好在《二哥的Java进阶之路》上读过这篇文章，所以回答得胸有成竹。
以下是小二当时读过的文章内容，他印象深刻。
在 Java 中，我们对 List 进行遍历的时候，主要有这么三种方式。
第一种：for 循环。
123for (int i &#x3D; 0; i &lt; list.size(); i++) {    System.out.print(list.get(i) + &quot;，&quot;);}
第二种：迭代器。
1234Iterator it &#x3D; list.iterator();while (it.hasNext()) {    System.out.print(it.next() + &quot;，&quot;);}
第三种：for-each。
123for (String str : list) {    System.out.print(str + &quot;，&quot;);}
第一种我们略过，第二种用的是 Iterator，第三种看起来是 for-each，其实背后也是 Iterator，看一下反编译后的代码（如下所示）就明白了。
12345Iterator var3 &#x3D; list.iterator();while(var3.hasNext()) {    String str &#x3D; (String)var3.next();    System.out.print(str + &quot;，&quot;);}
for-each 只不过是个语法糖，让我们开发者在遍历 List 的时候可以写更少的代码，更简洁明了。
Iterator 是个接口，JDK 1.2 的时候就有了，用来改进 Enumeration 接口：

允许删除元素（增加了 remove 方法）
优化了方法名（Enumeration 中是 hasMoreElements 和 nextElement，不简洁）

来看一下 Iterator 的源码：
12345678910public interface Iterator&lt;E&gt; {    &#x2F;&#x2F; 判断集合中是否存在下一个对象    boolean hasNext();    &#x2F;&#x2F; 返回集合中的下一个对象，并将访问指针移动一位    E next();    &#x2F;&#x2F; 删除集合中调用next()方法返回的对象    default void remove() {        throw new UnsupportedOperationException(&quot;remove&quot;);    }}
JDK 1.8 时，Iterable 接口中新增了 forEach 方法。该方法接受一个 Consumer 对象作为参数，用于对集合中的每个元素执行指定的操作。该方法的实现方式是使用 for-each 循环遍历集合中的元素，对于每个元素，调用 Consumer 对象的 accept 方法执行指定的操作。
123456default void forEach(Consumer&lt;? super T&gt; action) {    Objects.requireNonNull(action);    for (T t : this) {        action.accept(t);    }}
该方法实现时首先会对 action 参数进行非空检查，如果为 null 则抛出 NullPointerException 异常。然后使用 for-each 循环遍历集合中的元素，并对每个元素调用 action.accept(t) 方法执行指定的操作。由于 Iterable 接口是 Java 集合框架中所有集合类型的基本接口，因此该方法可以被所有实现了 Iterable 接口的集合类型使用。
它对 Iterable 的每个元素执行给定操作，具体指定的操作需要自己写Consumer接口通过accept方法回调出来。
12List&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;(Arrays.asList(1, 2, 3));list.forEach(integer -&gt; System.out.println(integer));
写得更浅显易懂点，就是：
1234567List&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;(Arrays.asList(1, 2, 3));list.forEach(new Consumer&lt;Integer&gt;() {    @Override    public void accept(Integer integer) {        System.out.println(integer);    }});
如果我们仔细观察ArrayList 或者 LinkedList 的“户口本”就会发现，并没有直接找到 Iterator 的影子。

反而找到了 Iterable！
123public interface Iterable&lt;T&gt; {    Iterator&lt;T&gt; iterator();}
也就是说，List 的关系图谱中并没有直接使用 Iterator，而是使用 Iterable 做了过渡。
回头再来看一下第二种遍历 List 的方式。
123Iterator it &#x3D; list.iterator();while (it.hasNext()) {}
发现刚好呼应上了。拿 ArrayList 来说吧，它重写了 Iterable 接口的 iterator 方法：
123public Iterator&lt;E&gt; iterator() {    return new Itr();}
返回的对象 Itr 是个内部类，实现了 Iterator 接口，并且按照自己的方式重写了 hasNext、next、remove 等方法。
1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&#x2F;** * ArrayList 迭代器的实现，内部类。 *&#x2F;private class Itr implements Iterator&lt;E&gt; {    &#x2F;**     * 游标位置，即下一个元素的索引。     *&#x2F;    int cursor;    &#x2F;**     * 上一个元素的索引。     *&#x2F;    int lastRet &#x3D; -1;    &#x2F;**     * 预期的结构性修改次数。     *&#x2F;    int expectedModCount &#x3D; modCount;    &#x2F;**     * 判断是否还有下一个元素。     *     * @return 如果还有下一个元素，则返回 true，否则返回 false。     *&#x2F;    public boolean hasNext() {        return cursor !&#x3D; size;    }    &#x2F;**     * 获取下一个元素。     *     * @return 列表中的下一个元素。     * @throws NoSuchElementException 如果没有下一个元素，则抛出 NoSuchElementException 异常。     *&#x2F;    @SuppressWarnings(&quot;unchecked&quot;)    public E next() {        &#x2F;&#x2F; 获取 ArrayList 对象的内部数组        Object[] elementData &#x3D; ArrayList.this.elementData;        &#x2F;&#x2F; 记录当前迭代器的位置        int i &#x3D; cursor;        if (i &gt;&#x3D; size) {            throw new NoSuchElementException();        }        &#x2F;&#x2F; 将游标位置加 1，为下一次迭代做准备        cursor &#x3D; i + 1;        &#x2F;&#x2F; 记录上一个元素的索引        return (E) elementData[lastRet &#x3D; i];    }    &#x2F;**     * 删除最后一个返回的元素。     * 迭代器只能删除最后一次调用 next 方法返回的元素。     *     * @throws ConcurrentModificationException 如果在最后一次调用 next 方法之后列表结构被修改，则抛出 ConcurrentModificationException 异常。     * @throws IllegalStateException         如果在调用 next 方法之前没有调用 remove 方法，或者在同一次迭代中多次调用 remove 方法，则抛出 IllegalStateException 异常。     *&#x2F;    public void remove() {        &#x2F;&#x2F; 检查在最后一次调用 next 方法之后是否进行了结构性修改        if (expectedModCount !&#x3D; modCount) {            throw new ConcurrentModificationException();        }        &#x2F;&#x2F; 如果上一次调用 next 方法之前没有调用 remove 方法，则抛出 IllegalStateException 异常        if (lastRet &lt; 0) {            throw new IllegalStateException();        }        try {            &#x2F;&#x2F; 调用 ArrayList 对象的 remove(int index) 方法删除上一个元素            ArrayList.this.remove(lastRet);            &#x2F;&#x2F; 将游标位置设置为上一个元素的位置            cursor &#x3D; lastRet;            &#x2F;&#x2F; 将上一个元素的索引设置为 -1，表示没有上一个元素            lastRet &#x3D; -1;            &#x2F;&#x2F; 更新预期的结构性修改次数            expectedModCount &#x3D; modCount;        } catch (IndexOutOfBoundsException ex) {            throw new ConcurrentModificationException();        }    }}
 那可能有些小伙伴会问：为什么不直接将 Iterator 中的核心方法 hasNext、next 放到 Iterable 接口中呢？
 直接像下面这样使用不是更方便？
123Iterable it &#x3D; list.iterator();while (it.hasNext()) {}
 从英文单词的后缀语法上来看，（Iterable）able 表示这个 List 是支持迭代的，而 （Iterator）tor 表示这个 List 是如何迭代的。
 支持迭代与具体怎么迭代显然不能混在一起，否则就乱的一笔。还是各司其职的好。
 想一下，如果把 Iterator 和 Iterable 合并，for-each 这种遍历 List 的方式是不是就不好办了？
 原则上，只要一个 List 实现了 Iterable 接口，那么它就可以使用 for-each 这种方式来遍历，那具体该怎么遍历，还是要看它自己是怎么实现 Iterator 接口的。
 Map 就没办法直接使用 for-each，因为 Map 没有实现 Iterable 接口，只有通过 map.entrySet() 、map.keySet() 、 map.values() 这种返回一个  Collection 的方式才能 使用 for-each。
 如果我们仔细研究 LinkedList 的源码就会发现，LinkedList 并没有直接重写 Iterable 接口的 iterator 方法，而是由它的父类 AbstractSequentialList 来完成。
123public Iterator&lt;E&gt; iterator() {    return listIterator();}
 LinkedList 重写了 listIterator 方法：
1234public ListIterator&lt;E&gt; listIterator(int index) {    checkPositionIndex(index);    return new ListItr(index);}
 这里我们发现了一个新的迭代器 ListIterator，它继承了 Iterator 接口，在遍历List 时可以从任意下标开始遍历，而且支持双向遍历。
123456public interface ListIterator&lt;E&gt; extends Iterator&lt;E&gt; {    boolean hasNext();    E next();    boolean hasPrevious();    E previous();}
 我们知道，集合（Collection）不仅有 List，还有 Set，那 Iterator 不仅支持 List，还支持 Set，但 ListIterator 就只支持 List。
 那可能有些小伙伴会问：为什么不直接让 List 实现 Iterator 接口，而是要用内部类来实现呢？
 这是因为有些 List 可能会有多种遍历方式，比如说 LinkedList，除了支持正序的遍历方式，还支持逆序的遍历方式——DescendingIterator：
123456789101112131415161718192021222324252627282930313233343536 &#x2F;** * ArrayList 逆向迭代器的实现，内部类。 *&#x2F;private class DescendingIterator implements Iterator&lt;E&gt; {    &#x2F;**     * 使用 ListItr 对象进行逆向遍历。     *&#x2F;    private final ListItr itr &#x3D; new ListItr(size());    &#x2F;**     * 判断是否还有下一个元素。     *     * @return 如果还有下一个元素，则返回 true，否则返回 false。     *&#x2F;    public boolean hasNext() {        return itr.hasPrevious();    }    &#x2F;**     * 获取下一个元素。     *     * @return 列表中的下一个元素。     * @throws NoSuchElementException 如果没有下一个元素，则抛出 NoSuchElementException 异常。     *&#x2F;    public E next() {        return itr.previous();    }    &#x2F;**     * 删除最后一个返回的元素。     * 迭代器只能删除最后一次调用 next 方法返回的元素。     *     * @throws UnsupportedOperationException 如果列表不支持删除操作，则抛出 UnsupportedOperationException 异常。     * @throws IllegalStateException         如果在调用 next 方法之前没有调用 remove 方法，或者在同一次迭代中多次调用 remove 方法，则抛出 IllegalStateException 异常。     *&#x2F;    public void remove() {        itr.remove();    }}
  可以看得到，DescendingIterator 刚好利用了 ListIterator 向前遍历的方式。可以通过以下的方式来使用：
123Iterator it &#x3D; list.descendingIterator();while (it.hasNext()) {}
  好了，关于Iterator与Iterable我们就先聊这么多，总结两点：

学会深入思考，一点点抽丝剥茧，多想想为什么这样实现，很多问题没有自己想象中的那么复杂。
遇到疑惑不放弃，这是提升自己最好的机会，遇到某个疑难的点，解决的过程中会挖掘出很多相关的东西。

4.8 Java foreach 循环陷阱 这篇文章同样采用小二去面试的形式，给大家换个胃口。
 那天，小二去阿里面试，面试官老王一上来就甩给了他一道面试题：为什么阿里的 Java 开发手册里会强制不要在 foreach 里进行元素的删除操作？

 小二听完这句话就乐了。为什么呢？因为一天前他刚在《Java进阶之路》上看到过这道题的答案。
 以下是整篇文章的内容。
 关于fail-fast 
 为了镇楼，先搬一段英文来解释一下 fail-fast。

In systems design, a fail-fast system is one which immediately reports at its interface any condition that is likely to indicate a failure. Fail-fast systems are usually designed to stop normal operation rather than attempt to continue a possibly flawed process. Such designs often check the system’s state at several points in an operation, so any failures can be detected early. The responsibility of a fail-fast module is detecting errors, then letting the next-highest level of the system handle them.

 这段话的大致意思就是，fail-fast 是一种通用的系统设计思想，一旦检测到可能会发生错误，就立马抛出异常，程序将不再往下执行。
1234567public void test(Wanger wanger) {       if (wanger &#x3D;&#x3D; null) {        throw new RuntimeException(&quot;wanger 不能为空&quot;);    }        System.out.println(wanger.toString());}
 一旦检测到 wanger 为 null，就立马抛出异常，让调用者来决定这种情况下该怎么处理，下一步 wanger.toString() 就不会执行了——避免更严重的错误出现。
 很多时候，我们会把 fail-fast 归类为 Java 集合框架的一种错误检测机制，但其实 fail-fast 并不是 Java 集合框架特有的机制。
 for-each 删除元素报错 
 之所以我们把 fail-fast 放在集合框架篇里介绍，是因为问题比较容易再现。
12345678910List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();list.add(&quot;沉默王二&quot;);list.add(&quot;沉默王三&quot;);list.add(&quot;一个文章真特么有趣的程序员&quot;);for (String str : list) {    if (&quot;沉默王二&quot;.equals(str)) {        list.remove(str);    }}System.out.println(list);
 这段代码看起来没有任何问题，但运行起来就报错了。

 根据错误的堆栈信息，我们可以定位到 ArrayList 的第 901 行代码。
1234final void checkForComodification() {    if (modCount !&#x3D; expectedModCount)        throw new ConcurrentModificationException();}
 也就是说，remove 的时候触发执行了 checkForComodification 方法，该方法对 modCount 和 expectedModCount 进行了比较，发现两者不等，就抛出了 ConcurrentModificationException 异常。
 为什么会执行 checkForComodification 方法呢？
 是因为 for-each 本质上是个语法糖，底层是通过迭代器 Iterator 配合 while 循环实现的，来看一下反编译后的字节码。
123456789101112List&lt;String&gt; list &#x3D; new ArrayList();list.add(&quot;沉默王二&quot;);list.add(&quot;沉默王三&quot;);list.add(&quot;一个文章真特么有趣的程序员&quot;);Iterator var2 &#x3D; list.iterator();while(var2.hasNext()) {    String str &#x3D; (String)var2.next();    if (&quot;沉默王二&quot;.equals(str)) {        list.remove(str);    }}System.out.println(list);
 来看一下 ArrayList 的 iterator 方法吧：
123public Iterator&lt;E&gt; iterator() {    return new Itr();}
 内部类 Itr 实现了 Iterator 接口，这是 Itr 的源码。
123456789101112131415161718192021 private class Itr implements Iterator&lt;E&gt; {    int cursor;             &#x2F;&#x2F; 下一个元素的索引    int lastRet &#x3D; -1;       &#x2F;&#x2F; 上一个返回元素的索引；如果没有则为 -1    int expectedModCount &#x3D; modCount; &#x2F;&#x2F; ArrayList 的修改次数    Itr() { }  &#x2F;&#x2F; 构造函数    public boolean hasNext() { &#x2F;&#x2F; 判断是否还有下一个元素        return cursor !&#x3D; size;    }        @SuppressWarnings(&quot;unchecked&quot;)    public E next() { &#x2F;&#x2F; 返回下一个元素        checkForComodification(); &#x2F;&#x2F; 检查 ArrayList 是否被修改过        int i &#x3D; cursor; &#x2F;&#x2F; 当前索引        Object[] elementData &#x3D; ArrayList.this.elementData; &#x2F;&#x2F; ArrayList 中的元素数组        if (i &gt;&#x3D; elementData.length) &#x2F;&#x2F; 超出数组范围            throw new ConcurrentModificationException(); &#x2F;&#x2F; 抛出异常        cursor &#x3D; i + 1; &#x2F;&#x2F; 更新下一个元素的索引        return (E) elementData[lastRet &#x3D; i]; &#x2F;&#x2F; 返回下一个元素    }}
 也就是说 new Itr() 的时候 expectedModCount 被赋值为 modCount，而 modCount 是 ArrayList 中的一个计数器，用于记录 ArrayList 对象被修改的次数。ArrayList 的修改操作包括添加、删除、设置元素值等。每次对 ArrayList 进行修改操作时，modCount 的值会自增 1。
 在迭代 ArrayList 时，如果迭代过程中发现 modCount 的值与迭代器的 expectedModCount 不一致，则说明 ArrayList 已被修改过，此时会抛出 ConcurrentModificationException 异常。这种机制可以保证迭代器在遍历 ArrayList 时，不会遗漏或重复元素，同时也可以在多线程环境下检测到并发修改问题。
1protected transient int modCount &#x3D; 0;
 分析代码执行的逻辑 
 我们来继续定位之前报错的错误堆栈。这是之前的代码。
12345678910List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();list.add(&quot;沉默王二&quot;);list.add(&quot;沉默王三&quot;);list.add(&quot;一个文章真特么有趣的程序员&quot;);for (String str : list) {    if (&quot;沉默王二&quot;.equals(str)) {        list.remove(str);    }}System.out.println(list);
 由于 list 此前执行了 3 次 add 方法。

add 方法调用 ensureCapacityInternal 方法
ensureCapacityInternal 方法调用 ensureExplicitCapacity 方法
ensureExplicitCapacity 方法中会执行 modCount++

123private void ensureExplicitCapacity(int minCapacity) {    modCount++;}
 所以 modCount 的值在经过三次 add 后为 3，于是 new Itr() 后 expectedModCount 的值也为 3（回到前面去看一下 Itr 的源码）。
 接着来执行 for-each 的循环遍历。
 执行第一次循环时，发现“沉默王二”等于 str，于是执行 list.remove(str) 。

remove 方法调用 fastRemove 方法
fastRemove 方法中会执行 modCount++

123private void fastRemove(int index) {    modCount++;}
 modCount 的值变成了 4。
 第二次遍历时，会执行 Itr 的 next 方法（ String str &#x3D; (String) var3.next(); ），next 方法就会调用 checkForComodification 方法。
1234final void checkForComodification() {    if (modCount !&#x3D; expectedModCount)        throw new ConcurrentModificationException();}
 此时 expectedModCount 为 3，modCount 为 4，就只好抛出 ConcurrentModificationException 异常了。
 那其实在阿里巴巴的 Java 开发手册里也提到了，不要在 for-each 循环里进行元素的 remove&#x2F;add 操作。remove 元素请使用 Iterator 方式。

 那原因其实就是我们上面分析的这些，出于 fail-fast 保护机制。
那该如何正确地删除元素呢？ 
1）remove 后 break 
12345678910List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();list.add(&quot;沉默王二&quot;);list.add(&quot;沉默王三&quot;);list.add(&quot;一个文章真特么有趣的程序员&quot;);for (String str : list) {    if (&quot;沉默王二&quot;.equals(str)) {        list.remove(str);        break;    }}
 break 后循环就不再遍历了，意味着 Iterator 的 next 方法不再执行了，也就意味着 checkForComodification 方法不再执行了，所以异常也就不会抛出了。
 但是呢，当 List 中有重复元素要删除的时候，break 就不合适了。
2）for 循环 
12345678910List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();list.add(&quot;沉默王二&quot;);list.add(&quot;沉默王三&quot;);list.add(&quot;一个文章真特么有趣的程序员&quot;);for (int i &#x3D; 0; i &lt; list.size(); i++) {    String str &#x3D; list.get(i);    if (&quot;沉默王二&quot;.equals(str)) {        list.remove(str);    }}
 for 循环虽然可以避开 fail-fast 保护机制，也就说 remove 元素后不再抛出异常；但是呢，这段程序在原则上是有问题的。为什么呢？
 第一次循环的时候，i 为 0， list.size() 为 3，当执行完 remove 方法后，i 为 1， list.size() 却变成了 2，因为 list 的大小在 remove 后发生了变化，也就意味着“沉默王三”这个元素被跳过了。能明白吗？
 remove 之前 list.get(1) 为“沉默王三”；但 remove 之后 list.get(1) 变成了“一个文章真特么有趣的程序员”，而 list.get(0) 变成了“沉默王三”。
3）使用 Iterator 
1234567891011List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();list.add(&quot;沉默王二&quot;);list.add(&quot;沉默王三&quot;);list.add(&quot;一个文章真特么有趣的程序员&quot;);Iterator&lt;String&gt; itr &#x3D; list.iterator();while (itr.hasNext()) {    String str &#x3D; itr.next();    if (&quot;沉默王二&quot;.equals(str)) {        itr.remove();    }}
 为什么使用 Iterator 的 remove 方法就可以避开 fail-fast 保护机制呢？看一下 remove 的源码就明白了。
12345678910111213public void remove() {    if (lastRet &lt; 0) &#x2F;&#x2F; 如果没有上一个返回元素的索引，则抛出异常        throw new IllegalStateException();    checkForComodification(); &#x2F;&#x2F; 检查 ArrayList 是否被修改过    try {        ArrayList.this.remove(lastRet); &#x2F;&#x2F; 删除上一个返回元素        cursor &#x3D; lastRet; &#x2F;&#x2F; 更新下一个元素的索引        lastRet &#x3D; -1; &#x2F;&#x2F; 清空上一个返回元素的索引        expectedModCount &#x3D; modCount; &#x2F;&#x2F; 更新 ArrayList 的修改次数    } catch (IndexOutOfBoundsException ex) {        throw new ConcurrentModificationException(); &#x2F;&#x2F; 抛出异常    }}
 删除完会执行 expectedModCount &#x3D; modCount ，保证了 expectedModCount 与 modCount 的同步。
小结 
 为什么不能在foreach里执行删除操作？
 因为 foreach 循环是基于迭代器实现的，而迭代器在遍历集合时会维护一个 expectedModCount 属性来记录集合被修改的次数。如果在 foreach 循环中执行删除操作会导致 expectedModCount 属性值与实际的 modCount 属性值不一致，从而导致迭代器的 hasNext() 和 next() 方法抛出 ConcurrentModificationException 异常。
 为了避免这种情况，应该使用迭代器的 remove() 方法来删除元素，该方法会在删除元素后更新迭代器状态，确保循环的正确性。如果需要在循环中删除元素，应该使用迭代器的 remove() 方法，而不是集合自身的 remove() 方法。
 就像这样。
1234567891011List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();list.add(&quot;沉默王二&quot;);list.add(&quot;沉默王三&quot;);list.add(&quot;一个文章真特么有趣的程序员&quot;);Iterator&lt;String&gt; itr &#x3D; list.iterator();while (itr.hasNext()) {    String str &#x3D; itr.next();    if (&quot;沉默王二&quot;.equals(str)) {        itr.remove();    }}
 除此之外，我们还可以采用 Stream 流的filter() 方法来过滤集合中的元素，然后再通过 collect() 方法将过滤后的元素收集到一个新的集合中。
12List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;(Arrays.asList(&quot;沉默&quot;, &quot;王二&quot;, &quot;陈清扬&quot;));list &#x3D; list.stream().filter(s -&gt; !s.equals(&quot;陈清扬&quot;)).collect(Collectors.toList());
 好了，关于这个问题，就聊到这里吧，希望能帮助到你。
4.9 HashMap详解（附源码） 这篇文章将通过源码的方式，详细透彻地讲清楚 Java 的 HashMap，包括 hash 方法的原理、HashMap 的扩容机制、HashMap的加载因子为什么是 0.75 而不是 0.6、0.8，以及 HashMap 为什么是线程不安全的，基本上 HashMap 的常见面试题，都会在这一篇文章里讲明白。
 HashMap 是 Java 中常用的数据结构之一，用于存储键值对。在 HashMap 中，每个键都映射到一个唯一的值，可以通过键来快速访问对应的值。
 HashMap 不仅在日常开发中经常用到，在面试中也是重点考察的对象。
 以下是 HashMap 增删改查的简单例子：
1）增加元素：
 将一个键值对（元素）添加到 HashMap 中，可以使用 put() 方法。例如，将名字和年龄作为键值对添加到 HashMap 中：
123HashMap&lt;String, Integer&gt; map &#x3D; new HashMap&lt;&gt;();map.put(&quot;沉默&quot;, 20);map.put(&quot;王二&quot;, 25);
2）删除元素：
 从 HashMap 中删除一个键值对，可以使用 remove() 方法。例如，删除名字为 “沉默” 的键值对：
1map.remove(&quot;沉默&quot;);
 3）修改元素：
 修改 HashMap 中的一个键值对，可以使用 put() 方法。例如，将名字为 “沉默” 的年龄修改为 30：
1map.put(&quot;沉默&quot;, 30);
 为什么和添加元素的方法一样呢？这个我们后面会讲，先简单说一下，是因为 HashMap 的键是唯一的，所以再次 put 的时候会覆盖掉之前的键值对。
4）查找元素：
 从 HashMap 中查找一个键对应的值，可以使用 get() 方法。例如，查找名字为 “沉默” 的年龄：
1int age &#x3D; map.get(&quot;沉默&quot;);
 在实际应用中，HashMap 可以用于缓存、索引等场景。例如，可以将用户 ID 作为键，用户信息作为值，将用户信息缓存到 HashMap 中，以便快速查找。又如，可以将关键字作为键，文档 ID 列表作为值，将文档索引缓存到 HashMap 中，以便快速搜索文档。
 HashMap 的实现原理是基于哈希表的，它的底层是一个数组，数组的每个位置可能是一个链表或红黑树，也可能只是一个键值对（后面会讲）。当添加一个键值对时，HashMap 会根据键的哈希值计算出该键对应的数组下标（索引），然后将键值对插入到对应的位置。
当通过键查找值时，HashMap 也会根据键的哈希值计算出数组下标，并查找对应的值。
01、hash方法的原理 
 简单了解 HashMap 后，我们来讨论第一个问题：hash 方法的原理，对吃透 HashMap 会大有帮助。
 来看一下 hash 方法的源码（JDK 8 中的 HashMap）：
1234static final int hash(Object key) {    int h;    return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);}
 这段代码究竟是用来干嘛的呢？
 将 key 的 hashCode 值进行处理，得到最终的哈希值。
 怎么理解这句话呢？不要着急。
 我们来 new 一个 HashMap，并通过 put 方法添加一个元素。
12HashMap&lt;String, String&gt; map &#x3D; new HashMap&lt;&gt;();map.put(&quot;chenmo&quot;, &quot;沉默&quot;);
 来看一下 put 方法的源码。
123public V put(K key, V value) {    return putVal(hash(key), key, value, false, true);}
 看到 hash 方法的身影了吧？
hash 方法的作用 
 前面也说了，HashMap 的底层是通过数组的形式实现的，初始大小是 16（这个后面会讲），先记住。
 也就是说，HashMap 在添加第一个元素的时候，需要通过键的哈希码在大小为 16 的数组中确定一个位置（索引），怎么确定呢？
 为了方便大家直观的感受，我这里画了一副图，16 个方格子（可以把它想象成一个一个桶），每个格子都有一个编号，对应大小为 16 的数组下标（索引）。

 现在，我们要把 key 为 “chenmo”，value 为“沉默”的键值对放到这 16 个格子中的一个。
 怎么确定位置（索引）呢？
 我先告诉大家结论，通过这个与运算 (n - 1) &amp; hash ，其中变量 n 为数组的长度，变量 hash 就是通过 hash() 方法计算后的结果。
 那“chenmo”这个 key 计算后的位置（索引）是多少呢？
 答案是 8，也就是说 map.put(“chenmo”, “沉默”) 会把key 为 “chenmo”，value 为“沉默”的键值对放到下标为 8 的位置上（也就是索引为 8 的桶上）。

 这样大家就会对 HashMap 存放键值对（元素）的时候有一个大致的印象。其中的一点是，hash 方法对计算键值对的位置起到了至关重要的作用。
 回到 hash 方法：
1234static final int hash(Object key) {    int h;    return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);}
 下面是对该方法的一些解释：

参数 key：需要计算哈希码的键值。
key &#x3D;&#x3D; null ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16) ：这是一个三目运算符，如果键值为null，则哈希码为0（依旧是说如果键为 null，则存放在第一个位置）；否则，通过调用 hashCode()方法获取键的哈希码，并将其与右移16位的哈希码进行异或运算。
^ 运算符：异或运算符是Java中的一种位运算符，它用于将两个数的二进制位进行比较，如果相同则为0，不同则为1。
h &gt;&gt;&gt; 16 ：将哈希码向右移动16位，相当于将原来的哈希码分成了两个16位的部分。
最终返回的是经过异或运算后得到的哈希码值。
这短短的一行代码，汇聚不少计算机巨佬们的聪明才智。
理论上，哈希值（哈希码）是一个 int 类型，范围从-2147483648 到 2147483648。前后加起来大概 40 亿的映射空间，只要哈希值映射得比较均匀松散，一般是不会出现哈希碰撞（哈希冲突会降低 HashMap 的效率）。
但问题是一个 40 亿长度的数组，内存是放不下的。HashMap 扩容之前的数组初始大小只有 16，所以这个哈希值是不能直接拿来用的，用之前要和数组的长度做取模运算（前文提到的 (n - 1) &amp; hash ），用得到的余数来访问数组下标才行。
取模运算 
取模运算（（“Modulo Operation”））和取余运算（（“Remainder Operation ”））是两种不同的运算方式，它们在计算机中的实现也不同。
在数学中，取模运算和取余运算是等价的，都是计算一个数除以另一个数的余数。例如，10 mod 3 和 10 % 3 都等于 1，因为 10 除以 3 的余数是 1。
在计算机中，取模运算和取余运算的差别在于，当被除数为负数时，取模运算的结果符号与被除数相同，取余运算的结果符号与除数相同。
例如，-10 mod 3 的结果是 -1，而 -10 % 3 的结果是 2，因为 -10 除以 3 的余数是 -1，所以 -10 取模 3 的结果应该是 -1；而 -10 对 3 取余的结果是 2，因为：-10 ÷ 3 &#x3D; -3 余 -1，由于除数为正数 3，余数的符号应与被除数的符号相同，因此余数应为正数 2，而不是 -1。
在 Java 中，取模运算使用 % 运算符，取余运算使用 Math.floorMod() 方法。例如，计算 -10 mod 3 和 -10 % 3 的结果：


12int a &#x3D; -10 % 3; &#x2F;&#x2F; a &#x3D; -1int b &#x3D; Math.floorMod(-10, 3); &#x2F;&#x2F; b &#x3D; 2
 需要注意的是，在数学中，取模运算和取余运算都有定义域的限制，即除数不能为 0。在计算机中，除数为 0 会抛出异常或返回 NaN（Not a Number）。
 HashMap 的取模运算有两处。
 一处是往 HashMap 中 put 的时候（会调用私有的 putVal 方法）：
123456789101112131415 final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) {    &#x2F;&#x2F; 数组    HashMap.Node&lt;K,V&gt;[] tab;     &#x2F;&#x2F; 元素    HashMap.Node&lt;K,V&gt; p;     &#x2F;&#x2F; n 为数组的长度 i 为下标    int n, i;    &#x2F;&#x2F; 数组为空的时候    if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)        &#x2F;&#x2F; 第一次扩容后的数组长度        n &#x3D; (tab &#x3D; resize()).length;    &#x2F;&#x2F; 计算节点的插入位置，如果该位置为空，则新建一个节点插入    if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null)        tab[i] &#x3D; newNode(hash, key, value, null);}
 其中 (n - 1) &amp; hash 为取模运算，为什么没用 % ，我们随后解释。
 一处是从 HashMap 中 get 的时候（会调用 getNode 方法）：
123456789101112131415161718192021222324final Node&lt;K,V&gt; getNode(int hash, Object key) {    &#x2F;&#x2F; 获取当前的数组和长度，以及当前节点链表的第一个节点（根据索引直接从数组中找）    Node&lt;K,V&gt;[] tab;     Node&lt;K,V&gt; first, e;     int n;     K k;    if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;            (first &#x3D; tab[(n - 1) &amp; hash]) !&#x3D; null) {        &#x2F;&#x2F; 如果第一个节点就是要查找的节点，则直接返回        if (first.hash &#x3D;&#x3D; hash &amp;&amp; ((k &#x3D; first.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))            return first;        &#x2F;&#x2F; 如果第一个节点不是要查找的节点，则遍历节点链表查找        if ((e &#x3D; first.next) !&#x3D; null) {            do {                if (e.hash &#x3D;&#x3D; hash &amp;&amp; ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))                    return e;            } while ((e &#x3D; e.next) !&#x3D; null);        }    }    &#x2F;&#x2F; 如果节点链表中没有找到对应的节点，则返回 null    return null;}
 看到没，取模运算 (n - 1) &amp; hash 再次出现，说简单点，就是把键的哈希码经过 hash() 方法计算后，再和（数组长度-1）做了一个“与”运算。
 取模运算%和位运算&amp; 
 可能大家在疑惑：取模运算难道不该用 %吗？为什么要用位运算 &amp;呢？
 这是因为 &amp; 运算比 % 更加高效，并且当 b 为 2 的 n 次方时，存在下面这样一个公式。

a % b &#x3D; a &amp; (b-1)

 用 $2^n$ 替换下 b 就是：

a % $2^n$ &#x3D; a &amp; ($2^n$-1)

 我们来验证一下，假如 a &#x3D; 14，b &#x3D; 8，也就是 $2^3$，n&#x3D;3。
 14%8（余数为 6）。
 14 的二进制为 1110，8 的二进制 1000，8-1 &#x3D; 7，7 的二进制为 0111，1110&amp;0111&#x3D;0110，也就是 0  $2^0$+1  $2^1$+1  $2^2$+0  $2^3$&#x3D;0+2+4+0&#x3D;6，14%8 刚好也等于 6。
 害，计算机就是这么讲道理，没办法
 这也正好解释了为什么 HashMap 的数组长度要取 2 的整次方。
 为什么会这样巧呢？
 因为（数组长度-1）正好相当于一个“低位掩码”——这个掩码的低位最好全是 1，这样 &amp; 操作才有意义，否则结果就肯定是 0，那么 &amp; 操作就没有意义了。

a&amp;b 操作的结果是：a、b 中对应位同时为 1，则对应结果位为 1，否则为 0

 2 的整次幂刚好是偶数，偶数-1 是奇数，奇数的二进制最后一位是 1，保证了 hash &amp;(length-1) 的最后一位可能为 0，也可能为 1（这取决于 h 的值），即 &amp; 运算后的结果可能为偶数，也可能为奇数，这样便可以保证哈希值的均匀性。
 &amp; 操作的结果就是将哈希值的高位全部归零，只保留低位值，用来做数组下标访问。
 假设某哈希值为 10100101 11000100 00100101 ，用它来做取模运算，我们来看一下结果。HashMap 的初始长度为 16（内部是数组），16-1&#x3D;15，二进制是 00000000 00000000 00001111 （高位用 0 来补齐）：
1234    10100101 11000100 00100101&amp;   00000000 00000000 00001111----------------------------------    00000000 00000000 00000101
 因为 15 的高位全部是 0，所以 &amp; 运算后的高位结果肯定是 0，只剩下 4 个低位 0101 ，也就是十进制的 5，也就是将哈希值为 10100101 11000100 00100101 的键放在数组的第 5 位。
 当然了，如果你是新手，上面这些 01 串没看懂，也没关系，记住取模运算就行了，记不住取模运算也没关系，记住取模运算是为了计算数组的下标就可以了。

put 的时候计算下标，把键值对放到对应的桶上。
get 的时候通过下标，把键值对从对应的桶上取出来。
为什么取模运算之前要调用 hash 方法呢？ 
看下面这个图。



某哈希值为 11111111 11111111 11110000 1110 1010 ，将它右移 16 位（h &gt;&gt;&gt; 16），刚好是 00000000 00000000 11111111 11111111 ，再进行异或操作（h ^ (h &gt;&gt;&gt; 16)），结果是 11111111 11111111 00001111 00010101

异或（ ^ ）运算是基于二进制的位运算，采用符号 XOR 或者 ^来表示，运算规则是：如果是同值取 0、异值取 1

由于混合了原来哈希值的高位和低位，所以低位的随机性加大了（掺杂了部分高位的特征，高位的信息也得到了保留）。
结果再与数组长度-1（ 00000000 00000000 00000000 00001111 ）做取模运算，得到的下标就是 00000000 00000000 00000000 00000101 ，也就是 5。
还记得之前我们假设的某哈希值 10100101 11000100 00100101 吗？在没有调用 hash 方法之前，与 15 做取模运算后的结果也是 5，我们不妨来看看调用 hash 之后的取模运算结果是多少。
某哈希值 00000000 10100101 11000100 00100101 （补齐 32 位），将它右移 16 位（h &gt;&gt;&gt; 16），刚好是 00000000 00000000 00000000 10100101 ，再进行异或操作（h ^ (h &gt;&gt;&gt; 16)），结果是 00000000 10100101 00111011 10000000
结果再与数组长度-1（ 00000000 00000000 00000000 00001111 ）做取模运算，得到的下标就是 00000000 00000000 00000000 00000000 ，也就是 0。
综上所述，hash 方法是用来做哈希值优化的，把哈希值右移 16 位，也就正好是自己长度的一半，之后与原哈希值做异或运算，这样就混合了原哈希值中的高位和低位，增大了随机性。
说白了，hash 方法就是为了增加随机性，让数据元素更加均衡的分布，减少碰撞。
我这里写了一段测试代码，假如 HashMap 的容量就是第一次扩容时候的 16，我在里面放了五个键值对，来看一下键的 hash 值（经过 
1234567891011121314HashMap&lt;String, String&gt; map &#x3D; new HashMap&lt;&gt;();map.put(&quot;chenmo&quot;, &quot;沉默&quot;);map.put(&quot;wanger&quot;, &quot;王二&quot;);map.put(&quot;chenqingyang&quot;, &quot;陈清扬&quot;);map.put(&quot;xiaozhuanling&quot;, &quot;小转铃&quot;);map.put(&quot;fangxiaowan&quot;, &quot;方小婉&quot;);&#x2F;&#x2F; 遍历 HashMapfor (String key : map.keySet()) {    int h, n &#x3D; 16;    int hash &#x3D; (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);    int i &#x3D; (n - 1) &amp; hash;    &#x2F;&#x2F; 打印 key 的 hash 值 和 索引 i    System.out.println(key + &quot;的hash值 : &quot; + hash +&quot; 的索引 : &quot; + i);}
输出结果如下所示：
12345xiaozhuanling的hash值 : 14597045 的索引 : 5fangxiaowan的hash值 : -392727066 的索引 : 6chenmo的hash值 : -1361556696 的索引 : 8chenqingyang的hash值 : -613818743 的索引 : 9wanger的hash值 : -795084437 的索引 : 11
也就是说，此时还没有发生哈希冲突，索引值都是比较均匀分布的，5、6、8、9、11，这其中的很大一部分功劳，就来自于 hash 方法。
小结 
hash 方法的主要作用是将 key 的 hashCode 值进行处理，得到最终的哈希值。由于 key 的 hashCode 值是不确定的，可能会出现哈希冲突，因此需要将哈希值通过一定的算法映射到 HashMap 的实际存储位置上。
hash 方法的原理是，先获取 key 对象的 hashCode 值，然后将其高位与低位进行异或操作，得到一个新的哈希值。为什么要进行异或操作呢？因为对于 hashCode 的高位和低位，它们的分布是比较均匀的，如果只是简单地将它们加起来或者进行位运算，容易出现哈希冲突，而异或操作可以避免这个问题。
然后将新的哈希值取模（mod），得到一个实际的存储位置。这个取模操作的目的是将哈希值映射到桶（Bucket）的索引上，桶是 HashMap 中的一个数组，每个桶中会存储着一个链表（或者红黑树），装载哈希值相同的键值对（没有相同哈希值的话就只存储一个键值对）。
总的来说，HashMap 的 hash 方法就是将 key 对象的 hashCode 值进行处理，得到最终的哈希值，并通过一定的算法映射到实际的存储位置上。这个过程决定了 HashMap 内部键值对的查找效率。
02、HashMap的扩容机制 
好，理解了 hash 方法后我们来看第二个问题，HashMap 的扩容机制。
大家都知道，数组一旦初始化后大小就无法改变了，所以就有了 ArrayList这种“动态数组”，可以自动扩容。
HashMap 的底层用的也是数组。向 HashMap 里不停地添加元素，当数组无法装载更多元素时，就需要对数组进行扩容，以便装入更多的元素；除此之外，容量的提升也会相应地提高查询效率，因为“桶（坑）”更多了嘛，原来需要通过链表存储的（查询的时候需要遍历），扩容后可能就有自己专属的“坑位”了（直接就能查出来）。
来看这个例子，容量我们定位 16：
1234567891011121314151617HashMap&lt;String, String&gt; map &#x3D; new HashMap&lt;&gt;();map.put(&quot;chenmo&quot;, &quot;沉默&quot;);map.put(&quot;wanger&quot;, &quot;王二&quot;);map.put(&quot;chenqingyang&quot;, &quot;陈清扬&quot;);map.put(&quot;xiaozhuanling&quot;, &quot;小转铃&quot;);map.put(&quot;fangxiaowan&quot;, &quot;方小婉&quot;);map.put(&quot;yexin&quot;, &quot;叶辛&quot;);map.put(&quot;liuting&quot;,&quot;刘婷&quot;);map.put(&quot;yaoxiaojuan&quot;,&quot;姚小娟&quot;);&#x2F;&#x2F; 遍历 HashMapfor (String key : map.keySet()) {    int h, n &#x3D; 16;    int hash &#x3D; (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);    int i &#x3D; (n - 1) &amp; hash;    &#x2F;&#x2F; 打印 key 的 hash 值 和 索引 i    System.out.println(key + &quot;的hash值 : &quot; + hash +&quot; 的索引 : &quot; + i);}
来看输出结果：
12345678liuting的hash值 : 183821170 的索引 : 2xiaozhuanling的hash值 : 14597045 的索引 : 5fangxiaowan的hash值 : -392727066 的索引 : 6yaoxiaojuan的hash值 : 1231568918 的索引 : 6chenmo的hash值 : -1361556696 的索引 : 8chenqingyang的hash值 : -613818743 的索引 : 9yexin的hash值 : 114873289 的索引 : 9wanger的hash值 : -795084437 的索引 : 11
看到没？

fangxiaowan（方小婉）和 yaoxiaojuan（姚小娟）的索引都是 6；
chenqingyang（陈清扬）和yexin（叶辛）的索引都是 9

这就意味着，要采用拉链法（后面会讲）将他们放在同一个索引的链表上。查询的时候，就不能直接通过索引的方式直接拿到（时间复杂度为 O(1)），而要通过遍历的方式（时间复杂度为 O(n)）。
那假如把数组的长度由 16 扩容为 32 呢？
将之前示例中的 n 由 16 改为 32 即可得到如下的答案：
12345678liuting的hash值 : 183821170 的索引 : 18xiaozhuanling的hash值 : 14597045 的索引 : 21fangxiaowan的hash值 : -392727066 的索引 : 6yaoxiaojuan的hash值 : 1231568918 的索引 : 22chenmo的hash值 : -1361556696 的索引 : 8chenqingyang的hash值 : -613818743 的索引 : 9yexin的hash值 : 114873289 的索引 : 9wanger的hash值 : -795084437 的索引 : 11
可以看到：

虽然chenqingyang（陈清扬）和yexin（叶辛）的索引仍然是 9。
但 fangxiaowan（方小婉）的索引为 6，yaoxiaojuan（姚小娟）的索引由 6 变为 22，各自都有坑了。

当然了，数组是无法自动扩容的，所以如果要扩容的话，就需要新建一个大的数组，然后把之前小的数组的元素复制过去，并且要重新计算哈希值和重新分配桶（重新散列），这个过程也是挺耗时的。
resize方法 
HashMap 的扩容是通过 resize 方法来实现的，JDK 8 中融入了红黑树（链表长度超过 8 的时候，会将链表转化为红黑树来提高查询效率），对于新手来说，可能比较难理解。
为了减轻大家的学习压力，就还使用 JDK 7 的源码，搞清楚了 JDK 7 的，再看 JDK 8 的就会轻松很多。
来看 Java7 的 resize 方法源码，我加了注释：
123456789101112131415161718192021&#x2F;&#x2F; newCapacity为新的容量void resize(int newCapacity) {    &#x2F;&#x2F; 小数组，临时过度下    Entry[] oldTable &#x3D; table;    &#x2F;&#x2F; 扩容前的容量    int oldCapacity &#x3D; oldTable.length;    &#x2F;&#x2F; MAXIMUM_CAPACITY 为最大容量，2 的 30 次方 &#x3D; 1&lt;&lt;30    if (oldCapacity &#x3D;&#x3D; MAXIMUM_CAPACITY) {        &#x2F;&#x2F; 容量调整为 Integer 的最大值 0x7fffffff（十六进制）&#x3D;2 的 31 次方-1        threshold &#x3D; Integer.MAX_VALUE;        return;    }    &#x2F;&#x2F; 初始化一个新的数组（大容量）    Entry[] newTable &#x3D; new Entry[newCapacity];    &#x2F;&#x2F; 把小数组的元素转移到大数组中    transfer(newTable, initHashSeedAsNeeded(newCapacity));    &#x2F;&#x2F; 引用新的大数组    table &#x3D; newTable;    &#x2F;&#x2F; 重新计算阈值    threshold &#x3D; (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);}
该方法接收一个新的容量 newCapacity，然后将 HashMap 的容量扩大到 newCapacity。
首先，方法获取当前 HashMap 的旧数组 oldTable 和旧容量 oldCapacity。如果旧容量已经达到 HashMap 支持的最大容量 MAXIMUM_CAPACITY（ 2 的 30 次方），就将新的阈值 threshold 调整为 Integer.MAX_VALUE（2 的 31 次方 - 1），这是因为 HashMap 的容量不能超过 MAXIMUM_CAPACITY。
因为 2,147,483,647（Integer.MAX_VALUE） - 1,073,741,824（MAXIMUM_CAPACITY） &#x3D; 1,073,741,823，刚好相差一倍（HashMap 每次扩容都是之前的一倍）。
接着，方法创建一个新的数组 newTable，并将旧数组 oldTable 中的元素转移到新数组 newTable 中。转移过程是通过调用 transfer 方法来实现的。该方法遍历旧数组中的每个桶，并将每个桶中的键值对重新计算哈希值后，将其插入到新数组对应的桶中。
转移完成后，方法将 HashMap 内部的数组引用 table 指向新数组 newTable，并重新计算阈值 threshold。新的阈值是新容量 newCapacity 乘以负载因子 loadFactor 的结果，但如果计算结果超过了 HashMap 支持的最大容量 MAXIMUM_CAPACITY，则将阈值设置为 MAXIMUM_CAPACITY + 1，这是因为 HashMap 的元素数量不能超过 MAXIMUM_CAPACITY。
新容量newCapacity 
那 newCapacity 是如何计算的呢？
123456int newCapacity &#x3D; oldCapacity * 2;if (newCapacity &lt; 0 || newCapacity &gt;&#x3D; MAXIMUM_CAPACITY) {    newCapacity &#x3D; MAXIMUM_CAPACITY;} else if (newCapacity &lt; DEFAULT_INITIAL_CAPACITY) {    newCapacity &#x3D; DEFAULT_INITIAL_CAPACITY;}
新容量 newCapacity 被初始化为原容量 oldCapacity 的两倍。然后，如果 newCapacity 超过了 HashMap 的容量限制 MAXIMUM_CAPACITY（2^30），就将 newCapacity 设置为 MAXIMUM_CAPACITY。如果 newCapacity 小于默认初始容量 DEFAULT_INITIAL_CAPACITY（16），就将 newCapacity 设置为 DEFAULT_INITIAL_CAPACITY。这样可以避免新容量太小或太大导致哈希冲突过多或者浪费空间。
Java 8 的时候，newCapacity 的计算方式发生了一些细微的变化。
123456789int newCapacity &#x3D; oldCapacity &lt;&lt; 1;if (newCapacity &gt;&#x3D; DEFAULT_INITIAL_CAPACITY &amp;&amp; oldCapacity &gt;&#x3D; DEFAULT_INITIAL_CAPACITY) {    if (newCapacity &gt; MAXIMUM_CAPACITY)        newCapacity &#x3D; MAXIMUM_CAPACITY;} else {    if (newCapacity &lt; DEFAULT_INITIAL_CAPACITY)        newCapacity &#x3D; DEFAULT_INITIAL_CAPACITY;}
注意， oldCapacity * 2 变成了 oldCapacity &lt;&lt; 1 ，出现了左移（ &lt;&lt; ），这里简单介绍一下：
12a&#x3D;39b &#x3D; a &lt;&lt; 2
十进制 39 用 8 位的二进制来表示，就是 00100111，左移两位后是 10011100（低位用 0 补上），再转成十进制数就是 156。
移位运算通常可以用来代替乘法运算和除法运算。例如，将 0010011（39）左移两位就是 10011100（156），刚好变成了原来的 4 倍。
实际上呢，二进制数左移后会变成原来的 2 倍、4 倍、8 倍，记住这个就好。
transfer方法 
接下来，来说 transfer 方法，该方法用来转移，将旧的小数组元素拷贝到新的大数组中。
1234567891011121314151617181920212223void transfer(Entry[] newTable, boolean rehash) {    &#x2F;&#x2F; 新的容量    int newCapacity &#x3D; newTable.length;    &#x2F;&#x2F; 遍历小数组    for (Entry&lt;K,V&gt; e : table) {        while(null !&#x3D; e) {            &#x2F;&#x2F; 拉链法，相同 key 上的不同值            Entry&lt;K,V&gt; next &#x3D; e.next;            &#x2F;&#x2F; 是否需要重新计算 hash            if (rehash) {                e.hash &#x3D; null &#x3D;&#x3D; e.key ? 0 : hash(e.key);            }            &#x2F;&#x2F; 根据大数组的容量，和键的 hash 计算元素在数组中的下标            int i &#x3D; indexFor(e.hash, newCapacity);            &#x2F;&#x2F; 同一位置上的新元素被放在链表的头部            e.next &#x3D; newTable[i];            &#x2F;&#x2F; 放在新的数组上            newTable[i] &#x3D; e;            &#x2F;&#x2F; 链表上的下一个元素            e &#x3D; next;        }    }}
该方法接受一个新的 Entry 数组 newTable 和一个布尔值 rehash 作为参数，其中 newTable 表示新的哈希表，rehash 表示是否需要重新计算键的哈希值。
在方法中，首先获取新哈希表（数组）的长度 newCapacity，然后遍历旧哈希表中的每个 Entry。对于每个 Entry，使用拉链法将相同 key 值的不同 value 值存储在同一个链表中。如果 rehash 为 true，则需要重新计算键的哈希值，并将新的哈希值存储在 Entry 的 hash 属性中。
接着，根据新哈希表的长度和键的哈希值，计算 Entry 在新数组中的位置 i，然后将该 Entry 添加到新数组的 i 位置上。由于新元素需要被放在链表的头部，因此将新元素的下一个元素设置为当前数组位置上的元素。
最后，遍历完旧哈希表中的所有元素后，转移工作完成，新的哈希表 newTable 已经包含了旧哈希表中的所有元素。
拉链法 
注意， e.next &#x3D; newTable[i] ，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素最终会被放到链表的尾部，这就会导致在旧数组中同一个链表上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。
就这点上，Java 8 做了很大的优化（下面会讲）。
现在假设 hash 算法就是简单的用键的哈希值（一个 int 值）和数组大小取模（也就是 hashCode % table.length ）。
继续假设：

数组 table 的长度为 2
键的哈希值为 3、7、5

取模运算后，哈希冲突都到 table[1] 上了，因为余数为 1。那么扩容前的样子如下图所示。

数组的容量为 2， key 3、7、5 都在 table[1] 的链表上。
假设负载因子（后面会细讲） loadFactor 为 1，也就是当元素的个数大于 table 的长度时进行扩容。
扩容后的数组容量为 4。

key 3 取模（3%4）后是 3，放在 table[3] 上。
key 7 取模（7%4）后是 3，放在 table[3] 上的链表头部。
key 5 取模（5%4）后是 1，放在 table[1] 上。


按照我们的预期，扩容后的 7 仍然应该在 3 这条链表的后面，但实际上呢？ 7 跑到 3 这条链表的头部了。
针对 JDK 7 中的这个情况，JDK 8 做了哪些优化呢？
看下面这张图。

n 为 table 的长度，默认值为 16。

n-1 也就是二进制的 0000 1111（1X$2^0$+1X$2^1$+1X$2^2$+1X$2^3$&#x3D;1+2+4+8&#x3D;15）；
key1 哈希值的最后 8 位为 0000 0101
key2 哈希值的最后 8 位为 0001 0101（和 key1 不同）
做与运算后发生了哈希冲突，索引都在（0000 0101）上。

扩容后为 32。

n-1 也就是二进制的 0001 1111（1X$2^0$+1X$2^1$+1X$2^2$+1X$2^3$+1X$2^4$&#x3D;1+2+4+8+16&#x3D;31），扩容前是 0000 1111。
key1 哈希值的低位为 0000 0101
key2 哈希值的低位为 0001 0101（和 key1 不同）
key1 做与运算后，索引为 0000 0101。
key2 做与运算后，索引为 0001 0101。

新的索引就会发生这样的变化：

原来的索引是 5（0 0101）
原来的容量是 16
扩容后的容量是 32
扩容后的索引是 21（1 0101），也就是 5+16，也就是原来的索引+原来的容量


也就是说，JDK 8 不需要像 JDK 7 那样重新计算 hash，只需要看原来的hash值新增的那个bit是1还是0就好了，是0的话就表示索引没变，是1的话，索引就变成了“原索引+原来的容量”。

JDK 8 的这个设计非常巧妙，既省去了重新计算hash的时间，同时，由于新增的1 bit是0还是1是随机的，因此扩容的过程，可以均匀地把之前的节点分散到新的位置上。
woc，只能说 HashMap 的作者 Doug Lea、Josh Bloch、Arthur van Hoff、Neal Gafter 真的强——的一笔。
Java 8 扩容 
JDK 8 的扩容源代码：
1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374final Node&lt;K,V&gt;[] resize() {    Node&lt;K,V&gt;[] oldTab &#x3D; table; &#x2F;&#x2F; 获取原来的数组 table    int oldCap &#x3D; (oldTab &#x3D;&#x3D; null) ? 0 : oldTab.length; &#x2F;&#x2F; 获取数组长度 oldCap    int oldThr &#x3D; threshold; &#x2F;&#x2F; 获取阈值 oldThr    int newCap, newThr &#x3D; 0;    if (oldCap &gt; 0) { &#x2F;&#x2F; 如果原来的数组 table 不为空        if (oldCap &gt;&#x3D; MAXIMUM_CAPACITY) { &#x2F;&#x2F; 超过最大值就不再扩充了，就只好随你碰撞去吧            threshold &#x3D; Integer.MAX_VALUE;            return oldTab;        }        else if ((newCap &#x3D; oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; &#x2F;&#x2F; 没超过最大值，就扩充为原来的2倍                 oldCap &gt;&#x3D; DEFAULT_INITIAL_CAPACITY)            newThr &#x3D; oldThr &lt;&lt; 1; &#x2F;&#x2F; double threshold    }    else if (oldThr &gt; 0) &#x2F;&#x2F; initial capacity was placed in threshold        newCap &#x3D; oldThr;    else { &#x2F;&#x2F; zero initial threshold signifies using defaults        newCap &#x3D; DEFAULT_INITIAL_CAPACITY;        newThr &#x3D; (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);    }    &#x2F;&#x2F; 计算新的 resize 上限    if (newThr &#x3D;&#x3D; 0) {        float ft &#x3D; (float)newCap * loadFactor;        newThr &#x3D; (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?                  (int)ft : Integer.MAX_VALUE);    }    threshold &#x3D; newThr; &#x2F;&#x2F; 将新阈值赋值给成员变量 threshold    @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})        Node&lt;K,V&gt;[] newTab &#x3D; (Node&lt;K,V&gt;[])new Node[newCap]; &#x2F;&#x2F; 创建新数组 newTab    table &#x3D; newTab; &#x2F;&#x2F; 将新数组 newTab 赋值给成员变量 table    if (oldTab !&#x3D; null) { &#x2F;&#x2F; 如果旧数组 oldTab 不为空        for (int j &#x3D; 0; j &lt; oldCap; ++j) { &#x2F;&#x2F; 遍历旧数组的每个元素            Node&lt;K,V&gt; e;            if ((e &#x3D; oldTab[j]) !&#x3D; null) { &#x2F;&#x2F; 如果该元素不为空                oldTab[j] &#x3D; null; &#x2F;&#x2F; 将旧数组中该位置的元素置为 null，以便垃圾回收                if (e.next &#x3D;&#x3D; null) &#x2F;&#x2F; 如果该元素没有冲突                    newTab[e.hash &amp; (newCap - 1)] &#x3D; e; &#x2F;&#x2F; 直接将该元素放入新数组                else if (e instanceof TreeNode) &#x2F;&#x2F; 如果该元素是树节点                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); &#x2F;&#x2F; 将该树节点分裂成两个链表                else { &#x2F;&#x2F; 如果该元素是链表                    Node&lt;K,V&gt; loHead &#x3D; null, loTail &#x3D; null; &#x2F;&#x2F; 低位链表的头结点和尾结点                    Node&lt;K,V&gt; hiHead &#x3D; null, hiTail &#x3D; null; &#x2F;&#x2F; 高位链表的头结点和尾结点                    Node&lt;K,V&gt; next;                    do { &#x2F;&#x2F; 遍历该链表                        next &#x3D; e.next;                        if ((e.hash &amp; oldCap) &#x3D;&#x3D; 0) { &#x2F;&#x2F; 如果该元素在低位链表中                            if (loTail &#x3D;&#x3D; null) &#x2F;&#x2F; 如果低位链表还没有结点                                loHead &#x3D; e; &#x2F;&#x2F; 将该元素作为低位链表的头结点                            else                                loTail.next &#x3D; e; &#x2F;&#x2F; 如果低位链表已经有结点，将该元素加入低位链表的尾部                            loTail &#x3D; e; &#x2F;&#x2F; 更新低位链表的尾结点                        }                        else { &#x2F;&#x2F; 如果该元素在高位链表中                            if (hiTail &#x3D;&#x3D; null) &#x2F;&#x2F; 如果高位链表还没有结点                                hiHead &#x3D; e; &#x2F;&#x2F; 将该元素作为高位链表的头结点                            else                                hiTail.next &#x3D; e; &#x2F;&#x2F; 如果高位链表已经有结点，将该元素加入高位链表的尾部                            hiTail &#x3D; e; &#x2F;&#x2F; 更新高位链表的尾结点                        }                    } while ((e &#x3D; next) !&#x3D; null); &#x2F;&#x2F;                    if (loTail !&#x3D; null) { &#x2F;&#x2F; 如果低位链表不为空                        loTail.next &#x3D; null; &#x2F;&#x2F; 将低位链表的尾结点指向 null，以便垃圾回收                        newTab[j] &#x3D; loHead; &#x2F;&#x2F; 将低位链表作为新数组对应位置的元素                    }                    if (hiTail !&#x3D; null) { &#x2F;&#x2F; 如果高位链表不为空                        hiTail.next &#x3D; null; &#x2F;&#x2F; 将高位链表的尾结点指向 null，以便垃圾回收                        newTab[j + oldCap] &#x3D; hiHead; &#x2F;&#x2F; 将高位链表作为新数组对应位置的元素                    }                }            }        }    }    return newTab; &#x2F;&#x2F; 返回新数组}
1、获取原来的数组 table、数组长度 oldCap 和阈值 oldThr。
2、如果原来的数组 table 不为空，则根据扩容规则计算新数组长度 newCap 和新阈值 newThr，然后将原数组中的元素复制到新数组中。
3、如果原来的数组 table 为空但阈值 oldThr 不为零，则说明是通过带参数构造函数创建的 HashMap，此时将阈值作为新数组长度 newCap。
4、如果原来的数组 table 和阈值 oldThr 都为零，则说明是通过无参数构造函数创建的 HashMap，此时将默认初始容量 DEFAULT_INITIAL_CAPACITY（16）和默认负载因子 DEFAULT_LOAD_FACTOR（0.75）计算出新数组长度 newCap 和新阈值 newThr。
5、计算新阈值 threshold，并将其赋值给成员变量 threshold。
6、创建新数组 newTab，并将其赋值给成员变量 table。
7、如果旧数组 oldTab 不为空，则遍历旧数组的每个元素，将其复制到新数组中。
8、返回新数组 newTab。
小结 
HashMap 的内部实现是通过一个数组和链表或红黑树的组合来实现的。当我们往 HashMap 中不断添加元素时，HashMap 会自动进行扩容操作（条件是元素数量达到负载因子（load factor）乘以数组长度时），以保证其存储的元素数量不会超出其容量限制。下面是 HashMap 的扩容机制：
1、在进行扩容操作时，HashMap 会先将数组的长度扩大一倍，然后将原来的元素重新散列（这个词还是挺贴切的）到新的数组中。由于元素的散列位置是通过 key 的 hashcode 和数组长度取模得到的，因此在数组长度扩大后，元素的散列位置也会发生一些改变。
2、在重新散列元素时，如果一个元素的散列位置发生了改变，那么它需要被移动到新的位置。如果新的位置上已经有元素了，那么这个元素就会被添加到链表的末尾，如果链表的长度超过了阈值（8个），那么它将会被转换成红黑树。
总之，HashMap 的扩容机制是通过增加数组长度和重新散列元素来实现的，它可以保证 HashMap 的存储容量足够大，同时也可以保证 HashMap 的存储效率和检索效率。但是，由于扩容操作需要耗费一定的时间和空间，因此我们需要在使用 HashMap 时，合理地设置初始容量和负载因子，以避免过多的扩容操作。
03、加载因子为什么是0.75 
上一个问题提到了加载因子（或者叫负载因子），那么这个问题我们来讨论为什么加载因子是 0.75 而不是 0.6、0.8。
我们知道，HashMap 是用数组+链表&#x2F;红黑树实现的，我们要想往 HashMap 中添加数据（元素&#x2F;键值对）或者取数据，就需要确定数据在数组中的下标（索引）。
先把数据的键进行一次 hash：
1234static final int hash(Object key) {    int h;    return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);}
再做一次取模运算确定下标：
1i &#x3D; (n - 1) &amp; hash
那这样的过程容易产生两个问题：

数组的容量过小，经过哈希计算后的下标，容易出现冲突；
数组的容量过大，导致空间利用率不高。

加载因子是用来表示 HashMap 中数据的填满程度：

加载因子 &#x3D; 填入哈希表中的数据个数 &#x2F; 哈希表的长度

这就意味着：

加载因子越小，填满的数据就越少，哈希冲突的几率就减少了，但浪费了空间，而且还会提高扩容的触发几率；
加载因子越大，填满的数据就越多，空间利用率就高，但哈希冲突的几率就变大了。

好难！！！！
这就必须在“哈希冲突”与“空间利用率”两者之间有所取舍，尽量保持平衡，谁也不碍着谁。
我们知道，HashMap 是通过拉链法来解决哈希冲突的。
为了减少哈希冲突发生的概率，当 HashMap 的数组长度达到一个临界值的时候，就会触发扩容，扩容后会将之前小数组中的元素转移到大数组中，这是一个相当耗时的操作。
这个临界值由什么来确定呢？

临界值 &#x3D; 初始容量 * 加载因子

一开始，HashMap 的容量是 16：
1static final int DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4; &#x2F;&#x2F; aka 16
加载因子是 0.75：
1static final float DEFAULT_LOAD_FACTOR &#x3D; 0.75f;
也就是说，当 16*0.75&#x3D;12 时，会触发扩容机制。
为什么加载因子会选择 0.75 呢？为什么不是0.8、0.6呢？
这跟统计学里的一个很重要的原理——泊松分布有关。
是时候上维基百科了：

泊松分布，是一种统计与概率学里常见到的离散概率分布，由法国数学家西莫恩·德尼·泊松在1838年时提出。它会对随机事件的发生次数进行建模，适用于涉及计算在给定的时间段、距离、面积等范围内发生随机事件的次数的应用情形。

阮一峰老师曾在一篇博文中详细的介绍了泊松分布和指数分布，大家可以去看一下。

链接：https:&#x2F;&#x2F;www.ruanyifeng.com&#x2F;blog&#x2F;2015&#x2F;06&#x2F;poisson-distribution.html

具体是用这么一个公式来表示的。

P(N(t)&#x3D;n)&#x3D;\frac{(\lambda t)^ne^{-\lambda t}}{n!}等号的左边，P 表示概率，N表示某种函数关系，t 表示时间，n 表示数量。
在 HashMap 的 doc 文档里，曾有这么一段描述：
1234567891011121314151617181920212223Because TreeNodes are about twice the size of regular nodes, weuse them only when bins contain enough nodes to warrant use(see TREEIFY_THRESHOLD). And when they become too small (due toremoval or resizing) they are converted back to plain bins.  Inusages with well-distributed user hashCodes, tree bins arerarely used.  Ideally, under random hashCodes, the frequency ofnodes in bins follows a Poisson distribution(http:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Poisson_distribution) with aparameter of about 0.5 on average for the default resizingthreshold of 0.75, although with a large variance because ofresizing granularity. Ignoring variance, the expectedoccurrences of list size k are (exp(-0.5) * pow(0.5, k) &#x2F;factorial(k)). The first values are:0:    0.606530661:    0.303265332:    0.075816333:    0.012636064:    0.001579525:    0.000157956:    0.000013167:    0.000000948:    0.00000006more: less than 1 in ten million
为了便于大家的理解，这里来重温一下 HashMap 的拉链法和红黑树结构。
Java 8 之前，HashMap 使用链表来解决冲突，即当两个或者多个键映射到同一个桶时，它们被放在同一个桶的链表上。当链表上的节点（Node）过多时，链表会变得很长，查找的效率（LinkedList 的查找效率为 O（n））就会受到影响。
Java 8 中，当链表的节点数超过一个阈值（8）时，链表将转为红黑树（节点为TreeNode），红黑树（在讲TreeMap时会细说）是一种高效的平衡树结构，能够在 O(log n) 的时间内完成插入、删除和查找等操作。这种结构在节点数很多时，可以提高 HashMap 的性能和可伸缩性。好，有了这个背景，我们来把上面的 doc 文档翻译为中文：
1234567891011121314151617181920因为TreeNode（红黑树的节点）的大小大约是常规节点（链表的节点 Node）的两倍，所以只有当桶内包含足够多的节点时才使用红黑树（参见TREEIFY_THRESHOLD「阈值，值为8」，节点数量较多时，红黑树可以提高查询效率）。由于删除元素或者调整数组大小（扩容）时（再次散列），红黑树可能会被转换为链表（节点数量小于 8 时），节点数量较少时，链表的效率比红黑树更高，因为红黑树需要更多的内存空间来存储节点。在具有良好分布的hashCode使用中，很少使用红黑树。理想情况下，在随机hashCode下，节点在桶中的频率遵循泊松分布（https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;卜瓦松分布），平均缩放阈值为0.75，忽略方差，列表大小k的预期出现次数为（exp（-0.5）* pow（0.5，k）&#x2F; factorial（k））。前几个值是：0: 0.606530661: 0.303265332: 0.075816333: 0.012636064: 0.001579525: 0.000157956: 0.000013167: 0.000000948: 0.00000006更多：小于一千万分之一
虽然这段话的本意更多的是表示 jdk 8中为什么拉链长度超过8的时候进行了红黑树转换，但提到了 0.75 这个加载因子，但没提到底为什么。
为了搞清楚到底为什么，我看到了这篇文章：

参考链接：https:&#x2F;&#x2F;segmentfault.com&#x2F;a&#x2F;1190000023308658

里面提到了一个概念：二项分布（Binomial Distribution）。
在做一件事情的时候，其结果的概率只有2种情况，和抛硬币一样，不是正面就是反面。
假如，我们做了 N 次实验，那么在每次试验中只有两种可能的结果，并且每次实验是独立的，不同实验之间互不影响，每次实验成功的概率都是一样的。
以此理论为基础：我们往哈希表中扔数据，如果发生哈希冲突就为失败，否则为成功。
我们可以设想，实验的hash值是随机的，并且经过hash运算的键都会映射到hash表的地址空间上，那么这个结果也是随机的。所以，每次put的时候就相当于我们在扔一个16面（HashMap 第一次扩容后的数组默认长度为16）的骰子，扔骰子实验那肯定是相互独立的。碰撞发生即扔了n次有出现重复数字。
然后，我们的目的是啥呢？
就是掷了k次骰子，没有一次是相同的概率，需要尽可能的大些，一般意义上我们肯定要大于0.5（这个数是个理想数）。
于是，n次事件里面，碰撞为0的概率，由上面公式得：

binom(n,0)&#x3D;C_{n}^{0} \times (\frac{1}{s} )^0 \times (1-\frac{1}{s})^{n-0}&#x3D;(1-\frac{1}{s})^n这个概率值需要大于0.5，我们认为这样的hashmap可以提供很低的碰撞率。所以：
这时候，我们对于该公式其实最想求的时候长度s的时候，n为多少次就应该进行扩容了？而负载因子则是$n&#x2F;s$的值。所以推导如下：

\begin{align*}
&amp;nln(1-\frac{1}{s} )\ge -ln2...两边取对数\\
&amp;n\le \frac{-ln2}{ln(1-\frac{1}{s} )} \to n\le \frac{ln2}{ln\frac{s}{s-1} } ...提取n\\
&amp;\frac{n}{s} \le \frac{ln2}{sln\frac{s}{s-1} } ...两边除以s\\
\end{align*}所以可以得到

loadFactor&#x3D;\lim_{s \to \infty} \frac{ln2}{sln\frac{s}{s-1} }其中

\lim_{s \to \infty} \frac{ln2}{sln\frac{s}{s-1} }这就是一个求 ∞⋅0函数极限问题，这里我们先令$s &#x3D; m+1（m \to \infty）$则转化为

\lim_{m \to \infty} (m+1)ln(1+\frac{1}{m} )我们再令 $x &#x3D; \frac{1}{m} （x \to 0）$ 则有，

\begin{align*}
&amp;\lim_{s \to \infty} sln\frac{s}{s-1} &#x3D;\lim_{x \to 0} (\frac{1}{x} +1)ln(1+x)\\
&amp;&#x3D;\lim_{x \to 0} (\frac{1}{x} +1)x...无穷小等价替换有ln(1+x)\sim x\\
&amp;&#x3D;\lim_{x \to 0} (1+x)\\
&amp;\sim1\\
\end{align*}所以

\begin{align*}
&amp;loadFactor&#x3D;\lim_{s \to \infty} \frac{ln2}{sln\frac{s}{s-1} } \\
&amp;\sim ln2\\
&amp;\sim 0.693\\
\end{align*}考虑到 HashMap的容量有一个要求：它必须是2的n 次幂。当加载因子选择了0.75就可以保证它与容量的乘积为整数。
除了 0.75，0.5~1 之间还有 0.625（5&#x2F;8）、0.875（7&#x2F;8）可选，从中位数的角度，挑 0.75 比较完美。另外，维基百科上说，拉链法（解决哈希冲突的一种）的加载因子最好限制在 0.7-0.8以下，超过0.8，查表时的CPU缓存不命中（cache missing）会按照指数曲线上升。
综上，0.75 是个比较完美的选择。
小结 
HashMap 的加载因子（load factor，直译为加载因子，意译为负载因子）是指哈希表中填充元素的个数与桶的数量的比值，当元素个数达到负载因子与桶的数量的乘积时，就需要进行扩容。这个值一般选择 0.75，是因为这个值可以在时间和空间成本之间做到一个折中，使得哈希表的性能达到较好的表现。
如果负载因子过大，填充因子较多，那么哈希表中的元素就会越来越多地聚集在少数的桶中，这就导致了冲突的增加，这些冲突会导致查找、插入和删除操作的效率下降。同时，这也会导致需要更频繁地进行扩容，进一步降低了性能。
如果负载因子过小，那么桶的数量会很多，虽然可以减少冲突，但是在空间利用上面也会有浪费，因此选择 0.75 是为了取得一个平衡点，即在时间和空间成本之间取得一个比较好的平衡点。
总之，选择 0.75 这个值是为了在时间和空间成本之间达到一个较好的平衡点，既可以保证哈希表的性能表现，又能够充分利用空间。
04、线程不安全 
其实这个问题也不用说太多，但考虑到面试的时候有些面试官会问，那就简单说一下。
三方面原因：

多线程下扩容会死循环
多线程下 put 会导致元素丢失
put 和 get 并发时会导致 get 到 null

1）多线程下扩容会死循环 
众所周知，HashMap 是通过拉链法来解决哈希冲突的，也就是当哈希冲突时，会将相同哈希值的键值对通过链表的形式存放起来。
JDK 7 时，采用的是头部插入的方式来存放链表的，也就是下一个冲突的键值对会放在上一个键值对的前面（讲扩容的时候讲过了）。扩容的时候就有可能导致出现环形链表，造成死循环。
resize 方法的源码：
123456789101112131415161718192021&#x2F;&#x2F; newCapacity为新的容量void resize(int newCapacity) {    &#x2F;&#x2F; 小数组，临时过度下    Entry[] oldTable &#x3D; table;    &#x2F;&#x2F; 扩容前的容量    int oldCapacity &#x3D; oldTable.length;    &#x2F;&#x2F; MAXIMUM_CAPACITY 为最大容量，2 的 30 次方 &#x3D; 1&lt;&lt;30    if (oldCapacity &#x3D;&#x3D; MAXIMUM_CAPACITY) {        &#x2F;&#x2F; 容量调整为 Integer 的最大值 0x7fffffff（十六进制）&#x3D;2 的 31 次方-1        threshold &#x3D; Integer.MAX_VALUE;        return;    }    &#x2F;&#x2F; 初始化一个新的数组（大容量）    Entry[] newTable &#x3D; new Entry[newCapacity];    &#x2F;&#x2F; 把小数组的元素转移到大数组中    transfer(newTable, initHashSeedAsNeeded(newCapacity));    &#x2F;&#x2F; 引用新的大数组    table &#x3D; newTable;    &#x2F;&#x2F; 重新计算阈值    threshold &#x3D; (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);}
transfer 方法用来转移，将小数组的元素拷贝到新的数组中。
1234567891011121314151617181920212223void transfer(Entry[] newTable, boolean rehash) {    &#x2F;&#x2F; 新的容量    int newCapacity &#x3D; newTable.length;    &#x2F;&#x2F; 遍历小数组    for (Entry&lt;K,V&gt; e : table) {        while(null !&#x3D; e) {            &#x2F;&#x2F; 拉链法，相同 key 上的不同值            Entry&lt;K,V&gt; next &#x3D; e.next;            &#x2F;&#x2F; 是否需要重新计算 hash            if (rehash) {                e.hash &#x3D; null &#x3D;&#x3D; e.key ? 0 : hash(e.key);            }            &#x2F;&#x2F; 根据大数组的容量，和键的 hash 计算元素在数组中的下标            int i &#x3D; indexFor(e.hash, newCapacity);            &#x2F;&#x2F; 同一位置上的新元素被放在链表的头部            e.next &#x3D; newTable[i];            &#x2F;&#x2F; 放在新的数组上            newTable[i] &#x3D; e;            &#x2F;&#x2F; 链表上的下一个元素            e &#x3D; next;        }    }}
注意 e.next &#x3D; newTable[i] 和 newTable[i] &#x3D; e 这两行代码，就会将同一位置上的新元素被放在链表的头部。
扩容前的样子假如是下面这样子。
 
那么正常扩容后就是下面这样子。

假设现在有两个线程同时进行扩容，线程 A 在执行到 newTable[i] &#x3D; e; 被挂起，此时线程 A 中：e&#x3D;3、next&#x3D;7、e.next&#x3D;null

线程 B 开始执行，并且完成了数据转移。

此时，7 的 next 为 3，3 的 next 为 null。
随后线程A获得CPU时间片继续执行 newTable[i] &#x3D; e ，将3放入新数组对应的位置，执行完此轮循环后线程A的情况如下：

执行下一轮循环，此时 e&#x3D;7，原本线程 A 中 7 的 next 为 5，但由于 table 是线程 A 和线程 B 共享的，而线程 B 顺利执行完后，7 的 next 变成了 3，那么此时线程 A 中，7 的 next 也为 3 了。
采用头部插入的方式，变成了下面这样子：

好像也没什么问题，此时 next &#x3D; 3，e &#x3D; 3。
进行下一轮循环，但此时，由于线程 B 将 3 的 next 变为了 null，所以此轮循环应该是最后一轮了。
接下来当执行完 e.next&#x3D;newTable[i] 即 3.next&#x3D;7 后，3 和 7 之间就相互链接了，执行完 newTable[i]&#x3D;e 后，3 被头插法重新插入到链表中，执行结果如下图所示：

套娃开始，元素 5 也就成了弃婴，惨~~~
不过，JDK 8 时已经修复了这个问题，扩容时会保持链表原来的顺序（嗯，等于说了半天白说了，哈哈，这个面试题确实是这样，很水，但有些面试官又确实比较装逼）。
**2）多线程下 put 会导致元素丢失 
正常情况下，当发生哈希冲突时，HashMap 是这样的：

但多线程同时执行 put 操作时，如果计算出来的索引位置是相同的，那会造成前一个 key 被后一个 key 覆盖，从而导致元素的丢失。
put 的源码：
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051final V putVal(int hash, K key, V value, boolean onlyIfAbsent,               boolean evict) {    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;    &#x2F;&#x2F; 步骤①：tab为空则创建    if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)        n &#x3D; (tab &#x3D; resize()).length;    &#x2F;&#x2F; 步骤②：计算index，并对null做处理     if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null)        tab[i] &#x3D; newNode(hash, key, value, null);    else {        Node&lt;K,V&gt; e; K k;        &#x2F;&#x2F; 步骤③：节点key存在，直接覆盖value        if (p.hash &#x3D;&#x3D; hash &amp;&amp;            ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))            e &#x3D; p;        &#x2F;&#x2F; 步骤④：判断该链为红黑树        else if (p instanceof TreeNode)            e &#x3D; ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);        &#x2F;&#x2F; 步骤⑤：该链为链表        else {            for (int binCount &#x3D; 0; ; ++binCount) {                if ((e &#x3D; p.next) &#x3D;&#x3D; null) {                    p.next &#x3D; newNode(hash, key, value, null);                    &#x2F;&#x2F;链表长度大于8转换为红黑树进行处理                    if (binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1) &#x2F;&#x2F; -1 for 1st                        treeifyBin(tab, hash);                    break;                }                &#x2F;&#x2F; key已经存在直接覆盖value                if (e.hash &#x3D;&#x3D; hash &amp;&amp;                    ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))                    break;                p &#x3D; e;            }        }        &#x2F;&#x2F; 步骤⑥、直接覆盖        if (e !&#x3D; null) { &#x2F;&#x2F; existing mapping for key            V oldValue &#x3D; e.value;            if (!onlyIfAbsent || oldValue &#x3D;&#x3D; null)                e.value &#x3D; value;            afterNodeAccess(e);            return oldValue;        }    }    ++modCount;    &#x2F;&#x2F; 步骤⑦：超过最大容量 就扩容    if (++size &gt; threshold)        resize();    afterNodeInsertion(evict);    return null;}
问题发生在步骤 ② 这里：
12if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null)    tab[i] &#x3D; newNode(hash, key, value, null);
两个线程都执行了 if 语句，假设线程 A 先执行了 tab[i] &#x3D; newNode(hash, key, value, null) ，那 table 是这样的：          
接着，线程 B 执行了 tab[i] &#x3D; newNode(hash, key, value, null) ，那 table 是这样的：

3 被干掉了。
3）put 和 get 并发时会导致 get 到 null 
线程 A 执行put时，因为元素个数超出阈值而出现扩容，线程B 此时执行get，有可能导致这个问题。
注意来看 resize 源码：
123456789101112131415161718192021222324252627282930313233final Node&lt;K,V&gt;[] resize() {    Node&lt;K,V&gt;[] oldTab &#x3D; table;    int oldCap &#x3D; (oldTab &#x3D;&#x3D; null) ? 0 : oldTab.length;    int oldThr &#x3D; threshold;    int newCap, newThr &#x3D; 0;    if (oldCap &gt; 0) {        &#x2F;&#x2F; 超过最大值就不再扩充了，就只好随你碰撞去吧        if (oldCap &gt;&#x3D; MAXIMUM_CAPACITY) {            threshold &#x3D; Integer.MAX_VALUE;            return oldTab;        }        &#x2F;&#x2F; 没超过最大值，就扩充为原来的2倍        else if ((newCap &#x3D; oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;                 oldCap &gt;&#x3D; DEFAULT_INITIAL_CAPACITY)            newThr &#x3D; oldThr &lt;&lt; 1; &#x2F;&#x2F; double threshold    }    else if (oldThr &gt; 0) &#x2F;&#x2F; initial capacity was placed in threshold        newCap &#x3D; oldThr;    else {               &#x2F;&#x2F; zero initial threshold signifies using defaults        newCap &#x3D; DEFAULT_INITIAL_CAPACITY;        newThr &#x3D; (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);    }    &#x2F;&#x2F; 计算新的resize上限    if (newThr &#x3D;&#x3D; 0) {        float ft &#x3D; (float)newCap * loadFactor;        newThr &#x3D; (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?                  (int)ft : Integer.MAX_VALUE);    }    threshold &#x3D; newThr;    @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})        Node&lt;K,V&gt;[] newTab &#x3D; (Node&lt;K,V&gt;[])new Node[newCap];    table &#x3D; newTab;}
线程 A 执行完 table &#x3D; newTab 之后，线程 B 中的 table 此时也发生了变化，此时去 get 的时候当然会 get 到 null 了，因为元素还没有转移。
参考链接：

https:&#x2F;&#x2F;blog.csdn.net&#x2F;lonyw&#x2F;article&#x2F;details&#x2F;80519652
https:&#x2F;&#x2F;zhuanlan.zhihu.com&#x2F;p&#x2F;91636401
https:&#x2F;&#x2F;www.zhihu.com&#x2F;question&#x2F;20733617
https:&#x2F;&#x2F;zhuanlan.zhihu.com&#x2F;p&#x2F;21673805

4）小结 
HashMap 是线程不安全的主要是因为它在进行插入、删除和扩容等操作时可能会导致链表的结构发生变化，从而破坏了 HashMap 的不变性。具体来说，如果在一个线程正在遍历 HashMap 的链表时，另外一个线程对该链表进行了修改（比如添加了一个节点），那么就会导致链表的结构发生变化，从而破坏了当前线程正在进行的遍历操作，可能导致遍历失败或者出现死循环等问题。
为了解决这个问题，Java 提供了线程安全的 HashMap 实现类 ConcurrentHashMap。ConcurrentHashMap 内部采用了分段锁（Segment），将整个 Map 拆分为多个小的 HashMap，每个小的 HashMap 都有自己的锁，不同的线程可以同时访问不同的小 Map，从而实现了线程安全。在进行插入、删除和扩容等操作时，只需要锁住当前小 Map，不会对整个 Map 进行锁定，提高了并发访问的效率。
05、总结 
HashMap是Java中最常用的集合之一，它是一种键值对存储的数据结构，可以根据键来快速访问对应的值。
以下是对HashMap的总结：

HashMap采用数组+链表&#x2F;红黑树的存储结构，能够在O(1)的时间复杂度内实现元素的添加、删除、查找等操作。
HashMap是线程不安全的，因此在多线程环境下需要使用ConcurrentHashMap来保证线程安全。
HashMap的扩容机制是通过扩大数组容量和重新计算hash值来实现的，扩容时需要重新计算所有元素的hash值，因此在元素较多时扩容会影响性能。
在Java 8中，HashMap的实现引入了拉链法、树化等机制来优化大量元素存储的情况，进一步提升了性能。
HashMap中的key是唯一的，如果要存储重复的key，则后面的值会覆盖前面的值。
HashMap的初始容量和加载因子都可以设置，初始容量表示数组的初始大小，加载因子表示数组的填充因子。一般情况下，初始容量为16，加载因子为0.75。
HashMap在遍历时是无序的，因此如果需要有序遍历，可以使用TreeMap。

综上所述，HashMap是一种高效的数据结构，具有快速查找和插入元素的能力，但需要注意线程安全和性能问题。
4.10 LinkedHashMap详解（附源码）这篇继续换个文风来写，给大家一点新鲜的空气。
俗话说了，“金无足赤人无完人”，HashMap 也不例外，有一种需求它就满足不了，假如我们需要一个按照插入顺序来排列的键值对集合，那 HashMap 就无能为力了。那该怎么办呢？必须得上今天这篇文章的主角：LinkedHashMap。
同学们好啊，还记得 HashMap 那篇吗？我自己感觉写得非常棒啊，既通俗易懂，又深入源码，真的是分析得透透彻彻、清清楚楚、明明白白的。（一不小心又甩了三个成语，有文化吧？）HashMap 哪哪都好，真的，只要你想用键值对，第一时间就应该想到它。
为了提高查找效率，HashMap 在插入的时候对键做了一次哈希算法，这就导致插入的元素是无序的。
对这一点还不太明白的同学，可以再回到 HashMap 那一篇，看看 hash 方法，再看看我对 put() 方法的讲解，就能明白了，我们这里再来回顾一下。
12345678910final V putVal(int hash, K key, V value, boolean onlyIfAbsent,               boolean evict) {    HashMap.Node&lt;K,V&gt;[] tab; HashMap.Node&lt;K,V&gt; p; int n, i;    &#x2F;&#x2F; ①、数组 table 为 null 时，调用 resize 方法创建默认大小的数组    if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)        n &#x3D; (tab &#x3D; resize()).length;    &#x2F;&#x2F; ②、计算下标，如果该位置上没有值，则填充    if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null)        tab[i] &#x3D; newNode(hash, key, value, null);}
其中这个公式 i &#x3D; (n - 1) &amp; hash 计算后的值就是键位在数组（桶）中的索引（下标&#x2F;位置），但这它并不是按照 0、1、2、3、4、5 这样有序的下标将键值对插入到数组当中的，而是有一定的随机性。
比如说默认大小为 16 的 HashMap，如果 put 了 4 个键值对，可能下标是 0、4、9、11，那这样的话，在遍历 HashMap 的时候，就不一定能按照插入顺序来了。
看下面的例子。
123456789101112&#x2F;&#x2F; 创建 HashMap 对象，键类型为 String，值类型为 StringMap&lt;String, String&gt; map &#x3D; new HashMap&lt;&gt;();&#x2F;&#x2F; 使用 put() 方法向 HashMap 中添加数据map.put(&quot;chenmo&quot;, &quot;沉默&quot;);map.put(&quot;wanger&quot;, &quot;王二&quot;);map.put(&quot;chenqingyang&quot;, &quot;陈清扬&quot;);&#x2F;&#x2F; 遍历 HashMap，输出所有键值对for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) {    String key &#x3D; entry.getKey();    String value &#x3D; entry.getValue();    System.out.println(&quot;Key: &quot; + key + &quot;, Value: &quot; + value);}
来看输出结果
123Key: chenmo, Value: 沉默Key: chenqingyang, Value: 陈清扬Key: wanger, Value: 王二
对比一下输出结果就可以看得出来，put 的时候是 沉默、王二、陈清扬的顺序，但遍历的时候就没有按照这个顺序来：沉默、陈清扬、王二，因为 HashMap 是无序的。
那怎么保证键值对的插入顺序呢？
LinkedHashMap 就是为这个需求应运而生的。LinkedHashMap 继承了 HashMap，所以 HashMap 有的关于键值对的功能，它也有了。
123public class LinkedHashMap&lt;K,V&gt;    extends HashMap&lt;K,V&gt;    implements Map&lt;K,V&gt;{}
在此基础上，LinkedHashMap 内部追加了双向链表，来维护元素的插入顺序。注意下面代码中的 before 和 after，它俩就是用来维护当前元素的前一个元素和后一个元素的顺序的。
123456static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; {    Entry&lt;K,V&gt; before, after;    Entry(int hash, K key, V value, Node&lt;K,V&gt; next) {        super(hash, key, value, next);    }}
关于双向链表，同学们可以回头看一遍我写的 LinkedList 那篇文章，会对理解本篇的 LinkedHashMap 有很大的帮助。
用 LinkedHashMap 替换 HashMap，再来对比一下输出结果。
123456789101112&#x2F;&#x2F; 创建 LinkedHashMap 对象，键类型为 String，值类型为 StringMap&lt;String, String&gt; map &#x3D; new LinkedHashMap&lt;&gt;();&#x2F;&#x2F; 使用 put() 方法向 LinkedHashMap 中添加数据map.put(&quot;chenmo&quot;, &quot;沉默&quot;);map.put(&quot;wanger&quot;, &quot;王二&quot;);map.put(&quot;chenqingyang&quot;, &quot;陈清扬&quot;);&#x2F;&#x2F; 遍历 LinkedHashMap，输出所有键值对for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) {    String key &#x3D; entry.getKey();    String value &#x3D; entry.getValue();    System.out.println(&quot;Key: &quot; + key + &quot;, Value: &quot; + value);}
来看输出结果：
123Key: chenmo, Value: 沉默Key: wanger, Value: 王二Key: chenqingyang, Value: 陈清扬
看，LinkedHashMap 是不是保持了插入顺序？这就对了。
01、插入顺序 
在 HashMap 那篇文章里，我有讲解到一点，不知道同学们记不记得，就是 null 会插入到 HashMap 的第一位。
123456789Map&lt;String, String&gt; hashMap &#x3D; new HashMap&lt;&gt;();hashMap.put(&quot;沉&quot;, &quot;沉默王二&quot;);hashMap.put(&quot;默&quot;, &quot;沉默王二&quot;);hashMap.put(&quot;王&quot;, &quot;沉默王二&quot;);hashMap.put(&quot;二&quot;, &quot;沉默王二&quot;);hashMap.put(null, null);for (String key : hashMap.keySet()) {    System.out.println(key + &quot; : &quot; + hashMap.get(key));}
输出的结果是：
12345null : null默 : 沉默王二沉 : 沉默王二王 : 沉默王二二 : 沉默王二
虽然 null 最后一位 put 进去的，但在遍历输出的时候，跑到了第一位。
那再来对比看一下 LinkedHashMap。
123456789Map&lt;String, String&gt; linkedHashMap &#x3D; new LinkedHashMap&lt;&gt;();linkedHashMap.put(&quot;沉&quot;, &quot;沉默王二&quot;);linkedHashMap.put(&quot;默&quot;, &quot;沉默王二&quot;);linkedHashMap.put(&quot;王&quot;, &quot;沉默王二&quot;);linkedHashMap.put(&quot;二&quot;, &quot;沉默王二&quot;);linkedHashMap.put(null, null);for (String key : linkedHashMap.keySet()) {    System.out.println(key + &quot; : &quot; + linkedHashMap.get(key));}
输出结果是：
12345沉 : 沉默王二默 : 沉默王二王 : 沉默王二二 : 沉默王二null : null
null 在最后一位插入，在最后一位输出。
输出结果可以再次证明，HashMap 是无序的，LinkedHashMap 是可以维持插入顺序的。
那 LinkedHashMap 是如何做到这一点呢？我相信同学们和我一样，非常希望知道原因。
要想搞清楚，就需要深入研究一下 LinkedHashMap 的源码。LinkedHashMap 并未重写 HashMap 的 put() 方法，而是重写了 put() 方法需要调用的内部方法 newNode() 。
这是 HashMap 的。
123Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) {    return new Node&lt;&gt;(hash, key, value, next);}
这是 LinkedHashMap 的。
123456HashMap.Node&lt;K,V&gt; newNode(int hash, K key, V value, HashMap.Node&lt;K,V&gt; e) {    LinkedHashMap.Entry&lt;K,V&gt; p &#x3D;            new LinkedHashMap.Entry&lt;&gt;(hash, key, value, e);    linkNodeLast(p);    return p;}
前面曾提到 LinkedHashMap.Entry 继承了 HashMap.Node，并且追加了两个字段 before 和 after，用来维持键值对的关系。
在 LinkedHashMap 中，链表中的节点顺序是按照插入顺序维护的。当使用 put() 方法向 LinkedHashMap 中添加键值对时，会将新节点插入到链表的尾部，并更新 before 和 after 属性，以保证链表的顺序关系——由 linkNodeLast() 方法来完成：
123456789101112131415&#x2F;** * 将指定节点插入到链表的尾部 * * @param p 要插入的节点 *&#x2F;private void linkNodeLast(LinkedHashMap.Entry&lt;K,V&gt; p) {    LinkedHashMap.Entry&lt;K,V&gt; last &#x3D; tail; &#x2F;&#x2F; 获取链表的尾节点    tail &#x3D; p; &#x2F;&#x2F; 将 p 设为尾节点    if (last &#x3D;&#x3D; null)        head &#x3D; p; &#x2F;&#x2F; 如果链表为空，则将 p 设为头节点    else {        p.before &#x3D; last; &#x2F;&#x2F; 将 p 的前驱节点设为链表的尾节点        last.after &#x3D; p; &#x2F;&#x2F; 将链表的尾节点的后继节点设为 p    }}
看到了吧，LinkedHashMap 在添加第一个元素的时候，会把 head 赋值为第一个元素，等到第二个元素添加进来的时候，会把第二个元素的 before 赋值为第一个元素，第一个元素的 afer 赋值为第二个元素。
这就保证了键值对是按照插入顺序排列的，明白了吧？
02、访问顺序 
LinkedHashMap 不仅能够维持插入顺序，还能够维持访问顺序。访问包括调用 get() 方法、 remove() 方法和 put() 方法。
要维护访问顺序，需要我们在声明 LinkedHashMap 的时候指定三个参数。
1LinkedHashMap&lt;String, String&gt; map &#x3D; new LinkedHashMap&lt;&gt;(16, .75f, true);
第一个参数和第二个参数，看过 HashMap 的同学们应该很熟悉了，指的是初始容量和负载因子。
第三个参数如果为 true 的话，就表示 LinkedHashMap 要维护访问顺序；否则，维护插入顺序。默认是 false。
12345678910Map&lt;String, String&gt; linkedHashMap &#x3D; new LinkedHashMap&lt;&gt;(16, .75f, true);linkedHashMap.put(&quot;沉&quot;, &quot;沉默王二&quot;);linkedHashMap.put(&quot;默&quot;, &quot;沉默王二&quot;);linkedHashMap.put(&quot;王&quot;, &quot;沉默王二&quot;);linkedHashMap.put(&quot;二&quot;, &quot;沉默王二&quot;);System.out.println(linkedHashMap);linkedHashMap.get(&quot;默&quot;);System.out.println(linkedHashMap);linkedHashMap.get(&quot;王&quot;);System.out.println(linkedHashMap);
输出的结果如下所示：
123{沉&#x3D;沉默王二, 默&#x3D;沉默王二, 王&#x3D;沉默王二, 二&#x3D;沉默王二}{沉&#x3D;沉默王二, 王&#x3D;沉默王二, 二&#x3D;沉默王二, 默&#x3D;沉默王二}{沉&#x3D;沉默王二, 二&#x3D;沉默王二, 默&#x3D;沉默王二, 王&#x3D;沉默王二}
当我们使用 get() 方法访问键位“默”的元素后，输出结果中，默&#x3D;沉默王二 在最后；当我们访问键位“王”的元素后，输出结果中，王&#x3D;沉默王二 在最后，默&#x3D;沉默王二 在倒数第二位。
也就是说，最不经常访问的放在头部，这就有意思了。有意思在哪呢？
我们可以使用 LinkedHashMap 来实现 LRU 缓存，LRU 是 Least Recently Used 的缩写，即最近最少使用，是一种常用的页面置换算法，选择最近最久未使用的页面予以淘汰。
12345678910111213141516171819202122232425262728293031&#x2F;** * 自定义的 MyLinkedHashMap 类，继承了 Java 中内置的 LinkedHashMap&lt;K, V&gt; 类。 * 用于实现一个具有固定大小的缓存，当缓存达到最大容量时，会自动移除最早加入的元素，以腾出空间给新的元素。 * * @param &lt;K&gt; 键的类型 * @param &lt;V&gt; 值的类型 *&#x2F;public class MyLinkedHashMap&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; {    private static final int MAX_ENTRIES &#x3D; 5; &#x2F;&#x2F; 表示 MyLinkedHashMap 中最多存储的键值对数量    &#x2F;**     * 构造方法，使用 super() 调用了父类的构造函数，并传递了三个参数：initialCapacity、loadFactor 和 accessOrder。     *     * @param initialCapacity 初始容量     * @param loadFactor      负载因子     * @param accessOrder     访问顺序     *&#x2F;    public MyLinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) {        super(initialCapacity, loadFactor, accessOrder);    }    &#x2F;**     * 重写父类的 removeEldestEntry() 方法，用于指示是否应该移除最早加入的元素。     * 如果返回 true，那么将删除最早加入的元素。     *     * @param eldest 最早加入的元素     * @return 如果当前 MyLinkedHashMap 中元素的数量大于 MAX_ENTRIES，返回 true，否则返回 false。     *&#x2F;    @Override    protected boolean removeEldestEntry(Map.Entry eldest) {        return size() &gt; MAX_ENTRIES;    }}
MyLinkedHashMap 是一个自定义类，它继承了 LinkedHashMap，并且重写了 removeEldestEntry() 方法——使 Map 最多可容纳 5 个元素，超出后就淘汰。
我们来测试一下。
1234567891011MyLinkedHashMap&lt;String,String&gt; map &#x3D; new MyLinkedHashMap&lt;&gt;(16,0.75f,true);map.put(&quot;沉&quot;, &quot;沉默王二&quot;);map.put(&quot;默&quot;, &quot;沉默王二&quot;);map.put(&quot;王&quot;, &quot;沉默王二&quot;);map.put(&quot;二&quot;, &quot;沉默王二&quot;);map.put(&quot;一枚有趣的程序员&quot;, &quot;一枚有趣的程序员&quot;);System.out.println(map);map.put(&quot;一枚有颜值的程序员&quot;, &quot;一枚有颜值的程序员&quot;);System.out.println(map);map.put(&quot;一枚有才华的程序员&quot;,&quot;一枚有才华的程序员&quot;);System.out.println(map);
输出结果如下所示：
12345{沉&#x3D;沉默王二, 默&#x3D;沉默王二, 王&#x3D;沉默王二, 二&#x3D;沉默王二, 一枚有趣的程序员&#x3D;一枚有趣的程序员}{默&#x3D;沉默王二, 王&#x3D;沉默王二, 二&#x3D;沉默王二, 一枚有趣的程序员&#x3D;一枚有趣的程序员, 一枚有颜值的程序员&#x3D;一枚有颜值的程序员}{王&#x3D;沉默王二, 二&#x3D;沉默王二, 一枚有趣的程序员&#x3D;一枚有趣的程序员, 一枚有颜值的程序员&#x3D;一枚有颜值的程序员, 一枚有才华的程序员&#x3D;一枚有才华的程序员}
沉&#x3D;沉默王二 和 默&#x3D;沉默王二 依次被淘汰出局。
假如在 put “一枚有才华的程序员”之前 get 了键位为“默”的元素：
123456789101112MyLinkedHashMap&lt;String,String&gt; map &#x3D; new MyLinkedHashMap&lt;&gt;(16,0.75f,true);map.put(&quot;沉&quot;, &quot;沉默王二&quot;);map.put(&quot;默&quot;, &quot;沉默王二&quot;);map.put(&quot;王&quot;, &quot;沉默王二&quot;);map.put(&quot;二&quot;, &quot;沉默王二&quot;);map.put(&quot;一枚有趣的程序员&quot;, &quot;一枚有趣的程序员&quot;);System.out.println(map);map.put(&quot;一枚有颜值的程序员&quot;, &quot;一枚有颜值的程序员&quot;);System.out.println(map);map.get(&quot;默&quot;);map.put(&quot;一枚有才华的程序员&quot;,&quot;一枚有才华的程序员&quot;);System.out.println(map);
那输出结果就变了，对吧？
12345{沉&#x3D;沉默王二, 默&#x3D;沉默王二, 王&#x3D;沉默王二, 二&#x3D;沉默王二, 一枚有趣的程序员&#x3D;一枚有趣的程序员}{默&#x3D;沉默王二, 王&#x3D;沉默王二, 二&#x3D;沉默王二, 一枚有趣的程序员&#x3D;一枚有趣的程序员, 一枚有颜值的程序员&#x3D;一枚有颜值的程序员}{二&#x3D;沉默王二, 一枚有趣的程序员&#x3D;一枚有趣的程序员, 一枚有颜值的程序员&#x3D;一枚有颜值的程序员, 默&#x3D;沉默王二, 一枚有才华的程序员&#x3D;一枚有才华的程序员}
沉&#x3D;沉默王二 和 王&#x3D;沉默王二 被淘汰出局了。
那 LinkedHashMap 是如何来维持访问顺序呢？同学们感兴趣的话，可以研究一下下面这三个方法。
123void afterNodeAccess(Node&lt;K,V&gt; p) { }void afterNodeInsertion(boolean evict) { }void afterNodeRemoval(Node&lt;K,V&gt; p) { }
afterNodeAccess() 会在调用 get() 方法的时候被调用， afterNodeInsertion() 会在调用 put() 方法的时候被调用， afterNodeRemoval() 会在调用 remove() 方法的时候被调用。
我来以 afterNodeAccess() 为例来讲解一下。
123456789101112131415161718192021222324252627282930&#x2F;** * 在访问节点后，将节点移动到链表的尾部 * * @param e 要移动的节点 *&#x2F;void afterNodeAccess(HashMap.Node&lt;K,V&gt; e) { &#x2F;&#x2F; move node to last    LinkedHashMap.Entry&lt;K,V&gt; last;    if (accessOrder &amp;&amp; (last &#x3D; tail) !&#x3D; e) { &#x2F;&#x2F; 如果按访问顺序排序，并且访问的节点不是尾节点        LinkedHashMap.Entry&lt;K,V&gt; p &#x3D; (LinkedHashMap.Entry&lt;K,V&gt;)e, b &#x3D; p.before, a &#x3D; p.after;        p.after &#x3D; null; &#x2F;&#x2F; 将要移动的节点的后继节点设为 null        if (b &#x3D;&#x3D; null)            head &#x3D; a; &#x2F;&#x2F; 如果要移动的节点没有前驱节点，则将要移动的节点设为头节点        else            b.after &#x3D; a; &#x2F;&#x2F; 将要移动的节点的前驱节点的后继节点设为要移动的节点的后继节点        if (a !&#x3D; null)            a.before &#x3D; b; &#x2F;&#x2F; 如果要移动的节点有后继节点，则将要移动的节点的后继节点的前驱节点设为要移动的节点的前驱节点        else            last &#x3D; b; &#x2F;&#x2F; 如果要移动的节点没有后继节点，则将要移动的节点的前驱节点设为尾节点        if (last &#x3D;&#x3D; null)            head &#x3D; p; &#x2F;&#x2F; 如果尾节点为空，则将要移动的节点设为头节点        else {            p.before &#x3D; last; &#x2F;&#x2F; 将要移动的节点的前驱节点设为尾节点            last.after &#x3D; p; &#x2F;&#x2F; 将尾节点的后继节点设为要移动的节点        }        tail &#x3D; p; &#x2F;&#x2F; 将要移动的节点设为尾节点        ++modCount; &#x2F;&#x2F; 修改计数器    }}
哪个元素被 get 就把哪个元素放在最后。了解了吧？
那同学们可能还想知道，为什么 LinkedHashMap 能实现 LRU 缓存，把最不经常访问的那个元素淘汰？
在插入元素的时候，需要调用 put() 方法，该方法最后会调用 afterNodeInsertion() 方法，这个方法被 LinkedHashMap 重写了。
1234567891011121314&#x2F;** * 在插入节点后，如果需要，可能会删除最早加入的元素 * * @param evict 是否需要删除最早加入的元素 *&#x2F;void afterNodeInsertion(boolean evict) { &#x2F;&#x2F; possibly remove eldest    LinkedHashMap.Entry&lt;K,V&gt; first;    if (evict &amp;&amp; (first &#x3D; head) !&#x3D; null &amp;&amp; removeEldestEntry(first)) { &#x2F;&#x2F; 如果需要删除最早加入的元素        K key &#x3D; first.key; &#x2F;&#x2F; 获取要删除元素的键        removeNode(hash(key), key, null, false, true); &#x2F;&#x2F; 调用 removeNode() 方法删除元素    }}
removeEldestEntry() 方法会判断第一个元素是否超出了可容纳的最大范围，如果超出，那就会调用 removeNode() 方法对最不经常访问的那个元素进行删除。
03、小结 
由于 LinkedHashMap 要维护双向链表，所以 LinkedHashMap 在插入、删除操作的时候，花费的时间要比 HashMap 多一些。
这也是没办法的事，对吧，欲戴皇冠必承其重嘛。既然想要维护元素的顺序，总要付出点代价才行。
简单总结一下吧。
首先，我们知道 HashMap 是一种常用的哈希表数据结构，它可以快速地进行键值对的查找和插入操作。但是，HashMap 本身并不保证键值对的顺序，如果我们需要按照插入顺序或访问顺序来遍历键值对，就需要使用 LinkedHashMap 了。
LinkedHashMap 继承自 HashMap，它在 HashMap 的基础上，增加了一个双向链表来维护键值对的顺序。这个链表可以按照插入顺序或访问顺序排序，它的头节点表示最早插入或访问的元素，尾节点表示最晚插入或访问的元素。这个链表的作用就是让 LinkedHashMap 可以保持键值对的顺序，并且可以按照顺序遍历键值对。
LinkedHashMap 还提供了两个构造方法来指定排序方式，分别是按照插入顺序排序和按照访问顺序排序。在按照访问顺序排序的情况下，每次访问一个键值对，都会将该键值对移到链表的尾部，以保证最近访问的元素在最后面。如果需要删除最早加入的元素，可以通过重写 removeEldestEntry() 方法来实现。
总之，LinkedHashMap 通过维护一个双向链表来保持键值对的顺序，可以按照插入顺序或访问顺序来遍历键值对。如果你需要按照顺序来遍历键值对，那么 LinkedHashMap 就是你的不二选择了！
4.11 TreeMap详解（附源码）下面有请王老师上台，来给大家讲一讲 TreeMap，鼓掌了！
之前 LinkedHashMap 那篇文章里提到过了，HashMap 是无序的，所以有了 LinkedHashMap，加上了双向链表后，就可以保持元素的插入顺序和访问顺序，那 TreeMap 呢？
TreeMap 由红黑树实现，可以保持元素的自然顺序，或者实现了 Comparator 接口的自定义顺序。
可能有些同学不了解红黑树，我这里来普及一下：

红黑树（英语：Red–black tree）是一种自平衡的二叉查找树（Binary Search Tree），结构复杂，但却有着良好的性能，完成查找、插入和删除的时间复杂度均为 log(n)。

二叉查找树是一种常见的树形结构，它的每个节点都包含一个键值对。每个节点的左子树节点的键值小于该节点的键值，右子树节点的键值大于该节点的键值，这个特性使得二叉查找树非常适合进行数据的查找和排序操作。
下面是一个简单的手绘图，展示了一个二叉查找树的结构：
1234567     8   &#x2F;   \  3     10 &#x2F; \      \1   6     14   &#x2F; \    &#x2F;  4   7  13
在上面这个二叉查找树中，根节点是 8，左子树节点包括 3、1、6、4 和 7，右子树节点包括 10、14 和 13。

3&lt;8&lt;10
1&lt;3&lt;6
4&lt;6&lt;7
10&lt;14
13&lt;14

这是一颗典型的二叉查找树：
1）左子树上所有节点的值均小于或等于它的根结点的值。
2）右子树上所有节点的值均大于或等于它的根结点的值。
3）左、右子树也分别为二叉查找树。
二叉查找树用来查找非常方面，从根节点开始遍历，如果当前节点的键值等于要查找的键值，则查找成功；如果要查找的键值小于当前节点的键值，则继续遍历左子树；如果要查找的键值大于当前节点的键值，则继续遍历右子树。如果遍历到叶子节点仍然没有找到，则查找失败。
插入操作也非常简单，从根节点开始遍历，如果要插入的键值小于当前节点的键值，则将其插入到左子树中；如果要插入的键值大于当前节点的键值，则将其插入到右子树中。如果要插入的键值已经存在于树中，则更新该节点的值。
删除操作稍微复杂一些，需要考虑多种情况，包括要删除的节点是叶子节点、要删除的节点只有一个子节点、要删除的节点有两个子节点等等。
总之，二叉查找树是一种非常常用的数据结构，它可以帮助我们实现数据的查找、排序和删除等操作。
理解二叉查找树了吧？
不过，二叉查找树有一个明显的不足，就是容易变成瘸子，就是一侧多，一侧少，比如说这样：
1234567       6     &#x2F;   \    4     8   &#x2F;     &#x2F; \  3     7   9 &#x2F;1
在上面这个不平衡的二叉查找树中，左子树比右子树高。根节点是 6，左子树节点包括 4、3 和 1，右子树节点包括 8、7 和 9。
由于左子树比右子树高，这个不平衡的二叉查找树可能会导致查找、插入和删除操作的效率下降。
来一个更极端的情况。
12345678910111 \  2   \    3     \      4       \        5         \          6
在上面这个极度不平衡的二叉查找树中，所有节点都只有一个右子节点，根节点是 1，右子树节点包括 2、3、4、5 和 6。
这种极度不平衡的二叉查找树会导致查找、插入和删除操作的效率急剧下降，因为每次操作都只能在右子树中进行，而左子树几乎没有被利用到。
查找的效率就要从 log(n) 变成 o(n) 了（戳这里了解时间复杂度），对吧？
必须要平衡一下，对吧？于是就有了平衡二叉树，左右两个子树的高度差的绝对值不超过 1，就像下图这样：
1234567     8   &#x2F;   \  4     12 &#x2F; \    &#x2F; \2   6  10  14   &#x2F; \    &#x2F; \  5   7  13  15
根节点是 8，左子树节点包括 4、2、6、5 和 7，右子树节点包括 12、10、14、13 和 15。左子树和右子树的高度差不超过1，因此它是一个平衡二叉查找树。
平衡二叉树就像是一棵树形秤，它的左右两边的重量要尽可能的平衡。当我们往平衡二叉树中插入一个节点时，平衡二叉树会自动调整节点的位置，以保证树的左右两边的高度差不超过1。类似地，当我们删除一个节点时，平衡二叉树也会自动调整节点的位置，以保证树的左右两边的高度差不超过1。
常见的平衡二叉树包括AVL树、红黑树等等，它们都是通过旋转操作来调整树的平衡，使得左子树和右子树的高度尽可能接近。
AVL树的示意图：
1234567     8   &#x2F;   \  4     12 &#x2F; \   &#x2F;  \2   6 10  14   &#x2F; \  5   7
AVL树是一种高度平衡的二叉查找树，它要求左子树和右子树的高度差不超过1。由于AVL树的平衡度比较高，因此在进行插入和删除操作时需要进行更多的旋转操作来保持平衡，但是在查找操作时效率较高。AVL树适用于读操作比较多的场景。
例如，对于一个需要频繁进行查找操作的场景，如字典树、哈希表等数据结构，可以使用AVL树来进行优化。另外，AVL树也适用于需要保证数据有序性的场景，如数据库中的索引。
AVL树最初由两位苏联的计算机科学家，Adelson-Velskii和Landis，于1962年提出。因此，AVL树就以他们两人名字的首字母缩写命名了。
AVL树的发明对计算机科学的发展有着重要的影响，不仅为后来的平衡二叉树提供了基础，而且为其他领域的数据结构和算法提供了启示。
红黑树的示意图（R 即 Red「红」、B 即 Black「黑」）：
1234567     8B   &#x2F;   \  4R    12R &#x2F; \   &#x2F;  \2B 6B 10B 14B   &#x2F; \  5R 7R
红黑树，顾名思义，就是节点是红色或者黑色的平衡二叉树，它通过颜色的约束来维持二叉树的平衡，它要求任意一条路径上的黑色节点数目相同，同时还需要满足一些其他特定的条件，如红色节点的父节点必须为黑色节点等。
1）每个节点都只能是红色或者黑色
2）根节点是黑色
3）每个叶节点（NIL 节点，空节点）是黑色的。
4）如果一个节点是红色的，则它两个子节点都是黑色的。也就是说在一条路径上不能出现相邻的两个红色节点。
5）从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。
由于红黑树的平衡度比AVL树稍低，因此在进行插入和删除操作时需要进行的旋转操作较少，但是在查找操作时效率仍然较高。红黑树适用于读写操作比较均衡的场景。
那，关于红黑树，同学们就先了解到这，脑子里有个大概的印象，知道 TreeMap 是个什么玩意。
01、自然顺序 
默认情况下，TreeMap 是根据 key 的自然顺序排列的。比如说整数，就是升序，1、2、3、4、5。
1234567TreeMap&lt;Integer,String&gt; mapInt &#x3D; new TreeMap&lt;&gt;();mapInt.put(3, &quot;沉默王二&quot;);mapInt.put(2, &quot;沉默王二&quot;);mapInt.put(1, &quot;沉默王二&quot;);mapInt.put(5, &quot;沉默王二&quot;);mapInt.put(4, &quot;沉默王二&quot;);System.out.println(mapInt);
输出结果如下所示：
1{1&#x3D;沉默王二, 2&#x3D;沉默王二, 3&#x3D;沉默王二, 4&#x3D;沉默王二, 5&#x3D;沉默王二}
TreeMap 是怎么做到的呢？想一探究竟，就得上源码了，来看 TreeMap 的 put() 方法：
12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public V put(K key, V value) {    Entry&lt;K,V&gt; t &#x3D; root; &#x2F;&#x2F; 将根节点赋值给变量t    if (t &#x3D;&#x3D; null) { &#x2F;&#x2F; 如果根节点为null，说明TreeMap为空        compare(key, key); &#x2F;&#x2F; type (and possibly null) check，检查key的类型是否合法        root &#x3D; new Entry&lt;&gt;(key, value, null); &#x2F;&#x2F; 创建一个新节点作为根节点        size &#x3D; 1; &#x2F;&#x2F; size设置为1        return null; &#x2F;&#x2F; 返回null，表示插入成功    }    int cmp;    Entry&lt;K,V&gt; parent;    &#x2F;&#x2F; split comparator and comparable paths，根据使用的比较方法进行查找    Comparator&lt;? super K&gt; cpr &#x3D; comparator; &#x2F;&#x2F; 获取比较器    if (cpr !&#x3D; null) { &#x2F;&#x2F; 如果使用了Comparator        do {            parent &#x3D; t; &#x2F;&#x2F; 将当前节点赋值给parent            cmp &#x3D; cpr.compare(key, t.key); &#x2F;&#x2F; 使用Comparator比较key和t的键的大小            if (cmp &lt; 0) &#x2F;&#x2F; 如果key小于t的键                t &#x3D; t.left; &#x2F;&#x2F; 在t的左子树中查找            else if (cmp &gt; 0) &#x2F;&#x2F; 如果key大于t的键                t &#x3D; t.right; &#x2F;&#x2F; 在t的右子树中查找            else &#x2F;&#x2F; 如果key等于t的键                return t.setValue(value); &#x2F;&#x2F; 直接更新t的值        } while (t !&#x3D; null);    }    else { &#x2F;&#x2F; 如果没有使用Comparator        if (key &#x3D;&#x3D; null) &#x2F;&#x2F; 如果key为null            throw new NullPointerException(); &#x2F;&#x2F; 抛出NullPointerException异常            Comparable&lt;? super K&gt; k &#x3D; (Comparable&lt;? super K&gt;) key; &#x2F;&#x2F; 将key强制转换为Comparable类型        do {            parent &#x3D; t; &#x2F;&#x2F; 将当前节点赋值给parent            cmp &#x3D; k.compareTo(t.key); &#x2F;&#x2F; 使用Comparable比较key和t的键的大小            if (cmp &lt; 0) &#x2F;&#x2F; 如果key小于t的键                t &#x3D; t.left; &#x2F;&#x2F; 在t的左子树中查找            else if (cmp &gt; 0) &#x2F;&#x2F; 如果key大于t的键                t &#x3D; t.right; &#x2F;&#x2F; 在t的右子树中查找            else &#x2F;&#x2F; 如果key等于t的键                return t.setValue(value); &#x2F;&#x2F; 直接更新t的值        } while (t !&#x3D; null);    }    &#x2F;&#x2F; 如果没有找到相同的键，需要创建一个新节点插入到TreeMap中    Entry&lt;K,V&gt; e &#x3D; new Entry&lt;&gt;(key, value, parent); &#x2F;&#x2F; 创建一个新节点    if (cmp &lt; 0) &#x2F;&#x2F; 如果key小于parent的键        parent.left &#x3D; e; &#x2F;&#x2F; 将e作为parent的左子节点    else        parent.right &#x3D; e; &#x2F;&#x2F; 将e作为parent的右子节点    fixAfterInsertion(e); &#x2F;&#x2F; 插入节点后需要进行平衡操作    size++; &#x2F;&#x2F; size加1    return null; &#x2F;&#x2F; 返回null，表示插入成功}

首先定义一个Entry类型的变量t，用于表示当前的根节点；
如果t为null，说明TreeMap为空，直接创建一个新的节点作为根节点，并将size设置为1；
如果t不为null，说明需要在TreeMap中查找键所对应的节点。因为TreeMap中的元素是有序的，所以可以使用二分查找的方式来查找节点；
如果TreeMap中使用了Comparator来进行排序，则使用Comparator进行比较，否则使用Comparable进行比较。如果查找到了相同的键，则直接更新键所对应的值；
如果没有查找到相同的键，则创建一个新的节点，并将其插入到TreeMap中。然后使用fixAfterInsertion()方法来修正插入节点后的平衡状态；
最后将TreeMap的size加1，然后返回null。如果更新了键所对应的值，则返回原先的值。

注意 cmp &#x3D; k.compareTo(t.key) 这行代码，就是用来进行 key 比较的，由于此时 key 是 String，所以就会调用 String 类的compareTo() 方法进行比较。
1234567891011121314151617181920212223public int compareTo(String anotherString) {    &#x2F;&#x2F; 获取当前字符串和另一个字符串的长度    int len1 &#x3D; value.length;    int len2 &#x3D; anotherString.value.length;    &#x2F;&#x2F; 取两个字符串长度的较短者作为比较的上限    int lim &#x3D; Math.min(len1, len2);    &#x2F;&#x2F; 获取当前字符串和另一个字符串的字符数组    char v1[] &#x3D; value;    char v2[] &#x3D; anotherString.value;    int k &#x3D; 0;    &#x2F;&#x2F; 对两个字符串的每个字符进行比较    while (k &lt; lim) {        char c1 &#x3D; v1[k];        char c2 &#x3D; v2[k];        &#x2F;&#x2F; 如果两个字符不相等，返回它们的差值        if (c1 !&#x3D; c2) {            return c1 - c2;        }        k++;    }    &#x2F;&#x2F; 如果两个字符串前面的字符都相等，返回它们长度的差值    return len1 - len2;}
来看下面的示例。
1234567TreeMap&lt;String,String&gt; mapString &#x3D; new TreeMap&lt;&gt;();mapString.put(&quot;c&quot;, &quot;沉默王二&quot;);mapString.put(&quot;b&quot;, &quot;沉默王二&quot;);mapString.put(&quot;a&quot;, &quot;沉默王二&quot;);mapString.put(&quot;e&quot;, &quot;沉默王二&quot;);mapString.put(&quot;d&quot;, &quot;沉默王二&quot;);System.out.println(mapString);
输出结果如下所示：
1{a&#x3D;沉默王二, b&#x3D;沉默王二, c&#x3D;沉默王二, d&#x3D;沉默王二, e&#x3D;沉默王二}
从结果可以看得出，是按照字母的升序进行排序的。
02、自定义排序 
如果自然顺序不满足，那就可以在声明 TreeMap 对象的时候指定排序规则。
1234567TreeMap&lt;Integer,String&gt; mapIntReverse &#x3D; new TreeMap&lt;&gt;(Comparator.reverseOrder());mapIntReverse.put(3, &quot;沉默王二&quot;);mapIntReverse.put(2, &quot;沉默王二&quot;);mapIntReverse.put(1, &quot;沉默王二&quot;);mapIntReverse.put(5, &quot;沉默王二&quot;);mapIntReverse.put(4, &quot;沉默王二&quot;);System.out.println(mapIntReverse);
TreeMap 提供了可以指定排序规则的构造方法：
123public TreeMap(Comparator&lt;? super K&gt; comparator) {    this.comparator &#x3D; comparator;}
Comparator.reverseOrder() 返回的是 Collections.ReverseComparator 对象，就是用来反转顺序的，非常方便。
12345678910111213141516171819private static class ReverseComparator        implements Comparator&lt;Comparable&lt;Object&gt;&gt;, Serializable {    &#x2F;&#x2F; 单例模式，用于表示逆序比较器    static final ReverseComparator REVERSE_ORDER            &#x3D; new ReverseComparator();    &#x2F;&#x2F; 实现比较方法，对两个实现了Comparable接口的对象进行逆序比较    public int compare(Comparable&lt;Object&gt; c1, Comparable&lt;Object&gt; c2) {        return c2.compareTo(c1); &#x2F;&#x2F; 调用c2的compareTo()方法，以c1为参数，实现逆序比较    }    &#x2F;&#x2F; 反序列化时，返回Collections.reverseOrder()，保证单例模式    private Object readResolve() {        return Collections.reverseOrder();    }    &#x2F;&#x2F; 返回正序比较器    @Override    public Comparator&lt;Comparable&lt;Object&gt;&gt; reversed() {        return Comparator.naturalOrder();    }}
所以，输出结果如下所示：
1{5&#x3D;沉默王二, 4&#x3D;沉默王二, 3&#x3D;沉默王二, 2&#x3D;沉默王二, 1&#x3D;沉默王二}
HashMap 是无序的，插入的顺序随着元素的增加会不停地变动。但 TreeMap 能够至始至终按照指定的顺序排列，这对于需要自定义排序的场景，实在是太有用了！
03、排序的好处 
既然 TreeMap 的元素是经过排序的，那找出最大的那个，最小的那个，或者找出所有大于或者小于某个值的键来说，就方便多了。
12345678Integer highestKey &#x3D; mapInt.lastKey();Integer lowestKey &#x3D; mapInt.firstKey();Set&lt;Integer&gt; keysLessThan3 &#x3D; mapInt.headMap(3).keySet();Set&lt;Integer&gt; keysGreaterThanEqTo3 &#x3D; mapInt.tailMap(3).keySet();System.out.println(highestKey);System.out.println(lowestKey);System.out.println(keysLessThan3);System.out.println(keysGreaterThanEqTo3);
TreeMap 考虑得很周全，恰好就提供了 lastKey() 、 firstKey() 这样获取最后一个 key 和第一个 key 的方法。
headMap() 获取的是到指定 key 之前的 key； tailMap() 获取的是指定 key 之后的 key（包括指定 key）。
来看一下输出结果：
123451[1, 2][3, 4, 
再来看一下例子：
123456789101112131415TreeMap&lt;Integer, String&gt; treeMap &#x3D; new TreeMap&lt;&gt;();treeMap.put(1, &quot;value1&quot;);treeMap.put(2, &quot;value2&quot;);treeMap.put(3, &quot;value3&quot;);treeMap.put(4, &quot;value4&quot;);treeMap.put(5, &quot;value5&quot;);&#x2F;&#x2F; headMap示例，获取小于3的键值对Map&lt;Integer, String&gt; headMap &#x3D; treeMap.headMap(3);System.out.println(headMap); &#x2F;&#x2F; 输出 {1&#x3D;value1, 2&#x3D;value2}&#x2F;&#x2F; tailMap示例，获取大于等于4的键值对Map&lt;Integer, String&gt; tailMap &#x3D; treeMap.tailMap(4);System.out.println(tailMap); &#x2F;&#x2F; 输出 {4&#x3D;value4, 5&#x3D;value5}&#x2F;&#x2F; subMap示例，获取大于等于2且小于4的键值对Map&lt;Integer, String&gt; subMap &#x3D; treeMap.subMap(2, 4);System.out.println(subMap); &#x2F;&#x2F; 输出 {2&#x3D;value2, 3&#x3D;value3}
headMap、tailMap、subMap方法分别获取了小于3、大于等于4、大于等于2且小于4的键值对。
04、如何选择 Map 
在学习 TreeMap 之前，我们已经学习了 HashMap 和 LinkedHashMap ，那如何从它们三个中间选择呢？
需要考虑以下因素：

是否需要按照键的自然顺序或者自定义顺序进行排序。如果需要按照键排序，则可以使用 TreeMap；如果不需要排序，则可以使用 HashMap 或 LinkedHashMap。
是否需要保持插入顺序。如果需要保持插入顺序，则可以使用 LinkedHashMap；如果不需要保持插入顺序，则可以使用 TreeMap 或 HashMap。
是否需要高效的查找。如果需要高效的查找，则可以使用 LinkedHashMap 或 HashMap，因为它们的查找操作的时间复杂度为 O(1)，而是 TreeMap 是 O(log n)。
LinkedHashMap 内部使用哈希表来存储键值对，并使用一个双向链表来维护插入顺序，但查找操作只需要在哈希表中进行，与链表无关，所以时间复杂度为 O(1)

来个表格吧，一目了然。




特性
TreeMap
HashMap
LinkedHashMap




排序
支持
不支持
不支持


插入顺序
不保证
不保证
保证


查找效率
O(log n)
O(1)
O(1)


空间占用
通常较大
通常较小
通常较大


适用场景
需要排序的场景
无需排序的场景
需要保持插入顺




好了，下课，关于 TreeMap 我们就讲到这里吧，希望同学们都能对 TreeMap 有一个清晰的认识。我们下节课见~
4.12 双端队列ArrayDeque详解好，我们这节继续有请王老师上台来给大家讲 ArrayDeque，鼓掌欢迎了 。
Java 里有一个叫做Stack的类，却没有叫做Queue的类（它只是个接口名字，和类还不一样）。
1public interface Queue&lt;E&gt; extends Collection&lt;E&gt; {}
当需要使用栈时，Java 已不推荐使用Stack，而是推荐使用更高效的ArrayDeque（双端队列），原因我们第一次讲集合框架的时候，其实已经聊过了，Stack 是一个“原始”类，它的核心方法上都加了 synchronized 关键字以确保线程安全，当我们不需要线程安全（比如说单线程环境下）性能就会比较差。

也就是说，当需要使用栈时候，请首选ArrayDeque。
1234567891011121314151617181920212223242526272829303132&#x2F;&#x2F; 声明一个双端队列ArrayDeque&lt;String&gt; stack &#x3D; new ArrayDeque&lt;&gt;();&#x2F;&#x2F; 增加元素stack.push(&quot;沉默&quot;);stack.push(&quot;王二&quot;);stack.push(&quot;陈清扬&quot;);&#x2F;&#x2F; 获取栈顶元素String top &#x3D; stack.peek();System.out.println(&quot;栈顶元素为：&quot; + top); &#x2F;&#x2F; 陈清扬&#x2F;&#x2F; 弹出栈顶元素String pop &#x3D; stack.pop();System.out.println(&quot;弹出的元素为：&quot; + pop); &#x2F;&#x2F; 陈清扬&#x2F;&#x2F; 修改栈顶元素stack.pop();stack.push(&quot;小明&quot;);System.out.println(&quot;修改后的栈为：&quot; + stack); &#x2F;&#x2F; [沉默, 小明]&#x2F;&#x2F; 遍历队列查找元素Iterator&lt;String&gt; iterator &#x3D; stack.iterator();int index &#x3D; -1;String target &#x3D; &quot;王二&quot;;while (iterator.hasNext()) {    String element &#x3D; iterator.next();    index++;    if (element.equals(target)) {        break;    }}if (index &#x3D;&#x3D; -1) {    System.out.println(&quot;元素 &quot; + target + &quot; 不存在于队列中&quot;);} else {    System.out.println(&quot;元素 &quot; + target + &quot; 在队列中的位置为：&quot; + index);}
在上面的示例中，我们先创建了一个 ArrayDeque 对象，然后使用 push 方法向栈中添加了三个元素。接着使用 peek 方法获取栈顶元素，使用 pop 方法弹出栈顶元素，使用 pop 和 push 方法修改栈顶元素，使用迭代器查找元素在栈中的位置。
ArrayDeque 又实现了 Deque 接口（Deque 又实现了 Queue 接口）：
123public class ArrayDeque&lt;E&gt; extends AbstractCollection&lt;E&gt;                           implements Deque&lt;E&gt;, Cloneable, Serializable{}
因此，当我们需要使用队列的时候，也可以选择 ArrayDeque。
1234567891011121314151617181920212223242526ArrayDeque&lt;String&gt; queue &#x3D; new ArrayDeque&lt;&gt;();&#x2F;&#x2F; 增加元素queue.offer(&quot;沉默&quot;);queue.offer(&quot;王二&quot;);queue.offer(&quot;陈清扬&quot;);&#x2F;&#x2F; 获取队首元素String front &#x3D; queue.peek();System.out.println(&quot;队首元素为：&quot; + front); &#x2F;&#x2F; 沉默&#x2F;&#x2F; 弹出队首元素String poll &#x3D; queue.poll();System.out.println(&quot;弹出的元素为：&quot; + poll); &#x2F;&#x2F; 沉默&#x2F;&#x2F; 修改队列中的元素queue.poll();queue.offer(&quot;小明&quot;);System.out.println(&quot;修改后的队列为：&quot; + queue); &#x2F;&#x2F; [陈清扬, 小明]&#x2F;&#x2F; 查找元素Iterator&lt;String&gt; iterator &#x3D; queue.iterator();int index &#x3D; 0;while (iterator.hasNext()) {    String element &#x3D; iterator.next();    if (element.equals(&quot;王二&quot;)) {        System.out.println(&quot;元素在队列中的位置为：&quot; + index); &#x2F;&#x2F; 0        break;    }    index++;}
在上面的示例中，我们先创建了一个 ArrayDeque 对象，然后使用 offer 方法向队列中添加了三个元素。接着使用 peek 方法获取队首元素，使用 poll 方法弹出队首元素，使用 poll 和 offer 方法修改队列中的元素，使用迭代器查找元素在队列中的位置。
我们前面讲了，LinkedList不只是个 List，还是一个 Queue，它也实现了 Deque 接口。
1234public class LinkedList&lt;E&gt;    extends AbstractSequentialList&lt;E&gt;    implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable{}
所以，当我们需要使用队列时，还可以选择LinkedList。
123456789101112131415161718192021222324252627&#x2F;&#x2F; 创建一个 LinkedList 对象LinkedList&lt;String&gt; queue &#x3D; new LinkedList&lt;&gt;();&#x2F;&#x2F; 添加元素queue.offer(&quot;沉默&quot;);queue.offer(&quot;王二&quot;);queue.offer(&quot;陈清扬&quot;);System.out.println(queue); &#x2F;&#x2F; 输出 [沉默, 王二, 陈清扬]&#x2F;&#x2F; 删除元素queue.poll();System.out.println(queue); &#x2F;&#x2F; 输出 [王二, 陈清扬]&#x2F;&#x2F; 修改元素：LinkedList 中的元素不支持直接修改，需要先删除再添加String first &#x3D; queue.poll();queue.offer(&quot;王大二&quot;);System.out.println(queue); &#x2F;&#x2F; 输出 [陈清扬, 王大二]&#x2F;&#x2F; 查找元素：LinkedList 中的元素可以使用 get() 方法进行查找System.out.println(queue.get(0)); &#x2F;&#x2F; 输出 陈清扬System.out.println(queue.contains(&quot;沉默&quot;)); &#x2F;&#x2F; 输出 false&#x2F;&#x2F; 查找元素：使用迭代器的方式查找陈清扬&#x2F;&#x2F; 使用迭代器依次遍历元素并查找Iterator&lt;String&gt; iterator &#x3D; queue.iterator();while (iterator.hasNext()) {    String element &#x3D; iterator.next();    if (element.equals(&quot;陈清扬&quot;)) {        System.out.println(&quot;找到了：&quot; + element);        break;    }}
在使用 LinkedList 作为队列时，可以使用 offer() 方法将元素添加到队列的末尾，使用 poll() 方法从队列的头部删除元素，使用迭代器或者 poll() 方法依次遍历元素。
栈和队列 
要讲栈和队列，首先要讲Deque接口。Deque的含义是“double ended queue”，即双端队列，它既可以当作栈使用，也可以当作队列使用。下表列出了Deque与Queue相对应的接口：




Queue Method
Equivalent Deque Method
说明




add(e)
addLast(e)
向队尾插入元素，失败则抛出异常


offer(e)
offerLast(e)
向队尾插入元素，失败则返回 false


remove()
removeFirst()
获取并删除队首元素，失败则抛出异常


poll()
pollFirst()
获取并删除队首元素，失败则返回 null


element()
getFirst()
获取但不删除队首元素，失败则抛出异常


peek()
peekFirst()
获取但不删除队首元素，失败则返回 null




下表列出了Deque与Stack对应的接口：




Stack Method
Equivalent Deque Method
说明




push(e)
addFirst(e)
向栈顶插入元素，失败则抛出异常


无
offerFirst(e)
向栈顶插入元素，失败则返回 false


pop()
removeFirst()
获取并删除栈顶元素，失败则抛出异常


无
pollFirst()
获取并删除栈顶元素，失败则返回 null


peek()
getFirst()
获取但不删除栈顶元素，失败则抛出异常


无
peekFirst()
获取但不删除栈顶元素，失败则返回 null




上面两个表共定义了Deque的 12 个接口。
添加，删除，取值都有两套接口，它们功能相同，区别是对失败情况的处理不同。
一套接口遇到失败就会抛出异常，另一套遇到失败会返回特殊值（ 或 ）。除非某种实现对容量有限制，大多数情况下，添加操作是不会失败的。
虽然Deque的接口有 12 个之多，但无非就是对容器的两端进行操作，或添加，或删除，或查看。明白了这一点讲解起来就会非常简单。
ArrayDeque和LinkedList是Deque的两个通用实现，由于官方更推荐使用ArrayDeque用作栈和队列，加之上一篇已经讲解过LinkedList，本文将着重讲解ArrayDeque的具体实现。
从名字可以看出ArrayDeque底层通过数组实现，为了满足可以同时在数组两端插入或删除元素的需求，该数组还必须是循环的，即循环数组（circular array），也就是说数组的任何一点都可能被看作起点或者终点。
ArrayDeque是非线程安全的（not thread-safe），当多个线程同时使用的时候，需要手动同步；另外，该容器不允许放入 null元素。

上图中我们看到， head指向首端第一个有效元素， tail指向尾端第一个可以插入元素的空位。因为是循环数组，所以 head不一定总等于 0， tail也不一定总是比 head大。
方法剖析 
addFirst() 
addFirst(E e)的作用是在Deque的首端插入元素，也就是在 head的前面插入元素，在空间足够且下标没有越界的情况下，只需要将 elements[—head] &#x3D; e即可。

实际需要考虑：

空间是否够用，以及 
下标是否越界的问题。

上图中，如果 head为 0之后接着调用 addFirst() ，虽然空余空间还够用，但 head为 -1 ，下标越界了。
下列代码很好的解决了这两个问题。
12345678&#x2F;&#x2F;addFirst(E e)public void addFirst(E e) {    if (e &#x3D;&#x3D; null)&#x2F;&#x2F;不允许放入null        throw new NullPointerException();    elements[head &#x3D; (head - 1) &amp; (elements.length - 1)] &#x3D; e;&#x2F;&#x2F;2.下标是否越界    if (head &#x3D;&#x3D; tail)&#x2F;&#x2F;1.空间是否够用        doubleCapacity();&#x2F;&#x2F;扩容}
上述代码我们看到，空间问题是在插入之后解决的，因为 tail总是指向下一个可插入的空位，也就意味着elements数组至少有一个空位，所以插入元素的时候不用考虑空间问题。
下标越界的处理解决起来非常简单， head &#x3D; (head - 1) &amp; (elements.length - 1)就可以了，这段代码相当于取余，同时解决了 head为负值的情况。因为 elements.length必需是 2的指数倍， elements - 1就是二进制低位全 1 ，跟 head - 1相与之后就起到了取模的作用，如果 head - 1为负数（其实只可能是-1），则相当于对其取相对于 elements.length的补码。
下面再说说扩容函数 doubleCapacity() ，其逻辑是申请一个更大的数组（原数组的两倍），然后将原数组复制过去。过程如下图所示：

图中我们看到，复制分两次进行，第一次复制 head右边的元素，第二次复制 head左边的元素。
12345678910111213141516&#x2F;&#x2F;doubleCapacity()private void doubleCapacity() {    assert head &#x3D;&#x3D; tail;    int p &#x3D; head;    int n &#x3D; elements.length;    int r &#x3D; n - p; &#x2F;&#x2F; head右边元素的个数    int newCapacity &#x3D; n &lt;&lt; 1;&#x2F;&#x2F;原空间的2倍    if (newCapacity &lt; 0)        throw new IllegalStateException(&quot;Sorry, deque too big&quot;);    Object[] a &#x3D; new Object[newCapacity];    System.arraycopy(elements, p, a, 0, r);&#x2F;&#x2F;复制右半部分，对应上图中绿色部分    System.arraycopy(elements, 0, a, r, p);&#x2F;&#x2F;复制左半部分，对应上图中灰色部分    elements &#x3D; (E[])a;    head &#x3D; 0;    tail &#x3D; n;}
该方法的实现中，首先检查 head 和 tail 是否相等，如果不相等则抛出异常。然后计算出 head 右边的元素个数 r，以及新的容量 newCapacity，如果 newCapacity 太大则抛出异常。
接下来创建一个新的 Object 数组 a，将原有 ArrayDeque 中 head 右边的元素复制到 a 的前面（即图中绿色部分），将 head 左边的元素复制到 a 的后面（即图中灰色部分）。最后将 elements 数组替换为 a，head 设置为 0，tail 设置为 n（即新容量的长度）。
需要注意的是，由于 elements 数组被替换为 a 数组，因此在方法调用结束后，原有的 elements 数组将不再被引用，会被垃圾回收器回收。
addLast() 
addLast(E e)的作用是在Deque的尾端插入元素，也就是在 tail的位置插入元素，由于 tail总是指向下一个可以插入的空位，因此只需要 elements[tail] &#x3D; e;即可。插入完成后再检查空间，如果空间已经用光，则调用 doubleCapacity()进行扩容。

下标越界处理方式 addFirt()中已经讲过，不再赘述。
pollFirst() 
pollFirst()的作用是删除并返回Deque首端元素，也即是 head位置处的元素。如果容器不空，只需要直接返回 elements[head]即可，当然还需要处理下标的问题。由于 ArrayDeque中不允许放入 null ，当elements[head] &#x3D;&#x3D; null时，意味着容器为空。
12345678public E pollFirst() {    E result &#x3D; elements[head];    if (result &#x3D;&#x3D; null)&#x2F;&#x2F;null值意味着deque为空        return null;    elements[h] &#x3D; null;&#x2F;&#x2F;let GC work    head &#x3D; (head + 1) &amp; (elements.length - 1);&#x2F;&#x2F;下标越界处理    return result;}
pollLast() 
pollLast()的作用是删除并返回Deque尾端元素，也即是 tail位置前面的那个元素。
123456789public E pollLast() {    int t &#x3D; (tail - 1) &amp; (elements.length - 1);&#x2F;&#x2F;tail的上一个位置是最后一个元素    E result &#x3D; elements[t];    if (result &#x3D;&#x3D; null)&#x2F;&#x2F;null值意味着deque为空        return null;    elements[t] &#x3D; null;&#x2F;&#x2F;let GC work    tail &#x3D; t;    return result;}
peekFirst() 
peekFirst()的作用是返回但不删除Deque首端元素，也即是 head位置处的元素，直接返回elements[head]即可。
123public E peekFirst() {    return elements[head]; &#x2F;&#x2F; elements[head] is null if deque empty}
peekLast() 
peekLast()的作用是返回但不删除Deque尾端元素，也即是 tail位置前面的那个元素。
123public E peekLast() {    return elements[(tail - 1) &amp; (elements.length - 1)];}
小结 
当需要实现先进先出(FIFO)或者先进后出(LIFO)的数据结构时，可以考虑使用 ArrayDeque。以下是一些使用 ArrayDeque 的场景：

管理任务队列：如果需要实现一个任务队列，可以使用 ArrayDeque 来存储任务元素。在队列头部添加新任务元素，从队列尾部取出任务进行处理，可以保证任务按照先进先出的顺序执行。
实现栈：ArrayDeque 可以作为栈的实现方式，支持 push、pop、peek 等操作，可以用于需要后进先出的场景。
实现缓存：在需要缓存一定数量的数据时，可以使用 ArrayDeque。当缓存的数据量超过容量时，可以从队列头部删除最老的数据，从队列尾部添加新的数据。
实现事件处理器：ArrayDeque 可以作为事件处理器的实现方式，支持从队列头部获取事件进行处理，从队列尾部添加新的事件。

简单总结一下吧。
ArrayDeque 是 Java 标准库中的一种双端队列实现，底层基于数组实现。与 LinkedList 相比，ArrayDeque 的性能更优，因为它使用连续的内存空间存储元素，可以更好地利用 CPU 缓存，在大多数情况下也更快。
为什么这么说呢？
因为ArrayDeque 的底层实现是数组，而 LinkedList 的底层实现是链表。数组是一段连续的内存空间，而链表是由多个节点组成的，每个节点存储数据和指向下一个节点的指针。因此，在使用 LinkedList 时，需要频繁进行内存分配和释放，而 ArrayDeque 在创建时就一次性分配了连续的内存空间，不需要频繁进行内存分配和释放，这样可以更好地利用 CPU 缓存，提高访问效率。
现代计算机CPU对于数据的局部性有很强的依赖，如果需要访问的数据在内存中是连续存储的，那么就可以利用CPU的缓存机制，提高访问效率。而当数据存储在不同的内存块里时，每次访问都需要从内存中读取，效率会受到影响。
当然了，使用 ArrayDeque 时，数组复制操作也是需要考虑的性能消耗之一。
当 ArrayDeque 的元素数量超过了初始容量时，会触发扩容操作。扩容操作会创建一个新的数组，并将原有元素复制到新数组中。扩容操作的时间复杂度为 O(n)。
不过，ArrayDeque 的扩容策略（当 ArrayDeque 中的元素数量达到数组容量时，就需要进行扩容操作，扩容时会将数组容量扩大为原来的两倍）可以在一定程度上减少数组复制的次数和时间消耗，同时保证 ArrayDeque 的性能和空间利用率。
ArrayDeque 不仅支持常见的队列操作，如添加元素、删除元素、获取队列头部元素、获取队列尾部元素等。同时，它还支持栈操作，如 push、pop、peek 等。这使得 ArrayDeque 成为一种非常灵活的数据结构，可以用于各种场景的数据存储和处理。
4.13 优先级队列PriorityQueue详解继续有请王老师，来上台给大家讲讲优先级队列 PriorityQueue。
PriorityQueue 是 Java 中的一个基于优先级堆的优先队列实现，它能够在 O(log n) 的时间复杂度内实现元素的插入和删除操作，并且能够自动维护队列中元素的优先级顺序。
通俗来说，PriorityQueue 就是一个队列，但是它不是先进先出的，而是按照元素优先级进行排序的。当你往 PriorityQueue 中插入一个元素时，它会自动根据元素的优先级将其插入到合适的位置。当你从 PriorityQueue 中删除一个元素时，它会自动将优先级最高的元素出队。
下面 是一个简单的PriorityQueue示例：
1234567891011&#x2F;&#x2F; 创建 PriorityQueue 对象PriorityQueue&lt;String&gt; priorityQueue &#x3D; new PriorityQueue&lt;&gt;();&#x2F;&#x2F; 添加元素到 PriorityQueuepriorityQueue.offer(&quot;沉默王二&quot;);priorityQueue.offer(&quot;陈清扬&quot;);priorityQueue.offer(&quot;小转铃&quot;);&#x2F;&#x2F; 打印 PriorityQueue 中的元素System.out.println(&quot;PriorityQueue 中的元素：&quot;);while (!priorityQueue.isEmpty()) {    System.out.print(priorityQueue.poll() + &quot; &quot;);}
在上述代码中，我们首先创建了一个 PriorityQueue 对象，并向其中添加了三个元素。然后，我们使用 while 循环遍历 PriorityQueue 中的元素，并打印出来。来看输出结果：
12PriorityQueue 中的元素：小转铃 沉默王二 陈清扬 
再来看一下示例。
123456789101112&#x2F;&#x2F; 创建 PriorityQueue 对象，并指定优先级顺序PriorityQueue&lt;String&gt; priorityQueue &#x3D; new PriorityQueue&lt;&gt;(Comparator.reverseOrder());&#x2F;&#x2F; 添加元素到 PriorityQueuepriorityQueue.offer(&quot;沉默王二&quot;);priorityQueue.offer(&quot;陈清扬&quot;);priorityQueue.offer(&quot;小转铃&quot;);&#x2F;&#x2F; 打印 PriorityQueue 中的元素System.out.println(&quot;PriorityQueue 中的元素：&quot;);while (!priorityQueue.isEmpty()) {    System.out.print(priorityQueue.poll() + &quot; &quot;);}
在上述代码中，我们使用了 Comparator.reverseOrder() 方法指定了 PriorityQueue 的优先级顺序为降序。
也就是说，PriorityQueue 中的元素会按照从大到小的顺序排序。
其他部分的代码与之前的例子相同，我们再来看一下输出结果：
12PriorityQueue 中的元素：陈清扬 沉默王二 小转铃
对比一下两个例子的输出结果，不难发现，顺序正好相反。
PriorityQueue的作用 
PriorityQueue 的主要作用是维护一组数据的排序，使得取出数据时可以按照一定的优先级顺序进行，当我们调用 poll() 方法时，它会从队列的顶部弹出最高优先级的元素。它在很多场景下都有广泛的应用，例如任务调度、事件处理等场景，以及一些算法中需要对数据进行排序的场景。
在实际应用中，PriorityQueue 也经常用于实现 Dijkstra 算法、Prim 算法、Huffman 编码等算法。这里简单说一下这几种算法的作用，理解不了也没关系哈。
Dijkstra算法是一种用于计算带权图中的最短路径的算法。该算法采用贪心的策略，在遍历图的过程中，每次选取当前到源点距离最短的一个顶点，并以它为中心进行扩展，更新其他顶点的距离值。经过多次扩展，可以得到源点到其它所有顶点的最短路径。
Prim算法是一种用于求解最小生成树的算法，可以在加权连通图中找到一棵生成树，使得这棵生成树的所有边的权值之和最小。该算法从任意一个顶点开始，逐渐扩展生成树的规模，每次选择一个距离已生成树最近的顶点加入到生成树中。
Huffman编码是一种基于霍夫曼树的压缩算法，用于将一个字符串转换为二进制编码以进行压缩。该算法的主要思想是通过建立霍夫曼树，将出现频率较高的字符用较短的编码表示，而出现频率较低的字符用较长的编码表示，从而实现对字符串的压缩。在解压缩时，根据编码逐步解析出原字符串。
由于 PriorityQueue 的底层是基于堆实现的，因此在数据量比较大时，使用 PriorityQueue 可以获得较好的时间复杂度。
这里牵涉到了大小关系，元素大小的评判可以通过元素本身的自然顺序（natural ordering），也可以通过构造时传入的比较器（Comparator，或者元素自身实现 Comparable 接口）来决定。
在 PriorityQueue 中，每个元素都有一个优先级，这个优先级决定了元素在队列中的位置。队列内部通过小顶堆（也可以是大顶堆）的方式来维护元素的优先级关系。具体来说，小顶堆是一个完全二叉树，任何一个非叶子节点的权值，都不大于其左右子节点的权值，这样保证了队列的顶部元素（堆顶）一定是优先级最高的元素。
完全二叉树（Complete Binary Tree）是一种二叉树，其中除了最后一层，其他层的节点数都是满的，最后一层的节点都靠左对齐。下面是一个完全二叉树的示意图：
12345     1   &#x2F;   \  2     3 &#x2F; \   &#x2F;4   5 6
堆是一种完全二叉树，堆的特点是根节点的值最小（小顶堆）或最大（大顶堆），并且任意非根节点i的值都不大于（或不小于）其父节点的值。
这是一颗包含整数 1, 2, 3, 4, 5, 6, 7 的小顶堆：
12345    1   &#x2F; \  2   3 &#x2F; \ &#x2F; \4  5 6  7
这是一颗大顶堆。
12345     8   &#x2F;   \  7     5 &#x2F; \   &#x2F; \6   4 2   1
因为完全二叉树的结构比较规则，所以可以使用数组来存储堆的元素，而不需要使用指针等额外的空间。
在堆中，每个节点的下标和其在数组中的下标是一一对应的，假设节点下标为i，则其父节点下标为i&#x2F;2，其左子节点下标为2i，其右子节点下标为2i+1。
假设有一个数组arr&#x3D;[10, 20, 15, 30, 40]，现在要将其转化为一个小顶堆。
首先，我们将数组按照完全二叉树的形式排列，如下图所示：
12345      10     &#x2F;  \   20    15  &#x2F;  \30   40
从上往下、从左往右依次给每个节点编号，如下所示：
12345    1   &#x2F; \  2   3 &#x2F; \4   5
接下来，我们按照上述公式，依次确定每个节点在数组中的位置。例如，节点1的父节点下标为1&#x2F;2&#x3D;0，左子节点下标为21&#x3D;2，右子节点下标为21+1&#x3D;3，因此节点1在数组中的位置为0，节点2在数组中的位置为2，节点3在数组中的位置为3。
对应的数组为[10, 20, 15, 30, 40]，符合小顶堆的定义，即每个节点的值都小于或等于其子节点的值。
好，我们画幅图再来理解一下。

上图中我们给每个元素按照层序遍历的方式进行了编号，如果你足够细心，会发现父节点和子节点的编号是有联系的，更确切的说父子节点的编号之间有如下关系：
123leftNo &#x3D; parentNo\*2+1rightNo &#x3D; parentNo\*2+2parentNo &#x3D; (nodeNo-1)&#x2F;2
通过上述三个公式，可以轻易计算出某个节点的父节点以及子节点的下标。这也就是为什么可以直接用数组来存储堆的原因。
方法剖析 
add()和 offer() 
add(E e)和 offer(E e)的语义相同，都是向优先队列中插入元素，只是 Queue接口规定二者对插入失败时的处理不同，前者在插入失败时抛出异常，后则则会返回 false 。对于PriorityQueue这两个方法其实没什么差别。

新加入的元素可能会破坏小顶堆的性质，因此需要进行必要的调整。
123456789101112131415&#x2F;&#x2F;offer(E e)public boolean offer(E e) {    if (e &#x3D;&#x3D; null)&#x2F;&#x2F;不允许放入null元素        throw new NullPointerException();    modCount++;    int i &#x3D; size;    if (i &gt;&#x3D; queue.length)        grow(i + 1);&#x2F;&#x2F;自动扩容    size &#x3D; i + 1;    if (i &#x3D;&#x3D; 0)&#x2F;&#x2F;队列原来为空，这是插入的第一个元素        queue[0] &#x3D; e;    else        siftUp(i, e);&#x2F;&#x2F;调整    return true;}
上述代码中，扩容函数 grow()类似于 ArrayList里的 grow()函数，就是再申请一个更大的数组，并将原数组的元素复制过去，这里不再赘述。需要注意的是 siftUp(int k, E x)方法，该方法用于插入元素 x并维持堆的特性。
123456789101112&#x2F;&#x2F;siftUp()private void siftUp(int k, E x) {    while (k &gt; 0) {        int parent &#x3D; (k - 1) &gt;&gt;&gt; 1;&#x2F;&#x2F;parentNo &#x3D; (nodeNo-1)&#x2F;2        Object e &#x3D; queue[parent];        if (comparator.compare(x, (E) e) &gt;&#x3D; 0)&#x2F;&#x2F;调用比较器的比较方法            break;        queue[k] &#x3D; e;        k &#x3D; parent;    }    queue[k] &#x3D; x;}
调整的过程为：从k指定的位置开始，将x逐层与当前点的parent进行比较并交换，直到满足x &gt;&#x3D; queue[parent]为止。注意这里的比较可以是元素的自然顺序，也可以是依靠比较器的顺序。
element()和 peek() 
element()和 peek()的语义完全相同，都是获取但不删除队首元素，也就是队列中权值最小的那个元素，二者唯一的区别是当方法失败时前者抛出异常，后者返回 null 。根据小顶堆的性质，堆顶那个元素就是全局最小的那个；由于堆用数组表示，根据下标关系， 0下标处的那个元素既是堆顶元素。所以直接返回数组0下标处的那个元素即可。

代码也就非常简洁：
123456&#x2F;&#x2F;peek()public E peek() {    if (size &#x3D;&#x3D; 0)        return null;    return (E) queue[0];&#x2F;&#x2F;0下标处的那个元素就是最小的那个}
remove()和 poll() 
remove()和 poll()方法的语义也完全相同，都是获取并删除队首元素，区别是当方法失败时前者抛出异常，后者返回 null 。由于删除操作会改变队列的结构，为维护小顶堆的性质，需要进行必要的调整。

代码如下：
123456789101112public E poll() {    if (size &#x3D;&#x3D; 0)        return null;    int s &#x3D; --size;    modCount++;    E result &#x3D; (E) queue[0];&#x2F;&#x2F;0下标处的那个元素就是最小的那个    E x &#x3D; (E) queue[s];    queue[s] &#x3D; null;    if (s !&#x3D; 0)        siftDown(0, x);&#x2F;&#x2F;调整    return result;}
上述代码首先记录 0下标处的元素，并用最后一个元素替换 0下标位置的元素，之后调用 siftDown()方法对堆进行调整，最后返回原来 0下标处的那个元素（也就是最小的那个元素）。重点是 siftDown(int k, E x)方法，该方法的作用是从 k指定的位置开始，将 x逐层向下与当前点的左右孩子中较小的那个交换，直到 小于或等于左右孩子中的任何一个为止。
123456789101112131415161718&#x2F;&#x2F;siftDown()private void siftDown(int k, E x) {    int half &#x3D; size &gt;&gt;&gt; 1;    while (k &lt; half) {      &#x2F;&#x2F;首先找到左右孩子中较小的那个，记录到c里，并用child记录其下标        int child &#x3D; (k &lt;&lt; 1) + 1;&#x2F;&#x2F;leftNo &#x3D; parentNo*2+1        Object c &#x3D; queue[child];        int right &#x3D; child + 1;        if (right &lt; size &amp;&amp;            comparator.compare((E) c, (E) queue[right]) &gt; 0)            c &#x3D; queue[child &#x3D; right];        if (comparator.compare(x, (E) c) &lt;&#x3D; 0)            break;        queue[k] &#x3D; c;&#x2F;&#x2F;然后用c取代原来的值        k &#x3D; child;    }    queue[k] &#x3D; x;}
remove(Object o) 
remove(Object o)方法用于删除队列中跟 o相等的某一个元素（如果有多个相等，只删除一个），该方法不是Queue接口内的方法，而是Collection接口的方法。由于删除操作会改变队列结构，所以要进行调整；又由于删除元素的位置可能是任意的，所以调整过程比其它方法稍加繁琐。
具体来说， remove(Object o)可以分为 2 种情况：

删除的是最后一个元素。直接删除即可，不需要调整。
删除的不是最后一个元素，从删除点开始以最后一个元素为参照调用一次 siftDown()即可。此处不再赘述。


具体代码如下：
1234567891011121314151617&#x2F;&#x2F;remove(Object o)public boolean remove(Object o) {  &#x2F;&#x2F;通过遍历数组的方式找到第一个满足o.equals(queue[i])元素的下标    int i &#x3D; indexOf(o);    if (i &#x3D;&#x3D; -1)        return false;    int s &#x3D; --size;    if (s &#x3D;&#x3D; i) &#x2F;&#x2F;情况1        queue[i] &#x3D; null;    else {        E moved &#x3D; (E) queue[s];        queue[s] &#x3D; null;        siftDown(i, moved);&#x2F;&#x2F;情况2        ......    }    return true;}
小结 
PriorityQueue 是一个非常常用的数据结构，它是一种特殊的堆（Heap）实现，可以用来高效地维护一个有序的集合。

它的底层实现是一个数组，通过堆的性质来维护元素的顺序。
取出元素时按照优先级顺序（从小到大或者从大到小）进行取出。
如果需要指定排序，元素必须实现 Comparable 接口或者传入一个 Comparator 来进行比较。

4.14 Comparable和Comparator的区别在前面学习优先级队列的时候，我们曾提到过 Comparable和Comparator，那这篇继续以面试官的角度去切入，一起来看。
那天，小二去马蜂窝面试，面试官老王一上来就甩给了他一道面试题：请问Comparable和Comparator有什么区别？小二差点笑出声，因为他在《Java进阶之路》上看到过这题 。
Comparable 和 Comparator 是 Java 的两个接口，从名字上我们就能够读出来它们俩的相似性：以某种方式来比较两个对象。但它们之间到底有什么区别呢？请随我来，打怪进阶喽！
01、Comparable 
Comparable 接口的定义非常简单，源码如下所示。
123public interface Comparable&lt;T&gt; {    int compareTo(T t);}
如果一个类实现了 Comparable 接口（只需要干一件事，重写 compareTo() 方法），就可以按照自己制定的规则将由它创建的对象进行比较。下面给出一个例子。
123456789101112131415161718192021public class Cmower implements Comparable&lt;Cmower&gt; {    private int age;    private String name;    public Cmower(int age, String name) {        this.age &#x3D; age;        this.name &#x3D; name;    }    @Override    public int compareTo(Cmower o) {        return this.getAge() - o.getAge();    }    public static void main(String[] args) {        Cmower wanger &#x3D; new Cmower(19,&quot;沉默王二&quot;);        Cmower wangsan &#x3D; new Cmower(16,&quot;沉默王三&quot;);        if (wanger.compareTo(wangsan) &lt; 0) {            System.out.println(wanger.getName() + &quot;比较年轻有为&quot;);        } else {            System.out.println(wangsan.getName() + &quot;比较年轻有为&quot;);        }    }}
在上面的示例中，我创建了一个 Cmower 类，它有两个字段：age 和 name。Cmower 类实现了 Comparable 接口，并重写了 compareTo() 方法。
程序输出的结果是“沉默王三比较年轻有为”，因为他比沉默王二小三岁。这个结果有什么凭证吗？
凭证就在于 compareTo() 方法，该方法的返回值可能为负数，零或者正数，代表的意思是该对象按照排序的规则小于、等于或者大于要比较的对象。如果指定对象的类型与此对象不能进行比较，则引发 ClassCastException 异常（自从有了泛型，这种情况就少有发生了）。
02、Comparator 
Comparator 接口的定义相比较于 Comparable 就复杂的多了，不过，核心的方法只有两个，来看一下源码。
1234public interface Comparator&lt;T&gt; {    int compare(T o1, T o2);    boolean equals(Object obj);}
第一个方法 compare(T o1, T o2) 的返回值可能为负数，零或者正数，代表的意思是第一个对象小于、等于或者大于第二个对象。
第二个方法 equals(Object obj) 需要传入一个 Object 作为参数，并判断该 Object 是否和 Comparator 保持一致。
有时候，我们想让类保持它的原貌，不想主动实现 Comparable 接口，但我们又需要它们之间进行比较，该怎么办呢？
Comparator 就派上用场了，来看一下示例。
1）原封不动的 Cmower 类。 
12345678public class Cmower  {    private int age;    private String name;    public Cmower(int age, String name) {        this.age &#x3D; age;        this.name &#x3D; name;    }}
Cmower 类有两个字段：age 和 name，意味着该类可以按照 age 或者 name 进行排序。
2）再来看 Comparator 接口的实现类。 
123456public class CmowerComparator implements Comparator&lt;Cmower&gt; {    @Override    public int compare(Cmower o1, Cmower o2) {        return o1.getAge() - o2.getAge();    }}
按照 age 进行比较。当然也可以再实现一个比较器，按照 name 进行自然排序，示例如下。
1234567891011public class CmowerNameComparator implements Comparator&lt;Cmower&gt; {    @Override    public int compare(Cmower o1, Cmower o2) {        if (o1.getName().hashCode() &lt; o2.getName().hashCode()) {            return -1;        } else if (o1.getName().hashCode() &#x3D;&#x3D; o2.getName().hashCode()) {            return 0;        }        return 1;    }}
3）再来看测试类。 
1234567891011Cmower wanger &#x3D; new Cmower(19,&quot;沉默王二&quot;);Cmower wangsan &#x3D; new Cmower(16,&quot;沉默王三&quot;);Cmower wangyi &#x3D; new Cmower(28,&quot;沉默王一&quot;);List&lt;Cmower&gt; list &#x3D; new ArrayList&lt;&gt;();list.add(wanger);list.add(wangsan);list.add(wangyi);list.sort(new CmowerComparator());for (Cmower c : list) {    System.out.println(c.getName());}
创建了三个对象，age 不同，name 不同，并把它们加入到了 List 当中。然后使用 List 的 sort() 方法进行排序，来看一下输出的结果。
123沉默王三沉默王二沉默王一
这意味着沉默王三的年纪比沉默王二小，排在第一位；沉默王一的年纪比沉默王二大，排在第三位。和我们的预期完全符合。
借此机会，再来看一下 sort 方法的源码：
123456789101112public void sort(Comparator&lt;? super E&gt; c) {    &#x2F;&#x2F; 保存当前队列的 modCount 值，用于检测 sort 操作是否非法    final int expectedModCount &#x3D; modCount;    &#x2F;&#x2F; 调用 Arrays.sort 对 elementData 数组进行排序，使用传入的比较器 c    Arrays.sort((E[]) elementData, 0, size, c);    &#x2F;&#x2F; 检查操作期间 modCount 是否被修改，如果被修改则抛出并发修改异常    if (modCount !&#x3D; expectedModCount) {        throw new ConcurrentModificationException();    }    &#x2F;&#x2F; 增加 modCount 值，表示队列已经被修改过    modCount++;}
可以看到，参数就是一个 Comparator 接口，并且使用了泛型 Comparator&lt;? super E&gt; c 。
03、到底该用哪一个？ 
通过上面的两个例子可以比较出 Comparable 和 Comparator 两者之间的区别：

一个类实现了 Comparable 接口，意味着该类的对象可以直接进行比较（排序），但比较（排序）的方式只有一种，很单一。
一个类如果想要保持原样，又需要进行不同方式的比较（排序），就可以定制比较器（实现 Comparator 接口）。
Comparable 接口在 java.lang 包下，而 Comparator 接口在 java.util 包下，算不上是亲兄弟，但可以称得上是表（堂）兄弟。

举个不恰当的例子。我想从洛阳出发去北京看长城，体验一下好汉的感觉，要么坐飞机，要么坐高铁；但如果是孙悟空的话，翻个筋斗就到了。我和孙悟空之间有什么区别呢？
孙悟空自己实现了 Comparable 接口（他那年代也没有飞机和高铁，没得选），而我可以借助 Comparator 接口（现代化的交通工具）。
好了，关于 Comparable 和 Comparator 我们就先聊这么多。总而言之，如果对象的排序需要基于自然顺序，请选择 Comparable ，如果需要按照对象的不同属性进行排序，请选择 Comparator 。
5 Java IO5.1 IO 分类“老王，Java IO 也太上头了吧？”新兵蛋子小二向头顶很凉快的老王抱怨道，“你瞧，我就按照传输方式对 IO 进行了一个简单的分类，就能搞出来这么多的玩意！”

好久没搞过 IO 了，老王看到这幅思维导图也是吃了一惊。想想也是，他当初学习 Java IO 的时候头也大，乌央乌央的一片，全是类，估计是所有 Java 包里面类最多的，一会是 Input 一会是 Output，一会是 Reader ，一会是 Writer，真不知道 Java 的设计者是怎么想的。
看着肺都快要气炸的小二，老王深深地吸了一口气，耐心地对小二说：“主要是 Java 的设计者考虑得比较多吧，所以 IO 给人一种很乱的感觉，我来给你梳理一下。”
00、初识 Java IO 
IO，即in和out，也就是输入和输出，指应用程序和外部设备之间的数据传递，常见的外部设备包括文件、管道、网络连接。
Java 中是通过流处理IO 的，那么什么是流？
流（Stream），是一个抽象的概念，是指一连串的数据（字符或字节），是以先进先出的方式发送信息的通道。
当程序需要读取数据的时候，就会开启一个通向数据源的流，这个数据源可以是文件，内存，或是网络连接。类似的，当程序需要写入数据的时候，就会开启一个通向目的地的流。这时候你就可以想象数据好像在这其中“流”动一样。
一般来说关于流的特性有下面几点：

先进先出：最先写入输出流的数据最先被输入流读取到。
顺序存取：可以一个接一个地往流中写入一串字节，读出时也将按写入顺序读取一串字节，不能随机访问中间的数据（RandomAccessFile除外）
只读或只写：每个流只能是输入流或输出流的一种，不能同时具备两个功能，输入流只能进行读操作，对输出流只能进行写操作。在一个数据传输通道中，如果既要写入数据，又要读取数据，则要分别提供两个流。

01、传输方式划分 
就按照你的那副思维导图来说吧。
传输方式有两种，字节和字符，那首先得搞明白字节和字符有什么区别，对吧？
字节（byte）是计算机中用来表示存储容量的一个计量单位，通常情况下，一个字节有 8 位（bit）。
字符（char）可以是计算机中使用的字母、数字、和符号，比如说 A 1 $ 这些。
通常来说，一个字母或者一个字符占用一个字节，一个汉字占用两个字节。

具体还要看字符编码，比如说在 UTF-8 编码下，一个英文字母（不分大小写）为一个字节，一个中文汉字为三个字节；在 Unicode 编码中，一个英文字母为一个字节，一个中文汉字为两个字节。
明白了字节与字符的区别，再来看字节流和字符流就会轻松多了。
字节流用来处理二进制文件，比如说图片啊、MP3 啊、视频啊。
字符流用来处理文本文件，文本文件可以看作是一种特殊的二进制文件，只不过经过了编码，便于人们阅读。
换句话说就是，字节流可以处理一切文件，而字符流只能处理文本。
虽然 IO 类很多，但核心的就是 4 个抽象类：InputStream、OutputStream、Reader、Writer。（抽象大法真好）
虽然 IO 类的方法也很多，但核心的也就 2 个：read 和 write。
InputStream 类

int read() ：读取数据
int read(byte b[], int off, int len) ：从第 off 位置开始读，读取 len 长度的字节，然后放入数组 b 中
long skip(long n) ：跳过指定个数的字节
int available() ：返回可读的字节数
void close() ：关闭流，释放资源

OutputStream 类

void write(int b) ： 写入一个字节，虽然参数是一个 int 类型，但只有低 8 位才会写入，高 24 位会舍弃（这块后面再讲）
void write(byte b[], int off, int len) ： 将数组 b 中的从 off 位置开始，长度为 len 的字节写入
void flush() ： 强制刷新，将缓冲区的数据写入
void close() ：关闭流

Reader 类

int read() ：读取单个字符
int read(char cbuf[], int off, int len) ：从第 off 位置开始读，读取 len 长度的字符，然后放入数组 b 中
long skip(long n) ：跳过指定个数的字符
int ready() ：是否可以读了
void close() ：关闭流，释放资源

Writer 类

void write(int c) ： 写入一个字符
void write( char cbuf[], int off, int len) ： 将数组 cbuf 中的从 off 位置开始，长度为 len 的字符写入
void flush() ： 强制刷新，将缓冲区的数据写入
void close() ：关闭流

理解了上面这些方法，基本上 IO 的灵魂也就全部掌握了。
字节流和字符流的区别：

字节流一般用来处理图像、视频、音频、PPT、Word等类型的文件。字符流一般用于处理纯文本类型的文件，如TXT文件等，但不能处理图像视频等非文本文件。用一句话说就是：字节流可以处理一切文件，而字符流只能处理纯文本文件。
字节流本身没有缓冲区，缓冲字节流相对于字节流，效率提升非常高。而字符流本身就带有缓冲区，缓冲字符流相对于字符流效率提升就不是那么大了。

以写文件为例，我们查看字符流的源码，发现确实有利用到缓冲区：
1234567891011121314151617181920212223242526&#x2F;&#x2F; 声明一个 char 类型的数组，用于写入输出流private char[] writeBuffer;&#x2F;&#x2F; 定义 writeBuffer 数组的大小，必须 &gt;&#x3D; 1private static final int WRITE_BUFFER_SIZE &#x3D; 1024;&#x2F;&#x2F; 写入给定字符串中的一部分到输出流中public void write(String str, int off, int len) throws IOException {    &#x2F;&#x2F; 使用 synchronized 关键字同步代码块，确保线程安全    synchronized (lock) {        char cbuf[];        &#x2F;&#x2F; 如果 len &lt;&#x3D; WRITE_BUFFER_SIZE，则使用 writeBuffer 数组进行写入        if (len &lt;&#x3D; WRITE_BUFFER_SIZE) {            &#x2F;&#x2F; 如果 writeBuffer 为 null，则创建一个大小为 WRITE_BUFFER_SIZE 的新 char 数组            if (writeBuffer &#x3D;&#x3D; null) {                writeBuffer &#x3D; new char[WRITE_BUFFER_SIZE];            }            cbuf &#x3D; writeBuffer;        } else {    &#x2F;&#x2F; 如果 len &gt; WRITE_BUFFER_SIZE，则不永久分配非常大的缓冲区            &#x2F;&#x2F; 创建一个大小为 len 的新 char 数组            cbuf &#x3D; new char[len];        }        &#x2F;&#x2F; 将 str 中的一部分（从 off 开始，长度为 len）拷贝到 cbuf 数组中        str.getChars(off, (off + len), cbuf, 0);        &#x2F;&#x2F; 将 cbuf 数组中的数据写入输出流中        write(cbuf, 0, len);    }}
这段代码是 Java IO 类库中的 OutputStreamWriter 类的 write 方法，可以看到缓冲区的大小是 1024 个 char。
我们再以文件的字符流和字节流来做一下对比，代码差别很小。
12345678910111213141516171819202122&#x2F;&#x2F; 字节流try (FileInputStream fis &#x3D; new FileInputStream(&quot;input.txt&quot;);     FileOutputStream fos &#x3D; new FileOutputStream(&quot;output.txt&quot;)) {    byte[] buffer &#x3D; new byte[1024];    int len;    while ((len &#x3D; fis.read(buffer)) !&#x3D; -1) {        fos.write(buffer, 0, len);    }} catch (IOException e) {    e.printStackTrace();}&#x2F;&#x2F; 字符流try (FileReader fr &#x3D; new FileReader(&quot;input.txt&quot;);     FileWriter fw &#x3D; new FileWriter(&quot;output.txt&quot;)) {    char[] buffer &#x3D; new char[1024];    int len;    while ((len &#x3D; fr.read(buffer)) !&#x3D; -1) {        fw.write(buffer, 0, len);    }} catch (IOException e) {    e.printStackTrace();}
02、操作对象划分 
小二，你细想一下，IO IO，不就是输入输出（Input&#x2F;Output）嘛：

Input：将外部的数据读入内存，比如说把文件从硬盘读取到内存，从网络读取数据到内存等等
Output：将内存中的数据写入到外部，比如说把数据从内存写入到文件，把数据从内存输出到网络等等。

所有的程序，在执行的时候，都是在内存上进行的，一旦关机，内存中的数据就没了，那如果想要持久化，就需要把内存中的数据输出到外部，比如说文件。
文件操作算是 IO 中最典型的操作了，也是最频繁的操作。那其实你可以换个角度来思考，比如说按照 IO 的操作对象来思考，IO 就可以分类为：文件、数组、管道、基本数据类型、缓冲、打印、对象序列化&#x2F;反序列化，以及转换等。

1）文件 
文件流也就是直接操作文件的流，可以细分为字节流（FileInputStream 和 FileOuputStream）和字符流（FileReader 和 FileWriter）。
FileInputStream 的例子：
1234567891011&#x2F;&#x2F; 声明一个 int 类型的变量 b，用于存储读取到的字节int b;&#x2F;&#x2F; 创建一个 FileInputStream 对象，用于读取文件 fis.txt 中的数据FileInputStream fis1 &#x3D; new FileInputStream(&quot;fis.txt&quot;);&#x2F;&#x2F; 循环读取文件中的数据while ((b &#x3D; fis1.read()) !&#x3D; -1) {    &#x2F;&#x2F; 将读取到的字节转换为对应的 ASCII 字符，并输出到控制台    System.out.println((char)b);}&#x2F;&#x2F; 关闭 FileInputStream 对象，释放资源fis1.close();
FileOutputStream 的例子：
123456&#x2F;&#x2F; 创建一个 FileOutputStream 对象，用于写入数据到文件 fos.txt 中FileOutputStream fos &#x3D; new FileOutputStream(&quot;fos.txt&quot;);&#x2F;&#x2F; 向文件中写入数据，这里写入的是字符串 &quot;沉默王二&quot; 对应的字节数组fos.write(&quot;沉默王二&quot;.getBytes());&#x2F;&#x2F; 关闭 FileOutputStream 对象，释放资源fos.close();
FileReader 的例子：
1234567891011&#x2F;&#x2F; 声明一个 int 类型的变量 b，用于存储读取到的字符int b &#x3D; 0;&#x2F;&#x2F; 创建一个 FileReader 对象，用于读取文件 read.txt 中的数据FileReader fileReader &#x3D; new FileReader(&quot;read.txt&quot;);&#x2F;&#x2F; 循环读取文件中的数据while ((b &#x3D; fileReader.read()) !&#x3D; -1) {    &#x2F;&#x2F; 将读取到的字符强制转换为 char 类型，并输出到控制台    System.out.println((char)b);}&#x2F;&#x2F; 关闭 FileReader 对象，释放资源fileReader.close();
FileWriter 的例子：
12345678&#x2F;&#x2F; 创建一个 FileWriter 对象，用于写入数据到文件 fw.txt 中FileWriter fileWriter &#x3D; new FileWriter(&quot;fw.txt&quot;);&#x2F;&#x2F; 将字符串 &quot;沉默王二&quot; 转换为字符数组char[] chars &#x3D; &quot;沉默王二&quot;.toCharArray();&#x2F;&#x2F; 向文件中写入数据，这里写入的是 chars 数组中的所有字符fileWriter.write(chars, 0, chars.length);&#x2F;&#x2F; 关闭 FileWriter 对象，释放资源fileWriter.close();
文件流还可以用于创建、删除、重命名文件等操作。FileOutputStream 和 FileWriter 构造函数的第二个参数可以指定是否追加数据到文件末尾。
示例代码：
123456789101112131415161718192021&#x2F;&#x2F; 创建文件File file &#x3D; new File(&quot;test.txt&quot;);if (file.createNewFile()) {    System.out.println(&quot;文件创建成功&quot;);} else {    System.out.println(&quot;文件已存在&quot;);}&#x2F;&#x2F; 删除文件if (file.delete()) {    System.out.println(&quot;文件删除成功&quot;);} else {    System.out.println(&quot;文件删除失败&quot;);}&#x2F;&#x2F; 重命名文件File oldFile &#x3D; new File(&quot;old.txt&quot;);File newFile &#x3D; new File(&quot;new.txt&quot;);if (oldFile.renameTo(newFile)) {    System.out.println(&quot;文件重命名成功&quot;);} else {    System.out.println(&quot;文件重命名失败&quot;);}
当掌握了文件的输入输出，其他的自然也就掌握了，都大差不差。
2）数组（内存）
通常来说，针对文件的读写操作，使用文件流配合缓冲流就够用了，但为了提升效率，频繁地读写文件并不是太好，那么就出现了数组流，有时候也称为内存流。
ByteArrayInputStream 的例子：
123456789101112131415&#x2F;&#x2F; 创建一个 ByteArrayInputStream 对象，用于从字节数组中读取数据InputStream is &#x3D; new BufferedInputStream(        new ByteArrayInputStream(                &quot;沉默王二&quot;.getBytes(StandardCharsets.UTF_8)));&#x2F;&#x2F; 定义一个字节数组用于存储读取到的数据byte[] flush &#x3D; new byte[1024];&#x2F;&#x2F; 定义一个变量用于存储每次读取到的字节数int len &#x3D; 0;&#x2F;&#x2F; 循环读取字节数组中的数据，并输出到控制台while (-1 !&#x3D; (len &#x3D; is.read(flush))) {    &#x2F;&#x2F; 将读取到的字节转换为对应的字符串，并输出到控制台    System.out.println(new String(flush, 0, len));}&#x2F;&#x2F; 关闭输入流，释放资源is.close();
ByteArrayOutputStream 的例子：
12345678910&#x2F;&#x2F; 创建一个 ByteArrayOutputStream 对象，用于写入数据到内存缓冲区中ByteArrayOutputStream bos &#x3D; new ByteArrayOutputStream();&#x2F;&#x2F; 定义一个字节数组用于存储要写入内存缓冲区中的数据byte[] info &#x3D; &quot;沉默王二&quot;.getBytes();&#x2F;&#x2F; 向内存缓冲区中写入数据，这里写入的是 info 数组中的所有字节bos.write(info, 0, info.length);&#x2F;&#x2F; 将内存缓冲区中的数据转换为字节数组byte[] dest &#x3D; bos.toByteArray();&#x2F;&#x2F; 关闭 ByteArrayOutputStream 对象，释放资源bos.close();
数组流可以用于在内存中读写数据，比如将数据存储在字节数组中进行压缩、加密、序列化等操作。它的优点是不需要创建临时文件，可以提高程序的效率。但是，数组流也有缺点，它只能存储有限的数据量，如果存储的数据量过大，会导致内存溢出。
3）管道 
Java 中的管道和 Unix&#x2F;Linux 中的管道不同，在 Unix&#x2F;Linux 中，不同的进程之间可以通过管道来通信，但 Java 中，通信的双方必须在同一个进程中，也就是在同一个 JVM 中，管道为线程之间的通信提供了通信能力。
一个线程通过 PipedOutputStream 写入的数据可以被另外一个线程通过相关联的 PipedInputStream 读取出来。
1234567891011121314151617181920212223242526272829303132333435363738394041&#x2F;&#x2F; 创建一个 PipedOutputStream 对象和一个 PipedInputStream 对象final PipedOutputStream pipedOutputStream &#x3D; new PipedOutputStream();final PipedInputStream pipedInputStream &#x3D; new PipedInputStream(pipedOutputStream);&#x2F;&#x2F; 创建一个线程，向 PipedOutputStream 中写入数据Thread thread1 &#x3D; new Thread(new Runnable() {    @Override    public void run() {        try {            &#x2F;&#x2F; 将字符串 &quot;沉默王二&quot; 转换为字节数组，并写入到 PipedOutputStream 中            pipedOutputStream.write(&quot;沉默王二&quot;.getBytes(StandardCharsets.UTF_8));            &#x2F;&#x2F; 关闭 PipedOutputStream，释放资源            pipedOutputStream.close();        } catch (IOException e) {            e.printStackTrace();        }    }});&#x2F;&#x2F; 创建一个线程，从 PipedInputStream 中读取数据并输出到控制台Thread thread2 &#x3D; new Thread(new Runnable() {    @Override    public void run() {        try {            &#x2F;&#x2F; 定义一个字节数组用于存储读取到的数据            byte[] flush &#x3D; new byte[1024];            &#x2F;&#x2F; 定义一个变量用于存储每次读取到的字节数            int len &#x3D; 0;            &#x2F;&#x2F; 循环读取字节数组中的数据，并输出到控制台            while (-1 !&#x3D; (len &#x3D; pipedInputStream.read(flush))) {                &#x2F;&#x2F; 将读取到的字节转换为对应的字符串，并输出到控制台                System.out.println(new String(flush, 0, len));            }            &#x2F;&#x2F; 关闭 PipedInputStream，释放资源            pipedInputStream.close();        } catch (IOException e) {            e.printStackTrace();        }    }});&#x2F;&#x2F; 启动线程1和线程2thread1.start();thread2.start();
使用管道流可以实现不同线程之间的数据传输，可以用于线程间的通信、数据的传递等。但是，管道流也有一些局限性，比如只能在同一个 JVM 中的线程之间使用，不能跨越不同的 JVM 进程。
4）基本数据类型 
基本数据类型输入输出流是一个字节流，该流不仅可以读写字节和字符，还可以读写基本数据类型。
DataInputStream 提供了一系列可以读基本数据类型的方法：
1234567891011121314151617181920&#x2F;&#x2F; 创建一个 DataInputStream 对象，用于从文件中读取数据DataInputStream dis &#x3D; new DataInputStream(new FileInputStream(&quot;das.txt&quot;));&#x2F;&#x2F; 读取一个字节，将其转换为 byte 类型byte b &#x3D; dis.readByte();&#x2F;&#x2F; 读取两个字节，将其转换为 short 类型short s &#x3D; dis.readShort();&#x2F;&#x2F; 读取四个字节，将其转换为 int 类型int i &#x3D; dis.readInt();&#x2F;&#x2F; 读取八个字节，将其转换为 long 类型long l &#x3D; dis.readLong();&#x2F;&#x2F; 读取四个字节，将其转换为 float 类型float f &#x3D; dis.readFloat();&#x2F;&#x2F; 读取八个字节，将其转换为 double 类型double d &#x3D; dis.readDouble();&#x2F;&#x2F; 读取一个字节，将其转换为 boolean 类型boolean bb &#x3D; dis.readBoolean();&#x2F;&#x2F; 读取两个字节，将其转换为 char 类型char ch &#x3D; dis.readChar();&#x2F;&#x2F; 关闭 DataInputStream，释放资源dis.close();
DataOutputStream 提供了一系列可以写基本数据类型的方法：
1234567891011121314151617181920&#x2F;&#x2F; 创建一个 DataOutputStream 对象，用于将数据写入到文件中DataOutputStream das &#x3D; new DataOutputStream(new FileOutputStream(&quot;das.txt&quot;));&#x2F;&#x2F; 将一个 byte 类型的数据写入到文件中das.writeByte(10);&#x2F;&#x2F; 将一个 short 类型的数据写入到文件中das.writeShort(100);&#x2F;&#x2F; 将一个 int 类型的数据写入到文件中das.writeInt(1000);&#x2F;&#x2F; 将一个 long 类型的数据写入到文件中das.writeLong(10000L);&#x2F;&#x2F; 将一个 float 类型的数据写入到文件中das.writeFloat(12.34F);&#x2F;&#x2F; 将一个 double 类型的数据写入到文件中das.writeDouble(12.56);&#x2F;&#x2F; 将一个 boolean 类型的数据写入到文件中das.writeBoolean(true);&#x2F;&#x2F; 将一个 char 类型的数据写入到文件中das.writeChar(&#39;A&#39;);&#x2F;&#x2F; 关闭 DataOutputStream，释放资源das.close();
除了 DataInputStream 和 DataOutputStream，Java IO 还提供了其他一些读写基本数据类型和字符串的流类，包括 ObjectInputStream 和 ObjectOutputStream（用于读写对象）。
示例代码：
12345678910111213141516public static void main(String[] args) {    try (ObjectOutputStream oos &#x3D; new ObjectOutputStream(new FileOutputStream(&quot;person.dat&quot;))) {        Person p &#x3D; new Person(&quot;张三&quot;, 20);        oos.writeObject(p);    } catch (IOException e) {        e.printStackTrace();    }    try (ObjectInputStream ois &#x3D; new ObjectInputStream(new FileInputStream(&quot;person.dat&quot;))) {        Person p &#x3D; (Person) ois.readObject();        System.out.println(p);    } catch (IOException | ClassNotFoundException e) {        e.printStackTrace();    }}
以上代码创建了一个 Person 对象，将其写入文件中，然后从文件中读取该对象，并打印在控制台上。
5）缓冲 
CPU 很快，它比内存快 100 倍，比磁盘快百万倍。那也就意味着，程序和内存交互会很快，和硬盘交互相对就很慢，这样就会导致性能问题。
为了减少程序和硬盘的交互，提升程序的效率，就引入了缓冲流，也就是类名前缀带有 Buffer 的那些，比如说 BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter。

缓冲流在内存中设置了一个缓冲区，只有缓冲区存储了足够多的带操作的数据后，才会和内存或者硬盘进行交互。简单来说，就是一次多读&#x2F;写点，少读&#x2F;写几次，这样程序的性能就会提高。
以下是一个使用 BufferedInputStream 读取文件的示例代码：
12345678910111213&#x2F;&#x2F; 创建一个 BufferedInputStream 对象，用于从文件中读取数据BufferedInputStream bis &#x3D; new BufferedInputStream(new FileInputStream(&quot;data.txt&quot;));&#x2F;&#x2F; 创建一个字节数组，作为缓存区byte[] buffer &#x3D; new byte[1024];&#x2F;&#x2F; 读取文件中的数据，并将其存储到缓存区中int bytesRead;while ((bytesRead &#x3D; bis.read(buffer)) !&#x3D; -1) {    &#x2F;&#x2F; 对缓存区中的数据进行处理    &#x2F;&#x2F; 这里只是简单地将读取到的字节数组转换为字符串并打印出来    System.out.println(new String(buffer, 0, bytesRead));}&#x2F;&#x2F; 关闭 BufferedInputStream，释放资源bis.close();
上述代码中，首先创建了一个 BufferedInputStream 对象，用于从文件中读取数据。然后创建了一个字节数组作为缓存区，每次读取数据时将数据存储到缓存区中。读取数据的过程是通过 while 循环实现的，每次读取数据后对缓存区中的数据进行处理。最后关闭BufferedInputStream，释放资源。
以下是一个使用 BufferedOutputStream 写入文件的示例代码：
12345678910111213&#x2F;&#x2F; 创建一个 BufferedOutputStream 对象，用于将数据写入到文件中BufferedOutputStream bos &#x3D; new BufferedOutputStream(new FileOutputStream(&quot;data.txt&quot;));&#x2F;&#x2F; 创建一个字节数组，作为缓存区byte[] buffer &#x3D; new byte[1024];&#x2F;&#x2F; 将数据写入到文件中String data &#x3D; &quot;沉默王二是个大傻子!&quot;;buffer &#x3D; data.getBytes();bos.write(buffer);&#x2F;&#x2F; 刷新缓存区，将缓存区中的数据写入到文件中bos.flush();&#x2F;&#x2F; 关闭 BufferedOutputStream，释放资源bos.close();
上述代码中，首先创建了一个 BufferedOutputStream 对象，用于将数据写入到文件中。然后创建了一个字节数组作为缓存区，将数据写入到缓存区中。写入数据的过程是通过 write() 方法实现的，将字节数组作为参数传递给 write() 方法即可。
最后，通过 flush() 方法将缓存区中的数据写入到文件中。在写入数据时，由于使用了 BufferedOutputStream，数据会先被写入到缓存区中，只有在缓存区被填满或者调用了 flush() 方法时才会将缓存区中的数据写入到文件中。
以下是一个使用 BufferedReader 读取文件的示例代码：
1234567891011&#x2F;&#x2F; 创建一个 BufferedReader 对象，用于从文件中读取数据BufferedReader br &#x3D; new BufferedReader(new FileReader(&quot;data.txt&quot;));&#x2F;&#x2F; 读取文件中的数据，并将其存储到字符串中String line;while ((line &#x3D; br.readLine()) !&#x3D; null) {    &#x2F;&#x2F; 对读取到的数据进行处理    &#x2F;&#x2F; 这里只是简单地将读取到的每一行字符串打印出来    System.out.println(line);}&#x2F;&#x2F; 关闭 BufferedReader，释放资源br.close();
上述代码中，首先创建了一个 BufferedReader 对象，用于从文件中读取数据。然后使用 readLine() 方法读取文件中的数据，每次读取一行数据并将其存储到一个字符串中。读取数据的过程是通过 while 循环实现的。
以下是一个使用 BufferedWriter 写入文件的示例代码：
123456789&#x2F;&#x2F; 创建一个 BufferedWriter 对象，用于将数据写入到文件中BufferedWriter bw &#x3D; new BufferedWriter(new FileWriter(&quot;data.txt&quot;));&#x2F;&#x2F; 将数据写入到文件中String data &#x3D; &quot;沉默王二，真帅气&quot;;bw.write(data);&#x2F;&#x2F; 刷新缓存区，将缓存区中的数据写入到文件中bw.flush();&#x2F;&#x2F; 关闭 BufferedWriter，释放资源bw.close();
上述代码中，首先创建了一个 BufferedWriter 对象，用于将数据写入到文件中。然后使用 write() 方法将数据写入到缓存区中，写入数据的过程和使用 FileWriter 类似。需要注意的是，使用 BufferedWriter 写入数据时，数据会先被写入到缓存区中，只有在缓存区被填满或者调用了 flush() 方法时才会将缓存区中的数据写入到文件中。
最后，通过 flush() 方法将缓存区中的数据写入到文件中，并通过 close() 方法关闭 BufferedWriter，释放资源。
使用缓冲流可以提高读写效率，减少了频繁的读写磁盘或网络的次数，从而提高了程序的性能。但是，在使用缓冲流时需要注意缓冲区的大小和清空缓冲区的时机，以避免数据丢失或不完整的问题。
6）打印 
Java 的打印流是一组用于打印输出数据的类，包括 PrintStream 和 PrintWriter 两个类。
恐怕 Java 程序员一生当中最常用的就是打印流了： System.out 其实返回的就是一个 PrintStream 对象，可以用来打印各式各样的对象。
1System.out.println(&quot;沉默王二是真的二！&quot;);
PrintStream 最终输出的是字节数据，而 PrintWriter 则是扩展了 Writer 接口，所以它的 print()&#x2F;println() 方法最终输出的是字符数据。使用上几乎和 PrintStream 一模一样。
12345StringWriter buffer &#x3D; new StringWriter();try (PrintWriter pw &#x3D; new PrintWriter(buffer)) {    pw.println(&quot;沉默王二&quot;);}System.out.println(buffer.toString());
7）对象序列化&#x2F;反序列化 
序列化本质上是将一个 Java 对象转成字节数组，然后可以将其保存到文件中，或者通过网络传输到远程。
1234567891011&#x2F;&#x2F; 创建一个 ByteArrayOutputStream 对象 buffer，用于存储数据ByteArrayOutputStream buffer &#x3D; new ByteArrayOutputStream();&#x2F;&#x2F; 使用 try-with-resources 语句创建一个 ObjectOutputStream 对象 output，并将其与 buffer 关联try (ObjectOutputStream output &#x3D; new ObjectOutputStream(buffer)) {        &#x2F;&#x2F; 使用 writeUTF() 方法将字符串 &quot;沉默王二&quot; 写入到缓冲区中    output.writeUTF(&quot;沉默王二&quot;);}&#x2F;&#x2F; 使用 toByteArray() 方法将缓冲区中的数据转换成字节数组，并输出到控制台System.out.println(Arrays.toString(buffer.toByteArray()));
与其对应的，有序列化，就有反序列化，也就是再将字节数组转成 Java 对象的过程。
1234try (ObjectInputStream input &#x3D; new ObjectInputStream(new FileInputStream(        new File(&quot;Person.txt&quot;)))) {    String s &#x3D; input.readUTF();}
这段代码主要使用了 Java 的 ByteArrayOutputStream 和 ObjectOutputStream 类，将字符串 “沉默王二” 写入到一个字节数组缓冲区中，并将缓冲区中的数据转换成字节数组输出到控制台。
具体的执行过程如下：

创建一个 ByteArrayOutputStream 对象 buffer，用于存储数据。
使用 try-with-resources 语句创建一个 ObjectOutputStream 对象 output，并将其与 buffer 关联。
使用 writeUTF() 方法将字符串 “沉默王二” 写入到缓冲区中。
当 try-with-resources 语句执行完毕时，会自动调用 output 的 close() 方法关闭输出流，释放资源。
使用 toByteArray() 方法将缓冲区中的数据转换成字节数组。
使用 Arrays.toString() 方法将字节数组转换成字符串，并输出到控制台。

8）转换 
InputStreamReader 是从字节流到字符流的桥连接，它使用指定的字符集读取字节并将它们解码为字符。
123456789101112&#x2F;&#x2F; 创建一个 InputStreamReader 对象 isr，使用 FileInputStream 对象读取文件 demo.txt 的内容并将其转换为字符流InputStreamReader isr &#x3D; new InputStreamReader(new FileInputStream(&quot;demo.txt&quot;));&#x2F;&#x2F; 创建一个字符数组 cha，用于存储读取的字符数据，其中 1024 表示数组的长度char[] cha &#x3D; new char[1024];&#x2F;&#x2F; 使用 read() 方法读取 isr 中的数据，并将读取的字符数据存储到 cha 数组中，返回值 len 表示读取的字符数int len &#x3D; isr.read(cha);&#x2F;&#x2F; 将 cha 数组中从下标 0 开始、长度为 len 的部分转换成字符串，并输出到控制台System.out.println(new String(cha, 0, len));&#x2F;&#x2F; 关闭 InputStreamReader 对象 isr，释放资源isr.close();
这段代码主要使用了 Java 的 InputStreamReader 和 FileInputStream 类，从文件 demo.txt 中读取数据并将其转换为字符流，然后将读取的字符数据存储到一个字符数组中，并输出转换成字符串后的结果到控制台。
OutputStreamWriter 将一个字符流的输出对象变为字节流的输出对象，是字符流通向字节流的桥梁。
123456789&#x2F;&#x2F; 创建一个 File 对象 f，表示文件 test.txtFile f &#x3D; new File(&quot;test.txt&quot;);&#x2F;&#x2F; 创建一个 OutputStreamWriter 对象 out，使用 FileOutputStream 对象将数据写入到文件 f 中，并将字节流转换成字符流Writer out &#x3D; new OutputStreamWriter(new FileOutputStream(f));&#x2F;&#x2F; 使用 write() 方法将字符串 &quot;沉默王二!!&quot; 写入到文件 f 中out.write(&quot;沉默王二!!&quot;);&#x2F;&#x2F; 关闭 Writer 对象 out，释放资源out.close();
使用转换流可以方便地在字节流和字符流之间进行转换。在进行文本文件读写时，通常使用字符流进行操作，而在进行网络传输或与设备进行通信时，通常使用字节流进行操作。
另外，在使用转换流时需要注意字符编码的问题。如果不指定字符编码，则使用默认的字符编码，可能会出现乱码问题。因此，建议在使用转换流时，始终指定正确的字符编码，以避免出现乱码问题。
“小二啊，你看，经过我的梳理，是不是感觉 IO 也没多少东西！针对不同的场景、不同的业务，选择对应的 IO 流就可以了，用法上就是读和写。”老王一口气讲完这些，长长的舒了一口气。
此时此刻的小二，还沉浸在老王的滔滔不绝中。不仅感觉老王的肺活量是真的大，还感慨老王不愧是工作了十多年的“老油条”，一下子就把自己感觉头大的 IO 给梳理得很清晰了。
5.2 文件流在 IO 操作中，文件的操作相对来说是比较复杂的，但也是使用频率最高的部分，我们几乎所有的项目中几乎都躺着一个叫做 FileUtil 或者 FileUtils 的工具类。
java.io.File 类是专门对文件进行操作的类，注意只能对文件本身进行操作，不能对文件内容进行操作，想要操作内容，必须借助输入输出流。
File 类是文件和目录的抽象表示，主要用于文件和目录的创建、查找和删除等操作。
怎么理解上面两句话？其实很简单！
第一句是说 File 跟流无关，File 类不能对文件进行读和写，也就是输入和输出！
第二句是说 File 可以表示 D:\文件目录1与 D:\文件目录1\文件.txt ，前者是文件夹（Directory，或者叫目录）后者是文件(file)，File 类就是用来操作它俩的。
File 构造方法 
在 Java 中，一切皆是对象，File 类也不例外，不论是哪个对象都应该从该对象的构造说起，所以我们来分析分析 File类的构造方法。
比较常用的构造方法有三个：
1、 File(String pathname) ：通过给定的路径来创建新的 File 实例。
2、 File(String parent, String child) ：从父路径（字符串）和子路径创建新的 File 实例。
3、 File(File parent, String child) ：从父路径（File）和子路径名字符串创建新的 File 实例。
看文字描述不够生动、不够形象、不得劲？没事，通过举例马上就生动形象了，代码如下：
1234567891011121314&#x2F;&#x2F; 文件路径名String path &#x3D; &quot;&#x2F;Users&#x2F;username&#x2F;123.txt&quot;;File file1 &#x3D; new File(path);&#x2F;&#x2F; 文件路径名String path2 &#x3D; &quot;&#x2F;Users&#x2F;username&#x2F;1&#x2F;2.txt&quot;;File file2 &#x3D; new File(path2); -------------相当于&#x2F;Users&#x2F;username&#x2F;1&#x2F;2.txt&#x2F;&#x2F; 通过父路径和子路径字符串String parent &#x3D; &quot;&#x2F;Users&#x2F;username&#x2F;aaa&quot;;String child &#x3D; &quot;bbb.txt&quot;;File file3 &#x3D; new File(parent, child); --------相当于&#x2F;Users&#x2F;username&#x2F;aaa&#x2F;bbb.txt&#x2F;&#x2F; 通过父级File对象和子路径字符串File parentDir &#x3D; new File(&quot;&#x2F;Users&#x2F;username&#x2F;aaa&quot;);String child &#x3D; &quot;bbb.txt&quot;;File file4 &#x3D; new File(parentDir, child); --------相当于&#x2F;Users&#x2F;username&#x2F;aaa&#x2F;bbb.txt
注意，macOS 路径使用正斜杠（ &#x2F; ）作为路径分隔符，而 Windows 路径使用反斜杠（ \ ）作为路径分隔符。所以在遇到路径分隔符的时候，不要直接去写 &#x2F;或者 \ 。
Java 中提供了一个跨平台的方法来获取路径分隔符，即使用 File.separator ，这个属性会根据操作系统自动返回正确的路径分隔符。
File 类的注意点：

一个 File 对象代表硬盘中实际存在的一个文件或者目录。
File 类的构造方法不会检验这个文件或目录是否真实存在，因此无论该路径下是否存在文件或者目录，都不影响 File 对象的创建。

File 常用方法 
File 的常用方法主要分为获取功能、获取绝对路径和相对路径、判断功能、创建删除功能的方法。
1）获取功能的方法 
1、 getAbsolutePath() ：返回此 File 的绝对路径。
2、 getPath() ：结果和 getAbsolutePath 一致。
3、 getName() ：返回文件名或目录名。
4、 length() ：返回文件长度，以字节为单位。
测试代码如下【注意测试以你自己的电脑文件夹为准】：
12345678910File f &#x3D; new File(&quot;&#x2F;Users&#x2F;username&#x2F;aaa&#x2F;bbb.java&quot;);System.out.println(&quot;文件绝对路径:&quot;+f.getAbsolutePath());System.out.println(&quot;文件构造路径:&quot;+f.getPath());System.out.println(&quot;文件名称:&quot;+f.getName());System.out.println(&quot;文件长度:&quot;+f.length()+&quot;字节&quot;);File f2 &#x3D; new File(&quot;&#x2F;Users&#x2F;username&#x2F;aaa&quot;);System.out.println(&quot;目录绝对路径:&quot;+f2.getAbsolutePath());System.out.println(&quot;目录构造路径:&quot;+f2.getPath());System.out.println(&quot;目录名称:&quot;+f2.getName());System.out.println(&quot;目录长度:&quot;+f2.length());
注意： length() 表示文件的长度， File 对象表示目录的时候，返回值并无意义。
2）绝对路径和相对路径 
绝对路径是从文件系统的根目录开始的完整路径，它描述了一个文件或目录在文件系统中的确切位置。在 Windows 系统中，绝对路径通常以盘符（如 C:）开始，例如 “ C:\Program Files\Java\jdk1.8.0_291\bin\java.exe “。在 macOS 和 Linux 系统中，绝对路径通常以斜杠（ &#x2F; ）开始，例如 “ &#x2F;usr&#x2F;local&#x2F;bin&#x2F;python3 “。
相对路径是相对于当前工作目录的路径，它描述了一个文件或目录与当前工作目录之间的位置关系。在 Java 中，相对路径通常是相对于当前 Java 程序所在的目录，例如 “ config&#x2F;config.properties “。如果当前工作目录是 “ &#x2F;Users&#x2F;username&#x2F;project “，那么相对路径 “ config&#x2F;config.properties “ 就表示 “ &#x2F;Users&#x2F;username&#x2F;project&#x2F;config&#x2F;config.properties “。
注意：

在 Windows 操作系统中，文件系统默认是不区分大小写的，即在文件系统中，文件名和路径的大小写可以混合使用。例如，” C:\Users\username\Documents\example.txt “ 和 “ C:\Users\Username\Documents\Example.txt “ 表示的是同一个文件。但是，Windows 操作系统提供了一个区分大小写的选项，可以在格式化磁盘时选择启用，这样文件系统就会区分大小写。
在 macOS 和 Linux 等 Unix 系统中，文件系统默认是区分大小写的。例如，在 macOS 系统中，” &#x2F;Users&#x2F;username&#x2F;Documents&#x2F;example.txt “ 和 “ &#x2F;Users&#x2F;username&#x2F;Documents&#x2F;Example.txt “ 表示的是两个不同的文件。

123456&#x2F;&#x2F; 绝对路径示例File absoluteFile &#x3D; new File(&quot;&#x2F;Users&#x2F;username&#x2F;example&#x2F;test.txt&quot;);System.out.println(&quot;绝对路径：&quot; + absoluteFile.getAbsolutePath());&#x2F;&#x2F; 相对路径示例File relativeFile &#x3D; new File(&quot;example&#x2F;test.txt&quot;);System.out.println(&quot;相对路径：&quot; + relativeFile.getPath());
3）判断功能的方法 
1、 exists() ：判断文件或目录是否存在。
2、 isDirectory() ：判断是否为目录。
3、 isFile() ：判断是否为文件。
方法演示，代码如下：
12345678910111213141516171819File file &#x3D; new File(&quot;&#x2F;Users&#x2F;username&#x2F;example&quot;);&#x2F;&#x2F; 判断文件或目录是否存在if (file.exists()) {    System.out.println(&quot;文件或目录存在&quot;);} else {    System.out.println(&quot;文件或目录不存在&quot;);}&#x2F;&#x2F; 判断是否是目录if (file.isDirectory()) {    System.out.println(&quot;是目录&quot;);} else {    System.out.println(&quot;不是目录&quot;);}&#x2F;&#x2F; 判断是否是文件if (file.isFile()) {    System.out.println(&quot;是文件&quot;);} else {    System.out.println(&quot;不是文件&quot;);}
4）创建、删除功能的方法 

createNewFile() ：文件不存在，创建一个新的空文件并返回 true ，文件存在，不创建文件并返回false 。
delete() ：删除文件或目录。如果是目录，只有目录为空才能删除。
mkdir() ：只能创建一级目录，如果父目录不存在，则创建失败。返回 true 表示创建成功，返回 false 表示创建失败。
mkdirs() ：可以创建多级目录，如果父目录不存在，则会一并创建。返回 true 表示创建成功，返回 false 表示创建失败或目录已经存在。

开发中一般用 mkdirs() ;
方法测试，代码如下：
1234567891011121314151617181920&#x2F;&#x2F; 创建文件File file &#x3D; new File(&quot;&#x2F;Users&#x2F;username&#x2F;example&#x2F;test.txt&quot;);if (file.createNewFile()) {    System.out.println(&quot;创建文件成功：&quot; + file.getAbsolutePath());} else {    System.out.println(&quot;创建文件失败：&quot; + file.getAbsolutePath());}&#x2F;&#x2F; 删除文件if (file.delete()) {    System.out.println(&quot;删除文件成功：&quot; + file.getAbsolutePath());} else {    System.out.println(&quot;删除文件失败：&quot; + file.getAbsolutePath());}&#x2F;&#x2F; 创建多级目录File directory &#x3D; new File(&quot;&#x2F;Users&#x2F;username&#x2F;example&#x2F;subdir1&#x2F;subdir2&quot;);if (directory.mkdirs()) {    System.out.println(&quot;创建目录成功：&quot; + directory.getAbsolutePath());} else {    System.out.println(&quot;创建目录失败：&quot; + directory.getAbsolutePath());}
5）目录的遍历 

String[] list() ：返回一个 String 数组，表示该 File 目录中的所有子文件或目录。
File[] listFiles() ：返回一个 File 数组，表示该 File 目录中的所有的子文件或目录。

1234567891011121314151617File directory &#x3D; new File(&quot;&#x2F;Users&#x2F;itwanger&#x2F;Documents&#x2F;Github&#x2F;paicoding&quot;);&#x2F;&#x2F; 列出目录下的文件名String[] files &#x3D; directory.list();System.out.println(&quot;目录下的文件名：&quot;);for (String file : files) {    System.out.println(file);}&#x2F;&#x2F; 列出目录下的文件和子目录File[] filesAndDirs &#x3D; directory.listFiles();System.out.println(&quot;目录下的文件和子目录：&quot;);for (File fileOrDir : filesAndDirs) {    if (fileOrDir.isFile()) {        System.out.println(&quot;文件：&quot; + fileOrDir.getName());    } else if (fileOrDir.isDirectory()) {        System.out.println(&quot;目录：&quot; + fileOrDir.getName());    }}
listFiles在获取指定目录下的文件或者子目录时必须满足下面两个条件：

指定的目录必须存在
指定的必须是目录。否则容易引发 NullPointerException 异常

6）递归遍历 
不说啥了，直接上代码：
1234567891011121314151617181920public static void main(String[] args) {    File directory &#x3D; new File(&quot;&#x2F;Users&#x2F;itwanger&#x2F;Documents&#x2F;Github&#x2F;paicoding&quot;);    &#x2F;&#x2F; 递归遍历目录下的文件和子目录    traverseDirectory(directory);}public static void traverseDirectory(File directory) {    &#x2F;&#x2F; 列出目录下的所有文件和子目录    File[] filesAndDirs &#x3D; directory.listFiles();    &#x2F;&#x2F; 遍历每个文件和子目录    for (File fileOrDir : filesAndDirs) {        if (fileOrDir.isFile()) {            &#x2F;&#x2F; 如果是文件，输出文件名            System.out.println(&quot;文件：&quot; + fileOrDir.getName());        } else if (fileOrDir.isDirectory()) {            &#x2F;&#x2F; 如果是目录，递归遍历子目录            System.out.println(&quot;目录：&quot; + fileOrDir.getName());            traverseDirectory(fileOrDir);        }    }}
RandomAccessFile 
RandomAccessFile 是 Java 中一个非常特殊的类，它既可以用来读取文件，也可以用来写入文件。与其他 IO 类（如 FileInputStream 和 FileOutputStream）不同，RandomAccessFile 允许您跳转到文件的任何位置，从那里开始读取或写入。这使得它特别适用于需要在文件中随机访问数据的场景，如数据库系统。
下面是一个使用 RandomAccessFile 的示例，包括写入和读取文件：
123456789101112131415161718192021222324252627282930313233import java.io.IOException;import java.io.RandomAccessFile;public class RandomAccessFileDemo {    public static void main(String[] args) {        String filePath &#x3D; &quot;logs&#x2F;javabetter&#x2F;itwanger.txt&quot;;        try {            &#x2F;&#x2F; 使用 RandomAccessFile 写入文件            writeToFile(filePath, &quot;Hello, 沉默王二!&quot;);            &#x2F;&#x2F; 使用 RandomAccessFile 读取文件            String content &#x3D; readFromFile(filePath);            System.out.println(&quot;文件内容: &quot; + content);        } catch (IOException e) {            e.printStackTrace();        }    }    private static void writeToFile(String filePath, String content) throws IOException {        try (RandomAccessFile randomAccessFile &#x3D; new RandomAccessFile(filePath, &quot;rw&quot;)) {            &#x2F;&#x2F; 将文件指针移动到文件末尾（在此处追加内容）            randomAccessFile.seek(randomAccessFile.length());            &#x2F;&#x2F; 写入内容            randomAccessFile.writeUTF(content);        }    }    private static String readFromFile(String filePath) throws IOException {        StringBuilder content &#x3D; new StringBuilder();        try (RandomAccessFile randomAccessFile &#x3D; new RandomAccessFile(filePath, &quot;r&quot;)) {            &#x2F;&#x2F; 将文件指针移动到文件开始处（从头开始读取）            randomAccessFile.seek(0);            content.append(randomAccessFile.readUTF());        }        return content.toString();    }}
为了避免中文乱码问题，我们使用 RandomAccessFile 的 writeUTF 和 readUTF 方法，它们将使用 UTF-8 编码处理字符串。大家可以运行一下这段代码，体验一下。

接下来，会详细介绍一下 RandomAccessFile 的构造方法和常用的方法。
构造方法 
RandomAccessFile 主要有两个构造方法：

RandomAccessFile(File file, String mode) ：使用给定的文件对象和访问模式创建一个新的 RandomAccessFile 实例。
RandomAccessFile(String name, String mode) ：使用给定的文件名和访问模式创建一个新的 RandomAccessFile 实例。

访问模式 mode 的值可以是：

“r”：以只读模式打开文件。调用结果对象的任何 write 方法都将导致 IOException。
“rw”：以读写模式打开文件。如果文件不存在，它将被创建。
“rws”：以读写模式打开文件，并要求对内容或元数据的每个更新都被立即写入到底层存储设备。这种模式是同步的，可以确保在系统崩溃时不会丢失数据。
“rwd”：与“rws”类似，以读写模式打开文件，但仅要求对文件内容的更新被立即写入。元数据可能会被延迟写入。

主要方法 

long getFilePointer() ：返回文件指针的当前位置。
long length() ：返回此文件的长度。
int read() ：从该文件中读取一个字节数据。
int read(byte[] b) ：从该文件中读取字节数据并将其存储到指定的字节数组中。
int read(byte[] b, int off, int len) ：从该文件中读取字节数据并将其存储到指定的字节数组中，从偏移量 off 开始，最多读取 len 个字节。
String readLine() ：从该文件中读取一行文本。
readUTF() ：从文件读取 UTF-8 编码的字符串。此方法首先读取两个字节的长度信息，然后根据这个长度读取字符串的 UTF-8 字节。最后，这些字节被转换为 Java 字符串。这意味着当你使用 readUTF 方法读取字符串时，需要确保文件中的字符串是使用 writeUTF 方法写入的，这样它们之间的长度信息和编码方式才能保持一致。
void seek(long pos) ：将文件指针设置到文件中的 pos 位置。
void write(byte[] b) ：将指定的字节数组的所有字节写入该文件。
void write(byte[] b, int off, int len) ：将指定字节数组的部分字节写入该文件，从偏移量 off 开始，写入 len 个字节。
void write(int b) ：将指定的字节写入该文件。
writeUTF(String str) ：将一个字符串以 UTF-8 编码写入文件。此方法首先写入两个字节的长度信息，表示字符串的 UTF-8 字节长度，然后写入 UTF-8 字节本身。因此，当你使用 writeUTF 写入字符串时，实际写入的字节数会比字符串的 UTF-8 字节长度多两个字节。这两个字节用于在读取字符串时确定正确的字符串长度。

再来看一个示例，结合前面的讲解，就会彻底掌握 RandomAccessFile。
123456789101112File file &#x3D; new File(&quot;logs&#x2F;javabetter&#x2F;itwanger.txt&quot;);try (RandomAccessFile raf &#x3D; new RandomAccessFile(file, &quot;rw&quot;)) {    &#x2F;&#x2F; 写入文件    raf.writeUTF(&quot;Hello, 沉默王二!&quot;);    &#x2F;&#x2F; 将文件指针移动到文件开头    raf.seek(0);    &#x2F;&#x2F; 读取文件内容    String content &#x3D; raf.readUTF();    System.out.println(&quot;内容: &quot; + content);} catch (IOException e) {    e.printStackTrace();}
在这个示例中，我们首先创建了一个名为 itwanger.txt 的文件对象。然后我们使用 RandomAccessFile 以读写模式打开这个文件。
接下来，我们使用 writeUTF 方法将字符串”Hello, 沉默王二!”写入文件。然后，我们使用 seek 方法将文件指针移动到文件开头，并使用 readUTF 方法读取文件内容。输出应该是”Hello, 沉默王二!”。
最后，我们使用try-with-resources语句确保 RandomAccessFile 在操作完成后被正确关闭。
Apache FileUtils 类 
FileUtils 类是 Apache Commons IO 库中的一个类，提供了一些更为方便的方法来操作文件或目录。
1）复制文件或目录： 
123456File srcFile &#x3D; new File(&quot;path&#x2F;to&#x2F;src&#x2F;file&quot;);File destFile &#x3D; new File(&quot;path&#x2F;to&#x2F;dest&#x2F;file&quot;);&#x2F;&#x2F; 复制文件FileUtils.copyFile(srcFile, destFile);&#x2F;&#x2F; 复制目录FileUtils.copyDirectory(srcFile, destFile);
2）删除文件或目录： 
123File file &#x3D; new File(&quot;path&#x2F;to&#x2F;file&quot;);&#x2F;&#x2F; 删除文件或目录FileUtils.delete(file);
需要注意的是，如果要删除一个非空目录，需要先删除目录中的所有文件和子目录。
3）移动文件或目录： 
1234File srcFile &#x3D; new File(&quot;path&#x2F;to&#x2F;src&#x2F;file&quot;);File destFile &#x3D; new File(&quot;path&#x2F;to&#x2F;dest&#x2F;file&quot;);&#x2F;&#x2F; 移动文件或目录FileUtils.moveFile(srcFile, destFile);
4）查询文件或目录的信息： 
1234567File file &#x3D; new File(&quot;path&#x2F;to&#x2F;file&quot;);&#x2F;&#x2F; 获取文件或目录的修改时间Date modifyTime &#x3D; FileUtils.lastModified(file);&#x2F;&#x2F; 获取文件或目录的大小long size &#x3D; FileUtils.sizeOf(file);&#x2F;&#x2F; 获取文件或目录的扩展名String extension &#x3D; FileUtils.getExtension(file.getName());
Hutool FileUtil 类 
FileUtil 类是 Hutool 工具包中的文件操作工具类，提供了一系列简单易用的文件操作方法，可以帮助 Java 开发者快速完成文件相关的操作任务。
FileUtil 类包含以下几类操作工具：

文件操作：包括文件目录的新建、删除、复制、移动、改名等
文件判断：判断文件或目录是否非空，是否为目录，是否为文件等等。
绝对路径：针对 ClassPath 中的文件转换为绝对路径文件。
文件名：主文件名，扩展名的获取
读操作：包括 getReader、readXXX 操作
写操作：包括 getWriter、writeXXX 操作

下面是 FileUtil 类中一些常用的方法：
1、copyFile：复制文件。该方法可以将指定的源文件复制到指定的目标文件中。
1File dest &#x3D; FileUtil.file(&quot;FileUtilDemo2.java&quot;);
2、move：移动文件或目录。该方法可以将指定的源文件或目录移动到指定的目标文件或目录中。
1FileUtil.move(file, dest, true);
3、del：删除文件或目录。该方法可以删除指定的文件或目录，如果指定的文件或目录不存在，则会抛出异常。
1FileUtil.del(file);
4、rename：重命名文件或目录。该方法可以将指定的文件或目录重命名为指定的新名称。
1FileUtil.rename(file, &quot;FileUtilDemo3.java&quot;, true);
5、readLines：从文件中读取每一行数据。
1FileUtil.readLines(file, &quot;UTF-8&quot;).forEach(System.out::println);
更多方法，可以去看一下 hutool 的源码，里面有非常多实用的方法，多看看，绝对能提升不少编程水平。
5.3 字节流我们必须得明确一点，一切文件（文本、视频、图片）的数据都是以二进制的形式存储的，传输时也是。所以，字节流可以传输任意类型的文件数据。
字节输出流（OutputStream） 
java.io.OutputStream 是字节输出流的超类（父类），我们来看一下它定义的一些共性方法：
1、 close() ：关闭此输出流并释放与此流相关联的系统资源。
2、 flush() ：刷新此输出流并强制缓冲区的字节被写入到目的地。
3、 write(byte[] b) ：将 b.length 个字节从指定的字节数组写入此输出流。
4、 write(byte[] b, int off, int len) ：从指定的字节数组写入 len 字节到此输出流，从偏移量 off开始。 也就是说从off个字节数开始一直到len个字节结束
FileOutputStream类 
OutputStream 有很多子类，我们从最简单的一个子类 FileOutputStream 开始。看名字就知道是文件输出流，用于将数据写入到文件。
1）FileOutputStrea 的构造方法 
1、使用文件名创建 FileOutputStream 对象。
12String fileName &#x3D; &quot;example.txt&quot;;FileOutputStream fos &#x3D; new FileOutputStream(fileName);
以上代码使用文件名 “example.txt” 创建一个 FileOutputStream 对象，将数据写入到该文件中。如果文件不存在，则创建一个新文件；如果文件已经存在，则覆盖原有文件。
2、使用文件对象创建 FileOutputStream 对象。
12File file &#x3D; new File(&quot;example.txt&quot;);FileOutputStream fos &#x3D; new FileOutputStream(file);
FileOutputStream 的使用示例：
123456789101112131415FileOutputStream fos &#x3D; null;try {  fos &#x3D; new FileOutputStream(&quot;example.txt&quot;);  fos.write(&quot;沉默王二&quot;.getBytes());} catch (IOException e) {  e.printStackTrace();} finally {  if (fos !&#x3D; null) {    try {      fos.close();    } catch (IOException e) {      e.printStackTrace();    }  }}
以上代码创建了一个 FileOutputStream 对象，将字符串 “沉默王二” 写入到 example.txt 文件中，并在最后关闭了输出流。
2）FileOutputStream 写入字节数据 
使用 FileOutputStream 写入字节数据主要通过 write 方法：
123write(int b)write(byte[] b)write(byte[] b,int off,int len)  &#x2F;&#x2F;从òff&#96;索引开始，&#96;len&#96;个字节
①、写入字节： write(int b) 方法，每次可以写入一个字节，代码如下：
12345678&#x2F;&#x2F; 使用文件名称创建流对象FileOutputStream fos &#x3D; new FileOutputStream(&quot;fos.txt&quot;);     &#x2F;&#x2F; 写出数据fos.write(97); &#x2F;&#x2F; 第1个字节fos.write(98); &#x2F;&#x2F; 第2个字节fos.write(99); &#x2F;&#x2F; 第3个字节&#x2F;&#x2F; 关闭资源fos.close();
字符 a 的 ASCII 值为 97，字符 b 的ASCII 值为 98，字符 b 的ASCII 值为 99。也就是说，以上代码可以写成：
12345678&#x2F;&#x2F; 使用文件名称创建流对象FileOutputStream fos &#x3D; new FileOutputStream(&quot;fos.txt&quot;);     &#x2F;&#x2F; 写出数据fos.write(&#39;a&#39;); &#x2F;&#x2F; 第1个字节fos.write(&#39;b&#39;); &#x2F;&#x2F; 第2个字节fos.write(&#39;c&#39;); &#x2F;&#x2F; 第3个字节&#x2F;&#x2F; 关闭资源fos.close();
当使用 write(int b) 方法写出一个字节时，参数 b 表示要写出的字节的整数值。由于一个字节只有8位，因此参数 b 的取值范围应该在 0 到 255 之间，超出这个范围的值将会被截断。例如，如果参数 b 的值为 -1，那么它会被截断为 255，如果参数 b 的值为 256，那么它会被截断为 0。
在将参数 b 写入输出流中时，write(int b) 方法只会将参数 b 的低8位写入，而忽略高24位。这是因为在 Java 中，整型类型（包括 byte、short、int、long）在内存中以二进制补码形式表示。当将一个整型值传递给 write(int b) 方法时，方法会将该值转换为 byte 类型，只保留二进制补码的低8位，而忽略高24位。
例如，如果要写出的整数为 0x12345678，它的二进制补码表示为 0001 0010 0011 0100 0101 0110 0111 1000。当使用 write(int b) 方法写出该整数时，只会将二进制补码的低8位 0111 1000 写出，而忽略高24位 0001 0010 0011 0100 0101 0110。这就是参数 b 的高24位被忽略的原因。
0111 1000 是一个8位的二进制数，它对应的十进制数是 120，对应的 ASCII 码字符是小写字母 “x”。在 ASCII 码表中，小写字母 “x” 的十进制 ASCII 码值为 120。因此，如果使用 write(int b) 方法写出一个字节值为 0x78（十进制为 120），那么写出的结果就是小写字母 “x”。
我们来验证一下：
1234567891011121314151617FileOutputStream fos &#x3D; null;try {    fos &#x3D; new FileOutputStream(&quot;example.txt&quot;);    fos.write(120);    fos.write(&#39;x&#39;);    fos.write(0x12345678);} catch (IOException e) {    e.printStackTrace();} finally {    if (fos !&#x3D; null) {        try {            fos.close();        } catch (IOException e) {            e.printStackTrace();        }    }}
来看一下结果：

果然是 3 个 x。
②、写入字节数组： write(byte[] b) ，代码示例：
12345678&#x2F;&#x2F; 使用文件名称创建流对象FileOutputStream fos &#x3D; new FileOutputStream(&quot;fos.txt&quot;);     &#x2F;&#x2F; 字符串转换为字节数组byte[] b &#x3D; &quot;沉默王二有点帅&quot;.getBytes();&#x2F;&#x2F; 写入字节数组数据fos.write(b);&#x2F;&#x2F; 关闭资源fos.close();
③、写入指定长度字节数组： write(byte[] b, int off, int len) ，代码示例：
12345678&#x2F;&#x2F; 使用文件名称创建流对象FileOutputStream fos &#x3D; new FileOutputStream(&quot;fos.txt&quot;);     &#x2F;&#x2F; 字符串转换为字节数组byte[] b &#x3D; &quot;abcde&quot;.getBytes();&#x2F;&#x2F; 从索引2开始，2个字节。索引2是c，两个字节，也就是cd。fos.write(b,2,2);&#x2F;&#x2F; 关闭资源fos.close();
3）FileOutputStream实现数据追加、换行 
在上面的代码示例中，每次运行程序都会创建新的输出流对象，于是文件中的数据也会被清空。如果想保留目标文件中的数据，还能继续追加新数据，该怎么办呢？以及如何实现换行呢？
其实很简单。
我们来学习 FileOutputStream的另外两个构造方法，如下：
1、使用文件名和追加标志创建 FileOutputStream 对象
123String fileName &#x3D; &quot;example.txt&quot;;boolean append &#x3D; true;FileOutputStream fos &#x3D; new FileOutputStream(fileName, append);
以上代码使用文件名 “example.txt” 和追加标志创建一个 FileOutputStream 对象，将数据追加到该文件的末尾。如果文件不存在，则创建一个新文件；如果文件已经存在，则在文件末尾追加数据。
2、使用文件对象和追加标志创建 FileOutputStream 对象
123File file &#x3D; new File(&quot;example.txt&quot;);boolean append &#x3D; true;FileOutputStream fos &#x3D; new FileOutputStream(file, append);
以上代码使用文件对象和追加标志创建一个 FileOutputStream 对象，将数据追加到该文件的末尾。
这两个构造方法，第二个参数中都需要传入一个boolean类型的值， true 表示追加数据， false 表示不追加也就是清空原有数据。
实现数据追加代码如下：
12345678&#x2F;&#x2F; 使用文件名称创建流对象FileOutputStream fos &#x3D; new FileOutputStream(&quot;fos.txt&quot;,true);     &#x2F;&#x2F; 字符串转换为字节数组byte[] b &#x3D; &quot;abcde&quot;.getBytes();&#x2F;&#x2F; 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。fos.write(b);&#x2F;&#x2F; 关闭资源fos.close();
多次运行代码，你会发现数据在不断地追加。
在 Windows 系统中，换行符号是 \r\n ，具体代码如下：
12345String filename &#x3D; &quot;example.txt&quot;;FileOutputStream fos &#x3D; new FileOutputStream(filename, true);  &#x2F;&#x2F; 追加模式String content &#x3D; &quot;沉默王二\r\n&quot;;  &#x2F;&#x2F; 使用回车符和换行符的组合fos.write(content.getBytes());fos.close();
在 macOS 系统中，换行符是 \n ，具体代码如下：
12345String filename &#x3D; &quot;example.txt&quot;;FileOutputStream fos &#x3D; new FileOutputStream(filename, true);  &#x2F;&#x2F; 追加模式String content &#x3D; &quot;沉默王二\n&quot;;  &#x2F;&#x2F; 只使用换行符fos.write(content.getBytes());fos.close();
这里再唠一唠回车符和换行符。
回车符（ \r ）和换行符（ \n ）是计算机中常见的控制字符，用于表示一行的结束或者换行的操作。它们在不同的操作系统和编程语言中的使用方式可能有所不同。
在 Windows 系统中，通常使用回车符和换行符的组合（ \r\n ）来表示一行的结束。在文本文件中，每行的末尾都会以一个回车符和一个换行符的组合结束。这是由于早期的打印机和终端设备需要回车符和换行符的组合来完成一行的结束和换行操作。在 Windows 中，文本编辑器和命令行终端等工具都支持使用回车符和换行符的组合来表示一行的结束。
而在 macOS 和 Linux 系统中，通常只使用换行符（ \n ）来表示一行的结束。在文本文件中，每行的末尾只有一个换行符。这是由于早期 Unix 系统中的终端设备只需要换行符来完成一行的结束和跨行操作。在 macOS 和 Linux 中，文本编辑器和终端等工具都支持使用换行符来表示一行的结束。
在编程语言中，通常也会使用回车符和换行符来进行字符串的操作。例如，在 Java 中，字符串中的回车符可以用 “ \r “ 来表示，换行符可以用 “ \n “ 来表示。在通过输入输出流进行文件读写时，也需要注意回车符和换行符的使用方式和操作系统的差异。
字节输入流（InputStream） 
java.io.InputStream 是字节输入流的超类（父类），我们来看一下它的一些共性方法：
1、 close() ：关闭此输入流并释放与此流相关的系统资源。
2、 int read() ： 从输入流读取数据的下一个字节。
3、 read(byte[] b) ： 该方法返回的 int 值代表的是读取了多少个字节，读到几个返回几个，读取不到返回-1
FileInputStream类 
InputStream 有很多子类，我们从最简单的一个子类 FileInputStream 开始。看名字就知道是文件输入流，用于将数据从文件中读取数据。
1）FileInputStream的构造方法 
1、 FileInputStream(String name) ：创建一个 FileInputStream 对象，并打开指定名称的文件进行读取。文件名由 name 参数指定。如果文件不存在，将会抛出 FileNotFoundException 异常。
2、 FileInputStream(File file) ：创建一个 FileInputStream 对象，并打开指定的 File 对象表示的文件进行读取。
代码示例如下：
123456789&#x2F;&#x2F; 创建一个 FileInputStream 对象FileInputStream fis &#x3D; new FileInputStream(&quot;test.txt&quot;);&#x2F;&#x2F; 读取文件内容int data;while ((data &#x3D; fis.read()) !&#x3D; -1) {    System.out.print((char) data);}&#x2F;&#x2F; 关闭输入流fis.close();
2）FileInputStream读取字节数据 
①、读取字节： read()方法会读取一个字节并返回其整数表示。如果已经到达文件的末尾，则返回 -1。如果在读取时发生错误，则会抛出 IOException 异常。
代码示例如下：
123456789&#x2F;&#x2F; 创建一个 FileInputStream 对象FileInputStream fis &#x3D; new FileInputStream(&quot;test.txt&quot;);&#x2F;&#x2F; 读取文件内容int data;while ((data &#x3D; fis.read()) !&#x3D; -1) {    System.out.print((char) data);}&#x2F;&#x2F; 关闭输入流fis.close();
②、使用字节数组读取： read(byte[] b) 方法会从输入流中最多读取 b.length 个字节，并将它们存储到缓冲区数组 b 中。
代码示例如下：
12345678910&#x2F;&#x2F; 创建一个 FileInputStream 对象FileInputStream fis &#x3D; new FileInputStream(&quot;test.txt&quot;);&#x2F;&#x2F; 读取文件内容到缓冲区byte[] buffer &#x3D; new byte[1024];int count;while ((count &#x3D; fis.read(buffer)) !&#x3D; -1) {    System.out.println(new String(buffer, 0, count));}&#x2F;&#x2F; 关闭输入流fis.close();
3）字节流FileInputstream复制图片 
原理很简单，就是把图片信息读入到字节输入流中，再通过字节输出流写入到文件中。
代码示例如下所示：
1234567891011121314&#x2F;&#x2F; 创建一个 FileInputStream 对象以读取原始图片文件FileInputStream fis &#x3D; new FileInputStream(&quot;original.jpg&quot;);&#x2F;&#x2F; 创建一个 FileOutputStream 对象以写入复制后的图片文件FileOutputStream fos &#x3D; new FileOutputStream(&quot;copy.jpg&quot;);&#x2F;&#x2F; 创建一个缓冲区数组以存储读取的数据byte[] buffer &#x3D; new byte[1024];int count;&#x2F;&#x2F; 读取原始图片文件并将数据写入复制后的图片文件while ((count &#x3D; fis.read(buffer)) !&#x3D; -1) {    fos.write(buffer, 0, count);}&#x2F;&#x2F; 关闭输入流和输出流fis.close();fos.close();
上面的代码创建了一个 FileInputStream 对象以读取原始图片文件，并创建了一个 FileOutputStream 对象以写入复制后的图片文件。然后，使用 while 循环逐个读取原始图片文件中的字节，并将其写入复制后的图片文件中。最后，关闭输入流和输出流释放资源。
小结 
InputStream 是字节输入流的抽象类，它定义了读取字节数据的方法，如 read() 、 read(byte[] b) 、read(byte[] b, int off, int len) 等。OutputStream 是字节输出流的抽象类，它定义了写入字节数据的方法，如 write(int b) 、 write(byte[] b) 、 write(byte[] b, int off, int len) 等。这两个抽象类是字节流的基础。
FileInputStream 是从文件中读取字节数据的流，它继承自 InputStream。FileOutputStream 是将字节数据写入文件的流，它继承自 OutputStream。这两个类是字节流最常用的实现类之一。
5.4 字符流字符流 Reader 和 Writer 的故事要从它们的类关系图开始，来看图。

字符流是一种用于读取和写入字符数据的输入输出流。与字节流不同，字符流以字符为单位读取和写入数据，而不是以字节为单位。常用来处理文本信息。
如果用字节流直接读取中文，可能会遇到乱码问题，见下例：
123456&#x2F;&#x2F;FileInputStream为操作文件的字符输入流FileInputStream inputStream &#x3D; new FileInputStream(&quot;a.txt&quot;);&#x2F;&#x2F;内容为“沉默王二是傻 X”int len;while ((len&#x3D;inputStream.read())!&#x3D;-1){    System.out.print((char)len);}
来看运行结果：
1运行结果：   æ²•é»•ç••äº•æ•¯å•» X
看一下截图：

之所以出现乱码是因为在字节流中，一个字符通常由多个字节组成，而不同的字符编码使用的字节数不同。如果我们使用了错误的字符编码，或者在读取和写入数据时没有正确处理字符编码的转换，就会导致读取出来的中文字符出现乱码。
例如，当我们使用默认的字符编码（见上例）读取一个包含中文字符的文本文件时，就会出现乱码。因为默认的字符编码通常是 ASCII 编码，它只能表示英文字符，而不能正确地解析中文字符。
那使用字节流该如何正确地读出中文呢？见下例。
1234567try (FileInputStream inputStream &#x3D; new FileInputStream(&quot;a.txt&quot;)) {    byte[] bytes &#x3D; new byte[1024];    int len;    while ((len &#x3D; inputStream.read(bytes)) !&#x3D; -1) {        System.out.print(new String(bytes, 0, len));    }}
为什么这种方式就可以呢？
因为我们拿 String 类进行了解码，查看 new String(byte bytes[], int offset, int length)的源码就可以发现，该构造方法有解码功能：
1234public String(byte bytes[], int offset, int length) {    checkBounds(bytes, offset, length);    this.value &#x3D; StringCoding.decode(bytes, offset, length);}
继续追看 StringCoding.decode() 方法调用的 defaultCharset() 方法，会发现默认编码是 UTF-8 ，代码如下
1234567891011121314151617181920public static Charset defaultCharset() {    if (defaultCharset &#x3D;&#x3D; null) {        synchronized (Charset.class) {            if (cs !&#x3D; null)                defaultCharset &#x3D; cs;            else                defaultCharset &#x3D; forName(&quot;UTF-8&quot;);        }    }    return defaultCharset;}static char[] decode(byte[] ba, int off, int len) {    String csn &#x3D; Charset.defaultCharset().name();    try {        &#x2F;&#x2F; use charset name decode() variant which provides caching.        return decode(csn, ba, off, len);    } catch (UnsupportedEncodingException x) {        warnUnsupportedCharset(csn);    }}
在 Java 中，常用的字符编码有 ASCII、ISO-8859-1、UTF-8、UTF-16 等。其中，ASCII 和 ISO-8859-1 只能表示部分字符，而 UTF-8 和 UTF-16 可以表示所有的 Unicode 字符，包括中文字符。
当我们使用 new String(byte bytes[], int offset, int length) 将字节流转换为字符串时，Java 会根据 UTF-8 的规则将每 3 个字节解码为一个中文字符，从而正确地解码出中文。
尽管字节流也有办法解决乱码问题，但不够直接，于是就有了字符流，专门用于处理文本文件（音频、图片、视频等为非文本文件）。
从另一角度来说：字符流 &#x3D; 字节流 + 编码表
01、字符输入流（Reader） 
java.io.Reader是字符输入流的超类（父类），它定义了字符输入流的一些共性方法：
1、 close() ：关闭此流并释放与此流相关的系统资源。
2、 read() ：从输入流读取一个字符。
3、 read(char[] cbuf) ：从输入流中读取一些字符，并将它们存储到字符数组 cbuf中
FileReader 是 Reader 的子类，用于从文件中读取字符数据。它的主要特点如下：

可以通过构造方法指定要读取的文件路径。
每次可以读取一个或多个字符。
可以读取 Unicode 字符集中的字符，通过指定字符编码来实现字符集的转换。

1）FileReader构造方法 
1、 FileReader(File file) ：创建一个新的 FileReader，参数为File对象。
2、 FileReader(String fileName) ：创建一个新的 FileReader，参数为文件名。
代码示例如下：
12345&#x2F;&#x2F; 使用File对象创建流对象File file &#x3D; new File(&quot;a.txt&quot;);FileReader fr &#x3D; new FileReader(file);&#x2F;&#x2F; 使用文件名称创建流对象FileReader fr &#x3D; new FileReader(&quot;b.txt&quot;);
2）FileReader读取字符数据 
①、读取字符： read方法，每次可以读取一个字符，返回读取的字符（转为 int 类型），当读取到文件末尾时，返回 -1 。代码示例如下：
12345678910&#x2F;&#x2F; 使用文件名称创建流对象FileReader fr &#x3D; new FileReader(&quot;abc.txt&quot;);&#x2F;&#x2F; 定义变量，保存数据int b;&#x2F;&#x2F; 循环读取while ((b &#x3D; fr.read())!&#x3D;-1) {    System.out.println((char)b);}&#x2F;&#x2F; 关闭资源fr.close();
②、读取指定长度的字符： read(char[] cbuf, int off, int len) ，并将其存储到字符数组中。其中，cbuf 表示存储读取结果的字符数组，off 表示存储结果的起始位置，len 表示要读取的字符数。代码示例如下：
1234567891011File textFile &#x3D; new File(&quot;docs&#x2F;约定.md&quot;);&#x2F;&#x2F; 给一个 FileReader 的示例&#x2F;&#x2F; try-with-resources FileReadertry(FileReader reader &#x3D; new FileReader(textFile);) {    &#x2F;&#x2F; read(char[] cbuf)    char[] buffer &#x3D; new char[1024];    int len;    while ((len &#x3D; reader.read(buffer, 0, buffer.length)) !&#x3D; -1) {        System.out.print(new String(buffer, 0, len));    }}
在这个例子中，使用 FileReader 从文件中读取字符数据，并将其存储到一个大小为 1024 的字符数组中。每次读取 len 个字符，然后使用 String 构造方法将其转换为字符串并输出。
FileReader 实现了 AutoCloseable 接口，因此可以使用 try-with-resources 语句自动关闭资源，避免了手动关闭资源的繁琐操作。
02、字符输出流（Writer） 
java.io.Writer 是字符输出流类的超类（父类），可以将指定的字符信息写入到目的地，来看它定义的一些共性方法：
1、 write(int c) 写入单个字符。
2、 write(char[] cbuf) 写入字符数组。
3、 write(char[] cbuf, int off, int len) 写入字符数组的一部分，off为开始索引，len为字符个数。
4、 write(String str) 写入字符串。
5、 write(String str, int off, int len) 写入字符串的某一部分，off 指定要写入的子串在 str 中的起始位置，len 指定要写入的子串的长度。
6、 flush() 刷新该流的缓冲。
7、 close() 关闭此流，但要先刷新它。
java.io.FileWriter 类是 Writer 的子类，用来将字符写入到文件。
1）FileWriter 构造方法 

FileWriter(File file) ： 创建一个新的 FileWriter，参数为要读取的File对象。
FileWriter(String fileName) ： 创建一个新的 FileWriter，参数为要读取的文件的名称。

代码示例如下：
12345&#x2F;&#x2F; 第一种：使用File对象创建流对象File file &#x3D; new File(&quot;a.txt&quot;);FileWriter fw &#x3D; new FileWriter(file);&#x2F;&#x2F; 第二种：使用文件名称创建流对象FileWriter fw &#x3D; new FileWriter(&quot;b.txt&quot;);
2）FileWriter写入数据 
①、写入字符： write(int b) 方法，每次可以写出一个字符，代码示例如下：
12345678910111213141516171819FileWriter fw &#x3D; null;try {    fw &#x3D; new FileWriter(&quot;output.txt&quot;);    fw.write(72); &#x2F;&#x2F; 写入字符&#39;H&#39;的ASCII码    fw.write(101); &#x2F;&#x2F; 写入字符&#39;e&#39;的ASCII码    fw.write(108); &#x2F;&#x2F; 写入字符&#39;l&#39;的ASCII码    fw.write(108); &#x2F;&#x2F; 写入字符&#39;l&#39;的ASCII码    fw.write(111); &#x2F;&#x2F; 写入字符&#39;o&#39;的ASCII码} catch (IOException e) {    e.printStackTrace();} finally {    try {        if (fw !&#x3D; null) {            fw.close();        }    } catch (IOException e) {        e.printStackTrace();    }}
在这个示例代码中，首先创建一个 FileWriter 对象 fw，并指定要写入的文件路径 “output.txt”。然后使用 fw.write() 方法将字节写入文件中，这里分别写入字符’H’、’e’、’l’、’l’、’o’的 ASCII 码。最后在 finally 块中关闭 FileWriter 对象，释放资源。
需要注意的是，使用 write(int b) 方法写入的是一个字节，而不是一个字符。如果需要写入字符，可以使用 write(char cbuf[]) 或 write(String str) 方法。
②、写入字符数组： write(char[] cbuf) 方法，将指定字符数组写入输出流。代码示例如下：
12345678910111213141516FileWriter fw &#x3D; null;try {    fw &#x3D; new FileWriter(&quot;output.txt&quot;);    char[] chars &#x3D; {&#39;H&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;};    fw.write(chars); &#x2F;&#x2F; 将字符数组写入文件} catch (IOException e) {    e.printStackTrace();} finally {    try {        if (fw !&#x3D; null) {            fw.close();        }    } catch (IOException e) {        e.printStackTrace();    }}
③、写入指定字符数组： write(char[] cbuf, int off, int len) 方法，将指定字符数组的一部分写入输出流。代码示例如下（重复的部分就不写了哈，参照上面的部分）：
1234fw &#x3D; new FileWriter(&quot;output.txt&quot;);    char[] chars &#x3D; {&#39;H&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, &#39;,&#39;, &#39; &#39;, &#39;W&#39;, &#39;o&#39;, &#39;r&#39;, &#39;l&#39;, &#39;d&#39;, &#39;!&#39;};fw.write(chars, 0, 5); &#x2F;&#x2F; 将字符数组的前 5 个字符写入文件
使用 fw.write() 方法将字符数组的前 5 个字符写入文件中。
④、写入字符串： write(String str) 方法，将指定字符串写入输出流。代码示例如下：
123fw &#x3D; new FileWriter(&quot;output.txt&quot;);String str &#x3D; &quot;沉默王二&quot;;fw.write(str); &#x2F;&#x2F; 将字符串写入文件
⑤、写入指定字符串： write(String str, int off, int len) 方法，将指定字符串的一部分写入输出流。代码示例如下（try-with-resources形式）：
123456String str &#x3D; &quot;沉默王二真的帅啊！&quot;;try (FileWriter fw &#x3D; new FileWriter(&quot;output.txt&quot;)) {    fw.write(str, 0, 5); &#x2F;&#x2F; 将字符串的前 5 个字符写入文件} catch (IOException e) {    e.printStackTrace();}

【注意】如果不关闭资源，数据只是保存到缓冲区，并未保存到文件中。

3）关闭close和刷新flush 
因为 FileWriter 内置了缓冲区 ByteBuffer，所以如果不关闭输出流，就无法把字符写入到文件中。

但是关闭了流对象，就无法继续写数据了。如果我们既想写入数据，又想继续使用流，就需要 flush 方法了。
flush ：刷新缓冲区，流对象可以继续使用。
close ：先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。
flush还是比较有趣的，来段代码体会体会：
12345678910&#x2F;&#x2F;源   也就是输入流【读取流】 读取a.txt文件FileReader fr&#x3D;new FileReader(&quot;abc.txt&quot;);  &#x2F;&#x2F;必须要存在a.txt文件，否则报FileNotFoundException异常&#x2F;&#x2F;目的地  也就是输出流FileWriter fw&#x3D;new FileWriter(&quot;b.txt&quot;);  &#x2F;&#x2F;系统会自动创建b.txt，因为它是输出流！int len;while((len&#x3D;fr.read())!&#x3D;-1){    fw.write(len);}&#x2F;&#x2F;注意这里是没有使用close关闭流，开发中不能这样做，但是为了更好的体会flush的作用
运行效果是怎么样的呢？答案是b.txt文件中依旧是空的，并没有任何东西。

原因我们前面已经说过了。编程就是这样，不去敲，永远学不会！！！所以一定要去敲，多敲啊！！！
在以上的代码中再添加下面三句代码，b.txt文件就能复制到源文件的数据了！
123fr.close();fw.flush();fw.close();
flush()这个方法是清空缓存的意思，用于清空缓冲区的数据流，进行流的操作时，数据先被读到内存中，然后再把数据写到文件中。
你可以使用下面的代码示例再体验一下：
123456789101112&#x2F;&#x2F; 使用文件名称创建流对象FileWriter fw &#x3D; new FileWriter(&quot;fw.txt&quot;);&#x2F;&#x2F; 写出数据，通过flushfw.write(&#39;刷&#39;); &#x2F;&#x2F; 写出第1个字符fw.flush();fw.write(&#39;新&#39;); &#x2F;&#x2F; 继续写出第2个字符，写出成功fw.flush();&#x2F;&#x2F; 写出数据，然后closefw.write(&#39;关&#39;); &#x2F;&#x2F; 写出第1个字符fw.close();fw.write(&#39;闭&#39;); &#x2F;&#x2F; 继续写出第2个字符,【报错】java.io.IOException: Stream closedfw.close();
注意，即便是flush方法写出了数据，操作的最后还是要调用close方法，释放系统资源。当然你也可以用 try-with-resources 的方式。
4）FileWriter的续写和换行 
续写和换行：操作类似于FileOutputStream操作，直接上代码：
12345678910&#x2F;&#x2F; 使用文件名称创建流对象，可以续写数据FileWriter fw &#x3D; new FileWriter(&quot;fw.txt&quot;,true);     &#x2F;&#x2F; 写出字符串fw.write(&quot;沉默王二&quot;);&#x2F;&#x2F; 写出换行fw.write(&quot;\r\n&quot;);&#x2F;&#x2F; 写出字符串fw.write(&quot;是傻 X&quot;);&#x2F;&#x2F; 关闭资源fw.close();
输出结果如下所示：
123输出结果:沉默王二是傻 X
5）文本文件复制 
直接上代码：
123456789101112131415161718192021222324252627282930313233343536373839404142import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;public class CopyFile {    public static void main(String[] args) throws IOException {        &#x2F;&#x2F;创建输入流对象        FileReader fr&#x3D;new FileReader(&quot;aa.txt&quot;);&#x2F;&#x2F;文件不存在会抛出java.io.FileNotFoundException        &#x2F;&#x2F;创建输出流对象        FileWriter fw&#x3D;new FileWriter(&quot;copyaa.txt&quot;);        &#x2F;*创建输出流做的工作：         *      1、调用系统资源创建了一个文件         *      2、创建输出流对象         *      3、把输出流对象指向文件                 * *&#x2F;        &#x2F;&#x2F;文本文件复制，一次读一个字符        copyMethod1(fr, fw);        &#x2F;&#x2F;文本文件复制，一次读一个字符数组        copyMethod2(fr, fw);                fr.close();        fw.close();    }    public static void copyMethod1(FileReader fr, FileWriter fw) throws IOException {        int ch;        while((ch&#x3D;fr.read())!&#x3D;-1) {&#x2F;&#x2F;读数据            fw.write(ch);&#x2F;&#x2F;写数据        }        fw.flush();    }    public static void copyMethod2(FileReader fr, FileWriter fw) throws IOException {        char chs[]&#x3D;new char[1024];        int len&#x3D;0;        while((len&#x3D;fr.read(chs))!&#x3D;-1) {&#x2F;&#x2F;读数据            fw.write(chs,0,len);&#x2F;&#x2F;写数据        }        fw.flush();    }}
03、IO异常的处理 
我们在学习的过程中可能习惯把异常抛出，而实际开发中建议使用 try…catch…finally 代码块，处理异常部分，格式代码如下：
123456789101112131415161718&#x2F;&#x2F; 声明变量FileWriter fw &#x3D; null;try {    &#x2F;&#x2F;创建流对象    fw &#x3D; new FileWriter(&quot;fw.txt&quot;);    &#x2F;&#x2F; 写出数据    fw.write(&quot;二哥真的帅&quot;); &#x2F;&#x2F;哥敢摸si} catch (IOException e) {    e.printStackTrace();} finally {    try {        if (fw !&#x3D; null) {            fw.close();        }    } catch (IOException e) {        e.printStackTrace();    }}
或者直接使用 try-with-resources 的方式。
123456try (FileWriter fw &#x3D; new FileWriter(&quot;fw.txt&quot;)) {    &#x2F;&#x2F; 写出数据    fw.write(&quot;二哥真的帅&quot;); &#x2F;&#x2F;哥敢摸si} catch (IOException e) {    e.printStackTrace();}
在这个代码中，try-with-resources 会在 try 块执行完毕后自动关闭 FileWriter 对象 fw，不需要手动关闭流。如果在 try 块中发生了异常，也会自动关闭流并抛出异常。因此，使用 try-with-resources 可以让代码更加简洁、安全和易读。
04、小结 
Writer 和 Reader 是 Java I&#x2F;O 中用于字符输入输出的抽象类，它们提供了一系列方法用于读取和写入字符数据。它们的区别在于 Writer 用于将字符数据写入到输出流中，而 Reader 用于从输入流中读取字符数据。
Writer 和 Reader 的常用子类有 FileWriter、FileReader，可以将字符流写入和读取到文件中。
在使用 Writer 和 Reader 进行字符输入输出时，需要注意字符编码的问题。
5.5 缓冲流Java 的缓冲流是对字节流和字符流的一种封装，通过在内存中开辟缓冲区来提高 I&#x2F;O 操作的效率。Java 通过 BufferedInputStream 和 BufferedOutputStream 来实现字节流的缓冲，通过 BufferedReader 和 BufferedWriter 来实现字符流的缓冲。
缓冲流的工作原理是将数据先写入缓冲区中，当缓冲区满时再一次性写入文件或输出流，或者当缓冲区为空时一次性从文件或输入流中读取一定量的数据。这样可以减少系统的 I&#x2F;O 操作次数，提高系统的 I&#x2F;O 效率，从而提高程序的运行效率。
01、字节缓冲流 
BufferedInputStream 和 BufferedOutputStream 属于字节缓冲流，强化了字节流 InputStream 和 OutputStream，关于字节流，我们前面已经详细地讲过了。
1）构造方法 

BufferedInputStream(InputStream in) ：创建一个新的缓冲输入流，注意参数类型为InputStream。
BufferedOutputStream(OutputStream out) ： 创建一个新的缓冲输出流，注意参数类型为OutputStream。

代码示例如下：
1234567&#x2F;&#x2F; 创建字节缓冲输入流，先声明字节流FileInputStream fps &#x3D; new FileInputStream(b.txt);BufferedInputStream bis &#x3D; new BufferedInputStream(fps)&#x2F;&#x2F; 创建字节缓冲输入流（一步到位）BufferedInputStream bis &#x3D; new BufferedInputStream(new FileInputStream(&quot;b.txt&quot;));&#x2F;&#x2F; 创建字节缓冲输出流（一步到位）BufferedOutputStream bos &#x3D; new BufferedOutputStream(new FileOutputStream(&quot;b.txt&quot;));
2）缓冲流的高效 
我们通过复制一个 370M+ 的大文件，来测试缓冲流的效率。为了做对比，我们先用基本流来实现一下，代码如下：
1234567891011121314&#x2F;&#x2F; 记录开始时间long start &#x3D; System.currentTimeMillis();&#x2F;&#x2F; 创建流对象try (FileInputStream fis &#x3D; new FileInputStream(&quot;py.mp4&quot;);&#x2F;&#x2F;exe文件够大        FileOutputStream fos &#x3D; new FileOutputStream(&quot;copyPy.mp4&quot;)){    &#x2F;&#x2F; 读写数据    int b;    while ((b &#x3D; fis.read()) !&#x3D; -1) {        fos.write(b);    }}&#x2F;&#x2F; 记录结束时间long end &#x3D; System.currentTimeMillis();System.out.println(&quot;普通流复制时间:&quot;+(end - start)+&quot; 毫秒&quot;);
不好意思，我本机比较菜，10 分钟还在复制中。切换到缓冲流试一下，代码如下：
12345678910111213141516&#x2F;&#x2F; 记录开始时间long start &#x3D; System.currentTimeMillis();&#x2F;&#x2F; 创建流对象try (BufferedInputStream bis &#x3D; new BufferedInputStream(new FileInputStream(&quot;py.mp4&quot;));        BufferedOutputStream bos &#x3D; new BufferedOutputStream(new FileOutputStream(&quot;copyPy.mp4&quot;));){    &#x2F;&#x2F; 读写数据    int b;    while ((b &#x3D; bis.read()) !&#x3D; -1) {        bos.write(b);    }}&#x2F;&#x2F; 记录结束时间long end &#x3D; System.currentTimeMillis();System.out.println(&quot;缓冲流复制时间:&quot;+(end - start)+&quot; 毫秒&quot;);
只需要 8016 毫秒，如何更快呢？
可以换数组的方式来读写，这个我们前面也有讲到，代码如下：
1234567891011121314151617&#x2F;&#x2F; 记录开始时间long start &#x3D; System.currentTimeMillis();&#x2F;&#x2F; 创建流对象try (BufferedInputStream bis &#x3D; new BufferedInputStream(new FileInputStream(&quot;py.mp4&quot;));        BufferedOutputStream bos &#x3D; new BufferedOutputStream(new FileOutputStream(&quot;copyPy.mp4&quot;));){    &#x2F;&#x2F; 读写数据    int len;    byte[] bytes &#x3D; new byte[8*1024];    while ((len &#x3D; bis.read(bytes)) !&#x3D; -1) {        bos.write(bytes, 0 , len);    }}&#x2F;&#x2F; 记录结束时间long end &#x3D; System.currentTimeMillis();System.out.println(&quot;缓冲流使用数组复制时间:&quot;+(end - start)+&quot; 毫秒&quot;);
这下就更快了，只需要 521 毫秒。
3）为什么字节缓冲流会这么快？ 
传统的 Java IO 是阻塞模式的，它的工作状态就是“读&#x2F;写，等待，读&#x2F;写，等待。。。。。。”
字节缓冲流解决的就是这个问题：一次多读点多写点，减少读写的频率，用空间换时间。

减少系统调用次数：在使用字节缓冲流时，数据不是立即写入磁盘或输出流，而是先写入缓冲区，当缓冲区满时再一次性写入磁盘或输出流。这样可以减少系统调用的次数，从而提高 I&#x2F;O 操作的效率。
减少磁盘读写次数：在使用字节缓冲流时，当需要读取数据时，缓冲流会先从缓冲区中读取数据，如果缓冲区中没有足够的数据，则会一次性从磁盘或输入流中读取一定量的数据。同样地，当需要写入数据时，缓冲流会先将数据写入缓冲区，如果缓冲区满了，则会一次性将缓冲区中的数据写入磁盘或输出流。这样可以减少磁盘读写的次数，从而提高 I&#x2F;O 操作的效率。
提高数据传输效率：在使用字节缓冲流时，由于数据是以块的形式进行传输，因此可以减少数据传输的次数，从而提高数据传输的效率。

我们来看 BufferedInputStream 的 read 方法：
12345678public synchronized int read() throws IOException {    if (pos &gt;&#x3D; count) {     &#x2F;&#x2F; 如果当前位置已经到达缓冲区末尾        fill();             &#x2F;&#x2F; 填充缓冲区        if (pos &gt;&#x3D; count)   &#x2F;&#x2F; 如果填充后仍然到达缓冲区末尾，说明已经读取完毕            return -1;      &#x2F;&#x2F; 返回 -1 表示已经读取完毕    }    return getBufIfOpen()[pos++] &amp; 0xff; &#x2F;&#x2F; 返回当前位置的字节，并将位置加 1}
这段代码主要有两部分：

fill() ：该方法会将缓冲 buf 填满。
getBufIfOpen()[pos++] &amp; 0xff ：返回当前读取位置 pos 处的字节（ getBufIfOpen()返回的是 buffer 数组，是 byte 类型），并将其与 0xff 进行位与运算。这里的目的是将读取到的字节 b 当做无符号的字节处理，因为 Java 的 byte 类型是有符号的，而将 b 与 0xff 进行位与运算，就可以将其转换为无符号的字节，其范围为 0 到 255。


byte &amp; 0xFF 我们一会再细讲。

再来看 FileInputStream 的 read 方法：

在这段代码中， read0() 方法是一个本地方法，它的实现是由底层操作系统提供的，并不是 Java 语言实现的。在不同的操作系统上， read0() 方法的实现可能会有所不同，但是它们的功能都是相同的，都是用于读取一个字节。
再来看一下 BufferedOutputStream 的 write(byte b[], int off, int len) 方法：
123456789101112public synchronized void write(byte b[], int off, int len) throws IOException {    if (len &gt;&#x3D; buf.length) {    &#x2F;&#x2F; 如果写入的字节数大于等于缓冲区长度        flushBuffer();          &#x2F;&#x2F; 先刷新缓冲区        out.write(b, off, len); &#x2F;&#x2F; 直接将数据写入输出流        return;    }    if (len &gt; buf.length - count) { &#x2F;&#x2F; 如果写入的字节数大于空余空间        flushBuffer();              &#x2F;&#x2F; 先刷新缓冲区    }    System.arraycopy(b, off, buf, count, len); &#x2F;&#x2F; 将数据拷贝到缓冲区中    count +&#x3D; len;                             &#x2F;&#x2F; 更新计数器}
首先，该方法会检查写入的字节数是否大于等于缓冲区长度，如果是，则先将缓冲区中的数据刷新到磁盘中，然后直接将数据写入输出流。这样做是为了避免缓冲流级联时的问题，即缓冲区的大小不足以容纳写入的数据时，可能会引发级联刷新，导致效率降低。

级联问题（Cascade Problem）是指在一组缓冲流（Buffered Stream）中，由于缓冲区的大小不足以容纳要写入的数据，导致数据被分割成多个部分，并分别写入到不同的缓冲区中，最终需要逐个刷新缓冲区，从而导致性能下降的问题。

其次，如果写入的字节数小于缓冲区长度，则检查缓冲区中剩余的空间是否足够容纳要写入的字节数，如果不够，则先将缓冲区中的数据刷新到磁盘中。然后，使用 System.arraycopy() 方法将要写入的数据拷贝到缓冲区中，并更新计数器 count。
最后，如果写入的字节数小于缓冲区长度且缓冲区中还有剩余空间，则直接将要写入的数据拷贝到缓冲区中，并更新计数器 count。
也就是说，只有当 buf 写满了，才会 flush，将数据刷到磁盘，默认一次刷 8192 个字节。
123public BufferedOutputStream(OutputStream out) {    this(out, 8192);}
如果 buf 没有写满，会继续写 buf。

当把 BufferedOutputStream 和 BufferedInputStream 配合起来使用后，就减少了大量的读写次数，尤其是 byte[] bytes &#x3D; new byte[8*1024] ，就相当于缓冲区的空间有 8 个 1024 字节，那读写效率就会大大提高。
4） byte &amp; 0xFF
byte 类型通常被用于存储二进制数据，例如读取和写入文件、网络传输等场景。在这些场景下，byte 类型的变量可以用来存储数据流中的每个字节，从而进行读取和写入操作。
byte 类型是有符号的，即其取值范围为 -128 到 127。如果我们希望得到的是一个无符号的 byte 值，就需要使用 byte &amp; 0xFF 来进行转换。
这是因为 0xFF 是一个无符号的整数，它的二进制表示为 11111111。当一个 byte 类型的值与 0xFF 进行位与运算时，会将 byte 类型的值转换为一个无符号的整数，其范围为 0 到 255。
0xff 是一个十六进制的数，相当于二进制的 11111111，&amp; 运算符的意思是：如果两个操作数的对应位为 1，则输出 1，否则为 0；由于 0xff 有 8 个 1，单个 byte 转成 int 其实就是将 byte 和 int 类型的 255 进行(&amp;)与运算。
例如，如果我们有一个 byte 类型的变量 b，其值为 -1，那么 b &amp; 0xFF 的结果就是 255。这样就可以将一个有符号的 byte 类型的值转换为一个无符号的整数。
&amp; 运算是一种二进制数据的计算方式, 两个操作位都为1，结果才为1，否则结果为0. 在上面的 getBufIfOpen()[pos++] &amp; 0xff 计算过程中, byte 有 8bit, OXFF 是16进制的255, 表示的是 int 类型, int 有 32bit.
如果 getBufIfOpen()[pos++] 为 -118, 那么其原码表示为
100000000 00000000 00000000 10001010
反码为
111111111 11111111 11111111 11110101
补码为
111111111 11111111 11111111 11110110
0XFF 表示16进制的数据255, 原码, 反码, 补码都是一样的, 其二进制数据为
100000000 00000000 00000000 11111111
0XFF 和 -118 进行&amp;运算后结果为
100000000 00000000 00000000 11110110
还原为原码后为
100000000 00000000 00000000 10001010
其表示的 int 值为 138，可见将 byte 类型的 -118 与 0XFF 进行与运算后值由 -118 变成了 int 类型的 138，其中低8位和byte的-118完全一致。
顺带聊一下 原码、反码和补码。
①、原码
原码就是符号位加上真值的绝对值，即用第一位表示符号，其余位表示值。比如如果是8位二进制:
12[+1]原 &#x3D; 0000 0001[-1]原 &#x3D; 1000 0001
第一位是符号位。因为第一位是符号位，所以8位二进制数的取值范围就是：
1[1111 1111 , 0111 1111]
即
1[-127 , 127]
②、反码
反码的表示方法是：

正数的反码是其本身
负数的反码是在其原码的基础上，符号位不变，其余各个位取反。

例如：
12[+1] &#x3D; [00000001]原 &#x3D; [00000001]反[-1] &#x3D; [10000001]原 &#x3D; [11111110]反
可见如果一个反码表示的是负数，人脑无法直观的看出来它的数值。通常要将其转换成原码再计算。
③、补码
补码的表示方法是：

正数的补码就是其本身
负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后+1。(即在反码的基础上+1)

12[+1] &#x3D; [00000001]原 &#x3D; [00000001]反 &#x3D; [00000001]补[-1] &#x3D; [10000001]原 &#x3D; [11111110]反 &#x3D; [11111111]补
对于负数，补码表示方式也是人脑无法直观看出其数值的。通常也需要转换成原码在计算其数值。
从上面可以看到：

对于正数：原码，反码，补码都是一样的
对于负数：原码，反码，补码都是不一样的

02、字符缓冲流 
BufferedReader 类继承自 Reader 类，提供了一些便捷的方法，例如 readLine() 方法可以一次读取一行数据，而不是一个字符一个字符地读取。
BufferedWriter 类继承自 Writer 类，提供了一些便捷的方法，例如 newLine() 方法可以写入一个系统特定的行分隔符。
1）构造方法 

BufferedReader(Reader in) ：创建一个新的缓冲输入流，注意参数类型为Reader。
BufferedWriter(Writer out) ： 创建一个新的缓冲输出流，注意参数类型为Writer。

代码示例如下：
1234&#x2F;&#x2F; 创建字符缓冲输入流BufferedReader br &#x3D; new BufferedReader(new FileReader(&quot;b.txt&quot;));&#x2F;&#x2F; 创建字符缓冲输出流BufferedWriter bw &#x3D; new BufferedWriter(new FileWriter(&quot;b.txt&quot;));
2）字符缓冲流特有方法 
字符缓冲流的基本方法与普通字符流调用方式一致，这里不再赘述，我们来看字符缓冲流特有的方法。

BufferedReader： String readLine() : 读一行数据，读取到最后返回 null
BufferedWriter： newLine() : 换行，由系统定义换行符。

来看 readLine()方法的代码示例：
1234567891011&#x2F;&#x2F; 创建流对象BufferedReader br &#x3D; new BufferedReader(new FileReader(&quot;a.txt&quot;));&#x2F;&#x2F; 定义字符串,保存读取的一行文字String line  &#x3D; null;&#x2F;&#x2F; 循环读取,读取到最后返回nullwhile ((line &#x3D; br.readLine())!&#x3D;null) {    System.out.print(line);    System.out.println(&quot;------&quot;);}&#x2F;&#x2F; 释放资源br.close();
再来看 newLine() 方法的代码示例：
1234567891011121314&#x2F;&#x2F; 创建流对象BfferedWriter bw &#x3D; new BufferedWriter(new FileWriter(&quot;b.txt&quot;));&#x2F;&#x2F; 写出数据bw.write(&quot;沉&quot;);&#x2F;&#x2F; 写出换行bw.newLine();bw.write(&quot;默&quot;);bw.newLine();bw.write(&quot;王&quot;);bw.newLine();bw.write(&quot;二&quot;);bw.newLine();&#x2F;&#x2F; 释放资源bw.close();
03、字符缓冲流练习
来欣赏一下我写的这篇诗：

6.岑夫子，丹丘生，将进酒，杯莫停。
1.君不见黄河之水天上来，奔流到海不复回。
8.钟鼓馔玉不足贵，但愿长醉不愿醒。
3.人生得意须尽欢，莫使金樽空对月。
5.烹羊宰牛且为乐，会须一饮三百杯。
2.君不见高堂明镜悲白发，朝如青丝暮成雪。
7.与君歌一曲，请君为我倾耳听。
4.天生我材必有用，千金散尽还复来。

欣赏完了没？
估计你也看出来了，这是李白写的《将进酒》，不是我王二写的。
不过，顺序是乱的，还好，我都编了号。那如何才能按照正确的顺序来呢？
来看代码实现：
12345678910111213141516171819202122232425262728293031&#x2F;&#x2F; 创建map集合,保存文本数据,键为序号,值为文字HashMap&lt;String, String&gt; lineMap &#x3D; new HashMap&lt;&gt;();&#x2F;&#x2F; 创建流对象  源BufferedReader br &#x3D; new BufferedReader(new FileReader(&quot;logs&#x2F;test.log&quot;));&#x2F;&#x2F;目标BufferedWriter bw &#x3D; new BufferedWriter(new FileWriter(&quot;logs&#x2F;test1.txt&quot;));&#x2F;&#x2F; 读取数据String line;while ((line &#x3D; br.readLine())!&#x3D;null) {    &#x2F;&#x2F; 解析文本    if (line.isEmpty()) {        continue;    }    String[] split &#x3D; line.split(Pattern.quote(&quot;.&quot;));    &#x2F;&#x2F; 保存到集合    lineMap.put(split[0], split[1]);}&#x2F;&#x2F; 释放资源br.close();&#x2F;&#x2F; 遍历map集合for (int i &#x3D; 1; i &lt;&#x3D; lineMap.size(); i++) {    String key &#x3D; String.valueOf(i);    &#x2F;&#x2F; 获取map中文本    String value &#x3D; lineMap.get(key);    &#x2F;&#x2F; 写出拼接文本    bw.write(key+&quot;.&quot;+value);    &#x2F;&#x2F; 写出换行    bw.newLine();}&#x2F;&#x2F; 释放资源bw.close();
这里面用到的知识都是我们前面学过的，比如说 HashMap，字符串分割，包括刚刚学习的字符缓冲流。
来看输出结果
123456781.君不见黄河之水天上来，奔流到海不复回。2.君不见高堂明镜悲白发，朝如青丝暮成雪。3.人生得意须尽欢，莫使金樽空对月。4.天生我材必有用，千金散尽还复来。5.烹羊宰牛且为乐，会须一饮三百杯。6.岑夫子，丹丘生，将进酒，杯莫停。7.与君歌一曲，请君为我倾耳听。8.钟鼓馔玉不足贵，但愿长醉不愿醒。
5.6 转换流转换流可以将一个字节流包装成字符流，或者将一个字符流包装成字节流。这种转换通常用于处理文本数据，如读取文本文件或将数据从网络传输到应用程序。
转换流主要有两种类型：InputStreamReader 和 OutputStreamWriter。
InputStreamReader 将一个字节输入流转换为一个字符输入流，而 OutputStreamWriter 将一个字节输出流转换为一个字符输出流。它们使用指定的字符集将字节流和字符流之间进行转换。常用的字符集包括 UTF-8、GBK、ISO-8859-1 等。

01、编码和解码 
在计算机中，数据通常以二进制形式存储和传输。

编码就是将原始数据（比如说文本、图像、视频、音频等）转换为二进制形式。
解码就是将二进制数据转换为原始数据，是一个反向的过程。

常见的编码和解码方式有很多，举几个例子：

ASCII 编码和解码：在计算机中，常常使用 ASCII 码来表示字符，如键盘上的字母、数字和符号等。例如，字母 A 对应的 ASCII 码是 65，字符 + 对应的 ASCII 码是 43。
Unicode 编码和解码：Unicode 是一种字符集，支持多种语言和字符集。在计算机中，Unicode 可以使用 UTF-8、UTF-16 等编码方式将字符转换为二进制数据进行存储和传输。
Base64 编码和解码：Base64 是一种将二进制数据转换为 ASCII 码的编码方式。它将 3 个字节的二进制数据转换为 4 个 ASCII 字符，以便在网络传输中使用。例如，将字符串 “Hello, world!” 进行 Base64 编码后，得到的结果是 “SGVsbG8sIHdvcmxkIQ&#x3D;&#x3D;”。
图像编码和解码：在图像处理中，常常使用 JPEG、PNG、GIF 等编码方式将图像转换为二进制数据进行存储和传输。在解码时，可以将二进制数据转换为图像，以便显示或处理。
视频编码和解码：在视频处理中，常常使用 H.264、AVC、MPEG-4 等编码方式将视频转换为二进制数据进行存储和传输。在解码时，可以将二进制数据转换为视频，以便播放或处理。

简单一点说就是：

编码：字符(能看懂的)—&gt;字节(看不懂的)
解码：字节(看不懂的)—&gt;字符(能看懂的)

我用代码来表示一下：
12345678String str &#x3D; &quot;沉默王二&quot;;String charsetName &#x3D; &quot;UTF-8&quot;;&#x2F;&#x2F; 编码byte[] bytes &#x3D; str.getBytes(Charset.forName(charsetName));System.out.println(&quot;编码: &quot; + bytes);&#x2F;&#x2F; 解码String decodedStr &#x3D; new String(bytes, Charset.forName(charsetName));System.out.println(&quot;解码: &quot; + decodedStr);
在这个示例中，首先定义了一个字符串变量 str 和一个字符集名称 charsetName。然后，使用 Charset.forName() 方法获取指定字符集的 Charset 对象。接着，使用字符串的 getBytes() 方法将字符串编码为指定字符集的字节数组。最后，使用 new String() 方法将字节数组解码为字符串。
需要注意的是，在编码和解码过程中，要保证使用相同的字符集，以便正确地转换数据。
02、字符集 
Charset：字符集，是一组字符的集合，每个字符都有一个唯一的编码值，也称为码点。
常见的字符集包括 ASCII、Unicode 和 GBK，而 Unicode 字符集包含了多种编码方式，比如说 UTF-8、UTF-16。

ASCII 字符集 
ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）字符集是一种最早的字符集，包含 128 个字符，其中包括控制字符、数字、英文字母以及一些标点符号。ASCII 字符集中的每个字符都有一个唯一的 7 位二进制编码（由 0 和 1 组成），可以表示为十进制数或十六进制数。
ASCII 编码方式是一种固定长度的编码方式，每个字符都使用 7 位二进制编码来表示。ASCII 编码只能表示英文字母、数字和少量的符号，不能表示其他语言的文字和符号，因此在全球范围内的应用受到了很大的限制。
Unicode 字符集 
Unicode 包含了世界上几乎所有的字符，用于表示人类语言、符号和表情等各种信息。Unicode 字符集中的每个字符都有一个唯一的码点（code point），用于表示该字符在字符集中的位置，可以用十六进制数表示。
为了在计算机中存储和传输 Unicode 字符集中的字符，需要使用一种编码方式。UTF-8、UTF-16 和 UTF-32 都是 Unicode 字符集的编码方式，用于将 Unicode 字符集中的字符转换成字节序列，以便于存储和传输。
它们的差别在于使用的字节长度不同。

UTF-8 是一种可变长度的编码方式，对于 ASCII 字符（码点范围为 0x00~0x7F ），使用一个字节表示，对于其他 Unicode 字符，使用两个、三个或四个字节表示。UTF-8 编码方式被广泛应用于互联网和计算机领域，因为它可以有效地压缩数据，适用于网络传输和存储。
UTF-16 是一种固定长度的编码方式，对于基本多语言平面（Basic Multilingual Plane，Unicode 字符集中的一个码位范围，包含了世界上大部分常用的字符，总共包含了超过 65,000 个码位）中的字符（码点范围为 0x0000~0xFFFF ），使用两个字节表示，对于其他 Unicode 字符，使用四个字节表示。
UTF-32 是一种固定长度的编码方式，对于所有 Unicode 字符，使用四个字节表示。

GBK 字符集 
GBK 包含了 GB2312 字符集中的字符，同时还扩展了许多其他汉字字符和符号，共收录了 21,913 个字符。
GBK 采用双字节编码方式，每个汉字占用 2 个字节，其中高字节和低字节都使用了 8 位，因此 GBK 编码共有 2^16&#x3D;65536 种可能的编码，其中大部分被用于表示汉字字符。
GBK 编码是一种变长的编码方式，对于 ASCII 字符（码位范围为 0x00 到 0x7F），使用一个字节表示，对于其他字符，使用两个字节表示。GBK 编码中的每个字节都可以采用 0x81 到 0xFE 之间的任意一个值，因此可以表示 2^15&#x3D;32768 个字符。为了避免与 ASCII 码冲突，GBK 编码的第一个字节采用了 0x81 到 0xFE 之间除了 0x7F 的所有值，第二个字节采用了 0x40 到 0x7E 和 0x80 到 0xFE 之间的所有值，共 94 个值。
GB2312 的全名是《信息交换用汉字编码字符集基本集》，也被称为“国标码”。采用了双字节编码方式，每个汉字占用 2 个字节，其中高字节和低字节都使用了 8 位，因此 GB2312 编码共有 2^16&#x3D;65536 种可能的编码，其中大部分被用于表示汉字字符。GB2312 编码中的每个字节都可以采用 0xA1 到 0xF7 之间的任意一个值，因此可以表示 126 个字符。
GB2312 是一个较为简单的字符集，只包含了常用的汉字和符号，因此对于一些较为罕见的汉字和生僻字，GB2312 不能满足需求，现在已经逐渐被 GBK、GB18030 等字符集所取代。
GB18030 是最新的中文码表。收录汉字 70244 个，采用多字节编码，每个字可以由 1 个、2 个或 4 个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。
03、乱码 
当使用不同的编码方式读取或者写入文件时，就会出现乱码问题，来看示例。
12345678910111213141516String s &#x3D; &quot;沉默王二！&quot;;try {    &#x2F;&#x2F; 将字符串按GBK编码方式保存到文件中    OutputStreamWriter out &#x3D; new OutputStreamWriter(            new FileOutputStream(&quot;logs&#x2F;test_utf8.txt&quot;), &quot;GBK&quot;);    out.write(s);    out.close();    FileReader fileReader &#x3D; new FileReader(&quot;logs&#x2F;test_utf8.txt&quot;);    int read;    while ((read &#x3D; fileReader.read()) !&#x3D; -1) {        System.out.print((char)read);    }    fileReader.close();} catch (IOException e) {    e.printStackTrace();}
在上面的示例代码中，首先定义了一个包含中文字符的字符串，然后将该字符串按 GBK 编码方式保存到文件中，接着将文件按默认编码方式（UTF-8）读取，并显示内容。此时就会出现乱码问题，显示为“��Ĭ������”。
这是因为文件中的 GBK 编码的字符在使用 UTF-8 编码方式解析时无法正确解析，从而导致出现乱码问题。
那如何才能解决乱码问题呢？
这就引出我们今天的主角了——转换流。
04、InputStreamReader 
java.io.InputStreamReader 是 Reader 类的子类。它的作用是将字节流（InputStream）转换为字符流（Reader），同时支持指定的字符集编码方式，从而实现字符流与字节流之间的转换。
1）构造方法 

InputStreamReader(InputStream in) : 创建一个使用默认字符集的字符流。
InputStreamReader(InputStream in, String charsetName) : 创建一个指定字符集的字符流。

代码示例如下：
12InputStreamReader isr &#x3D; new InputStreamReader(new FileInputStream(&quot;in.txt&quot;));InputStreamReader isr2 &#x3D; new InputStreamReader(new FileInputStream(&quot;in.txt&quot;) , &quot;GBK&quot;);
2）解决编码问题 
下面是一个使用 InputStreamReader 解决乱码问题的示例代码：
12345678910111213141516171819String s &#x3D; &quot;沉默王二！&quot;;try {    &#x2F;&#x2F; 将字符串按GBK编码方式保存到文件中    OutputStreamWriter outUtf8 &#x3D; new OutputStreamWriter(            new FileOutputStream(&quot;logs&#x2F;test_utf8.txt&quot;), &quot;GBK&quot;);    outUtf8.write(s);    outUtf8.close();    &#x2F;&#x2F; 将字节流转换为字符流，使用GBK编码方式    InputStreamReader isr &#x3D; new InputStreamReader(new FileInputStream(&quot;logs&#x2F;test_utf8.txt&quot;), &quot;GBK&quot;);    &#x2F;&#x2F; 读取字符流    int c;    while ((c &#x3D; isr.read()) !&#x3D; -1) {        System.out.print((char) c);    }    isr.close();} catch (IOException e) {    e.printStackTrace();}
由于使用了 InputStreamReader 对字节流进行了编码方式的转换，因此在读取字符流时就可以正确地解析出中文字符，避免了乱码问题。
05、OutputStreamWriter 
java.io.OutputStreamWriter 是 Writer 的子类，字面看容易误以为是转为字符流，其实是将字符流转换为字节流，是字符流到字节流的桥梁。

OutputStreamWriter(OutputStream in) : 创建一个使用默认字符集的字符流。
OutputStreamWriter(OutputStream in, String charsetName) ：创建一个指定字符集的字符流。

代码示例如下：
12OutputStreamWriter isr &#x3D; new OutputStreamWriter(new FileOutputStream(&quot;a.txt&quot;));OutputStreamWriter isr2 &#x3D; new OutputStreamWriter(new FileOutputStream(&quot;b.txt&quot;) , &quot;GBK&quot;);
通常为了提高读写效率，我们会在转换流上再加一层缓冲流，来看代码示例：
12345678910111213141516171819202122232425try {    &#x2F;&#x2F; 从文件读取字节流，使用UTF-8编码方式    FileInputStream fis &#x3D; new FileInputStream(&quot;test.txt&quot;);    &#x2F;&#x2F; 将字节流转换为字符流，使用UTF-8编码方式    InputStreamReader isr &#x3D; new InputStreamReader(fis, &quot;UTF-8&quot;);    &#x2F;&#x2F; 使用缓冲流包装字符流，提高读取效率    BufferedReader br &#x3D; new BufferedReader(isr);    &#x2F;&#x2F; 创建输出流，使用UTF-8编码方式    FileOutputStream fos &#x3D; new FileOutputStream(&quot;output.txt&quot;);    &#x2F;&#x2F; 将输出流包装为转换流，使用UTF-8编码方式    OutputStreamWriter osw &#x3D; new OutputStreamWriter(fos, &quot;UTF-8&quot;);    &#x2F;&#x2F; 使用缓冲流包装转换流，提高写入效率    BufferedWriter bw &#x3D; new BufferedWriter(osw);    &#x2F;&#x2F; 读取输入文件的每一行，写入到输出文件中    String line;    while ((line &#x3D; br.readLine()) !&#x3D; null) {        bw.write(line);        bw.newLine(); &#x2F;&#x2F; 每行结束后写入一个换行符    }    &#x2F;&#x2F; 关闭流    br.close();    bw.close();} catch (IOException e) {    e.printStackTrace();}
在上面的示例代码中，首先使用 FileInputStream 从文件中读取字节流，使用 UTF-8 编码方式进行读取。然后，使用 InputStreamReader 将字节流转换为字符流，使用 UTF-8 编码方式进行转换。接着，使用 BufferedReader 包装字符流，提高读取效率。然后，创建 FileOutputStream 用于输出文件，使用 UTF-8 编码方式进行创建。接着，使用 OutputStreamWriter 将输出流转换为字符流，使用 UTF-8 编码方式进行转换。最后，使用 BufferedWriter 包装转换流，提高写入效率。
06、小结 
InputStreamReader 和 OutputStreamWriter 是将字节流转换为字符流或者将字符流转换为字节流。通常用于解决字节流和字符流之间的转换问题，可以将字节流以指定的字符集编码方式转换为字符流，或者将字符流以指定的字符集编码方式转换为字节流。
InputStreamReader 类的常用方法包括：

read() ：从输入流中读取一个字符的数据。
read(char[] cbuf, int off, int len) ：从输入流中读取 len 个字符的数据到指定的字符数组 cbuf 中，从 off 位置开始存放。
ready() ：返回此流是否已准备好读取。
close() ：关闭输入流。

OutputStreamWriter 类的常用方法包括：

write(int c) ：向输出流中写入一个字符的数据。
write(char[] cbuf, int off, int len) ：向输出流中写入指定字符数组 cbuf 中的 len 个字符，从 off 位置开始。
flush() ：将缓冲区的数据写入输出流中。
close() ：关闭输出流。

在使用转换流时，需要指定正确的字符集编码方式，否则可能会导致数据读取或写入出现乱码。
5.7 打印流在我的职业生涯中， System.out.println() 的使用频率恐怕不亚于 main 方法的使用频率。其中 System.out 返回的正是打印流 PrintStream 。
除此之外，还有它还有一个孪生兄弟，PrintWriter。PrintStream 是 OutputStream 的子类，PrintWriter 是 Writer 的子类，也就是说，一个字节流，一个是字符流。
打印流具有以下几个特点：

可以自动进行数据类型转换：打印流可以将各种数据类型转换为字符串，并输出到指定的输出流中。
可以自动进行换行操作：打印流可以在输出字符串的末尾自动添加换行符，方便输出多个字符串时的格式控制。
可以输出到控制台或者文件中：打印流可以将数据输出到控制台或者文件中，方便调试和日志记录（尽管生产环境下更推荐使用 Logback、ELK 等）。

PrintStream 类的常用方法包括：

print() ：输出一个对象的字符串表示形式。
println() ：输出一个对象的字符串表示形式，并在末尾添加一个换行符。
printf() ：使用指定的格式字符串和参数输出格式化的字符串。

来一个示例体验一下。
12345678PrintStream ps &#x3D; System.out;ps.println(&quot;沉默王二&quot;);ps.print(&quot;沉 &quot;);ps.print(&quot;默 &quot;);ps.print(&quot;王 &quot;);ps.print(&quot;二 &quot;);ps.println();ps.printf(&quot;姓名：%s，年龄：%d，成绩：%f&quot;, &quot;沉默王二&quot;, 18, 99.9);
在这个示例中，我们创建了一个 PrintStream 对象 ps，它输出到控制台。我们使用 ps 的 print 和 println 方法输出了一些字符串。
使用 printf 方法输出了一个格式化字符串，其中 %s、%d 和 %.2f 分别表示字符串、整数和浮点数的格式化输出。我们使用逗号分隔的参数列表指定了要输出的值。
来详细说说 printf 方法哈。
1public PrintStream printf(String format, Object... args);
其中，format 参数是格式化字符串，args 参数是要输出的参数列表。格式化字符串包含了普通字符和转换说明符。普通字符是指除了转换说明符之外的字符，它们在输出时直接输出。转换说明符是由百分号（%）和一个或多个字符组成的，用于指定输出的格式和数据类型。
下面是 Java 的常用转换说明符及对应的输出格式：

%s ：输出一个字符串。
%d 或 %i ：输出一个十进制整数。
%x 或 %X ：输出一个十六进制整数， %x 输出小写字母， %X 输出大写字母。
%f 或 %F ：输出一个浮点数。
%e 或 %E ：输出一个科学计数法表示的浮点数， %e 输出小写字母 e， %E 输出大写字母 E。
%g 或 %G ：输出一个浮点数，自动选择 %f 或 %e&#x2F;%E 格式输出。
%c ：输出一个字符。
%b ：输出一个布尔值。
%h ：输出一个哈希码（16进制）。
%n ：换行符。

除了转换说明符之外，Java 的 printf 方法还支持一些修饰符，用于指定输出的宽度、精度、对齐方式等。

宽度修饰符：用数字指定输出的最小宽度，如果输出的数据不足指定宽度，则在左侧或右侧填充空格或零。
精度修饰符：用点号（.）和数字指定浮点数或字符串的精度，对于浮点数，指定小数点后的位数，对于字符串，指定输出的字符数。
对齐修饰符：用减号（-）或零号（0）指定输出的对齐方式，减号表示左对齐，零号表示右对齐并填充零。

下面是一些示例：
12345678910int num &#x3D; 123;System.out.printf(&quot;%5d\n&quot;, num); &#x2F;&#x2F; 输出 &quot;  123&quot;System.out.printf(&quot;%-5d\n&quot;, num); &#x2F;&#x2F; 输出 &quot;123  &quot;System.out.printf(&quot;%05d\n&quot;, num); &#x2F;&#x2F; 输出 &quot;00123&quot;double pi &#x3D; Math.PI;System.out.printf(&quot;%10.2f\n&quot;, pi); &#x2F;&#x2F; 输出 &quot;      3.14&quot;System.out.printf(&quot;%-10.4f\n&quot;, pi); &#x2F;&#x2F; 输出 &quot;3.1416    &quot;String name &#x3D; &quot;沉默王二&quot;;System.out.printf(&quot;%10s\n&quot;, name); &#x2F;&#x2F; 输出 &quot;     沉默王二&quot;System.out.printf(&quot;%-10s\n&quot;, name); &#x2F;&#x2F; 输出 &quot;沉默王二     &quot;
具体来说，

我们使用 %5d 来指定输出的整数占据 5 个字符的宽度，不足部分在左侧填充空格。
使用 %-5d 来指定输出的整数占据 5 个字符的宽度，不足部分在右侧填充空格。
使用 %05d 来指定输出的整数占据 5 个字符的宽度，不足部分在左侧填充 0。
使用 %10.2f 来指定输出的浮点数占据 10 个字符的宽度，保留 2 位小数，不足部分在左侧填充空格。
使用 %-10.4f 来指定输出的浮点数占据 10 个字符的宽度，保留 4 位小数，不足部分在右侧填充空格。
使用 %10s 来指定输出的字符串占据 10 个字符的宽度，不足部分在左侧填充空格。
使用 %-10s 来指定输出的字符串占据 10 个字符的宽度，不足部分在右侧填充空格。

接下来，我们给出一个 PrintWriter 的示例：
1234PrintWriter writer &#x3D; new PrintWriter(new FileWriter(&quot;output.txt&quot;));writer.println(&quot;沉默王二&quot;);writer.printf(&quot;他的年纪为 %d.\n&quot;, 18);writer.close();
首先，我们创建一个 PrintWriter 对象，它的构造函数接收一个 Writer 对象作为参数。在这里，我们使用 FileWriter 来创建一个输出文件流，并将其作为参数传递给 PrintWriter 的构造函数。然后，我们使用 PrintWriter 的 println 和 printf 方法来输出两行内容，其中 printf 方法可以接收格式化字符串。最后，我们调用 PrintWriter 的 close 方法来关闭输出流。
我们也可以不创建 FileWriter 对象，直接指定文件名。
1234PrintWriter pw &#x3D; new PrintWriter(&quot;output.txt&quot;);pw.println(&quot;沉默王二&quot;);pw.printf(&quot;他的年纪为 %d.\n&quot;, 18);pw.close();
好，关于打印流我们就说这么多，比较简单。至于 printf 的一些规则，用到的时候可以再查使用说明或者看 API 文档就可以了，记不住没关系。
5.8 序列流(序列化和反序列化)Java 的序列流（ObjectInputStream 和 ObjectOutputStream）是一种可以将 Java 对象序列化和反序列化的流。
序列化是指将一个对象转换为一个字节序列（包含对象的数据 、对象的类型和对象中存储的属性等信息），以便在网络上传输或保存到文件中，或者在程序之间传递。在 Java 中，序列化通过实现 java.io.Serializable 接口来实现，只有实现了 Serializable 接口的对象才能被序列化。
反序列化是指将一个字节序列转换为一个对象，以便在程序中使用。

01、ObjectOutputStream 
java.io.ObjectOutputStream 继承自 OutputStream 类，因此可以将序列化后的字节序列写入到文件、网络等输出流中。
来看 ObjectOutputStream 的构造方法： 
ObjectOutputStream(OutputStream out)
该构造方法接收一个 OutputStream 对象作为参数，用于将序列化后的字节序列输出到指定的输出流中。例如：
12FileOutputStream fos &#x3D; new FileOutputStream(&quot;file.txt&quot;);ObjectOutputStream oos &#x3D; new ObjectOutputStream(fos);
一个对象要想序列化，必须满足两个条件:

该类必须实现 java.io.Serializable 接口，否则会抛出 NotSerializableException 。
该类的所有字段都必须是可序列化的。如果一个字段不需要序列化，则需要使用 transient 关键字进行修饰。

使用示例如下：
12345public class Employee implements Serializable {    public String name;    public String address;    public transient int age; &#x2F;&#x2F; transient瞬态修饰成员,不会被序列化}
接下来，来聊聊 writeObject (Object obj) 方法，该方法是 ObjectOutputStream 类中用于将对象序列化成字节序列并输出到输出流中的方法，可以处理对象之间的引用关系、继承关系、静态字段和 transient 字段。
123456789101112131415161718192021222324252627public class ObjectOutputStreamDemo {    public static void main(String[] args) {        Person person &#x3D; new Person(&quot;沉默王二&quot;, 20);        try {            FileOutputStream fos &#x3D; new FileOutputStream(&quot;logs&#x2F;person.dat&quot;);            ObjectOutputStream oos &#x3D; new ObjectOutputStream(fos);            oos.writeObject(person);            oos.close();        } catch (IOException e) {            e.printStackTrace();        }    }}class Person implements Serializable {    private String name;    private int age;    public Person(String name, int age) {        this.name &#x3D; name;        this.age &#x3D; age;    }    public String getName() {        return name;    }    public int getAge() {        return age;    }}
上面的代码中，首先创建了一个 Person 对象，然后使用 FileOutputStream 和 ObjectOutputStream 将 Person 对象序列化并输出到 person.dat 文件中。在 Person 类中，实现了 Serializable 接口，表示该类可以进行对象序列化。
02、ObjectInputStream 
ObjectInputStream 可以读取 ObjectOutputStream 写入的字节流，并将其反序列化为相应的对象（包含对象的数据 、对象的类型和对象中存储的属性等信息）。
说简单点就是，序列化之前是什么样子，反序列化后就是什么样子。
来看一下构造方法： ObjectInputStream(InputStream in) ： 创建一个指定 InputStream 的 ObjectInputStream。
其中，ObjectInputStream 的 readObject 方法用来读取指定文件中的对象，示例如下：
123456789101112String filename &#x3D; &quot;logs&#x2F;person.dat&quot;; &#x2F;&#x2F; 待反序列化的文件名try (FileInputStream fileIn &#x3D; new FileInputStream(filename);     ObjectInputStream in &#x3D; new ObjectInputStream(fileIn)) {     &#x2F;&#x2F; 从指定的文件输入流中读取对象并反序列化     Object obj &#x3D; in.readObject();     &#x2F;&#x2F; 将反序列化后的对象强制转换为指定类型     Person p &#x3D; (Person) obj;     &#x2F;&#x2F; 打印反序列化后的对象信息     System.out.println(&quot;Deserialized Object: &quot; + p);} catch (IOException | ClassNotFoundException e) {     e.printStackTrace();}
我们首先指定了待反序列化的文件名（前面通过 ObjectOutputStream 序列化后的文件），然后创建了一个 FileInputStream 对象和一个 ObjectInputStream 对象。接着我们调用 ObjectInputStream 的 readObject 方法来读取指定文件中的对象，并将其强制转换为 Person 类型。最后我们打印了反序列化后的对象信息。
03、Kryo 
实际开发中，很少使用 JDK 自带的序列化和反序列化，这是因为：

可移植性差：Java 特有的，无法跨语言进行序列化和反序列化。
性能差：序列化后的字节体积大，增加了传输&#x2F;保存成本。
安全问题：攻击者可以通过构造恶意数据来实现远程代码执行，从而对系统造成严重的安全威胁。相关阅读：Java 反序列化漏洞之殇 。

Kryo 是一个优秀的 Java 序列化和反序列化库，具有高性能、高效率和易于使用和扩展等特点，有效地解决了 JDK 自带的序列化机制的痛点。

GitHub 地址：https:&#x2F;&#x2F;github.com&#x2F;EsotericSoftware&#x2F;kryo

使用示例：
第一步，在 pom.xml 中引入依赖。
123456&lt;!-- 引入 Kryo 序列化工具 --&gt;&lt;dependency&gt;     &lt;groupId&gt;com.esotericsoftware&lt;&#x2F;groupId&gt;     &lt;artifactId&gt;kryo&lt;&#x2F;artifactId&gt;     &lt;version&gt;5.4.0&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;
第二步，创建一个 Kryo 对象，并使用 register() 方法将对象进行注册。然后，使用 writeObject() 方法将 Java 对象序列化为二进制流，再使用 readObject() 方法将二进制流反序列化为 Java 对象。最后，输出反序列化后的 Java 对象。
12345678910111213141516171819202122232425262728293031323334353637383940414243public class KryoDemo {    public static void main(String[] args) throws FileNotFoundException {        Kryo kryo &#x3D; new Kryo();        kryo.register(KryoParam.class);        KryoParam object &#x3D; new KryoParam(&quot;沉默王二&quot;, 123);        Output output &#x3D; new Output(new FileOutputStream(&quot;logs&#x2F;kryo.bin&quot;));        kryo.writeObject(output, object);        output.close();        Input input &#x3D; new Input(new FileInputStream(&quot;logs&#x2F;kryo.bin&quot;));        KryoParam object2 &#x3D; kryo.readObject(input, KryoParam.class);        System.out.println(object2);        input.close();    }}class KryoParam {    private String name;    private int age;    public KryoParam() {    }    public KryoParam(String name, int age) {        this.name &#x3D; name;        this.age &#x3D; age;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name &#x3D; name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age &#x3D; age;    }    @Override    public String toString() {        return &quot;KryoParam{&quot; +                &quot;name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, age&#x3D;&quot; + age +                &#39;}&#39;;    }}
04、小结 
本节我们介绍了 Java 的序列化机制，并推荐了一款高性能的 Java 类库 Kryo 来取代 JDK 自带的序列化机制，已经在 Twitter、Groupon、Yahoo 以及多个著名开源项目（如 Hive、Storm）中广泛使用。以上，希望能帮助到大家。
5.9 序列接口Serializable对于 Java 的序列化，我之前一直停留在最浅层次的认知上——把那个要序列化的类实现 Serializbale 接口就可以了嘛。
我似乎不愿意做更深入的研究，因为会用就行了嘛。
但随着时间的推移，见到 Serializbale 的次数越来越多，我便对它产生了浓厚的兴趣。是时候花点时间研究研究了。
01、先来点理论 
Java 序列化是 JDK 1.1 时引入的一组开创性的特性，用于将 Java 对象转换为字节数组，便于存储或传输。此后，仍然可以将字节数组转换回 Java 对象原有的状态。
序列化的思想是“冻结”对象状态，然后写到磁盘或者在网络中传输；反序列化的思想是“解冻”对象状态，重新获得可用的 Java 象。
序列化有一条规则，就是要序列化的对象必须实现 Serializbale 接口，否则就会报 NotSerializableException 异常。
好，来看看 Serializbale 接口的定义吧：
12public interface Serializable {}
没别的了！
明明就一个空的接口嘛，竟然能够保证实现了它的“类对象”被序列化和反序列化？
02、再来点实战 
在回答上述问题之前，我们先来创建一个类（只有两个字段，和对应的 getter&#x2F;setter ），用于序列化和反序列化。
12345678910111213141516class Wanger {    private String name;    private int age;    public String getName() {        return name;    }    public void setName(String name) {        this.name &#x3D; name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age &#x3D; age;    }}
再来创建一个测试类，通过 ObjectOutputStream 将“18 岁的王二”写入到文件当中，实际上就是一种序列化的过程；再通过 ObjectInputStream 将“18 岁的王二”从文件中读出来，实际上就是一种反序列化的过程。（前面我们学习序列流的时候也讲过）
1234567891011121314151617181920&#x2F;&#x2F; 初始化Wanger wanger &#x3D; new Wanger();wanger.setName(&quot;王二&quot;);wanger.setAge(18);System.out.println(wanger);&#x2F;&#x2F; 把对象写到文件中try (ObjectOutputStream oos &#x3D; new ObjectOutputStream(new FileOutputStream(&quot;chenmo&quot;));){    oos.writeObject(wanger);} catch (IOException e) {    e.printStackTrace();}&#x2F;&#x2F; 从文件中读出对象try (ObjectInputStream ois &#x3D; new ObjectInputStream(new FileInputStream(new File(&quot;chenmo&quot;)));){    Wanger wanger1 &#x3D; (Wanger) ois.readObject();    System.out.println(wanger1);} catch (IOException | ClassNotFoundException e) {    e.printStackTrace();}
不过，由于 Wanger 没有实现 Serializbale 接口，所以在运行测试类的时候会抛出异常，堆栈信息如下：
1234java.io.NotSerializableException: com.cmower.java_demo.xuliehua.Wanger    at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1184)    at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:348)    at com.cmower.java_demo.xuliehua.Test.main(Test.java:21)
顺着堆栈信息，我们来看一下 ObjectOutputStream 的 writeObject0() 方法。其部分源码如下：
12345678910111213141516171819202122232425&#x2F;&#x2F; 判断对象是否为字符串类型，如果是，则调用 writeString 方法进行序列化if (obj instanceof String) {    writeString((String) obj, unshared);}&#x2F;&#x2F; 判断对象是否为数组类型，如果是，则调用 writeArray 方法进行序列化else if (cl.isArray()) {    writeArray(obj, desc, unshared);}&#x2F;&#x2F; 判断对象是否为枚举类型，如果是，则调用 writeEnum 方法进行序列化else if (obj instanceof Enum) {    writeEnum((Enum&lt;?&gt;) obj, desc, unshared);}&#x2F;&#x2F; 判断对象是否为可序列化类型，如果是，则调用 writeOrdinaryObject 方法进行序列化else if (obj instanceof Serializable) {    writeOrdinaryObject(obj, desc, unshared);}&#x2F;&#x2F; 如果对象不能被序列化，则抛出 NotSerializableException 异常else {if (extendedDebugInfo) {    throw new NotSerializableException(        cl.getName() + &quot;\n&quot; + debugInfoStack.toString());} else {    throw new NotSerializableException(cl.getName());}}
也就是说， ObjectOutputStream 在序列化的时候，会判断被序列化的对象是哪一种类型，字符串？数组？枚举？还是 Serializable ，如果全都不是的话，抛出 NotSerializableException 。
假如 Wanger 实现了 Serializable 接口，就可以序列化和反序列化了。
123456class Wanger implements Serializable{    private static final long serialVersionUID &#x3D; -2095916884810199532L;        private String name;    private int age;}
具体怎么序列化呢？
以 ObjectOutputStream 为例吧，它在序列化的时候会依次调用 writeObject() → writeObject0() → writeOrdinaryObject() → writeSerialData() → invokeWriteObject() → defaultWriteFields() 。
1234567891011121314151617181920212223242526272829private void defaultWriteFields(Object obj, ObjectStreamClass desc) throws IOException {    &#x2F;&#x2F; 获取对象的类，并检查是否可以进行默认的序列化    Class&lt;?&gt; cl &#x3D; desc.forClass();    desc.checkDefaultSerialize();    &#x2F;&#x2F; 获取对象的基本类型字段的数量，以及这些字段的值    int primDataSize &#x3D; desc.getPrimDataSize();    desc.getPrimFieldValues(obj, primVals);    &#x2F;&#x2F; 将基本类型字段的值写入输出流    bout.write(primVals, 0, primDataSize, false);    &#x2F;&#x2F; 获取对象的非基本类型字段的值    ObjectStreamField[] fields &#x3D; desc.getFields(false);    Object[] objVals &#x3D; new Object[desc.getNumObjFields()];    int numPrimFields &#x3D; fields.length - objVals.length;    desc.getObjFieldValues(obj, objVals);    &#x2F;&#x2F; 循环写入对象的非基本类型字段的值    for (int i &#x3D; 0; i &lt; objVals.length; i++) {        &#x2F;&#x2F; 调用 writeObject0 方法将对象的非基本类型字段序列化写入输出流        try {            writeObject0(objVals[i], fields[numPrimFields + i].isUnshared());        }        &#x2F;&#x2F; 如果在写入过程中出现异常，则将异常包装成 IOException 抛出        catch (IOException ex) {            if (abortIOException &#x3D;&#x3D; null) {                abortIOException &#x3D; ex;            }        }    }}
那怎么反序列化呢？
以 ObjectInputStream 为例，它在反序列化的时候会依次调用 readObject() → readObject0() → readOrdinaryObject() → readSerialData() → defaultReadFields() 。
123456789101112131415161718192021222324252627282930313233343536373839private void defaultReadFields(Object obj, ObjectStreamClass desc) throws IOException {    &#x2F;&#x2F; 获取对象的类，并检查对象是否属于该类    Class&lt;?&gt; cl &#x3D; desc.forClass();    if (cl !&#x3D; null &amp;&amp; obj !&#x3D; null &amp;&amp; !cl.isInstance(obj)) {        throw new ClassCastException();    }    &#x2F;&#x2F; 获取对象的基本类型字段的数量和值    int primDataSize &#x3D; desc.getPrimDataSize();    if (primVals &#x3D;&#x3D; null || primVals.length &lt; primDataSize) {        primVals &#x3D; new byte[primDataSize];    }    &#x2F;&#x2F; 从输入流中读取基本类型字段的值，并存储在 primVals 数组中    bin.readFully(primVals, 0, primDataSize, false);    if (obj !&#x3D; null) {        &#x2F;&#x2F; 将 primVals 数组中的基本类型字段的值设置到对象的相应字段中        desc.setPrimFieldValues(obj, primVals);    }    &#x2F;&#x2F; 获取对象的非基本类型字段的数量和值    int objHandle &#x3D; passHandle;    ObjectStreamField[] fields &#x3D; desc.getFields(false);    Object[] objVals &#x3D; new Object[desc.getNumObjFields()];    int numPrimFields &#x3D; fields.length - objVals.length;    &#x2F;&#x2F; 循环读取对象的非基本类型字段的值    for (int i &#x3D; 0; i &lt; objVals.length; i++) {        &#x2F;&#x2F; 调用 readObject0 方法读取对象的非基本类型字段的值        ObjectStreamField f &#x3D; fields[numPrimFields + i];        objVals[i] &#x3D; readObject0(Object.class, f.isUnshared());        &#x2F;&#x2F; 如果该字段是一个引用字段，则将其标记为依赖该对象        if (f.getField() !&#x3D; null) {            handles.markDependency(objHandle, passHandle);        }    }    if (obj !&#x3D; null) {        &#x2F;&#x2F; 将 objVals 数组中的非基本类型字段的值设置到对象的相应字段中        desc.setObjFieldValues(obj, objVals);    }    passHandle &#x3D; objHandle;}
我想看到这，你应该会恍然大悟的“哦”一声了。 Serializable 接口之所以定义为空，是因为它只起到了一个标识的作用，告诉程序实现了它的对象是可以被序列化的，但真正序列化和反序列化的操作并不需要它来完成。
03、再来点注意事项 
开门见山的说吧， static 和 transient 修饰的字段是不会被序列化的。
为什么呢？我们先来证明，再来解释原因。
首先，在 Wanger 类中增加两个字段。
123456789101112class Wanger implements Serializable {    private static final long serialVersionUID &#x3D; -2095916884810199532L;    private String name;    private int age;    public static String pre &#x3D; &quot;沉默&quot;;    transient String meizi &#x3D; &quot;王三&quot;;    @Override    public String toString() {        return &quot;Wanger{&quot; + &quot;name&#x3D;&quot; + name + &quot;,age&#x3D;&quot; + age + &quot;,pre&#x3D;&quot; + pre + &quot;,meizi&#x3D;&quot; + meizi + &quot;}&quot;;    }}
其次，在测试类中打印序列化前和反序列化后的对象，并在序列化后和反序列化前改变 static 字段的值。
具体代码如下：
1234567891011121314151617181920212223&#x2F;&#x2F; 初始化Wanger wanger &#x3D; new Wanger();wanger.setName(&quot;王二&quot;);wanger.setAge(18);System.out.println(wanger);&#x2F;&#x2F; 把对象写到文件中try (ObjectOutputStream oos &#x3D; new ObjectOutputStream(new FileOutputStream(&quot;chenmo&quot;));){        oos.writeObject(wanger);    } catch (IOException e) {        e.printStackTrace();    }       &#x2F;&#x2F; 改变 static 字段的值Wanger.pre &#x3D;&quot;不沉默&quot;;&#x2F;&#x2F; 从文件中读出对象try (ObjectInputStream ois &#x3D; new ObjectInputStream(new FileInputStream(new File(&quot;chenmo&quot;)));){    Wanger wanger1 &#x3D; (Wanger) ois.readObject();    System.out.println(wanger1);} catch (IOException | ClassNotFoundException e) {    e.printStackTrace();}
输出结果：
12Wanger{name&#x3D;王二,age&#x3D;18,pre&#x3D;沉默,meizi&#x3D;王三}Wanger{name&#x3D;王二,age&#x3D;18,pre&#x3D;不沉默,meizi&#x3D;null}
从结果的对比当中，我们可以发现：
1）序列化前， pre 的值为“沉默”，序列化后， pre 的值修改为“不沉默”，反序列化后， pre 的值为“不沉默”，而不是序列化前的状态“沉默”。
为什么呢？因为序列化保存的是对象的状态，而 static 修饰的字段属于类的状态，因此可以证明序列化并不保存 static 修饰的字段。
2）序列化前， meizi 的值为“王三”，反序列化后， meizi 的值为 null ，而不是序列化前的状态“王三”。
为什么呢？ transient 的中文字义为“临时的”（论英语的重要性），它可以阻止字段被序列化到文件中，在被反序列化后， transient 字段的值被设为初始值，比如 int 型的初始值为 0，对象型的初始值为 null 。
如果想要深究源码的话，你可以在 ObjectStreamClass 中发现下面这样的代码：
12345678910111213141516171819202122private static ObjectStreamField[] getDefaultSerialFields(Class&lt;?&gt; cl) {    &#x2F;&#x2F; 获取该类中声明的所有字段    Field[] clFields &#x3D; cl.getDeclaredFields();    ArrayList&lt;ObjectStreamField&gt; list &#x3D; new ArrayList&lt;&gt;();    int mask &#x3D; Modifier.STATIC | Modifier.TRANSIENT;    &#x2F;&#x2F; 遍历所有字段，将非 static 和 transient 的字段添加到 list 中    for (int i &#x3D; 0; i &lt; clFields.length; i++) {        Field field &#x3D; clFields[i];        int mods &#x3D; field.getModifiers();        if ((mods &amp; mask) &#x3D;&#x3D; 0) {            &#x2F;&#x2F; 根据字段名、字段类型和字段是否可序列化创建一个 ObjectStreamField 对象            ObjectStreamField osf &#x3D; new ObjectStreamField(field.getName(), field.getType(), !Serializable.class.isAssignableFrom(cl));            list.add(osf);        }    }    int size &#x3D; list.size();    &#x2F;&#x2F; 如果 list 为空，则返回一个空的 ObjectStreamField 数组，否则将 list 转换为 ObjectStreamField 数组并返回    return (size &#x3D;&#x3D; 0) ? NO_FIELDS :        list.toArray(new ObjectStreamField[size]);}
看到 Modifier.STATIC | Modifier.TRANSIENT 了吧，这两个修饰符标记的字段就没有被放入到序列化的字段中，明白了吧？
04、再来点干货 
除了 Serializable 之外，Java 还提供了一个序列化接口 Externalizable （念起来有点拗口）。
两个接口有什么不一样的吗？试一试就知道了。
首先，把 Wanger 类实现的接口  Serializable 替换为 Externalizable 。
123456789101112131415161718192021class Wanger implements Externalizable {    private String name;    private int age;    public Wanger() {    }    public String getName() {        return name;    }        @Override    public String toString() {        return &quot;Wanger{&quot; + &quot;name&#x3D;&quot; + name + &quot;,age&#x3D;&quot; + age + &quot;}&quot;;    }    @Override    public void writeExternal(ObjectOutput out) throws IOException {    }    @Override    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {    }}
实现 Externalizable 接口的 Wanger 类和实现 Serializable 接口的 Wanger 类有一些不同：
1）新增了一个无参的构造方法。
使用 Externalizable 进行反序列化的时候，会调用被序列化类的无参构造方法去创建一个新的对象，然后再将被保存对象的字段值复制过去。否则的话，会抛出以下异常：
12345678910java.io.InvalidClassException: com.cmower.java_demo.xuliehua1.Wanger; no valid constructor    at java.io.ObjectStreamClass$ExceptionInfo.newInvalidClassException(ObjectStreamClass.java:150)    at java.io.ObjectStreamClass.checkDeserialize(ObjectStreamClass.java:790)    at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:1782)    at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1353)    at java.io.ObjectInputStream.readObject(ObjectInputStream.java:373)    at com.cmower.java_demo.xuliehua1.Test.main(Test.java:27)
2）新增了两个方法 writeExternal() 和 readExternal() ，实现 Externalizable 接口所必须的。
然后，我们再在测试类中打印序列化前和反序列化后的对象。
12345678910111213141516171819202122&#x2F;&#x2F; 初始化Wanger wanger &#x3D; new Wanger();wanger.setName(&quot;王二&quot;);wanger.setAge(18);System.out.println(wanger);&#x2F;&#x2F; 把对象写到文件中try (ObjectOutputStream oos &#x3D; new ObjectOutputStream(new FileOutputStream(&quot;chenmo&quot;));) {    oos.writeObject(wanger);} catch (IOException e) {    e.printStackTrace();}&#x2F;&#x2F; 从文件中读出对象try (ObjectInputStream ois &#x3D; new ObjectInputStream(new FileInputStream(new File(&quot;chenmo&quot;)));) {    Wanger wanger1 &#x3D; (Wanger) ois.readObject();    System.out.println(wanger1);} catch (IOException | ClassNotFoundException e) {    e.printStackTrace();}&#x2F;&#x2F; Wanger{name&#x3D;王二,age&#x3D;18}&#x2F;&#x2F; Wanger{name&#x3D;null,age&#x3D;0}
从输出的结果看，反序列化后得到的对象字段都变成了默认值，也就是说，序列化之前的对象状态没有被“冻结”下来。
为什么呢？因为我们没有为 Wanger 类重写具体的 writeExternal() 和 readExternal() 方法。那该怎么重写呢？
1234567891011@Overridepublic void writeExternal(ObjectOutput out) throws IOException {    out.writeObject(name);    out.writeInt(age);}@Overridepublic void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {    name &#x3D; (String) in.readObject();    age &#x3D; in.readInt();}
1）调用 ObjectOutput 的 writeObject() 方法将字符串类型的 name 写入到输出流中；
2）调用 ObjectOutput 的 writeInt() 方法将整型的 age 写入到输出流中；
3）调用 ObjectInput 的 readObject() 方法将字符串类型的 name 读入到输入流中；
4）调用 ObjectInput 的 readInt() 方法将字符串类型的 age 读入到输入流中；
再运行一次测试了类，你会发现对象可以正常地序列化和反序列化了。

序列化前：Wanger{name&#x3D;王二,age&#x3D;18} 
序列化后：Wanger{name&#x3D;王二,age&#x3D;18}

总结一下：
Externalizable 和 Serializable 都是用于实现 Java 对象的序列化和反序列化的接口，但是它们有以下区别：
①、Serializable 是 Java 标准库提供的接口，而 Externalizable 是 Serializable 的子接口；

②、Serializable 接口不需要实现任何方法，只需要将需要序列化的类标记为 Serializable 即可，而 Externalizable 接口需要实现 writeExternal 和 readExternal 两个方法；
③、Externalizable 接口提供了更高的序列化控制能力，可以在序列化和反序列化过程中对对象进行自定义的处理，如对一些敏感信息进行加密和解密。
05、再来点甜点 
让我先问问你吧，你知道 private static final long serialVersionUID &#x3D; -2095916884810199532L; 这段代码的作用吗？
嗯……
serialVersionUID 被称为序列化 ID，它是决定 Java 对象能否反序列化成功的重要因子。在反序列化时，Java 虚拟机会把字节流中的 serialVersionUID 与被序列化类中的 serialVersionUID 进行比较，如果相同则可以进行反序列化，否则就会抛出序列化版本不一致的异常。
当一个类实现了 Serializable 接口后，IDE 就会提醒该类最好产生一个序列化 ID，就像下面这样：

1）添加一个默认版本的序列化 ID：
1private static final long serialVersionUID &#x3D; 1L。
2）添加一个随机生成的不重复的序列化 ID。
1private static final long serialVersionUID &#x3D; -2095916884810199532L;
3）添加 @SuppressWarnings 注解。
1@SuppressWarnings(&quot;serial&quot;)
怎么选择呢？
首先，我们采用第二种办法，在被序列化类中添加一个随机生成的序列化 ID。
1234567class Wanger implements Serializable {    private static final long serialVersionUID &#x3D; -2095916884810199532L;        private String name;    private int age;    &#x2F;&#x2F; 其他代码忽略}
然后，序列化一个 Wanger 对象到文件中。
123456789101112&#x2F;&#x2F; 初始化Wanger wanger &#x3D; new Wanger();wanger.setName(&quot;王二&quot;);wanger.setAge(18);System.out.println(wanger);&#x2F;&#x2F; 把对象写到文件中try (ObjectOutputStream oos &#x3D; new ObjectOutputStream(new FileOutputStream(&quot;chenmo&quot;));) {    oos.writeObject(wanger);} catch (IOException e) {    e.printStackTrace();}
这时候，我们悄悄地把 Wanger 类的序列化 ID 偷梁换柱一下，嘿嘿。
12&#x2F;&#x2F; private static final long serialVersionUID &#x3D; -2095916884810199532L;private static final long serialVersionUID &#x3D; -2095916884810199533L;
好了，准备反序列化吧。
1234567try (ObjectInputStream ois &#x3D; new ObjectInputStream(new FileInputStream(new File(&quot;chenmo&quot;)));) {    Wanger wanger &#x3D; (Wanger) ois.readObject();    System.out.println(wanger);} catch (IOException | ClassNotFoundException e) {    e.printStackTrace();}
哎呀，出错了。
12345java.io.InvalidClassException:  local class incompatible: stream classdesc serialVersionUID &#x3D; -2095916884810199532,local class serialVersionUID &#x3D; -2095916884810199533    at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1521)    at com.cmower.java_demo.xuliehua1.Test.main(Test.java:27)
异常堆栈信息里面告诉我们，从持久化文件里面读取到的序列化 ID 和本地的序列化 ID 不一致，无法反序列化。
那假如我们采用第三种方法，为 Wanger 类添加个 @SuppressWarnings(“serial”) 注解呢？
1234@SuppressWarnings(&quot;serial&quot;)class Wanger implements Serializable {&#x2F;&#x2F; 省略其他代码}
好了，再来一次反序列化吧。可惜依然报错。
12345java.io.InvalidClassException:  local class incompatible: stream classdesc serialVersionUID &#x3D; -2095916884810199532, local class serialVersionUID &#x3D; -3818877437117647968    at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1521)    at com.cmower.java_demo.xuliehua1.Test.main(Test.java:27)
异常堆栈信息里面告诉我们，本地的序列化 ID 为 -3818877437117647968，和持久化文件里面读取到的序列化 ID 仍然不一致，无法反序列化。这说明什么呢？使用 @SuppressWarnings(“serial”) 注解时，该注解会为被序列化类自动生成一个随机的序列化 ID。
由此可以证明，Java 虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，还有一个非常重要的因素就是序列化 ID 是否一致。
也就是说，如果没有特殊需求，采用默认的序列化 ID（1L）就可以，这样可以确保代码一致时反序列化成功。
06、再来点总结 
写这篇文章之前，我真没想到：“空空其身”的 Serializable 竟然有这么多可以研究的内容！
写完这篇文章之后，我不由得想起理科状元曹林菁说说过的一句话：“在学习中再小的问题也不放过，每个知识点都要总结”——说得真真真真的对啊！
5.10 transient关键字害，小二最熟的是 Java，但很多 Java 基础知识都不知道，比如 transient 关键字以前就没用到过，所以不知道它的作用是什么，今天去招银面试的时候，面试官问到了这个：说说 Java 的 transient 关键字吧，结果小二直接懵逼了。
下面是他自己面试凉了以后回去做的总结，分享出来，大家一起涨下姿势~~~好了，废话不多说，下面开始：
01、transient 的作用及使用方法 
我们知道，一个对象只要实现了 Serilizable 接口，它就可以被序列化。
在实际开发过程中，我们常常会遇到这样的问题，一个类的有些字段需要序列化，有些字段不需要，比如说用户的一些敏感信息（如密码、银行卡号等），为了安全起见，不希望在网络操作中传输或者持久化到磁盘文件中，那这些字段就可以加上 transient 关键字。
需要注意的是，被 transient 关键字修饰的成员变量在反序列化时会被自动初始化为默认值，例如基本数据类型为 0，引用类型为 null。
来看示例：
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class TransientTest {    public static void main(String[] args) {                User user &#x3D; new User();        user.setUsername(&quot;沉默王二&quot;);        user.setPasswd(&quot;123456&quot;);                System.out.println(&quot;read before Serializable: &quot;);        System.out.println(&quot;username: &quot; + user.getUsername());        System.err.println(&quot;password: &quot; + user.getPasswd());                try {            ObjectOutputStream os &#x3D; new ObjectOutputStream(                    new FileOutputStream(&quot;user.txt&quot;));            os.writeObject(user); &#x2F;&#x2F; 将User对象写进文件            os.flush();            os.close();        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        }        try {            ObjectInputStream is &#x3D; new ObjectInputStream(new FileInputStream(                    &quot;user.txt&quot;));            user &#x3D; (User) is.readObject(); &#x2F;&#x2F; 从流中读取User的数据            is.close();                        System.out.println(&quot;\nread after Serializable: &quot;);            System.out.println(&quot;username: &quot; + user.getUsername());            System.err.println(&quot;password: &quot; + user.getPasswd());                    } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        } catch (ClassNotFoundException e) {            e.printStackTrace();        }    }}class User implements Serializable {    private static final long serialVersionUID &#x3D; 8294180014912103005L;          private String username;    private transient String passwd;        public String getUsername() {        return username;    }        public void setUsername(String username) {        this.username &#x3D; username;    }        public String getPasswd() {        return passwd;    }        public void setPasswd(String passwd) {        this.passwd &#x3D; passwd;    }}
输出为：
123456read before Serializable:username: 沉默王二password: 123456 read after Serializable:username: 沉默王二password: null
密码字段为 null，说明反序列化时根本没有从文件中获取到信息。
02、transient 使用小结 
1）一旦字段被 transient 修饰，成员变量将不再是对象持久化的一部分，该变量的值在序列化后无法访问。
2）transient 关键字只能修饰字段，而不能修饰方法和类。
3）被 transient 关键字修饰的字段不能被序列化，一个静态变量（static关键字修饰）不管是否被 transient 修饰，均不能被序列化，前面讲到过。
来看示例：
1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class TransientTest {    public static void main(String[] args) {                User user &#x3D; new User();        user.setUsername(&quot;沉默王二&quot;);        user.setPasswd(&quot;123456&quot;);                System.out.println(&quot;read before Serializable: &quot;);        System.out.println(&quot;username: &quot; + user.getUsername());        System.err.println(&quot;password: &quot; + user.getPasswd());                try {            ObjectOutputStream os &#x3D; new ObjectOutputStream(                    new FileOutputStream(&quot;user.txt&quot;));            os.writeObject(user); &#x2F;&#x2F; 将User对象写进文件            os.flush();            os.close();        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        }        try {            &#x2F;&#x2F; 在反序列化之前改变username的值            User.username &#x3D; &quot;沉默王三&quot;;                        ObjectInputStream is &#x3D; new ObjectInputStream(new FileInputStream(&quot;user.txt&quot;));            user &#x3D; (User) is.readObject(); &#x2F;&#x2F; 从流中读取User的数据            is.close();                        System.out.println(&quot;\nread after Serializable: &quot;);            System.out.println(&quot;username: &quot; + user.getUsername());            System.err.println(&quot;password: &quot; + user.getPasswd());                    } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        } catch (ClassNotFoundException e) {            e.printStackTrace();        }    }}class User implements Serializable {    private static final long serialVersionUID &#x3D; 8294180014912103005L;          public static String username;    private transient String passwd;        public String getUsername() {        return username;    }        public void setUsername(String username) {        this.username &#x3D; username;    }        public String getPasswd() {        return passwd;    }        public void setPasswd(String passwd) {        this.passwd &#x3D; passwd;    }}
运行结果为：
123456read before Serializable:username: 沉默王二password: 123456 read after Serializable:username: 沉默王三password: null
序列化前，static 修饰的 username 为 沉默王二，然后我们在反序列化前将其修改为 沉默王三 了，如果说 static 修饰的字段能保持状态的话，反序列化后应该是 沉默王二，对吧？
但结果是 沉默王三，这就证明了我们之前的结论：static 修饰的字段不能被序列化。
03、transient 修饰的字段真的不能被序列化？ 
思考下面的例子：
1234567891011121314151617181920212223242526public class ExternalizableTest implements Externalizable {    private transient String content &#x3D; &quot;是的，我将会被序列化，不管我是否被transient关键字修饰&quot;;    @Override    public void writeExternal(ObjectOutput out) throws IOException {        out.writeObject(content);    }    @Override    public void readExternal(ObjectInput in) throws IOException,            ClassNotFoundException {        content &#x3D; (String) in.readObject();    }    public static void main(String[] args) throws Exception {                ExternalizableTest et &#x3D; new ExternalizableTest();        ObjectOutput out &#x3D; new ObjectOutputStream(new FileOutputStream(                new File(&quot;test&quot;)));        out.writeObject(et);        ObjectInput in &#x3D; new ObjectInputStream(new FileInputStream(new File(                &quot;test&quot;)));        et &#x3D; (ExternalizableTest) in.readObject();        System.out.println(et.content);        out.close();        in.close();    }}
来看下输出结果：
1是的，我将会被序列化，不管我是否被transient关键字修饰
这是为什么呢？不是说 transient 关键字修饰的字段不能序列化吗？
我先说结论，这是因为我们使用了 Externalizable 接口而不是 Serializable接口，这个知识点我们前面其实也讲到过。
在 Java 中，对象的序列化可以通过实现两种接口来实现，如果实现的是 Serializable 接口，则所有的序列化将会自动进行，如果实现的是 Externalizable 接口，则需要在 writeExternal 方法中指定要序列化的字段，与 transient 关键字修饰无关。
因此例子输出的是变量 content 的内容，而不是 null。
04、小结 
transient 关键字用于修饰类的成员变量，在序列化对象时，被修饰的成员变量不会被序列化和保存到文件中。其作用是告诉 JVM 在序列化对象时不需要将该变量的值持久化，这样可以避免一些安全或者性能问题。但是，transient 修饰的成员变量在反序列化时会被初始化为其默认值（如 int 类型会被初始化为 0，引用类型会被初始化为 null），因此需要在程序中进行适当的处理。
transient 关键字和 static 关键字都可以用来修饰类的成员变量。其中，transient 关键字表示该成员变量不参与序列化和反序列化，而 static 关键字表示该成员变量是属于类的，不属于对象的，因此不需要序列化和反序列化。
在 Serializable 和 Externalizable 接口中，transient 关键字的表现也不同，在 Serializable 中表示该成员变量不参与序列化和反序列化，在 Externalizable 中不起作用，因为 Externalizable 接口需要实现 readExternal 和 writeExternal 方法，需要手动完成序列化和反序列化的过程。
6 异常处理6.1 Java异常处理全面解析01、什么是异常 
“二哥，今天就要学习异常了吗？”三妹问。
“是的。只有正确地处理好异常，才能保证程序的可靠性，所以异常的学习还是很有必要的。”我说。
“那到底什么是异常呢？”三妹问。
“异常是指中断程序正常执行的一个不确定的事件。当异常发生时，程序的正常执行流程就会被打断。一般情况下，程序都会有很多条语句，如果没有异常处理机制，前面的语句一旦出现了异常，后面的语句就没办法继续执行了。”
“有了异常处理机制后，程序在发生异常的时候就不会中断，我们可以对异常进行捕获，然后改变程序执行的流程。”
“除此之外，异常处理机制可以保证我们向用户提供友好的提示信息，而不是程序原生的异常信息——用户根本理解不了。”
“不过，站在开发者的角度，我们更希望看到原生的异常信息，因为这有助于我们更快地找到 bug 的根源，反而被过度包装的异常信息会干扰我们的视线。”
“Java 语言在一开始就提供了相对完善的异常处理机制，这种机制大大降低了编写可靠程序的门槛，这也是 Java 之所以能够流行的原因之一。”
“那导致程序抛出异常的原因有哪些呢？”三妹问。
比如说：

程序在试图打开一个不存在的文件；
程序遇到了网络连接问题；
用户输入了糟糕的数据；
程序在处理算术问题时没有考虑除数为 0 的情况；

等等等等。
挑个最简单的原因来说吧。
12345public class Demo {    public static void main(String[] args) {        System.out.println(10&#x2F;0);    }}
这段代码在运行的时候抛出的异常信息如下所示：
12Exception in thread &quot;main&quot; java.lang.ArithmeticException: &#x2F; by zero    at com.itwanger.s41.Demo.main(Demo.java:8)
“你看，三妹，这个原生的异常信息对用户来说，显然是不太容易理解的，但对于我们开发者来说，简直不要太直白了——很容易就能定位到异常发生的根源。”
02、Exception和Error的区别 
“哦，我知道了。下一个问题，我经常看到一些文章里提到 Exception 和 Error，二哥你能帮我解释一下它们之间的区别吗？”三妹问。
“这是一个好问题呀，三妹！”
从单词的释义上来看，error 为错误，exception 为异常，错误的等级明显比异常要高一些。
从程序的角度来看，也的确如此。
Error 的出现，意味着程序出现了严重的问题，而这些问题不应该再交给 Java 的异常处理机制来处理，程序应该直接崩溃掉，比如说 OutOfMemoryError，内存溢出了，这就意味着程序在运行时申请的内存大于系统能够提供的内存，导致出现的错误，这种错误的出现，对于程序来说是致命的。
Exception 的出现，意味着程序出现了一些在可控范围内的问题，我们应当采取措施进行挽救。
比如说之前提到的 ArithmeticException，很明显是因为除数出现了 0 的情况，我们可以选择捕获异常，然后提示用户不应该进行除 0 操作，当然了，更好的做法是直接对除数进行判断，如果是 0 就不进行除法运算，而是告诉用户换一个非 0 的数进行运算。
03、checked和unchecked异常 
“三妹，还能想到其他的问题吗？”
“嗯，不用想，二哥，我已经提前做好预习工作了。”三妹自信地说，“异常又可以分为 checked 和 unchecked，它们之间又有什么区别呢？”
“哇，三妹，果然又是一个好问题呢。”
checked 异常（检查型异常）在源代码里必须显式地捕获或者抛出，否则编译器会提示你进行相应的操作；而 unchecked 异常（非检查型异常）就是所谓的运行时异常，通常是可以通过编码进行规避的，并不需要显式地捕获或者抛出。
“我先画一幅思维导图给你感受一下。”

首先，Exception 和 Error 都继承了 Throwable 类。换句话说，只有 Throwable 类（或者子类）的对象才能使用 throw 关键字抛出，或者作为 catch 的参数类型。
面试中经常问到的一个问题是，NoClassDefFoundError 和 ClassNotFoundException 有什么区别？
“三妹你知道吗？”
“不知道，二哥，你解释下呗。”
它们都是由于系统运行时找不到要加载的类导致的，但是触发的原因不一样。

NoClassDefFoundError：程序在编译时可以找到所依赖的类，但是在运行时找不到指定的类文件，导致抛出该错误；原因可能是 jar 包缺失或者调用了初始化失败的类。
ClassNotFoundException：当动态加载 Class 对象的时候找不到对应的类时抛出该异常；原因可能是要加载的类不存在或者类名写错了。

其次，像 IOException、ClassNotFoundException、SQLException 都属于 checked 异常；像 RuntimeException 以及子类 ArithmeticException、ClassCastException、ArrayIndexOutOfBoundsException、NullPointerException，都属于 unchecked 异常。
unchecked 异常可以不在程序中显示处理，就像之前提到的 ArithmeticException 就是的；但 checked 异常必须显式处理。
比如说下面这行代码：
1Class clz &#x3D; Class.forName(&quot;com.itwanger.s41.Demo1&quot;);
如果没做处理，比如说在 Intellij IDEA 环境下，就会提示你这行代码可能会抛出 java.lang.ClassNotFoundException 。

建议你要么使用 try-catch 进行捕获：
12345try {    Class clz &#x3D; Class.forName(&quot;com.itwanger.s41.Demo1&quot;);} catch (ClassNotFoundException e) {    e.printStackTrace();}
注意打印异常堆栈信息的 printStackTrace() 方法，该方法会将异常的堆栈信息打印到标准的控制台下，如果是测试环境，这样的写法还 OK，如果是生产环境，这样的写法是不可取的，必须使用日志框架把异常的堆栈信息输出到日志系统中，否则可能没办法跟踪。
要么在方法签名上使用 throws 关键字抛出：
12345public class Demo1 {    public static void main(String[] args) throws ClassNotFoundException {        Class clz &#x3D; Class.forName(&quot;com.itwanger.s41.Demo1&quot;);    }}
这样做的好处是不需要对异常进行捕获处理，只需要交给 Java 虚拟机来处理即可；坏处就是没法针对这种情况做相应的处理。
“二哥，针对 checked 异常，我在知乎上看到一个帖子，说 Java 中的 checked 很没有必要，这种异常在编译期要么 try-catch，要么 throws，但又不一定会出现异常，你觉得这样的设计有意义吗？”三妹提出了一个很尖锐的问题。
“哇，这种问题问的好。”我不由得对三妹心生敬佩。
“的确，checked 异常在业界是有争论的，它假设我们捕获了异常，并且针对这种情况作了相应的处理，但有些时候，根本就没法处理。”我说，“就拿上面提到的 ClassNotFoundException 异常来说，我们假设对其进行了 try-catch，可真的出现了 ClassNotFoundException 异常后，我们也没多少的可操作性，再 Class.forName() 一次？”
另外，checked 异常也不兼容函数式编程，后面如果你写 Lambda&#x2F;Stream 代码的时候，就会体验到这种苦涩。
当然了，checked 异常并不是一无是处，尤其是在遇到 IO 或者网络异常的时候，比如说进行 Socket 链接，我大致写了一段：
123456789101112131415161718192021public class Demo2 {    private String mHost;    private int mPort;    private Socket mSocket;    private final Object mLock &#x3D; new Object();    public void run() {    }    private void initSocket() {        while (true) {            try {                Socket socket &#x3D; new Socket(mHost, mPort);                synchronized (mLock) {                    mSocket &#x3D; socket;                }                break;            } catch (IOException e) {                e.printStackTrace();            }        }    }}
当发生 IOException 的时候，socket 就重新尝试连接，否则就 break 跳出循环。意味着如果 IOException 不是 checked 异常，这种写法就略显突兀，因为 IOException 没办法像 ArithmeticException 那样用一个 if 语句判断除数是否为 0 去规避。
或者说，强制性的 checked 异常可以让我们在编程的时候去思考，遇到这种异常的时候该怎么更优雅的去处理。显然，Socket 编程中，肯定是会遇到 IOException 的，假如 IOException 是非检查型异常，就意味着开发者也可以不考虑，直接跳过，交给 Java 虚拟机来处理，但我觉得这样做肯定更不合适。
04、关于 throw 和 throws 
“二哥，你能告诉我 throw 和 throws 两个关键字的区别吗？”三妹问。
“throw 关键字，用于主动地抛出异常；正常情况下，当除数为 0 的时候，程序会主动抛出 ArithmeticException；但如果我们想要除数为 1 的时候也抛出 ArithmeticException，就可以使用 throw 关键字主动地抛出异常。”我说。
语法也非常简单，throw 关键字后跟上 new 关键字，以及异常的类型还有参数即可。
举个例子。
12345678910111213public class ThrowDemo {    static void checkEligibilty(int stuage){        if(stuage&lt;18) {            throw new ArithmeticException(&quot;年纪未满 18 岁，禁止观影&quot;);        } else {            System.out.println(&quot;请认真观影!!&quot;);        }    }    public static void main(String args[]){        checkEligibilty(10);        System.out.println(&quot;愉快地周末..&quot;);    }}
这段代码在运行的时候就会抛出以下错误：
123Exception in thread &quot;main&quot; java.lang.ArithmeticException: 年纪未满 18 岁，禁止观影    at com.itwanger.s43.ThrowDemo.checkEligibilty(ThrowDemo.java:9)    at com.itwanger.s43.ThrowDemo.main(ThrowDemo.java:16)
“throws 关键字的作用就和 throw 完全不同。”我说，“前面的小节里已经讲了 checked exception 和 unchecked exception，也就是检查型异常和非检查型异常；对于检查型异常来说，如果你没有做处理，编译器就会提示你。”
Class.forName() 方法在执行的时候可能会遇到 java.lang.ClassNotFoundException 异常，一个检查型异常，如果没有做处理，IDEA 就会提示你，要么在方法签名上声明，要么放在 try-catch 中。

“那什么情况下使用 throws 而不是 try-catch 呢？”三妹问。
“假设现在有这么一个方法 myMethod() ，可能会出现 ArithmeticException 异常，也可能会出现 NullPointerException。这种情况下，可以使用 try-catch 来处理。”我回答。
123456789public void myMethod() {    try {        &#x2F;&#x2F; 可能抛出异常     } catch (ArithmeticException e) {        &#x2F;&#x2F; 算术异常    } catch (NullPointerException e) {        &#x2F;&#x2F; 空指针异常    }}
“但假设有好几个类似 myMethod() 的方法，如果为每个方法都加上 try-catch，就会显得非常繁琐。代码就会变得又臭又长，可读性就差了。”我继续说。
“一个解决办法就是，使用 throws 关键字，在方法签名上声明可能会抛出的异常，然后在调用该方法的地方使用 try-catch 进行理。”
123456789101112public static void main(String args[]){    try {        myMethod1();    } catch (ArithmeticException e) {        &#x2F;&#x2F; 算术异常    } catch (NullPointerException e) {        &#x2F;&#x2F; 空指针异常    }}public static void myMethod1() throws ArithmeticException, NullPointerException{    &#x2F;&#x2F; 方法签名上声明异常}
“好了，我来总结下 throw 和 throws 的区别，三妹，你记一下。”
 1）throws 关键字用于声明异常，它的作用和 try-catch 相似；而 throw 关键字用于显式的抛出异常。
2）throws 关键字后面跟的是异常的名字；而 throw 关键字后面跟的是异常的对象。
示例。
1throws ArithmeticException;
1throw new ArithmeticException(&quot;算术异常&quot;);
3）throws 关键字出现在方法签名上，而 throw 关键字出现在方法体里。
4）throws 关键字在声明异常的时候可以跟多个，用逗号隔开；而 throw 关键字每次只能抛出一个异常。
05、关于 try-catch-finally 
“二哥，之前你讲了异常处理机制，这一节讲什么呢？”三妹问。
“该讲 try-catch-finally 了。”我说，“try 关键字后面会跟一个大括号 {} ，我们把一些可能发生异常的代码放到大括号里； try 块后面一般会跟 catch 块，用来处理发生异常的情况；当然了，异常不一定会发生，为了保证发不发生异常都能执行一些代码，就会跟一个 finally 块。”
“具体该怎么用呀，二哥？”三妹问。
“别担心，三妹，我一一来说明下。”我说。
try 块的语法很简单：
123try{&#x2F;&#x2F; 可能发生异常的代码}
“注意啊，三妹，如果一些代码确定不会抛出异常，就尽量不要把它包裹在 try 块里，因为加了异常处理的代码执行起来要比没有加的花费更多的时间。”
catch 块的语法也很简单：
12345try{&#x2F;&#x2F; 可能发生异常的代码}catch (exception(type) e(object)){&#x2F;&#x2F; 异常处理代码}
一个 try 块后面可以跟多个 catch 块，用来捕获不同类型的异常并做相应的处理，当 try 块中的某一行代码发生异常时，之后的代码就不再执行，而是会跳转到异常对应的 catch 块中执行。
如果一个 try 块后面跟了多个与之关联的 catch 块，那么应该把特定的异常放在前面，通用型的异常放在后面，不然编译器会提示错误。举例来说。
12345678910111213141516static void test() {    int num1, num2;    try {        num1 &#x3D; 0;        num2 &#x3D; 62 &#x2F; num1;        System.out.println(num2);        System.out.println(&quot;try 块的最后一句&quot;);    } catch (ArithmeticException e) {        &#x2F;&#x2F; 算术运算发生时跳转到这里        System.out.println(&quot;除数不能为零&quot;);    } catch (Exception e) {        &#x2F;&#x2F; 通用型的异常意味着可以捕获所有的异常，它应该放在最后面，        System.out.println(&quot;异常发生了&quot;);    }    System.out.println(&quot;try-catch 之外的代码.&quot;);}
“为什么 Exception 不能放到 ArithmeticException 前面呢？”三妹问。
“因为 ArithmeticException 是 Exception 的子类，它更具体，我们看到就这个异常就知道是发生了算术错误，而 Exception 比较泛，它隐藏了具体的异常信息，我们看到后并不确定到底是发生了哪一种类型的异常，对错误的排查很不利。”我说，“再者，如果把通用型的异常放在前面，就意味着其他的 catch 块永远也不会执行，所以编译器就直接提示错误了。”
“再给你举个例子，注意看，三妹。”
1234567891011121314static void test1 () {    try{        int arr[]&#x3D;new int[7];        arr[4]&#x3D;30&#x2F;0;        System.out.println(&quot;try 块的最后&quot;);    } catch(ArithmeticException e){        System.out.println(&quot;除数必须是 0&quot;);    } catch(ArrayIndexOutOfBoundsException e){        System.out.println(&quot;数组越界了&quot;);    } catch(Exception e){        System.out.println(&quot;一些其他的异常&quot;);    }    System.out.println(&quot;try-catch 之外&quot;);}
这段代码在执行的时候，第一个 catch 块会执行，因为除数为零；我再来稍微改动下代码。
1234567891011121314static void test1 () {    try{        int arr[]&#x3D;new int[7];        arr[9]&#x3D;30&#x2F;1;        System.out.println(&quot;try 块的最后&quot;);    } catch(ArithmeticException e){        System.out.println(&quot;除数必须是 0&quot;);    } catch(ArrayIndexOutOfBoundsException e){        System.out.println(&quot;数组越界了&quot;);    } catch(Exception e){        System.out.println(&quot;一些其他的异常&quot;);    }    System.out.println(&quot;try-catch 之外&quot;);}
“我知道，二哥，第二个 catch 块会执行，因为没有发生算术异常，但数组越界了。”三妹没等我把代码运行起来就说出了答案。
“三妹，你说得很对，我再来改一下代码。”
12345678910static void test1 () {    try{        int arr[]&#x3D;new int[7];        arr[9]&#x3D;30&#x2F;1;        System.out.println(&quot;try 块的最后&quot;);    } catch(ArithmeticException | ArrayIndexOutOfBoundsException e){        System.out.println(&quot;除数必须是 0&quot;);    }    System.out.println(&quot;try-catch 之外&quot;);}
“当有多个 catch 的时候，也可以放在一起，用竖划线 | 隔开，就像上面这样。”我说。
“这样不错呀，看起来更简洁了。”三妹说。
finally 块的语法也不复杂。
1234567try {    &#x2F;&#x2F; 可能发生异常的代码}catch {   &#x2F;&#x2F; 异常处理}finally {   &#x2F;&#x2F; 必须执行的代码}
在没有 try-with-resources 之前，finally 块常用来关闭一些连接资源，比如说 socket、数据库链接、IO 输入输出流等。
12345678OutputStream osf &#x3D; new FileOutputStream( &quot;filename&quot; );OutputStream osb &#x3D; new BufferedOutputStream(opf);ObjectOutput op &#x3D; new ObjectOutputStream(osb);try{    output.writeObject(writableObject);} finally{    op.close();}
“三妹，注意，使用 finally 块的时候需要遵守这些规则。”

finally 块前面必须有 try 块，不要把 finally 块单独拉出来使用。编译器也不允许这样做。
finally 块不是必选项，有 try 块的时候不一定要有 finally 块。
如果 finally 块中的代码可能会发生异常，也应该使用 try-catch 进行包裹。
即便是 try 块中执行了 return、break、continue 这些跳转语句，finally 块也会被执行。

“真的吗，二哥？”三妹对最后一个规则充满了疑惑。
“来试一下就知道了。”我说。
12345678static int test2 () {    try {        return 112;    }    finally {        System.out.println(&quot;即使 try 块有 return，finally 块也会执行&quot;);    }}
来看一下输出结果：
1即使 try 块有 return，finally 块也会执行
“那，会不会有不执行 finally 的情况呀？”三妹很好奇。
“有的。”我斩钉截铁地回答。

遇到了死循环。
执行了 System. exit() 这行代码。

System.exit() 和 return 语句不同，前者是用来退出程序的，后者只是回到了上一级方法调用。
“三妹，来看一下源码的文档注释就全明白了！”

至于参数 status 的值也很好理解，如果是异常退出，设置为非 0 即可，通常用 1 来表示；如果是想正常退出程序，用 0 表示即可。
06、小结 
Java 的异常处理是一种重要的机制，可以帮助我们处理程序执行期间发生的错误 或异常。
异常分为两类：Checked Exception 和 Unchecked Exception，其中 Checked Exception 需要在代码中显式地处理或声明抛出，而 Unchecked Exception 不需要在代码中显式地处理或声明抛出。异常处理通常使用 try-catch-finally 块来处理，也可以使用 throws 关键字将异常抛出给调用者处理。
下面是 Java 异常处理的一些总结：

使用 try-catch 块捕获并处理异常，可以避免程序因异常而崩溃。
可以使用多个 catch 块来捕获不同类型的异常，并进行不同的处理。
可以使用 finally 块来执行一些必要的清理工作，无论是否发生异常都会执行。
可以使用 throw 关键字手动抛出异常，用于在程序中明确指定某些异常情况。
可以使用 throws 关键字将异常抛出给调用者处理，用于在方法签名中声明可能会出现的异常。
Checked Exception 通常是由于外部因素导致的问题，需要在代码中显式地处理或声明抛出。
Unchecked Exception 通常是由于程序内部逻辑或数据异常导致的，可以不处理或者在需要时进行处理。
在处理异常时，应该根据具体的异常类型进行处理，例如可以尝试重新打开文件、重新建立网络连接等操作。
异常处理应该根据具体的业务需求和设计原则进行，避免过度捕获和处理异常，从而降低程序的性能和可维护性。

6.2 try-with-resources“二哥，终于等到你讲 try-with-resources 了！”三妹夸张的表情让我有些吃惊。
“三妹，不要激动呀！开讲之前，我们还是要来回顾一下 try–catch-finally，好做个铺垫。”我说，“来看看这段代码吧。”
123456789101112131415161718192021222324public class TrycatchfinallyDecoder {    public static void main(String[] args) {        BufferedReader br &#x3D; null;        try {            String path &#x3D; TrycatchfinallyDecoder.class.getResource(&quot;&#x2F;牛逼.txt&quot;).getFile();            String decodePath &#x3D; URLDecoder.decode(path,&quot;utf-8&quot;);            br &#x3D; new BufferedReader(new FileReader(decodePath));            String str &#x3D; null;            while ((str &#x3D;br.readLine()) !&#x3D; null) {                System.out.println(str);            }        } catch (IOException e) {            e.printStackTrace();        } finally {            if (br !&#x3D; null) {                try {                    br.close();                } catch (IOException e) {                    e.printStackTrace();                }            }        }    }}
“我简单来解释下。”等三妹看完这段代码后，我继续说，“在 try 块中读取文件中的内容，并一行一行地打印到控制台。如果文件找不到或者出现 IO 读写错误，就在 catch 中捕获并打印错误的堆栈信息。最后，在 finally 中关闭缓冲字符读取器对象 BufferedReader，有效杜绝了资源未被关闭的情况下造成的严重性能后果。”
“在 Java 7 之前，try–catch-finally 的确是确保资源会被及时关闭的最佳方法，无论程序是否会抛出异常。”
三妹点了点头，表示同意。
“不过，这段代码还是有些臃肿，尤其是 finally 中的代码。”我说，“况且，try–catch-finally 至始至终存在一个严重的隐患：try 中的 br.readLine() 有可能会抛出 IOException ，finally 中的 br.close() 也有可能会抛出 IOException 。假如两处都不幸地抛出了 IOException，那程序的调试任务就变得复杂了起来，到底是哪一处出了错误，就需要花一番功夫，这是我们不愿意看到的结果。”
“我来给你演示下，三妹。”
“首先，我们来定义这样一个类 MyfinallyReadLineThrow，它有两个方法，分别是 readLine() 和 close() ，方法体都是主动抛出异常。”
12345678class MyfinallyReadLineThrow {    public void close() throws Exception {        throw new Exception(&quot;close&quot;);    }    public void readLine() throws Exception {        throw new Exception(&quot;readLine&quot;);    }}
“然后在 main() 方法中使用 try-catch-finally 的方式调用 MyfinallyReadLineThrow 的 readLine() 和 close() 方法。”
1234567891011public class TryfinallyCustomReadLineThrow {    public static void main(String[] args) throws Exception {        MyfinallyReadLineThrow myThrow &#x3D; null;        try {            myThrow &#x3D; new MyfinallyReadLineThrow();            myThrow.readLine();        } finally {            myThrow.close();        }    }}
运行上述代码后，错误堆栈如下所示：
1234567Exception in thread &quot;main&quot; java.lang.Exception: close    at com.cmower.dzone.trycatchfinally.MyfinallyOutThrow.close(TryfinallyCustomOutThrow.java:17)    at com.cmower.dzone.trycatchfinally.TryfinallyCustomOutThrow.main(TryfinallyCustomOutThrow.java:10)
“看出来问题了吗，三妹？”
“啊？ readLine() 方法的异常信息竟然被 close() 方法的堆栈信息吃了！”
“不错啊，三妹，火眼金睛，的确，这会让我们误以为要调查的目标是 close() 方法而不是 readLine() 方法——尽管它也是应该怀疑的对象。”
“但有了 try-with-resources 后，这些问题就迎刃而解了。前提条件只有一个，就是需要释放的资源（比如 BufferedReader）实现了 AutoCloseable 接口。”
12345678try (BufferedReader br &#x3D; new BufferedReader(new FileReader(decodePath));) {    String str &#x3D; null;    while ((str &#x3D;br.readLine()) !&#x3D; null) {        System.out.println(str);    }} catch (IOException e) {    e.printStackTrace();}
“你瞧，三妹，finally 块消失了，取而代之的是把要释放的资源写在 try 后的 () 中。如果有多个资源（BufferedReader 和 PrintWriter）需要释放的话，可以直接在 () 中添加。”
123456789try (BufferedReader br &#x3D; new BufferedReader(new FileReader(decodePath));     PrintWriter writer &#x3D; new PrintWriter(new File(writePath))) {    String str &#x3D; null;    while ((str &#x3D;br.readLine()) !&#x3D; null) {        writer.print(str);    }} catch (IOException e) {    e.printStackTrace();}
“如果想释放自定义资源的话，只要让它实现 AutoCloseable 接口，并提供 close() 方法即可。”
1234567891011121314public class TrywithresourcesCustom {    public static void main(String[] args) {        try (MyResource resource &#x3D; new MyResource();) {        } catch (Exception e) {            e.printStackTrace();        }    }}class MyResource implements AutoCloseable {    @Override    public void close() throws Exception {        System.out.println(&quot;关闭自定义资源&quot;);    }}
来看一下代码运行后的输出结果：
1关闭自定义资源
“好神奇呀！”三妹欣喜若狂，“在 try () 中只是 new 了一个 MyResource 的对象，其他什么也没干，close() 方法就执行了！”
“想知道为什么吗？三妹。”
“当然想啊。”
“来看看反编译后的字节码吧。”
12345678910111213141516171819class MyResource implements AutoCloseable {    MyResource() {    }    public void close() throws Exception {        System.out.println(&quot;关闭自定义资源&quot;);    }}public class TrywithresourcesCustom {    public TrywithresourcesCustom() {    }    public static void main(String[] args) {        try {            MyResource resource &#x3D; new MyResource();            resource.close();        } catch (Exception var2) {            var2.printStackTrace();        }    }}
“啊，原来如此。编译器主动为 try-with-resources 进行了变身，在 try 中调用了 close() 方法。”
“是这样的。接下来，我们在 MyResourceOut 类中再添加一个 out() 方法。”
123456789class MyResourceOut implements AutoCloseable {    @Override    public void close() throws Exception {        System.out.println(&quot;关闭自定义资源&quot;);    }    public void out() throws Exception{        System.out.println(&quot;沉默王二，一枚有趣的程序员&quot;);    }}
“这次，我们在 try 中调用一下 out() 方法。”
123456789public class TrywithresourcesCustomOut {    public static void main(String[] args) {        try (MyResourceOut resource &#x3D; new MyResourceOut();) {            resource.out();        } catch (Exception e) {            e.printStackTrace();        }    }}
“再来看一下反编译的字节码。”
12345678910111213141516171819202122public class TrywithresourcesCustomOut {    public TrywithresourcesCustomOut() {    }    public static void main(String[] args) {        try {            MyResourceOut resource &#x3D; new MyResourceOut();            try {                resource.out();            } catch (Throwable var5) {                try {                    resource.close();                } catch (Throwable var4) {                    var5.addSuppressed(var4);                }                throw var5;            }            resource.close();        } catch (Exception var6) {            var6.printStackTrace();        }    }}
“这次， catch 块主动调用了 resource.close() ，并且有一段很关键的代码 var5.addSuppressed(var4) 。”
“这是为了什么呢？”三妹问。
“当一个异常被抛出的时候，可能有其他异常因为该异常而被抑制住，从而无法正常抛出。这时可以通过 addSuppressed() 方法把这些被抑制的方法记录下来，然后被抑制的异常就会出现在抛出的异常的堆栈信息中，可以通过 getSuppressed() 方法来获取这些异常。这样做的好处是不会丢失任何异常，方便我们进行调试。”我说。
“有没有想到之前的那个例子——在 try-catch-finally 中， readLine() 方法的异常信息竟然被 close() 方法的堆栈信息吃了。现在有了 try-with-resources，再来看看和 readLine() 方法一致的 out() 方法会不会被 close() 吃掉吧。”
123456789class MyResourceOutThrow implements AutoCloseable {    @Override    public void close() throws Exception {        throw  new Exception(&quot;close()&quot;);    }    public void out() throws Exception{        throw new Exception(&quot;out()&quot;);    }}
“调用这 2 个方法。”
123456789public class TrywithresourcesCustomOutThrow {    public static void main(String[] args) {        try (MyResourceOutThrow resource &#x3D; new MyResourceOutThrow();) {            resource.out();        } catch (Exception e) {            e.printStackTrace();        }    }}
“程序输出的结果如下所示。”
1234567891011121314java.lang.Exception: out()    at com.cmower.dzone.trycatchfinally.MyResourceOutThrow.out(TrywithresourcesCustomOutThrow.java:20)    at com.cmower.dzone.trycatchfinally.TrywithresourcesCustomOutThrow.main(TrywithresourcesCustomOutThrow.java:6)    Suppressed: java.lang.Exception: close()        at com.cmower.dzone.trycatchfinally.MyResourceOutThrow.close(TrywithresourcesCustomOutThrow.java:16)        at com.cmower.dzone.trycatchfinally.TrywithresourcesCustomOutThrow.main(TrywithresourcesCustomOutThrow.java:5)
“瞧，这次不会了， out() 的异常堆栈信息打印出来了，并且 close() 方法的堆栈信息上加了一个关键字 Suppressed ，一目了然。”
“三妹，怎么样？是不是感觉 try-with-resources 好用多了！我来简单总结下哈，在处理必须关闭的资源时，始终有限考虑使用 try-with-resources，而不是 try–catch-finally。前者产生的代码更加简洁、清晰，产生的异常信息也更靠谱。”
“靠谱！”三妹说。
6.3 异常处理的20个最佳实践“三妹啊，今天我来给你传授 20 个异常处理的最佳实践经验，以免你以后在开发中采坑。”我面带着微笑对三妹说。
“好啊，二哥，我洗耳恭听。”三妹也微微一笑，欣然接受。
“好，那哥就不废话了。开整。”
01、尽量不要捕获 RuntimeException 
阿里出品的 Java 开发手册上这样规定：

尽量不要 catch RuntimeException，比如 NullPointerException、IndexOutOfBoundsException 等等，应该用预检查的方式来规避。

正例：
123if (obj !&#x3D; null) {  &#x2F;&#x2F;...}
反例：
12345try {   obj.method(); } catch (NullPointerException e) {  &#x2F;&#x2F;...}
“哦，那如果有些异常预检查不出来呢？”三妹问。
“的确会存在这样的情况，比如说 NumberFormatException，虽然也属于 RuntimeException，但没办法预检查，所以还是应该用 catch 捕获处理。”我说。
02、尽量使用 try-with-resource 来关闭资源 
当需要关闭资源时，尽量不要使用 try-catch-finally，禁止在 try 块中直接关闭资源。
反例：
123456789101112public void doNotCloseResourceInTry() {    FileInputStream inputStream &#x3D; null;    try {        File file &#x3D; new File(&quot;.&#x2F;tmp.txt&quot;);        inputStream &#x3D; new FileInputStream(file);        inputStream.close();    } catch (FileNotFoundException e) {        log.error(e);    } catch (IOException e) {        log.error(e);    }}
“为什么呢？”三妹问。
“原因也很简单，因为一旦 close() 之前发生了异常，那么资源就无法关闭。直接使用 try-with-resource 来处理是最佳方式。”我说。
123456789public void automaticallyCloseResource() {    File file &#x3D; new File(&quot;.&#x2F;tmp.txt&quot;);    try (FileInputStream inputStream &#x3D; new FileInputStream(file);) {    } catch (FileNotFoundException e) {        log.error(e);    } catch (IOException e) {        log.error(e);    }}
“除非资源没有实现 AutoCloseable 接口。”我补充道。
“那这种情况下怎么办呢？”三妹问。
“就在 finally 块关闭流。”我说。
1234567891011121314151617public void closeResourceInFinally() {    FileInputStream inputStream &#x3D; null;    try {        File file &#x3D; new File(&quot;.&#x2F;tmp.txt&quot;);        inputStream &#x3D; new FileInputStream(file);    } catch (FileNotFoundException e) {        log.error(e);    } finally {        if (inputStream !&#x3D; null) {            try {                inputStream.close();            } catch (IOException e) {                log.error(e);            }        }    }}
03、不要捕获 Throwable 
Throwable 是 exception 和 error 的父类，如果在 catch 子句中捕获了 Throwable，很可能把超出程序处理能力之外的错误也捕获了。
123456public void doNotCatchThrowable() {    try {    } catch (Throwable t) {        &#x2F;&#x2F; 不要这样做    }}
“到底为什么啊？”三妹问。
“因为有些 error 是不需要程序来处理，程序可能也处理不了，比如说 OutOfMemoryError 或者 StackOverflowError，前者是因为 Java 虚拟机无法申请到足够的内存空间时出现的非正常的错误，后者是因为线程申请的栈深度超过了允许的最大深度出现的非正常错误，如果捕获了，就掩盖了程序应该被发现的严重错误。”我说。
“打个比方，一匹马只能拉一车厢的货物，拉两车厢可能就挂了，但一 catch，就发现不了问题了。”我补充道。
04、不要省略异常信息的记录 
很多时候，由于疏忽大意，我们很容易捕获了异常却没有记录异常信息，导致程序上线后真的出现了问题却没有记录可查。
123456public void doNotIgnoreExceptions() {    try {    } catch (NumberFormatException e) {        &#x2F;&#x2F; 没有记录异常    }}
应该把错误信息记录下来。
123456public void logAnException() {    try {    } catch (NumberFormatException e) {        log.error(&quot;哦，错误竟然发生了: &quot; + e);    }}
05、不要记录了异常又抛出了异常 
这纯属画蛇添足，并且容易造成错误信息的混乱。
反例：
12345try {} catch (NumberFormatException e) {    log.error(e);    throw e;}
要抛出就抛出，不要记录，记录了又抛出，等于多此一举。
反例：
123456public void wrapException(String input) throws MyBusinessException {    try {    } catch (NumberFormatException e) {        throw new MyBusinessException(&quot;错误信息描述：&quot;, e);    }}
这种也是一样的道理，既然已经捕获了，就不要在方法签名上抛出了。
06、不要在 finally 块中使用 return 
阿里出品的 Java 开发手册上这样规定：

try 块中的 return 语句执行成功后，并不会马上返回，而是继续执行 finally 块中的语句，如果 finally 块中也存在 return 语句，那么 try 块中的 return 就将被覆盖。

反例：
12345678private int x &#x3D; 0;public int checkReturn() {    try {        return ++x;    } finally {        return ++x;    }}
“哦，确实啊，try 块中 x 返回的值为 1，到了 finally 块中就返回 2 了。”三妹说。
“是这样的。”我点点头。
07、抛出具体定义的检查性异常而不是 Exception 
12public void foo() throws Exception { &#x2F;&#x2F;错误方式}
一定要避免出现上面的代码，它破坏了检查性（checked）异常的目的。声明的方法应该尽可能抛出具体的检查性异常。
例如，如果一个方法可能会抛出 SQLException 异常，应该显式地声明抛出 SQLException 而不是 Exception 类型的异常。这样可以让其他开发者更好地理解代码的意图和异常处理的方式，并且可以根据 SQLException 的定义和文档来确定异常的处理方式和策略。
08、捕获具体的子类而不是捕获 Exception 类 
12345try {   someMethod();} catch (Exception e) { &#x2F;&#x2F;错误方式   LOGGER.error(&quot;method has failed&quot;, e);}
如果在 catch 块中捕获 Exception 类型的异常，会将所有异常都捕获，从而可能会给程序带来不必要的麻烦。具体来说，如果捕获 Exception 类型的异常，可能会导致以下问题：

难以识别和定位异常：如果捕获 Exception 类型的异常，可能会捕获到一些不应该被处理的异常，从而导致程序难以识别和定位异常。
难以调试和排错：如果捕获 Exception 类型的异常，可能会使得调试和排错变得更加困难，因为无法确定具体的异常类型和异常发生的原因。

下面举一个例子来说明为什么应该尽可能地捕获具体的子类而不是 Exception 类型的异常。
假设我们有一个方法 readFromFile(String filePath) ，用于从指定文件中读取数据。在方法实现过程中，可能会出现两种异常：FileNotFoundException 和 IOException。
如果在方法中使用以下 catch 块来捕获异常：
12345try {    &#x2F;&#x2F; 读取数据的代码} catch (Exception e) {    &#x2F;&#x2F; 异常处理的代码}
这样做会捕获所有类型的异常，包括 Checked Exception 和 Unchecked Exception。这可能会导致以下问题：

发生 RuntimeException 类型的异常时，也会被捕获，从而可能会掩盖实际的异常信息。
在调试和排错时，无法确定异常的具体类型和发生原因，从而增加了调试和排错的难度。
在程序运行时，可能会捕获一些不需要处理的异常（如 NullPointerException、IllegalArgumentException 等），从而降低程序的性能和稳定性。

因此，为了更好地定位和处理异常，应该尽可能地捕获具体的子类，例如：
1234567try {    &#x2F;&#x2F; 读取数据的代码} catch (FileNotFoundException e) {    &#x2F;&#x2F; 处理文件未找到异常的代码} catch (IOException e) {    &#x2F;&#x2F; 处理输入输出异常的代码}
这样做可以更准确地捕获异常，从而提高程序的健壮性和稳定性。
09、自定义异常时不要丢失堆栈跟踪 
123catch (NoSuchMethodException e) {   throw new MyServiceException(&quot;Some information: &quot; + e.getMessage());  &#x2F;&#x2F;错误方式}
这破坏了原始异常的堆栈跟踪，正确的做法是：
123catch (NoSuchMethodException e) {   throw new MyServiceException(&quot;Some information: &quot; , e);  &#x2F;&#x2F;正确方式}
例如，下面是一个自定义异常类，它重写了 printStackTrace() 方法来打印堆栈跟踪信息：
12345678910public class MyException extends Exception {    public MyException(String message, Throwable cause) {        super(message, cause);    }    @Override    public void printStackTrace() {        System.err.println(&quot;MyException:&quot;);        super.printStackTrace();    }}
这样做可以保留堆栈跟踪信息，同时也可以提供自定义的异常信息。在抛出 MyException 异常时，可以得到完整的堆栈跟踪信息，从而更好地定位和解决异常。
10、finally 块中不要抛出任何异常
12345try {  someMethod();  &#x2F;&#x2F;Throws exceptionOne} finally {  cleanUp();    &#x2F;&#x2F;如果finally还抛出异常，那么exceptionOne将永远丢失}
finally 块用于定义一段代码，无论 try 块中是否出现异常，都会被执行。finally 块通常用于释放资源、关闭文件等必须执行的操作。
如果在 finally 块中抛出异常，可能会导致原始异常被掩盖。比如说上例中，一旦 cleanup 抛出异常，someMethod 中的异常将会被覆盖。
11、不要在生产环境中使用  
在 Java 中， printStackTrace() 方法用于将异常的堆栈跟踪信息输出到标准错误流中。这个方法对于调试和排错非常有用。但在生产环境中，不应该使用 printStackTrace() 方法，因为它可能会导致以下问题：

printStackTrace() 方法将异常的堆栈跟踪信息输出到标准错误流中，这可能会暴露敏感信息，如文件路径、用户名、密码等。
printStackTrace() 方法会将堆栈跟踪信息输出到标准错误流中，这可能会影响程序的性能和稳定性。在高并发的生产环境中，大量的异常堆栈跟踪信息可能会导致系统崩溃或出现意外的行为。
由于生产环境中往往是多线程、分布式的复杂系统， printStackTrace() 方法输出的堆栈跟踪信息可能并不完整或准确。

在生产环境中，应该使用日志系统来记录异常信息，例如 log4j、slf4j、logback 等。日志系统可以将异常信息记录到文件或数据库中，而不会暴露敏感信息，也不会影响程序的性能和稳定性。同时，日志系统也提供了更多的功能，如级别控制、滚动日志、邮件通知等。
123456例如，可以使用 logback 记录异常信息，如下所示：try {    &#x2F;&#x2F; some code} catch (Exception e) {    logger.error(&quot;An error occurred: &quot;, e);}
12、对于不打算处理的异常，直接使用 try-finally，不用 catch 
12345try {  method1();  &#x2F;&#x2F; 会调用 Method 2} finally {  cleanUp();    &#x2F;&#x2F;do cleanup here}
如果 method1 正在访问 Method 2，而 Method 2 抛出一些你不想在 Method 1 中处理的异常，但是仍然希望在发生异常时进行一些清理，可以直接在 finally 块中进行清理，不要使用 catch 块。
13、记住早 throw 晚 catch 原则 
“早 throw, 晚 catch” 是 Java 中的一种异常处理原则。这个原则指的是在代码中尽可能早地抛出异常，以便在异常发生时能够及时地处理异常。同时，在 catch 块中尽可能晚地捕获异常，以便在捕获异常时能够获得更多的上下文信息，从而更好地处理异常。
来举个 “早 throw” 例子，如果一个方法需要传递参数，并且该参数必须满足一定的条件，如果参数不符合条件，则应该立即抛出异常，而不是在方法中进行其他操作。这可以确保异常在发生时能够及时被处理，避免更严重的问题。
再来举个“晚 catch”的例子，如果一个方法调用了其他方法，可能会抛出异常，如果在方法内部立即捕获异常，则可能会导致对异常的处理不充分。
来看这段代码：
123456789101112131415161718192021public class ExceptionDemo1 {    public static void main(String[] args) {        Scanner sc &#x3D; new Scanner(System.in);        String str &#x3D; sc.nextLine();        try {            int num &#x3D; parseInt(str);            System.out.println(&quot;转换结果：&quot; + num);        } catch (NumberFormatException e) {            System.out.println(&quot;转换失败：&quot; + e.getMessage());        }    }    public static int parseInt(String str) {        if (str &#x3D;&#x3D; null || &quot;&quot;.equals(str)) {            throw new NullPointerException(&quot;字符串为空&quot;);        }        if (!str.matches(&quot;\\d+&quot;)) {            throw new NumberFormatException(&quot;字符串不是数字&quot;);        }        return Integer.parseInt(str);    }}
这个示例中，定义了一个 parseInt() 方法，用于将字符串转换为整数。在该方法中，首先检测字符串是否为空，如果为空，则立即抛出 NullPointerException 异常。然后，检测字符串是否为数字，如果不是数字，则抛出 NumberFormatException 异常。最后，使用 Integer.parseInt() 方法将字符串转换为整数，并返回。
在示例的 main() 方法中，调用 parseInt() 方法，并使用 try-catch 块捕获可能抛出的 NumberFormatException 异常。如果转换成功，则输出转换结果，否则输出转换失败信息。
这个示例使用了 “早 throw, 晚 catch” 的原则，在 parseInt() 方法中尽可能早地抛出异常，在 main() 方法中尽可能晚地捕获异常，以便在捕获异常时能够获得更多的上下文信息，从而更好地处理异常。
运行该示例，输入一个数字字符串，可以看到输出转换结果。如果输入一个非数字字符串，则输出转换失败信息。
14、只抛出和方法相关的异常 
相关性对于保持代码的整洁非常重要。一种尝试读取文件的方法，如果抛出 NullPointerException，那么它不会给用户提供有价值的信息。相反，如果这种异常被包裹在自定义异常中，则会更好。
NoSuchFileFoundException 则对该方法的用户更有用。
12345678910111213141516public class Demo {    public static void main(String[] args) {        try {            int result &#x3D; divide(10, 0);            System.out.println(&quot;The result is: &quot; + result);        } catch (ArithmeticException e) {            System.err.println(&quot;Error: &quot; + e.getMessage());        }    }    public static int divide(int a, int b) throws ArithmeticException {        if (b &#x3D;&#x3D; 0) {            throw new ArithmeticException(&quot;Division by zero&quot;);        }        return a &#x2F; b;    }}
在该示例中，只抛出了和方法相关的异常 ArithmeticException，这可以使代码更加清晰和易于维护。
15、切勿在代码中使用异常来进行流程控制 
在代码中使用异常来进行流程控制会导致代码的可读性、可维护性和性能出现问题。
1234567891011121314public class Demo {    public static void main(String[] args) {        String input &#x3D; &quot;1,2,3,a,5&quot;;        String[] values &#x3D; input.split(&quot;,&quot;);        for (String value : values) {            try {                int num &#x3D; Integer.parseInt(value);                System.out.println(num);            } catch (NumberFormatException e) {                System.err.println(value + &quot; is not a valid number&quot;);            }        }    }}
虽然这个示例可以正确地处理输入字符串中的非数字字符，但是它使用异常进行流程控制，这就导致代码变得混乱、难以理解。应该使用其他合适的控制结构（如 if、switch、循环等）来管理程序的流程。
16、尽早验证用户输入以在请求处理的早期捕获异常 
例如：在用户注册的业务中，如果按照这样来做：

验证用户
插入用户
验证地址
插入地址
如果出问题回滚一切

这是不正确的做法，它会使数据库在各种情况下处于不一致的状态，应该首先验证所有内容，然后再进行数据库更新。正确的做法是：

验证用户
验证地址
插入用户
插入地址
如果问题回滚一切

举个例子，我们用 JDBC 的方式往数据库插入数据，那么最好是先 validate 再 insert，而不是 validateUserInput、insertUserData、
123456789101112131415161718192021222324252627282930313233343536Connection conn &#x3D; null;try {    &#x2F;&#x2F; Connect to the database    conn &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mydatabase&quot;, &quot;username&quot;, &quot;password&quot;);    &#x2F;&#x2F; Start a transaction    conn.setAutoCommit(false);    &#x2F;&#x2F; Validate user input    validateUserInput();    &#x2F;&#x2F; Insert user data    insertUserData(conn);    &#x2F;&#x2F; Validate address input    validateAddressInput();    &#x2F;&#x2F; Insert address data    insertAddressData(conn);    &#x2F;&#x2F; Commit the transaction if everything is successful    conn.commit();} catch (SQLException e) {    &#x2F;&#x2F; Rollback the transaction if there is an error    if (conn !&#x3D; null) {        try {            conn.rollback();        } catch (SQLException ex) {            System.err.println(&quot;Error: &quot; + ex.getMessage());        }    }    System.err.println(&quot;Error: &quot; + e.getMessage());} finally {    &#x2F;&#x2F; Close the database connection    if (conn !&#x3D; null) {        try {            conn.close();        } catch (SQLException e) {            System.err.println(&quot;Error: &quot; + e.getMessage());        }    }}
17、一个异常只能包含在一个日志中 
不要这样做：
12log.debug(&quot;Using cache sector A&quot;);log.debug(&quot;Using retry sector B&quot;);
在单线程环境中，这样看起来没什么问题，但如果在多线程环境中，这两行紧挨着的代码中间可能会输出很多其他的内容，导致问题查起来会很难受。应该这样做：
1LOGGER.debug(&quot;Using cache sector A, using retry sector B&quot;);
18、将所有相关信息尽可能地传递给异常 
有用的异常消息和堆栈跟踪非常重要，如果你的日志不能定位异常位置，那要日志有什么用呢？
12&#x2F;&#x2F; Log exception message and stack traceLOGGER.debug(&quot;Error reading file&quot;, e);
应该尽量把 String message, Throwable cause 异常信息和堆栈都输出。
19、终止掉被中断线程 
123456while (true) {  try {    Thread.sleep(100000);  } catch (InterruptedException e) {} &#x2F;&#x2F;别这样做  doSomethingCool();}
InterruptedException 提示应该停止程序正在做的事情，比如事务超时或线程池被关闭等。
应该尽最大努力完成正在做的事情，并完成当前执行的线程，而不是忽略 InterruptedException。修改后的程序如下：
12345678while (true) {  try {    Thread.sleep(100000);  } catch (InterruptedException e) {    break;  }}doSomethingCool();
20、对于重复的 try-catch，使用模板方法 
类似的 catch 块是无用的，只会增加代码的重复性，针对这样的问题可以使用模板方法。
例如，在尝试关闭数据库连接时的异常处理。
123456789class DBUtil{    public static void closeConnection(Connection conn){        try{            conn.close();        } catch(Exception ex){            &#x2F;&#x2F;Log Exception - Cannot close connection        }    }}
这类的方法将在应用程序很多地方使用。不要把这块代码放的到处都是，而是定义上面的方法，然后像下面这样使用它：
123456789public void dataAccessCode() {    Connection conn &#x3D; null;    try{        conn &#x3D; getConnection();        ....    } finally{        DBUtil.closeConnection(conn);    }}
“好了，三妹，关于异常处理实践就先讲这 20 条吧，实际开发中你还会碰到其他的一些坑，自己踩一踩可能印象更深刻一些。”我说。
“那万一到时候我工作后被领导骂了怎么办？”三妹委屈地说。
“新人嘛，总要写几个 bug 才能对得起新人这个称号嘛。”我轻描淡写地说。
“好吧。”三妹无奈地叹了口气。
6.4 空指针的传说空指针，号称天下最强刺客。
他原本不叫这个名字，空指针原本复姓异常，空指针只不过是他的武器，但他杀戮过多，渐渐地人们只记住了空指针这三个字。
天下武功，唯快不破，空指针的针，以快和诡异著称，稍有不慎，便是伤亡。
… …
我叫王二，我来到这个奇怪的世界已经一年了，我等了一年，穿越附赠的老爷爷、戒指、系统什么的我到现在都没发现。
而且这个世界看起来也太奇怪了，这里好像叫什么 Java 大陆，我只知道这个世界的最强者叫做 Object，听说是什么道祖级的存在，我也不知道是什么意思，毕竟我现在好像还是个菜鸡，别的主角一年都应该要飞升仙界了吧，我还连个小火球都放不出来。
哦，对了，上面的那段话是我在茶馆喝茶的时候听说书的先生说的，总觉得空指针这个名字怪怪的，好像在什么地方听说过。
我的头痛的毛病又犯了，我已经记不起来我为什么来到这里了，我只记得我的名字叫王二，其他的，我只感觉这个奇怪的世界有一种熟悉，但是我什么都记不起来了。
算了，得过且过吧。
我准备去找空指针了，虽然听说他很可怕，但是好像听说他不是嗜杀之人，应该不会滥杀无辜吧，目前为止，我也只对这三个字有熟悉的感觉了，我一定要找到他，找回我的记忆！
我打听了很久，原来空指针是异常组织的三代嫡传，异常组织是这个世界上最恐怖的杀手组织，空指针就是异常现在最出色的刺客。
听说空指针出生的时候，脖子上就挂着一根针，整个 Java 大陆雪下一月不停，Linux 森林多块陆地直接沉陷，于是他的父亲 RuntimeException 就给他起了空指针这个名字。
空指针出生的天生异象也引起了异常组织高层的注意，听说他的祖父 Exception，还有整个异常组织的领军人物 Throwable 都亲自接见了空指针，并且认为空指针天赋异禀，未来可期。
要知道，Throwable 可是 Object 亲自任命的异常组织头领。作为 Object 最值得信任的亲信，跟随 Object 万年以来，所有的脏活累活都依靠 Thrwoable 创立的异常组织来处理，真可谓一人之下，万人之上。
Throwable 只有两个亲子，就是 Error 和 Exception，传说中 Error 心狠手辣，手下无一活口，见过 Error 的人还能活下来的寥寥无几。
整个大陆只有他们恐怖的传说，谁也不知道他们什么时候出现，但是一旦他们出现，基本宣告着你已经是个死人了。
而我听说过最恐怖的就是 OutOfMemoryError  和  StackOverflowError  这两位刺客，因为大陆上永远有一座风云榜悬挂在帝都门口，而这两位，一直位居杀手榜榜首位置，空指针也只只能屈居第三而已。当然，大陆不少人都认为空指针会后来居上。
我的消息只是打听到这么多，接下来的日子，我走过无数的城市、荒野，我穿过沙漠、丛林，这一天，终于，我来到了大陆的帝都—堆。
这个名字听起来也有点耳熟，不管他，先进城再说。
进城后我发现这里非常诡异，整座城市好像都非常年轻，好像连一个成年人都没有！街道上熙熙攘攘竟然都是年轻人。
带着疑惑，我走进了一家叫做同福客栈的酒楼。
”客官，打尖还是住店啊？“一个小二模样的小孩带着一丝谄媚的对我说。
”住店，带我去最好的房间，这些钱先押你这里，不够再跟我要。“一路走来，对于这些地方的行情我也算轻车熟路了。
”小朋友，这里是怎么回事？你们这里没有大人吗？“我一边走一边问这个只有我一半身高的小孩，根据我目测，他身高不超过1米，应该还只有七八岁的样子，难道这里的商人如此黑心，竟然雇佣童工，不过这也不貌似不对，因为周围的客人好像也都是这般年纪，他们竟然还有在抽烟喝酒的！
”客官可真幽默，不过我看客官应该是刚来帝都，不瞒您说，整个帝都就基本没有超过15岁的人，超过15的据说都在叫做老年区的养老去了！就拿我来说吧，我今年可不小了，我都8岁了，像我这般年纪的已经半截腿迈进棺材咯。哎，这身子也是一年不如一年了。“
看着这个小二一脸认真的样子，我越发觉得这座城市诡异起来了！8岁，什么鬼？8岁不是应该在家里看喜羊羊吗？！还半截腿迈进棺材！
”可是你看我比你高这么多，你不觉得奇怪吗？“我奇怪的问他。
”有什么好奇怪的，要不是我小时候喝多了三鹿，没准我也长这么高了！“小二有点生气的对我说。
行吧，再说两句把他激怒了，跳起来打我膝盖就大事不妙了。
接下来的几天，经过我的打探，原来我在的地方是叫做年轻区，整个帝都就只有这两个区域，年轻区的人年龄确实没有超过15岁的，有些人刚出生没几天就死了，对此，生活在这里的人也见怪不怪了。对于他们来说，寄希望能活到超过15岁进入老年区养老就是他们的梦想。
我在怀疑是不是异常组织在这里暗杀，可是发现结果并不是，这里的人貌似已经习惯了，生活对他们来说就是随便活活就好了，每次的死亡对于他们来说毫无征兆，可能刚踢着球呢，就突然挂了，有的上着厕所突然就死了，临死前连个屁股都没擦，不说了，有点恶心。
就在我等的不耐烦想打算去老年区看看的时候，一个穿着黑衣的人找到了我。
”你是谁？“我警惕的问他。
”本座IOException。“黑衣人神情冰冷的看着我说。
”你找我什么事？“
”这些你不用知道，跟我走一趟吧！“
我刚想说话拒绝，开什么玩笑，跟你们异常组打交道的人非死即残，谁要跟你去。
但是由不得我拒绝，我只感觉一阵天旋地转，我感觉我在天上飞，然后我就失去了意识。当我醒来的时候，我发现我躺在一张巨大的床上，桌子上点着一支檀香，整个房间只有一张桌子、一把椅子和我躺的地方。
房间很小，应该只有10几个平方，但是我竟然又有一种熟悉的感觉，这种感觉萦绕在我心头挥散不去。
没等我再想更多，房门打开了。
”是你，你把我带来干什么？“
”走吧，有人要见你。“
还是不容我抗拒，如果我的战斗力是5的话，我想，IO他该有好几万了吧。
又是这该死的眩晕感，不过这次没有几秒钟，我就发现我在一个花园里，花园中间一个身穿黄袍的中年人正在慢悠悠的喝茶。在他身上我感受不到任何强大的气息，甚至不如IOException给我的压迫感强烈。这是谁？
不等我思绪飘飞，IOException弯腰躬身说道：”陛下，人带过来了。“
”嗯，你退下吧。“中年人转过身来，脸上丝毫看不出情绪的说道。
我大概猜到了这是哪里了，于是也放下心来，在这里，或许能找到我的答案。
反正他要对我怎么样，我也没有办法反抗，我径直坐到他的对面，看着他说：”您就是Object陛下吧，不知找我所谓何事？“
中年人也不在意，没有正面回答我的问题，反而略带一丝调侃的说道：”不用咬文嚼字，说点正常人的话吧。
… …
这不按套路出牌啊，我这不是来久了，模仿你们古代人说话嘛，怎么还埋怨起我来了？！
”那我就直说了，我想知道空指针在哪里。“
”空指针就在皇宫轮值，你找他干嘛？“
”我暂时不能说“
”呵呵，你就不好奇我为什么知道你，为什么又把你带过来？“
”好奇，可是我就是不想问。“
Object喝了口茶，不紧不慢的回道：”年轻人有性格是好事，可是过刚易折的道理你应该明白。“
”我不明白，我在这里反正也没看见什么老人，当然，除了你。“我理所当然的认为这肯定是Object搞得鬼，整个帝都都是小朋友，要是没有猫腻，骗鬼呢！
Object听到这话，皱了皱眉，他沉默了一会儿，缓缓站起身子走到一颗柳树下，背着手说道：“你不知道这一切是为什么吗？”
废话，我当然不知道了，我知道还能问你吗？！
又是沉默… …这个气氛让我感觉很不舒服。就在我受不了想说话的时候，Object突然说了一句：“带他去见空指针吧。”
“是，陛下！”突然，一个身穿红袍的枯瘦老者出现在我背后，把我吓了一跳。
我也不想再多生事端，直觉告诉我这里不是久留之地，虽然有点莫名其妙，我还是跟着红袍老者来走了。
… …
“陛下，是他吗？”一个光头大汉的身影在半空若影若现的说道。
“还不能确定… 不过，留给我们的时间不多了，下一次的轮回就快来了。”
“轮回，又是轮回。我们还有希望吗？”大汉呢喃着，不知道是对自己说还是对中年人说。
中年人依然背着手，抬头望着漫天的柳絮说道：“这一世，该是个了断了。”
… …
没多久，他把我带到一个房间门口，也是面无表情的说道：“进去吧，空指针就在里面。”
我挺住脚步，转过身问他：“你是谁？我们是不是见过？”
红袍老者怪异一笑：“也许吧，老夫 IndexOutOfBoundsException ，空指针便是我好友。”
这个名字可真长，我听说过他，据传闻他的实力也非常之强，可能不下于空指针，都是以诡异的出手角度著称，不过相比于空指针的大名，他好像更低调，难怪在皇宫当个老太监一般。
我也不在多想，点点头，走进了房间。刚进房间，我就看见一个一身白衣的身影背对着我，笔直的身影好像要冲破天际，身上的气势强大无比，至少在我见过的所有人里足以排进前三了。空指针，果然名不虚传！
我走到房间中央，环目四望才发现这好像是一座祠堂的样子，就在我还在打量四周之际，一道清冷的声音传到我的耳边：
“你身上的气息让我非常讨厌！”
他转过身来，我发现我根本看不清空指针长什么样子，他的脸好像打上了马赛克。听到他的话，我心里的疑惑更多了，我只是觉得他的气息让我感到非常熟悉，他的话让我有点莫名其妙。于是我试探道：
“你知道我是谁？”
听到我的话，他一步步走进我，在我身边闻了闻，这让我什么一紧，虽然我想搞清楚我身上的问题，但是我不是出卖肉体的人，我退后一步说：
“你想干嘛？”
空指针皱紧了眉头，仿佛自言自语道：“不对，不对，这是… 规则的气息？可是他明明身上没有任何能量波动。”
我见他好像魔怔了，仿佛在思考什么，于是迈步走到他刚才站立的地方看着前面，原来，这是他们的族谱！
这里是异常的祠堂！

看完这张族谱，我恍然大悟，好像明白了什么。突然，我的脑袋里出现了一个冰冷的机器声音：“获取异常族谱，历练完成度+100。”
我Kao，系统，这是系统啊，我不禁内牛满面，啥任务系统啊，一点提示都没有，我赶紧喊道：
“系统，系统，还在吗？在线等，挺着急的。”可是没有任何回复！这啥破系统！就在我想破口大骂的时候，空指针看到我和个二傻子似的大呼小叫，突然一脸不可思议的对着我说：
“你明悟了规则？”
我愣了愣，嗯？难道我不是战5渣了？规则之力？好像是很高端的样子啊？
“撒豆成兵！”
“呼风！”
”唤雨！“”临兵斗者皆阵列在前！“
一点反应都没有。。。啥玩意儿？还规则之力？九字真言都没用啊？
空指针好像都蒙了，他敲了敲太阳穴，无语的看着我说：
”你不是来找我的吗？说完你的问题，然后给我滚！“
对啊，这系统把我整的我都忘记我来干嘛的了，我赶紧说：
”你认识我对不对，你是不是觉得我有一种熟悉的感觉？我想知道我的来历！“
空指针又愣了愣，他看着我，沉默了一会儿，回道：“不知道！”
我有点奇怪，看他一脸便秘的表情应该是见过我的，他一定在撒谎，既然如此…
“那你告诉我你们有什么办法能在你们异常的攻击下防身吧？”
空指针大怒，刚想起身说话，空中突然传来一道声音：答应他的要求！
他冷哼一声，丢给我一本书，上面写着catch一个字，还有一块写着catch的令牌，冰冷的说到：“你想知道的都在这里了。”说完，拂袖而去。
我看着桌子上的这本书，想了想还是翻阅起来。
原来 Exception  和它的儿子们，除了 RuntimeException  一支，都叫作 Checked Exception ，我还能用catch令牌来对抗他们的攻击！包括空指针，以后我就不怕他们了！
可是，他为什么要给我，看他刚才的样子都想打我了，又突然给了我这些？还有他一直在说的规则之力又是什么？这座城市为什么又这么诡异？
6.5 try-catch会影响性能吗？“二哥，你看着这鬼代码，竟然在 for 循环里面搞了个 try-catch ，不知道 try-catch有性能损耗吗？” 老王煞有其事地指着屏幕里的代码：
1234567for (int i &#x3D; 0; i &lt; 5000; i++) {     try {         dosth     } catch (Exception e) {         e.printStackTrace();     } }
我探过头去看了眼代码，“那 老王你觉得该怎么改？”
“当然是把 try-catch 提到外面啊！” 老王脑子都不转一下，脱口而出。
“你是不是傻？且不说性能，这代码的目的明显是让循环内部单次调用出错不影响循环的运行，你移到外面，业务逻辑不就变了吗！”老王挠了挠他的地中海，“好像也是啊！”
“回过头来，catch 整个 for 循环和在循环内部 catch，在不出错的情况下，其实性能差不多。” 我喝一口咖啡不经意地提到，准备在 老王前面秀一下。
“啥意思？” 老王有点懵地看着我，“ try-catch是有性能损耗的，我可是看过网上资料的！”
果然， 老王上钩了，我二话不说直接打开 idea，一顿操作敲了以下代码：
123456789101112131415161718192021222324252627282930public class TryCatchTest {    &#x2F;&#x2F; 用 @Benchmark 注解标记一个方法作为基准测试方法    @Benchmark    public void tryfor(Blackhole blackhole) {        &#x2F;&#x2F; 使用 try-catch 语句包装一个 for 循环        try {            for (int i &#x3D; 0; i &lt; 1000; i++) {                &#x2F;&#x2F; 在循环中调用 Blackhole.consume() 方法                blackhole.consume(i);            }        } catch (Exception e) {            &#x2F;&#x2F; 捕获异常并打印堆栈跟踪信息            e.printStackTrace();        }    }    &#x2F;&#x2F; 用 @Benchmark 注解标记另一个方法作为基准测试方法    @Benchmark    public void fortry(Blackhole blackhole) {        &#x2F;&#x2F; 使用 for 循环包装一个 try-catch 语句        for (int i &#x3D; 0; i &lt; 1000; i++) {            try {                &#x2F;&#x2F; 在 try 块中调用 Blackhole.consume() 方法                blackhole.consume(i);            } catch (Exception e) {                &#x2F;&#x2F; 捕获异常并打印堆栈跟踪信息                e.printStackTrace();            }        }    }}
在这里，请允许我补充一些概念，以便大家能更好的理解这段代码。

第一个： @Benchmark 是一个来自于 JMH（Java Microbenchmark Harness）库的注解，用来标记一个方法作为基准测试方法。JMH 是一个专门用于编写 Java 微基准测试的工具包，包含了一些用于测试 Java 代码性能和微调 JVM 的工具和库。使用 @Benchmark 注解标记的方法将被 JMH 自动识别为基准测试方法，并在运行时进行基准测试。在基准测试期间，JMH 会运行被标记的方法多次，并测量方法的执行时间、吞吐量、延迟等指标，并生成统计结果。
第二个：在 JMH 进行基准测试时，为了避免 JIT 编译器优化掉测试代码中的某些操作，我们需要在测试代码中使用一些占位符，以便让编译器认为这些操作是有意义的，不应该被优化掉。Blackhole.consume() 方法就是这样的一个占位符。它用来占用一些 CPU 时间和内存空间，以确保测试结果的准确性和可靠性。

“BB 不如 show code，看到没， 老王，我把 try-catch 从 for 循环里面提出来跟在for循环里面做个对比跑一下，你猜猜两个差多少？”
“切，肯定 tryfor 性能好，想都不用想，不是的话我倒立洗头！” 老王信誓旦旦道。
我懒得跟他BB，直接开始了 benchmark，跑的结果如下：     
可以看到，两者的性能（数字越大越好）其实差不多：551063.024 VS 551525.861。
在这里，简单普及一下 JMH 的使用指南。

第一步，在 pom.xml 文件中加入依赖。

1234567891011&lt;!-- 引入 JMH 工具包 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.openjdk.jmh&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;jmh-core&lt;&#x2F;artifactId&gt;    &lt;version&gt;1.35&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.openjdk.jmh&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;jmh-generator-annprocess&lt;&#x2F;artifactId&gt;    &lt;version&gt;1.35&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;

第二步，Intellij IDEA 中安装 JMH 插件。



第三步，在代码编辑器中点击这个带有时间和运行的图标。然后静静等待结果就可以了，我本机（32G 内存 Intel i7 跑了 16 分钟，贼慢，因为 JMH 比较喜欢追求公平公正 ）


老王一看傻了：“说好的性能影响呢？怎么没了？”
我直接一个javap，让 老王看看，其实两个实现在字节码层面没啥区别：

tryfor 的字节码

异常表记录的是 0 - 20 行，如果这些行里面的代码出现问题，直接跳到 23 行处理。


fortry 的字节码

差别也就是异常表的范围小点，包的是 9-14 行，其它跟 tryfor 都差不多。

所以从字节码层面来看，没抛错两者的执行效率其实没啥差别。
“那为什么网上流传着 try-catch会有性能问题的说法啊？” 老王觉得非常奇怪。
这个说法确实有，在《Effective Java》这本书里就提到了 try-catch 性能问题：

正所谓听话不能听一半，以前读书时候最怕的就是一知半解，因为完全理解选择题能选对，完全不懂蒙可能蒙对，一知半解必定选到错误的选项！
《Effective Java》书中说的其实是不要用 try-catch 来代替正常的代码，书中的举例了正常的 for 循环肯定这样实现：
12for ( Mountain m : range )    m.climb();
但有个卧龙偏偏不这样实现，要通过   try-catch 拐着弯来实现循环：
1234567&#x2F;* Horrible abuse of exceptions. Don&#39;t ever do this! *&#x2F;try {    int i &#x3D; 0;    while ( true )        range[i++].climb();} catch ( ArrayIndexOutOfBoundsException e ) {}
这操作我只能说有点逆天，这两个实现的对比就有性能损耗了。
我们直接再跑下有 try-catch 的代码和没 try-catch的 for 循环区别，代码如下：
123456789101112131415161718public class TryCatchTest1 {    @Benchmark    public void fornotry(Blackhole blackhole) {        for (int i &#x3D; 0; i &lt; 1000; i++) {            blackhole.consume(i);        }    }    @Benchmark    public void tryfor(Blackhole blackhole) {        for (int i &#x3D; 0; i &lt; 1000; i++) {            try {                blackhole.consume(i);            } catch (Exception e) {                e.printStackTrace();            }        }    }}
结果如下：

+-差不多，直接看前面的分数对比，没有 ry-catch 的性能确实好些，这也和书中说的 try-catch 会影响 JVM 一些特定的优化说法吻合，但是具体没有说影响哪些优化，我猜测可能是指令重排之类的。
好了，我再总结下有关 try-catch 性能问题说法：

try-catch 相比较没 try-catch ，确实有一定的性能影响，但是旨在不推荐我们用 try-catch 来代替正常能不用 try-catch 的实现，而不是不让用 try-catch 。
for循环内用   try-catch 和用 try-catch 包裹整个 for 循环性能差不多，但是其实两者本质上是业务处理方式的不同，跟性能扯不上关系，关键看你的业务流程处理。
虽然知道 try-catch会有性能影响，但是业务上不需要避讳其使用，业务实现优先（只要不是书中举例的那种逆天代码就行），非特殊情况下性能都是其次，有意识地避免大范围的 try-catch ，只 catch 需要的部分即可（没把握全 catch 也行，代码安全执行第一）。

“好了， 老王你懂了没？”
“行啊二哥，BB是一套一套的，走请你喝燕麦拿铁！”  老王一把拉起我，我直接一个挣脱，“少来，我刚喝过咖啡，你那个倒立洗头，赶紧的！”我立马意识到 老王想岔开话题。
“洗洗洗，我们先喝个咖啡，晚上回去给你洗！”
7 常用工具类7.1 Scanner工具类Java 的 Scanner 类是一个方便在控制台扫描用户输入的工具类，虽然它也可以扫描文件内容，但我们通常更喜欢它扮演前面的角色，因为扫描文件可以通过文件流来完成。
接下来，我们通过几个简单的示例讲一下 Scanner 类。
01、扫描控制台输入 
通常，我们会使用 Scanner 类来扫描控制台输入，尤其是对于初学 Java 的人来说，这样会非常的酷，因为终于可以拿到我们自己想要输入的数据了。
来看下面的示例：
123456789Scanner scanner &#x3D; new Scanner(System.in); &#x2F;&#x2F; 创建 Scanner 对象，从标准输入流中读取数据System.out.print(&quot;请输入一个整数：&quot;);int num &#x3D; scanner.nextInt(); &#x2F;&#x2F; 获取用户输入的整数System.out.println(&quot;您输入的整数是：&quot; + num);scanner.nextLine(); &#x2F;&#x2F; 读取换行符，避免影响下一次读取System.out.print(&quot;请输入一个字符串：&quot;);String str &#x3D; scanner.nextLine(); &#x2F;&#x2F; 获取用户输入的字符串System.out.println(&quot;您输入的字符串是：&quot; + str);scanner.close(); &#x2F;&#x2F; 关闭 Scanner 对象
运行后就可以在控制台交互了，对于新手来说，估计会觉得比较有趣。

其中 System.in 返回的是一个字节输入流 InputStream，和 System.out 刚好对应。

1）nextLine 
nextLine() 方法会扫描输入流中的字符，直到遇到行末尾的换行符 \n ，然后将该行的内容作为字符串返回，同时， nextLine() 会将 Scanner 对象的位置移动到下一行的开头，以便下一次读取数据时从下一行的开头开始读取。
12345678910Scanner scanner &#x3D; new Scanner(System.in); &#x2F;&#x2F; 创建 Scanner 对象，从标准输入流中读取数据System.out.println(&quot;请输入多行文本，以空行结束：&quot;);StringBuilder sb &#x3D; new StringBuilder(); &#x2F;&#x2F; 创建 StringBuilder 对象，用于保存读取的文本String line &#x3D; scanner.nextLine(); &#x2F;&#x2F; 读取输入流中的第一行while (!line.isEmpty()) { &#x2F;&#x2F; 如果读取的行不为空，则继续读取下一行    sb.append(line).append(&quot;\n&quot;); &#x2F;&#x2F; 将当前行的内容添加到 StringBuilder 对象中，并换行    line &#x3D; scanner.nextLine(); &#x2F;&#x2F; 读取下一行}System.out.println(&quot;您输入的文本是：\n&quot; + sb.toString()); &#x2F;&#x2F; 打印读取的文本scanner.close(); &#x2F;&#x2F; 关闭 Scanner 对象
2）nextInt 
nextInt() 用于从输入流中读取下一个整数并返回，如果输入流中没有整数，或者不是整数，将抛出 InputMismatchException 异常。

3）其他方法 
除了以上两个常用的方法，Scanner 类中还有一些其他的方法：

boolean hasNext() ：检查输入流是否还有下一个标记。
boolean hasNextLine() ：检查输入流是否还有下一行。
String next() ：读取输入流中的下一个标记（使用默认的分隔符，通常是空格或换行符）。
double nextDouble() ：读取输入流中的下一个双精度浮点数。

来个 demo 吧。
12345678910111213141516171819202122232425262728293031Scanner scanner &#x3D; new Scanner(System.in); &#x2F;&#x2F; 创建 Scanner 对象，从标准输入流中读取数据System.out.print(&quot;请输入一个整数：&quot;);if (scanner.hasNextInt()) { &#x2F;&#x2F; 判断输入流中是否有下一个整数    int num &#x3D; scanner.nextInt(); &#x2F;&#x2F; 读取输入流中的下一个整数    System.out.println(&quot;您输入的整数是：&quot; + num);} else {    System.out.println(&quot;输入的不是整数！&quot;);}scanner.nextLine(); &#x2F;&#x2F; 读取输入流中的换行符System.out.print(&quot;请输入多个单词，以空格分隔：&quot;);while (scanner.hasNext()) { &#x2F;&#x2F; 判断输入流中是否还有下一个标记    String word &#x3D; scanner.next(); &#x2F;&#x2F; 读取输入流中的下一个单词    System.out.println(&quot;您输入的单词是：&quot; + word);}scanner.nextLine(); &#x2F;&#x2F; 读取输入流中的换行符System.out.print(&quot;请输入一个实数：&quot;);if (scanner.hasNextDouble()) { &#x2F;&#x2F; 判断输入流中是否有下一个实数    double num &#x3D; scanner.nextDouble(); &#x2F;&#x2F; 读取输入流中的下一个实数    System.out.println(&quot;您输入的实数是：&quot; + num);} else {    System.out.println(&quot;输入的不是实数！&quot;);}scanner.nextLine(); &#x2F;&#x2F; 读取输入流中的换行符System.out.print(&quot;请输入一个字符串：&quot;);if (scanner.hasNextLine()) { &#x2F;&#x2F; 判断输入流中是否有下一行    String line &#x3D; scanner.nextLine(); &#x2F;&#x2F; 读取输入流中的下一行    System.out.println(&quot;您输入的字符串是：&quot; + line);} else {    System.out.println(&quot;输入的不是字符串！&quot;);}scanner.close(); &#x2F;&#x2F; 关闭 Scanner 对象
02、扫描文件 
当然了，Scanner 也是可以用来扫描文件的，方式也非常的简单，以下是代码示例：
123456789101112try {    &#x2F;&#x2F; 创建 File 对象，表示要扫描的文件    File file &#x3D; new File(&quot;docs&#x2F;安装环境.md&quot;);    Scanner scanner &#x3D; new Scanner(file); &#x2F;&#x2F; 创建 Scanner 对象，从文件中读取数据    while (scanner.hasNextLine()) { &#x2F;&#x2F; 判断文件中是否有下一行        String line &#x3D; scanner.nextLine(); &#x2F;&#x2F; 读取文件中的下一行        System.out.println(line); &#x2F;&#x2F; 打印读取的行    }    scanner.close(); &#x2F;&#x2F; 关闭 Scanner 对象} catch (FileNotFoundException e) {    System.out.println(&quot;文件不存在！&quot;);}
在上面的示例中，我们首先创建了一个 File 对象，表示要扫描的文件。然后，我们使用 Scanner 类的构造方法来创建 Scanner 对象，将文件作为参数传递给构造方法。在 while 循环中，我们使用 hasNextLine() 方法来判断文件中是否有下一行，如果有，则使用 nextLine() 方法读取该行字符串，并使用 println() 方法将其打印出来。最后，我们在程序结束前使用 close() 方法关闭 Scanner 对象。
除了使用循环+nextLine，我们还可以使用 useDelimiter 方法设置文件结束符 \Z 来读取整个文件。
123456789&#x2F;&#x2F; 创建 File 对象，表示要扫描的文件Scanner scanner &#x3D; new Scanner(new File(&quot;docs&#x2F;安装环境.md&quot;)); &#x2F;&#x2F; 创建 Scanner 对象，从文件中读取数据scanner.useDelimiter(&quot;\\Z&quot;); &#x2F;&#x2F; 设置分隔符为文件结尾if (scanner.hasNext()) { &#x2F;&#x2F; 判断文件中是否有下一行    String content &#x3D; scanner.next(); &#x2F;&#x2F; 读取文件中的下一行    System.out.println(content); &#x2F;&#x2F; 打印读取的行}scanner.close(); &#x2F;&#x2F; 关闭 Scanner 对象
正则表达式中的 \Z 表示输入的结尾，也就是文件结束符。在 Scanner 类中，我们可以使用 \Z 作为分隔符，以便读取整个文件内容。
03、查找匹配项 
除了上面提到的扫描控制台输入流、文件，Scanner 还提供了另外四个以 find 开头的查找匹配项的方法：

来看示例：
1234567891011String input &#x3D; &quot;good good study, day day up.&quot;;Scanner scanner &#x3D; new Scanner(input);String result;&#x2F;&#x2F; 使用 findInLine() 方法查找字符串中的单词result &#x3D; scanner.findInLine(&quot;study&quot;);System.out.println(&quot;findInLine(): &quot; + result); &#x2F;&#x2F; 输出 &quot;study&quot;&#x2F;&#x2F; 使用 findWithinHorizon() 方法查找字符串中的单词scanner &#x3D; new Scanner(input);result &#x3D; scanner.findWithinHorizon(&quot;study&quot;, 20);System.out.println(&quot;findWithinHorizon(): &quot; + result); &#x2F;&#x2F; 输出 &quot;study&quot;scanner.close(); &#x2F;&#x2F; 关闭 Scanner 对象
在上面的示例中，我们首先创建了一个字符串 input，表示要查找的文本。然后，我们使用 Scanner 类的构造方法创建 Scanner 对象，并将 input 作为输入流传递给该对象。接着，我们使用 findInLine() 方法和 findWithinHorizon() 方法分别查找字符串中的单词 “study”。其中， findInLine() 方法在当前行中查找匹配项，而 findWithinHorizon() 方法在指定的限制范围内查找匹配项。在本例中，我们将查找的范围限制为前 20 个字符。
需要注意的是， findInLine() 方法和 findWithinHorizon() 方法都返回找到的匹配项。如果没有找到匹配项，则返回 null。此外， findInLine() 方法和 findWithinHorizon() 方法都会忽略默认的分隔符，因此需要使用正则表达式来指定查找的模式。在本例中，我们使用了字符串 “study” 作为查找的模式。
当然我们也可以使用正则表达式，比如说我们要在下面的文件中查找 openjdk 这个关键字。

代码就可以这样写：
12345678&#x2F;&#x2F; 创建 File 对象，表示要扫描的文件Scanner scanner &#x3D; new Scanner(new File(&quot;docs&#x2F;安装环境.md&quot;)); &#x2F;&#x2F; 创建 Scanner 对象，从文件中读取数据Pattern pattern &#x3D; Pattern.compile(&quot;op..jdk&quot;);String result;while ((result &#x3D; scanner.findWithinHorizon(pattern, 0)) !&#x3D; null) {    System.out.println(&quot;findWithinHorizon(): &quot; + result);}
我们用正则表达式 pattern 来表示 openjdk 这个关键字， op..jdk 中的 . 表示任意字符，可以通过查找正则表达式去了解。
然后我们使用 while 循环来查找文件中所有的 openjdk ，其中 findWithinHorizon 方法的第二个参数如果为 0 则表示忽略边界，如果没找到，会返回 null。

由于文件中有两个 openjdk 关键字，所以输出结果如下所示：

04、小结 
总之，Scanner 类是一个功能强大的输入处理工具类，不仅可以扫描控制台的输入流，还可以扫描文件，并且提供了多种方法来读取不同类型的数据，比如 next() , nextInt() , nextLine() , nextDouble() 等。
除此之外，还可以通过 useDelimiter() 方法设置分隔符，通过 findInLine() , findWithinHorizon() 查找匹配项等。
7.2 Arrays工具类“哥，数组专用工具类是专门用来操作数组的吗？比如说创建数组、数组排序、数组检索等等。”三妹的提问其实已经把答案说了出来。
“是滴，这里说的数组专用工具类指的是 java.util.Arrays 类，基本上常见的数组操作，这个类都提供了静态方法可供直接调用。毕竟数组本身想完成这些操作还是挺麻烦的，有了这层封装，就方便多了。”在回答三妹的同时，我打开 Intellij IDEA，找到了 Arrays 类的源码。
“具体来说，数组操作可分为以下 9 种。”

创建数组
比较数组
数组排序
数组检索
数组转流
打印数组
数组转 List
setAll（没想好中文名）
parallelPrefix（没想好中文名）

“我们来一个一个学习。”
01、创建数组 
使用 Arrays 类创建数组可以通过以下三个方法：

copyOf，复制指定的数组，截取或用 null 填充
copyOfRange，复制指定范围内的数组到一个新的数组
fill，对数组进行填充

1）copyOf 
直接来看例子：
12345String[] intro &#x3D; new String[] { &quot;沉&quot;, &quot;默&quot;, &quot;王&quot;, &quot;二&quot; };String[] revised &#x3D; Arrays.copyOf(intro, 3);String[] expanded &#x3D; Arrays.copyOf(intro, 5);System.out.println(Arrays.toString(revised));System.out.println(Arrays.toString(expanded));
revised 和 expanded 是复制后的新数组，长度分别是 3 和 5，指定的数组长度是 4。来看一下输出结果：
12[沉, 默, 王][沉, 默, 王, 二, null]
看到没？revised 截取了最后一位，因为长度是 3 嘛；expanded 用 null 填充了一位，因为长度是 5。
ArrayList（内部的数据结构用的就是数组）源码中的 grow() 方法就调用了 copyOf() 方法：当 ArrayList 初始大小不满足元素的增长时就会扩容。
1234private Object[] grow(int minCapacity) {    return elementData &#x3D; Arrays.copyOf(elementData,            newCapacity(minCapacity));}
2）copyOfRange 
直接来看例子：
123String[] intro &#x3D; new String[] { &quot;沉&quot;, &quot;默&quot;, &quot;王&quot;, &quot;二&quot; };String[] abridgement &#x3D; Arrays.copyOfRange(intro, 0, 3);System.out.println(Arrays.toString(abridgement));
copyOfRange() 方法需要三个参数，第一个是指定的数组，第二个是起始位置（包含），第三个是截止位置（不包含）。来看一下输出结果：
1[沉, 默, 王]
0 的位置是“沉”，3 的位置是“二”，也就是说截取了从 0 位（包含）到 3 位（不包含）的数组元素。那假如说下标超出了数组的长度，会发生什么呢？
12String[] abridgementExpanded &#x3D; Arrays.copyOfRange(intro, 0, 6);System.out.println(Arrays.toString(abridgementExpanded));
结束位置此时为 6，超出了指定数组的长度 4，来看一下输出结果：
1[沉, 默, 王, 二, null, null]
仍然使用了 null 进行填充。
“为什么要这么做呢？”经过这段时间的学习，三妹的眼光越来越毒辣了，问的问题都恰到好处。
“嗯，我想是 Arrays 的设计者考虑到了数组越界的问题，不然每次调用 Arrays 类就要先判断很多次长度，很麻烦。”稍作思考后，我给出了这样一个回答。
3）fill 
直接来看例子：
123String[] stutter &#x3D; new String[4];Arrays.fill(stutter, &quot;沉默王二&quot;);System.out.println(Arrays.toString(stutter));
使用 new 关键字创建了一个长度为 4 的数组，然后使用 fill() 方法将 4 个位置填充为“沉默王二”，来看一下输出结果：
1[沉默王二, 沉默王二, 沉默王二, 沉默王二]
如果想要一个元素完全相同的数组时， fill() 方法就派上用场了。
02、比较数组 
Arrays 类的 equals() 方法用来判断两个数组是否相等，来看下面这个例子：
12345String[] intro &#x3D; new String[] { &quot;沉&quot;, &quot;默&quot;, &quot;王&quot;, &quot;二&quot; };boolean result &#x3D; Arrays.equals(new String[] { &quot;沉&quot;, &quot;默&quot;, &quot;王&quot;, &quot;二&quot; }, intro);System.out.println(result);boolean result1 &#x3D; Arrays.equals(new String[] { &quot;沉&quot;, &quot;默&quot;, &quot;王&quot;, &quot;三&quot; }, intro);System.out.println(result1);
输出结果如下所示：
12truefalse
指定的数组为沉默王二四个字，比较的数组一个是沉默王二，一个是沉默王三，所以 result 为 true，result1 为 false。
简单看一下 equals() 方法的源码：
1234567891011121314public static boolean equals(Object[] a, Object[] a2) {    if (a&#x3D;&#x3D;a2)        return true;    if (a&#x3D;&#x3D;null || a2&#x3D;&#x3D;null)        return false;    int length &#x3D; a.length;    if (a2.length !&#x3D; length)        return false;    for (int i&#x3D;0; i&lt;length; i++) {        if (!Objects.equals(a[i], a2[i]))            return false;    }    return true;}
因为数组是一个对象，所以先使用“\&#x3D;&#x3D;”操作符进行判断，如果不相等，再判断是否为 null，其中一个为 null，返回 false；紧接着判断 length，不等的话，返回 false；否则的话，依次调用 Objects.equals() 比较相同位置上的元素是否相等。
“这段代码还是非常严谨的，对吧？三妹，这也就是我们学习源码的意义，欣赏的同时，可以学习源码作者清晰的编码思路。”我语重心长地给三妹讲。
除了 equals() 方法，还有另外一个诀窍可以判断两个数组是否相等，尽管可能会出现误差。那就是 Arrays.hashCode() 方法，先来看一下该方法的源码：
12345678public static int hashCode(Object a[]) {    if (a &#x3D;&#x3D; null)        return 0;    int result &#x3D; 1;    for (Object element : a)        result &#x3D; 31 * result + (element &#x3D;&#x3D; null ? 0 : element.hashCode());    return result;}
哈希算法本身是非常严谨的，所以如果两个数组的哈希值相等，那几乎可以判断两个数组是相等的。
123String[] intro &#x3D; new String[] { &quot;沉&quot;, &quot;默&quot;, &quot;王&quot;, &quot;二&quot; };System.out.println(Arrays.hashCode(intro));System.out.println(Arrays.hashCode(new String[] { &quot;沉&quot;, &quot;默&quot;, &quot;王&quot;, &quot;二&quot; }));
来看一下输出结果：
12868681617868681617
两个数组的哈希值相等，毕竟元素是一样的。但这样确实不够严谨，优先使用 Objects.equals() 方法，当我们想快速确认两个数组是否相等时，可以通过比较 hashCode 来确认——算是投机取巧吧，高收益高风险，哈哈。
03、数组排序 
Arrays 类的 sort() 方法用来对数组进行排序，来看下面这个例子：
1234String[] intro1 &#x3D; new String[] { &quot;chen&quot;, &quot;mo&quot;, &quot;wang&quot;, &quot;er&quot; };String[] sorted &#x3D; Arrays.copyOf(intro1, 4);Arrays.sort(sorted);System.out.println(Arrays.toString(sorted));
由于排序会改变原有的数组，所以我们使用了 copyOf() 方法重新复制了一份。来看一下输出结果：
1[chen, er, mo, wang]
可以看得出，按照的是首字母的升序进行排列的。基本数据类型是按照双轴快速排序的，引用数据类型是按照 TimSort 排序的，使用了 Peter McIlroy 的“乐观排序和信息理论复杂性”中的技术。
“哥，你说的这些排序算法我都不太懂啊！”三妹眨巴眨巴眼睛说。
“不要紧的，后面学了数据结构与算法后，就明白了，现在了解这个东西即可。”我赶紧甩出了安抚大法。
04、数组检索 
数组排序后就可以使用 Arrays 类的 binarySearch() 方法进行二分查找了。否则的话，只能线性检索，效率就会低很多。
12345678String[] intro1 &#x3D; new String[] { &quot;chen&quot;, &quot;mo&quot;, &quot;wang&quot;, &quot;er&quot; };String[] sorted &#x3D; Arrays.copyOf(intro1, 4);Arrays.sort(sorted);int exact &#x3D; Arrays.binarySearch(sorted, &quot;wang&quot;);System.out.println(exact);int caseInsensitive &#x3D; Arrays.binarySearch(sorted, &quot;Wang&quot;, String::compareToIgnoreCase);System.out.println(caseInsensitive);
 binarySearch() 方法既可以精确检索，也可以模糊检索，比如说忽略大小写。来看一下输出结果：
1233
排序后的结果是 [chen, er, mo, wang] ，所以检索出来的下标是 3。
“三妹，记住了，以后如果要从数组或者集合中查找元素的话，尽量先排序，然后使用二分查找法，这样能提高检索的效率。”
三妹若有所思的点了点头。
05、数组转流 
“流是什么呀？”三妹好奇的问。
“流的英文单词是 Stream，它可以极大提高 Java 程序员的生产力，让程序员写出高效、干净、简洁的代码。 这种风格将要处理的集合看作是一种流，想象一下水流在管道中流过的样子，我们可以在管道中对流进行处理，比如筛选、排序等等。Stream 具体怎么使用，我们留到后面再详细地讲，这里你先有一个大致的印象就可以了。”我回答到。
Arrays 类的 stream() 方法可以将数组转换成流：
12String[] intro &#x3D; new String[] { &quot;沉&quot;, &quot;默&quot;, &quot;王&quot;, &quot;二&quot; };System.out.println(Arrays.stream(intro).count());
还可以为 stream() 方法指定起始下标和结束下标：
1System.out.println(Arrays.stream(intro, 1, 2).count());
如果下标的范围有误的时候，比如说从 2 到 1 结束，则程序会抛出 ArrayIndexOutOfBoundsException 异常：
123Exception in thread &quot;main&quot; java.lang.ArrayIndexOutOfBoundsException: origin(2) &gt; fence(1)    at java.base&#x2F;java.util.Spliterators.checkFromToBounds(Spliterators.java:387)
06、打印数组 
因为数组是一个对象，直接 System.out.println 的话，结果是这样的：
1[Ljava.lang.String;@3d075dc0
最优雅的打印方式，是使用 Arrays.toString() ，其实前面讲过。来看一下该方法的源码：
123456789101112131415public static String toString(Object[] a) {    if (a &#x3D;&#x3D; null)        return &quot;null&quot;;    int iMax &#x3D; a.length - 1;    if (iMax &#x3D;&#x3D; -1)        return &quot;[]&quot;;    StringBuilder b &#x3D; new StringBuilder();    b.append(&#39;[&#39;);    for (int i &#x3D; 0; ; i++) {        b.append(String.valueOf(a[i]));        if (i &#x3D;&#x3D; iMax)            return b.append(&#39;]&#39;).toString();        b.append(&quot;, &quot;);    }}

先判断 null，是的话，直接返回“null”字符串；
获取数组的长度，如果数组的长度为 0（ 等价于 length - 1 为 -1），返回中括号“[]”，表示数组为空的；
如果数组既不是 null，长度也不为 0，就声明 StringBuilder 对象，然后添加一个数组的开始标记“[”，之后再遍历数组，把每个元素添加进去；其中一个小技巧就是，当遇到末尾元素的时候（i &#x3D;&#x3D; iMax），不再添加逗号和空格“, ”，而是添加数组的闭合标记“]”。

“哥，我能不能问一个问题呀？”
“你问啊。”
“就是为什么判断数组长度为 0 的时候判断的是减 1 后比较 -1 呢？为什么不直接比较 0 呢？”
“呀，你这个问题问的很妙啊！”我想到三妹说一句“respect”，很强！“其实是和遍历数组的时候判断 i &#x3D;&#x3D; iMax 有关了，否则这里就要用 i &#x3D;&#x3D; iMax -1 来判断是否到达数组的最后一个元素了。”
“哦—————”三妹似乎明白了什么。
07、数组转 List 
尽管数组非常强大，但它自身可以操作的工具方法很少，比如说判断数组中是否包含某个值。如果能转成 List 的话，就简便多了，因为 Java 的集合框架 List 中封装了很多常用的方法。
123String[] intro &#x3D; new String[] { &quot;沉&quot;, &quot;默&quot;, &quot;王&quot;, &quot;二&quot; };List&lt;String&gt; rets &#x3D; Arrays.asList(intro);System.out.println(rets.contains(&quot;二&quot;));
不过需要注意的是， Arrays.asList() 返回的是 java.util.Arrays.ArrayList ，并不是 java.util.ArrayList ，它的长度是固定的，无法进行元素的删除或者添加。
12rets.add(&quot;三&quot;);rets.remove(&quot;二&quot;);
这个在编码的时候一定要注意，否则在执行这两个方法的时候，会抛出异常：
123Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException    at java.base&#x2F;java.util.AbstractList.add(AbstractList.java:153)    at java.base&#x2F;java.util.AbstractList.add(AbstractList.java:111)
要想操作元素的话，需要多一步转化，转成真正的 java.util.ArrayList ：
123List&lt;String&gt; rets1 &#x3D; new ArrayList&lt;&gt;(Arrays.asList(intro));rets1.add(&quot;三&quot;);rets1.remove(&quot;二&quot;);
08、setAll 
Java 8 新增了 setAll() 方法，它提供了一个函数式编程的入口，可以对数组的元素进行填充：
123int[] array &#x3D; new int[10];Arrays.setAll(array, i -&gt; i * 10);System.out.println(Arrays.toString(array));
“这段代码什么意思呢？”三妹问。
i 就相当于是数组的下标，值从 0 开始，到 9 结束，那么 i  10 就意味着值从 0  10 开始，到 9 * 10 结束，来看一下输出结果：
1[0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
可以用来为新数组填充基于原来数组的新元素。
09、parallelPrefix 
parallelPrefix() 方法和 setAll() 方法一样，也是 Java 8 之后提供的，提供了一个函数式编程的入口，通过遍历数组中的元素，将当前下标位置上的元素与它之前下标的元素进行操作，然后将操作后的结果覆盖当前下标位置上的元素。
123int[] arr &#x3D; new int[] { 1, 2, 3, 4};Arrays.parallelPrefix(arr, (left, right) -&gt; left + right);System.out.println(Arrays.toString(arr));
上面代码中有一个 Lambda 表达式（ (left, right) -&gt; left + right ），是什么意思呢？上面这段代码等同于：
123456int[] arr &#x3D; new int[]{1, 2, 3, 4};Arrays.parallelPrefix(arr, (left, right) -&gt; {    System.out.println(left + &quot;，&quot; + right);    return left + right;});System.out.println(Arrays.toString(arr));
来看一下输出结果就明白了：
12341，23，36，4[1, 3, 6, 10]
也就是说， Lambda 表达式执行了三次：

第一次是 1 和 2 相加，结果是 3，替换下标为 1 的位置
第二次是 3 和 3 相加，结果是 6，也就是第一次的结果和下标为 2 的元素相加的结果
第三次是 6 和 4 相加，结果是 10，也就是第二次的结果和下标为 3 的元素相加的结果

10、总结 
“好了，三妹，就先学到这吧。如果你以后翻 Java 源码的时候，只要是用到数组的，尤其是 ArrayList 类，就可以看到 Arrays 类的很多影子。”
“嗯嗯，我先复习一下这节的内容。哥，你去休息吧。”
7.3 StringUtils工具类字符串 （String）在我们的日常工作中，用得非常非常非常多。
在我们的代码中经常需要对字符串判空，截取字符串、转换大小写、分隔字符串、比较字符串、去掉多余空格、拼接字符串、使用正则表达式等等。
如果只用 String 类提供的那些方法，我们需要手写大量的额外代码，不然容易出现各种异常。
现在有个好消息是： org.apache.commons.lang3包下的 StringUtils工具类，给我们提供了非常丰富的选择。
Maven 坐标：
12345&lt;dependency&gt;    &lt;groupId&gt;org.apache.commons&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;commons-lang3&lt;&#x2F;artifactId&gt;    &lt;version&gt;3.12.0&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;
StringUtils 提供了非常多实用的方法，大概有下图的四页到五页，我只截了两页，实在是太多了。

接下来，我们来拿一些常用的方法举例说明。
字符串判空 
其实空字符串，不只是 null 一种，还有””，” “，”null”等等，多种情况。
StringUtils 给我们提供了多个判空的静态方法，例如：
1234567891011121314151617181920212223String str1 &#x3D; null;String str2 &#x3D; &quot;&quot;;String str3 &#x3D; &quot; &quot;;String str4 &#x3D; &quot;abc&quot;;System.out.println(StringUtils.isEmpty(str1));System.out.println(StringUtils.isEmpty(str2));System.out.println(StringUtils.isEmpty(str3));System.out.println(StringUtils.isEmpty(str4));System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);System.out.println(StringUtils.isNotEmpty(str1));System.out.println(StringUtils.isNotEmpty(str2));System.out.println(StringUtils.isNotEmpty(str3));System.out.println(StringUtils.isNotEmpty(str4));System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);System.out.println(StringUtils.isBlank(str1));System.out.println(StringUtils.isBlank(str2));System.out.println(StringUtils.isBlank(str3));System.out.println(StringUtils.isBlank(str4));System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);System.out.println(StringUtils.isNotBlank(str1));System.out.println(StringUtils.isNotBlank(str2));System.out.println(StringUtils.isNotBlank(str3));System.out.println(StringUtils.isNotBlank(str4));
执行结果：
12345678910111213141516171819truetruefalsefalse&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;falsefalsetruetrue&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;truetruetruefalse&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;falsefalsefalsetrue
示例中的： isEmpty 、 isNotEmpty 、 isBlank和 isNotBlank ，这 4 个判空方法你们可以根据实际情况使用。
优先推荐使用 isBlank和 isNotBlank方法，因为它会把 “ “也考虑进去。
分隔字符串 
分隔字符串是常见需求，如果直接使用 String 类的 split 方法，就可能会出现空指针异常。
123String str1 &#x3D; null;System.out.println(StringUtils.split(str1,&quot;,&quot;));System.out.println(str1.split(&quot;,&quot;));
执行结果：
123nullException in thread &quot;main&quot; java.lang.NullPointerException\tat com.sue.jump.service.test1.UtilTest.main(UtilTest.java:21)
使用 StringUtils 的 split 方法会返回 null，而使用 String 的 split 方法会报指针异常。
判断是否纯数字 
给定一个字符串，判断它是否为纯数字，可以使用 isNumeric方法。例如：
123456String str1 &#x3D; &quot;123&quot;;String str2 &#x3D; &quot;123q&quot;;String str3 &#x3D; &quot;0.33&quot;;System.out.println(StringUtils.isNumeric(str1));System.out.println(StringUtils.isNumeric(str2));System.out.println(StringUtils.isNumeric(str3));
执行结果：
123truefalsefalse
将集合拼接成字符串 
有时候，我们需要将某个集合的内容，拼接成一个字符串，然后输出，这时可以使用 join方法。例如：
1234List&lt;String&gt; list &#x3D; Lists.newArrayList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);List&lt;Integer&gt; list2 &#x3D; Lists.newArrayList(1, 2, 3);System.out.println(StringUtils.join(list, &quot;,&quot;));System.out.println(StringUtils.join(list2, &quot; &quot;));
执行结果：
12a,b,c1 2 3
其他方法 
这里再列举一些，其他的方法可以自己去研究一下。

trim(String str) ：去除字符串首尾的空白字符。
trimToEmpty(String str) ：去除字符串首尾的空白字符，如果字符串为 null，则返回空字符串。
trimToNull(String str) ：去除字符串首尾的空白字符，如果结果为空字符串，则返回 null。
equals(String str1, String str2) ：比较两个字符串是否相等。
equalsIgnoreCase(String str1, String str2) ：比较两个字符串是否相等，忽略大小写。
startsWith(String str, String prefix) ：检查字符串是否以指定的前缀开头。
endsWith(String str, String suffix) ：检查字符串是否以指定的后缀结尾。
contains(String str, CharSequence seq) ：检查字符串是否包含指定的字符序列。
indexOf(String str, CharSequence seq) ：返回指定字符序列在字符串中首次出现的索引，如果没有找到，则返回 -1。
lastIndexOf(String str, CharSequence seq) ：返回指定字符序列在字符串中最后一次出现的索引，如果没有找到，则返回 -1。
substring(String str, int start, int end) ：截取字符串中指定范围的子串。
replace(String str, String searchString, String replacement) ：替换字符串中所有出现的搜索字符串为指定的替换字符串。
replaceAll(String str, String regex, String replacement) ：使用正则表达式替换字符串中所有匹配的部分。
join(Iterable&lt;?&gt; iterable, String separator) ：使用指定的分隔符将可迭代对象中的元素连接为一个字符串。
split(String str, String separator) ：使用指定的分隔符将字符串分割为一个字符串数组。
capitalize(String str) ：将字符串的第一个字符转换为大写。
uncapitalize(String str) ：将字符串的第一个字符转换为小写。

7.4 Objects工具类Java 的 Objects 类是一个实用工具类，包含了一系列静态方法，用于处理对象。它位于 java.util 包中，自 Java 7 引入。Objects 类的主要目的是降低代码中的空指针异常 (NullPointerException) 风险，同时提供一些非常实用的方法供我们使用。
对象判空 
在 Java 中，万物皆对象，对象的判空可以说无处不在。Objects 的 isNull 方法用于判断对象是否为空，而 nonNull 方法判断对象是否不为空。例如：
1234567Integer integer &#x3D; new Integer(1);if (Objects.isNull(integer)) {    System.out.println(&quot;对象为空&quot;);}if (Objects.nonNull(integer)) {    System.out.println(&quot;对象不为空&quot;);}
对象为空时抛异常 
如果我们想在对象为空时，抛出空指针异常，可以使用 Objects 的 requireNonNull 方法。例如：
1234Integer integer1 &#x3D; new Integer(128);Objects.requireNonNull(integer1);Objects.requireNonNull(integer1, &quot;参数不能为空&quot;);Objects.requireNonNull(integer1, () -&gt; &quot;参数不能为空&quot;);
判断两个对象是否相等 
我们经常需要判断两个对象是否相等，Objects 给我们提供了 equals 方法，能非常方便的实现：
123Integer integer1 &#x3D; new Integer(1);Integer integer2 &#x3D; new Integer(1);System.out.println(Objects.equals(integer1, integer2));
执行结果：
1true
但使用这个方法有坑，比如例子改成：
123Integer integer1 &#x3D; new Integer(1);Long integer2 &#x3D; new Long(1);System.out.println(Objects.equals(integer1, integer2));
执行结果：
1false
不过，需要注意的是，虽然 Objects.equals() 方法本身是用来避免坑的，因为它可以处理 null 值的比较，而不会抛出空指针异常。然而，这并不意味着它没有任何潜在问题。实际上， Objects.equals() 方法的一个潜在问题是依赖于被比较对象的 equals() 方法实现。
当两个对象的类没有正确实现 equals() 方法时， Objects.equals() 方法可能会产生不符合预期的结果。举个例子：
123456789101112131415public class ObjectsDemo1 {    public static void main(String[] args) {        Person person1 &#x3D; new Person(&quot;沉默王二&quot;, 18);        Person person2 &#x3D; new Person(&quot;沉默王二&quot;, 18);        System.out.println(Objects.equals(person1, person2)); &#x2F;&#x2F; 输出：false    }}class Person {    String name;    int age;    Person(String name, int age) {        this.name &#x3D; name;        this.age &#x3D; age;    }}
在上面的例子中，我们创建了一个名为 Person 的类，但是没有重写 equals() 方法。然后我们创建了两个具有相同属性的 Person 对象，并使用 Objects.equals() 方法比较它们。尽管这两个对象的属性是相同的，但输出结果却是 false。这是因为 Objects.equals() 方法依赖于对象的 equals() 方法，而在这个例子中，Person 类没有正确地实现 equals() 方法，所以默认情况下会使用 Object 类的 equals() 方法，它只比较对象引用是否相同。
为了解决这个问题，我们需要在 Person 类中重写 equals() 方法：
1234567891011@Overridepublic boolean equals(Object obj) {    if (this &#x3D;&#x3D; obj) {        return true;    }    if (obj &#x3D;&#x3D; null || getClass() !&#x3D; obj.getClass()) {        return false;    }    Person person &#x3D; (Person) obj;    return age &#x3D;&#x3D; person.age &amp;&amp; Objects.equals(name, person.name);}
现在，当我们使用 Objects.equals() 方法比较两个具有相同属性的 Person 对象时，输出将是 true，符合我们的预期。
获取对象的hashCode 
如果你想获取某个对象的 hashCode，可以使用 Objects 的 hashCode 方法。例如：
12String str &#x3D; new String(&quot;沉默王二&quot;);System.out.println(Objects.hashCode(str));
执行结果：
1867758096
比较两个对象 
compare() 方法用于比较两个对象，通常用于自定义排序。它需要一个比较器 (Comparator) 作为参数。如果比较器为 null，则使用自然顺序。以下是一个 compare() 方法的示例：
12345678910111213141516171819class ObjectsCompareDemo {    public static void main(String[] args) {        PersonCompare person1 &#x3D; new PersonCompare(&quot;itwanger&quot;, 30);        PersonCompare person2 &#x3D; new PersonCompare(&quot;chenqingyang&quot;, 25);        Comparator&lt;PersonCompare&gt; ageComparator &#x3D; Comparator.comparingInt(p -&gt; p.age);        int ageComparisonResult &#x3D; Objects.compare(person1, person2, ageComparator);        System.out.println(&quot;年龄排序: &quot; + ageComparisonResult); &#x2F;&#x2F; 输出：1（表示 person1 的 age 在 person2 之后）    }}class PersonCompare {    String name;    int age;    PersonCompare(String name, int age) {        this.name &#x3D; name;        this.age &#x3D; age;    }}
比较两个数组 
deepEquals() 用于比较两个数组类型的对象，当对象是非数组的话，行为和 equals() 一致。
1234567891011int[] array1 &#x3D; {1, 2, 3};int[] array2 &#x3D; {1, 2, 3};int[] array3 &#x3D; {1, 2, 4};System.out.println(Objects.deepEquals(array1, array2)); &#x2F;&#x2F; 输出：true（因为 array1 和 array2 的内容相同）System.out.println(Objects.deepEquals(array1, array3)); &#x2F;&#x2F; 输出：false（因为 array1 和 array3 的内容不同）&#x2F;&#x2F; 对于非数组对象，deepEquals() 的行为与 equals() 相同String string1 &#x3D; &quot;hello&quot;;String string2 &#x3D; &quot;hello&quot;;String string3 &#x3D; &quot;world&quot;;System.out.println(Objects.deepEquals(string1, string2)); &#x2F;&#x2F; 输出：true（因为 string1 和 string2 相同）System.out.println(Objects.deepEquals(string1, string3)); &#x2F;&#x2F; 输出：false（因为 string1 和 string3 不同）
再来个二维数组的：
12345String[][] nestedArray1 &#x3D; {{&quot;A&quot;, &quot;B&quot;}, {&quot;C&quot;, &quot;D&quot;}};String[][] nestedArray2 &#x3D; {{&quot;A&quot;, &quot;B&quot;}, {&quot;C&quot;, &quot;D&quot;}};String[][] nestedArray3 &#x3D; {{&quot;A&quot;, &quot;B&quot;}, {&quot;C&quot;, &quot;E&quot;}};System.out.println(Objects.deepEquals(nestedArray1, nestedArray2)); &#x2F;&#x2F; 输出：true (因为嵌套数组元素相同)System.out.println(Objects.deepEquals(nestedArray1, nestedArray3)); &#x2F;&#x2F; 输出：false (因为嵌套数组元素不同)
小结 
除了上面提到的这些方法，Objects 还提供了一些其他的方法，比如说 toString，感兴趣的话可以试一下。

总之，Objects 类提供的这些方法在许多情况下还是非常有用得，可以简化代码并减少出错的可能性。
7.5 Collections工具类Collections 是 JDK 提供的一个工具类，位于 java.util 包下，提供了一系列的静态方法，方便我们对集合进行各种骚操作，算是集合框架的一个大管家。
还记得我们前面讲过的 Arrays 工具类吗？可以回去温习下。
Collections 的用法很简单，在 Intellij IDEA 中敲完 Collections. 之后就可以看到它提供的方法了，大致看一下方法名和参数就能知道这个方法是干嘛的。

为了节省大家的学习时间，我将这些方法做了一些分类，并列举了一些简单的例子。
01、排序操作 

reverse(List list) ：反转顺序
shuffle(List list) ：洗牌，将顺序打乱
sort(List list) ：自然升序
sort(List list, Comparator c) ：按照自定义的比较器排序
swap(List list, int i, int j) ：将 i 和 j 位置的元素交换位置

来看例子：
12345678910111213141516171819List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();list.add(&quot;沉默王二&quot;);list.add(&quot;沉默王三&quot;);list.add(&quot;沉默王四&quot;);list.add(&quot;沉默王五&quot;);list.add(&quot;沉默王六&quot;);System.out.println(&quot;原始顺序：&quot; + list);&#x2F;&#x2F; 反转Collections.reverse(list);System.out.println(&quot;反转后：&quot; + list);&#x2F;&#x2F; 洗牌Collections.shuffle(list);System.out.println(&quot;洗牌后：&quot; + list);&#x2F;&#x2F; 自然升序Collections.sort(list);System.out.println(&quot;自然升序后：&quot; + list);&#x2F;&#x2F; 交换Collections.swap(list, 2,4);System.out.println(&quot;交换后：&quot; + list);
输出后：
12345原始顺序：[沉默王二, 沉默王三, 沉默王四, 沉默王五, 沉默王六]反转后：[沉默王六, 沉默王五, 沉默王四, 沉默王三, 沉默王二]洗牌后：[沉默王五, 沉默王二, 沉默王六, 沉默王三, 沉默王四]自然升序后：[沉默王三, 沉默王二, 沉默王五, 沉默王六, 沉默王四]交换后：[沉默王三, 沉默王二, 沉默王四, 沉默王六, 沉默王五]
02、查找操作 

binarySearch(List list, Object key) ：二分查找法，前提是 List 已经排序过了
max(Collection coll) ：返回最大元素
max(Collection coll, Comparator comp) ：根据自定义比较器，返回最大元素
min(Collection coll) ：返回最小元素
min(Collection coll, Comparator comp) ：根据自定义比较器，返回最小元素
fill(List list, Object obj) ：使用指定对象填充
frequency(Collection c, Object o) ：返回指定对象出现的次数

来看例子：
123456789101112System.out.println(&quot;最大元素：&quot; + Collections.max(list));System.out.println(&quot;最小元素：&quot; + Collections.min(list));System.out.println(&quot;出现的次数：&quot; + Collections.frequency(list, &quot;沉默王二&quot;));&#x2F;&#x2F; 没有排序直接调用二分查找，结果是不确定的System.out.println(&quot;排序前的二分查找结果：&quot; + Collections.binarySearch(list, &quot;沉默王二&quot;));Collections.sort(list);&#x2F;&#x2F; 排序后，查找结果和预期一致System.out.println(&quot;排序后的二分查找结果：&quot; + Collections.binarySearch(list, &quot;沉默王二&quot;));Collections.fill(list, &quot;沉默王八&quot;);System.out.println(&quot;填充后的结果：&quot; + list);
输出后：
1234567原始顺序：[沉默王二, 沉默王三, 沉默王四, 沉默王五, 沉默王六]最大元素：沉默王四最小元素：沉默王三出现的次数：1排序前的二分查找结果：0排序后的二分查找结果：1填充后的结果：[沉默王八, 沉默王八, 沉默王八, 沉默王八, 沉默王八]
03、同步控制 
HashMap 是线程不安全的，这个我们前面讲到了。那其实 ArrayList 也是线程不安全的，没法在多线程环境下使用，那 Collections 工具类中提供了多个 synchronizedXxx 方法，这些方法会返回一个同步的对象，从而解决多线程中访问集合时的安全问题。

使用起来也非常的简单：
1SynchronizedList synchronizedList &#x3D; Collections.synchronizedList(list);
看一眼 SynchronizedList 的源码就明白了，不过是在方法里面使用 synchronized 关键字加了一层锁而已。
123456789101112131415161718192021222324252627static class SynchronizedList&lt;E&gt;    extends SynchronizedCollection&lt;E&gt;    implements List&lt;E&gt; {    private static final long serialVersionUID &#x3D; -7754090372962971524L;    final List&lt;E&gt; list;    SynchronizedList(List&lt;E&gt; list) {        super(list); &#x2F;&#x2F; 调用父类 SynchronizedCollection 的构造方法，传入 list        this.list &#x3D; list; &#x2F;&#x2F; 初始化成员变量 list    }    &#x2F;&#x2F; 获取指定索引处的元素    public E get(int index) {        synchronized (mutex) {return list.get(index);} &#x2F;&#x2F; 加锁，调用 list 的 get 方法获取元素    }        &#x2F;&#x2F; 在指定索引处插入指定元素    public void add(int index, E element) {        synchronized (mutex) {list.add(index, element);} &#x2F;&#x2F; 加锁，调用 list 的 add 方法插入元素    }        &#x2F;&#x2F; 移除指定索引处的元素    public E remove(int index) {        synchronized (mutex) {return list.remove(index);} &#x2F;&#x2F; 加锁，调用 list 的 remove 方法移除元素    }}
那这样的话，其实效率和那些直接在方法上加 synchronized 关键字的 Vector、Hashtable 差不多（JDK 1.0 时期就有了），而这些集合类基本上已经废弃了，几乎不怎么用。
1234567891011121314151617181920212223public class Vector&lt;E&gt;    extends AbstractList&lt;E&gt;    implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable{    &#x2F;&#x2F; 获取指定索引处的元素    public synchronized E get(int index) {        if (index &gt;&#x3D; elementCount) &#x2F;&#x2F; 如果索引超出了列表的大小，则抛出数组下标越界异常            throw new ArrayIndexOutOfBoundsException(index);        return elementData(index); &#x2F;&#x2F; 返回指定索引处的元素    }    &#x2F;&#x2F; 移除指定索引处的元素    public synchronized E remove(int index) {        modCount++; &#x2F;&#x2F; 修改计数器，标识列表已被修改        if (index &gt;&#x3D; elementCount) &#x2F;&#x2F; 如果索引超出了列表的大小，则抛出数组下标越界异常            throw new ArrayIndexOutOfBoundsException(index);        E oldValue &#x3D; elementData(index); &#x2F;&#x2F; 获取指定索引处的元素        int numMoved &#x3D; elementCount - index - 1; &#x2F;&#x2F; 计算需要移动的元素个数        if (numMoved &gt; 0) &#x2F;&#x2F; 如果需要移动元素            System.arraycopy(elementData, index+1, elementData, index,numMoved); &#x2F;&#x2F; 将数组中的元素向左移动一位        elementData[--elementCount] &#x3D; null; &#x2F;&#x2F; 将最后一个元素设置为 null，等待垃圾回收        return oldValue; &#x2F;&#x2F; 返回被移除的元素    }}
正确的做法是使用并发包下的 CopyOnWriteArrayList、ConcurrentHashMap。这些我们放到并发编程时再讲。
04、不可变集合 

emptyXxx() ：制造一个空的不可变集合
singletonXxx() ：制造一个只有一个元素的不可变集合
unmodifiableXxx() ：为指定集合制作一个不可变集合

举个例子：
123List emptyList &#x3D; Collections.emptyList();emptyList.add(&quot;非空&quot;);System.out.println(emptyList);
这段代码在执行的时候就抛出错误了。
1234Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException    at java.util.AbstractList.add(AbstractList.java:148)    at java.util.AbstractList.add(AbstractList.java:108)    at com.itwanger.s64.Demo.main(Demo.java:61)
这是因为 Collections.emptyList() 会返回一个 Collections 的内部类 EmptyList，而 EmptyList 并没有重写父类 AbstractList 的 add(int index, E element) 方法，所以执行的时候就抛出了不支持该操作的 UnsupportedOperationException 了。
这是从分析 add 方法源码得出的原因。除此之外，emptyList 方法是 final 的，返回的 EMPTY_LIST 也是 final 的，种种迹象表明 emptyList 返回的就是不可变对象，没法进行增伤改查。     
1234public static final &lt;T&gt; List&lt;T&gt; emptyList() {    return (List&lt;T&gt;) EMPTY_LIST;}public static final List EMPTY_LIST &#x3D; new EmptyList&lt;&gt;();
05、其他 
还有两个方法比较常用：

addAll(Collection&lt;? super T&gt; c, T… elements) ，往集合中添加元素
disjoint(Collection&lt;?&gt; c1, Collection&lt;?&gt; c2) ，判断两个集合是否没有交集

举个例子：
1234List&lt;String&gt; allList &#x3D; new ArrayList&lt;&gt;();Collections.addAll(allList, &quot;沉默王九&quot;,&quot;沉默王十&quot;,&quot;沉默王二&quot;);System.out.println(&quot;addAll 后：&quot; + allList);System.out.println(&quot;是否没有交集：&quot; + (Collections.disjoint(list, allList) ? &quot;是&quot; : &quot;否&quot;));
输出后：
123原始顺序：[沉默王二, 沉默王三, 沉默王四, 沉默王五, 沉默王六]addAll 后：[沉默王九, 沉默王十, 沉默王二]是否没有交集：否
06、CollectionUtils：Spring 和 Apache 都有提供的集合工具类 
对集合操作，除了前面说的 JDK 原生 Collections 工具类， CollectionUtils工具类也很常用。
目前比较主流的是 Spring的 org.springframework.util包下的 CollectionUtils 工具类。

和 Apache的 org.apache.commons.collections包下的 CollectionUtils 工具类。

Maven 坐标如下：
12345&lt;dependency&gt;    &lt;groupId&gt;org.apache.commons&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;commons-collections4&lt;&#x2F;artifactId&gt;    &lt;version&gt;4.4&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;
Apache 的方法比 Spring 的更多一些，我们就以 Apache 的为例，来介绍一下常用的方法。
集合判空 
通过 CollectionUtils 工具类的 isEmpty方法可以轻松判断集合是否为空， isNotEmpty方法判断集合不为空。
12345678910List&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();list.add(2);list.add(1);list.add(3);if (CollectionUtils.isEmpty(list)) {    System.out.println(&quot;集合为空&quot;);}if (CollectionUtils.isNotEmpty(list)) {    System.out.println(&quot;集合不为空&quot;);}
对两个集合进行操作 
有时候我们需要对已有的两个集合进行操作，比如取交集或者并集等。
12345678910111213141516171819List&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();list.add(2);list.add(1);list.add(3);List&lt;Integer&gt; list2 &#x3D; new ArrayList&lt;&gt;();list2.add(2);list2.add(4);&#x2F;&#x2F;获取并集Collection&lt;Integer&gt; unionList &#x3D; CollectionUtils.union(list, list2);System.out.println(unionList);&#x2F;&#x2F;获取交集Collection&lt;Integer&gt; intersectionList &#x3D; CollectionUtils.intersection(list, list2);System.out.println(intersectionList);&#x2F;&#x2F;获取交集的补集Collection&lt;Integer&gt; disjunctionList &#x3D; CollectionUtils.disjunction(list, list2);System.out.println(disjunctionList);&#x2F;&#x2F;获取差集Collection&lt;Integer&gt; subtractList &#x3D; CollectionUtils.subtract(list, list2);System.out.println(subtractList);
执行结果：
1234[1, 2, 3, 4][2][1, 3, 4][1, 3]
说句实话，对两个集合的操作，在实际工作中用得挺多的，特别是很多批量的场景中。以前我们需要写一堆代码，但没想到有现成的轮子。
07、小结 
整体上，Collections 工具类作为集合框架的大管家，提供了一些非常便利的方法供我们调用，也非常容易掌握，没什么难点，看看方法的注释就能大致明白干嘛的。
不过，工具就放在那里，用是一回事，为什么要这么用就是另外一回事了。能不能提高自己的编码水平，很大程度上取决于你到底有没有去钻一钻源码，看这些设计 JDK 的大师们是如何写代码的，学会一招半式，在工作当中还是能很快脱颖而出的。
恐怕 JDK 的设计者是这个世界上最好的老师了，文档写得不能再详细了，代码写得不能再优雅了，基本上都达到了性能上的极致。
可能有人会说，工具类没什么鸟用，不过是调用下方法而已，但这就大错特错了：如果要你来写，你能写出来 Collections 这样一个工具类吗？
这才是高手要思考的一个问题。
7.6 Hutool工具类库读者群里有个小伙伴感慨说，“Hutool 这款开源类库太厉害了，基本上该有该的工具类，它里面都有。”讲真的，我平常工作中也经常用 Hutool，它确实可以帮助我们简化每一行代码，使 Java 拥有函数式语言般的优雅，让 Java 语言变得“甜甜的”。
Hutool 的作者在官网上说，Hutool 是 Hu+tool 的自造词（好像不用说，我们也能猜得到），“Hu”用来致敬他的“前任”公司，“tool”就是工具的意思，谐音就有意思了，“糊涂”，寓意追求“万事都作糊涂观，无所谓失，无所谓得”（一个开源类库，上升到了哲学的高度，作者厉害了）。
看了一下开发团队的一个成员介绍，一个 Java 后端工具的作者竟然爱前端、爱数码，爱美女，嗯嗯嗯，确实“难得糊涂”（手动狗头）。
废话就说到这，来吧，实操走起！
01、引入 Hutool 
Maven 项目只需要在 pom.xml 文件中添加以下依赖即可。
12345&lt;dependency&gt;    &lt;groupId&gt;cn.hutool&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;hutool-all&lt;&#x2F;artifactId&gt;    &lt;version&gt;5.4.3&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;
Hutool 的设计思想是尽量减少重复的定义，让项目中的 util 包尽量少。一个好的轮子可以在很大程度上避免“复制粘贴”，从而节省我们开发人员对项目中公用类库和公用工具方法的封装时间。同时呢，成熟的开源库也可以最大限度的避免封装不完善带来的 bug。
就像作者在官网上说的那样：

以前，我们打开搜索引擎 -&gt; 搜“Java MD5 加密” -&gt; 打开某篇博客 -&gt; 复制粘贴 -&gt; 改改，变得好用些
有了 Hutool 以后呢，引入 Hutool -&gt; 直接 SecureUtil.md5()

Hutool 对不仅对 JDK 底层的文件、流、加密解密、转码、正则、线程、XML等做了封装，还提供了以下这些组件：

非常多，非常全面，鉴于此，我只挑选一些我喜欢的来介绍下（偷偷地告诉你，我就是想偷懒）。
02、类型转换 
类型转换在 Java 开发中很常见，尤其是从 HttpRequest 中获取参数的时候，前端传递的是整型，但后端只能先获取到字符串，然后再调用 parseXXX() 方法进行转换，还要加上判空，很繁琐。
Hutool 的 Convert 类可以简化这个操作，可以将任意可能的类型转换为指定类型，同时第二个参数 defaultValue 可用于在转换失败时返回一个默认值。
123String param &#x3D; &quot;10&quot;;int paramInt &#x3D; Convert.toInt(param);int paramIntDefault &#x3D; Convert.toInt(param, 0);
把字符串转换成日期：
12String dateStr &#x3D; &quot;2020年09月29日&quot;;Date date &#x3D; Convert.toDate(dateStr);
把字符串转成 Unicode：
12String unicodeStr &#x3D; &quot;沉默王二&quot;;String unicode &#x3D; Convert.strToUnicode(unicodeStr);
03、日期时间 
JDK 自带的 Date 和 Calendar 不太好用，Hutool 封装的 DateUtil 用起来就舒服多了！
获取当前日期：
1Date date &#x3D; DateUtil.date();
DateUtil.date() 返回的其实是 DateTime，它继承自 Date 对象，重写了 toString() 方法，返回 yyyy-MM-dd HH:mm:ss 格式的字符串。
有些小伙伴是不是想看看我写这篇文章的时间，输出一下给大家看看：
1System.out.println(date);&#x2F;&#x2F; 2020-09-29 04:28:02
字符串转日期：
12String dateStr &#x3D; &quot;2020-09-29&quot;;Date date &#x3D; DateUtil.parse(dateStr);
DateUtil.parse() 会自动识别一些常用的格式，比如说：

yyyy-MM-dd HH:mm:ss
yyyy-MM-dd
HH:mm:ss
yyyy-MM-dd HH:mm
yyyy-MM-dd HH:mm:ss.SSS

还可以识别带中文的：

年月日时分秒

格式化时间差：
12345678String dateStr1 &#x3D; &quot;2020-09-29 22:33:23&quot;;Date date1 &#x3D; DateUtil.parse(dateStr1);String dateStr2 &#x3D; &quot;2020-10-01 23:34:27&quot;;Date date2 &#x3D; DateUtil.parse(dateStr2);long betweenDay &#x3D; DateUtil.between(date1, date2, DateUnit.MS);&#x2F;&#x2F; 输出：2天1小时1分4秒String formatBetween &#x3D; DateUtil.formatBetween(betweenDay, BetweenFormater.Level.SECOND);
星座和属相：
1234&#x2F;&#x2F; 射手座String zodiac &#x3D; DateUtil.getZodiac(Month.DECEMBER.getValue(), 10);&#x2F;&#x2F; 蛇String chineseZodiac &#x3D; DateUtil.getChineseZodiac(1989);
04、IO 流相关 
IO 操作包括读和写，应用的场景主要包括网络操作和文件操作，原生的 Java 类库区分字符流和字节流，字节流 InputStream 和 OutputStream 就有很多很多种，使用起来让人头皮发麻。
Hutool 封装了流操作工具类 IoUtil、文件读写操作工具类 FileUtil、文件类型判断工具类 FileTypeUtil 等等。
123BufferedInputStream in &#x3D; FileUtil.getInputStream(&quot;hutool&#x2F;origin.txt&quot;);BufferedOutputStream out &#x3D; FileUtil.getOutputStream(&quot;hutool&#x2F;to.txt&quot;);long copySize &#x3D; IoUtil.copy(in, out, IoUtil.DEFAULT_BUFFER_SIZE);
在 IO 操作中，文件的操作相对来说是比较复杂的，但使用频率也很高，几乎所有的项目中都躺着一个叫 FileUtil 或者 FileUtils 的工具类。Hutool 的 FileUtil 类包含以下几类操作：

文件操作：包括文件目录的新建、删除、复制、移动、改名等
文件判断：判断文件或目录是否非空，是否为目录，是否为文件等等
绝对路径：针对 ClassPath 中的文件转换为绝对路径文件
文件名：主文件名，扩展名的获取
读操作：包括 getReader、readXXX 操作
写操作：包括 getWriter、writeXXX 操作

顺带说说 classpath。
在实际编码当中，我们通常需要从某些文件里面读取一些数据，比如配置文件、文本文件、图片等等，那这些文件通常放在什么位置呢？

放在项目结构图中的 resources 目录下，当项目编译后，会出现在 classes 目录下。对应磁盘上的目录如下图所示：

当我们要读取文件的时候，我是不建议使用绝对路径的，因为操作系统不一样的话，文件的路径标识符也是不一样的。最好使用相对路径。
假设在 src&#x2F;resources 下放了一个文件 origin.txt，文件的路径参数如下所示：
1FileUtil.getInputStream(&quot;origin.txt&quot;)
假设文件放在 src&#x2F;resources&#x2F;hutool 目录下，则路径参数改为：
1FileUtil.getInputStream(&quot;hutool&#x2F;origin.txt&quot;)
05、字符串工具 
Hutool 封装的字符串工具类 StrUtil 和 Apache Commons Lang 包中的 StringUtils 类似，作者认为优势在于 Str 比 String 短，尽管我不觉得。不过，我倒是挺喜欢其中的一个方法的：
123String template &#x3D; &quot;{}，一枚沉默但有趣的程序员，喜欢他的文章的话，请微信搜索{}&quot;;String str &#x3D; StrUtil.format(template, &quot;沉默王二&quot;, &quot;沉默王二&quot;);&#x2F;&#x2F; 沉默王二，一枚沉默但有趣的程序员，喜欢他的文章的话，请微信搜索沉默王二
06、反射工具 
反射机制可以让 Java 变得更加灵活，因此在某些情况下，反射可以做到事半功倍的效果。Hutool 封装的反射工具 ReflectUtil 包括：

获取构造方法
获取字段
获取字段值
获取方法
执行方法（对象方法和静态方法）

1234567891011121314151617181920212223242526272829303132333435363738package com.itwanger.hutool.reflect;import cn.hutool.core.util.ReflectUtil;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;public class ReflectDemo {    private int id;    public ReflectDemo() {        System.out.println(&quot;构造方法&quot;);    }    public void print() {        System.out.println(&quot;我是沉默王二&quot;);    }    public static void main(String[] args) throws IllegalAccessException {        &#x2F;&#x2F; 构建对象        ReflectDemo reflectDemo &#x3D; ReflectUtil.newInstance(ReflectDemo.class);        &#x2F;&#x2F; 获取构造方法        Constructor[] constructors &#x3D; ReflectUtil.getConstructors(ReflectDemo.class);        for (Constructor constructor : constructors) {            System.out.println(constructor.getName());        }        &#x2F;&#x2F; 获取字段        Field field &#x3D; ReflectUtil.getField(ReflectDemo.class, &quot;id&quot;);        field.setInt(reflectDemo, 10);        &#x2F;&#x2F; 获取字段值        System.out.println(ReflectUtil.getFieldValue(reflectDemo, field));        &#x2F;&#x2F; 获取所有方法        Method[] methods &#x3D; ReflectUtil.getMethods(ReflectDemo.class);        for (Method m : methods) {            System.out.println(m.getName());        }        &#x2F;&#x2F; 获取指定方法        Method method &#x3D; ReflectUtil.getMethod(ReflectDemo.class, &quot;print&quot;);        System.out.println(method.getName());        &#x2F;&#x2F; 执行方法        ReflectUtil.invoke(reflectDemo, &quot;print&quot;);    }}
07、压缩工具 
在 Java 中，对文件、文件夹打包压缩是一件很繁琐的事情，Hutool 封装的 ZipUtil 针对 java.util.zip 包做了优化，可以使用一个方法搞定压缩和解压，并且自动处理文件和目录的问题，不再需要用户判断，大大简化的压缩解压的复杂度。
12ZipUtil.zip(&quot;hutool&quot;, &quot;hutool.zip&quot;);File unzip &#x3D; ZipUtil.unzip(&quot;hutool.zip&quot;, &quot;hutoolzip&quot;);
08、身份证工具 
Hutool 封装的 IdcardUtil 可以用来对身份证进行验证，支持大陆 15 位、18 位身份证，港澳台 10 位身份证。
1234String ID_18 &#x3D; &quot;321083197812162119&quot;;String ID_15 &#x3D; &quot;150102880730303&quot;;boolean valid &#x3D; IdcardUtil.isValidCard(ID_18);boolean valid15 &#x3D; IdcardUtil.isValidCard(ID_15);
09、扩展 HashMap 
Java 中的 HashMap 是强类型的，而 Hutool 封装的 Dict 对键的类型要求没那么严格。
123456Dict dict &#x3D; Dict.create()        .set(&quot;age&quot;, 18)        .set(&quot;name&quot;, &quot;沉默王二&quot;)        .set(&quot;birthday&quot;, DateTime.now());int age &#x3D; dict.getInt(&quot;age&quot;);String name &#x3D; dict.getStr(&quot;name&quot;);
10、控制台打印 
本地编码的过程中，经常需要使用 System.out 打印结果，但是往往一些复杂的对象不支持直接打印，比如说数组，需要调用 Arrays.toString 。Hutool 封装的 Console 类借鉴了 JavaScript 中的 console.log() ，使得打印变成了一个非常便捷的方式。
1234567891011public class ConsoleDemo {    public static void main(String[] args) {        &#x2F;&#x2F; 打印字符串        Console.log(&quot;沉默王二，一枚有趣的程序员&quot;);        &#x2F;&#x2F; 打印字符串模板        Console.log(&quot;洛阳是{}朝古都&quot;,13);        int [] ints &#x3D; {1,2,3,4};        &#x2F;&#x2F; 打印数组        Console.log(ints);    }}
11、字段验证器 
做 Web 开发的时候，后端通常需要对表单提交过来的数据进行验证。Hutool 封装的 Validator 可以进行很多有效的条件验证：

是不是邮箱
是不是 IP V4、V6
是不是电话号码
等等


12Validator.isEmail(&quot;沉默王二&quot;);Validator.isMobile(&quot;itwanger.com&quot;);
12、双向查找 Map 
Guava 中提供了一种特殊的 Map 结构，叫做 BiMap，实现了一种双向查找的功能，可以根据 key 查找 value，也可以根据 value 查找 key，Hutool 也提供这种 Map 结构。
123456789BiMap&lt;String, String&gt; biMap &#x3D; new BiMap&lt;&gt;(new HashMap&lt;&gt;());biMap.put(&quot;wanger&quot;, &quot;沉默王二&quot;);biMap.put(&quot;wangsan&quot;, &quot;沉默王三&quot;);&#x2F;&#x2F; get value by keybiMap.get(&quot;wanger&quot;);biMap.get(&quot;wangsan&quot;);&#x2F;&#x2F; get key by valuebiMap.getKey(&quot;沉默王二&quot;);biMap.getKey(&quot;沉默王三&quot;);
在实际的开发工作中，其实我更倾向于使用 Guava 的 BiMap，而不是 Hutool 的。这里提一下，主要是我发现了 Hutool 在线文档上的一处错误，提了个 issue（从中可以看出我一颗一丝不苟的心和一双清澈明亮的大眼睛啊）。

13、图片工具 
Hutool 封装的 ImgUtil 可以对图片进行缩放、裁剪、转为黑白、加水印等操作。
缩放图片：
12345ImgUtil.scale(        FileUtil.file(&quot;hutool&#x2F;wangsan.jpg&quot;),        FileUtil.file(&quot;hutool&#x2F;wangsan_small.jpg&quot;),        0.5f);
裁剪图片：
12345ImgUtil.cut(        FileUtil.file(&quot;hutool&#x2F;wangsan.jpg&quot;),        FileUtil.file(&quot;hutool&#x2F;wangsan_cut.jpg&quot;),        new Rectangle(200, 200, 100, 100));
添加水印：
123456789ImgUtil.pressText(&#x2F;&#x2F;        FileUtil.file(&quot;hutool&#x2F;wangsan.jpg&quot;),        FileUtil.file(&quot;hutool&#x2F;wangsan_logo.jpg&quot;),        &quot;沉默王二&quot;, Color.WHITE,        new Font(&quot;黑体&quot;, Font.BOLD, 100),        0,        0,        0.8f);
14、配置文件 

众所周知，Java 中广泛应用的配置文件 Properties 存在一个特别大的诟病：不支持中文。每次使用时，如果想存放中文字符，就必须借助 IDE 相关插件才能转为 Unicode 符号，而这种反人类的符号在命令行下根本没法看。

于是，Hutool 的 Setting 运用而生。Setting 除了兼容 Properties 文件格式外，还提供了一些特有功能，这些功能包括：

各种编码方式支持
变量支持
分组支持

先整个配置文件 example.setting，内容如下：
12name&#x3D;沉默王二age&#x3D;18
再来读取和更新配置文件：
12345678910111213public class SettingDemo {    private final static String SETTING &#x3D; &quot;hutool&#x2F;example.setting&quot;;    public static void main(String[] args) {        &#x2F;&#x2F; 初始化 Setting        Setting setting &#x3D; new Setting(SETTING);        &#x2F;&#x2F; 读取        setting.getStr(&quot;name&quot;, &quot;沉默王二&quot;);        &#x2F;&#x2F; 在配置文件变更时自动加载        setting.autoLoad(true);        &#x2F;&#x2F; 通过代码方式增加键值对        setting.set(&quot;birthday&quot;, &quot;2020年09月29日&quot;);        setting.store(SETTING);   
15、日志工厂 
Hutool 封装的日志工厂 LogFactory 兼容了各大日志框架，使用起来也非常简便。
123456public class LogDemo {    private static final Log log &#x3D; LogFactory.get();    public static void main(String[] args) {        log.debug(&quot;难得糊涂&quot;);    }}
先通过 LogFactory.get() 自动识别引入的日志框架，从而创建对应日志框架的门面 Log 对象，然后调用 debug() 、 info() 等方法输出日志。
如果不想创建 Log 对象的话，可以使用 StaticLog，顾名思义，一个提供了静态方法的日志类。
1StaticLog.info(&quot;爽啊 {}.&quot;, &quot;沉默王二的文章&quot;);
16、缓存工具 
CacheUtil 是 Hutool 封装的创建缓存的快捷工具类，可以创建不同的缓存对象：

FIFOCache：先入先出，元素不停的加入缓存直到缓存满为止，当缓存满时，清理过期缓存对象，清理后依旧满则删除先入的缓存。

1234567Cache&lt;String, String&gt; fifoCache &#x3D; CacheUtil.newFIFOCache(3);fifoCache.put(&quot;key1&quot;, &quot;沉默王一&quot;);fifoCache.put(&quot;key2&quot;, &quot;沉默王二&quot;);fifoCache.put(&quot;key3&quot;, &quot;沉默王三&quot;);fifoCache.put(&quot;key4&quot;, &quot;沉默王四&quot;);&#x2F;&#x2F; 大小为 3，所以 key3 放入后 key1 被清除String value1 &#x3D; fifoCache.get(&quot;key1&quot;);

LFUCache，最少使用，根据使用次数来判定对象是否被持续缓存，当缓存满时清理过期对象，清理后依旧满的情况下清除最少访问的对象并将其他对象的访问数减去这个最少访问数，以便新对象进入后可以公平计数。

12345678910Cache&lt;String, String&gt; lfuCache &#x3D; CacheUtil.newLFUCache(3);lfuCache.put(&quot;key1&quot;, &quot;沉默王一&quot;);&#x2F;&#x2F; 使用次数+1lfuCache.get(&quot;key1&quot;);lfuCache.put(&quot;key2&quot;, &quot;沉默王二&quot;);lfuCache.put(&quot;key3&quot;, &quot;沉默王三&quot;);lfuCache.put(&quot;key4&quot;, &quot;沉默王四&quot;);&#x2F;&#x2F; 由于缓存容量只有 3，当加入第 4 个元素的时候，最少使用的将被移除（2,3被移除）String value2 &#x3D; lfuCache.get(&quot;key2&quot;);String value3 &#x3D; lfuCache.get(&quot;key3&quot;);

LRUCache，最近最久未使用，根据使用时间来判定对象是否被持续缓存，当对象被访问时放入缓存，当缓存满了，最久未被使用的对象将被移除。

12345678910Cache&lt;String, String&gt; lruCache &#x3D; CacheUtil.newLRUCache(3);lruCache.put(&quot;key1&quot;, &quot;沉默王一&quot;);lruCache.put(&quot;key2&quot;, &quot;沉默王二&quot;);lruCache.put(&quot;key3&quot;, &quot;沉默王三&quot;);&#x2F;&#x2F; 使用时间近了lruCache.get(&quot;key1&quot;);lruCache.put(&quot;key4&quot;, &quot;沉默王四&quot;);&#x2F;&#x2F; 由于缓存容量只有 3，当加入第 4 个元素的时候，最久使用的将被移除（2）String value2 &#x3D; lruCache.get(&quot;key2&quot;);System.out.println(value2);
17、加密解密 
加密分为三种：

对称加密（symmetric），例如：AES、DES 等
非对称加密（asymmetric），例如：RSA、DSA 等
摘要加密（digest），例如：MD5、SHA-1、SHA-256、HMAC 等

Hutool 针对这三种情况都做了封装：

对称加密 SymmetricCrypto
非对称加密 AsymmetricCrypto
摘要加密 Digester

快速加密工具类 SecureUtil 有以下这些方法：
1）对称加密

SecureUtil.aes
SecureUtil.des

2）非对称加密

SecureUtil.rsa
SecureUtil.dsa

3）摘要加密

SecureUtil.md5
SecureUtil.sha1
SecureUtil.hmac
SecureUtil.hmacMd5
SecureUtil.hmacSha1

只写一个简单的例子作为参考：
123456789public class SecureUtilDemo {    static AES aes &#x3D; SecureUtil.aes();    public static void main(String[] args) {        String encry &#x3D; aes.encryptHex(&quot;沉默王二&quot;);        System.out.println(encry);        String oo &#x3D; aes.decryptStr(encry);        System.out.println(oo);    }}
18、其他类库 
Hutool 中的类库还有很多，尤其是一些对第三方类库的进一步封装，比如邮件工具 MailUtil，二维码工具 QrCodeUtil，Emoji 工具 EmojiUtil，小伙伴们可以参考 Hutool 的官方文档：https:&#x2F;&#x2F;www.hutool.cn&#x2F;
项目源码地址：https:&#x2F;&#x2F;github.com&#x2F;looly&#x2F;hutool
7.7 Guava工具库01、前世今生 
你好呀，我是 Guava。
我由 Google 公司开源，目前在 GitHub 上已经有 39.9k 的铁粉了，由此可以证明我的受欢迎程度。

我的身体里主要包含有这些常用的模块：集合 [collections] 、缓存 [caching] 、原生类型支持 [primitives support] 、并发库 [concurrency libraries] 、通用注解 [common annotations] 、字符串处理 [string processing] 、I&#x2F;O 等。新版的 JDK 中已经直接把我引入了，可想而知我有多优秀，忍不住骄傲了。
这么说吧，学好如何使用我，能让你在编程中变得更快乐，写出更优雅的代码！
02、引入 Guava 
如果你要在 Maven 项目使用我的话，需要先在 pom.xml 文件中引入我的依赖。
12345&lt;dependency&gt;    &lt;groupId&gt;com.google.guava&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;guava&lt;&#x2F;artifactId&gt;    &lt;version&gt;30.1-jre&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;
一点要求，JDK 版本需要在 8 以上。
03、基本工具 
Doug Lea，java.util.concurrent 包的作者，曾说过一句话：“null 真糟糕”。Tony Hoare，图灵奖得主、快速排序算法的作者，当然也是 null 的创建者，也曾说过类似的话：“null 的使用，让我损失了十亿美元。”鉴于此，我用 Optional 来表示可能为 null 的对象。

代码示例如下所示。
123Optional&lt;Integer&gt; possible &#x3D; Optional.of(5);possible.isPresent(); &#x2F;&#x2F; returns truepossible.get(); &#x2F;&#x2F; returns 5
我大哥 Java 在 JDK 8 中新增了 Optional 类，显然是从我这借鉴过去的，不过他的和我的有些不同。

我的 Optional 是 abstract 的，意味着我可以有子类对象；我大哥的是 final 的，意味着没有子类对象。
我的 Optional 实现了 Serializable 接口，可以序列化；我大哥的没有。
我的一些方法和我大哥的也不尽相同。

使用 Optional 除了赋予 null 语义，增加了可读性，最大的优点在于它是一种傻瓜式的防护。Optional 迫使你积极思考引用缺失的情况，因为你必须显式地从 Optional 获取引用。
除了 Optional 之外，我还提供了：

参数校验
常见的 Object 方法，比如说 Objects.equals、Objects.hashCode，JDK 7 引入的 Objects 类提供同样的方法，当然也是从我这借鉴的灵感。
更强大的比较器

04、集合 
首先我来说一下，为什么需要不可变集合。

保证线程安全。在并发程序中，使用不可变集合既保证线程的安全性，也大大地增强了并发时的效率（跟并发锁方式相比）。
如果一个对象不需要支持修改操作，不可变的集合将会节省空间和时间的开销。
可以当作一个常量来对待，并且集合中的对象在以后也不会被改变。

与 JDK 中提供的不可变集合相比，我提供的 Immutable 才是真正的不可变，我为什么这么说呢？来看下面这个示例。
下面的代码利用 JDK 的 Collections.unmodifiableList(list) 得到一个不可修改的集合 unmodifiableList。
12345List list &#x3D; new ArrayList();list.add(&quot;雷军&quot;);list.add(&quot;乔布斯&quot;);List unmodifiableList &#x3D; Collections.unmodifiableList(list);unmodifiableList.add(&quot;马云&quot;);
运行代码将会出现以下异常：
1234Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException    at java.base&#x2F;java.util.Collections$UnmodifiableCollection.add(Collections.java:1060)    at com.itwanger.guava.NullTest.main(NullTest.java:29)
很好，执行 unmodifiableList.add() 的时候抛出了 UnsupportedOperationException 异常，说明 Collections.unmodifiableList() 返回了一个不可变集合。但真的是这样吗？
你可以把 unmodifiableList.add() 换成 list.add() 。
12345List list &#x3D; new ArrayList();list.add(&quot;雷军&quot;);list.add(&quot;乔布斯&quot;);List unmodifiableList &#x3D; Collections.unmodifiableList(list);list.add(&quot;马云&quot;);
再次执行的话，程序并没有报错，并且你会发现 unmodifiableList 中真的多了一个元素。说明什么呢？
Collections.unmodifiableList(…) 实现的不是真正的不可变集合，当原始集合被修改后，不可变集合里面的元素也是跟着发生变化。
我就不会犯这种错，来看下面的代码。
123List&lt;String&gt; stringArrayList &#x3D; Lists.newArrayList(&quot;雷军&quot;,&quot;乔布斯&quot;);ImmutableList&lt;String&gt; immutableList &#x3D; ImmutableList.copyOf(stringArrayList);immutableList.add(&quot;马云&quot;);
尝试 immutableList.add() 的时候会抛出 UnsupportedOperationException 。我在源码中已经把 add() 方法废弃了。
123456789101112&#x2F;**  * Guaranteed to throw an exception and leave the collection unmodified.  *  * @throws UnsupportedOperationException always  * @deprecated Unsupported operation.  *&#x2F;@CanIgnoreReturnValue@Deprecated@Overridepublic final boolean add(E e) {  throw new UnsupportedOperationException();}
尝试 stringArrayList.add() 修改原集合的时候 immutableList 并不会因此而发生改变。
除了不可变集合以外，我还提供了新的集合类型，比如说：

Multiset，可以多次添加相等的元素。当把 Multiset 看成普通的 Collection 时，它表现得就像无序的 
ArrayList；当把 Multiset 看作 Map 时，它也提供了符合性能期望的查询操作。
Multimap，可以很容易地把一个键映射到多个值。
BiMap，一种特殊的 Map，可以用 inverse() 反转，BiMap 的键值映射；保证值是唯一的，因此 values() 返回 Set 而不是普通的 Collection。

05、字符串处理 
字符串表示字符的不可变序列，创建后就不能更改。在我们日常的工作中，字符串的使用非常频繁，熟练的对其操作可以极大的提升我们的工作效率。
我提供了连接器——Joiner，可以用分隔符把字符串序列连接起来。下面的代码将会返回“雷军; 乔布斯”，你可以使用 useForNull(String) 方法用某个字符串来替换 null，而不像 skipNulls() 方法那样直接忽略 null。
12Joiner joiner &#x3D; Joiner.on(&quot;; &quot;).skipNulls();return joiner.join(&quot;雷军&quot;, null, &quot;乔布斯&quot;);
我还提供了拆分器—— Splitter，可以按照指定的分隔符把字符串序列进行拆分。
1234Splitter.on(&#39;,&#39;)        .trimResults()        .omitEmptyStrings()        .split(&quot;雷军,乔布斯,,   沉默王二&quot;);
06、缓存 
缓存在很多场景下都是相当有用的。你应该知道，检索一个值的代价很高，尤其是需要不止一次获取值的时候，就应当考虑使用缓存。
我提供的 Cache 和 ConcurrentMap 很相似，但也不完全一样。最基本的区别是 ConcurrentMap 会一直保存所有添加的元素，直到显式地移除。相对地，我提供的 Cache 为了限制内存占用，通常都设定为自动回收元素。
如果你愿意消耗一些内存空间来提升速度，你能预料到某些键会被查询一次以上，缓存中存放的数据总量不会超出内存容量，就可以使用 Cache。
来个示例你感受下吧。
12345678910111213141516171819202122232425262728293031323334353637383940414243@Testpublic void testCache() throws ExecutionException, InterruptedException {    CacheLoader cacheLoader &#x3D; new CacheLoader&lt;String, Animal&gt;() {        &#x2F;&#x2F; 如果找不到元素，会调用这里        @Override        public Animal load(String s) {            return null;        }    };    LoadingCache&lt;String, Animal&gt; loadingCache &#x3D; CacheBuilder.newBuilder()        .maximumSize(1000) &#x2F;&#x2F; 容量        .expireAfterWrite(3, TimeUnit.SECONDS) &#x2F;&#x2F; 过期时间        .removalListener(new MyRemovalListener()) &#x2F;&#x2F; 失效监听器        .build(cacheLoader); &#x2F;&#x2F;    loadingCache.put(&quot;狗&quot;, new Animal(&quot;旺财&quot;, 1));    loadingCache.put(&quot;猫&quot;, new Animal(&quot;汤姆&quot;, 3));    loadingCache.put(&quot;狼&quot;, new Animal(&quot;灰太狼&quot;, 4));    loadingCache.invalidate(&quot;猫&quot;); &#x2F;&#x2F; 手动失效    Animal animal &#x3D; loadingCache.get(&quot;狼&quot;);    System.out.println(animal);    Thread.sleep(4 * 1000);    &#x2F;&#x2F; 狼已经自动过去，获取为 null 值报错    System.out.println(loadingCache.get(&quot;狼&quot;));}&#x2F;** * 缓存移除监听器 *&#x2F;class MyRemovalListener implements RemovalListener&lt;String, Animal&gt; {    @Override    public void onRemoval(RemovalNotification&lt;String, Animal&gt; notification) {        String reason &#x3D; String.format(&quot;key&#x3D;%s,value&#x3D;%s,reason&#x3D;%s&quot;, notification.getKey(), notification.getValue(), notification.getCause());        System.out.println(reason);    }}class Animal {    private String name;    private Integer age;    public Animal(String name, Integer age) {        this.name &#x3D; name;        this.age &#x3D; age;    }}
CacheLoader 中重写了 load 方法，这个方法会在查询缓存没有命中时被调用，我这里直接返回了 null，其实这样会在没有命中时抛出 CacheLoader returned null for key 异常信息。
MyRemovalListener 作为缓存元素失效时的监听类，在有元素缓存失效时会自动调用 onRemoval 方法，这里需要注意的是这个方法是同步方法，如果这里耗时较长，会阻塞直到处理完成。
LoadingCache 就是缓存的主要操作对象了，常用的就是其中的 put 和 get 方法了。
07、集合工具 
com.google.common.collect包下的集合工具： Lists也非常强大。
创建空集合 
有时候，我们想创建一个空集合。这时可以用Lists的 newArrayList方法，例如：
1List&lt;Integer&gt; list &#x3D; Lists.newArrayList();
快速初始化集合 
有时候，我们想给一个集合中初始化一些元素。这时可以用Lists的newArrayList方法，例如：
1List&lt;Integer&gt; list &#x3D; Lists.newArrayList(1, 2, 3);
执行结果：
1[1, 2, 3]
笛卡尔积 
如果你想将两个集合做笛卡尔积 ，Lists的 cartesianProduct方法可以帮你实现：
1234List&lt;Integer&gt; list1 &#x3D; Lists.newArrayList(1, 2, 3);List&lt;Integer&gt; list2 &#x3D; Lists.newArrayList(4,5);List&lt;List&lt;Integer&gt;&gt; productList &#x3D; Lists.cartesianProduct(list1,list2);System.out.println(productList);
执行结果：
1[[1, 4], [1, 5], [2, 4], [2, 5], [3, 4], [3, 5]]
分页 
如果你想将一个大集合分成若干个小集合 ，可以使用Lists的 partition方法：
123List&lt;Integer&gt; list &#x3D; Lists.newArrayList(1, 2, 3, 4, 5);List&lt;List&lt;Integer&gt;&gt; partitionList &#x3D; Lists.partition(list, 2);System.out.println(partitionList);
执行结果：
1[[1, 2], [3, 4], [5]]
这个例子中，list有5条数据，我将list集合按大小为2，分成了3页，即变成3个小集合。
这个是我最喜欢的方法之一，经常在项目中使用。
比如有个需求：现在有5000个id，需要调用批量用户查询接口，查出用户数据。但如果你直接查5000个用户，单次接口响应时间可能会非常慢。如果改成分页处理，每次只查500个用户，异步调用10次接口，就不会有单次接口响应慢的问题。
流处理 
如果我们想把某个集合转换成另外一个接口，可以使用Lists的 transform方法。例如：
123List&lt;String&gt; list &#x3D; Lists.newArrayList(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);List&lt;String&gt; transformList &#x3D; Lists.transform(list, x -&gt; x.toUpperCase());System.out.println(transformList);
将小写字母转换成了大写字母。
颠倒顺序 
Lists的有颠倒顺序的方法 reverse 。例如：
123List&lt;Integer&gt; list &#x3D; Lists.newArrayList(3, 1, 2);List&lt;Integer&gt; reverseList &#x3D; Lists.reverse(list);System.out.println(reverseList);
执行结果：
1[2, 1, 3]
list的原始顺序是312，使用 reverse方法颠倒顺序之后，变成了213。
Lists还有其他的好用的工具，我在这里只是抛砖引玉，有兴趣的小伙伴，可以仔细研究一下。

08、尾声 
上面介绍了我认为最常用的功能，作为 Google 公司开源的 Java 开发核心库，个人觉得实用性还是很高的（不然呢？嘿嘿嘿）。引入到你的项目后不仅能快速的实现一些开发中常用的功能，而且还可以让代码更加的优雅简洁。
我觉得适用于每一个 Java 项目，至于其他的一些功能，比如说散列、事件总线、数学运算、反射，就等待你去发掘了。
7.8 其他常用工具类除了我们前面提到的 Java 原生工具类，比如说 Arrays、Objects、Collections、Scanner 等，还有一些第三方的工具类，比如说 Hutool、Guava 等，以及我们今天介绍的 IpUtil、CollectionUtils、StringUtils、MDC、ClassUtils、BeanUtils、ReflectionUtils 等等，在很大程度上能够提高我们的生产效率。
当然了，如果能好好看一下它们的源码，对技术功底的提升，也是有很大帮助的。
IpUtil：获取本机 Ip 
获取本机 IP 算是比较常见的一个需求场景了，比如业务报警，可能就会带上出问题的机器 IP，方便直接上去看日志定位问题，那么问题来了，如何获取机器 IP 呢？
1.基本方法 
如何获取机器 IP？如果了解 InetAddress 这个工具类，就很容易写出一个简单的工具类，如下
1234567public static String getLocalIP() {    try {        return InetAddress.getLocalHost().getHostAddress();    } catch (UnknownHostException e) {        throw new RuntimeException(e);    }}
上面的实现有问题么？
当然没问题，拿我本机和阿里服务器执行一下，并没有问题如实的输出了预期的 IP
本机执行后截图如下：

阿里云机器执行后截图如下：

2.进阶版 
做一点简单的改动，获取 IPV4 的地址，源码如下
123456789101112131415161718192021222324252627public static String getLocalIpByNetcard() {    try {        &#x2F;&#x2F; 枚举所有的网络接口        for (Enumeration&lt;NetworkInterface&gt; e &#x3D; NetworkInterface.getNetworkInterfaces(); e.hasMoreElements(); ) {            &#x2F;&#x2F; 获取当前网络接口            NetworkInterface item &#x3D; e.nextElement();            &#x2F;&#x2F; 遍历当前网络接口的所有地址            for (InterfaceAddress address : item.getInterfaceAddresses()) {                &#x2F;&#x2F; 忽略回环地址和未启用的网络接口                if (item.isLoopback() || !item.isUp()) {                    continue;                }                &#x2F;&#x2F; 如果当前地址是 IPv4 地址，则返回其字符串表示                if (address.getAddress() instanceof Inet4Address) {                    Inet4Address inet4Address &#x3D; (Inet4Address) address.getAddress();                    return inet4Address.getHostAddress();                }            }        }        &#x2F;&#x2F; 如果没有找到任何 IPv4 地址，则返回本地主机地址        return InetAddress.getLocalHost().getHostAddress();    } catch (SocketException | UnknownHostException e) {        &#x2F;&#x2F; 抛出运行时异常        throw new RuntimeException(e);    }}
需要注意的是，这段代码只返回本机的 IPv4 地址，并且只返回第一个符合条件的地址。如果本机有多个网络接口或者每个接口有多个地址，则可能无法返回预期的地址。此外，如果找不到任何 IPv4 地址，则会返回本地主机地址。
再次测试，输出如下

3.完整工具类 
12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.net.*;import java.util.Enumeration;public class IPUtil {    public static final String DEFAULT_IP &#x3D; &quot;127.0.0.1&quot;;    &#x2F;**     * 直接根据第一个网卡地址作为其内网ipv4地址，避免返回 127.0.0.1     *     * @return 第一个符合条件的内网 IPv4 地址     *&#x2F;    public static String getLocalIpByNetcard() {        try {            &#x2F;&#x2F; 枚举所有的网络接口            for (Enumeration&lt;NetworkInterface&gt; e &#x3D; NetworkInterface.getNetworkInterfaces(); e.hasMoreElements(); ) {                &#x2F;&#x2F; 获取当前网络接口                NetworkInterface item &#x3D; e.nextElement();                &#x2F;&#x2F; 遍历当前网络接口的所有地址                for (InterfaceAddress address : item.getInterfaceAddresses()) {                    &#x2F;&#x2F; 忽略回环地址和未启用的网络接口                    if (item.isLoopback() || !item.isUp()) {                        continue;                    }                    &#x2F;&#x2F; 如果当前地址是 IPv4 地址，则返回其字符串表示                    if (address.getAddress() instanceof Inet4Address) {                        Inet4Address inet4Address &#x3D; (Inet4Address) address.getAddress();                        return inet4Address.getHostAddress();                    }                }            }            &#x2F;&#x2F; 如果没有找到符合条件的地址，则返回本地主机地址            return InetAddress.getLocalHost().getHostAddress();        } catch (SocketException | UnknownHostException e) {            throw new RuntimeException(e);        }    }    &#x2F;**     * 获取本地主机地址     *     * @return 本地主机地址     *&#x2F;    public static String getLocalIP() {        try {            return InetAddress.getLocalHost().getHostAddress();        } catch (UnknownHostException e) {            throw new RuntimeException(e);        }    }}
IPUtil 类中定义了两个方法，分别是 getLocalIpByNetcard() 和 getLocalIP() 。前者是获取本机的内网 IPv4 地址，避免了返回 127.0.0.1 的问题。后者是获取本地主机地址，如果本机有多个 IP 地址，则可能返回其中的任意一个。
MDC：一个线程安全的参数传递工具类 
MDC 是 org.slf4j 包下的一个类，它的全称是 Mapped Diagnostic Context，我们可以认为它是一个线程安全的存放诊断日志的容器。
MDC 的底层是用了 ThreadLocal 来保存数据的。
我们可以用它传递参数。
例如现在有这样一种场景：我们使用 RestTemplate调用远程接口时，有时需要在 header中传递信息，比如：traceId，source 等，便于在查询日志时能够串联一次完整的请求链路，快速定位问题。
这种业务场景就能通过 ClientHttpRequestInterceptor接口实现，具体做法如下：
第一步，定义一个 LogFilter 拦截所有接口请求，在 MDC 中设置 traceId：
1234567891011121314151617public class LogFilter implements Filter {    @Override    public void init(FilterConfig filterConfig) throws ServletException {    }    @Override    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {        MdcUtil.add(UUID.randomUUID().toString());        System.out.println(&quot;记录请求日志&quot;);        chain.doFilter(request, response);        System.out.println(&quot;记录响应日志&quot;);    }    @Override    public void destroy() {    }}
第二步，实现 ClientHttpRequestInterceptor接口，MDC 中获取当前请求的 traceId，然后设置到 header 中：
12345678public class RestTemplateInterceptor implements ClientHttpRequestInterceptor {    @Override    public ClientHttpResponse intercept(HttpRequest request, byte[] body, ClientHttpRequestExecution execution) throws IOException {        request.getHeaders().set(&quot;traceId&quot;, MdcUtil.get());        return execution.execute(request, body);    }}
第三步，定义配置类，配置上面定义的 RestTemplateInterceptor类：
1234567891011121314@Configurationpublic class RestTemplateConfiguration {    @Bean    public RestTemplate restTemplate() {        RestTemplate restTemplate &#x3D; new RestTemplate();        restTemplate.setInterceptors(Collections.singletonList(restTemplateInterceptor()));        return restTemplate;    }    @Bean    public RestTemplateInterceptor restTemplateInterceptor() {        return new RestTemplateInterceptor();    }}
其中 MdcUtil 其实是利用 MDC 工具在 ThreadLocal 中存储和获取 traceId
123456789public class MdcUtil {    private static final String TRACE_ID &#x3D; &quot;TRACE_ID&quot;;    public static String get() {        return MDC.get(TRACE_ID);    }    public static void add(String value) {        MDC.put(TRACE_ID, value);    }}
当然，这个例子中没有演示 MdcUtil 类的 add 方法具体调的地方，我们可以在 filter 中执行接口方法之前，生成 traceId，调用 MdcUtil 类的 add 方法添加到 MDC 中，然后在同一个请求的其他地方就能通过 MdcUtil 类的 get 方法获取到该 traceId。
能使用 MDC 保存 traceId 等参数的根本原因是，用户请求到应用服务器，Tomcat 会从线程池中分配一个线程去处理该请求。
那么该请求的整个过程中，保存到 MDC 的 ThreadLocal 中的参数，也是该线程独享的，所以不会有线程安全问题。
ClassUtils 
spring 的 org.springframework.util包下的 ClassUtils类，它里面有很多让我们惊喜的功能。
它里面包含了类和对象相关的很多非常实用的方法。
获取对象的所有接口 
如果你想获取某个对象的所有接口，可以使用 ClassUtils 的 getAllInterfaces方法。例如：
1Class&lt;?&gt;[] allInterfaces &#x3D; ClassUtils.getAllInterfaces(new User());
获取某个类的包名 
如果你想获取某个类的包名，可以使用 ClassUtils 的 getPackageName方法。例如：
12String packageName &#x3D; ClassUtils.getPackageName(User.class);System.out.println(packageName);
判断某个类是否内部类 
如果你想判断某个类是否内部类，可以使用 ClassUtils 的 isInnerClass方法。例如：
1System.out.println(ClassUtils.isInnerClass(User.class));
判断对象是否代理对象 
如果你想判断对象是否代理对象，可以使用 ClassUtils 的 isCglibProxy方法。例如：
1System.out.println(ClassUtils.isCglibProxy(new User()));
ClassUtils 还有很多有用的方法，等待着你去发掘。感兴趣的小伙伴，可以看看下面的内容：

BeanUtils 
Spring 给我们提供了一个 JavaBean的工具类，它在 org.springframework.beans包下面，它的名字叫做： BeanUtils 。
让我们一起看看这个工具可以带给我们哪些惊喜。
拷贝对象的属性 
曾几何时，你有没有这样的需求：把某个对象中的所有属性，都拷贝到另外一个对象中。这时就能使用 BeanUtils 的 copyProperties方法。例如：
1234567User user1 &#x3D; new User();user1.setId(1L);user1.setName(&quot;沉默王二&quot;);user1.setAddress(&quot;中国&quot;);User user2 &#x3D; new User();BeanUtils.copyProperties(user1, user2);System.out.println(user2);
实例化某个类 
如果你想通过反射实例化一个类的对象，可以使用 BeanUtils 的 instantiateClass方法。例如：
12User user &#x3D; BeanUtils.instantiateClass(User.class);System.out.println(user);
获取指定类的指定方法 
如果你想获取某个类的指定方法，可以使用 BeanUtils 的 findDeclaredMethod方法。例如：
12Method declaredMethod &#x3D; BeanUtils.findDeclaredMethod(User.class, &quot;getId&quot;);System.out.println(declaredMethod.getName());
获取指定方法的参数 
如果你想获取某个方法的参数，可以使用 BeanUtils 的 findPropertyForMethod方法。例如：
1234Method declaredMethod &#x3D; BeanUtils.findDeclaredMethod(User.class, &quot;getId&quot;);PropertyDescriptor propertyForMethod &#x3D; BeanUtils.findPropertyForMethod(declaredMethod);System.out.println(propertyForMethod.getName());
如果你对 BeanUtils 比较感兴趣，可以看看下面内容：

ReflectionUtils 
有时候，我们需要在项目中使用反射功能，如果使用最原始的方法来开发，代码量会非常多，而且很麻烦，它需要处理一大堆异常以及访问权限等问题。
好消息是 Spring 给我们提供了一个 ReflectionUtils工具，它在 org.springframework.util包下面。
获取方法 
如果你想获取某个类的某个方法，可以使用 ReflectionUtils 类的 findMethod方法。例如：
1Method method &#x3D; ReflectionUtils.findMethod(User.class, &quot;getId&quot;);
获取字段 
如果你想获取某个类的某个字段，可以使用 ReflectionUtils 类的 findField方法。例如：
1Field field &#x3D; ReflectionUtils.findField(User.class, &quot;id&quot;);
执行方法 
如果你想通过反射调用某个方法，传递参数，可以使用 ReflectionUtils 类的 invokeMethod方法。例如：
1ReflectionUtils.invokeMethod(method, springContextsUtil.getBean(beanName), param);
判断字段是否常量 
如果你想判断某个字段是否常量，可以使用 ReflectionUtils 类的 isPublicStaticFinal方法。例如：
12Field field &#x3D; ReflectionUtils.findField(User.class, &quot;id&quot;);System.out.println(ReflectionUtils.isPublicStaticFinal(field));
判断是否 equals 方法 
如果你想判断某个方法是否 equals 方法，可以使用 ReflectionUtils 类的 isEqualsMethod方法。例如：
12Method method &#x3D; ReflectionUtils.findMethod(User.class, &quot;getId&quot;);System.out.println(ReflectionUtils.isEqualsMethod(method));
当然这个类还有不少有趣的方法，感兴趣的朋友，可以看看下面内容：

8 Java新特性8.1 掌握Stream流两个星期以前，就有读者强烈要求我写一篇 Java Stream 流的文章，我说市面上不是已经有很多了吗，结果你猜他怎么说：“就想看你写的啊！”你看你看，多么苍白的喜欢啊。那就“勉为其难”写一篇吧，嘻嘻。
单从“Stream”这个单词上来看，它似乎和 java.io 包下的 InputStream 和 OutputStream 有些关系。实际上呢，没毛关系。Java 8 新增的 Stream 是为了解放程序员操作集合（Collection）时的生产力，之所以能解放，很大一部分原因可以归功于同时出现的 Lambda 表达式——极大的提高了编程效率和程序可读性。
Stream 究竟是什么呢？

Stream 就好像一个高级的迭代器，但只能遍历一次，就好像一江春水向东流；在流的过程中，对流中的元素执行一些操作，比如“过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等。

要想操作流，首先需要有一个数据源，可以是数组或者集合。每次操作都会返回一个新的流对象，方便进行链式操作，但原有的流对象会保持不变。
流的操作可以分为两种类型：
1）中间操作，可以有多个，每次返回一个新的流，可进行链式操作。
2）终端操作，只能有一个，每次执行完，这个流也就用光光了，无法执行下一个操作，因此只能放在最后。
来举个例子。
1234567List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();list.add(&quot;武汉加油&quot;);list.add(&quot;中国加油&quot;);list.add(&quot;世界加油&quot;);list.add(&quot;世界加油&quot;);long count &#x3D; list.stream().distinct().count();System.out.println(count);
distinct() 方法是一个中间操作（去重），它会返回一个新的流（没有共同元素）。
1Stream&lt;T&gt; distinct();
count() 方法是一个终端操作，返回流中的元素个数。
1long count();
中间操作不会立即执行，只有等到终端操作的时候，流才开始真正地遍历，用于映射、过滤等。通俗点说，就是一次遍历执行多个操作，性能就大大提高了。
理论部分就扯这么多，下面直接进入实战部分。
01、创建流 
如果是数组的话，可以使用 Arrays.stream() 或者 Stream.of() 创建流；如果是集合的话，可以直接使用 stream() 方法创建流，因为该方法已经添加到 Collection 接口中。
123456789101112public class CreateStreamDemo {    public static void main(String[] args) {        String[] arr &#x3D; new String[]{&quot;武汉加油&quot;, &quot;中国加油&quot;, &quot;世界加油&quot;};        Stream&lt;String&gt; stream &#x3D; Arrays.stream(arr);        stream &#x3D; Stream.of(&quot;武汉加油&quot;, &quot;中国加油&quot;, &quot;世界加油&quot;);        List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();        list.add(&quot;武汉加油&quot;);        list.add(&quot;中国加油&quot;);        list.add(&quot;世界加油&quot;);        stream &#x3D; list.stream();    }}
查看 Stream 源码的话，你会发现 of() 方法内部其实调用了 Arrays.stream() 方法。
123public static&lt;T&gt; Stream&lt;T&gt; of(T... values) {    return Arrays.stream(values);}
另外，集合还可以调用 parallelStream() 方法创建并发流，默认使用的是 ForkJoinPool.commonPool()线程池。
12List&lt;Long&gt; aList &#x3D; new ArrayList&lt;&gt;();Stream&lt;Long&gt; parallelStream &#x3D; aList.parallelStream();
02、操作流 
Stream 类提供了很多有用的操作流的方法，我来挑一些常用的给你介绍一下。
1）过滤 
通过 filter() 方法可以从流中筛选出我们想要的元素。
1234567891011public class FilterStreamDemo {    public static void main(String[] args) {        List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();        list.add(&quot;周杰伦&quot;);        list.add(&quot;王力宏&quot;);        list.add(&quot;陶喆&quot;);        list.add(&quot;林俊杰&quot;);        Stream&lt;String&gt; stream &#x3D; list.stream().filter(element -&gt; element.contains(&quot;王&quot;));        stream.forEach(System.out::println);    }}
filter() 方法接收的是一个 Predicate（Java 8 新增的一个函数式接口，接受一个输入参数返回一个布尔值结果）类型的参数，因此，我们可以直接将一个 Lambda 表达式传递给该方法，比如说 element -&gt; element.contains(“王”) 就是筛选出带有“王”的字符串。
forEach() 方法接收的是一个 Consumer（Java 8 新增的一个函数式接口，接受一个输入参数并且无返回的操作）类型的参数，类名 :: 方法名是 Java 8 引入的新语法， System.out 返回 PrintStream 类，println 方法你应该知道是打印的。
stream.forEach(System.out::println); 相当于在 for 循环中打印，类似于下面的代码：
123for (String s : strs) {    System.out.println(s);}
很明显，一行代码看起来更简洁一些。来看一下程序的输出结果：
1王力宏
2）映射 
如果想通过某种操作把一个流中的元素转化成新的流中的元素，可以使用 map() 方法。
1234567891011public class MapStreamDemo {    public static void main(String[] args) {        List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();        list.add(&quot;周杰伦&quot;);        list.add(&quot;王力宏&quot;);        list.add(&quot;陶喆&quot;);        list.add(&quot;林俊杰&quot;);        Stream&lt;Integer&gt; stream &#x3D; list.stream().map(String::length);        stream.forEach(System.out::println);    }}
map() 方法接收的是一个 Function（Java 8 新增的一个函数式接口，接受一个输入参数 T，返回一个结果 R）类型的参数，此时参数 为 String 类的 length 方法，也就是把 Stream 的流转成一个 Stream 的流。
程序输出的结果如下所示：
12343323
3）匹配 
Stream 类提供了三个方法可供进行元素匹配，它们分别是：

anyMatch() ，只要有一个元素匹配传入的条件，就返回 true。
allMatch() ，只有有一个元素不匹配传入的条件，就返回 false；如果全部匹配，则返回 true。
noneMatch() ，只要有一个元素匹配传入的条件，就返回 false；如果全部不匹配，则返回 true。

1234567891011121314151617public class MatchStreamDemo {    public static void main(String[] args) {        List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();        list.add(&quot;周杰伦&quot;);        list.add(&quot;王力宏&quot;);        list.add(&quot;陶喆&quot;);        list.add(&quot;林俊杰&quot;);        boolean  anyMatchFlag &#x3D; list.stream().anyMatch(element -&gt; element.contains(&quot;王&quot;));        boolean  allMatchFlag &#x3D; list.stream().allMatch(element -&gt; element.length() &gt; 1);        boolean  noneMatchFlag &#x3D; list.stream().noneMatch(element -&gt; element.endsWith(&quot;沉&quot;));        System.out.println(anyMatchFlag);        System.out.println(allMatchFlag);        System.out.println(noneMatchFlag);    }}
因为“王力宏”以“王”字开头，所以 anyMatchFlag 应该为 true；因为“周杰伦”、“王力宏”、“陶喆”、“林俊杰”的字符串长度都大于 1，所以 allMatchFlag 为 true；因为 4 个字符串结尾都不是“沉”，所以 noneMatchFlag 为 true。
程序输出的结果如下所示：
123truetruetrue
4）组合 
reduce() 方法的主要作用是把 Stream 中的元素组合起来，它有两种用法：

Optional reduce(BinaryOperator accumulator)

没有起始值，只有一个参数，就是运算规则，此时返回 Optional。

T reduce(T identity, BinaryOperator accumulator)

有起始值，有运算规则，两个参数，此时返回的类型和起始值类型一致。
来看下面这个例子。
1234567891011121314public class ReduceStreamDemo {    public static void main(String[] args) {        Integer[] ints &#x3D; {0, 1, 2, 3};        List&lt;Integer&gt; list &#x3D; Arrays.asList(ints);        Optional&lt;Integer&gt; optional &#x3D; list.stream().reduce((a, b) -&gt; a + b);        Optional&lt;Integer&gt; optional1 &#x3D; list.stream().reduce(Integer::sum);        System.out.println(optional.orElse(0));        System.out.println(optional1.orElse(0));        int reduce &#x3D; list.stream().reduce(6, (a, b) -&gt; a + b);        System.out.println(reduce);        int reduce1 &#x3D; list.stream().reduce(6, Integer::sum);        System.out.println(reduce1);    }}
运算规则可以是 Lambda 表达式（比如 (a, b) -&gt; a + b ），也可以是类名::方法名（比如 Integer::sum ）。
程序运行的结果如下所示：
1234661212
0、1、2、3 在没有起始值相加的时候结果为 6；有起始值 6 的时候结果为 12。
03、转换流 
既然可以把集合或者数组转成流，那么也应该有对应的方法，将流转换回去—— collect() 方法就满足了这种需求。
12345678910111213141516171819public class CollectStreamDemo {    public static void main(String[] args) {        List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();        list.add(&quot;周杰伦&quot;);        list.add(&quot;王力宏&quot;);        list.add(&quot;陶喆&quot;);        list.add(&quot;林俊杰&quot;);        String[] strArray &#x3D; list.stream().toArray(String[]::new);        System.out.println(Arrays.toString(strArray));        List&lt;Integer&gt; list1 &#x3D; list.stream().map(String::length).collect(Collectors.toList());        List&lt;String&gt; list2 &#x3D; list.stream().collect(Collectors.toCollection(ArrayList::new));        System.out.println(list1);        System.out.println(list2);        String str &#x3D; list.stream().collect(Collectors.joining(&quot;, &quot;)).toString();        System.out.println(str);    }}
toArray() 方法可以将流转换成数组，你可能比较好奇的是 String[]::new ，它是什么东东呢？来看一下 toArray() 方法的源码。
1&lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator);
也就是说 String[]::new 是一个 IntFunction，一个可以产生所需的新数组的函数，可以通过反编译字节码看看它到底是什么：
1234String[] strArray &#x3D; (String[])list.stream().toArray((x$0) -&gt; {    return new String[x$0];});System.out.println(Arrays.toString(strArray));
也就是相当于返回了一个指定长度的字符串数组。
当我们需要把一个集合按照某种规则转成另外一个集合的时候，就可以配套使用 map() 方法和 collect() 方法。
12List&lt;Integer&gt; list1 &#x3D; list.stream().map(String::length).collect(Collectors.toList());
通过 stream() 方法创建集合的流后，再通过 map(String:length) 将其映射为字符串长度的一个新流，最后通过 collect() 方法将其转换成新的集合。
Collectors 是一个收集器的工具类，内置了一系列收集器实现，比如说 toList() 方法将元素收集到一个新的 java.util.List 中；比如说 toCollection() 方法将元素收集到一个新的 java.util.ArrayList 中；比如说 joining() 方法将元素收集到一个可以用分隔符指定的字符串中。
来看一下程序的输出结果：
1234[周杰伦, 王力宏, 陶喆, 林俊杰][3, 3, 2, 3][周杰伦, 王力宏, 陶喆, 林俊杰]周杰伦, 王力宏, 陶喆, 林俊杰
8.2 Optional最佳指南想学习，永远都不晚，尤其是针对 Java 8 里面的好东西，Optional 就是其中之一，该类提供了一种用于表示可选值而非空引用的类级别解决方案。作为一名 Java 程序员，我真的是烦透了 NullPointerException（NPE），尽管和它熟得就像一位老朋友，知道它也是迫不得已——程序正在使用一个对象却发现这个对象的值为 null，于是 Java 虚拟机就怒发冲冠地把它抛了出来当做替罪羊。
当然了，我们程序员是富有责任心的，不会坐视不管，于是就有了大量的 null 值检查。尽管有时候这种检查完全没有必要，但我们已经习惯了例行公事。终于，Java 8 看不下去了，就引入了 Optional，以便我们编写的代码不再那么刻薄呆板。

01、没有 Optional 会有什么问题 
我们来模拟一个实际的应用场景。小王第一天上班，领导老马就给他安排了一个任务，要他从数据库中根据会员 ID 拉取一个会员的姓名，然后将姓名打印到控制台。虽然是新来的，但这个任务难不倒小王，于是他花了 10 分钟写下了这段代码：
123456789101112131415161718192021public class WithoutOptionalDemo {    class Member {        private String name;        public String getName() {            return name;        }        public void setName(String name) {            this.name &#x3D; name;        }    }    public static void main(String[] args) {        Member mem &#x3D; getMemberByIdFromDB();        if (mem !&#x3D; null) {            System.out.println(mem.getName());        }    }    public static Member getMemberByIdFromDB() {        &#x2F;&#x2F; 当前 ID 的会员不存在        return null;    }}
由于当前 ID 的会员不存在，所以 getMemberByIdFromDB() 方法返回了 null 来作为没有获取到该会员的结果，那就意味着在打印会员姓名的时候要先对 mem 判空，否则就会抛出 NPE 异常，不信？让小王把 if (mem !&#x3D; null) 去掉试试，控制台立马打印错误堆栈给你颜色看看。
123Exception in thread &quot;main&quot; java.lang.NullPointerException    at com.cmower.dzone.optional.WithoutOptionalDemo.main(WithoutOptionalDemo.java:24)
02、Optional 是如何解决这个问题的 
小王把代码提交后，就兴高采烈地去找老马要新的任务了。本着虚心学习的态度，小王请求老马看一下自己的代码，于是老王就告诉他应该尝试一下 Optional，可以避免没有必要的 null 值检查。现在，让我们来看看小王是如何通过 Optional 来解决上述问题的。
12345678910111213141516171819202122public class OptionalDemo {    public static void main(String[] args) {        Optional&lt;Member&gt; optional &#x3D; getMemberByIdFromDB();        optional.ifPresent(mem -&gt; {            System.out.println(&quot;会员姓名是：&quot; + mem.getName());        });    }    public static Optional&lt;Member&gt; getMemberByIdFromDB() {        boolean hasName &#x3D; true;        if (hasName) {            return Optional.of(new Member(&quot;沉默王二&quot;));        }        return Optional.empty();    }}class Member {    private String name;    public String getName() {        return name;    }    &#x2F;&#x2F; getter &#x2F; setter}
getMemberByIdFromDB() 方法返回了 Optional 作为结果，这样就表明 Member 可能存在，也可能不存在，这时候就可以在 Optional 的 ifPresent() 方法中使用 Lambda 表达式来直接打印结果。
Optional 之所以可以解决 NPE 的问题，是因为它明确的告诉我们，不需要对它进行判空。它就好像十字路口的路标，明确地告诉你该往哪走。
03、创建 Optional 对象 
1）可以使用静态方法 empty() 创建一个空的 Optional 对象
12Optional&lt;String&gt; empty &#x3D; Optional.empty();System.out.println(empty); &#x2F;&#x2F; 输出：Optional.empty
2）可以使用静态方法 of() 创建一个非空的 Optional 对象
12Optional&lt;String&gt; opt &#x3D; Optional.of(&quot;沉默王二&quot;);System.out.println(opt); &#x2F;&#x2F; 输出：Optional[沉默王二]
当然了，传递给 of() 方法的参数必须是非空的，也就是说不能为 null，否则仍然会抛出 NullPointerException。
12String name &#x3D; null;Optional&lt;String&gt; optnull &#x3D; Optional.of(name);
3）可以使用静态方法 ofNullable() 创建一个即可空又可非空的 Optional 对象
123String name &#x3D; null;Optional&lt;String&gt; optOrNull &#x3D; Optional.ofNullable(name);System.out.println(optOrNull); &#x2F;&#x2F; 输出：Optional.empty
ofNullable() 方法内部有一个三元表达式，如果为参数为 null，则返回私有常量 EMPTY；否则使用 new 关键字创建了一个新的 Optional 对象——不会再抛出 NPE 异常了。
04、判断值是否存在 
可以通过方法 isPresent() 判断一个 Optional 对象是否存在，如果存在，该方法返回 true，否则返回 false——取代了 obj !&#x3D; null 的判断。
1234Optional&lt;String&gt; opt &#x3D; Optional.of(&quot;沉默王二&quot;);System.out.println(opt.isPresent()); &#x2F;&#x2F; 输出：trueOptional&lt;String&gt; optOrNull &#x3D; Optional.ofNullable(null);System.out.println(opt.isPresent()); &#x2F;&#x2F; 输出：false
Java 11 后还可以通过方法 isEmpty() 判断与 isPresent() 相反的结果。
1234Optional&lt;String&gt; opt &#x3D; Optional.of(&quot;沉默王二&quot;);System.out.println(opt.isPresent()); &#x2F;&#x2F; 输出：falseOptional&lt;String&gt; optOrNull &#x3D; Optional.ofNullable(null);System.out.println(opt.isPresent()); &#x2F;&#x2F; 输出：true
05、非空表达式 
Optional 类有一个非常现代化的方法—— ifPresent() ，允许我们使用函数式编程的方式执行一些代码，因此，我把它称为非空表达式。如果没有该方法的话，我们通常需要先通过 isPresent() 方法对 Optional 对象进行判空后再执行相应的代码：
1234Optional&lt;String&gt; optOrNull &#x3D; Optional.ofNullable(null);if (optOrNull.isPresent()) {    System.out.println(optOrNull.get().length());}
有了 ifPresent() 之后，情况就完全不同了，可以直接将 Lambda 表达式传递给该方法，代码更加简洁，更加直观。
12Optional&lt;String&gt; opt &#x3D; Optional.of(&quot;沉默王二&quot;);opt.ifPresent(str -&gt; System.out.println(str.length()));
Java 9 后还可以通过方法 ifPresentOrElse(action, emptyAction) 执行两种结果，非空时执行 action，空时执行 emptyAction。
123Optional&lt;String&gt; opt &#x3D; Optional.of(&quot;沉默王二&quot;);opt.ifPresentOrElse(str -&gt; System.out.println(str.length()), () -&gt; System.out.println(&quot;为空&quot;));
06、设置（获取）默认值 
有时候，我们在创建（获取） Optional 对象的时候，需要一个默认值， orElse() 和 orElseGet() 方法就派上用场了。
orElse() 方法用于返回包裹在 Optional 对象中的值，如果该值不为 null，则返回；否则返回默认值。该方法的参数类型和值得类型一致。
123String nullName &#x3D; null;String name &#x3D; Optional.ofNullable(nullName).orElse(&quot;沉默王二&quot;);System.out.println(name); &#x2F;&#x2F; 输出：沉默王二
orElseGet() 方法与 orElse() 方法类似，但参数类型不同。如果 Optional 对象中的值为 null，则执行参数中的函数。
123String nullName &#x3D; null;String name &#x3D; Optional.ofNullable(nullName).orElseGet(()-&gt;&quot;沉默王二&quot;);System.out.println(name); &#x2F;&#x2F; 输出：沉默王二
从输出结果以及代码的形式上来看，这两个方法极其相似，这不免引起我们的怀疑，Java 类库的设计者有必要这样做吗？
假设现在有这样一个获取默认值的方法，很传统的方式。
1234public static String getDefaultValue() {    System.out.println(&quot;getDefaultValue&quot;);    return &quot;沉默王二&quot;;}
然后，通过 orElse() 方法和 orElseGet() 方法分别调用 getDefaultValue() 方法返回默认值。
12345678public static void main(String[] args) {    String name &#x3D; null;    System.out.println(&quot;orElse&quot;);    String name2 &#x3D; Optional.ofNullable(name).orElse(getDefaultValue());    System.out.println(&quot;orElseGet&quot;);    String name3 &#x3D; Optional.ofNullable(name).orElseGet(OrElseOptionalDemo::getDefaultValue);}
注：类名 :: 方法名是 Java 8 引入的语法，方法名后面是没有 () 的，表明该方法并不一定会被调用。
输出结果如下所示：
1234orElsegetDefaultValueorElseGetgetDefaultValue
输出结果是相似的，没什么太大的不同，这是在 Optional 对象的值为 null 的情况下。假如 Optional 对象的值不为 null 呢？
12345678public static void main(String[] args) {    String name &#x3D; &quot;沉默王三&quot;;    System.out.println(&quot;orElse&quot;);    String name2 &#x3D; Optional.ofNullable(name).orElse(getDefaultValue());    System.out.println(&quot;orElseGet&quot;);    String name3 &#x3D; Optional.ofNullable(name).orElseGet(OrElseOptionalDemo::getDefaultValue);}
输出结果如下所示：
123orElsegetDefaultValueorElseGet
咦， orElseGet() 没有去调用 getDefaultValue() 。哪个方法的性能更佳，你明白了吧？
07、获取值 
直观从语义上来看， get() 方法才是最正宗的获取 Optional 对象值的方法，但很遗憾，该方法是有缺陷的，因为假如 Optional 对象的值为 null，该方法会抛出 NoSuchElementException 异常。这完全与我们使用 Optional 类的初衷相悖。
1234567public class GetOptionalDemo {    public static void main(String[] args) {        String name &#x3D; null;        Optional&lt;String&gt; optOrNull &#x3D; Optional.ofNullable(name);        System.out.println(optOrNull.get());    }}
这段程序在运行时会抛出异常：
123Exception in thread &quot;main&quot; java.util.NoSuchElementException: No value present    at java.base&#x2F;java.util.Optional.get(Optional.java:141)    at com.cmower.dzone.optional.GetOptionalDemo.main(GetOptionalDemo.java:9)
尽管抛出的异常是 NoSuchElementException 而不是 NPE，但在我们看来，显然是在“五十步笑百步”。建议 orElseGet() 方法获取 Optional 对象的值。
08、过滤值 
小王通过 Optional 类对之前的代码进行了升级，完成后又兴高采烈地跑去找老马要任务了。老马觉得这小伙子不错，头脑灵活，又干活积极，很值得培养，就又交给了小王一个新的任务：用户注册时对密码的长度进行检查。
小王拿到任务后，乐开了花，因为他刚要学习 Optional 类的 filter() 方法，这就派上了用场。
1234567public class FilterOptionalDemo {    public static void main(String[] args) {        String password &#x3D; &quot;12345&quot;;        Optional&lt;String&gt; opt &#x3D; Optional.ofNullable(password);        System.out.println(opt.filter(pwd -&gt; pwd.length() &gt; 6).isPresent());    }}
filter() 方法的参数类型为 Predicate（Java 8 新增的一个函数式接口），也就是说可以将一个 Lambda 表达式传递给该方法作为条件，如果表达式的结果为 false，则返回一个 EMPTY 的 Optional 对象，否则返回过滤后的 Optional 对象。
在上例中，由于 password 的长度为 5 ，所以程序输出的结果为 false。假设密码的长度要求在 6 到 10 位之间，那么还可以再追加一个条件。来看小王增加难度后的代码。
123456Predicate&lt;String&gt; len6 &#x3D; pwd -&gt; pwd.length() &gt; 6;Predicate&lt;String&gt; len10 &#x3D; pwd -&gt; pwd.length() &lt; 10;password &#x3D; &quot;1234567&quot;;opt &#x3D; Optional.ofNullable(password);boolean result &#x3D; opt.filter(len6.and(len10)).isPresent();System.out.println(result);
这次程序输出的结果为 true，因为密码变成了 7 位，在 6 到 10 位之间。想象一下，假如小王使用 if-else 来完成这个任务，代码该有多冗长。
09、转换值 
小王检查完了密码的长度，仍然觉得不够尽兴，觉得要对密码的强度也进行检查，比如说密码不能是“password”，这样的密码太弱了。于是他又开始研究起了 map() 方法，该方法可以按照一定的规则将原有 Optional 对象转换为一个新的 Optional 对象，原有的 Optional 对象不会更改。
先来看小王写的一个简单的例子：
12345678910public class OptionalMapDemo {    public static void main(String[] args) {        String name &#x3D; &quot;沉默王二&quot;;        Optional&lt;String&gt; nameOptional &#x3D; Optional.of(name);        Optional&lt;Integer&gt; intOpt &#x3D; nameOptional                .map(String::length);                System.out.println( intOpt.orElse(0));    }}
在上面这个例子中， map() 方法的参数 String::length ，意味着要 将原有的字符串类型的 Optional 按照字符串长度重新生成一个新的 Optional 对象，类型为 Integer。
搞清楚了 map() 方法的基本用法后，小王决定把 map() 方法与 filter() 方法结合起来用，前者用于将密码转化为小写，后者用于判断长度以及是否是“password”。
1234567891011public class OptionalMapFilterDemo {    public static void main(String[] args) {        String password &#x3D; &quot;password&quot;;        Optional&lt;String&gt;  opt &#x3D; Optional.ofNullable(password);        Predicate&lt;String&gt; len6 &#x3D; pwd -&gt; pwd.length() &gt; 6;        Predicate&lt;String&gt; len10 &#x3D; pwd -&gt; pwd.length() &lt; 10;        Predicate&lt;String&gt; eq &#x3D; pwd -&gt; pwd.equals(&quot;password&quot;);        boolean result &#x3D; opt.map(String::toLowerCase).filter(len6.and(len10 ).and(eq)).isPresent();        System.out.println(result);    }}
好了，我亲爱的读者朋友，以上就是本文的全部内容了——可以说是史上最佳 Optional 指南了，能看到这里的都是最优秀的程序员，二哥必须要伸出大拇指为你点个赞。
8.3 深入浅出Lambda表达式今天分享的主题是《Lambda 表达式入门》，这也是之前一些读者留言强烈要求我写一写的，不好意思，让你们久等了，现在来满足你们，为时不晚吧？
01、初识 Lambda 
Lambda 表达式描述了一个代码块（或者叫匿名方法），可以将其作为参数传递给构造方法或者普通方法以便后续执行。考虑下面这段代码：
1() -&gt; System.out.println(&quot;沉默王二&quot;)
来从左到右解释一下， () 为 Lambda 表达式的参数列表（本例中没有参数）， -&gt; 标识这串代码为 Lambda 表达式（也就是说，看到 -&gt; 就知道这是 Lambda）， System.out.println(“沉默王二”) 为要执行的代码，即将“沉默王二”打印到标准输出流。
有点 Java 基础的同学应该不会对 Runnable 接口感到陌生，这是多线程的一个基础接口，它的定义如下：
12345@FunctionalInterfacepublic interface Runnable{   public abstract void run();}
Runnable 接口非常简单，仅有一个抽象方法 run() ；细心的同学会发现一个陌生的注解 @FunctionalInterface ，这个注解是什么意思呢？
我看了它的源码，里面有这样一段注释：

Note that instances of functional interfaces can be created with lambda expressions, method references, or constructor references.

大致的意思就是说，通过 @FunctionalInterface 标记的接口可以通过 Lambda 表达式创建实例。具体怎么表现呢？
原来我们创建一个线程并启动它是这样的：
12345678910public class LamadaTest {    public static void main(String[] args) {        new Thread(new Runnable() {            @Override            public void run() {                System.out.println(&quot;沉默王二&quot;);            }        }).start();    }}
通过 Lambda 表达式呢？只需要下面这样：
12345public class LamadaTest {    public static void main(String[] args) {        new Thread(() -&gt; System.out.println(&quot;沉默王二&quot;)).start();    }}
是不是很妙！比起匿名内部类，Lambda 表达式不仅易于理解，更大大简化了必须编写的代码数量。
02、Lambda 语法 
每个 Lambda 表达式都遵循以下法则：
1( parameter-list ) -&gt; { expression-or-statements }
() 中的 parameter-list 是以逗号分隔的参数。你可以指定参数的类型，也可以不指定（编译器会根据上下文进行推断）。Java 11 后，还可以使用 var 关键字作为参数类型，有点 JavaScript 的味道。
-&gt; 相当于 Lambda 的标识符，就好像见到圣旨就见到了皇上。
{} 中的 expression-or-statements 为 Lambda 的主体，可以是一行语句，也可以多行。
可以通过 Lambda 表达式干很多事情，比如说
1）为变量赋值，示例如下：
12Runnable r &#x3D; () -&gt; { System.out.println(&quot;沉默王二&quot;); };r.run();
2）作为 return 结果，示例如下：
1234static FileFilter getFilter(String ext){    return (pathname) -&gt; pathname.toString().endsWith(ext);}
3）作为数组元素，示例如下：
12345final PathMatcher matchers[] &#x3D;{        (path) -&gt; path.toString().endsWith(&quot;txt&quot;),        (path) -&gt; path.toString().endsWith(&quot;java&quot;)};
4）作为普通方法或者构造方法的参数，示例如下：
1new Thread(() -&gt; System.out.println(&quot;沉默王二&quot;)).start();
需要注意 Lambda 表达式的作用域范围。
12345678public static void main(String[] args) {    int limit &#x3D; 10;    Runnable r &#x3D; () -&gt; {        int limit &#x3D; 5;        for (int i &#x3D; 0; i &lt; limit; i++)            System.out.println(i);    };}
上面这段代码在编译的时候会提示错误：变量 limit 已经定义过了。
和匿名内部类一样，不要在 Lambda 表达式主体内对方法内的局部变量进行修改，否则编译也不会通过：Lambda 表达式中使用的变量必须是 final 的。

这个问题发生的原因是因为 Java 规范中是这样规定的：

Any local variable, formal parameter, or exception parameter used but not declared in a lambda expression must either be declared final or be effectively final (§4.12.4), or a compile-time error occurs where the use is attempted.

大致的意思就是说，Lambda 表达式中要用到的，但又未在 Lambda 表达式中声明的变量，必须声明为 final 或者是 effectively final，否则就会出现编译错误。
关于 final 和 effectively final 的区别，可能有些小伙伴不太清楚，这里多说两句。
12345678910111213final int a;a &#x3D; 1;&#x2F;&#x2F; a &#x3D; 2;&#x2F;&#x2F; 由于 a 是 final 的，所以不能被重新赋值int b;b &#x3D; 1;&#x2F;&#x2F; b 此后再未更改&#x2F;&#x2F; b 就是 effectively finalint c;c &#x3D; 1;&#x2F;&#x2F; c 先被赋值为 1，随后又被重新赋值为 2c &#x3D; 2;&#x2F;&#x2F; c 就不是 effectively final
明白了 final 和 effectively final 的区别后，我们了解到，如果把 limit 定义为 final，那就无法在 Lambda 表达式中修改变量的值。那有什么好的解决办法呢？既能让编译器不发出警告，又能修改变量的值。
思前想后，试来试去，我终于找到了 3 个可行的解决方案：
1）把 limit 变量声明为 static。
2）把 limit 变量声明为 AtomicInteger。
3）使用数组。
下面我们来详细地一一介绍下。
01）把 limit 变量声明为 static 
要想把 limit 变量声明为 static，就必须将 limit 变量放在 main() 方法外部，因为 main() 方法本身是 static 的。完整的代码示例如下所示。
123456789101112public class ModifyVariable2StaticInsideLambda {    static int limit &#x3D; 10;    public static void main(String[] args) {        Runnable r &#x3D; () -&gt; {            limit &#x3D; 5;            for (int i &#x3D; 0; i &lt; limit; i++) {                System.out.println(i);            }        };        new Thread(r).start();    }}
来看一下程序输出的结果：
123450123
OK，该方案是可行的。
02）把 limit 变量声明为 AtomicInteger 
AtomicInteger 可以确保 int 值的修改是原子性的，可以使用 set() 方法设置一个新的 int 值， get() 方法获取当前的 int 值。
123456789101112public class ModifyVariable2AtomicInsideLambda {    public static void main(String[] args) {        final AtomicInteger limit &#x3D; new AtomicInteger(10);        Runnable r &#x3D; () -&gt; {            limit.set(5);            for (int i &#x3D; 0; i &lt; limit.get(); i++) {                System.out.println(i);            }        };        new Thread(r).start();    }}
来看一下程序输出的结果：
1234501234
OK，该方案也是可行的。
03）使用数组 
使用数组的方式略带一些欺骗的性质，在声明数组的时候设置为 final，但更改 int 的值时却修改的是数组的一个元素。
123456789101112public class ModifyVariable2ArrayInsideLambda {    public static void main(String[] args) {        final int [] limits &#x3D; {10};        Runnable r &#x3D; () -&gt; {            limits[0] &#x3D; 5;            for (int i &#x3D; 0; i &lt; limits[0]; i++) {                System.out.println(i);            }        };        new Thread(r).start();    }}
来看一下程序输出的结果：
1234501234
OK，该方案也是可行的。
03、Lambda 和 this 关键字 
Lambda 表达式并不会引入新的作用域，这一点和匿名内部类是不同的。也就是说，Lambda 表达式主体内使用的 this 关键字和其所在的类实例相同。
来看下面这个示例。
123456789101112131415161718public class LamadaTest {    public static void main(String[] args) {        new LamadaTest().work();    }    public void work() {        System.out.printf(&quot;this &#x3D; %s%n&quot;, this);        Runnable r &#x3D; new Runnable()        {            @Override            public void run()            {                System.out.printf(&quot;this &#x3D; %s%n&quot;, this);            }        };        new Thread(r).start();        new Thread(() -&gt; System.out.printf(&quot;this &#x3D; %s%n&quot;, this)).start();    }}
Tips： %s 代表当前位置输出字符串， %n 代表换行符，也可以使用 \n 代替，但 %n 是跨平台的。
work() 方法中的代码可以分为 3 个部分：
1）单独的 this 关键字
1System.out.printf(&quot;this &#x3D; %s%n&quot;, this);
其中 this 为 main() 方法中通过 new 关键字创建的 LamadaTest 对象—— new LamadaTest() 。
2）匿名内部类中的 this 关键字
12345678Runnable r &#x3D; new Runnable(){    @Override    public void run()    {        System.out.printf(&quot;this &#x3D; %s%n&quot;, this);    }};
其中 this 为 work() 方法中通过 new 关键字创建的 Runnable 对象—— new Runnable(){…} 。
3）Lambda 表达式中的 this 关键字
其中 this 关键字和 1）中的相同。
我们来看一下程序的输出结果：
123this &#x3D; com.cmower.java_demo.journal.LamadaTest@3feba861this &#x3D; com.cmower.java_demo.journal.LamadaTest$1@64f033cbthis &#x3D; com.cmower.java_demo.journal.LamadaTest@3feba861
符合我们分析的预期。
04、最后 
尽管 Lambda 表达式在简化 Java 编程方面做了很多令人惊讶的努力，但在某些情况下，不当的使用仍然会导致不必要的混乱，大家伙慎用。
好了，我亲爱的读者朋友们，以上就是本文的全部内容了。能在疫情期间坚持看技术文，二哥必须要伸出大拇指为你点个赞 。原创不易，如果觉得有点用的话，请不要吝啬你手中点赞的权力——因为这将是我写作的最强动力。
8.4 Java 14 新特性Java 14 的时候，新增了记录 Record、模式匹配 instanceof 等新特性，转正了 Java 12 时的 switch 表达式，我们一起来过一遍。

01、下载 JDK 14 

截止到2023年03月30日，Java 20 已经发布了，不过不是 LTS（长期支持）版本，Java 17、11、8 是目前提供支持的 LTS 版本。

要想开箱，得先下载 JDK 14（如果你有更高版本，当然也可以），不然拿什么开箱呢，对吧？有 2 处地方可供下载，Oracle 上可以下载商用版， jdk.java.net  上可以下载开源版。我们就选择后者吧。

我目前用的是 Windows 操作系统，所以就选择 Windows 版的 zip 包进行下载，完成后记得解压。
02、升级 IntelliJ IDEA 

截止到 2023年03月30日，Intellij IDEA 的最新版本是 2023.1。 

需要把 IDEA 升级到抢先体验版 2020.1 EAP（如果你当前使用的版本大于此，当然也可以），否则无法支持 Java 14 的新特性。

社区版的下载地址如下所示：
12[https:&#x2F;&#x2F;www.jetbrains.com&#x2F;idea&#x2F;nextversion&#x2F;#section&#x3D;windows](https:&#x2F;&#x2F;www.jetbrains.com&#x2F;idea&#x2F;nextversion&#x2F;#section&#x3D;windows)
安装的时候可以把之前的版本卸载，也可以选择保留。完成后，我们来新建一个 Java 14 的项目。

01、instanceof 
按照新特性的顺序，我们就先从 instanceof 说起吧。旧式的 instanceof 的用法如下所示：
123456789public class OldInstanceOf {    public static void main(String[] args) {        Object str &#x3D; &quot;Java 14，真香&quot;;        if (str instanceof String) {            String s &#x3D; (String)str;            System.out.println(s.length());        }    }}
需要先使用 instanceof 在 if 条件中判断 str 的类型是否为 String（第一步），再在  if 语句中将 str 强转为字符串类型（第二步），并且要重新声明一个变量用于强转后的赋值（第三步）。
三个步骤也不算多，但总觉得应该还有更好的语法，这不，Java 14 就想到了这一层。
12345678public class NewInstanceOf {    public static void main(String[] args) {        Object str &#x3D; &quot;Java 14，真香&quot;;        if (str instanceof String s) {            System.out.println(s.length());        }    }}
可以直接在 if 条件判断类型的时候添加一个变量，就不需要再强转和声明新的变量了。是不是特别简洁？但模式匹配的 instanceof 在 Java 14 中是预览版的，默认是不启用的，所以这段代码会有一个奇怪的编译错误（Java 14 中不支持模式匹配的 instanceof）。

那怎么解决这个问题呢？需要在项目配置中手动设置一下语言的版本。

设置完成后，编译错误就随风飘走了。程序输出的结果如下所示：
110
不错不错，真香。想知道 Java 编译器在背后帮我们做了什么吗？看一下反编译后的字节码就明白了。
1234567891011public class NewInstanceOf {    public NewInstanceOf() {    }    public static void main(String[] args) {        Object str &#x3D; &quot;Java 14，真香&quot;;        String s;        if (str instanceof String &amp;&amp; (s &#x3D; (String)str) &#x3D;&#x3D; (String)str) {            System.out.println(s.length());        }    }}
在 if 条件判断前，先声明了变量 s，然后在 if  条件中进行了强转 s &#x3D; (String)str) ，并且判断了 s 和 str 是否相等。确实是一个解放开放者生产力的好特性，强烈希望这个特性在下个版本中转正。
02、Records 
在之前的一篇文章中，我谈到了类的不可变性，它是这样定义的：
123456789101112131415public final class Writer {    private final String name;    private final int age;    public Writer(String name, int age) {        this.name &#x3D; name;        this.age &#x3D; age;    }    public int getAge() {        return age;    }    public String getName() {        return name;    }}
那么，对于 Records 来说，一条 Record 就代表一个不变的状态。尽管它会提供诸如 equals() 、hashCode() 、 toString() 、构造方法，以及字段的 getter，但它无意替代可变对象的类（没有 setter），以及 Lombok 提供的功能。
来用 Records 替代一下上面这个 Writer 类：
1public record Writer(String name, int age) { }
你看，一行代码就搞定。关键是比之前的代码功能更丰富，来看一下反编译后的字节码：
12345678910public final class Writer extends java.lang.Record {    private final java.lang.String name;    private final int age;    public Writer(java.lang.String name, int age) { &#x2F;* compiled code *&#x2F; }    public java.lang.String toString() { &#x2F;* compiled code *&#x2F; }    public final int hashCode() { &#x2F;* compiled code *&#x2F; }    public final boolean equals(java.lang.Object o) { &#x2F;* compiled code *&#x2F; }    public java.lang.String name() { &#x2F;* compiled code *&#x2F; }    public int age() { &#x2F;* compiled code *&#x2F; }}
类是 final 的，字段是 private final 的，构造方法有两个参数， toString() 、 hashCode() 、 equals() 方法也有了，getter 方法也有了，只不过没有 get 前缀。但是没有 setter 方法，也就是说 Records 确实针对的是不可变对象——鉴定完毕。那怎么使用 Records 呢？
1234567891011public class WriterDemo {    public static void main(String[] args) {        Writer writer &#x3D; new Writer(&quot;沉默王二&quot;,18);        System.out.println(&quot;toString：&quot; + writer);        System.out.println(&quot;hashCode：&quot; + writer.hashCode());        System.out.println(&quot;name：&quot; + writer.name());        System.out.println(&quot;age：&quot; + writer.age());        Writer writer1 &#x3D; new Writer(&quot;沉默王二&quot;, 18);        System.out.println(&quot;equals：&quot; + (writer.equals(writer1)));    }}
程序输出的结果如下所示：
12345toString：Writer[name&#x3D;沉默王二, age&#x3D;18]hashCode：1130697218name：沉默王二age：18equals：true
不错不错，真香，以后定义不可变类时就简单了，强烈希望这个特性在下个版本中转正。
03、switch 表达式 
关于 switch 表达式，我在之前的一篇文章中已经详细说明了，点击传送门可以跳转过去看看。两周时间过去了，switch 表达式终于“媳妇熬成婆”，转正了，恭喜恭喜。
记得这篇文章发表到掘金的时候，被喷子各种无脑 diss，说：“还以为你有什么技巧，没想到用的是 Java 13，可我们还停留在 Java 8 啊！”这显然是一种固步自封的心态，非常不可取，程序员不应该这样。一个最简单的道理就是，Java 6 当年也很经典，不是被 Java 8 取代了吗？随着时间的推移，Java 8 早晚会被更划时代的新版本取代——总要进步嘛。
关于 switch 表达式，这里就简单地搬个例子给你瞧瞧：
123456789101112131415161718192021public class SwitchDemo {    enum PlayerTypes {        TENNIS,        FOOTBALL,        BASKETBALL,        PINGPANG,        UNKNOWN    }    public static void main(String[] args) {        System.out.println(createPlayer(PlayerTypes.BASKETBALL));    }    private static String createPlayer(PlayerTypes playerType) {        return switch (playerType) {            case TENNIS -&gt; &quot;网球运动员费德勒&quot;;            case FOOTBALL -&gt; &quot;足球运动员C罗&quot;;            case BASKETBALL -&gt; &quot;篮球运动员詹姆斯&quot;;            case PINGPANG -&gt; &quot;乒乓球运动员马龙&quot;;            case UNKNOWN -&gt; throw new IllegalArgumentException(&quot;未知&quot;);        };    }}
除了可以使用 -&gt; 的新式语法，还可以作为 return 结果，真香。
04、Text Blocks 
在文本块（Text Blocks）出现之前，如果我们需要拼接多行的字符串，就需要很多英文双引号和加号，看起来就好像老太婆的裹脚布，非常不雅。如果恰好要拼接一些 HTML 格式的文本（原生 SQL 也是如此）的话，还要通过空格进行排版，通过换行转义符 \n 进行换行，这些繁琐的工作对于一名开发人员来说，简直就是灾难。
12345678910public class OldTextBlock {    public static void main(String[] args) {        String html &#x3D; &quot;&lt;html&gt;\n&quot; +                &quot;    &lt;body&gt;\n&quot; +                &quot;        &lt;p&gt;Hello, world&lt;&#x2F;p&gt;\n&quot; +                &quot;    &lt;&#x2F;body&gt;\n&quot; +                &quot;&lt;&#x2F;html&gt;\n&quot;;        System.out.println(html);    }}
Java 14 就完全不同了：
123456789101112public class NewTextBlock {    public static void main(String[] args) {        String html &#x3D; &quot;&quot;&quot;              &lt;html&gt;                  &lt;body&gt;                      &lt;p&gt;Hello, world&lt;&#x2F;p&gt;                  &lt;&#x2F;body&gt;              &lt;&#x2F;html&gt;              &quot;&quot;&quot;;        System.out.println(html);    }}
多余的英文双引号、加号、换行转义符，统统不见了。仅仅是通过前后三个英文双引号就实现了。我只能说，香，它真的香！
9 Java 网络编程9.1 了解网络编程的基础知识   在学习 Java 网络编程之前，我们先来了解什么是计算机网络。
   计算机网络是指两台或更多的计算机组成的网络，在同一个网络中，任意两台计算机都可以直接通信，因为所有计算机都需要遵循同一种网络协议。
   下面是一张简化的网络拓扑图。


用户设备：Laptop，用于访问网络资源。
网络交换机：Switch，用于连接局域网内的设备，例如 Laptop 和 Router。
路由器：Router，用于连接不同网络，将局域网与互联网相连。
防火墙：Firewall，用于保护网络内部资源，阻止未经授权的访问。
互联网：Internet，提供连接到其他网络和全球信息资源。
服务器：Server，用于托管网络应用程序和数据。
那什么是互联网呢？互联网是网络的网络（Internet），即把很多计算机网络连接起来，形成一个全球统一的互联网。
对某个特定的计算机网络来说，它可能使用网络协议 ABC，而另一个计算机网络可能使用网络协议 XYZ。如果计算机网络各自的通讯协议不统一，就没法把不同的网络连接起来形成互联网。因此，为了把计算机网络接入互联网，就必须使用 TCP&#x2F;IP 协议。


TCP&#x2F;IP 协议泛指互联网协议，其中最重要的两个协议是 TCP 协议和 IP 协议。只有使用 TCP&#x2F;IP 协议的计算机才能够联入互联网，使用其他网络协议（例如 NetBIOS、AppleTalk 协议等）是无法联入互联网的。
IP 地址 
  在互联网中，一个 IP 地址用于唯一标识一个网络接口（Network Interface）。一台联入互联网的计算机肯定有一个 IP 地址，但也可能有多个 IP 地址。
 IP 地址分为 IPv4 和 IPv6 两种。IPv4 采用 32 位地址，类似 101.202.99.12 ，而 IPv6 采用 128 位地址，类似 2001:0DA8:100A:0000:0000:1020:F2F3:1428 。IPv4 地址总共有 232 个（大约 42 亿），而 IPv6 地址则总共有 2128 个（大约 340 万亿亿亿亿），IPv4 的地址目前已耗尽，而 IPv6 的地址是根本用不完的。
 IP 地址又分为公网 IP 地址和内网 IP 地址。公网 IP 地址可以直接被访问，内网 IP 地址只能在内网访问。内网 IP 地址类似于：

192.168.x.x
10.x.x.x
 有一个特殊的 IP 地址，称之为本机地址，它总是 127.0.0.1 。
 IPv4 地址实际上是一个 32 位整数。例如：


1231707762444 &#x3D; 0x65ca630c           &#x3D; 65  ca  63 0c           &#x3D; 101.202.99.12
   如果一台计算机只有一个网卡，并且接入了网络，那么，它有一个本机地址 127.0.0.1 ，还有一个 IP 地址，例如 101.202.99.12 ，可以通过这个 IP 地址接入网络。
   如果一台计算机有两块网卡，那么除了本机地址，它可以有两个 IP 地址，可以分别接入两个网络。通常连接两个网络的设备是路由器或者交换机，它至少有两个 IP 地址，分别接入不同的网络，让网络之间连接起来。
  如果两台计算机位于同一个网络，那么他们之间可以直接通信，因为他们的 IP 地址前段是相同的，也就是网络号是相同的。网络号是 IP 地址通过子网掩码过滤后得到的。例如：
   某台计算机的 IP 是 101.202.99.2 ，子网掩码是 255.255.255.0 ，那么计算该计算机的网络号是：
123IP &#x3D; 101.202.99.2Mask &#x3D; 255.255.255.0Network &#x3D; IP &amp; Mask &#x3D; 101.202.99.0
   每台计算机都需要正确配置 IP 地址和子网掩码，根据这两个就可以计算网络号，如果两台计算机计算出的网络号相同，说明两台计算机在同一个网络，可以直接通信。如果两台计算机计算出的网络号不同，那么两台计算机不在同一个网络，不能直接通信，它们之间必须通过路由器或者交换机这样的网络设备间接通信，我们把这种设备称为网关。
   网关的作用就是连接多个网络，负责把来自一个网络的数据包发到另一个网络，这个过程叫路由。
   所以，一台计算机的一个网卡会有 3 个关键配置：

IP 地址，例如： 10.0.2.15
子网掩码，例如： 255.255.255.0
网关的 IP 地址，例如： 10.0.2.2

域名 *
   因为直接记忆 IP 地址非常困难，所以我们通常使用域名访问某个特定的服务。域名解析服务器 DNS 负责把域名翻译成对应的 IP，客户端再根据 IP 地址访问服务器。
   用 nslookup可以查看域名对应的 IP 地址：
123456$ nslookup www.tobebetterjavaer.comServer:  xxx.xxx.xxx.xxxAddress: xxx.xxx.xxx.xxx#53Non-authoritative answer:Name:    www.tobebetterjavaer.comAddress: 47.98.33.223
有一个特殊的本机域名 localhost ，它对应的 IP 地址总是本机地址 127.0.0.1 。
网络模型 
由于计算机网络从底层的传输到高层的软件设计十分复杂，要合理地设计计算机网络模型，必须采用分层模型，每一层负责处理自己的操作。OSI（Open System Interconnect）网络模型是 ISO 组织定义的一个计算机互联的标准模型，注意它只是一个定义，目的是为了简化网络各层的操作，提供标准接口便于实现和维护。这个模型从上到下依次是：

应用层，提供应用程序之间的通信；
表示层：处理数据格式，加解密等等；
会话层：负责建立和维护会话；
传输层：负责提供端到端的可靠传输；
网络层：负责根据目标地址选择路由来传输数据；
链路层和物理层负责把数据进行分片并且真正通过物理网络传输，例如，无线网、光纤等。

互联网实际使用的 TCP&#x2F;IP 模型并不是对应到 OSI 的 7 层模型，而是大致对应 OSI 的 5 层模型：

常用协议 
IP 协议是一个分组交换，它不保证可靠传输。而 TCP 协议是传输控制协议，它是面向连接的协议，支持可靠传输和双向通信。TCP 协议是建立在 IP 协议之上的，简单地说，IP 协议只负责发数据包，不保证顺序和正确性，而 TCP 协议负责控制数据包传输，它在传输数据之前需要先建立连接，建立连接后才能传输数据，传输完后还需要断开连接。TCP 协议之所以能保证数据的可靠传输，是通过接收确认、超时重传这些机制实现的。并且，TCP 协议允许双向通信，即通信双方可以同时发送和接收数据。
TCP 协议也是应用最广泛的协议，许多高级协议都是建立在 TCP 协议之上的，例如 HTTP、SMTP 等。
TCP（传输控制协议）和 IP（互联网协议）通常一起使用，被称为 TCP&#x2F;IP 协议。
TCP&#x2F;IP 协议栈分为四层：应用层、传输层、网络层和链路层。IP 协议位于网络层，负责将数据包从源主机路由到目标主机；TCP 协议位于传输层，负责在源主机和目标主机之间建立可靠的连接并确保数据的有序传输。

UDP 协议（User Datagram Protocol）是一种数据报文协议，它是无连接协议，不保证可靠传输。因为 UDP 协议在通信前不需要建立连接，因此它的传输效率比 TCP 高，而且 UDP 协议比 TCP 协议要简单得多。
选择 UDP 协议时，传输的数据通常是能容忍丢失的，例如，一些语音视频通信的应用会选择 UDP 协议。
小结 
计算机网络的基本概念主要有：

计算机网络：由两台或更多计算机组成的网络；
互联网：连接网络的网络；
IP 地址：计算机的网络接口（通常是网卡）在网络中的唯一标识；
网关：负责连接多个网络，并在多个网络之间转发数据的计算机，通常是路由器或交换机；
网络协议：互联网使用 TCP&#x2F;IP 协议，它泛指互联网协议簇；
IP 协议：一种分组交换传输协议；
TCP 协议：一种面向连接，可靠传输的协议；
UDP 协议：一种无连接，不可靠传输的协议。

9.2 网络编程的核心套接字Socket在古代，由于通信不便利，一些聪明的人就利用鸽子会飞且飞得比较快、会辨认方向的优点，对其进行了驯化，用来进行消息的传递——也就是所谓的“飞鸽传书”。而在 Java 中，网络套接字（Socket）扮演了同样的角色。
套接字（Socket）是一个抽象层，应用程序可以通过它发送或接收数据；就像操作文件那样可以打开、读写和关闭。套接字允许应用程序将 I&#x2F;O 应用于网络中，并与其他应用程序进行通信。网络套接字是 IP 地址与端口的组合。
01、ping 与 telnet 
“老王啊，能不能帮我看一下这个问题呢，明明本地可以进行网络通信，可等我部署到服务器上时就通信不了了，搞了半天也不知道什么原因，我看代码是没有问题的。”小二的语气中充满了沮丧。
“ping 过吗？或者 telnet 了吗？”老王头都没回，冷冰冰地扔出去了这句话。
“哦，我去试试。”小二心头掠过一丝愧疚。
ping 与 telnet 这两个命令，对调试网络程序有着非常大的帮助。
ping，一种计算机网络工具，用来测试数据包能否透过 IP 协议到达特定主机。ping 会向目标主机发出一个 ICMP 的请求回显数据包，并等待接收回显响应数据包。
例如，我们 ping 一下博客园。截图如下。

telnet，Internet 远程登录服务的标准协议和主要方式，可以让我们坐在家里的计算机面前，登录到另一台远在天涯海角的远程计算机上。

在 Windows 系统中，telnet 一般是默认安装的，但未激活（可以在控制面板中激活它）。
例如，我们 telnet 一下火（shui）土（mu）社区。截图如下。

使用 telnet 登录远程计算机时，需要远程计算机上运行一个服务，它一直不停地等待那些希望和它进行连接的网络请求；当接收到一个客户端的网络连接时，它便唤醒正在监听网络连接请求的服务器进程，并为两者建立连接。连接会一直保持，直到某一方中止。
不过，需要注意的是，telnet 在格外重视安全的现代网络技术中并不受到重用。因为 telnet 是一个明文传输协议，用户的所有内容（包括用户名和密码）都没有经过加密，安全隐患非常大。
02、Socket 实例 
不知道你有没有体验一下 telnet 火土社区的那条命令，结果非常有趣。我们也可以通过 Java 的客户端套接字（Socket）实现，代码示例如下。
123456789101112try (Socket socket &#x3D; new Socket(&quot;bbs.newsmth.net&quot;, 23);) {    InputStream is &#x3D; socket.getInputStream();    Scanner scanner &#x3D; new Scanner(is, &quot;gbk&quot;);    while (scanner.hasNextLine()) {        String line &#x3D; scanner.nextLine();        System.out.println(line);    }} catch (UnknownHostException e) {    e.printStackTrace();} catch (IOException e) {    e.printStackTrace();}
1）建立套接字连接非常简单，只需要一行代码：
1Socket socket &#x3D; new Socket(host, port)
host 为主机名，port 为端口号（23 为默认的 telnet 端口号）。如果无法确定主机的 IP 地址，则抛出 UnknownHostException 异常；如果在创建套接字时发生 IO 错误，则抛出 IOException 异常。
需要注意的是，套接字在建立的时候，如果远程主机不可访问，这段代码就会阻塞很长时间，直到底层操作系统的限制而抛出异常。所以一般会在套接字建立后设置一个超时时间。
12Socket socket &#x3D; new Socket(...);socket.setSoTimeout(10000); &#x2F;&#x2F; 单位为毫秒
2）套接字连接成功后，可以通过 java.net.Socket 类的 getInputStream() 方法获取输入流。有了 InputStream 对象后，可以借助文本扫描器类（Scanner）将其中的内容打印出来。
123456InputStream is &#x3D; socket.getInputStream();Scanner scanner &#x3D; new Scanner(is, &quot;gbk&quot;);while (scanner.hasNextLine()) {    String line &#x3D; scanner.nextLine();    System.out.println(line);}
部分结果（完整结果自己亲手实践一下哦）如下图所示：

03、ServerSocket 实例 
接下来，我们模拟一个远程服务，通过 java.net.ServerSocket 实现。代码示例如下。
123456789101112131415161718192021try (ServerSocket server &#x3D; new ServerSocket(8888);        Socket socket &#x3D; server.accept();        InputStream is &#x3D; socket.getInputStream();        OutputStream os &#x3D; socket.getOutputStream();        Scanner scanner &#x3D; new Scanner(is)) {    PrintWriter pw &#x3D; new PrintWriter(new OutputStreamWriter(os, &quot;gbk&quot;), true);    pw.println(&quot;你好啊，欢迎关注「沉默王二」 公众号，回复关键字「2048」 领取程序员进阶必读资料包&quot;);    boolean done &#x3D; false;    while (!done &amp;&amp; scanner.hasNextLine()) {        String line &#x3D; scanner.nextLine();        System.out.println(line);        if (&quot;2048&quot;.equals(line)) {            done &#x3D; true;        }    }} catch (UnknownHostException e) {    e.printStackTrace();} catch (IOException e) {    e.printStackTrace();}
1）建立服务器端的套接字也比较简单，只需要指定一个能够独占的端口号就可以了（0~1023 这些端口都已经被系统预留了）。
1ServerSocket server &#x3D; new ServerSocket(8888);
2）调用 ServerSocket 对象的 accept() 等待客户端套接字的连接请求。一旦监听到客户端的套接字请求，就会返回一个表示连接已建立的 Socket 对象，可以从中获取到输入流和输出流。
123Socket socket &#x3D; server.accept();InputStream is &#x3D; socket.getInputStream();OutputStream os &#x3D; socket.getOutputStream();
客户端套接字发送的所有信息都会包裹在服务器端套接字的输入流中；而服务器端套接字发送的所有信息都会包裹在客户端套接字的输出流中。
3）服务器端可以通过以下代码向客户端发送消息。
12PrintWriter pw &#x3D; new PrintWriter(new OutputStreamWriter(os, &quot;gbk&quot;), true);pw.println(&quot;你好啊，欢迎关注「沉默王二」 公众号，回复关键字「2048」 领取程序员进阶必读资料包&quot;);
4）服务器端可以通过以下代码读取客户端发送过来的消息。
123456789Scanner scanner &#x3D; new Scanner(is);boolean done &#x3D; false;while (!done &amp;&amp; scanner.hasNextLine()) {    String line &#x3D; scanner.nextLine();    System.out.println(line);    if (&quot;2048&quot;.equals(line)) {        done &#x3D; true;    }}
运行该服务后，可以通过 telnet localhost 8888 命令连接该远程服务，不出所料，你将会看到以下信息。

PS：可以在当前命令窗口中输入 2048，服务端收到该消息后会中断该套接字连接（当前窗口会显示“遗失对主机的连接”）。
04、为多个客户端服务 
非常遗憾的是，上面的例子中，服务器端只能为一个客户端服务——这不符合服务器端一对多的要求。
优化方案也非常简单（你应该也能想得到）：服务器端接收到客户端的套接字请求时，可以启动一个线程来处理，而主程序继续等待下一个连接。代码示例如下。
1234567891011121314try (ServerSocket server &#x3D; new ServerSocket(8888)) {    while (true) {        Socket socket &#x3D; server.accept();        Thread thread &#x3D; new Thread(new Runnable() {            @Override            public void run() {              &#x2F;&#x2F; 套接字处理程序            }        });        thread.start();    }} catch (IOException e) {    e.printStackTrace();}
线程内部（ run(){} 方法里）用来处理套接字，代码示例如下：
12345678910111213141516try {    InputStream is &#x3D; socket.getInputStream();    OutputStream os &#x3D; socket.getOutputStream();    Scanner scanner &#x3D; new Scanner(is);   &#x2F;&#x2F; 其他代码省略   &#x2F;&#x2F; 向客户端发送消息   &#x2F;&#x2F; 读取客户端发送过来的消息} catch (IOException e) {    e.printStackTrace();} finally {    try {        socket.close();    } catch (IOException e) {        e.printStackTrace();    }}
服务器端代码优化后重新运行，你就可以通过 telnet 命令测试了。打开一个命令行窗口输入 telnet localhost 8888 ，再打开一个新的命令行窗口输入 telnet localhost 8888 ，多个窗口都可以和服务器端进行通信，除非服务器端代码中断运行。
05、加入多线程 
多线程我们后面会详细讲，这里就主要是写个例子，好让大家感觉更有趣一些，其实也非常简单。
来看服务端：
12345678910111213141516171819202122232425262728293031323334353637import java.io.*;import java.net.ServerSocket;import java.net.Socket;public class MultiThreadedServer {    public static void main(String[] args) throws IOException {        int port &#x3D; 12345;        ServerSocket serverSocket &#x3D; new ServerSocket(port);        System.out.println(&quot;Server is listening on port &quot; + port);        while (true) {            Socket socket &#x3D; serverSocket.accept();            System.out.println(&quot;Client connected&quot;);            new ClientHandler(socket).start();        }    }}class ClientHandler extends Thread {    private Socket socket;    public ClientHandler(Socket socket) {        this.socket &#x3D; socket;    }    public void run() {        try {            InputStream input &#x3D; socket.getInputStream();            BufferedReader reader &#x3D; new BufferedReader(new InputStreamReader(input));            OutputStream output &#x3D; socket.getOutputStream();            PrintWriter writer &#x3D; new PrintWriter(output, true);            String line;            while ((line &#x3D; reader.readLine()) !&#x3D; null) {                System.out.println(&quot;Received: &quot; + line);                writer.println(&quot;Server: &quot; + line);            }            socket.close();        } catch (IOException e) {            System.out.println(&quot;Client disconnected&quot;);        }    }}
在这个示例中，我们使用了一个 ClientHandler 类，该类继承自 Thread 类。这使得每个客户端连接都可以在单独的线程中处理，从而允许服务器同时处理多个客户端连接。当一个新客户端连接到服务器时，服务器会创建一个新的 ClientHandler 对象，并使用 start() 方法启动线程。ClientHandler 类的 run() 方法包含处理客户端请求的逻辑。
来看客户端代码：
123456789101112131415161718import java.io.*;import java.net.Socket;public class Client {    public static void main(String[] args) throws IOException {        String hostname &#x3D; &quot;localhost&quot;;        int port &#x3D; 12345;        Socket socket &#x3D; new Socket(hostname, port);        System.out.println(&quot;Connected to the server&quot;);        InputStream input &#x3D; socket.getInputStream();        BufferedReader reader &#x3D; new BufferedReader(new InputStreamReader(input));        OutputStream output &#x3D; socket.getOutputStream();        PrintWriter writer &#x3D; new PrintWriter(output, true);        writer.println(&quot;Hello, server!&quot;);        String response &#x3D; reader.readLine();        System.out.println(&quot;Server response: &quot; + response);        socket.close();    }}
启动服务器端，然后多启动几个客户端，就可以体验到交互的乐趣了。

08、DatagramSocket 实例 
DatagramSocket 类是 Java 中实现 UDP 协议的核心类。与基于 TCP 的 Socket 和 ServerSocket 类不同，DatagramSocket 类提供了无连接的通信服务，发送和接收数据包。由于无需建立连接，UDP 通常比 TCP 更快，但可能不如 TCP 可靠。
以下是一个简单的 DatagramSocket 示例，展示了如何使用 UDP 协议在客户端和服务器之间发送和接收消息。
服务器端代码：
12345678910111213141516import java.io.IOException;import java.net.DatagramPacket;import java.net.DatagramSocket;public class UDPServer {    public static void main(String[] args) throws IOException {        int port &#x3D; 12345;        DatagramSocket serverSocket &#x3D; new DatagramSocket(port);        System.out.println(&quot;Server is listening on port &quot; + port);        byte[] buffer &#x3D; new byte[1024];        DatagramPacket packet &#x3D; new DatagramPacket(buffer, buffer.length);        serverSocket.receive(packet);        String message &#x3D; new String(packet.getData(), 0, packet.getLength());        System.out.println(&quot;Received: &quot; + message);        serverSocket.close();    }}
客户端代码：
1234567891011121314151617import java.io.IOException;import java.net.*;public class UDPClient {    public static void main(String[] args) throws IOException {        String hostname &#x3D; &quot;localhost&quot;;        int port &#x3D; 12345;        InetAddress address &#x3D; InetAddress.getByName(hostname);        DatagramSocket clientSocket &#x3D; new DatagramSocket();        String message &#x3D; &quot;Hello, server!&quot;;        byte[] buffer &#x3D; message.getBytes();        DatagramPacket packet &#x3D; new DatagramPacket(buffer, buffer.length, address, port);        clientSocket.send(packet);        System.out.println(&quot;Message sent&quot;);        clientSocket.close();    }}
在这个示例中，服务器端创建一个 DatagramSocket 对象并监听端口 12345。然后，它创建一个 DatagramPacket 对象，用于存储接收到的数据包。 serverSocket.receive(packet) 方法阻塞，直到收到一个数据包。收到数据包后，服务器从数据包中提取并打印消息。
客户端首先解析服务器的 IP 地址，然后创建一个 DatagramSocket 对象。接着，客户端创建一个包含要发送消息的 DatagramPacket 对象，并指定目标地址和端口。最后，客户端通过调用 clientSocket.send(packet) 方法发送数据包。
运行结果如下所示：

07、最后 
如今大多数基于网络的软件，如浏览器、即时通讯工具甚至是 P2P 下载都是基于 Socket 实现的，所以掌握 Java Socket 编程还是蛮有必要的。Socket 编程也比较有趣，很多初学者都会编写一两个基于“客户端-服务器端”的小程序来提高自己的编程水平，建议你也试一试。
9.3 用Socket实现一个HTTP服务器作为一个 Java 后端，提供 HTTP 服务可以说是基本技能之一了，但是你真的了解 HTTP 协议么？你知道知道如何手撸一个 HTTP 服务器么？Tomcat 的底层是怎么支持 HTTP 服务的呢？大名鼎鼎的 Servlet 又是什么东西呢，该怎么使用呢？
在初学 Java 时，Socket 编程是逃不掉的一章；虽然在实际业务项目中，使用这个的可能性基本为 0， 但并不意味着不用学。本篇将主要介绍如何使用 Socket 来实现一个简单的 HTTP 服务器，提供常见的 get&#x2F;post 请求支持，并在此过程中了解下 HTTP 协议。
I. HTTP 服务器从 0 到 1 
既然我们的目标是借助 Socket 来搭建 HTTP 服务器，那么我们首先需要确认两点，一是如何使用 Socket；另一个则是 HTTP 协议如何解析数据；下面分别进行说明。
1.Socket 编程基础 
我们这里主要是利用 ServerSocket 来绑定端口，提供 TCP 服务，基本使用姿势也比较简单，一般套路如下

创建 ServerSocket 对象，绑定监听端口
通过 accept() 方法监听客户端请求
连接建立后，通过输入流读取客户端发送的请求信息
通过输出流向客户端发送响应信息
关闭相关资源

对应的伪代码如下:
12345678910ServerSocket serverSocket &#x3D; new ServerSocket(port, ip)serverSocket.accept();&#x2F;&#x2F; 接收请求数据socket.getInputStream();&#x2F;&#x2F; 返回数据给请求方out &#x3D; socket.getOutputStream()out.print(xxx)out.flush();;&#x2F;&#x2F; 关闭连接socket.close()
具体的代码，我们前面的章节详细地讲过了，第一次来的小伙伴可以戳链接去学习一下。
2.HTTP 协议 
ServerSocket 走的是 TCP 协议，HTTP 协议本身是在 TCP 协议之上的一层。
TCP 是一种面向连接的、可靠的、基于字节流的传输层协议。TCP 在两个网络节点之间提供了一条可靠的通信信道，确保数据在传输过程中不会丢失、重复或乱序。TCP 使用握手过程建立连接，通过确认和重传机制确保数据可靠传输，并使用流量控制和拥塞控制算法来优化网络性能。
HTTP 是一个用于在 Web 浏览器和 Web 服务器之间传输超文本、图像、视频和其他媒体资源的应用层协议。HTTP 使用请求-响应模型，即客户端（通常是 Web 浏览器）发送请求给服务器，服务器处理请求并返回响应。HTTP 协议定义了一组方法（如 GET、POST、PUT、DELETE 等），用于指定请求的类型和目的。
此外，HTTP 协议还定义了一组状态代码（如 200、404、500 等），用于表示响应的结果。
HTTP 协议依赖于 TCP 协议来传输数据。当 Web 浏览器向 Web 服务器发送 HTTP 请求时，它首先使用 TCP 协议与服务器建立连接。一旦连接建立，HTTP 请求消息会被封装在 TCP 数据包中，然后通过 TCP 信道发送给服务器。服务器收到 TCP 数据包后，解包提取 HTTP 请求消息，处理请求并生成 HTTP 响应消息。最后，HTTP 响应消息被封装在 TCP 数据包中，并通过相同的 TCP 信道发送回客户端。客户端收到 TCP 数据包后，解包提取 HTTP 响应消息并显示给用户。

这幅图展示了客户端（Web 浏览器）与服务器（Web 服务器）之间的 HTTP 请求和响应，它们通过可靠的、面向连接的 TCP 连接进行数据传输。
好，再说回 HTTP 服务器这件事，最需要关注的无非两点：

请求的数据怎么按照 HTTP 协议解析出来
如何按照 HTTP 协议，返回数据

所以我们需要知道数据格式的规范。
请求消息
HTTP 请求消息由请求行（Request Line）、请求头（Request Headers）、空行（Empty Line）、请求体（Request Body，可选）几个部分组成。
①、请求行又包含三个部分，HTTP 方法（例如 GET, POST, PUT, DELETE 等）、请求的目标 URL（通常是相对 URL，但也可以是绝对 URL）、HTTP 版本（例如 HTTP&#x2F;1.1 或 HTTP&#x2F;2），这些部分用空格分隔，例如：
1GET &#x2F;index.html HTTP&#x2F;1.1
②、请求头是一系列以键值对表示的元数据，用于描述请求的附加信息。每个请求头占一行，键和值之间用冒号（:）分隔。请求头包含诸如 Host、User-Agent、Content-Type、Content-Length、Accept 等信息。
例如：
123Host: www.tobebetterjavaer.comUser-Agent: Mozilla&#x2F;5.0Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8
③、请求头和请求体之间有一个空行，表示请求头的结束。
④、对于某些 HTTP 方法（例如 POST、PUT 等），还可以在请求消息中包含请求体。请求体用于传输要发送给服务器的数据。请求体的格式和内容取决于 Content-Type 请求头的值。
例如，当提交 HTML 表单时，请求体可能如下所示：
1username&#x3D;沉默王二&amp;password&#x3D;123456
将这些部分放在一起，就构成了一个完整的 HTTP 请求消息：
1234567POST &#x2F;login HTTP&#x2F;1.1Host: Host: www.tobebetterjavaer.comUser-Agent: Mozilla&#x2F;5.0Content-Type: application&#x2F;x-www-form-urlencodedContent-Length: 29Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8username&#x3D;沉默王二&amp;password&#x3D;123456
我用一张思维导图来表示下：

响应消息
一个典型的 HTTP 响应消息由三部分组成：状态行（Status Line）、响应头（Response Headers）、响应体（Response Body）。

上面两张图，可以让你对 HTTP 请求和响应有个直观映象，接下来开始抓重点。
不管是请求消息还是响应消息，都可以划分为三部分，这就为我们后面的处理简化了很多工作。

第一行：状态行
第二行到第一个空行：header（请求头&#x2F;相应头）
剩下所有：正文

3.HTTP 服务器设计 
接下来进入正题，基于 Socket 创建一个 HTTP 服务器，使用 Socket 基本没啥太大的问题，我们需要额外关注以下两点：

对请求数据进行解析
封装返回结果

a. 请求数据解析 
我们从 Socket 中拿到所有的数据，然后解析为对应的 HTTP 请求，我们先定义个 Request 对象，内部保存一些基本的 HTTP 信息，接下来重点就是将 Socket 中的所有数据都捞出来，封装为 request 对象。

注意 ，这些代码放在 HttpMessageParser 类中，随后会给出完整的代码。

1234567891011121314151617181920212223@Datapublic static class Request {    &#x2F;**     * 请求方法 GET&#x2F;POST&#x2F;PUT&#x2F;DELETE&#x2F;OPTION...     *&#x2F;    private String method;    &#x2F;**     * 请求的uri     *&#x2F;    private String uri;    &#x2F;**     * HTTP版本     *&#x2F;    private String version;    &#x2F;**     * 请求头     *&#x2F;    private Map&lt;String, String&gt; headers;    &#x2F;**     * 请求参数相关     *&#x2F;    private String message;}
根据前面的 HTTP 协议介绍，解析过程如下，我们先看请求行的解析过程。
请求行，包含三个基本要素：请求方法 + URI + HTTP 版本，用空格进行分割，所以解析代码如下
1234567891011121314&#x2F;** * 根据标准的HTTP协议，解析请求行 * * @param reader * @param request *&#x2F;private static void decodeRequestLine(BufferedReader reader, Request request) throws IOException {    String[] strs &#x3D; StringUtils.split(reader.readLine(), &quot; &quot;);    assert strs.length &#x3D;&#x3D; 3;    request.setMethod(strs[0]);    request.setUri(strs[1]);    request.setVersion(strs[2]);}
请求头的解析，从第二行，到第一个空白行之间的所有数据，都是请求头；请求头的格式也比较清晰，形如 key:value , 具体实现如下：
123456789101112131415161718192021222324&#x2F;**    * 根据标准 HTTP 协议，解析请求头    *    * @param reader  读取请求头的 BufferedReader 对象    * @param request 存储请求信息的 Request 对象    * @throws IOException 当读取请求头信息时发生 I&#x2F;O 异常时，将抛出该异常    *&#x2F;private static void decodeRequestHeader(BufferedReader reader, Request request) throws IOException {    &#x2F;&#x2F; 创建一个 Map 对象，用于存储请求头信息    Map&lt;String, String&gt; headers &#x3D; new HashMap&lt;&gt;(16);    &#x2F;&#x2F; 读取请求头信息，每行都是一个键值对，以空行结束    String line &#x3D; reader.readLine();    String[] kv;    while (!&quot;&quot;.equals(line)) {        &#x2F;&#x2F; 将每行请求头信息按冒号分隔，分别作为键和值存入 Map 中        kv &#x3D; StringUtils.split(line, &quot;:&quot;);        assert kv.length &#x3D;&#x3D; 2;        headers.put(kv[0].trim(), kv[1].trim());        line &#x3D; reader.readLine();    }    &#x2F;&#x2F; 将解析出来的请求头信息存入 Request 对象中    request.setHeaders(headers);}
最后就是正文的解析了，这一块需要注意一点，正文可能为空，也可能有数据；有数据时，我们要如何把所有的数据都取出来呢？
先看具体实现如下：
123456789101112131415161718192021222324&#x2F;** * 根据标注HTTP协议，解析正文 * * @param reader    输入流读取器，用于读取请求中的数据 * @param request   Request 对象，表示 HTTP 请求 * @throws IOException 当发生 I&#x2F;O 错误时抛出 *&#x2F;private static void decodeRequestMessage(BufferedReader reader, Request request) throws IOException {    &#x2F;&#x2F; 从请求头中获取 Content-Length，如果没有，则默认为 0    int contentLen &#x3D; Integer.parseInt(request.getHeaders().getOrDefault(&quot;Content-Length&quot;, &quot;0&quot;));    &#x2F;&#x2F; 如果 Content-Length 为 0，表示没有请求正文，直接返回。    &#x2F;&#x2F; 例如 GET 和 OPTIONS 请求通常不包含请求正文    if (contentLen &#x3D;&#x3D; 0) {        return;    }    &#x2F;&#x2F; 根据 Content-Length 创建一个字符数组来存储请求正文    char[] message &#x3D; new char[contentLen];    &#x2F;&#x2F; 使用 BufferedReader 读取请求正文    reader.read(message);    &#x2F;&#x2F; 将字符数组转换为字符串，并将其设置为 Request 对象的 message    request.setMessage(new String(message));}
注意上面我的使用姿势，首先是根据请求头中的 Content-Type的值，来获得正文的数据大小，因此我们获取的方式是创建一个这么大的 char[] 数组来读取流中所有数据，如果我们的数组比实际的小，则读不完；如果大，则数组中会有一些空的数据；
最后将上面的几个解析封装一下，完成 request 解析：
123456789101112131415161718192021222324252627&#x2F;** * HTTP 请求可以分为三部分： * 1. 请求行：包括请求方法、URI 和 HTTP 协议版本 * 2. 请求头：从第二行开始，直到一个空行为止 * 3. 消息正文：紧跟在空行后的所有内容，长度由请求头中的 Content-Length 决定 * * 本方法将 InputStream 中的 HTTP 请求数据解析为一个 Request 对象 * * @param reqStream  包含 HTTP 请求数据的输入流 * @return           一个表示 HTTP 请求的 Request 对象 * @throws IOException 当发生 I&#x2F;O 错误时抛出 *&#x2F;public static Request parse2request(InputStream reqStream) throws IOException {    &#x2F;&#x2F; 使用 BufferedReader 和 InputStreamReader 读取输入流中的数据    BufferedReader httpReader &#x3D; new BufferedReader(new InputStreamReader(reqStream, &quot;UTF-8&quot;));    &#x2F;&#x2F; 创建一个新的 Request 对象    Request httpRequest &#x3D; new Request();    &#x2F;&#x2F; 解析请求行并设置到 Request 对象中    decodeRequestLine(httpReader, httpRequest);    &#x2F;&#x2F; 解析请求头并设置到 Request 对象中    decodeRequestHeader(httpReader, httpRequest);    &#x2F;&#x2F; 解析消息正文并设置到 Request 对象中    decodeRequestMessage(httpReader, httpRequest);    &#x2F;&#x2F; 返回解析后的 Request 对象    return httpRequest;}
接下来，是请求结果的封装，给一个简单的进行演示：
1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&#x2F;**    * Response 类表示一个 HTTP 响应，包括版本、状态码、状态信息、响应头和响应正文。    *&#x2F;@Datapublic static class Response {    private String version;    private int code;    private String status;    private Map&lt;String, String&gt; headers;    private String message;}&#x2F;**    * 根据给定的 Request 对象和响应字符串构建一个 HTTP 响应。    *    * @param request   用于构建响应的 Request 对象    * @param response  响应字符串    * @return          一个表示 HTTP 响应的字符串    *&#x2F;public static String buildResponse(Request request, String response) {    &#x2F;&#x2F; 创建一个新的 Response 对象，并设置版本、状态码和状态信息    Response httpResponse &#x3D; new Response();    httpResponse.setCode(200);    httpResponse.setStatus(&quot;ok&quot;);    httpResponse.setVersion(request.getVersion());    &#x2F;&#x2F; 设置响应头    Map&lt;String, String&gt; headers &#x3D; new HashMap&lt;&gt;();    headers.put(&quot;Content-Type&quot;, &quot;application&#x2F;json&quot;);    headers.put(&quot;Content-Length&quot;, String.valueOf(response.getBytes().length));    httpResponse.setHeaders(headers);    &#x2F;&#x2F; 设置响应正文    httpResponse.setMessage(response);    &#x2F;&#x2F; 构建响应字符串    StringBuilder builder &#x3D; new StringBuilder();    buildResponseLine(httpResponse, builder);    buildResponseHeaders(httpResponse, builder);    buildResponseMessage(httpResponse, builder);    return builder.toString();}&#x2F;**    * 构建响应行，包括版本、状态码和状态信息。    *    * @param response      用于构建响应行的 Response 对象    * @param stringBuilder 用于拼接响应字符串的 StringBuilder 对象    *&#x2F;private static void buildResponseLine(Response response, StringBuilder stringBuilder) {    stringBuilder.append(response.getVersion()).append(&quot; &quot;).append(response.getCode()).append(&quot; &quot;)            .append(response.getStatus()).append(&quot;\n&quot;);}&#x2F;**    * 构建响应头。    *    * @param response      用于构建响应头的 Response 对象    * @param stringBuilder 用于拼接响应字符串的 StringBuilder 对象    *&#x2F;private static void buildResponseHeaders(Response response, StringBuilder stringBuilder) {    for (Map.Entry&lt;String, String&gt; entry : response.getHeaders().entrySet()) {        stringBuilder.append(entry.getKey()).append(&quot;:&quot;).append(entry.getValue()).append(&quot;\n&quot;);    }    stringBuilder.append(&quot;\n&quot;);}&#x2F;**    * 构建响应正文。    *    * @param response      用于构建响应正文的 Response 对象    * @param stringBuilder 用于拼接响应字符串的 StringBuilder 对象    *&#x2F;private static void buildResponseMessage(Response response, StringBuilder stringBuilder) {    stringBuilder.append(response.getMessage());}
b. 请求任务 HttpTask 
每个请求，单独分配一个任务来干这个事情，就是为了支持并发，对于 ServerSocket 而言，接收到了一个请求，那就创建一个 HttpTask 任务来实现 HTTP 通信。
那么这个 httptask 干啥呢？

从请求中捞数据
响应请求
封装结果并返回

12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&#x2F;** * HttpTask 类实现了 Runnable 接口，用于处理一个 HTTP 请求。 * 当在一个线程中执行时，该任务将处理一个 Socket 连接上的 HTTP 请求， * 并发送响应消息。 *&#x2F;public class HttpTask implements Runnable {    &#x2F;&#x2F; 用于处理 HTTP 请求的 Socket    private Socket socket;    &#x2F;**     * 构造一个新的 HttpTask，用于处理指定的 Socket 连接。     *     * @param socket  用于处理 HTTP 请求的 Socket     *&#x2F;    public HttpTask(Socket socket) {        this.socket &#x3D; socket;    }    &#x2F;**     * 实现 Runnable 接口的 run 方法，用于处理 HTTP 请求并发送响应消息。     *&#x2F;    @Override    public void run() {        &#x2F;&#x2F; 检查 socket 是否为 null，如果为 null 则抛出异常        if (socket &#x3D;&#x3D; null) {            throw new IllegalArgumentException(&quot;socket can&#39;t be null.&quot;);        }        try {            &#x2F;&#x2F; 获取 Socket 的输出流，并创建一个 PrintWriter 对象            OutputStream outputStream &#x3D; socket.getOutputStream();            PrintWriter out &#x3D; new PrintWriter(outputStream);            &#x2F;&#x2F; 从 Socket 的输入流中解析 HTTP 请求            HttpMessageParser.Request httpRequest &#x3D; HttpMessageParser.parse2request(socket.getInputStream());            try {                &#x2F;&#x2F; 根据请求结果进行响应，省略返回                String result &#x3D; null;                                &#x2F;&#x2F; 根据请求和结果构建 HTTP 响应                String httpRes &#x3D; HttpMessageParser.buildResponse(httpRequest, result);                &#x2F;&#x2F; 将 HTTP 响应发送到客户端                out.print(httpRes);            } catch (Exception e) {                &#x2F;&#x2F; 如果发生异常，构建一个包含异常信息的 HTTP 响应                String httpRes &#x3D; HttpMessageParser.buildResponse(httpRequest, e.toString());                out.print(httpRes);            }            &#x2F;&#x2F; 刷新输出流，确保响应消息被发送            out.flush();        } catch (IOException e) {            e.printStackTrace();        } finally {            &#x2F;&#x2F; 关闭 Socket 连接            try {                socket.close();            } catch (IOException e) {                e.printStackTrace();            }        }    }}
c. HTTP 服务搭建 
前面的基本上把该干的事情都干了，剩下的就简单了，创建 ServerSocket ，绑定端口接收请求，我们在线程池中跑这个 HTTP 服务
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class BasicHttpServer {    &#x2F;&#x2F; 创建一个单线程执行器，用于启动 HTTP 服务器    private static ExecutorService bootstrapExecutor &#x3D; Executors.newSingleThreadExecutor();    &#x2F;&#x2F; 创建一个线程池，用于处理来自客户端的 HTTP 请求    private static ExecutorService taskExecutor;    &#x2F;&#x2F; 设置服务器监听的端口号    private static int PORT &#x3D; 8999;    &#x2F;&#x2F; 启动 HTTP 服务器的方法    static void startHttpServer() {        &#x2F;&#x2F; 获取处理器可用核心数，用于设置线程池大小        int nThreads &#x3D; Runtime.getRuntime().availableProcessors();        &#x2F;&#x2F; 初始化线程池，设置线程池大小，队列大小和丢弃策略        taskExecutor &#x3D;                new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;&gt;(100),                        new ThreadPoolExecutor.DiscardPolicy());        &#x2F;&#x2F; 循环尝试启动服务器，如果启动失败，则等待10秒后重试        while (true) {            try {                ServerSocket serverSocket &#x3D; new ServerSocket(PORT);                bootstrapExecutor.submit(new ServerThread(serverSocket));                break;            } catch (Exception e) {                try {                    &#x2F;&#x2F; 重试，等待 10 秒                    TimeUnit.SECONDS.sleep(10);                } catch (InterruptedException ie) {                    Thread.currentThread().interrupt();                }            }        }        &#x2F;&#x2F; 关闭启动执行器        bootstrapExecutor.shutdown();    }    &#x2F;&#x2F; HTTP 服务器主要任务类    private static class ServerThread implements Runnable {        &#x2F;&#x2F; 保存传递给构造函数的 ServerSocket 实例        private ServerSocket serverSocket;        &#x2F;&#x2F; 构造函数        public ServerThread(ServerSocket s) throws IOException {            this.serverSocket &#x3D; s;        }        &#x2F;&#x2F; 任务主体方法        @Override        public void run() {            while (true) {                try {                    &#x2F;&#x2F; 等待客户端连接                    Socket socket &#x3D; this.serverSocket.accept();                    &#x2F;&#x2F; 创建一个 HttpTask 实例，将 Socket 实例作为参数传递                    HttpTask eventTask &#x3D; new HttpTask(socket);                    &#x2F;&#x2F; 将 HttpTask 提交给 taskExecutor 执行                    taskExecutor.submit(eventTask);                } catch (Exception e) {                    e.printStackTrace();                    try {                        &#x2F;&#x2F; 如果发生异常，等待 1 秒后继续尝试                        TimeUnit.SECONDS.sleep(1);                    } catch (InterruptedException ie) {                        Thread.currentThread().interrupt();                    }                }            }        }    }}
这段代码是一个简单的 HTTP 服务器实现。以下是关于这个 HTTP 服务器的主要组件和功能的详细解释：
1、bootstrapExecutor：一个单线程的 ExecutorService，用于执行 HTTP 服务器的启动任务。
2、taskExecutor：一个线程池，用于处理来自客户端的 HTTP 请求。线程池的大小等于处理器可用核心数，队列大小为100，使用 DiscardPolicy 丢弃策略。
3、PORT：服务器侦听的端口号，默认为 8999。
4、startHttpServer() 方法：
12345- a.创建一个线程池 taskExecutor 用于处理 HTTP 请求。- b.在一个循环中，尝试创建一个 ServerSocket 实例并绑定到指定端口。如果失败，则等待 10 秒后重试。- c.当成功创建 ServerSocket 实例后，将其作为参数提交给 bootstrapExecutor 执行 ServerThread 任务。- d.关闭 bootstrapExecutor。
5、ServerThread 类实现了 Runnable 接口，它是 HTTP 服务器的主要任务： 

a.serverSocket 成员变量：保存传递给构造函数的 ServerSocket 实例。 
b.run() 方法： 


在一个无限循环中，调用 serverSocket.accept() 方法等待客户端的连接。 

当接受到一个新的客户端连接时，创建一个 HttpTask 实例，将 Socket 实例作为参数传递。 

将 HttpTask 提交给 taskExecutor 执行。


这个 HTTP 服务器的主要逻辑是：使用一个线程来监听客户端连接，当有新的客户端连接时，创建一个 HttpTask 来处理客户端的 HTTP 请求，并将这个任务提交给线程池 taskExecutor 执行。这样可以实现多个客户端请求的并发处理。
到这里，一个基于 Socket 实现的 HTTP 服务器基本上就搭建完了，接下来就可以进行测试了
4.测试 
做这个服务器，主要是基于项目 quick-fix 产生的，这个项目主要是为了解决应用内部服务访问与数据订正，我们在这个项目的基础上进行测试。
一个完整的 post 请求如下

接下来我们看下打印出返回头的情况

II. 其他 
0.项目源码 

quick-fix
相关代码:
com.git.hui.fix.core.endpoint.BasicHttpServer
com.git.hui.fix.core.endpoint.HttpMessageParser
com.git.hui.fix.core.endpoint.HttpTask

10 Java NIO10.1 NIO比IO强在哪？我花了几天时间去了解NIO 的核心知识，期间看了《Java 编程思想》和《疯狂 Java 讲义》中的 NIO 模块。但是，看完之后还是很迷，不知道 NIO 是干嘛用的，网上的资料和书上的知识点没有很好地对应上。
我这里先给大家展示一副传统 IO 和 NIO 的对比图，感受一下。

传统 IO 基于字节流或字符流（如 FileInputStream、BufferedReader 等）进行文件读写，以及使用 Socket 和 ServerSocket 进行网络传输。
NIO 使用通道（Channel）和缓冲区（Buffer）进行文件操作，以及使用 SocketChannel 和 ServerSocketChannel 进行网络传输。
传统 IO 采用阻塞式模型，对于每个连接，都需要创建一个独立的线程来处理读写操作。当一个线程在等待 I&#x2F;O 操作时，无法执行其他任务。这会导致大量线程的创建和销毁，以及上下文切换，降低了系统性能。
NIO 使用非阻塞模型，允许线程在等待 I&#x2F;O 时执行其他任务。这种模式通过使用选择器（Selector）来监控多个通道（Channel）上的 I&#x2F;O 事件，实现了更高的性能和可伸缩性。
01、NIO 和传统 IO 在操作文件时的差异 
JDK 1.4 中， java.nio.包引入新的 Java I&#x2F;O 库，其目的是提高速度。实际上，“旧”的 I&#x2F;O 包已经使用 NIO*重新实现过，即使我们不显式的使用 NIO 编程，也能从中受益。
nio 翻译成 no-blocking io 或者 new io 都无所谓啦，都说得通~
在《Java 编程思想》读到“即使我们不显式的使用 NIO 编程，也能从中受益”的时候，我是挺在意的，所以：我们测试一下使用 NIO 复制文件和传统 IO 复制文件 的性能：
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class SimpleFileTransferTest {    &#x2F;&#x2F; 使用传统的 I&#x2F;O 方法传输文件    private long transferFile(File source, File des) throws IOException {        long startTime &#x3D; System.currentTimeMillis();        if (!des.exists())            des.createNewFile();        &#x2F;&#x2F; 创建输入输出流        BufferedInputStream bis &#x3D; new BufferedInputStream(new FileInputStream(source));        BufferedOutputStream bos &#x3D; new BufferedOutputStream(new FileOutputStream(des));        &#x2F;&#x2F; 使用数组传输数据        byte[] bytes &#x3D; new byte[1024 * 1024];        int len;        while ((len &#x3D; bis.read(bytes)) !&#x3D; -1) {            bos.write(bytes, 0, len);        }        long endTime &#x3D; System.currentTimeMillis();        return endTime - startTime;    }    &#x2F;&#x2F; 使用 NIO 方法传输文件    private long transferFileWithNIO(File source, File des) throws IOException {        long startTime &#x3D; System.currentTimeMillis();        if (!des.exists())            des.createNewFile();        &#x2F;&#x2F; 创建随机存取文件对象        RandomAccessFile read &#x3D; new RandomAccessFile(source, &quot;rw&quot;);        RandomAccessFile write &#x3D; new RandomAccessFile(des, &quot;rw&quot;);        &#x2F;&#x2F; 获取文件通道        FileChannel readChannel &#x3D; read.getChannel();        FileChannel writeChannel &#x3D; write.getChannel();        &#x2F;&#x2F; 创建并使用 ByteBuffer 传输数据        ByteBuffer byteBuffer &#x3D; ByteBuffer.allocate(1024 * 1024);        while (readChannel.read(byteBuffer) &gt; 0) {            byteBuffer.flip();            writeChannel.write(byteBuffer);            byteBuffer.clear();        }        &#x2F;&#x2F; 关闭文件通道        writeChannel.close();        readChannel.close();        long endTime &#x3D; System.currentTimeMillis();        return endTime - startTime;    }    public static void main(String[] args) throws IOException {        SimpleFileTransferTest simpleFileTransferTest &#x3D; new SimpleFileTransferTest();        File sourse &#x3D; new File(&quot;[电影天堂www.dygod.cn]猜火车-cd1.rmvb&quot;);        File des &#x3D; new File(&quot;io.avi&quot;);        File nio &#x3D; new File(&quot;nio.avi&quot;);        &#x2F;&#x2F; 比较传统的 I&#x2F;O 和 NIO 传输文件的时间        long time &#x3D; simpleFileTransferTest.transferFile(sourse, des);        System.out.println(time + &quot;：普通字节流时间&quot;);        long timeNio &#x3D; simpleFileTransferTest.transferFileWithNIO(sourse, nio);        System.out.println(timeNio + &quot;：NIO时间&quot;);    }}
先解释一下这段代码，里面出现的 RandomAccessFile 我们之前讲过，FileChannel 是 Java NIO（New I&#x2F;O）库中的一个类，它提供了对文件的高效 I&#x2F;O 操作，支持随机访问文件，允许在文件的任意位置进行读写操作。
与 RandomAccessFile 不同，FileChannel 使用了缓冲区（ByteBuffer）进行数据传输。
好，在我给出实际的结论之前，你是否会有这样的结论：

对于较小的文件，NIO 和普通 IO 之间的性能差异可能不会非常明显，因为文件本身较小，复制过程较快。
对于较大的文件，使用 NIO 的性能可能会明显优于普通 IO。因为 NIO 使用了更高效的缓冲区和通道机制，可以在内存中进行更快的数据传输。

然而实际的结果，却会令你大跌眼镜：        
文件越大的情况下，竟然普通字节流（传统 IO）的速度更快(当然了，个人测试，或许不是很准)，那还要 NIO 做什么呢？况且 NIO 的学习成本也比传统 IO 要高一些。
那这意味着我们可以不使用&#x2F;学习 NIO 了吗？
答案是否定的，IO 操作往往在两个场景下会用到：

文件 IO
网络 IO

而 NIO 的魅力主要体现在网络中！
NIO（New I&#x2F;O）的设计目标是解决传统 I&#x2F;O（BIO，Blocking I&#x2F;O）在处理大量并发连接时的性能瓶颈。传统 I&#x2F;O 在网络通信中主要使用阻塞式 I&#x2F;O，为每个连接分配一个线程。当连接数量增加时，系统性能将受到严重影响，线程资源成为关键瓶颈。而 NIO 提供了非阻塞 I&#x2F;O 和 I&#x2F;O 多路复用，可以在单个线程中处理多个并发连接，从而在网络传输中显著提高性能。
以下是 NIO 在网络传输中优于传统 I&#x2F;O 的原因：
①、NIO 支持非阻塞 I&#x2F;O，这意味着在执行 I&#x2F;O 操作时，线程不会被阻塞。这使得在网络传输中可以有效地管理大量并发连接（数千甚至数百万）。而在操作文件时，这个优势没有那么明显，因为文件读写通常不涉及大量并发操作。
②、NIO 支持 I&#x2F;O 多路复用，这意味着一个线程可以同时监视多个通道（如套接字），并在 I&#x2F;O 事件（如可读、可写）准备好时处理它们。这大大提高了网络传输中的性能，因为单个线程可以高效地管理多个并发连接。操作文件时这个优势也无法提现出来。
③、NIO 提供了 ByteBuffer 类，可以高效地管理缓冲区。这在网络传输中很重要，因为数据通常是以字节流的形式传输。操作文件的时候，虽然也有缓冲区，但优势仍然不够明显。
02、NIO 和传统 IO 在网络传输中的差异 
来看服务器端代码的差别。
IO，用的套接字，代码比较简单，我就不加注释了，之前学过，应该都能看得懂，用 while 循环监听客户端 Socket：
1234567891011121314151617181920public class IOServer {    public static void main(String[] args) {        try {            ServerSocket serverSocket &#x3D; new ServerSocket(8080);            while (true) {                Socket client &#x3D; serverSocket.accept();                InputStream in &#x3D; client.getInputStream();                OutputStream out &#x3D; client.getOutputStream();                byte[] buffer &#x3D; new byte[1024];                int bytesRead &#x3D; in.read(buffer);                out.write(buffer, 0, bytesRead);                in.close();                out.close();                client.close();            }        } catch (IOException e) {            e.printStackTrace();        }    }}
NIO，这部分我加上注释，主要用到的是 ServerSocketChannel 和 Selector：
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class NIOServer {    public static void main(String[] args) {        try {            &#x2F;&#x2F; 创建 ServerSocketChannel            ServerSocketChannel serverSocketChannel &#x3D; ServerSocketChannel.open();            &#x2F;&#x2F; 绑定端口            serverSocketChannel.bind(new InetSocketAddress(8081));            &#x2F;&#x2F; 设置为非阻塞模式            serverSocketChannel.configureBlocking(false);            &#x2F;&#x2F; 创建 Selector            Selector selector &#x3D; Selector.open();            &#x2F;&#x2F; 将 ServerSocketChannel 注册到 Selector，关注 OP_ACCEPT 事件            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);            &#x2F;&#x2F; 无限循环，处理事件            while (true) {                &#x2F;&#x2F; 阻塞直到有事件发生                selector.select();                &#x2F;&#x2F; 获取发生事件的 SelectionKey                Iterator&lt;SelectionKey&gt; iterator &#x3D; selector.selectedKeys().iterator();                while (iterator.hasNext()) {                    SelectionKey key &#x3D; iterator.next();                    &#x2F;&#x2F; 处理完后，从 selectedKeys 集合中移除                    iterator.remove();                    &#x2F;&#x2F; 判断事件类型                    if (key.isAcceptable()) {                        &#x2F;&#x2F; 有新的连接请求                        ServerSocketChannel server &#x3D; (ServerSocketChannel) key.channel();                        &#x2F;&#x2F; 接受连接                        SocketChannel client &#x3D; server.accept();                        &#x2F;&#x2F; 设置为非阻塞模式                        client.configureBlocking(false);                        &#x2F;&#x2F; 将新的 SocketChannel 注册到 Selector，关注 OP_READ 事件                        client.register(selector, SelectionKey.OP_READ);                    } else if (key.isReadable()) {                        &#x2F;&#x2F; 有数据可读                        SocketChannel client &#x3D; (SocketChannel) key.channel();                        &#x2F;&#x2F; 创建 ByteBuffer 缓冲区                        ByteBuffer buffer &#x3D; ByteBuffer.allocate(1024);                        &#x2F;&#x2F; 从 SocketChannel 中读取数据并写入 ByteBuffer                        client.read(buffer);                        &#x2F;&#x2F; 翻转 ByteBuffer，准备读取                        buffer.flip();                        &#x2F;&#x2F; 将数据从 ByteBuffer 写回到 SocketChannel                        client.write(buffer);                        &#x2F;&#x2F; 关闭连接                        client.close();                    }                }            }        } catch (IOException e) {            e.printStackTrace();        }    }}
上面的代码创建了一个基于 Java NIO 的简单 TCP 服务器。它使用 ServerSocketChannel 和 Selector（后面会讲） 实现了非阻塞 I&#x2F;O 和 I&#x2F;O 多路复用。服务器循环监听事件，当有新的连接请求时，接受连接并将新的 SocketChannel 注册到 Selector，关注 OP_READ 事件。当有数据可读时，从 SocketChannel 中读取数据并写入 ByteBuffer，然后将数据从 ByteBuffer 写回到 SocketChannel。
这里简单说一下 Socket 和 ServerSocket，以及 ServerSocketChannel 和 SocketChannel。
Socket 和 ServerSocket 是传统的阻塞式 I&#x2F;O 编程方式，用于建立和管理 TCP 连接。

Socket：表示客户端套接字，负责与服务器端建立连接并进行数据的读写。
ServerSocket：表示服务器端套接字，负责监听客户端连接请求。当有新的连接请求时，ServerSocket 会创建一个新的 Socket 实例，用于与客户端进行通信。

在传统阻塞式 I&#x2F;O 编程中，每个连接都需要一个单独的线程进行处理，这导致了在高并发场景下的性能问题。在接下来的客户端测试用例中会看到。
为了解决传统阻塞式 I&#x2F;O 的性能问题，Java NIO 引入了 ServerSocketChannel 和 SocketChannel。它们是非阻塞 I&#x2F;O，可以在单个线程中处理多个连接。

ServerSocketChannel：类似于 ServerSocket，表示服务器端套接字通道。它负责监听客户端连接请求，并可以设置为非阻塞模式，这意味着在等待客户端连接请求时不会阻塞线程。
SocketChannel：类似于 Socket，表示客户端套接字通道。它负责与服务器端建立连接并进行数据的读写。SocketChannel 也可以设置为非阻塞模式，在读写数据时不会阻塞线程。

再来简单说一下 Selector，后面会再细讲。
Selector 是 Java NIO 中的一个关键组件，用于实现 I&#x2F;O 多路复用。它允许在单个线程中同时监控多个 ServerSocketChannel 和 SocketChannel，并通过 SelectionKey 标识关注的事件。当某个事件发生时，Selector 会将对应的 SelectionKey 添加到已选择的键集合中。通过使用 Selector，可以在单个线程中同时处理多个连接，从而有效地提高 I&#x2F;O 操作的性能，特别是在高并发场景下。
客户端测试用例：
12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class TestClient {    public static void main(String[] args) throws InterruptedException {        int clientCount &#x3D; 10000;        ExecutorService executorServiceIO &#x3D; Executors.newFixedThreadPool(10);        ExecutorService executorServiceNIO &#x3D; Executors.newFixedThreadPool(10);        &#x2F;&#x2F; 使用传统 IO 的客户端        Runnable ioClient &#x3D; () -&gt; {            try {                Socket socket &#x3D; new Socket(&quot;localhost&quot;, 8080);                OutputStream out &#x3D; socket.getOutputStream();                InputStream in &#x3D; socket.getInputStream();                out.write(&quot;Hello, 沉默王二 IO!&quot;.getBytes());                byte[] buffer &#x3D; new byte[1024];                in.read(buffer);                in.close();                out.close();                socket.close();            } catch (IOException e) {                e.printStackTrace();            }        };        &#x2F;&#x2F; 使用 NIO 的客户端        Runnable nioClient &#x3D; () -&gt; {            try {                SocketChannel socketChannel &#x3D; SocketChannel.open();                socketChannel.connect(new InetSocketAddress(&quot;localhost&quot;, 8081));                ByteBuffer buffer &#x3D; ByteBuffer.wrap(&quot;Hello, 沉默王二 NIO!&quot;.getBytes());                socketChannel.write(buffer);                buffer.clear();                socketChannel.read(buffer);                socketChannel.close();            } catch (IOException e) {                e.printStackTrace();            }        };        &#x2F;&#x2F; 分别测试 NIO 和传统 IO 的服务器性能        long startTime, endTime;        startTime &#x3D; System.currentTimeMillis();        for (int i &#x3D; 0; i &lt; clientCount; i++) {            executorServiceIO.execute(ioClient);        }        executorServiceIO.shutdown();        executorServiceIO.awaitTermination(1, TimeUnit.MINUTES);        endTime &#x3D; System.currentTimeMillis();        System.out.println(&quot;传统 IO 服务器处理 &quot; + clientCount + &quot; 个客户端耗时: &quot; + (endTime - startTime) + &quot;ms&quot;);        startTime &#x3D; System.currentTimeMillis();        for (int i &#x3D; 0; i &lt; clientCount; i++) {            executorServiceNIO.execute(nioClient);        }        executorServiceNIO.shutdown();        executorServiceNIO.awaitTermination(1, TimeUnit.MINUTES);        endTime &#x3D; System.currentTimeMillis();        System.out.println(&quot;NIO 服务器处理 &quot; + clientCount + &quot; 个客户端耗时: &quot; + (endTime - startTime) + &quot;ms&quot;);    }}
在这个简单的性能测试中，我们使用固定线程池（10个线程）来模拟客户端并发请求。分别测试 NIO 和传统 IO 服务器处理 10000 个客户端请求所需的时间。来看一下结果。

可以看得出，NIO 比 传统 IO 差不多快一倍的时间。当然了，这是放在我本地测试的，如果服务端放在生产环境下，这个结果会有所不同，但我在本地跑了几次，结果差不多是这样的结果。
这说明 NIO 在网络传输中的性能确实要优于传统 IO 的。   
03、小结 
本篇内容主要讲了 NIO（New IO）和传统 IO 之间的差异，包括 IO 模型、操作文件、网络传输等方面。

传统 I&#x2F;O 采用阻塞式模型，线程在 I&#x2F;O 操作期间无法执行其他任务。NIO 使用非阻塞模型，允许线程在等待 I&#x2F;O 时执行其他任务，通过选择器（Selector）监控多个通道（Channel）上的 I&#x2F;O 事件，提高性能和可伸缩性。
传统 I&#x2F;O 使用基于字节流或字符流的类（如 FileInputStream、BufferedReader 等）进行文件读写。NIO 使用通道（Channel）和缓冲区（Buffer）进行文件操作，NIO 在性能上的优势并不大。
传统 I&#x2F;O 使用 Socket 和 ServerSocket 进行网络传输，存在阻塞问题。NIO 提供了 SocketChannel 和 ServerSocketChannel，支持非阻塞网络传输，提高了并发处理能力。

10.2 BIO、NIO 和 AIO 的区别上篇，我们了解了 NIO 和传统 IO 的区别，那这篇我们来了解 BIO、NIO 和 AIO 的区别，新手也很容易混淆，我们换一个方式来讲，讲给女朋友听 。
周末午后，在家里面进行电话面试，我问了面试者几个关于 IO 的问题，其中包括什么是 BIO、NIO 和 AIO？三者有什么区别？具体如何使用等问题，但是面试者回答的并不是很满意。于是我在面试评价中写道：”对 Java 的 IO 提醒理解不够深入”。恰好被女朋友看到了。

Java IO 与 BIO、NIO 
IO，常写作 I&#x2F;O，是 Input&#x2F;Output 的简称，即输入&#x2F;输出。通常指数据在内部存储器（内存）和外部存储器（硬盘、优盘等）或其他周边设备之间的输入和输出。
输入&#x2F;输出是信息处理系统（例如计算机）与外部世界（可能是人类或另一信息处理系统）之间的通信。
输入是系统接收的信号或数据，输出则是从其发送的信号或数据。
在 Java 中，提供了一系列 API，可以供开发者来读写外部数据或文件。我们称这些 API 为 Java IO。
IO 是 Java 中比较重要，且比较难的知识点，主要是因为随着 Java 的发展，目前有三种 IO 共存。分别是 BIO、NIO 和 AIO。
BIO 全称 Block-IO 是一种同步且阻塞的通信模式。是一个比较传统的通信方式，模式简单，使用方便。但并发处理能力低，通信耗时，依赖网速。
Java NIO，全程 Non-Block IO ，是 Java SE 1.4 版以后，针对网络传输效能优化的新功能。是一种非阻塞同步的通信模式。
NIO 与原来的 I&#x2F;O 有同样的作用和目的, 他们之间最重要的区别是数据打包和传输的方式。原来的 I&#x2F;O 以流的方式处理数据，而 NIO 以块的方式处理数据。
面向流的 I&#x2F;O 系统一次一个字节地处理数据。一个输入流产生一个字节的数据，一个输出流消费一个字节的数据。
面向块的 I&#x2F;O 系统以块的形式处理数据。每一个操作都在一步中产生或者消费一个数据块。按块处理数据比按(流式的)字节处理数据要快得多。但是面向块的 I&#x2F;O 缺少一些面向流的 I&#x2F;O 所具有的优雅性和简单性。
Java AIO，全称 Asynchronous IO，是异步非阻塞的 IO。是一种非阻塞异步的通信模式。
在 NIO 的基础上引入了新的异步通道的概念，并提供了异步文件通道和异步套接字通道的实现。

三种 IO 的区别 
首先，我们站在宏观的角度，重新画一下重点：

BIO （Blocking I&#x2F;O）：同步阻塞 I&#x2F;O 模式。
NIO （New I&#x2F;O）：同步非阻塞模式。
AIO （Asynchronous I&#x2F;O）：异步非阻塞 I&#x2F;O 模型。

同步阻塞模式：这种模式下，我们的工作模式是先来到厨房，开始烧水，并坐在水壶面前一直等着水烧开。
同步非阻塞模式：这种模式下，我们的工作模式是先来到厨房，开始烧水，但是我们不一直坐在水壶前面等，而是回到客厅看电视，然后每隔几分钟到厨房看一下水有没有烧开。
异步非阻塞 I&#x2F;O 模型：这种模式下，我们的工作模式是先来到厨房，开始烧水，我们不一直坐在水壶前面等，也不隔一段时间去看一下，而是在客厅看电视，水壶上面有个开关，水烧开之后他会通知我。
阻塞 VS 非阻塞：人是否坐在水壶前面一直等。
同步 VS 异步：水壶是不是在水烧开之后主动通知人。
适用场景 
BIO 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4 以前的唯一选择，但程序直观简单易理解。
NIO 方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4 开始支持。
AIO 方式适用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用 OS 参与并发操作，编程比较复杂，JDK7 开始支持。
使用方式 
使用 BIO 实现文件的读取和写入。
1234567891011121314151617181920212223242526272829303132333435363738public class BioFileDemo {    public static void main(String[] args) {        BioFileDemo demo &#x3D; new BioFileDemo();        demo.writeFile();        demo.readFile();    }    &#x2F;&#x2F; 使用 BIO 写入文件    public void writeFile() {        String filename &#x3D; &quot;logs&#x2F;itwanger&#x2F;paicoding.txt&quot;;        try {            FileWriter fileWriter &#x3D; new FileWriter(filename);            BufferedWriter bufferedWriter &#x3D; new BufferedWriter(fileWriter);            bufferedWriter.write(&quot;学编程就上技术派&quot;);            bufferedWriter.newLine();            System.out.println(&quot;写入完成&quot;);            bufferedWriter.close();            fileWriter.close();        } catch (IOException e) {            e.printStackTrace();        }    }    &#x2F;&#x2F; 使用 BIO 读取文件    public void readFile() {        String filename &#x3D; &quot;logs&#x2F;itwanger&#x2F;paicoding.txt&quot;;        try {            FileReader fileReader &#x3D; new FileReader(filename);            BufferedReader bufferedReader &#x3D; new BufferedReader(fileReader);            String line;            while ((line &#x3D; bufferedReader.readLine()) !&#x3D; null) {                System.out.println(&quot;读取的内容: &quot; + line);            }            bufferedReader.close();            fileReader.close();        } catch (IOException e) {            e.printStackTrace();        }    }}
这个示例展示了如何使用 Java 中的传统阻塞 I&#x2F;O（BIO）对文件进行读写操作。在 writeFile() 方法中，我们首先创建一个 FileWriter 对象，并使用 BufferedWriter 进行缓冲写入。接着，使用 bufferedWriter.write() 方法将字符串写入文件，然后调用bufferedWriter.newLine() 方法添加换行符。最后，关闭 BufferedWriter 和 FileWriter。在 readFile() 方法中，我们创建一个 FileReader 对象，并使用 BufferedReader 进行缓冲读取。然后通过调用 bufferedReader.readLine() 方法循环读取文件内容，直到返回 null 表示读取完毕。最后，关闭 BufferedReader 和 FileReader。
接下来是 NIO 的。
123456789101112131415161718192021222324252627282930313233343536373839public class NioFileDemo {    public static void main(String[] args) {        NioFileDemo demo &#x3D; new NioFileDemo();        demo.writeFile();        demo.readFile();    }    &#x2F;&#x2F; 使用 NIO 写入文件    public void writeFile() {        Path path &#x3D; Paths.get(&quot;logs&#x2F;itwanger&#x2F;paicoding.txt&quot;);        try {            FileChannel fileChannel &#x3D; FileChannel.open(path, EnumSet.of(StandardOpenOption.CREATE, StandardOpenOption.WRITE));            ByteBuffer buffer &#x3D; StandardCharsets.UTF_8.encode(&quot;学编程就上技术派&quot;);            fileChannel.write(buffer);            System.out.println(&quot;写入完成&quot;);            fileChannel.close();        } catch (IOException e) {            e.printStackTrace();        }    }    &#x2F;&#x2F; 使用 NIO 读取文件    public void readFile() {        Path path &#x3D; Paths.get(&quot;logs&#x2F;itwanger&#x2F;paicoding.txt&quot;);        try {            FileChannel fileChannel &#x3D; FileChannel.open(path, StandardOpenOption.READ);            ByteBuffer buffer &#x3D; ByteBuffer.allocate(1024);            int bytesRead &#x3D; fileChannel.read(buffer);            while (bytesRead !&#x3D; -1) {                buffer.flip();                System.out.println(&quot;读取的内容: &quot; + StandardCharsets.UTF_8.decode(buffer));                buffer.clear();                bytesRead &#x3D; fileChannel.read(buffer);            }            fileChannel.close();        } catch (IOException e) {            e.printStackTrace();        }    }}
这个示例演示了如何使用 NIO 的 FileChannel 对文件进行读写操作。在 writeFile() 方法中，我们首先打开文件通道并指定创建和写入选项。接着，将要写入的字符串转换为 ByteBuffer，然后使用 fileChannel.write() 方法将其写入文件。在 readFile() 方法中，我们打开文件通道并指定读取选项，然后创建一个 ByteBuffer 用于存储读取到的数据。使用 fileChannel.read() 方法循环读取文件内容，直到返回 -1 表示读取完毕。在循环中，我们翻转缓冲区，将其解码为字符串并打印，然后清空缓冲区以进行下一次读取。最后，关闭文件通道。
使用 AIO 实现文件的读取和写入     
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class AioDemo {    public static void main(String[] args) {        AioDemo demo &#x3D; new AioDemo();        demo.writeFile();        demo.readFile();    }    &#x2F;&#x2F; 使用 AsynchronousFileChannel 写入文件    public void writeFile() {        &#x2F;&#x2F; 使用 Paths.get() 获取文件路径        Path path &#x3D; Paths.get(&quot;logs&#x2F;itwanger&#x2F;paicoding.txt&quot;);        try {            &#x2F;&#x2F; 用 AsynchronousFileChannel.open() 打开文件通道，指定写入和创建文件的选项。            AsynchronousFileChannel fileChannel &#x3D; AsynchronousFileChannel.open(path, StandardOpenOption.WRITE, StandardOpenOption.CREATE);            &#x2F;&#x2F; 将要写入的字符串（&quot;学编程就上技术派&quot;）转换为 ByteBuffer。            ByteBuffer buffer &#x3D; StandardCharsets.UTF_8.encode(&quot;学编程就上技术派&quot;);            &#x2F;&#x2F; 调用 fileChannel.write() 方法将 ByteBuffer 中的内容写入文件。这是一个异步操作，因此需要使用 Future 对象等待写入操作完成。            Future&lt;Integer&gt; result &#x3D; fileChannel.write(buffer, 0);            &#x2F;&#x2F; 等待写操作完成            result.get();            System.out.println(&quot;写入完成&quot;);            fileChannel.close();        } catch (IOException | InterruptedException | java.util.concurrent.ExecutionException e) {            e.printStackTrace();        }    }    &#x2F;&#x2F; 使用 AsynchronousFileChannel 读取文件    public void readFile() {        Path path &#x3D; Paths.get(&quot;logs&#x2F;itwanger&#x2F;paicoding.txt&quot;);        try {            &#x2F;&#x2F; 指定读取文件的选项。            AsynchronousFileChannel fileChannel &#x3D; AsynchronousFileChannel.open(path, StandardOpenOption.READ);            &#x2F;&#x2F; 创建一个 ByteBuffer，用于存储从文件中读取的数据。            ByteBuffer buffer &#x3D; ByteBuffer.allocate(1024);            &#x2F;&#x2F; 调用 fileChannel.read() 方法从文件中异步读取数据。该方法接受一个 CompletionHandler 对象，用于处理异步操作完成后的回调。            fileChannel.read(buffer, 0, buffer, new CompletionHandler&lt;Integer, ByteBuffer&gt;() {                @Override                public void completed(Integer result, ByteBuffer attachment) {                    &#x2F;&#x2F; 在 CompletionHandler 的 completed() 方法中，翻转 ByteBuffer（attachment.flip()），然后使用 Charset.forName(&quot;UTF-8&quot;).decode() 将其解码为字符串并打印。最后，清空缓冲区并关闭文件通道。                    attachment.flip();                    System.out.println(&quot;读取的内容: &quot; + StandardCharsets.UTF_8.decode(attachment));                    attachment.clear();                    try {                        fileChannel.close();                    } catch (IOException e) {                        e.printStackTrace();                    }                }                @Override                public void failed(Throwable exc, ByteBuffer attachment) {                    &#x2F;&#x2F; 如果异步读取操作失败，CompletionHandler 的 failed() 方法将被调用，打印错误信息。                    System.out.println(&quot;读取失败&quot;);                    exc.printStackTrace();                }            });            &#x2F;&#x2F; 等待异步操作完成            Thread.sleep(1000);        } catch (IOException | InterruptedException e) {            e.printStackTrace();        }    }}
这段代码展示了一个名为 AioDemo 的类，包含两个方法： writeFile() 和 readFile() 。这两个方法分别使用 AsynchronousFileChannel 对文件进行异步写入和读取操作。代码的具体含义我都加到注释当中了，注意查看。
滴滴滴，水开了。

小结 
BIO（Blocking I&#x2F;O）：采用阻塞式 I&#x2F;O 模型，线程在执行 I&#x2F;O 操作时被阻塞，无法处理其他任务，适用于连接数较少且稳定的场景。
NIO（New I&#x2F;O 或 Non-blocking I&#x2F;O）：使用非阻塞 I&#x2F;O 模型，线程在等待 I&#x2F;O 时可执行其他任务，通过 Selector 监控多个 Channel 上的事件，提高性能和可伸缩性，适用于高并发场景。
AIO（Asynchronous I&#x2F;O）：采用异步 I&#x2F;O 模型，线程发起 I&#x2F;O 请求后立即返回，当 I&#x2F;O 操作完成时通过回调函数通知线程，进一步提高了并发处理能力，适用于高吞吐量场景。

参考链接：https:&#x2F;&#x2F;mp.weixin.qq.com&#x2F;s&#x2F;QQxrr5yP8X9YdFqIwXDoQQ

10.3 Buffer和Channel首先我们再来回顾一下 IO 和 NIO 的区别：

可简单认为：IO 是面向流的处理，NIO 是面向块(缓冲区)的处理
面向流的 I&#x2F;O 系统一次一个字节地处理数据。
一个面向块(缓冲区)的 I&#x2F;O 系统以块的形式处理数据。

NIO 主要有两个核心部分组成：

Buffer 缓冲区
Channel 通道

在 NIO 中，并不是以流的方式来处理数据的，而是以 buffer 缓冲区和 Channel 通道配合使用来处理数据的。
简单理解一下：
可以把 Channel 通道比作铁路，buffer 缓冲区比作成火车(运载着货物)
而我们的 NIO 就是通过 Channel 通道运输着存储数据的 Buffer 缓冲区的来实现数据的处理！
要时刻记住：Channel 不与数据打交道，它只负责运输数据。与数据打交道的是 Buffer 缓冲区

Channel—&gt;运输
Buffer—&gt;数据

相对于传统 IO 而言，流是单向的。对于 NIO 而言，有了 Channel 通道这个概念，我们的读写都是双向的(铁路上的火车能从广州去北京、自然就能从北京返还到广州)！
Buffer 缓冲区 
我们来看看 Buffer 缓冲区有什么值得我们注意的地方。
Buffer 是缓冲区的抽象类：

其中 ByteBuffer 是用得最多的实现类(在通道中读写字节数据)。

拿到一个缓冲区我们往往会做什么？很简单，就是读取缓冲区的数据&#x2F;写数据到缓冲区中。所以，缓冲区的核心方法就是 put 和 get：

Buffer 类维护了 4 个核心变量来提供关于其所包含的数组信息。它们是：
容量 Capacity 缓冲区能够容纳的数据元素的最大数量。容量在缓冲区创建时被设定，并且永远不能被改变。(不能被改变的原因也很简单，底层是数组嘛)
上界 Limit 缓冲区里的数据的总数，代表了当前缓冲区中一共有多少数据。
位置 Position 下一个要被读或写的元素的位置。Position 会自动由相应的 get()和 put()函数更新。
标记 Mark 一个备忘位置。用于记录上一次读写的位置。
首先展示一下是如何创建缓冲区的，核心变量的值是怎么变化的。
12345678910111213141516&#x2F;&#x2F; 创建一个缓冲区ByteBuffer byteBuffer &#x3D; ByteBuffer.allocate(1024);&#x2F;&#x2F; 看一下初始时4个核心变量的值System.out.println(&quot;初始时--&gt;limit---&gt;&quot;+byteBuffer.limit());System.out.println(&quot;初始时--&gt;position---&gt;&quot;+byteBuffer.position());System.out.println(&quot;初始时--&gt;capacity---&gt;&quot;+byteBuffer.capacity());System.out.println(&quot;初始时--&gt;mark---&gt;&quot; + byteBuffer.mark());System.out.println(&quot;--------------------------------------&quot;);&#x2F;&#x2F; 添加一些数据到缓冲区中String s &#x3D; &quot;沉默王二&quot;;byteBuffer.put(s.getBytes());&#x2F;&#x2F; 看一下初始时4个核心变量的值System.out.println(&quot;put完之后--&gt;limit---&gt;&quot;+byteBuffer.limit());System.out.println(&quot;put完之后--&gt;position---&gt;&quot;+byteBuffer.position());System.out.println(&quot;put完之后--&gt;capacity---&gt;&quot;+byteBuffer.capacity());System.out.println(&quot;put完之后--&gt;mark---&gt;&quot; + byteBuffer.mark());
运行结果：
123456789初始时--&gt;limit---&gt;1024初始时--&gt;position---&gt;0初始时--&gt;capacity---&gt;1024初始时--&gt;mark---&gt;java.nio.HeapByteBuffer[pos&#x3D;0 lim&#x3D;1024 cap&#x3D;1024]--------------------------------------put完之后--&gt;limit---&gt;1024put完之后--&gt;position---&gt;12put完之后--&gt;capacity---&gt;1024put完之后--&gt;mark---&gt;java.nio.HeapByteBuffer[pos&#x3D;12 lim&#x3D;1024 cap&#x3D;1024]
现在我想要从缓存区拿数据，怎么拿呀？？NIO 给了我们一个 flip()方法。这个方法可以改动 position 和 limit 的位置！
在之前代码的基础上，我们 flip() 一下。
123456&#x2F;&#x2F; flip()方法byteBuffer.flip();System.out.println(&quot;flip()方法之后--&gt;limit---&gt;&quot;+byteBuffer.limit());System.out.println(&quot;flip()方法之后--&gt;position---&gt;&quot;+byteBuffer.position());System.out.println(&quot;flip()方法之后--&gt;capacity---&gt;&quot;+byteBuffer.capacity());System.out.println(&quot;flip()方法之后--&gt;mark---&gt;&quot; + byteBuffer.mark());
再看看 4 个核心属性的值会发生什么变化：

在调用 flip() 之后，limit 变为当前 position 的值（12），position 重置为 0。这意味着你可以从缓冲区的开始位置读取刚刚写入的数据，直到 limit 指定的位置。capacity 保持不变（1024）。
假设我们有一个初始容量为 1024 的 ByteBuffer。
初始状态:
123position &#x3D; 0limit &#x3D; 1024capacity &#x3D; 1024
添加数据 “沉默王二” 后:
由于 “沉默王二” 为 UTF-8 编码，一个汉字占 3 个字节，共有 4 个汉字，所以占用 12 个字节。
123position &#x3D; 12limit &#x3D; 1024capacity &#x3D; 1024
调用flip()方法后:
123position &#x3D; 0limit &#x3D; 12capacity &#x3D; 1024
用一幅图来表示就是。

当切换成读模式之后，我们就可以读取缓冲区的数据了：
123456&#x2F;&#x2F; 创建一个limit()大小的字节数组(因为就只有limit这么多个数据可读)byte[] bytes &#x3D; new byte[byteBuffer.limit()];&#x2F;&#x2F; 将读取的数据装进我们的字节数组中byteBuffer.get(bytes);&#x2F;&#x2F; 输出数据System.out.println(new String(bytes, 0, bytes.length));
输出后的结果：
1沉默王二
随后输出一下核心变量的值看看：

读完如何还想写数据到缓冲区，那就使用 clear() 方法，这个方法会“清空”缓冲区，数据没有真正被清空，只是被遗忘掉了

Channel 通道 
Channel 通道只负责传输数据、不直接操作数据。操作数据都是通过 Buffer 缓冲区来进行操作！通常，通道可以分为两大类：文件通道和套接字通道。
FileChannel：用于文件 I&#x2F;O 的通道，支持文件的读、写和追加操作。FileChannel 允许在文件的任意位置进行数据传输，支持文件锁定以及内存映射文件等高级功能。FileChannel 无法设置为非阻塞模式，因此它只适用于阻塞式文件操作。
SocketChannel：用于 TCP 套接字 I&#x2F;O 的通道。SocketChannel 支持非阻塞模式，可以与 Selector（下文会讲）一起使用，实现高效的网络通信。SocketChannel 允许连接到远程主机，进行数据传输。
与之匹配的有ServerSocketChannel：用于监听 TCP 套接字连接的通道。与 SocketChannel 类似，ServerSocketChannel 也支持非阻塞模式，并可以与 Selector 一起使用。ServerSocketChannel 负责监听新的连接请求，接收到连接请求后，可以创建一个新的 
DatagramChannel：用于 UDP 套接字 I&#x2F;O 的通道。DatagramChannel 支持非阻塞模式，可以发送和接收数据报包，适用于无连接的、不可靠的网络通信。
这篇我们主要来讲 FileChannel，SocketChannel、ServerSocketChannel 和 DatagramChannel 会放到后面的章节中讲解。
文件通道 FileChannel 
可以通过下面的方式打开一个通道。
1FileChannel.open(Paths.get(&quot;docs&#x2F;配套教程.md&quot;), StandardOpenOption.WRITE);
这里我们用到了 Paths，这个后面也会讲到。
①、使用FileChannel 配合 ByteBuffer 缓冲区实现文件复制的功能：
12345678910111213try (FileChannel sourceChannel &#x3D; FileChannel.open(Paths.get(&quot;logs&#x2F;javabetter&#x2F;itwanger.txt&quot;), StandardOpenOption.READ);    FileChannel destinationChannel &#x3D; FileChannel.open(Paths.get(&quot;logs&#x2F;javabetter&#x2F;itwanger1.txt&quot;), StandardOpenOption.WRITE, StandardOpenOption.CREATE)) {  ByteBuffer buffer &#x3D; ByteBuffer.allocate(1024);  while (sourceChannel.read(buffer) !&#x3D; -1) {      buffer.flip();      destinationChannel.write(buffer);      buffer.clear();  }}
我们创建一个容量为 1024 的 ByteBuffer 作为缓冲区。在循环中，我们从源文件的 FileChannel 读取数据到缓冲区。当 read() 方法返回 -1 时，表示已经到达文件末尾。
读取数据后，我们调用 flip() 方法，以便在缓冲区中准备好要写入的数据。然后，我们将缓冲区的内容写入目标文件的 FileChannel（ write() 方法）。在写入完成后，我们调用 clear() 方法重置缓冲区，以便在下一次迭代中重用它。
②、使用内存映射文件（MappedByteBuffer）的方式实现文件复制的功能(直接操作缓冲区)：
12345678910111213141516try (FileChannel sourceChannel &#x3D; FileChannel.open(Paths.get(&quot;logs&#x2F;javabetter&#x2F;itwanger.txt&quot;), StandardOpenOption.READ);      FileChannel destinationChannel &#x3D; FileChannel.open(Paths.get(&quot;logs&#x2F;javabetter&#x2F;itwanger2.txt&quot;), StandardOpenOption.WRITE, StandardOpenOption.CREATE, StandardOpenOption.READ)) {    long fileSize &#x3D; sourceChannel.size();    MappedByteBuffer sourceMappedBuffer &#x3D; sourceChannel.map(FileChannel.MapMode.READ_ONLY, 0, fileSize);    MappedByteBuffer destinationMappedBuffer &#x3D; destinationChannel.map(FileChannel.MapMode.READ_WRITE, 0, fileSize);    for (int i &#x3D; 0; i &lt; fileSize; i++) {        byte b &#x3D; sourceMappedBuffer.get(i);        destinationMappedBuffer.put(i, b);    }}
MappedByteBuffer 是 Java NIO 中的一个类，它继承自 java.nio.ByteBuffer 。MappedByteBuffer 用于表示一个内存映射文件，即将文件的一部分或全部映射到内存中，以便通过直接操作内存来实现对文件的读写。这种方式可以提高文件 I&#x2F;O 的性能，因为操作系统可以直接在内存和磁盘之间传输数据，无需通过 Java 应用程序进行额外的数据拷贝。
通常与 FileChannel 一起使用，可以通过调用 FileChannel 的 map() 方法创建 MappedByteBuffer 对象。map() 方法接受三个参数：映射模式（FileChannel.MapMode）映射起始位置和映射的长度。
映射模式包括只读模式（READ_ONLY）、读写模式（READ_WRITE）和专用模式（PRIVATE）。
我们设置源文件的 MappedByteBuffer 为只读模式（READ_ONLY），目标文件的 MappedByteBuffer 为读写模式（READ_WRITE）。
在循环中，我们逐字节地从源文件的 MappedByteBuffer 读取数据并将其写入目标文件的 MappedByteBuffer。这样就实现了文件复制功能。利用内存映射文件（MappedByteBuffer）实现的文件复制，可能会比使用 ByteBuffer 的方法更快。
需要注意的是，使用 MappedByteBuffer 进行文件操作时，数据的修改可能不会立即写入磁盘。可以通过调用 MappedByteBuffer 的 force() 方法将数据立即写回磁盘。
③、通道之间通过 transfer()实现数据的传输(直接操作缓冲区)：
12345678910try (FileChannel sourceChannel &#x3D; FileChannel.open(Paths.get(&quot;logs&#x2F;javabetter&#x2F;itwanger.txt&quot;), StandardOpenOption.READ);      FileChannel destinationChannel &#x3D; FileChannel.open(Paths.get(&quot;logs&#x2F;javabetter&#x2F;itwanger3.txt&quot;), StandardOpenOption.WRITE, StandardOpenOption.CREATE, StandardOpenOption.READ)) {    sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);} catch (IOException e) {    throw new RuntimeException(e);}
FileChannel 的 transferTo() 方法是一个高效的文件传输方法，它允许将文件的一部分或全部内容直接从源文件通道传输到目标通道（通常是另一个文件通道或网络通道）。这种传输方式可以避免将文件数据在用户空间和内核空间之间进行多次拷贝，提高了文件传输的性能。
transferTo() 方法接受以下三个参数：

position：源文件中开始传输的位置。
count：要传输的字节数。
target：接收数据的目标通道。

需要注意的是， transferTo() 方法可能无法一次传输所有请求的字节。在实际应用中，你可能需要使用循环来确保所有字节都被传输。
12345678910111213141516171819202122public class FileChannelTransferToLoopExampleWithPaths {    public static void main(String[] args) {        Path sourcePath &#x3D; Paths.get(&quot;logs&#x2F;itwanger&#x2F;paicoding.txt&quot;);        Path destinationPath &#x3D; Paths.get(&quot;logs&#x2F;itwanger&#x2F;paicoding_copy.txt&quot;);        &#x2F;&#x2F; 使用 try-with-resources 语句确保通道资源被正确关闭        try (FileChannel sourceChannel &#x3D; FileChannel.open(sourcePath, StandardOpenOption.READ);             FileChannel destinationChannel &#x3D; FileChannel.open(destinationPath, StandardOpenOption.CREATE, StandardOpenOption.WRITE)) {            long position &#x3D; 0;            long count &#x3D; sourceChannel.size();            &#x2F;&#x2F; 循环传输，直到所有字节都被传输            while (position &lt; count) {                long transferred &#x3D; sourceChannel.transferTo(position, count - position, destinationChannel);                position +&#x3D; transferred;            }        } catch (IOException e) {            e.printStackTrace();        }    }}
此外， transferTo() 方法在底层使用了操作系统提供的零拷贝功能（如 Linux 的 sendfile() 系统调用），可以大幅提高文件传输性能。但是，不同操作系统和 JVM 实现可能会影响零拷贝的可用性和性能，因此实际性能可能因环境而异。
零拷贝（Zero-Copy）是一种优化数据传输性能的技术，它最大限度地减少了在数据传输过程中的 CPU 和内存开销。在传统的数据传输过程中，数据通常需要在用户空间和内核空间之间进行多次拷贝，这会导致额外的 CPU 和内存开销。零拷贝技术通过避免这些多余的拷贝操作，实现了更高效的数据传输。
在 Java 中，零拷贝技术主要应用于文件和网络 I&#x2F;O。FileChannel 类的 transferTo() 和 transferFrom() 方法就利用了零拷贝技术，可以在文件和网络通道之间高效地传输数据。
直接与非直接缓冲区 
直接缓冲区和非直接缓冲区的差别主要在于它们在内存中的存储方式。这里给出了直接缓冲区和非直接缓冲区的简要概述和区别：
非直接缓冲区：

分配在 JVM 堆内存中
受到垃圾回收的管理
在读写操作时，需要将数据从堆内存复制到操作系统的本地内存，再进行 I&#x2F;O 操作
创建： ByteBuffer.allocate(int capacity)

直接缓冲区：

分配在操作系统的本地内存中
不受垃圾回收的管理
在读写操作时，直接在本地内存中进行，避免了数据复制，提高了性能
创建： ByteBuffer.allocateDirect(int capacity)
还有前面提到的 FileChannel.map() 方法，会返回一个类型为 MappedByteBuffer 的直接缓冲区。

ByteBuffer.allocate和ByteBuffer.allocateDirect直接的差异。

直接缓冲区和非直接缓冲区之间的差异。

非直接缓冲区存储在JVM内部，数据需要从应用程序（Java）复制到非直接缓冲区，再复制到内核缓冲区，最后发送到设备（磁盘&#x2F;网络）。而对于直接缓冲区，数据可以直接从应用程序（Java）复制到内核缓冲区，无需经过JVM的非直接缓冲区。
异步文件通道 AsynchronousFileChannel 
AsynchronousFileChannel 是 Java 7 引入的一个异步文件通道类，提供了对文件的异步读、写、打开和关闭等操作。
可以通过 AsynchronousFileChannel.open() 方法打开一个异步文件通道，该方法接受一个 Path 对象和一组打开选项（如 StandardOpenOption.READ、StandardOpenOption.WRITE 等）作为参数。
123Path file &#x3D; Paths.get(&quot;example.txt&quot;);AsynchronousFileChannel fileChannel &#x3D; AsynchronousFileChannel.open(file, StandardOpenOption.READ, StandardOpenOption.WRITE);
AsynchronousFileChannel 提供了两种异步操作的方式：
①、Future 方式：使用 Future 对象来跟踪异步操作的完成情况。当我们调用一个异步操作（如 read() 或 write() ）时，它会立即返回一个 Future 对象。可以使用这个对象来检查操作是否完成，以及获取操作的结果。这种方式适用于不需要在操作完成时立即执行其他操作的场景。
举个例子：
12345678ByteBuffer buffer &#x3D; ByteBuffer.allocate(1024);long position &#x3D; 0;Future&lt;Integer&gt; result &#x3D; fileChannel.read(buffer, position);while (!result.isDone()) {    &#x2F;&#x2F; 执行其他操作}int bytesRead &#x3D; result.get();System.out.println(&quot;Bytes read: &quot; + bytesRead);
②、CompletionHandler 方式，使用一个实现了 CompletionHandler 接口的对象来处理异步操作的完成。我们需要提供一个 CompletionHandler 实现类，重写 completed() 和 failed() 方法，分别处理操作成功和操作失败的情况。当异步操作完成时，系统会自动调用相应的方法。这种方式适用于需要在操作完成时立即执行其他操作的场景。
举个例子：
1234567891011121314ByteBuffer buffer &#x3D; ByteBuffer.allocate(1024);long position &#x3D; 0;fileChannel.read(buffer, position, buffer, new CompletionHandler&lt;Integer, ByteBuffer&gt;() {    @Override    public void completed(Integer result, ByteBuffer attachment) {        System.out.println(&quot;Bytes read: &quot; + result);    }    @Override    public void failed(Throwable exc, ByteBuffer attachment) {        System.err.println(&quot;Read failed&quot;);        exc.printStackTrace();    }});
来看完整的示例，采用 Future 的形式。
12345678910111213141516171819202122Path path &#x3D; Paths.get(&quot;docs&#x2F;配套教程.md&quot;);try (AsynchronousFileChannel fileChannel &#x3D; AsynchronousFileChannel.open(path, StandardOpenOption.READ)) {    ByteBuffer buffer &#x3D; ByteBuffer.allocate(1024);    long position &#x3D; 0;    while (true) {        Future&lt;Integer&gt; result &#x3D; fileChannel.read(buffer, position);        while (!result.isDone()) {            &#x2F;&#x2F; 在这里可以执行其他任务，例如处理其他 I&#x2F;O 操作        }        int bytesRead &#x3D; result.get();        if (bytesRead &lt;&#x3D; 0) {            break;        }        position +&#x3D; bytesRead;        buffer.flip();        byte[] data &#x3D; new byte[buffer.limit()];        buffer.get(data);        System.out.println(new String(data));        buffer.clear();    }}
在这个示例中，我们使用 AsynchronousFileChannel.read() 方法发起异步读取操作。这个方法会返回一个 Future 对象，表示读取操作的结果。我们可以通过调用 isDone() 方法来检查异步操作是否完成。完成后，我们可以通过调用 get() 方法获取实际读取的字节数。
然后我们来看 CompletionHandler 接口的形式：
1234567891011121314151617181920212223242526272829303132333435public static void readAllBytes(Path path) throws IOException, InterruptedException {    AsynchronousFileChannel fileChannel &#x3D; AsynchronousFileChannel.open(path, StandardOpenOption.READ);    ByteBuffer buffer &#x3D; ByteBuffer.allocate(1024);    AtomicLong position &#x3D; new AtomicLong(0);    CountDownLatch latch &#x3D; new CountDownLatch(1);    fileChannel.read(buffer, position.get(), null, new CompletionHandler&lt;Integer, Object&gt;() {        @Override        public void completed(Integer bytesRead, Object attachment) {            if (bytesRead &gt; 0) {                position.addAndGet(bytesRead);                buffer.flip();                byte[] data &#x3D; new byte[buffer.limit()];                buffer.get(data);                System.out.print(new String(data));                buffer.clear();                fileChannel.read(buffer, position.get(), attachment, this);            } else {                latch.countDown();                try {                    fileChannel.close();                } catch (IOException e) {                    e.printStackTrace();                }            }        }        @Override        public void failed(Throwable exc, Object attachment) {            System.out.println(&quot;Error: &quot; + exc.getMessage());            latch.countDown();        }    });    latch.await();}
1、在 readAllBytes 方法中，我们使用 AsynchronousFileChannel.open() 方法以读取模式打开异步文件通道。
2、创建一个大小为 1024 的 ByteBuffer 来存储从文件中读取的数据。
3、使用 AtomicLong 类型的 position 变量来记录当前读取的文件位置。初始值为 0。
4、创建一个 CountDownLatch 对象，用于在异步操作完成时通知主线程。初始值为 1。
5、使用 fileChannel.read() 方法启动异步读取操作。这个方法的参数包括：用于存储数据的缓冲区、当前读取位置、附加对象（在这个例子中不需要，所以传递 null）以及一个实现了 CompletionHandler 接口的对象，用于在读取操作完成时回调。
6、CompletionHandler 接口有两个方法： completed() 和 failed() 。在读取操作成功完成时调用 completed() 方法；如果读取操作失败，调用 failed() 方法。
7、在 completed() 方法中，我们首先检查 bytesRead（本次读取的字节数）是否大于 0。如果大于 0，说明还有数据需要读取。

更新 position 变量，将其增加 bytesRead。
将缓冲区翻转（ flip() ），以便我们可以从中读取数据。
创建一个新的字节数组，其大小等于缓冲区的限制（ limit() ）。
从缓冲区中获取数据并将其存储在新创建的字节数组中。
将字节数组转换为字符串并输出。
清除缓冲区，以便我们可以继续读取更多数据。
再次调用 fileChannel.read() 方法，以继续从文件中读取数据。

8、如果 bytesRead 等于或小于 0，说明我们已经读取完文件中的所有数据。此时，我们需要：调用 latch.countDown() 方法，以通知主线程异步操作已完成。关闭 fileChannel。
9、如果读取操作失败，我们将在 failed() 方法中输出错误信息并调用 latch.countDown() 方法通知主线程。
10、最后，我们调用 latch.await() 方法来等待异步操作完成。主线程将在此处阻塞，直到 latch 的计数变为 0。 
小结 
Java NIO 中的 Buffer 和 Channel 是 NIO 系统的核心组件。Buffer 负责存储数据，提供了对数据的读写操作。它有多种类型，如 ByteBuffer、CharBuffer、IntBuffer 等，以支持不同的数据类型。
Channel 代表了与 I&#x2F;O 设备（如文件或套接字）之间的连接。它提供了从源设备到 Buffer 的数据读取能力和从 Buffer 到目标设备的数据写入能力。Channel 可以是可读、可写或同时可读写的，我们详细介绍了文件通道 FileChannel 和异步文件通道 AsynchronousFileChannel。
总之，NIO 使用 Buffer 和 Channel 这两个组件来进行高效的数据传输，以提高 I&#x2F;O 操作的性能。
10.4 Paths 和 FilesPaths 和 Files 在 Java 7 的时候引入，作为对 java.io.File 类的补充和改进。
Paths 类 
Paths 类主要用于操作文件和目录路径。它提供了一些静态方法，用于创建 java.nio.file.Path实例，代表文件系统中的路径。
下面是 Paths 的一个示例。
1234&#x2F;&#x2F; 创建一个Path实例，表示当前目录下的一个文件Path path &#x3D; Paths.get(&quot;example.txt&quot;);&#x2F;&#x2F; 创建一个绝对路径Path absolutePath &#x3D; Paths.get(&quot;&#x2F;home&#x2F;user&#x2F;example.txt&quot;);
java.nio.file.Path 接口在 Java NIO.2 中代表一个文件系统中的路径。它提供了一系列方法来操作和查询路径。

下面是 Paths 和 Path 一起使用的实例：
123456789101112131415161718192021Path path &#x3D; Paths.get(&quot;docs&#x2F;配套教程.md&quot;);&#x2F;&#x2F; 获取文件名System.out.println(&quot;File name: &quot; + path.getFileName());&#x2F;&#x2F; 获取父目录System.out.println(&quot;Parent: &quot; + path.getParent());&#x2F;&#x2F; 获取根目录System.out.println(&quot;Root: &quot; + path.getRoot());&#x2F;&#x2F; 将路径与另一个路径结合Path newPath &#x3D; path.resolve(&quot;config&#x2F;app.properties&quot;);System.out.println(&quot;Resolved path: &quot; + newPath);&#x2F;&#x2F; 简化路径Path normalizedPath &#x3D; newPath.normalize();System.out.println(&quot;Normalized path: &quot; + normalizedPath);&#x2F;&#x2F; 将相对路径转换为绝对路径Path absolutePath &#x3D; path.toAbsolutePath();System.out.println(&quot;Absolute path: &quot; + absolutePath);&#x2F;&#x2F; 计算两个路径之间的相对路径Path basePath &#x3D; Paths.get(&quot;&#x2F;docs&#x2F;&quot;);Path targetPath &#x3D; Paths.get(&quot;&#x2F;docs&#x2F;imgs&#x2F;itwanger&quot;);Path relativePath &#x3D; basePath.relativize(targetPath);System.out.println(&quot;Relative path: &quot; + relativePath);
Files 类 
java.nio.file.Files类提供了大量静态方法，用于处理文件系统中的文件和目录。这些方法包括文件的创建、删除、复制、移动等操作，以及读取和设置文件属性。
下面展示一个 Files 和 Paths 一起使用的示例：
123456789&#x2F;&#x2F; 创建一个Path实例Path path &#x3D; Paths.get(&quot;logs&#x2F;javabetter&#x2F;itwanger4.txt&quot;);&#x2F;&#x2F; 创建一个新文件Files.createFile(path);&#x2F;&#x2F; 检查文件是否存在boolean exists &#x3D; Files.exists(path);System.out.println(&quot;File exists: &quot; + exists);&#x2F;&#x2F; 删除文件Files.delete(path);
以下是一些常用方法及其示例：
1、 exists(Path path, LinkOption… options) ：检查文件或目录是否存在。
123Path path &#x3D; Paths.get(&quot;file.txt&quot;);boolean exists &#x3D; Files.exists(path);System.out.println(&quot;File exists: &quot; + exists);
LinkOption 是一个枚举类，它定义了如何处理文件系统链接的选项。它位于 java.nio.file 包中。LinkOption 主要在与文件或目录的路径操作相关的方法中使用，以控制这些方法如何处理符号链接。符号链接是一种特殊类型的文件，它在 Unix 和类 Unix 系统（如 Linux 和 macOS）上很常见。在 Windows 上，类似的概念被称为快捷方式。
2、 createFile(Path path, FileAttribute&lt;?&gt;… attrs) ：创建一个新的空文件。
12Path newPath &#x3D; Paths.get(&quot;newFile.txt&quot;);Files.createFile(newPath);
FileAttribute 是一个泛型接口，用于处理各种不同类型的属性。在使用 FileAttribute 时，你需要为其提供一个特定的实现。 java.nio.file.attribute 包中的 PosixFileAttributes 类提供了 POSIX（Portable Operating System Interface，定义了许多与文件系统相关的操作，包括文件和目录的创建、删除、读取和修改。）文件属性的实现。
12345Path path &#x3D; Paths.get(&quot;fileWithPermissions.txt&quot;);Set&lt;PosixFilePermission&gt; permissions &#x3D; PosixFilePermissions.fromString(&quot;rw-r-----&quot;);FileAttribute&lt;Set&lt;PosixFilePermission&gt;&gt; fileAttribute &#x3D; PosixFilePermissions.asFileAttribute(permissions);Files.createFile(path, fileAttribute);
PosixFileAttributes 接口提供了获取 POSIX 文件属性的方法，如文件所有者、文件所属的组以及文件的访问权限。以上示例会创建一个读写属性的文件。
3、 createDirectory(Path dir, FileAttribute&lt;?&gt;… attrs) ：创建一个新的目录。
12Path newDir &#x3D; Paths.get(&quot;newDirectory&quot;);Files.createDirectory(newDir);
4、 delete(Path path) ：删除文件或目录。
12Path pathToDelete &#x3D; Paths.get(&quot;fileToDelete.txt&quot;);Files.delete(pathToDelete);
5、 copy(Path source, Path target, CopyOption… options) ：复制文件或目录。
123Path sourcePath &#x3D; Paths.get(&quot;sourceFile.txt&quot;);Path targetPath &#x3D; Paths.get(&quot;targetFile.txt&quot;);Files.copy(sourcePath, targetPath, StandardCopyOption.REPLACE_EXISTING);
在 Java NIO 中，有两个实现了 CopyOption 接口的枚举类：StandardCopyOption 和 LinkOption。
StandardCopyOption 枚举类提供了以下两个选项：

REPLACE_EXISTING：如果目标文件已经存在，该选项会使 Files.copy() 方法替换目标文件。如果不指定此选项， Files.copy() 方法在目标文件已存在时将抛出 FileAlreadyExistsException。
COPY_ATTRIBUTES：此选项表示在复制文件时，尽可能地复制文件的属性（如文件时间戳、权限等）。如果不指定此选项，那么目标文件将具有默认的属性。

6、 move(Path source, Path target, CopyOption… options) ：移动或重命名文件或目录。
123Path sourcePath &#x3D; Paths.get(&quot;sourceFile.txt&quot;);Path targetPath &#x3D; Paths.get(&quot;targetFile.txt&quot;);Files.move(sourcePath, targetPath, StandardCopyOption.REPLACE_EXISTING);
7、 readAllLines(Path path, Charset cs) ：读取文件的所有行到一个字符串列表。
123ath path &#x3D; Paths.get(&quot;file.txt&quot;);List&lt;String&gt; lines &#x3D; Files.readAllLines(path, StandardCharsets.UTF_8);lines.forEach(System.out::println);
8、 write(Path path, Iterable&lt;? extends CharSequence&gt; lines, Charset cs, OpenOption… options) ：将字符串列表写入文件。
123Path path &#x3D; Paths.get(&quot;file.txt&quot;);List&lt;String&gt; lines &#x3D; Arrays.asList(&quot;沉默王二 1&quot;, &quot;沉默王二 2&quot;, &quot;沉默王二 3&quot;);Files.write(path, lines, StandardCharsets.UTF_8);
OpenOption 是 Java NIO 中一个用于配置文件操作的接口。它提供了在使用 Files.newByteChannel() 、Files.newInputStream() 、 Files.newOutputStream() 、 AsynchronousFileChannel.open() 和 FileChannel.open() 方法时定制行为的选项。
在 Java NIO 中，有两个实现了 OpenOption 接口的枚举类：StandardOpenOption 和 LinkOption。
StandardOpenOption 枚举类提供了以下几个选项：

READ：以读取模式打开文件。
WRITE：以写入模式打开文件。
APPEND：以追加模式打开文件。
TRUNCATE_EXISTING：在打开文件时，截断文件的内容，使其长度为 0。仅适用于 WRITE 或 APPEND 模式。
CREATE：当文件不存在时创建文件。如果文件已存在，则打开文件。
CREATE_NEW：当文件不存在时创建文件。如果文件已存在，抛出 FileAlreadyExistsException。
DELETE_ON_CLOSE：在关闭通道时删除文件。
SPARSE：提示文件系统创建一个稀疏文件。
SYNC：要求每次更新文件的内容或元数据时都进行同步。
DSYNC：要求每次更新文件内容时都进行同步。

8、 newBufferedReader(Path path, Charset cs) 和 newBufferedWriter(Path path, Charset cs, OpenOption… options) ：创建 BufferedReader 和 BufferedWriter 对象以读取和写入文件。
123456789101112131415Path path &#x3D; Paths.get(&quot;file.txt&quot;);&#x2F;&#x2F; Read filetry (BufferedReader reader &#x3D; Files.newBufferedReader(path, StandardCharsets.UTF_8)) {    String line;    while ((line &#x3D; reader.readLine()) !&#x3D; null) {        System.out.println(line);    }}&#x2F;&#x2F; Write filePath outputPath &#x3D; Paths.get(&quot;outputFile.txt&quot;);try (BufferedWriter writer &#x3D; Files.newBufferedWriter(outputPath, StandardCharsets.UTF_8)) {    writer.write(&quot;沉默王二&quot;);}
Files.walkFileTree() 静态方法 
这个方法可以递归地访问目录结构中的所有文件和目录，并允许您对这些文件和目录执行自定义操作。使用 walkFileTree 方法时，需要提供一个起始路径（起始目录）和一个实现了 FileVisitor 接口的对象。
FileVisitor 接口包含四个方法，它们在遍历过程中的不同阶段被调用：

preVisitDirectory：在访问目录之前调用。
postVisitDirectory：在访问目录之后调用。
visitFile：在访问文件时调用。
visitFileFailed：在访问文件失败时调用。

来看下面这个示例：
123456789101112131415161718192021222324252627282930313233public class WalkFileTreeExample {    public static void main(String[] args) {        Path startingDir &#x3D; Paths.get(&quot;docs&quot;);        MyFileVisitor fileVisitor &#x3D; new MyFileVisitor();        try {            Files.walkFileTree(startingDir, fileVisitor);        } catch (IOException e) {            e.printStackTrace();        }    }    private static class MyFileVisitor extends SimpleFileVisitor&lt;Path&gt; {        @Override        public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {            System.out.println(&quot;准备访问目录: &quot; + dir);            return FileVisitResult.CONTINUE;        }        @Override        public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {            System.out.println(&quot;正在访问目录: &quot; + dir);            return FileVisitResult.CONTINUE;        }        @Override        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {            System.out.println(&quot;访问文件: &quot; + file);            return FileVisitResult.CONTINUE;        }        @Override        public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {            System.err.println(&quot;访问文件失败: &quot; + file);            return FileVisitResult.CONTINUE;        }    }}
运行结果如下： 
1234567891011121314151617181920准备访问目录: docs访问文件: docs&#x2F;安装环境.md准备访问目录: docs&#x2F;imgs访问文件: docs&#x2F;imgs&#x2F;init_03.jpg准备访问目录: docs&#x2F;imgs&#x2F;itwanger访问文件: docs&#x2F;imgs&#x2F;itwanger&#x2F;tongzhishu.jpeg访问文件: docs&#x2F;imgs&#x2F;itwanger&#x2F;tongzhishu1.jpeg访问文件: docs&#x2F;imgs&#x2F;itwanger&#x2F;tongzhishu1.pdf正在访问目录: docs&#x2F;imgs&#x2F;itwanger访问文件: docs&#x2F;imgs&#x2F;init_02.jpg访问文件: docs&#x2F;imgs&#x2F;init_00.jpg访问文件: docs&#x2F;imgs&#x2F;init_01.jpg访问文件: docs&#x2F;imgs&#x2F;init_04.jpg正在访问目录: docs&#x2F;imgs访问文件: docs&#x2F;服务器启动教程.md访问文件: docs&#x2F;配套教程.md访问文件: docs&#x2F;约定.md访问文件: docs&#x2F;本地开发环境配置教程.md访问文件: docs&#x2F;前端工程结构说明.md正在访问目录: docs
在这个示例中，我们创建了一个名为 MyFileVisitor 的自定义 FileVisitor 类，它扩展了 SimpleFileVisitor 类。SimpleFileVisitor 是 FileVisitor 接口的一个实现，它提供了一些默认的行为。我们可以覆盖 SimpleFileVisitor 中的方法以实现自己的逻辑。在这个例子中，我们只是打印出了访问的文件和目录。然后，我们使用 Files.walkFileTree 方法遍历文件树。这个方法会遍历整个目录结构，并调用 MyFileVisitor 中的相应方法。
其中，FileVisitResult 枚举包含以下四个选项：

CONTINUE ： 继续
TERMINATE ： 终止
SKIP_SIBLINGS ： 跳过兄弟节点，然后继续
SKIP_SUBTREE ： 跳过子树（不访问此目录的条目），然后继续，仅在 preVisitDirectory 方法返回时才有意义，除此以外和 CONTINUE 相同。

搜索文件 
walkFileTree() 方法还可以用于搜索文件，下面这个例子扩展了 SimpleFileVisitor 来查找一个名为 itwanger.txt 的文件：
123456789101112131415161718192021222324252627282930313233343536373839public class FindFileWithWalkFileTree {    public static void main(String[] args) {        Path startingDir &#x3D; Paths.get(&quot;logs&quot;);        String targetFileName &#x3D; &quot;itwanger.txt&quot;;        FindFileVisitor findFileVisitor &#x3D; new FindFileVisitor(targetFileName);        try {            Files.walkFileTree(startingDir, findFileVisitor);            if (findFileVisitor.isFileFound()) {                System.out.println(&quot;找到文件了: &quot; + findFileVisitor.getFoundFilePath());            } else {                System.out.println(&quot;ooh，文件没找到&quot;);            }        } catch (IOException e) {            e.printStackTrace();        }    }    private static class FindFileVisitor extends SimpleFileVisitor&lt;Path&gt; {        private String targetFileName;        private Path foundFilePath;        public FindFileVisitor(String targetFileName) {            this.targetFileName &#x3D; targetFileName;        }        public boolean isFileFound() {            return foundFilePath !&#x3D; null;        }        public Path getFoundFilePath() {            return foundFilePath;        }        @Override        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {            String fileName &#x3D; file.getFileName().toString();            if (fileName.equals(targetFileName)) {                foundFilePath &#x3D; file;                return FileVisitResult.TERMINATE;            }            return FileVisitResult.CONTINUE;        }    }}
在主方法中，我们使用 Files.walkFileTree 方法遍历文件树，并传递一个起始目录和 FindFileVisitor 实例。
遍历完成后，我们检查是否找到了目标文件，如果找到了，就打印出它的路径。
搜索结果如下所示：

小结 
Paths 和 Files 是 Java NIO 中的两个核心类。Paths 提供了一系列静态方法，用于操作路径（Path 对象）。它可以将字符串或 URI 转换为 Path 对象，方便后续操作。Files 类提供了丰富的文件操作方法，如文件的创建、删除、移动、复制、读取和写入等。这些方法支持各种选项和属性，如覆盖、保留属性和符号链接处理。Files 还支持文件遍历（如 walkFileTree 方法），可以处理文件目录树。总之，Paths 和 Files 为文件和目录操作提供了简洁、高效的方法。
10.5 NIO 实现简易版聊天室在此之前，我们曾利用 Java 的套接字 Socket 和 ServerSocket 完成网络编程，但 Socket 和 ServerSocket 是基于 Java IO 的，在网络编程方面，性能会比较差。原因我们在之前也讲过。
那 Java NIO 的 SocketChannel 和 ServerSocketChannel 性能怎么样呢？
SocketChannel 和 ServerSocketChannel 
在学习 NIO 的第一讲里，我们已经介绍过 SocketChannel 和 ServerSocketChannel了，这里再简单补充下。
ServerSocketChannel 用于创建服务器端套接字，而 SocketChannel 用于创建客户端套接字。它们都支持阻塞和非阻塞模式，通过设置其 blocking 属性来切换。阻塞模式下，读&#x2F;写操作会一直阻塞直到完成，而非阻塞模式下，读&#x2F;写操作会立即返回。
阻塞模式：

优点：编程简单，适合低并发场景。
缺点：性能较差，不适合高并发场景。

非阻塞模式：

优点：性能更好，适合高并发场景。
缺点：编程相对复杂。

我们来看一个简单的示例（阻塞模式下）：
先来看 Server 端的：
1234567891011121314151617181920212223242526public class BlockingServer {    public static void main(String[] args) throws IOException {        &#x2F;&#x2F; 创建服务器套接字        ServerSocketChannel serverSocketChannel &#x3D; ServerSocketChannel.open();        &#x2F;&#x2F; 绑定端口        serverSocketChannel.socket().bind(new InetSocketAddress(8080));        &#x2F;&#x2F; 设置为阻塞模式（默认为阻塞模式）        serverSocketChannel.configureBlocking(true);        while (true) {            &#x2F;&#x2F; 接收客户端连接            SocketChannel socketChannel &#x3D; serverSocketChannel.accept();            &#x2F;&#x2F; 分配缓冲区            ByteBuffer buffer &#x3D; ByteBuffer.allocate(1024);            &#x2F;&#x2F; 读取数据            int bytesRead &#x3D; socketChannel.read(buffer);            while (bytesRead !&#x3D; -1) {                buffer.flip();                System.out.println(StandardCharsets.UTF_8.decode(buffer));                buffer.clear();                bytesRead &#x3D; socketChannel.read(buffer);            }            &#x2F;&#x2F; 关闭套接字            socketChannel.close();        }    }}
简单解释一下这段代码，也比较好理解。
首先创建服务器端套接字ServerSocketChannel，然后绑定 8080 端口，接着使用 while 循环监听客户端套接字。如果接收到客户端连接 SocketChannel，就从通道里读取数据到缓冲区 ByteBuffer，一直读到通道里没有数据，关闭当前通道。
其中 serverSocketChannel.configureBlocking(true) 用来设置通道为阻塞模式（可以缺省）。
再来看客户端的：
123456789101112131415161718public class BlockingClient {    public static void main(String[] args) throws IOException {        &#x2F;&#x2F; 创建客户端套接字        SocketChannel socketChannel &#x3D; SocketChannel.open();        &#x2F;&#x2F; 连接服务器        socketChannel.connect(new InetSocketAddress(&quot;localhost&quot;, 8080));        &#x2F;&#x2F; 分配缓冲区        ByteBuffer buffer &#x3D; ByteBuffer.allocate(1024);        &#x2F;&#x2F; 向服务器发送数据        buffer.put(&quot;沉默王二，这是来自客户端的消息。&quot;.getBytes(StandardCharsets.UTF_8));        buffer.flip();        socketChannel.write(buffer);        &#x2F;&#x2F; 清空缓冲区        buffer.clear();        &#x2F;&#x2F; 关闭套接字        socketChannel.close();    }}
客户端代码就更简单了，建立通道 SocketChannel，连接服务器，然后在缓冲区里放一段数据，之后写入到通道中，关闭套接字。
先运行 BlockingServer，再运行 BlockingClient，可以在 Server 端的控制台收到以下信息。

好，我们再来看非阻塞模式下的示例。
先来看 Server 端： 
1234567891011121314151617181920212223242526272829303132333435363738394041424344public class NonBlockingServer {    public static void main(String[] args) throws IOException {        &#x2F;&#x2F; 创建服务器套接字        ServerSocketChannel serverSocketChannel &#x3D; ServerSocketChannel.open();        &#x2F;&#x2F; 绑定端口        serverSocketChannel.socket().bind(new InetSocketAddress(8080));        &#x2F;&#x2F; 设置为非阻塞模式        serverSocketChannel.configureBlocking(false);        &#x2F;&#x2F; 创建选择器        Selector selector &#x3D; Selector.open();        &#x2F;&#x2F; 注册服务器套接字到选择器        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);        while (true) {            selector.select();            Set&lt;SelectionKey&gt; selectedKeys &#x3D; selector.selectedKeys();            Iterator&lt;SelectionKey&gt; iterator &#x3D; selectedKeys.iterator();            while (iterator.hasNext()) {                SelectionKey key &#x3D; iterator.next();                iterator.remove();                if (key.isAcceptable()) {                    &#x2F;&#x2F; 接收客户端连接                    SocketChannel socketChannel &#x3D; serverSocketChannel.accept();                    socketChannel.configureBlocking(false);                    socketChannel.register(selector, SelectionKey.OP_READ);                }                if (key.isReadable()) {                    &#x2F;&#x2F; 读取数据                    SocketChannel socketChannel &#x3D; (SocketChannel) key.channel();                    ByteBuffer buffer &#x3D; ByteBuffer.allocate(1024);                    int bytesRead &#x3D; socketChannel.read(buffer);                    if (bytesRead !&#x3D; -1) {                        buffer.flip();                        System.out.print(StandardCharsets.UTF_8.decode(buffer));                        buffer.clear();                    } else {                        &#x2F;&#x2F; 客户端已断开连接，取消选择键并关闭通道                        key.cancel();                        socketChannel.close();                    }                }            }        }    }}
与之前阻塞模式相同的，我们就不再赘述了，只说不同的。
①、首先，创建一个 ServerSocketChannel，并将其设置为非阻塞模式。
12ServerSocketChannel serverSocketChannel &#x3D; ServerSocketChannel.open();serverSocketChannel.configureBlocking(false);
②、创建一个 Selector 实例，用于处理多个通道的事件。
1Selector selector &#x3D; Selector.open();
③、将 ServerSocketChannel 注册到 Selector 上，并设置感兴趣的事件为 OP_ACCEPT。这意味着当有新的客户端连接请求时，Selector 会通知我们。
1serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
看一下 OP_ACCEPT 的注释：            
④、循环处理 Selector 中的事件。首先调用 selector.select() 方法来等待感兴趣的事件发生。这个方法会阻塞，直到至少有一个感兴趣的事件发生。
1234567while (true) {    int readyChannels &#x3D; selector.select();    if (readyChannels &#x3D;&#x3D; 0) {        continue;    }    &#x2F;&#x2F; ...}
⑤、当 selector.select() 返回时，我们可以通过 selector.selectedKeys() 获取所有已就绪的事件，并对其进行迭代处理。在处理事件时，根据 SelectionKey 的类型来执行相应的操作。
12345678Set&lt;SelectionKey&gt; selectedKeys &#x3D; selector.selectedKeys();Iterator&lt;SelectionKey&gt; keyIterator &#x3D; selectedKeys.iterator();while (keyIterator.hasNext()) {    SelectionKey key &#x3D; keyIterator.next();    &#x2F;&#x2F; 处理事件    &#x2F;&#x2F; ...    keyIterator.remove();}
⑥、当 SelectionKey 的类型为 OP_ACCEPT 时，说明有新的客户端连接请求。此时，我们需要接受新的连接，并将新创建的 SocketChannel 设置为非阻塞模式。然后，将该 SocketChannel 注册到 Selector 上，并设置感兴趣的事件为 OP_READ。
123456if (key.isAcceptable()) {    ServerSocketChannel server &#x3D; (ServerSocketChannel) key.channel();    SocketChannel client &#x3D; server.accept();    client.configureBlocking(false);    client.register(selector, SelectionKey.OP_READ);}
⑦、当 SelectionKey 的类型为 OP_READ 时，说明有客户端发送了数据。我们需要从 SocketChannel 中读取数据，并进行相应的处理。
1234567if (key.isReadable()) {    SocketChannel client &#x3D; (SocketChannel) key.channel();    ByteBuffer buffer &#x3D; ByteBuffer.allocate(1024);    int bytesRead &#x3D; client.read(buffer);    &#x2F;&#x2F; 对读取到的数据进行处理    &#x2F;&#x2F; ...}
⑧、（如果可以的话）当 SelectionKey 的类型为 OP_WRITE 时，说明可以向客户端发送数据。我们可以将要发送的数据写入 SocketChannel。
12345if (key.isWritable()) {    SocketChannel client &#x3D; (SocketChannel) key.channel();    ByteBuffer buffer &#x3D; ByteBuffer.wrap(&quot;你好，客户端&quot;.getBytes());   client.write(buffer);}
不过，本例中并没有这一步。如果需要的话，可以按照这样的方式向客户端写入数据。
⑨、在服务器停止运行时，需要关闭 Selector 和 ServerSocketChannel，释放资源。
12key.cancel();socketChannel.close();
好，接下来，我们来看客户端的。
123456789101112131415161718192021222324public class NonBlockingClient {    public static void main(String[] args) throws IOException {        &#x2F;&#x2F; 创建客户端套接字        SocketChannel socketChannel &#x3D; SocketChannel.open();        &#x2F;&#x2F; 设置为非阻塞模式        socketChannel.configureBlocking(false);        &#x2F;&#x2F; 连接服务器        socketChannel.connect(new InetSocketAddress(&quot;localhost&quot;, 8080));        while (!socketChannel.finishConnect()) {            &#x2F;&#x2F; 等待连接完成        }        &#x2F;&#x2F; 分配缓冲区        ByteBuffer buffer &#x3D; ByteBuffer.allocate(1024);        &#x2F;&#x2F; 向服务器发送数据        String message &#x3D; &quot;你好，沉默王二，这是来自客户端的消息。&quot;;        buffer.put(message.getBytes(StandardCharsets.UTF_8));        buffer.flip();        socketChannel.write(buffer);        &#x2F;&#x2F; 清空缓冲区        buffer.clear();        &#x2F;&#x2F; 关闭套接字        socketChannel.close();    }}
客户端代码依然比较简单，我们直接略过，不再解释。然后运行 Server，再运行 Client。可以运行多次，结果如下：

Scatter 和 Gather 
Scatter 和 Gather 是 Java NIO 中两种高效的 I&#x2F;O 操作，用于将数据分散到多个缓冲区或从多个缓冲区中收集数据。
Scatter（分散）：它将从 Channel 读取的数据分散（写入）到多个缓冲区。这种操作可以在读取数据时将其分散到不同的缓冲区，有助于处理结构化数据。例如，我们可以将消息头、消息体和消息尾分别写入不同的缓冲区。
Gather（聚集）：与 Scatter 相反，它将多个缓冲区中的数据聚集（读取）并写入到一个 Channel。这种操作允许我们在发送数据时从多个缓冲区中聚集数据。例如，我们可以将消息头、消息体和消息尾从不同的缓冲区中聚集到一起并写入到同一个 Channel。
来写一个完整的 demo，先看 Server。
12345678910111213141516171819202122232425262728&#x2F;&#x2F; 创建一个ServerSocketChannelServerSocketChannel serverSocketChannel &#x3D; ServerSocketChannel.open();serverSocketChannel.socket().bind(new InetSocketAddress(9000));&#x2F;&#x2F; 接受连接SocketChannel socketChannel &#x3D; serverSocketChannel.accept();&#x2F;&#x2F; Scatter：分散读取数据到多个缓冲区ByteBuffer headerBuffer &#x3D; ByteBuffer.allocate(128);ByteBuffer bodyBuffer &#x3D; ByteBuffer.allocate(1024);ByteBuffer[] buffers &#x3D; {headerBuffer, bodyBuffer};long bytesRead &#x3D; socketChannel.read(buffers);&#x2F;&#x2F; 输出缓冲区数据headerBuffer.flip();while (headerBuffer.hasRemaining()) {    System.out.print((char) headerBuffer.get());}System.out.println();bodyBuffer.flip();while (bodyBuffer.hasRemaining()) {    System.out.print((char) bodyBuffer.get());}&#x2F;&#x2F; Gather：聚集数据从多个缓冲区写入到ChannelByteBuffer headerResponse &#x3D; ByteBuffer.wrap(&quot;Header Response&quot;.getBytes());ByteBuffer bodyResponse &#x3D; ByteBuffer.wrap(&quot;Body Response&quot;.getBytes());ByteBuffer[] responseBuffers &#x3D; {headerResponse, bodyResponse};long bytesWritten &#x3D; socketChannel.write(responseBuffers);&#x2F;&#x2F; 关闭连接socketChannel.close();serverSocketChannel.close();
再来看 Client：
1234567891011121314151617181920212223242526&#x2F;&#x2F; 创建一个SocketChannelSocketChannel socketChannel &#x3D; SocketChannel.open();socketChannel.connect(new InetSocketAddress(&quot;localhost&quot;, 9000));&#x2F;&#x2F; 发送数据到服务器String header &#x3D; &quot;Header Content&quot;;String body &#x3D; &quot;Body Content&quot;;ByteBuffer headerBuffer &#x3D; ByteBuffer.wrap(header.getBytes());ByteBuffer bodyBuffer &#x3D; ByteBuffer.wrap(body.getBytes());ByteBuffer[] buffers &#x3D; {headerBuffer, bodyBuffer};socketChannel.write(buffers);&#x2F;&#x2F; 从服务器接收数据ByteBuffer headerResponseBuffer &#x3D; ByteBuffer.allocate(128);ByteBuffer bodyResponseBuffer &#x3D; ByteBuffer.allocate(1024);ByteBuffer[] responseBuffers &#x3D; {headerResponseBuffer, bodyResponseBuffer};long bytesRead &#x3D; socketChannel.read(responseBuffers);&#x2F;&#x2F; 输出接收到的数据headerResponseBuffer.flip();while (headerResponseBuffer.hasRemaining()) {    System.out.print((char) headerResponseBuffer.get());}bodyResponseBuffer.flip();while (bodyResponseBuffer.hasRemaining()) {    System.out.print((char) bodyResponseBuffer.get());}&#x2F;&#x2F; 关闭连接socketChannel.close();
在这个示例中，我们使用了 Scattering 从 SocketChannel 分散读取数据到多个缓冲区，并使用 Gathering 将数据从多个缓冲区聚集写入到 SocketChannel。通过这种方式，我们可以方便地处理多个缓冲区中的数据。
异步套接字通道 AsynchronousSocketChannel 和 AsynchronousServerSocketChannel
AsynchronousSocketChannel 和 AsynchronousServerSocketChannel 是 Java 7 引入的异步 I&#x2F;O 类，分别用于处理异步客户端 Socket 和服务器端 ServerSocket。异步 I&#x2F;O 允许在 I&#x2F;O 操作进行时执行其他任务，并在操作完成时接收通知，提高了并发处理能力。
来看一个简单的示例，先看服务器端。
123456789101112131415161718192021222324252627282930313233public class AsynchronousServer {    public static void main(String[] args) throws IOException, InterruptedException {        AsynchronousServerSocketChannel server &#x3D; AsynchronousServerSocketChannel.open();        server.bind(new InetSocketAddress(&quot;localhost&quot;, 5000));        System.out.println(&quot;服务器端启动&quot;);        server.accept(null, new CompletionHandler&lt;AsynchronousSocketChannel, Void&gt;() {            @Override            public void completed(AsynchronousSocketChannel client, Void attachment) {                &#x2F;&#x2F; 接收下一个连接请求                server.accept(null, this);                ByteBuffer buffer &#x3D; ByteBuffer.allocate(1024);                Future&lt;Integer&gt; readResult &#x3D; client.read(buffer);                try {                    readResult.get();                    buffer.flip();                    String message &#x3D; new String(buffer.array(), 0, buffer.remaining());                    System.out.println(&quot;接收到的消息: &quot; + message);                } catch (Exception e) {                    e.printStackTrace();                }            }            @Override            public void failed(Throwable exc, Void attachment) {                exc.printStackTrace();            }        });        &#x2F;&#x2F; 为了让服务器继续运行，我们需要阻止 main 线程退出        Thread.currentThread().join();    }}
代码结构和之前讲到的异步文件通道 AsynchronousFileChannel 比较相似，异步服务单套接字通道 AsynchronousServerSocketChannel 接收客户端连接，每当收到一个新的连接时，会调用 completed() 方法，然后读取客户端发送的数据并将其打印到控制台。
来简单分析一下吧。
①、创建了一个 AsynchronousServerSocketChannel 实例并将其打开。这个通道将用于监听客户端连接。
1AsynchronousServerSocketChannel server &#x3D; AsynchronousServerSocketChannel.open();
②、调用 accept() 方法来接收客户端连接。这个方法需要一个 CompletionHandler 实例，当客户端连接成功时， completed() 方法会被调用。
12server.accept(null, new CompletionHandler&lt;AsynchronousSocketChannel, Void&gt;() { ... });
③、实现 CompletionHandler，I&#x2F;O 操作成功时，会调用 completed() 方法；当 I&#x2F;O 操作失败时，会调用 failed() 方法。
123456new CompletionHandler&lt;AsynchronousSocketChannel, Void&gt;() {    @Override    public void completed(AsynchronousSocketChannel client, Void attachment) { ... }    @Override    public void failed(Throwable exc, Void attachment) { ... }}
在 completed 方法中，我们首先调用 server.accept() 来接收下一个连接请求。然后，我们创建一个缓冲区 ByteBuffer 并使用 client.read() 从客户端读取数据。在这个示例中，我们使用了一个 Future 对象来等待读取操作完成。当读取完成时，我们将缓冲区的内容打印到控制台。           
④、为了让服务器继续运行并接收客户端连接，我们需要阻止 main 线程退出。
1Thread.currentThread().join();
再来看客户端的：
12345678910111213141516171819public class AsynchronousClient {    public static void main(String[] args) {        try {            AsynchronousSocketChannel client &#x3D; AsynchronousSocketChannel.open();            Future&lt;Void&gt; connectResult &#x3D; client.connect(new InetSocketAddress(&quot;localhost&quot;, 5000));            connectResult.get(); &#x2F;&#x2F; 等待连接完成            String message &#x3D; &quot;沉默王二，在吗？&quot;;            ByteBuffer buffer &#x3D; ByteBuffer.wrap(message.getBytes(StandardCharsets.UTF_8));            Future&lt;Integer&gt; writeResult &#x3D; client.write(buffer);            writeResult.get(); &#x2F;&#x2F; 等待发送完成            System.out.println(&quot;消息发送完毕&quot;);            client.close();        } catch (IOException | InterruptedException | ExecutionException e) {            e.printStackTrace();        }    }}
就是简单的连接和写入数据，就不多做解释了。这里先运行一下 Server 端，然后再运行一下客户端，看一下结果。

简单的聊天室 
我们来通过 SocketChannel 和 ServerSocketChannel 实现一个 0.1 版的聊天室，先说一下需求，比较简单，服务端启动监听客户端请求，当客户端向服务器端发送信息后，服务器端接收到后把客户端消息回显给客户端，比较呆瓜，但可以先来看一下。

我们来看服务器端代码：
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class ChatServer {    private Selector selector;    private ServerSocketChannel serverSocketChannel;    private static final int PORT &#x3D; 8080;    public ChatServer() {        try {            selector &#x3D; Selector.open();            serverSocketChannel &#x3D; ServerSocketChannel.open();            serverSocketChannel.socket().bind(new InetSocketAddress(PORT));            serverSocketChannel.configureBlocking(false);            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);            System.out.println(&quot;聊天室服务端启动了 &quot; + PORT);        } catch (IOException e) {            e.printStackTrace();        }    }    public void start() {        try {            while (true) {                if (selector.select() &gt; 0) {                    Iterator&lt;SelectionKey&gt; iterator &#x3D; selector.selectedKeys().iterator();                    while (iterator.hasNext()) {                        SelectionKey key &#x3D; iterator.next();                        iterator.remove();                        handleKey(key);                    }                }            }        } catch (IOException e) {            e.printStackTrace();        }    }    private void handleKey(SelectionKey key) throws IOException {        if (key.isAcceptable()) {            SocketChannel socketChannel &#x3D; serverSocketChannel.accept();            socketChannel.configureBlocking(false);            socketChannel.register(selector, SelectionKey.OP_READ);            System.out.println(&quot;客户端连接上了: &quot; + socketChannel.getRemoteAddress());        } else if (key.isReadable()) {            SocketChannel socketChannel &#x3D; (SocketChannel) key.channel();            ByteBuffer buffer &#x3D; ByteBuffer.allocate(1024);            int read &#x3D; socketChannel.read(buffer);            if (read &gt; 0) {                buffer.flip();                String msg &#x3D; new String(buffer.array(), 0, read);                System.out.println(&quot;客户端说: &quot; + msg);                socketChannel.write(ByteBuffer.wrap((&quot;服务端回复: &quot; + msg).getBytes()));            }        }    }    public static void main(String[] args) {        new ChatServer().start();    }}
解释一下代码逻辑：
1、创建一个 ServerSocketChannel，并将其绑定到指定端口。
2、将 ServerSocketChannel 设置为非阻塞模式。
3、创建一个 Selector，并将 ServerSocketChannel 注册到它上面，监听 OP_ACCEPT 事件（等待客户端连接）。
4、无限循环，等待感兴趣的事件发生。
5、使用 Selector.select() 方法，等待已注册的通道中有事件发生。
6、获取到发生事件的通道的 SelectionKey。
7、判断 SelectionKey 的事件类型：

a. 如果是 OP_ACCEPT 事件，说明有新的客户端连接进来。接受新的连接，并将新连接的 SocketChannel 注册到 Selector 上，监听 OP_READ 事件。
b. 如果是 OP_READ 事件，说明客户端发送了消息。读取客户端发送的消息，并将其返回给客户端。 处理完毕后，清除已处理的 SelectionKey。

再来看一下客户端的代码：
12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class ChatClient {    private Selector selector;    private SocketChannel socketChannel;    private static final String HOST &#x3D; &quot;localhost&quot;;    private static final int PORT &#x3D; 8080;    public ChatClient() {        try {            selector &#x3D; Selector.open();            socketChannel &#x3D; SocketChannel.open(new InetSocketAddress(HOST, PORT));            socketChannel.configureBlocking(false);            socketChannel.register(selector, SelectionKey.OP_READ);            System.out.println(&quot;连接到聊天室了&quot;);        } catch (IOException e) {            e.printStackTrace();        }    }    public void start() {        new Thread(() -&gt; {            try {                while (true) {                    if (selector.select() &gt; 0) {                        for (SelectionKey key : selector.selectedKeys()) {                            selector.selectedKeys().remove(key);                            if (key.isReadable()) {                                readMessage();                            }                        }                    }                }            } catch (IOException e) {                e.printStackTrace();            }        }).start();        try (BufferedReader reader &#x3D; new BufferedReader(new InputStreamReader(System.in))) {            String input;            while ((input &#x3D; reader.readLine()) !&#x3D; null) {                sendMessage(input);            }        } catch (IOException e) {            e.printStackTrace();        }    }    private void sendMessage(String message) throws IOException {        if (message !&#x3D; null &amp;&amp; !message.trim().isEmpty()) {            ByteBuffer buffer &#x3D; ByteBuffer.wrap(message.getBytes());            socketChannel.write(buffer);        }    }    private void readMessage() throws IOException {        ByteBuffer buffer &#x3D; ByteBuffer.allocate(1024);        int read &#x3D; socketChannel.read(buffer);        if (read &gt; 0) {            buffer.flip();            String msg &#x3D; new String(buffer.array(), 0, read);            System.out.println(msg);        }    }    public static void main(String[] args) {        new ChatClient().start();    }}
解释一下代码逻辑：
1、创建一个 SocketChannel，并连接到指定的服务器地址和端口。
2、将 SocketChannel 设置为非阻塞模式。
3、创建一个 Selector，并将 SocketChannel 注册到它上面，监听 OP_READ 事件（等待接收服务器的消息）。
4、启动一个新线程用于读取用户在控制台输入的消息，并发送给服务器。
5、无限循环，等待感兴趣的事件发生。
6、使用 Selector.select() 方法，等待已注册的通道中有事件发生。
7、获取到发生事件的通道的 SelectionKey。
8、判断 SelectionKey 的事件类型：

a. 如果是 OP_READ 事件，说明服务器发送了消息。读取服务器发送的消息，并在控制台显示。 处理完毕后，清除已处理的 SelectionKey。

来看运行后的效果。

好，接下来，我们来升级一下需求，也就是 0.2 版聊天室，要求服务器端也能从控制台敲入信息主动发送给客户端。

来看服务器端代码：
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class Chat2Server {    public static void main(String[] args) throws IOException {        &#x2F;&#x2F; 创建一个 ServerSocketChannel        ServerSocketChannel serverSocketChannel &#x3D; ServerSocketChannel.open();        serverSocketChannel.configureBlocking(false);        serverSocketChannel.bind(new InetSocketAddress(8080));        &#x2F;&#x2F; 创建一个 Selector        Selector selector &#x3D; Selector.open();        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);        System.out.println(&quot;聊天室服务端启动了&quot;);        &#x2F;&#x2F; 客户端连接        AtomicReference&lt;SocketChannel&gt; clientRef &#x3D; new AtomicReference&lt;&gt;();        &#x2F;&#x2F; 从控制台读取输入并发送给客户端        Thread sendMessageThread &#x3D; new Thread(() -&gt; {            try (BufferedReader reader &#x3D; new BufferedReader(new InputStreamReader(System.in))) {                while (true) {                    System.out.println(&quot;输入服务器端消息: &quot;);                    String message &#x3D; reader.readLine();                    SocketChannel client &#x3D; clientRef.get();                    if (client !&#x3D; null &amp;&amp; client.isConnected()) {                        ByteBuffer buffer &#x3D; ByteBuffer.wrap((message + &quot;\n&quot;).getBytes());                        client.write(buffer);                    }                }            } catch (IOException e) {                e.printStackTrace();            }        });        sendMessageThread.start();        while (true) {            int readyChannels &#x3D; selector.select();            if (readyChannels &#x3D;&#x3D; 0) {                continue;            }            Set&lt;SelectionKey&gt; selectedKeys &#x3D; selector.selectedKeys();            Iterator&lt;SelectionKey&gt; keyIterator &#x3D; selectedKeys.iterator();            while (keyIterator.hasNext()) {                SelectionKey key &#x3D; keyIterator.next();                if (key.isAcceptable()) {                    &#x2F;&#x2F; 接受客户端连接                    SocketChannel client &#x3D; serverSocketChannel.accept();                    System.out.println(&quot;客户端已连接&quot;);                    client.configureBlocking(false);                    client.register(selector, SelectionKey.OP_READ);                    clientRef.set(client);                } else if (key.isReadable()) {                    &#x2F;&#x2F; 读取客户端消息                    SocketChannel channel &#x3D; (SocketChannel) key.channel();                    ByteBuffer buffer &#x3D; ByteBuffer.allocate(1024);                    int bytesRead &#x3D; channel.read(buffer);                    if (bytesRead &gt; 0) {                        buffer.flip();                        byte[] bytes &#x3D; new byte[buffer.remaining()];                        buffer.get(bytes);                        String message &#x3D; new String(bytes).trim();                        System.out.println(&quot;客户端消息: &quot; + message);                    }                }                keyIterator.remove();            }        }    }}
再来看客户端代码：
1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class Chat2Client {    public static void main(String[] args) throws IOException {        &#x2F;&#x2F; 创建一个 SocketChannel        SocketChannel socketChannel &#x3D; SocketChannel.open();        socketChannel.configureBlocking(false);        socketChannel.connect(new InetSocketAddress(&quot;localhost&quot;, 8080));        &#x2F;&#x2F; 创建一个 Selector        Selector selector &#x3D; Selector.open();        socketChannel.register(selector, SelectionKey.OP_CONNECT);        &#x2F;&#x2F; 从控制台读取输入并发送给服务器端        Thread sendMessageThread &#x3D; new Thread(() -&gt; {            try (BufferedReader reader &#x3D; new BufferedReader(new InputStreamReader(System.in))) {                while (true) {                    System.out.println(&quot;输入客户端消息: &quot;);                    String message &#x3D; reader.readLine();                    if (socketChannel.isConnected()) {                        ByteBuffer buffer &#x3D; ByteBuffer.wrap((message + &quot;\n&quot;).getBytes());                        socketChannel.write(buffer);                    }                }            } catch (IOException e) {                e.printStackTrace();            }        });        sendMessageThread.start();        while (true) {            int readyChannels &#x3D; selector.select();            if (readyChannels &#x3D;&#x3D; 0) {                continue;            }            Set&lt;SelectionKey&gt; selectedKeys &#x3D; selector.selectedKeys();            Iterator&lt;SelectionKey&gt; keyIterator &#x3D; selectedKeys.iterator();            while (keyIterator.hasNext()) {                SelectionKey key &#x3D; keyIterator.next();                if (key.isConnectable()) {                    &#x2F;&#x2F; 连接到服务器                    socketChannel.finishConnect();                    socketChannel.register(selector, SelectionKey.OP_READ);                    System.out.println(&quot;已连接到服务器&quot;);                } else if (key.isReadable()) {                    &#x2F;&#x2F; 读取服务器端消息                    ByteBuffer buffer &#x3D; ByteBuffer.allocate(1024);                    int bytesRead &#x3D; socketChannel.read(buffer);                    if (bytesRead &gt; 0) {                        buffer.flip();                        byte[] bytes &#x3D; new byte[buffer.remaining()];                        buffer.get(bytes);                        String message &#x3D; new String(bytes).trim();                        System.out.println(&quot;服务器端消息: &quot; + message);                    }                }                keyIterator.remove();            }        }    }}
运行 Server，再运行 Client，交互信息如下：

我们使用了 Selector 和非阻塞 I&#x2F;O，这使得服务器可以同时处理多个连接。所以我们在 Intellij IDEA 中可以再配置一个客户端，见下图（填上这四项内容）。

然后启动，就可以完成一个 Server 和多个 Client 交互了。

OK，关于聊天室，我们就先讲到这里。
小结 
前面我们了解到，Java NIO 在文件 IO 上的性能其实和传统 IO 差不多，甚至在处理大文件的时候还有些甘拜下风，但 NIO 的主要作用体现在网络 IO 上，像 Netty 框架底层其实就是 NIO，我们来做一下简单的总结吧。
SocketChannel（用于 TCP 连接）和 ServerSocketChannel（用于监听和接受新的 TCP 连接）可以用来替代传统的 Socket 和 ServerSocket 类，提供非阻塞模式。
NIO 支持阻塞和非阻塞模式。非阻塞模式允许程序在等待 I&#x2F;O 时执行其他任务，从而提高并发性能。非阻塞模式的实现依赖于 Selector，它可以监控多个通道上的 I&#x2F;O 事件。
NIO 支持将数据分散到多个 Buffer（Scatter）或从多个 Buffer 收集数据（Gather），提供了更高效的数据传输方式。
Java NIO.2 引入了 AsynchronousSocketChannel 和 AsynchronousServerSocketChannel，这些类提供了基于回调的异步 I&#x2F;O 操作。异步套接字通道可以在完成 I&#x2F;O 操作时自动触发回调函数，从而实现高效的异步处理。
最后，我们使用 NIO 实现了简单的聊天室功能。通过 ServerSocketChannel 和 SocketChannel 创建服务端和客户端，实现互相发送和接收消息。在处理多个客户端时，可以使用 Selector 来管理多个客户端连接，提高并发性能。
总之，Java NIO 网络编程实践提供了更高效、灵活且可扩展的 I&#x2F;O 处理方式，对于大型应用程序和高并发场景具有显著优势。
10.6 Java IO模型Java 的 IO 分为两大类，一类是传统的 IO（Blocking IO），一类是 NIO （New IO）。
传统的 IO 基于字节流和字符流，以阻塞式 IO 操作为主。常用的类有 FileInputStream、FileOutputStream、InputStreamReader、OutputStreamWriter 等。这些类在读写数据时，会导致执行线程阻塞，直到操作完成。
Java NIO 是 Java 1.4 版本引入的，基于通道（Channel）和缓冲区（Buffer）进行操作，采用非阻塞式 IO 操作，允许线程在等待 IO 时执行其他任务。常见的 NIO 类有 ByteBuffer、FileChannel、SocketChannel、ServerSocketChannel 等。
阻塞 IO 和非阻塞 IO 
那什么是阻塞式 IO，什么是非阻塞 IO 呢？
阻塞 I&#x2F;O（Blocking I&#x2F;O）：在这种模型中，I&#x2F;O 操作是阻塞的，即执行 I&#x2F;O 操作时，线程会被阻塞，直到操作完成。在阻塞 I&#x2F;O 模型中，每个连接都需要一个线程来处理。因此，对于大量并发连接的场景，阻塞 I&#x2F;O 模型的性能较差。

非阻塞 I&#x2F;O（Non-blocking I&#x2F;O）：在这种模型中，I&#x2F;O 操作不会阻塞线程。当数据尚未准备好时，I&#x2F;O 调用会立即返回。线程可以继续执行其他任务，然后在适当的时候再次尝试执行 I&#x2F;O 操作。非阻塞 I&#x2F;O 模型允许单个线程同时处理多个连接，但可能需要在应用程序级别进行复杂的调度和管理。

内核空间和用户空间 
在上面的两幅图中，涉及到了两个概念：内核空间和用户空间。我们之前在介绍非直接缓冲区的时候，有这样一副图片。

其中的非直接缓冲区（JVM）就是在用户空间中，内核缓冲区（OS）就是在内核空间上。
内核空间是操作系统内核的专用内存区域，用于存储内核代码、数据结构和运行内核级别的系统调用。内核空间具有较高的权限级别，能够直接访问硬件资源和底层系统服务。一般来说，内核空间是受到严格保护的，用户级别的程序不能直接访问内核空间，以确保操作系统的稳定性和安全性。
用户空间是为用户级别的应用程序和服务分配的内存区域。它包含了应用程序的代码、数据和运行时堆栈。用户空间与内核空间相对隔离，具有较低的权限级别，不能直接访问内核空间或硬件资源。应用程序需要通过系统调用与内核空间进行交互，请求操作系统提供的服务。
内核空间和用户空间的划分有助于操作系统实现内存保护和权限控制，确保系统运行的稳定性和安全性。当用户程序需要访问系统资源或执行特权操作时，它需要通过系统调用切换到内核空间，由内核代理执行相应的操作。这种设计可以防止恶意或错误的用户程序直接访问内核空间，从而破坏系统的稳定性和安全性。同时，这种划分也提高了操作系统的可扩展性，因为内核空间和用户空间可以独立地进行扩展和优化。

多路复用、信号驱动、异步 IO 
除了前面提到的阻塞 IO 和非阻塞 IO 模型，还有另外三种 IO 模型，分别是多路复用、信号驱动和异步 IO。
多路复用 
I&#x2F;O 多路复用（I&#x2F;O Multiplexing）模型使用操作系统提供的多路复用功能（如 select、poll、epoll 等），使得单个线程可以同时处理多个 I&#x2F;O 事件。当某个连接上的数据准备好时，操作系统会通知应用程序。这样，应用程序可以在一个线程中处理多个并发连接，而不需要为每个连接创建一个线程。

select 是 Unix 系统中最早的 I&#x2F;O 多路复用技术。它允许一个线程同时监视多个文件描述符（如套接字），并等待某个文件描述符上的 I&#x2F;O 事件（如可读、可写或异常）。select 的主要问题是性能受限，特别是在处理大量文件描述符时。这是因为它使用一个位掩码来表示文件描述符集，每次调用都需要传递这个掩码，并在内核和用户空间之间进行复制。
poll 是对 select 的改进。它使用一个文件描述符数组而不是位掩码来表示文件描述符集。这样可以避免 select 中的性能问题。然而，poll 仍然需要遍历整个文件描述符数组，以检查每个文件描述符的状态。因此，在处理大量文件描述符时，性能仍然受限。
epoll 是 Linux 中的一种高性能 I&#x2F;O 多路复用技术。它通过在内核中维护一个事件表来避免遍历文件描述符数组的性能问题。当某个文件描述符上的 I&#x2F;O 事件发生时，内核会将该事件添加到事件表中。应用程序可以使用 epoll_wait 函数来获取已准备好的 I&#x2F;O 事件，而无需遍历整个文件描述符集。这种方法大大提高了在大量并发连接下的性能。


在 Java NIO 中，I&#x2F;O 多路复用主要通过 Selector 类实现。Selector 能够监控多个 Channel（通道）上的 I&#x2F;O 事件，如连接、读取和写入。这使得一个线程可以处理多个并发连接，提高了程序的性能和可伸缩性。
以下是 Java NIO 中 I&#x2F;O 多路复用的应用：
①、首先，需要创建一个 Selector 对象。
1Selector selector &#x3D; Selector.open();
②、然后，需要将 Channel 注册到 Selector。每个 Channel 必须配置为非阻塞模式，才能与 Selector 一起使用。在注册 Channel 时，还需要指定感兴趣的 I&#x2F;O 事件，如 SelectionKey.OP_ACCEPT（接受连接）、SelectionKey.OP_READ（读取数据）等。
12345ServerSocketChannel serverChannel &#x3D; ServerSocketChannel.open();serverChannel.configureBlocking(false);serverChannel.bind(new InetSocketAddress(8080));&#x2F;&#x2F; 注册感兴趣的事件serverChannel.register(selector, SelectionKey.OP_ACCEPT);
③、接下来，使用 Selector 的 select() 方法等待 I&#x2F;O 事件。 select() 方法会阻塞，直到至少有一个 Channel 上的事件发生。当有事件发生时，可以通过调用 selectedKeys() 方法获取已准备好进行 I&#x2F;O 操作的 Channel 的 SelectionKey 集合。
1234567891011121314151617while (true) {    int readyChannels &#x3D; selector.select();    if (readyChannels &#x3D;&#x3D; 0) continue;    Set&lt;SelectionKey&gt; selectedKeys &#x3D; selector.selectedKeys();    Iterator&lt;SelectionKey&gt; keyIterator &#x3D; selectedKeys.iterator();    while (keyIterator.hasNext()) {        SelectionKey key &#x3D; keyIterator.next();        if (key.isAcceptable()) {            &#x2F;&#x2F; 处理接受连接事件        } else if (key.isReadable()) {            &#x2F;&#x2F; 处理读取数据事件        } else if (key.isWritable()) {            &#x2F;&#x2F; 处理写入数据事件        }        keyIterator.remove();    }}
④、最后，根据 SelectionKey 的状态，执行相应的 I&#x2F;O 操作。例如，如果 SelectionKey 表示 Channel 已准备好接受新的连接，可以调用 ServerSocketChannel 的 accept() 方法。如果 SelectionKey 表示 Channel 已准备好读取数据，可以从 SocketChannel 中读取数据。
123456if (key.isAcceptable()) {    SocketChannel socketChannel &#x3D; serverSocketChannel.accept();    socketChannel.configureBlocking(false);    socketChannel.register(selector, SelectionKey.OP_READ);    System.out.println(&quot;客户端连接上了: &quot; + socketChannel.getRemoteAddress());}
信号驱动 
信号驱动 I&#x2F;O（Signal-driven I&#x2F;O）模型中，应用程序可以向操作系统注册一个信号处理函数，当某个 I&#x2F;O 事件发生时，操作系统会发送一个信号通知应用程序。应用程序在收到信号后处理相应的 I&#x2F;O 事件。这种模型与非阻塞 I&#x2F;O 类似，也需要在应用程序级别进行事件管理和调度。

多路复用和信号驱动的差别主要在事件通知机制和引用场景上。
多路复用模型允许一个线程同时管理多个 I&#x2F;O 连接。这是通过使用特殊的系统调用（如 select、poll 和 epoll）实现的，它们能够监视多个文件描述符上的 I&#x2F;O 事件。当某个 I&#x2F;O 事件发生时，这些系统调用会返回，通知应用程序执行相应的 I&#x2F;O 操作。I&#x2F;O 多路复用模型适用于高并发、低延迟和高吞吐量的场景，因为它能够有效地减少线程数量和上下文切换开销。
信号驱动模型依赖于信号（如 SIGIO）来通知应用程序 I&#x2F;O 事件的发生。在这个模型中，应用程序首先设置文件描述符为信号驱动模式，并为相应的信号注册处理函数。当 I&#x2F;O 事件发生时，内核会发送一个信号给应用程序，触发信号处理函数的执行。然后，应用程序可以在信号处理函数中执行相应的 I&#x2F;O 操作。I&#x2F;O 信号驱动模型适用于低并发、低延迟和低吞吐量的场景，因为它需要为每个 I&#x2F;O 事件创建一个信号和信号处理函数。
Linux 的内核将所有外部设备都看做一个文件来操作，对一个文件的读写操作会调用内核提供的系统命令(api)，返回一个 file descriptor（fd，文件描述符）。而对一个Socket的读写也会有响应的描述符，称为 socket fd（Socket文件描述符），描述符就是一个数字，指向内核中的一个结构体（文件路径，数据区等一些属性）。
在Linux下对文件的操作是利用文件描述符(file descriptor)来实现的。
异步 IO 
异步 I&#x2F;O（Asynchronous I&#x2F;O）模型与同步 I&#x2F;O 模型的主要区别在于，异步 I&#x2F;O 操作会在后台运行，当操作完成时，操作系统会通知应用程序。应用程序不需要等待 I&#x2F;O 操作的完成，可以继续执行其他任务。这种模型适用于处理大量并发连接，且可以简化应用程序的设计和开发。

同步：在执行 I&#x2F;O 操作时，应用程序需要等待操作的完成。同步操作会导致线程阻塞，直到操作完成。同步 I&#x2F;O 包括阻塞 I&#x2F;O、非阻塞 I&#x2F;O 和 I&#x2F;O 多路复用。
异步：在执行 I&#x2F;O 操作时，应用程序不需要等待操作的完成。异步操作允许应用程序在 I&#x2F;O 操作进行时继续执行其他任务。异步 I&#x2F;O 模型包括信号驱动 I&#x2F;O 和异步 I&#x2F;O。


假设你现在是个大厨（炖个老母鸡汤，切点土豆丝&#x2F;姜丝&#x2F;葱丝）：

同步&#x2F;阻塞：你站在锅边，一直等到汤炖好，期间不能做其他事情，直到汤炖好才去处理其他任务。
同步&#x2F;非阻塞：你不断地查看锅里的汤，看是否炖好。在检查的间隙，你可以处理其他任务，如切菜。但你需要不断地切换任务，确保汤炖好了就可以处理。
异步&#x2F;信号驱动：你给锅安装一个传感器，当汤炖好时，传感器会发出信号提醒你。在此期间，你可以处理其他任务，而不用担心错过汤炖好的时机。
异步 I&#x2F;O：你请了一个助手，让他负责炖汤。当汤炖好时，助手会通知你。你可以专心处理其他任务，而无需关心炖汤的过程。

小结 
简单总结一下，IO 模型主要有五种：阻塞 I&#x2F;O、非阻塞 I&#x2F;O、多路复用、信号驱动和异步 I&#x2F;O。

阻塞 I&#x2F;O：应用程序执行 I&#x2F;O 操作时，会一直等待数据传输完成，期间无法执行其他任务。
非阻塞 I&#x2F;O：应用程序执行 I&#x2F;O 操作时，如果数据未准备好，立即返回错误状态，不等待数据传输完成，可执行其他任务。
多路复用：允许一个线程同时管理多个 I&#x2F;O 连接，适用于高并发、低延迟和高吞吐量场景，减少线程数量和上下文切换开销。
信号驱动：依赖信号通知应用程序 I&#x2F;O 事件，适用于低并发、低延迟和低吞吐量场景，需要为每个 I&#x2F;O 事件创建信号和信号处理函数。
异步 I&#x2F;O：应用程序发起 I&#x2F;O 操作后，内核负责数据传输过程，完成后通知应用程序。应用程序无需等待数据传输，可执行其他任务。

11 Java 重要知识点11.1 Java命名规范“二哥，Java 中的命名约定都有哪些呢？”三妹的脸上泛着甜甜的笑容，她开始对接下来要学习的内容充满期待了，这正是我感到欣慰的地方。
“对于我们中国人来说，名字也是有讲究的，比如说我叫沉默王二，你就叫沉默王三，哈哈。”我笑着对三妹说。
命名约定决定我们使用什么样的标识符来命名包、类、字段、方法等等，虽然这个规则不是强制的，可以遵守，也可以不遵守，但如果不遵守的话，就会带来很多不必要的麻烦。
起个好的名字，就好像穿一件得体的衣服，呈现给人的用户体验是完全不一样的。 
好的命名可以让你的代码更易读，包括你自己和你的小伙伴，看一眼，不用想太多，就能明白代码是干嘛的。
拿我这个笔名“沉默王二”来举例吧，读起来我就觉得朗朗上口，读者看到这个笔名就知道我是一个什么样的人——对不熟的人保持沉默，对熟的人妙语连珠，哈哈。

当然了，如果你暂时记不住也没关系，后面再回头来记一下就好了。

01、包（package） 
包的命名应该遵守以下规则：

应该全部是小写字母
点分隔符之间有且仅有一个自然语义的英语单词
包名统一使用单数形式，比如说 com.itwanger.util 不能是 com.itwanger.utils
在最新的 Java 编程规范中，要求开发人员在自己定义的包名前加上唯一的前缀。由于互联网上的域名是不会重复的，所以多数开发人员采用自己公司（或者个人博客）在互联网上的域名称作为包的唯一前缀。比如我文章中出现的代码示例的包名就是 package com.itwanger 。

02、类（class） 
类的命名应该遵守以下规则：

必须以大写字母开头
最好是一个名词，比如说 System
类名使用 UpperCamelCase（驼峰式命名）风格
尽量不要省略成单词的首字母，但以下情形例外：DO&#x2F;BO&#x2F;DTO&#x2F;VO&#x2F;AO&#x2F;PO&#x2F;UID 等


另外，如果是抽象类的话，使用 Abstract 或 Base 开头；如果是异常类的话，使用 Exception 结尾；如果是测试类的话，使用 Test 结尾。
03、接口（interface） 
接口的命名应该遵守以下规则：

必须以大写字母开头
最好是一个形容词，比如说 Runnable
尽量不要省略成单词的首字母

来看个例子：
1interface Printable {}
接口和实现类之间也有一些规则：

实现类用 Impl 的后缀与接口区别，比如说 CacheServiceImpl 实现 CacheService 接口
或者，AbstractTranslator 实现 Translatable 接口

04、字段（field）和变量（variable） 
字段和变量的命名应该遵守以下规则：

必须以小写字母开头
可以包含多个单词，第一个单词的首字母小写，其他的单词首字母大写，比如说 firstName
最好不要使用单个字符，比如说 int a ，除非是局部变量
类型与中括号紧挨相连来表示数组，比如说 int[] arrayDemo ，main 方法中字符串数组参数不应该写成 String args[]
POJO 类中的任何布尔类型的变量，都不要加 is 前缀，否则部分框架解析会引起序列化错误，我自己知道的有 fastjson
避免在子类和父类的成员变量之间、或者不同代码块的局部变量之间采用完全相同的命名，使可理解性降低。子类、父类成员变量名相同，即使是 public 类型的变量也能够通过编译，另外，局部变量在同一方法内的不同代码块中同名也是合法的，这些情况都要避免。

反例：
1234567891011121314151617public class ConfusingName {    public int stock;    &#x2F;&#x2F; 非 setter&#x2F;getter 的参数名称，不允许与本类成员变量同名    public void get(String alibaba) {        if (condition) {            final int money &#x3D; 666;&#x2F;&#x2F; ...        }        for (int i &#x3D; 0; i &lt; 10; i++) {&#x2F;&#x2F; 在同一方法体中，不允许与其它代码块中的 money 命名相同 final int money &#x3D; 15978;&#x2F;&#x2F; ...        }    }}class Son extends ConfusingName {&#x2F;&#x2F; 不允许与父类的成员变量名称相同 public int stock;}
05、常量（constant） 
常量的命名应该遵守以下规则：

应该全部是大写字母
可以包含多个单词，单词之间使用“_”连接，比如说 MAX_PRIORITY ，力求语义表达完整清楚，不要嫌名字长
可以包含数字，但不能以数字开头

来看个例子：
1static final int MIN_AGE &#x3D; 18; 
06、方法（method） 
方法的命名应该遵守以下规则：

必须以小写字母开头
最好是一个动词，比如说 print()
可以包含多个单词，第一个单词的首字母小写，其他的单词首字母大写，比如说 actionPerformed()

来看个例子：
1void writeBook(){}
Service&#x2F;DAO 层的方法命名规约：

获取单个对象的方法用 get 做前缀
获取多个对象的方法用 list 做前缀，复数结尾，如：listObjects
获取统计值的方法用 count 做前缀
插入的方法用 save&#x2F;insert 做前缀
删除的方法用 remove&#x2F;delete 做前缀
修改的方法用 update 做前缀

07、总结 
除了以上这些规则以外，还有一些共同的规则需要遵守，比如说：

代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。反例： _name &#x2F; __name &#x2F; $name &#x2F; name &#x2F; name$ &#x2F; name_
所有编程相关的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。反例：DaZhePromotion [打折] &#x2F; getPingfenByName() [评分] &#x2F; String fw[福娃] &#x2F; int 某变量 &#x3D; 3
代码和注释中都要避免使用任何语言的种族歧视性词语。反例： RIBENGUIZI &#x2F; Asan &#x2F; blackList &#x2F; whiteList &#x2F; slave
方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格。
杜绝完全不规范的缩写，避免望文不知义。反例：AbstractClass “缩写”成 AbsClass；condition “缩写”成 condi；Function 缩写”成 Fu，此类随意缩写严重降低了代码的可阅读性。
为了达到代码自解释的目标，任何自定义编程元素在命名时，使用尽量完整的单词组合来表达。
在常量与变量的命名时，表示类型的名词放在词尾，以提升辨识度。正例： startTime &#x2F; workQueue &#x2F; nameList &#x2F; TERMINATED_THREAD_COUNT
如果模块、接口、类、方法使用了设计模式，在命名时需体现出具体模式。 将设计模式体现在名中，有利于阅读者快速理解架构设计理念。比如说： public class OrderFactory;public class LoginProxy;public class ResourceObserver;
枚举类名带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。枚举其实就是特殊的常量类，且构造方法被默认强制是私有。比如说：枚举名字为 ProcessStatusEnum 的成员名称：SUCCESS &#x2F; UNKNOWN_REASON 。

11.2 中文乱码及字符编码全攻略就在昨天，我在二哥的编程星球里看到这样一张截图，有球友反馈说支付宝的理财页面出现了中文乱码，估计不少小伙伴和我一样，都惊呆了 ！阿里这种大厂还能出现这种低级错误？

难道昨天的人力都投入到“通义千问”的突然发布上了？
那借这个机会，我就来和大家探讨一下，中文乱码是怎么出现的，以及如何快速解决乱码问题。
什么是中文乱码 
Q：什么是中文乱码？
GPT4：中文乱码是指在计算机系统或软件中，由于字符编码不一致或处理不当，导致中文字符无法正常显示，出现乱码现象。这种现象通常表现为中文字符被替换成其他不相关的字符、符号或乱码。
比如说，历史上著名的“锟斤拷”同学，就是中文乱码的绝佳代言人。

什么是字符编码 
Q：那什么是字符编码呢？
GPT4：字符编码（Character Encoding）是一种规则或约定，它将字符（如字母、数字、标点符号等）映射到计算机中的二进制数据。简单来说，字符编码就是将人类可读的字符转换为计算机可以处理的二进制数据的过程。
对于计算机来说，只认 0 和 1，所有的信息最终都是一个二进制数。一个二进制数要么是 0，要么是 1。8 个二进制数放在一起是一个字节，就会组合出 256 种状态，也就是 2 的 8 次方（ 2^8 ），从 00000000 到 11111111。
为了让计算机能够识别和处理各种字符，需要使用字符编码来对字符进行编码和解码。常见的字符编码包括 ASCII、UTF-8、UTF-16、GBK、GB2312 等。

1）ASCII 
ASCII 码由电报码发展而来，第一版标准发布于 1963 年，最后一次更新则是在 1986 年，至今为止共定义了 128 个字符。其中 33 个字符无法显示在一般的设备上，需要用特殊的设备才能显示。
ASCII 码的局限在于只能显示 26 个基本拉丁字母、阿拉伯数字和英式标点符号，因此只能用于显示现代美国英语，对于其他一些语言则无能无力，比如在法语中，字母上方有注音符号，它就无法用 ASCII 码表示。

PS：拉丁字母（也称为罗马字母）是多数欧洲语言采用的字母系统，是世界上最通行的字母文字系统，是罗马文明的成果之一。
虽然名称上叫作拉丁字母，但拉丁文中并没有用 J、U 和 W 这三个字母。
在我的印象中，可能说拉丁字母多少有些陌生，说英语字母可能就有直观的印象了。

阿拉伯数字，我们都很熟悉了。

但是，阿拉伯数字并非起源于阿拉伯，而是起源于古印度。学过历史的你应该有一些印象，阿拉伯分布于西亚和北非，以阿拉伯语为主要语言，以伊斯兰教为主要信仰。

处在这样的地理位置，做起东亚和欧洲的一些生意就很有优势，于是阿拉伯数字就由阿拉伯人传到了欧洲，因此得名。
英式标点符号，也叫英文标点符号，和中文标点符号很相近。标点符号是辅助文字记录语言的符号，是书面语的组成部分，用来表示停顿、加强语气等。
英文标点符号在 16 世纪时，分为朗诵学派和句法学派，主要由古典时期的希腊文和拉丁文演变而来，在 17 世纪后进入稳定阶段。俄文的标点符号依据希腊文而来，到了 18 世纪后也采用了英文标点符号。
在很多人的印象中，古文是没有标点符号的，但管锡华博士研究指出，中国早在先秦时代就有标点符号了，后来融合了一些英文标点符号后，逐渐形成了现在的中文标点符号。

2）Unicode 
这个世界上，除了英语，还有法语、葡萄牙语、西班牙语、德语、俄语、阿拉伯语、韩语、日语等等等等。ASCII 码用来表示英语是绰绰有余的，但其他这些语言就没办法了。
像我的主人二哥的母语——中文，就博大精深，与其对应的汉字数量很多很多，东汉的《说文解字》收字 9353 个，清朝《康熙字典》收字 47035 个，当代的《汉语大字典》收字 60370 个。1994 年中华书局、中国友谊出版公司出版的《中华字海》收字 85568 个。

常用字大概 2500 个，次常用字 1000 个。

一个字节只能表示 256 种符号，所以如果拿 ASCII 码来表示汉字的话，是远远不够用的，那就必须要用更多的字节。简体中文常见的编码方式是 GB2312，使用两个字节表示一个汉字，理论上最多可以表示 256 x 256 &#x3D; 65536 个符号。
要知道，世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。

编码就是将原始数据（比如说文本、图像、视频、音频等）转换为二进制形式。
解码就是将二进制数据转换为原始数据，是一个反向的过程。

如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会彻底消失。
这个艰巨的任务由谁来完成呢？Unicode，中文译作万国码、国际码、统一码、单一码，就像它的名字都表示的，这是一种所有符号的编码。
Unicode 至今仍在不断增修，每个新版本都会加入更多新的字符。目前最新的版本为 2020 年 3 月公布的 13.0，收录了 13 万个字符。

Unicode 是一个很大的集合，现在的规模可以容纳 100 多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母 Ain ， U+0041 表示英语的大写字母 A ， U+4E25 表示汉字严 。
具体的符号对应表，可以查询：

unicode.org：http:&#x2F;&#x2F;www.unicode.org
汉字对应表：ttp:&#x2F;&#x2F;www.chi2ko.com&#x2F;tool&#x2F;CJK.htm

曾有人这样说：

Unicode 支持的字符上限是 65536 个，Unicode 字符必须占两个字节。

但这是一种误解，记住，Unicode 只是一个用来映射字符和数字的标准。它对支持字符的数量没有限制，也不要求字符必须占两个、三个或者其它任意数量的字节，所以它可以无穷大。
3）UTF-8 
Unicode 虽然统一了全世界字符的编码，但没有规定如何存储。如果统一规定的话，每个符号就要用 3 个或 4 个字节表示，因为 2 个字节只能表示 65536 个，根本表示不全。
那怎么办呢？
UTF（Unicode Transformation Formats，Unicode 的编码方式）来了！最常见的就是 UTF-8 和 UTF-16。
在 UTF-8 中，0-127 号的字符用 1 个字节来表示，使用和 ASCII 相同的编码。只有 128 号及以上的字符才用 2 个、3 个或者 4 个字节来表示。
如果只有一个字节，那么最高的比特位为 0；如果有多个字节，那么第一个字节从最高位开始，连续有几个比特位的值为 1，就使用几个字节编码，剩下的字节均以 10 开头。
具体的表现形式为：

0xxxxxxx：一个字节；
110xxxxx 10xxxxxx：两个字节编码形式（开始两个 1）；
1110xxxx 10xxxxxx 10xxxxxx：三字节编码形式（开始三个 1）；
11110xxx 10xxxxxx 10xxxxxx 10xxxxxx：四字节编码形式（开始四个 1）。

也就是说，UTF-8 是一种可变长度的编码方式——这是它的优势也是劣势。
怎么讲呢？优势就是它包罗万象，劣势就是浪费空间。举例来说吧，UTF-8 采用了 3 个字节（ 256*256*256&#x3D;16777216 ）来编码常用的汉字，但常用的汉字没有这么多，这对于计算机来说，就是一种严重的资源浪费。
4）GB2312 
基于这样的考虑，中国国家标准总局于 1980 年发布了 GB2312 编码，即中华人民共和国国家标准简体中文字符集。GB2312 标准共收录 6763 个汉字（2 个字节就够用了），其中一级汉字 3755 个，二级汉字 3008 个；同时收录了包括拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母在内的 682 个字符。
GB2312 的出现，基本满足了汉字的计算机处理需求。对于人名、古汉语等方面出现的罕用字和繁体字，GB2312 不能处理，就有了 GBK（K 为“扩展”的汉语拼音（kuòzhǎn）第一个声母）。
中文乱码是如何出现的？ 
Q：来一串出现中文乱码的 demo，中文为沉默王二
GPT4：下面是一个可能导致中文乱码的示例。首先使用 GBK 编码将中文字符串 “沉默王二” 转换为字节数组，然后使用 UTF-8 编码将字节数组转回字符串。这将导致字符串在解码时出现乱码。
1234567891011121314public class EncodingDemo {    public static void main(String[] args) {        String originalStr &#x3D; &quot;沉默王二&quot;;        String encodedStr &#x3D; &quot;&quot;;        try {            byte[] bytes &#x3D; originalStr.getBytes(&quot;GBK&quot;);            encodedStr &#x3D; new String(bytes, &quot;UTF-8&quot;);        } catch (UnsupportedEncodingException e) {            e.printStackTrace();        }        System.out.println(&quot;转码前: &quot; + originalStr);        System.out.println(&quot;转码后: &quot; + encodedStr);    }}
程序会输出什么呢？
12转码前: 沉默王二转码后: ��Ĭ����
嘿嘿，乱码来了！在 Unicode 中，� 是一个特殊的符号，它用来表示无法显示，它的十六进制是 0xEF 0xBF 0xBD 。那么两个 �� 就是 0xEF 0xBF 0xBD 0xEF 0xBF 0xBD ，如果用 GBK 进行解码的话，就是大名鼎鼎的“锟斤拷”。
可以通过代码来验证一下：
123456789&#x2F;&#x2F; 输出 efbfbdefbfbdchar[] kuijinkao &#x3D; HexUtil.encodeHex(&quot;��&quot;, StandardCharsets.UTF_8);System.out.println(kuijinkao);&#x2F;&#x2F; 借助 hutool 转成二进制byte[] testBytes &#x3D; HexUtil.decodeHex(kuijinkao);&#x2F;&#x2F; 使用 GBK 解码String testResult &#x3D; new String(testBytes, Charset.forName(&quot;GBK&quot;));&#x2F;&#x2F; 输出锟斤拷System.out.println(testResult);
来看一下输出结果：
12efbfbdefbfbd锟斤拷
所以，以后再见到锟斤拷，第一时间想到 UTF-8 和 GBK 的转换问题准没错。
如何解决中文乱码呢？ 
Q：如何解决中文乱码呢？
GPT4：解决中文乱码问题需要确保在编码和解码过程中使用相同的字符编码。这是一个修改过的示例，展示了如何避免中文乱码问题：
12345String originalStr &#x3D; &quot;沉默王二&quot;;byte[] bytes &#x3D; originalStr.getBytes(StandardCharsets.UTF_8);String encodedStr &#x3D; new String(bytes, StandardCharsets.UTF_8);System.out.println(&quot;正确转码前: &quot; + originalStr);System.out.println(&quot;正确转码后: &quot; + encodedStr);
输出结果：
12正确转码前: 沉默王二正确转码后: 沉默王二
除此之外，以下是一些避免乱码的实践：

使用统一的字符编码，如 UTF-8。它包含了所有 Unicode 字符，并且广泛支持。确保在所有平台和系统上使用相同的编码。
在处理文本文件时，始终明确指定字符编码。例如，在 Java 中使用 InputStreamReader、OutputStreamWriter 时，指定编码参数。
在 HTML、XML 等文档中，指定字符编码。例如，在 HTML 页面中添加  。
对于数据库，确保使用正确的字符集。在创建数据库和表时，明确指定字符集，如 utf8mb4。

当与第三方服务通信时，确保双方使用相同的字符编码。在处理 API 请求和响应时，检查字符编码是否匹配。
Q：针对支付宝这种生产环境事故，如何快速定位并解决问题呢？
GPT4：
1、收集信息：了解问题的具体表现，例如哪些页面或功能受到影响，问题的严重程度，以及用户反馈。这将有助于快速定位问题范围。
2、检查日志：查看服务器日志和应用程序日志，检查是否存在异常信息或错误。日志信息有助于识别问题发生的时间和具体原因。
3、复现问题：在测试环境中尝试复现问题，以便更深入地了解问题细节。如果无法复现问题，可能需要进一步收集生产环境的详细信息。
4、定位问题：根据收集到的信息，确定问题可能发生的代码或系统部分。检查相关代码，特别是涉及字符编码、数据传输、数据库操作的部分。
5、解决问题：修复问题代码，确保字符编码在整个系统中保持一致。进行单元测试和集成测试，验证问题是否已解决。
6、部署修复：将修复后的代码部署到生产环境。为了避免影响正常服务，可以考虑先在一个小规模的生产环境中进行验证，然后逐步扩大部署范围。
7、监控：在修复后持续关注系统运行状况，确保问题已得到解决。收集用户反馈，确认用户满意度。
8、总结经验：针对此次问题，总结经验教训，分析问题产生的根本原因，优化开发和测试流程，避免类似问题再次发生。
11.3 深入剖析Java中的拆箱和装箱“哥，听说 Java 的每个基本类型都对应了一个包装类型，比如说 int 的包装类型为 Integer，double 的包装类型为 Double，是这样吗？”从三妹这句话当中，能听得出来，她已经提前预习这块内容了。
“是的，三妹。基本类型和包装类型的区别主要有以下 4 点，我来带你学习一下。”我回答说。我们家的斜对面刚好是一所小学，所以时不时还能听到朗朗的读书声，让人心情非常愉快。
“三妹，你准备好了吗？我们开始吧。”
“第一，包装类型可以为 null，而基本类型不可以。别小看这一点区别，它使得包装类型可以应用于 POJO 中，而基本类型则不行。”
“POJO 是什么呢？”遇到不会的就问，三妹在这一点上还是非常兢兢业业的。
“POJO 的英文全称是 Plain Ordinary Java Object，翻译一下就是，简单无规则的 Java 对象，只有字段以及对应的 setter 和 getter 方法。”
12345678910111213141516class Writer {    private Integer age;    private String name;    public Integer getAge() {        return age;    }    public void setAge(Integer age) {        this.age &#x3D; age;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name &#x3D; name;    }}
和 POJO 类似的，还有数据传输对象 DTO（Data Transfer Object，泛指用于展示层与服务层之间的数据传输对象）、视图对象 VO（View Object，把某个页面的数据封装起来）、持久化对象 PO（Persistant Object，可以看成是与数据库中的表映射的 Java 对象）。“那为什么 POJO 的字段必须要用包装类型呢？”三妹问。
“《阿里巴巴 Java 开发手册》上有详细的说明，你看。”我打开 PDF，并翻到了对应的内容，指着屏幕念道。

数据库的查询结果可能是 null，如果使用基本类型的话，因为要自动拆箱，就会抛出 NullPointerException 的异常。

“什么是自动拆箱呢？”
“自动拆箱指的是，将包装类型转为基本类型，比如说把 Integer 对象转换成 int 值；对应的，把基本类型转为包装类型，则称为自动装箱。”
“哦。”
“那接下来，我们来看第二点不同。包装类型可用于泛型，而基本类型不可以，否则就会出现编译错误。”一边说着，我一边在 Intellij IDEA 中噼里啪啦地敲了起来。
“三妹，你瞧，编译器提示错误了。”
123List&lt;int&gt; list &#x3D; new ArrayList&lt;&gt;(); &#x2F;&#x2F; 提示 Syntax error, insert &quot;Dimensions&quot; to complete ReferenceTypeList&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();
“为什么呢？”三妹及时地问道。
“因为泛型在编译时会进行类型擦除，最后只保留原始类型，而原始类型只能是 Object 类及其子类——基本类型是个例外。”
“那，接下来，我们来说第三点，基本类型比包装类型更高效。”我喝了一口茶继续说道。
“作为局部变量时，基本类型在栈中直接存储的具体数值，而包装类型则存储的是堆中的引用。”我一边说着，一边打开 draw.io 画起了图。

很显然，相比较于基本类型而言，包装类型需要占用更多的内存空间，不仅要存储对象，还要存储引用。假如没有基本类型的话，对于数值这类经常使用到的数据来说，每次都要通过 new 一个包装类型就显得非常笨重。
“三妹，你想知道程序运行时，数据都存储在什么地方吗？”
“嗯嗯，哥，你说说呗。”
“通常来说，有 4 个地方可以用来存储数据。”
1）寄存器。这是最快的存储区，因为它位于 CPU 内部，用来暂时存放参与运算的数据和运算结果。
2）栈。位于 RAM（Random Access Memory，也叫主存，与 CPU 直接交换数据的内部存储器）中，速度仅次于寄存器。但是，在分配内存的时候，存放在栈中的数据大小与生存周期必须在编译时是确定的，缺乏灵活性。基本数据类型的值和对象的引用通常存储在这块域。
3）堆。也位于 RAM 区，可以动态分配内存大小，编译器不必知道要从堆里分配多少存储空间，生存周期也不必事先告诉编译器，Java 的垃圾收集器会自动收走不再使用的数据，因此可以得到更大的灵活性。但是，运行时动态分配内存和销毁对象都需要占用时间，所以效率比栈低一些。new 创建的对象都会存储在这块区域。
4）磁盘。如果数据完全存储在程序之外，就可以不受程序的限制，在程序没有运行时也可以存在。像文件、数据库，就是通过持久化的方式，让对象存放在磁盘上。当需要的时候，再反序列化成程序可以识别的对象。
“能明白吗？三妹？”
“这节讲完后，我再好好消化一下。”
“那好，我们来说第四点，两个包装类型的值可以相同，但却不相等。”
1234Integer chenmo &#x3D; new Integer(10);Integer wanger &#x3D; new Integer(10);System.out.println(chenmo &#x3D;&#x3D; wanger); &#x2F;&#x2F; falseSystem.out.println(chenmo.equals(wanger )); &#x2F;&#x2F; true
“两个包装类型在使用“\&#x3D;&#x3D;”进行判断的时候，判断的是其指向的地址是否相等，由于是两个对象，所以地址是不同的。”
“而 chenmo.equals(wanger) 的输出结果为 true，是因为 equals() 方法内部比较的是两个 int 值是否相等。”
12345678910private final int value;public int intValue() {    return value;}public boolean equals(Object obj) {    if (obj instanceof Integer) {        return value &#x3D;&#x3D; ((Integer)obj).intValue();    }    return false;}
虽然 chenmo 和 wanger 的值都是 10，但他们并不相等。换句话说就是：将“\&#x3D;&#x3D;”操作符应用于包装类型比较的时候，其结果很可能会和预期的不符。
“三妹，瞧， ((Integer)obj).intValue() 这段代码就是用来自动拆箱的。下面，我们来详细地说一说自动装箱和自动拆箱。”
既然有基本类型和包装类型，肯定有些时候要在它们之间进行转换。把基本类型转换成包装类型的过程叫做装箱（boxing）。反之，把包装类型转换成基本类型的过程叫做拆箱（unboxing）。
在 Java 1.5 之前，开发人员要手动进行装拆箱，比如说：
12Integer chenmo &#x3D; new Integer(10); &#x2F;&#x2F; 手动装箱int wanger &#x3D; chenmo.intValue();  &#x2F;&#x2F; 手动拆箱
Java 1.5 为了减少开发人员的工作，提供了自动装箱与自动拆箱的功能。这下就方便了。
12Integer chenmo  &#x3D; 10;  &#x2F;&#x2F; 自动装箱int wanger &#x3D; chenmo;     &#x2F;&#x2F; 自动拆箱
来看一下反编译后的代码。
12Integer chenmo &#x3D; Integer.valueOf(10);int wanger &#x3D; chenmo.intValue();
也就是说，自动装箱是通过 Integer.valueOf() 完成的；自动拆箱是通过 Integer.intValue() 完成的。
“嗯，三妹，给你出一道面试题吧。”
123456789101112&#x2F; 1）基本类型和包装类型int a &#x3D; 100;Integer b &#x3D; 100;System.out.println(a &#x3D;&#x3D; b);&#x2F;&#x2F; 2）两个包装类型Integer c &#x3D; 100;Integer d &#x3D; 100;System.out.println(c &#x3D;&#x3D; d);&#x2F;&#x2F; 3）c &#x3D; 200;d &#x3D; 200;System.out.println(c &#x3D;&#x3D; d);
“给你 3 分钟时间，你先思考下，等我回来，然后再来分析一下为什么。”
。。。。。。
“嗯，哥，你过来吧，我说一说我的想法。”
第一段代码，基本类型和包装类型进行 &#x3D;&#x3D; 比较，这时候 b 会自动拆箱，直接和 a 比较值，所以结果为 true。
第二段代码，两个包装类型都被赋值为了 100，这时候会进行自动装箱，按照你之前说的，将“&#x3D;&#x3D;”操作符应用于包装类型比较的时候，其结果很可能会和预期的不符，我想结果可能为 false。
第三段代码，两个包装类型重新被赋值为了 200，这时候仍然会进行自动装箱，我想结果仍然为 false。
“嗯嗯，三妹，你分析的很有逻辑，但第二段代码的结果为 true，是不是感到很奇怪？”
“为什么会这样呀？”三妹急切地问。
“你说的没错，自动装箱是通过 Integer.valueOf() 完成的，我们来看看这个方法的源码就明白为什么了。”
12345public static Integer valueOf(int i) {    if (i &gt;&#x3D; IntegerCache.low &amp;&amp; i &lt;&#x3D; IntegerCache.high)        return IntegerCache.cache[i + (-IntegerCache.low)];    return new Integer(i);}
是不是看到了一个之前从来没见过的类——IntegerCache？
“难道说是 Integer 的缓存类？”三妹做出了自己的判断。
“是的，来看一下 IntegerCache 的源码吧。”
12345678910111213141516171819private static class IntegerCache {    static final int low &#x3D; -128;    static final int high;    static final Integer cache[];    static {        &#x2F;&#x2F; high value may be configured by property        int h &#x3D; 127;        int i &#x3D; parseInt(integerCacheHighPropValue);        i &#x3D; Math.max(i, 127);        h &#x3D; Math.min(i, Integer.MAX_VALUE - (-low) -1);        high &#x3D; h;        cache &#x3D; new Integer[(high - low) + 1];        int j &#x3D; low;        for(int k &#x3D; 0; k &lt; cache.length; k++)            cache[k] &#x3D; new Integer(j++);        &#x2F;&#x2F; range [-128, 127] must be interned (JLS7 5.1.7)        assert IntegerCache.high &gt;&#x3D; 127;    }}
大致瞟一下这段代码你就全明白了。-128 到 127 之间的数会从 IntegerCache 中取，然后比较，所以第二段代码（100 在这个范围之内）的结果是 true，而第三段代码（200 不在这个范围之内，所以 new 出来了两个 Integer 对象）的结果是 false。
“三妹，看完上面的分析之后，我希望你记住一点：当需要进行自动装箱时，如果数字在 -128 至 127 之间时，会直接使用缓存中的对象，而不是重新创建一个对象。”
“自动装拆箱是一个很好的功能，大大节省了我们开发人员的精力，但也会引发一些麻烦，比如下面这段代码，性能就很差。”
1234567long t1 &#x3D; System.currentTimeMillis();Long sum &#x3D; 0L;for (int i &#x3D; 0; i &lt; Integer.MAX_VALUE;i++) {    sum +&#x3D; i;}long t2 &#x3D; System.currentTimeMillis();        System.out.println(t2-t1);
“知道为什么吗？三妹。”
“难道是因为 sum 被声明成了包装类型 Long 而不是基本类型 long。”三妹若有所思。
“是滴，由于 sum 是个 Long 型，而 i 为 int 类型， sum +&#x3D; i 在执行的时候，会先把 i 强转为 long 型，然后再把 sum 拆箱为 long 型进行相加操作，之后再自动装箱为 Long 型赋值给 sum。”
“三妹，你可以试一下，把 sum 换成 long 型比较一下它们运行的时间。”
。。。。。。
“哇，sum 为 Long 型的时候，足足运行了 5825 毫秒；sum 为 long 型的时候，只需要 679 毫秒。”
11.4 深入理解Java浅拷贝与深拷贝“哥，听说浅拷贝和深拷贝是 Java 面试中经常会被问到的一个问题，是这样吗？”
“还真的是，而且了解浅拷贝和深拷贝的原理，对 Java 是值传递还是引用传递也会有更深的理解。”我肯定地回答。
“不管是浅拷贝还是深拷贝，都可以通过调用 Object 类的 clone() 方法来完成。”我一边说，一边打开 Intellij IDEA，并找到了 clone() 方法的源码。
1protected native Object clone() throws CloneNotSupportedException;
需要注意的是， clone() 方法同时是一个本地（ native ）方法，它的具体实现会交给 HotSpot 虚拟机，那就意味着虚拟机在运行该方法的时候，会将其替换为更高效的 C&#x2F;C++ 代码，进而调用操作系统去完成对象的克隆工作。

Java 9 后，该方法会被标注 @HotSpotIntrinsicCandidate 注解，被该注解标注的方法，在 HotSpot 虚拟机中会有一套高效的实现。

“哥，那你就先说浅拷贝吧！”
“好的呀。直接上实战代码。”
123456789101112class Writer implements Cloneable{    private int age;    private String name;    &#x2F;&#x2F; getter&#x2F;setter 和构造方法都已省略    @Override    public String toString() {        return super.toString().substring(26) + &quot;{&quot; +                &quot;age&#x3D;&quot; + age +                &quot;, name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +                &#39;}&#39;;    }}
Writer 类有两个字段，分别是 int 类型的 age，和 String 类型的 name。然后重写了 toString() 方法，方便打印对象的具体信息。
“为什么要实现 Cloneable 接口呢？”三妹开启了十万个为什么的模式。
Cloneable 接口是一个标记接口，它肚子里面是空的：
12public interface Cloneable {}
只是，如果一个类没有实现 Cloneable 接口，即便它重写了 clone() 方法，依然是无法调用该方法进行对象克隆的，程序在执行 clone() 方法的时候会抛出 CloneNotSupportedException 异常。
标记接口的作用其实很简单，用来表示某个功能在执行的时候是合法的。
“哦，我悟了！”三妹看来是彻底明白了我说的内容。
“接着，来测试类。”
12345678910111213class TestClone {    public static void main(String[] args) throws CloneNotSupportedException {        Writer writer1 &#x3D; new Writer(18,&quot;二哥&quot;);        Writer writer2 &#x3D; (Writer) writer1.clone();        System.out.println(&quot;浅拷贝后：&quot;);        System.out.println(&quot;writer1：&quot; + writer1);        System.out.println(&quot;writer2：&quot; + writer2);        writer2.setName(&quot;三妹&quot;);        System.out.println(&quot;调整了 writer2 的 name 后：&quot;);        System.out.println(&quot;writer1：&quot; + writer1);        System.out.println(&quot;writer2：&quot; + writer2);    }}

通过 new 关键字声明了一个 Writer 对象（18 岁的二哥），将其赋值给 writer1。
通过调用 clone() 方法进行对象拷贝，并将其赋值给 writer2。
之后打印 writer1 和 writer2。
将 writer2 的 name 字段调整为“三妹”。
再次打印。

来看一下输出结果。
123456浅拷贝后：writer1：Writer@68837a77{age&#x3D;18, name&#x3D;&#39;二哥&#39;}writer2：Writer@b97c004{age&#x3D;18, name&#x3D;&#39;二哥&#39;}调整了 writer2 的 name 后：writer1：Writer@68837a77{age&#x3D;18, name&#x3D;&#39;二哥&#39;}writer2：Writer@b97c004{age&#x3D;18, name&#x3D;&#39;三妹&#39;}
可以看得出，浅拷贝后，writer1 和 writer2 引用了不同的对象，但值是相同的，说明拷贝成功。之后，修改了 writer2 的 name 字段，直接上图就明白了。

之前的例子中，Writer 类只有两个字段，没有引用类型字段。那么，我们再来看另外一个例子，为 Writer 类增加一个自定义的引用类型字段 Book，先来看 Book 的定义。
123456789101112class Book {    private String bookName;    private int price;    &#x2F;&#x2F; getter&#x2F;setter 和构造方法都已省略    @Override    public String toString() {        return super.toString().substring(26) +                &quot; bookName&#x3D;&#39;&quot; + bookName + &#39;\&#39;&#39; +                &quot;, price&#x3D;&quot; + price +                &#39;}&#39;;    }}
有两个字段，分别是 String 类型的 bookName 和 int 类型的 price。
然后来看 Writer 类的定义。
123456789101112131415161718class Writer implements Cloneable{    private int age;    private String name;    private Book book;    &#x2F;&#x2F; getter&#x2F;setter 和构造方法都已省略    @Override    public String toString() {        return super.toString().substring(26) +                &quot; age&#x3D;&quot; + age +                &quot;, name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, book&#x3D;&quot; + book +                &#39;}&#39;;    }    @Override    protected Object clone() throws CloneNotSupportedException {        return super.clone();    }}
比之前的例子多了一个自定义类型的字段 book， clone() 方法并没有任何改变。
再来看测试类。
1234567891011121314151617class TestClone {    public static void main(String[] args) throws CloneNotSupportedException {        Writer writer1 &#x3D; new Writer(18,&quot;二哥&quot;);        Book book1 &#x3D; new Book(&quot;编译原理&quot;,100);        writer1.setBook(book1);        Writer writer2 &#x3D; (Writer) writer1.clone();        System.out.println(&quot;浅拷贝后：&quot;);        System.out.println(&quot;writer1：&quot; + writer1);        System.out.println(&quot;writer2：&quot; + writer2);        Book book2 &#x3D; writer2.getBook();        book2.setBookName(&quot;永恒的图灵&quot;);        book2.setPrice(70);        System.out.println(&quot;writer2.book 变更后：&quot;);        System.out.println(&quot;writer1：&quot; + writer1);        System.out.println(&quot;writer2：&quot; + writer2);    }}

通过 new 关键字声明了一个 Writer 对象（18 岁的二哥），将其赋值给 writer1。
通过 new 关键字声明了一个 Book 对象（100 块的编译原理），将其赋值给 book1。
将 writer1 的 book 字段设置为 book1。
通过调用 clone() 方法进行对象拷贝，并将其赋值给 writer2。
之后打印 writer1 和 writer2。
获取 writer2 的 book 字段，并将其赋值给 book2。
将 book2 的 bookName 字段调整为“永恒的图灵”，price 字段调整为 70。
再次打印。

来看一下输出结果。
12345678910浅拷贝后：writer1：Writer@68837a77 age&#x3D;18, name&#x3D;&#39;二哥&#39;, book&#x3D;Book@32e6e9c3 bookName&#x3D;&#39;编译原理&#39;, price&#x3D;100}}writer2：Writer@6d00a15d age&#x3D;18, name&#x3D;&#39;二哥&#39;, book&#x3D;Book@32e6e9c3 bookName&#x3D;&#39;编译原理&#39;, price&#x3D;100}}writer2.book 变更后：writer1：Writer@68837a77 age&#x3D;18, name&#x3D;&#39;二哥&#39;, book&#x3D;Book@32e6e9c3 bookName&#x3D;&#39;永恒的图灵&#39;, price&#x3D;70}}writer2：Writer@36d4b5c age&#x3D;18, name&#x3D;&#39;二哥&#39;, book&#x3D;Book@32e6e9c3 bookName&#x3D;&#39;永恒的图灵&#39;, price&#x3D;70}}
与之前例子不同的是，writer2.book 变更后，writer1.book 也发生了改变。这是因为字符串 String 是不可变对象，一个新的值必须在字符串常量池中开辟一段新的内存空间，而自定义对象的内存地址并没有发生改变，只是对应的字段值发生了改变，见下图。

“哇，哥，果真一图胜千言，我明白了。”三妹似乎对我画的图很感兴趣呢，“那你继续说深拷贝吧！”
“嗯，三妹，你有没有注意到，浅拷贝克隆的对象中，引用类型的字段指向的是同一个，当改变任何一个对象，另外一个对象也会随之改变，除去字符串的特殊性外。”
“深拷贝和浅拷贝不同的，深拷贝中的引用类型字段也会克隆一份，当改变任何一个对象，另外一个对象不会随之改变。”
“明白了这一点后，我们再来看例子。”
12345678910111213141516class Book implements Cloneable{    private String bookName;    private int price;    &#x2F;&#x2F; getter&#x2F;setter 和构造方法都已省略    @Override    public String toString() {        return super.toString().substring(26) +                &quot; bookName&#x3D;&#39;&quot; + bookName + &#39;\&#39;&#39; +                &quot;, price&#x3D;&quot; + price +                &#39;}&#39;;    }    @Override    protected Object clone() throws CloneNotSupportedException {        return super.clone();    }}
注意，此时的 Book 类和浅拷贝时不同，重写了 clone() 方法，并实现了 Cloneable 接口。为的就是深拷贝的时候也能够克隆该字段。
1234567891011121314151617181920class Writer implements Cloneable{    private int age;    private String name;    private Book book;    &#x2F;&#x2F; getter&#x2F;setter 和构造方法都已省略    @Override    public String toString() {        return super.toString().substring(26) +                &quot; age&#x3D;&quot; + age +                &quot;, name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, book&#x3D;&quot; + book +                &#39;}&#39;;    }    @Override    protected Object clone() throws CloneNotSupportedException {        Writer writer &#x3D; (Writer) super.clone();        writer.setBook((Book) writer.getBook().clone());        return writer;    }}
注意，此时 Writer 类也与之前的不同， clone() 方法当中，不再只调用 Object 的 clone() 方法对 Writer 进行克隆了，还对 Book 也进行了克隆。
来看测试类。
1234567891011121314151617class TestClone {    public static void main(String[] args) throws CloneNotSupportedException {        Writer writer1 &#x3D; new Writer(18,&quot;二哥&quot;);        Book book1 &#x3D; new Book(&quot;编译原理&quot;,100);        writer1.setBook(book1);        Writer writer2 &#x3D; (Writer) writer1.clone();        System.out.println(&quot;深拷贝后：&quot;);        System.out.println(&quot;writer1：&quot; + writer1);        System.out.println(&quot;writer2：&quot; + writer2);        Book book2 &#x3D; writer2.getBook();        book2.setBookName(&quot;永恒的图灵&quot;);        book2.setPrice(70);        System.out.println(&quot;writer2.book 变更后：&quot;);        System.out.println(&quot;writer1：&quot; + writer1);        System.out.println(&quot;writer2：&quot; + writer2);    }}
这个测试类和之前的浅拷贝的测试类就完全一样了，但运行结果是不同的。
12345678910深拷贝后：writer1：Writer@6be46e8f age&#x3D;18, name&#x3D;&#39;二哥&#39;, book&#x3D;Book@5056dfcb bookName&#x3D;&#39;编译原理&#39;, price&#x3D;100}}writer2：Writer@6d00a15d age&#x3D;18, name&#x3D;&#39;二哥&#39;, book&#x3D;Book@51efea79 bookName&#x3D;&#39;编译原理&#39;, price&#x3D;100}}writer2.book 变更后：writer1：Writer@6be46e8f age&#x3D;18, name&#x3D;&#39;二哥&#39;, book&#x3D;Book@5056dfcb bookName&#x3D;&#39;编译原理&#39;, price&#x3D;100}}writer2：Writer@6d00a15d age&#x3D;18, name&#x3D;&#39;二哥&#39;, book&#x3D;Book@51efea79 bookName&#x3D;&#39;永恒的图灵&#39;, price&#x3D;70}}
不只是 writer1 和 writer2 是不同的对象，它们中的 book 也是不同的对象。所以，改变了 writer2 中的 book 并不会影响到 writer1。

不过，通过 clone() 方法实现的深拷贝比较笨重，因为要将所有的引用类型都重写 clone() 方法，当嵌套的对象比较多的时候，就废了！
“那有没有好的办法呢？”三妹急切的问。
“当然有了，利用序列化。”我胸有成竹的回答，“序列化是将对象写到流中便于传输，而反序列化则是将对象从流中读取出来。”
“写入流中的对象就是对原始对象的拷贝。需要注意的是，每个要序列化的类都要实现 Serializable 接口，该接口和 Cloneable 接口类似，都是标记型接口。”
来看例子。
123456789101112class Book implements Serializable {    private String bookName;    private int price;    &#x2F;&#x2F; getter&#x2F;setter 和构造方法都已省略    @Override    public String toString() {        return super.toString().substring(26) +                &quot; bookName&#x3D;&#39;&quot; + bookName + &#39;\&#39;&#39; +                &quot;, price&#x3D;&quot; + price +                &#39;}&#39;;    }}
Book 需要实现 Serializable 接口。
12345678910111213141516171819202122232425class Writer implements Serializable {    private int age;    private String name;    private Book book;    &#x2F;&#x2F; getter&#x2F;setter 和构造方法都已省略    @Override    public String toString() {        return super.toString().substring(26) +                &quot; age&#x3D;&quot; + age +                &quot;, name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, book&#x3D;&quot; + book +                &#39;}&#39;;    }    &#x2F;&#x2F;深度拷贝    public Object deepClone() throws IOException, ClassNotFoundException {        &#x2F;&#x2F; 序列化        ByteArrayOutputStream bos &#x3D; new ByteArrayOutputStream();        ObjectOutputStream oos &#x3D; new ObjectOutputStream(bos);        oos.writeObject(this);        &#x2F;&#x2F; 反序列化        ByteArrayInputStream bis &#x3D; new ByteArrayInputStream(bos.toByteArray());        ObjectInputStream ois &#x3D; new ObjectInputStream(bis);        return ois.readObject();    }}
Writer 类也需要实现 Serializable 接口，并且在该类中，增加了一个 deepClone() 的方法，利用 OutputStream 进行序列化，InputStream 进行反序列化，这样就实现了深拷贝。
来看示例。
123456789101112131415161718class TestClone {    public static void main(String[] args) throws IOException, ClassNotFoundException {        Writer writer1 &#x3D; new Writer(18,&quot;二哥&quot;);        Book book1 &#x3D; new Book(&quot;编译原理&quot;,100);        writer1.setBook(book1);        Writer writer2 &#x3D; (Writer) writer1.deepClone();        System.out.println(&quot;深拷贝后：&quot;);        System.out.println(&quot;writer1：&quot; + writer1);        System.out.println(&quot;writer2：&quot; + writer2);        Book book2 &#x3D; writer2.getBook();        book2.setBookName(&quot;永恒的图灵&quot;);        book2.setPrice(70);        System.out.println(&quot;writer2.book 变更后：&quot;);        System.out.println(&quot;writer1：&quot; + writer1);        System.out.println(&quot;writer2：&quot; + writer2);    }}
与之前测试类不同的是，调用了 deepClone() 方法。
12345678910深拷贝后：writer1：Writer@9629756 age&#x3D;18, name&#x3D;&#39;二哥&#39;, book&#x3D;Book@735b5592 bookName&#x3D;&#39;编译原理&#39;, price&#x3D;100}}writer2：Writer@544fe44c age&#x3D;18, name&#x3D;&#39;二哥&#39;, book&#x3D;Book@31610302 bookName&#x3D;&#39;编译原理&#39;, price&#x3D;100}}writer2.book 变更后：writer1：Writer@9629756 age&#x3D;18, name&#x3D;&#39;二哥&#39;, book&#x3D;Book@735b5592 bookName&#x3D;&#39;编译原理&#39;, price&#x3D;100}}writer2：Writer@544fe44c age&#x3D;18, name&#x3D;&#39;二哥&#39;, book&#x3D;Book@31610302 bookName&#x3D;&#39;永恒的图灵&#39;, price&#x3D;70}}
测试结果和之前用 clone() 方法实现的深拷贝类似。
“不过，三妹，需要注意，由于是序列化涉及到输入流和输出流的读写，在性能上要比 HotSpot 虚拟机实现的 clone() 方法差很多。”我语重心长地说。
“好的，二哥，你先去休息吧，让我来琢磨一会，总结一下浅拷贝和深拷贝之间的差异。”
“嗯嗯。”
11.5 Java hashCode方法解析今天我们来谈谈 Java 中的 hashCode() 方法。众所周知，Java 是一门面向对象的编程语言，所有的类都会默认继承自 Object 类，而 Object 的中文意思就是“对象”。
Object 类中就包含了 hashCode() 方法：
1public native int hashCode();
意味着所有的类都会有一个 hashCode() 方法，该方法会返回一个 int 类型的值。由于 hashCode() 方法是一个本地方法（ native 关键字修饰的方法，用 C&#x2F;C++ 语言实现，由 Java 调用），意味着 Object 类中并没有给出具体的实现。
具体的实现可以参考 jdk&#x2F;src&#x2F;hotspot&#x2F;share&#x2F;runtime&#x2F;synchronizer.cpp （源码可以到 GitHub 上 OpenJDK 的仓库中下载）。 get_next_hash() 方法会根据 hashCode 的取值来决定采用哪一种哈希值的生成策略。

Java 9 之后， hashCode() 方法会被 @HotSpotIntrinsicCandidate 注解修饰，表明它在 HotSpot 虚拟机中有一套高效的实现，基于 CPU 指令。
那大家有没有想过这样一个问题：为什么 Object 类需要一个 hashCode()方法呢？
在 Java 中， hashCode() 方法的主要作用就是为了配合哈希表使用的。
哈希表（Hash Table），也叫散列表，是一种可以通过关键码值（key-value）直接访问的数据结构，它最大的特点就是可以快速实现查找、插入和删除。其中用到的算法叫做哈希，就是把任意长度的输入，变换成固定长度的输出，该输出就是哈希值。像 MD5、SHA1 都用的是哈希算法。
像 Java 中的 HashSet、Hashtable（注意是小写的 t）、HashMap 都是基于哈希表的具体实现。其中的 HashMap 就是最典型的代表，不仅面试官经常问，工作中的使用频率也非常的高。
大家想一下，如果没有哈希表，但又需要这样一个数据结构，它里面存放的数据是不允许重复的，该怎么办呢？
要不使用 equals() 方法进行逐个比较？这种方案当然是可行的。但如果数据量特别特别大，采用 equals() 方法进行逐个对比的效率肯定很低很低，最好的解决方案就是哈希表。
拿 HashMap 来说吧。当我们要在它里面添加对象时，先调用这个对象的 hashCode() 方法，得到对应的哈希值，然后将哈希值和对象一起放到 HashMap 中。当我们要再添加一个新的对象时：

获取对象的哈希值；
和之前已经存在的哈希值进行比较，如果不相等，直接存进去；
如果有相等的，再调用 equals() 方法进行对象之间的比较，如果相等，不存了；
如果不等，说明哈希冲突了，增加一个链表，存放新的对象；
如果链表的长度大于 8，转为红黑树来处理。

就这么一套下来，调用 equals() 方法的频率就大大降低了。也就是说，只要哈希算法足够的高效，把发生哈希冲突的频率降到最低，哈希表的效率就特别的高。
来看一下 HashMap 的哈希算法：
1234static final int hash(Object key) {    int h;    return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);}
先调用对象的 hashCode() 方法，然后对该值进行右移运算，然后再进行异或运算。
通常来说，String 会用来作为 HashMap 的键进行哈希运算，因此我们再来看一下 String 的 hashCode() 方法：
1234567891011public int hashCode() {    int h &#x3D; hash;    if (h &#x3D;&#x3D; 0 &amp;&amp; value.length &gt; 0) {        char val[] &#x3D; value;        for (int i &#x3D; 0; i &lt; value.length; i++) {            h &#x3D; 31 * h + val[i];        }        hash &#x3D; h;    }    return h;}
可想而知，经过这么一系列复杂的运算，再加上 JDK 作者这种大师级别的设计，哈希冲突的概率我相信已经降到了最低（我们在 HashMap 中深入探讨过）。
当然了，从理论上来说，对于两个不同对象，它们通过 hashCode() 方法计算后的值可能相同。因此，不能使用 hashCode() 方法来判断两个对象是否相等，必须得通过 equals() 方法。
也就是说：

如果两个对象调用 equals() 方法得到的结果为 true，调用 hashCode() 方法得到的结果必定相等；
如果两个对象调用 hashCode() 方法得到的结果不相等，调用 equals() 方法得到的结果必定为 false；

反之：

如果两个对象调用 equals() 方法得到的结果为 false，调用 hashCode() 方法得到的结果不一定不相等；
如果两个对象调用 hashCode() 方法得到的结果相等，调用 equals() 方法得到的结果不一定为 true；

来看下面这段代码。
12345678910111213141516171819202122public class Test {    public static void main(String[] args) {        Student s1 &#x3D; new Student(18, &quot;张三&quot;);        Map&lt;Student, Integer&gt; scores &#x3D; new HashMap&lt;&gt;();        scores.put(s1, 98);        System.out.println(scores.get(new Student(18, &quot;张三&quot;)));    }} class Student {    private int age;    private String name;     public Student(int age, String name) {         this.age &#x3D; age;         this.name &#x3D; name;     }     @Override     public boolean equals(Object o) {         Student student &#x3D; (Student) o;         return age &#x3D;&#x3D; student.age &amp;&amp;                 Objects.equals(name, student.name);     } }
我们重写了 Student 类的 equals() 方法，如果两个学生的年纪和姓名相同，我们就认为是同一个学生，虽然很离谱，但我们就是这么草率。
在 main() 方法中，18 岁的张三考试得了 98 分，很不错的成绩，我们把张三和成绩放到了 HashMap 中，然后准备输出张三的成绩：
1null
很不巧，结果为 null，而不是预期当中的 98。这是为什么呢？
原因就在于重写 equals() 方法的时候没有重写 hashCode() 方法。默认情况下， hashCode() 方法是一个本地方法，会返回对象的存储地址，显然 put() 中的 s1 和 get() 中的 new Student(18, “张三”) 是两个对象，它们的存储地址肯定是不同的。
HashMap 的 get() 方法会调用 hash(key.hashCode()) 计算对象的哈希值，虽然两个不同的 hashCode() 结果经过 hash() 方法计算后有可能得到相同的结果，但这种概率微乎其微，所以就导致 scores.get(new Student(18, “张三”)) 无法得到预期的值 18。
怎么解决这个问题呢？很简单，重写 hashCode() 方法。
1234@Override public int hashCode() {     return Objects.hash(age, name); }
Objects 类的 hash() 方法可以针对不同数量的参数生成新的 hashCode() 值。
12345678public static int hashCode(Object a[]) { if (a &#x3D;&#x3D; null)     return 0; int result &#x3D; 1; for (Object element : a)     result &#x3D; 31 * result + (element &#x3D;&#x3D; null ? 0 : element.hashCode()); return result;}
代码似乎很简单，归纳出的数学公式如下所示（n 为字符串长度）。

注意：31 是个奇质数，不大不小，一般质数都非常适合哈希计算，偶数相当于移位运算，容易溢出，造成数据信息丢失。
这就意味着年纪和姓名相同的情况下，会得到相同的哈希值。 scores.get(new Student(18, “张三”)) 就会返回 98 的预期值了。
《Java 编程思想》这本圣经中有一段话，对 hashCode() 方法进行了一段描述。

设计 hashCode() 时最重要的因素就是：无论何时，对同一个对象调用 hashCode() 都应该生成同样的值。如果在将一个对象用 put() 方法添加进 HashMap 时产生一个 hashCode() 值，而用 get() 方法取出时却产生了另外一个 hashCode() 值，那么就无法重新取得该对象了。所以，如果你的 hashCode() 方法依赖于对象中易变的数据，用户就要当心了，因为此数据发生变化时，hashCode() 就会生成一个不同的哈希值，相当于产生了一个不同的键。

也就是说，如果在重写 hashCode() 和 equals() 方法时，对象中某个字段容易发生改变，那么最好舍弃这些字段，以免产生不可预期的结果。
好。有了上面这些内容作为基础后，我们回头再来看看本地方法 hashCode() 的 C++ 源码。
1234567891011121314151617181920212223242526272829303132333435static inline intptr_t get_next_hash(Thread* current, oop obj) {  intptr_t value &#x3D; 0;  if (hashCode &#x3D;&#x3D; 0) {    &#x2F;&#x2F; 这种形式使用全局的 Park-Miller 随机数生成器。    &#x2F;&#x2F; 在 MP 系统上，我们将对全局变量进行大量的读写访问，因此该机制会引发大量的一致性通信。    value &#x3D; os::random();  } else if (hashCode &#x3D;&#x3D; 1) {    &#x2F;&#x2F; 这种变体在 STW（Stop The World）操作之间具有稳定（幂等）的特性。    &#x2F;&#x2F; 在一些 1-0 同步方案中，这可能很有用。    intptr_t addr_bits &#x3D; cast_from_oop&lt;intptr_t&gt;(obj) &gt;&gt; 3;    value &#x3D; addr_bits ^ (addr_bits &gt;&gt; 5) ^ GVars.stw_random;  } else if (hashCode &#x3D;&#x3D; 2) {    value &#x3D; 1;            &#x2F;&#x2F; 用于敏感性测试  } else if (hashCode &#x3D;&#x3D; 3) {    value &#x3D; ++GVars.hc_sequence;  } else if (hashCode &#x3D;&#x3D; 4) {    value &#x3D; cast_from_oop&lt;intptr_t&gt;(obj);  } else {    &#x2F;&#x2F; Marsaglia 的异或移位方案，具有线程特定的状态    &#x2F;&#x2F; 这可能是最好的整体实现 -- 我们可能会在未来的版本中将其设为默认实现。    unsigned t &#x3D; current-&gt;_hashStateX;    t ^&#x3D; (t &lt;&lt; 11);    current-&gt;_hashStateX &#x3D; current-&gt;_hashStateY;    current-&gt;_hashStateY &#x3D; current-&gt;_hashStateZ;    current-&gt;_hashStateZ &#x3D; current-&gt;_hashStateW;    unsigned v &#x3D; current-&gt;_hashStateW;    v &#x3D; (v ^ (v &gt;&gt; 19)) ^ (t ^ (t &gt;&gt; 8));    current-&gt;_hashStateW &#x3D; v;    value &#x3D; v;  }  value &amp;&#x3D; markWord::hash_mask;  if (value &#x3D;&#x3D; 0) value &#x3D; 0xBAD;  assert(value !&#x3D; markWord::no_hash, &quot;invariant&quot;);  return value;}
如果没有 C++ 基础的话，不用细致去看每一行代码，我们只通过表面去了解一下 get_next_hash() 这个方法就行。其中的 hashCode 变量是 JVM 启动时的一个全局参数，可以通过它来切换哈希值的生成策略。

hashCode&#x3D;&#x3D;0 ，调用操作系统 OS 的 random() 方法返回随机数。
hashCode &#x3D;&#x3D; 1 ，在 STW（stop-the-world）操作中，这种策略通常用于同步方案中。利用对象地址进行计算，使用不经常更新的随机数（ GVars.stw_random ）参与其中。
hashCode &#x3D;&#x3D; 2 ，使用返回 1，用于某些情况下的测试。
hashCode &#x3D;&#x3D; 3 ，从 0 开始计算哈希值，不是线程安全的，多个线程可能会得到相同的哈希值。
hashCode &#x3D;&#x3D; 4 ，与创建对象的内存位置有关，原样输出。
hashCode &#x3D;&#x3D; 5 ，默认值，支持多线程，使用了 Marsaglia 的 xor-shift 算法产生伪随机数。所谓的 xor-shift 算法，简单来说，看起来就是一个移位寄存器，每次移入的位由寄存器中若干位取异或生成。所谓的伪随机数，不是完全随机的，但是真随机生成比较困难，所以只要能通过一定的随机数统计检测，就可以当作真随机数来使用。

这里简单总结下。
在 Java 中， hashCode()方法是定义在 java.lang.Object 类中的一个方法，该类是所有 Java 所有类的父类。因此，每个 Java 对象都可以调用 hashCode()方法。 hashCode()方法主要用于支持哈希表（如 java.util.HashMap），这些数据结构使用哈希算法能实现快速查找、插入和删除操作。
hashCode()方法的主要目的是返回一个整数，这个整数称为哈希码，它代表了对象在内存中的一种近似表示。哈希码用于将对象映射到哈希表中的一个特定的位置。两个相等的对象（根据 equals()方法比较）应该具有相同的哈希码。然而，具有相同哈希码的两个对象并不一定相等。
当你创建一个自定义类并覆盖 equals()方法时，通常也需要覆盖 hashCode()方法，以确保相等的对象具有相同的哈希码。这有助于提高哈希表在使用自定义类的对象作为键时的准确性。
11.6 Java是值传递还是引用传递？“哥，说说 Java 到底是值传递还是引用传递吧？”三妹一脸的困惑，看得出来她被这个问题折磨得不轻。
“说实在的，我在一开始学 Java 的时候也被这个问题折磨得够呛，总以为基本数据类型在传参的时候是值传递，而引用类型是引用传递。”我对三妹袒露了心声，为的就是让她不再那么焦虑，她哥当年也是这么过来的。
C 语言是很多编程语言的母胎，包括 Java，那么对于 C 语言来说，所有的方法参数都是“通过值”传递的，也就是说，传递给被调用方法的参数值存放在临时变量中，而不是存放在原来的变量中。这就意味着，被调用的方法不能修改调用方法中变量的值，而只能修改其私有变量的临时副本的值。
Java 继承了 C 语言这一特性，因此 Java 是按照值来传递的。
接下来，我们必须得搞清楚，到底什么是值传递（pass by value），什么是引用传递（pass by reference），否则，讨论 Java 到底是值传递还是引用传递就显得毫无意义。
当一个参数按照值的方式在两个方法之间传递时，调用者和被调用者其实是用的两个不同的变量——被调用者中的变量（原始值）是调用者中变量的一份拷贝，对它们当中的任何一个变量修改都不会影响到另外一个变量，据说 Fortran 语言是通过引用传递的。
“Fortran 语言？”三妹睁大了双眼，似乎听见了什么新的名词。
“是的，Fortran 语言，1957 年由 IBM 公司开发，是世界上第一个被正式采用并流传至今的高级编程语言。”当一个参数按照引用传递的方式在两个方法之间传递时，调用者和被调用者其实用的是同一个变量，当该变量被修改时，双方都是可见的。
“我们之所以容易搞不清楚 Java 到底是值传递还是引用传递，主要是因为 Java 中的两类数据类型的叫法容易引发误会，比如说 int 是基本类型，说它是值传递的，我们就很容易理解；但对于引用类型，比如说 String，说它也是值传递的时候，我们就容易弄不明白。”
我们来看看基本数据类型和引用数据类型之间的差别。
12int age &#x3D; 18;String name &#x3D; &quot;二哥&quot;;
age 是基本类型，值就保存在变量中，而 name 是引用类型，变量中保存的是对象的地址。一般称这种变量为对象的引用，引用存放在栈中，而对象存放在堆中。
这里说的栈和堆，是指内存中的一块区域，和数据结构中的栈和堆不一样。栈是由编译器自动分配释放的，所以适合存放编译期就确定生命周期的数据；而堆中存放的数据，编译器是不需要知道生命周期的，创建后的回收工作由垃圾收集器来完成。
“画幅图。”

当用 &#x3D; 赋值运算符改变 age 和 name 的值时。
12age &#x3D; 16;name &#x3D; &quot;三妹&quot;;
对于基本类型 age，赋值运算符会直接改变变量的值，原来的值被覆盖。
对于引用类型 name，赋值运算符会改变对象引用中保存的地址，原来的地址被覆盖，但原来的对象不会被覆盖。

“三妹，注意听，接下来，我们来说说基本数据类型的参数传递。”
Java 有 8 种基本数据类型，分别是 int、long、byte、short、float、double 、char 和 boolean，就拿 int 类型来举例吧。
12345678910class PrimitiveTypeDemo {    public static void main(String[] args) {        int age &#x3D; 18;        modify(age);        System.out.println(age);    }    private static void modify(int age1) {        age1 &#x3D; 30;    }}
1） main() 方法中的 age 为基本类型，所以它的值 18 直接存储在变量中。
2）调用 modify() 方法的时候，将会把 age 的值 18 复制给形参 age1。
3） modify() 方法中，对 age1  做出了修改。
4）回到 main() 方法中，age 的值仍然为 18，并没有发生改变。
如果我们想让 age 的值发生改变，就需要这样做。
1234567891011class PrimitiveTypeDemo1 {    public static void main(String[] args) {        int age &#x3D; 18;        age &#x3D; modify(age);        System.out.println(age);    }    private static int modify(int age1) {        age1 &#x3D; 30;        return age1;    }}
第一，让 modify() 方法有返回值；
第二，使用赋值运算符重新对 age 进行赋值。
“好了，再来说说引用类型的参数传递。”
就以 String 为例吧。
12345678910class ReferenceTypeDemo {    public static void main(String[] args) {        String name &#x3D; &quot;二哥&quot;;        modify(name);        System.out.println(name);    }    private static void modify(String name1) {        name1 &#x3D; &quot;三妹&quot;;    }}
在调用 modify() 方法的时候，形参 name1 复制了 name 的地址，指向的是堆中“二哥”的位置。

当 modify() 方法调用结束后，改变了形参 name1 的地址，但 main() 方法中 name 并没有发生改变。

总结：

Java 中的参数传递是按值传递的。
如果参数是基本类型，传递的是基本类型的字面量值的拷贝。
如果参数是引用类型，传递的是引用的对象在堆中地址的拷贝。

“好了，三妹，今天的学习就到这吧。”
11.7 Java为什么无法实现真正的泛型“二哥，为啥 Java 不能实现真正的泛型啊？”三妹开门见山地问。
简单来回顾一下类型擦除，看下面这段代码。
12345678public class Cmower {    public static void method(ArrayList&lt;String&gt; list) {        System.out.println(&quot;Arraylist&lt;String&gt; list&quot;);    }    public static void method(ArrayList&lt;Date&gt; list) {        System.out.println(&quot;Arraylist&lt;Date&gt; list&quot;);    }}
“三妹，你是不是认为 ArrayList list 和 ArrayList list 是两种不同的类型，因为 String 和 Date 是不同的类。”我问。
“嗯。”三妹点点头。
但由于类型擦除的原因，以上代码是不会编译通过的——编译器会提示一个错误：
12&gt;&#39;method(ArrayList&lt;String&gt;)&#39; clashes with &#39;method(ArrayList&lt;Date&gt;)&#39;; both methods have same erasure
也就是说，两个 method() 方法经过类型擦除后的方法签名是完全相同的，Java 是不允许这样做的。
也就是说，按照我们的假设：如果 Java 能够实现真正意义上的泛型，两个 method() 方法是可以同时存在的，就好像方法重载一样。
123456public class Cmower {    public static void method(String list) {    }    public static void method(Date list) {    }}
“为什么 Java 不能实现真正意义上的泛型呢？背后的原因是什么？快告诉我呀！”三妹着急了。
“保持耐心，好不好？”我安慰道。
第一，兼容性
Java 在 2004 年已经积累了较为丰富的生态，如果把现有的类修改为泛型类，需要让所有的用户重新修改源代码并且编译，这就会导致 Java 1.4 之前打下的江山可能会完全覆灭。
想象一下，你的代码原来运行的好好的，就因为 JDK 的升级，导致所有的源代码都无法编译通过并且无法运行，是不是会非常痛苦？
类型擦除就完美实现了兼容性，Java 1.5 之后的类可以使用泛型，而 Java 1.4 之前没有使用泛型的类也可以保留，并且不用做任何修改就能在新版本的 Java 虚拟机上运行。
老用户不受影响，新用户可以自由地选择使用泛型，可谓一举两得。
第二，不是“实现不了”。Pizza，1996 年的实验语言，在 Java 的基础上扩展了泛型。

Pizza 教程地址：http:&#x2F;&#x2F;pizzacompiler.sourceforge.net&#x2F;doc&#x2F;tutorial.html

“1996 年？”三妹表示很吃惊。
“嗯，你那会还没出生。”我说，“插一下 Java 的版本历史吧，你好有一个时间线上的观念。”

1995年5月23日，Java语言诞生
1996年1月，JDK1.0 诞生
1997年2月18日，JDK1.1发布
1998年2月，JDK1.1被下载超过2,000,000次
2000年5月8日，JDK1.3发布
2000年5月29日，JDK1.4发布
2004年9月30日18:00 PM，J2SE1.5 发布

也就是说，Pizza 在 JDK 1.0 的版本上就实现了“真正意义上的”泛型，我引过来两段例子，你一看就明白了。
首先是 StoreSomething，一个泛型类，标识符是大写字母 A 而不是我们熟悉的大写字母 T。
123456789101112class StoreSomething&lt;A&gt; {     A something;     StoreSomething(A something) {         this.something &#x3D; something;     }     void set(A something) {         this.something &#x3D; something;     }     A get() {         return something;     }}
这个 A 呢，可以是任何合法的 Java 类型：
12345StoreSomething&lt;String&gt; a &#x3D; new StoreSomething(&quot;I&#39;m a string!&quot;);StoreSomething&lt;int&gt; b &#x3D; new StoreSomething(17+4);b.set(9);int i &#x3D; b.get();String s &#x3D; a.get();
对吧？这就是我们想要的“真正意义上的泛型”，A 不仅仅可以是引用类型 String，还可以是基本数据类型。
要知道，Java 的泛型不允许是基本数据类型，只能是包装器类型。

除此之外，Pizza 的泛型还可以直接使用 new 关键字进行声明，并且 Pizza 编译器会从构造方法的参数上推断出具体的对象类型，究竟是 String 还是 int。要知道，Java 的泛型因为类型擦除的原因，程序员是无法知道一个 ArrayList 究竟是 ArrayList 还是 ArrayList 的。
1234ArrayList&lt;Integer&gt; ints &#x3D; new ArrayList&lt;Integer&gt;();ArrayList&lt;String&gt; strs &#x3D; new ArrayList&lt;String&gt;();System.out.println(ints.getClass());System.out.println(strs.getClass());
输出结果：
12class java.util.ArrayListclass java.util.ArrayList
都是 ArrayList 而已。
“那 Pizza 这种“真正意义上的泛型”为什么没有被 Java 采纳呢？”三妹很关心这个问题。
事实上，Java 的核心开发组对 Pizza 的泛型设计非常感兴趣，并且与 Pizza 的设计者 Martin 和 Phil 取得了联系，新合作了一个项目 Generic Java，争取在 Java 中添加泛型支持，但不引入 Pizza 的其他功能，比如说函数式编程。
这里再补充一点维基百科上的资料，Martin Odersky 是一名德国计算机科学家，他和其他人一起设计了 Scala 编程语言，以及 Generic Java（还有之前的 Pizza），他实现的 Generic Java 编译器成为了 Java 编译器 javac 的基础。
站在马后炮的思维来看，Pizza 的泛型设计和函数式编程非常具有历史前瞻性。然而 Java 的核心开发组在当时似乎并不想把函数式编程引入到 Java 中。
以至于 Java 在 1.4 之前仍然是不支持泛型的。
“为什么 Java 1.5 的时候又突然支持泛型了呢？”三妹问。
“当然是到了不支持不行的时候了。”我说。
没有泛型之前，我们可以这样写代码：
123ArrayList list &#x3D; new ArrayList();list.add(&quot;沉默王二&quot;);list.add(new Date());
不管是 String 类型，还是 Date 类型，都可以一股脑塞进 ArrayList 当中，这看起来似乎很方便，但取的时候就悲剧了。
1String s &#x3D; list.get(1);
这样取行吗？不行。还得加上强制转换。
1String s &#x3D; (String) list.get(1);
但我们知道，这行代码在运行的时候必然会出错：
12Exception in thread &quot;main&quot; java.lang.ClassCastException: java.util.Date cannot be cast to java.lang.String
这就又回到“兼容性”的问题了。
Java 语言和其他编程语言不一样，有着沉重的历史包袱，1.5 之前已经有大量的程序部署在生产环境下了，这时候如果一刀切，原来没有使用泛型的代码直接扼杀了，后果不堪想象。
Java 一直以来都强调兼容性，我认为这也是 Java 之所以能被广泛使用的主要原因之一，开发者不必担心Java 版本升级的问题，一个在 JDK 1.4 上可以跑的代码，放在 JDK 1.5 上仍然可以跑。
这里必须得说明一点，J2SE1.5 的发布，是 Java 语言发展史上的重要里程碑，为了表示该版本的重要性，J2SE1.5 也正式更名为 Java SE 5.0，往后去就是 Java SE 6.0，Java SE 7.0。。。。
但 Java 并不支持高版本 JDK 编译生成的字节码文件在低版本的 JRE（Java 运行时环境）上跑。

针对泛型，兼容性具体表现在什么地方呢？来看下面这段代码。
12345ArrayList&lt;Integer&gt; ints &#x3D; new ArrayList&lt;Integer&gt;();ArrayList&lt;String&gt; strs &#x3D; new ArrayList&lt;String&gt;();ArrayList list;list &#x3D; ints;list &#x3D; strs;
“兼容性表现在上面这段代码必须得能够编译运行。怎么办呢？”我扭头看了一下旁边的三妹，继续说。
“只能搞类型擦除了！”我妹肯定地回答。
“是滴。”
编译前进行泛型检测， ArrayList 只能放 Integer， ArrayList 只能放 String，取的时候就不用担心类型强转出错了。
但编译后的字节码文件里，是没有泛型的，放的都是 Object。
Java 神奇就神奇在这，表面上万物皆对象，但为了性能上的考量，又存在 int、double 这种原始类型，但原始类型又没办法和 Object 兼容，于是我们就只能写 ArrayList 这样很占用内存空间的代码。
这恐怕也是 Java 泛型被吐槽的原因之一了。

一个好消息是 Valhalla 项目正在努力解决这些因为泛型擦除带来的历史遗留问题。
Project Valhalla：正在进行当中的 OpenJDK 项目，计划给未来的 Java 添加改进的泛型支持。

源码地址：http:&#x2F;&#x2F;openjdk.java.net&#x2F;projects&#x2F;valhalla&#x2F;

让我们拭目以待吧！
“怎么样？三妹，这下全部都明白了吧！”我问。
“嗯嗯。二哥，你讲得可真棒 ”三妹夸奖得我有点小开心，嘿嘿。
11.8 掌握 Java 反射“二哥，什么是反射呀？”三妹开门见山地问。
“要想知道什么是反射，就需要先来了解什么是‘正射’。”我笑着对三妹说，“一般情况下，我们在使用某个类之前已经确定它到底是个什么类了，拿到手就直接可以使用 new 关键字来调用构造方法进行初始化，之后使用这个类的对象来进行操作。”
12Writer writer &#x3D; new Writer();writer.setName(&quot;沉默王二&quot;);
像上面这个例子，就可以理解为“正射”。而反射就意味着一开始我们不知道要初始化的类到底是什么，也就没法直接使用 new 关键字创建对象了。
我们只知道这个类的一些基本信息，就好像我们看电影的时候，为了抓住一个犯罪嫌疑人，警察就会问一些目击证人，根据这些证人提供的信息，找专家把犯罪嫌疑人的样貌给画出来——这个过程，就可以称之为反射。
12345Class clazz &#x3D; Class.forName(&quot;com.itwanger.s39.Writer&quot;);Method method &#x3D; clazz.getMethod(&quot;setName&quot;, String.class);Constructor constructor &#x3D; clazz.getConstructor();Object object &#x3D; constructor.newInstance();method.invoke(object,&quot;沉默王二&quot;);
像上面这个例子，就可以理解为“反射”。
“反射的写法比正射复杂得多啊！”三妹感慨地说。
“是的，反射的成本是要比正射的高得多。”我说，“反射的缺点主要有两个。”

破坏封装：由于反射允许访问私有字段和私有方法，所以可能会破坏封装而导致安全问题。
性能开销：由于反射涉及到动态解析，因此无法执行 Java 虚拟机优化，再加上反射的写法的确要复杂得多，所以性能要比“正射”差很多，在一些性能敏感的程序中应该避免使用反射。

“那反射有哪些好处呢？”三妹问。
反射的主要应用场景有：

开发通用框架：像 Spring，为了保持通用性，通过配置文件来加载不同的对象，调用不同的方法。
动态代理：在面向切面编程中，需要拦截特定的方法，就会选择动态代理的方式，而动态代理的底层技术就是反射。
注解：注解本身只是起到一个标记符的作用，它需要利用发射机制，根据标记符去执行特定的行为。

“好了，来看一下完整的例子吧。”我对三妹说。
Writer 类，有两个字段，然后还有对应的 getter&#x2F;setter。
12345678910111213141516public class Writer {    private int age;    private String name;    public int getAge() {        return age;    }    public void setAge(int age) {        this.age &#x3D; age;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name &#x3D; name;    }}
测试类：
12345678910111213141516public class ReflectionDemo1 {    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {        Writer writer &#x3D; new Writer();        writer.setName(&quot;沉默王二&quot;);        System.out.println(writer.getName());        Class clazz &#x3D; Class.forName(&quot;com.itwanger.s39.Writer&quot;);        Constructor constructor &#x3D; clazz.getConstructor();        Object object &#x3D; constructor.newInstance();        Method setNameMethod &#x3D; clazz.getMethod(&quot;setName&quot;, String.class);        setNameMethod.invoke(object, &quot;沉默王二&quot;);        Method getNameMethod &#x3D; clazz.getMethod(&quot;getName&quot;);        System.out.println(getNameMethod.invoke(object));    }}
来看一下输出结果：
12沉默王二沉默王二
只不过，反射的过程略显曲折了一些。
第一步，获取反射类的 Class 对象：
1Class clazz &#x3D; Class.forName(&quot;com.itwanger.s39.Writer&quot;);
第二步，通过  Class 对象获取构造方法 Constructor 对象：
1Constructor constructor &#x3D; clazz.getConstructor();
第三步，通过 Constructor 对象初始化反射类对象：
1Object object &#x3D; constructor.newInstance();
第四步，获取要调用的方法的 Method 对象：
12Method setNameMethod &#x3D; clazz.getMethod(&quot;setName&quot;, String.class);Method getNameMethod &#x3D; clazz.getMethod(&quot;getName&quot;);
第五步，通过 invoke() 方法执行：
12setNameMethod.invoke(object, &quot;沉默王二&quot;);getNameMethod.invoke(object)
“三妹，你看，经过这五个步骤，基本上就掌握了反射的使用方法。”我说。
“好像反射也没什么复杂的啊！”三妹说。
我先对三妹点点头，然后说：“是的，掌握反射的基本使用方法确实不难，但要理解整个反射机制还是需要花一点时间去了解一下 Java 虚拟机的类加载机制的。”
要想使用反射，首先需要获得反射类的 Class 对象，每一个类，不管它最终生成了多少个对象，这些对象只会对应一个 Class 对象，这个 Class 对象是由 Java 虚拟机生成的，由它来获悉整个类的结构信息。
也就是说， java.lang.Class 是所有反射 API 的入口。
而方法的反射调用，最终是由 Method 对象的 invoke() 方法完成的，来看一下源码（JDK 8 环境下）。
1234567891011121314151617181920public Object invoke(Object obj, Object... args)        throws IllegalAccessException, IllegalArgumentException,        InvocationTargetException {    &#x2F;&#x2F; 如果方法不允许被覆盖，进行权限检查    if (!override) {        if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {            Class&lt;?&gt; caller &#x3D; Reflection.getCallerClass();            &#x2F;&#x2F; 检查调用者是否具有访问权限            checkAccess(caller, clazz, obj, modifiers);        }    }    &#x2F;&#x2F; 获取方法访问器（从 volatile 变量中读取）    MethodAccessor ma &#x3D; methodAccessor;    if (ma &#x3D;&#x3D; null) {        &#x2F;&#x2F; 如果访问器为空，尝试获取方法访问器        ma &#x3D; acquireMethodAccessor();    }    &#x2F;&#x2F; 使用方法访问器调用方法，并返回结果    return ma.invoke(obj, args);}
两个嵌套的 if 语句是用来进行权限检查的。
invoke() 方法实际上是委派给 MethodAccessor 接口来完成的。

MethodAccessor 接口有三个实现类，其中的 MethodAccessorImpl 是一个抽象类，另外两个具体的实现类继承了这个抽象类。


NativeMethodAccessorImpl：通过本地方法来实现反射调用；
DelegatingMethodAccessorImpl：通过委派模式来实现反射调用；

通过 debug 的方式进入 invoke() 方法后，可以看到第一次反射调用会生成一个委派实现 DelegatingMethodAccessorImpl，它在生成的时候会传递一个本地实现 NativeMethodAccessorImpl。

也就是说， invoke() 方法在执行的时候，会先调用 DelegatingMethodAccessorImpl，然后调用 NativeMethodAccessorImpl，最后再调用实际的方法。
“为什么不直接调用本地实现呢？”三妹问。
“之所以采用委派实现，是为了能够在本地实现和动态实现之间切换。动态实现是另外一种反射调用机制，它是通过生成字节码的形式来实现的。如果反射调用的次数比较多，动态实现的效率就会更高，因为本地实现需要经过 Java 到 C&#x2F;C++ 再到 Java 之间的切换过程，而动态实现不需要；但如果反射调用的次数比较少，反而本地实现更快一些。”我说。
“那临界点是多少呢？”三妹问。
“默认是 15 次。”我说，“可以通过 -Dsun.reflect.inflationThreshold 参数类调整。”
来看下面这个例子。
1234Method setAgeMethod &#x3D; clazz.getMethod(&quot;setAge&quot;, int.class);for (int i &#x3D; 0;i &lt; 20; i++) {    setAgeMethod.invoke(object, 18);}
在 invoke() 方法处加断点进入 debug 模式，当 i &#x3D; 15 的时候，也就是第 16 次执行的时候，会进入到 if 条件分支中，改变 DelegatingMethodAccessorImpl 的委派模式 delegate 为 (MethodAccessorImpl)(new MethodAccessorGenerator()).generateMethod() ，而之前的委派模式 delegate 为 NativeMethodAccessorImpl。

“这下明白了吧？三妹。”我说，“接下来，我们再来熟悉一下反射当中常用的 API。”
1）获取反射类的 Class 对象
Class.forName() ，参数为反射类的完全限定名。
123456Class c1 &#x3D; Class.forName(&quot;com.itwanger.s39.ReflectionDemo3&quot;);System.out.println(c1.getCanonicalName());Class c2 &#x3D; Class.forName(&quot;[D&quot;);System.out.println(c2.getCanonicalName());Class c3 &#x3D; Class.forName(&quot;[[Ljava.lang.String;&quot;);System.out.println(c3.getCanonicalName());
来看一下输出结果：
123com.itwanger.s39.ReflectionDemo3double[]java.lang.String[][]
类名 + .class ，只适合在编译前就知道操作的 Class。。
123456Class c1 &#x3D; ReflectionDemo3.class;System.out.println(c1.getCanonicalName());Class c2 &#x3D; String.class;System.out.println(c2.getCanonicalName());Class c3 &#x3D; int[][][].class;System.out.println(c3.getCanonicalName());
来看一下输出结果：
123com.itwanger.s39.ReflectionDemo3java.lang.Stringint[][][]
2）创建反射类的对象
通过反射来创建对象的方式有两种：

用 Class 对象的 newInstance() 方法。
用 Constructor 对象的 newInstance() 方法。

12345Class c1 &#x3D; Writer.class;Writer writer &#x3D; (Writer) c1.newInstance();Class c2 &#x3D; Class.forName(&quot;com.itwanger.s39.Writer&quot;);Constructor constructor &#x3D; c2.getConstructor();Object object &#x3D; constructor.newInstance();
3）获取构造方法
Class 对象提供了以下方法来获取构造方法 Constructor 对象：

getConstructor() ：返回反射类的特定 public 构造方法，可以传递参数，参数为构造方法参数对应 Class 对象；缺省的时候返回默认构造方法。
getDeclaredConstructor() ：返回反射类的特定构造方法，不限定于 public 的。
getConstructors() ：返回类的所有 public 构造方法。
getDeclaredConstructors() ：返回类的所有构造方法，不限定于 public 的。

123456Class c2 &#x3D; Class.forName(&quot;com.itwanger.s39.Writer&quot;);Constructor constructor &#x3D; c2.getConstructor();Constructor[] constructors1 &#x3D; String.class.getDeclaredConstructors();for (Constructor c : constructors1) {    System.out.println(c);}
4）获取字段
大体上和获取构造方法类似，把关键字 Constructor 换成 Field 即可。
12Method setNameMethod &#x3D; clazz.getMethod(&quot;setName&quot;, String.class);Method getNameMethod &#x3D; clazz.getMethod(&quot;getName&quot;);
5）获取方法
大体上和获取构造方法类似，把关键字 Constructor 换成 Method 即可。
12Method[] methods1 &#x3D; System.class.getDeclaredMethods();Method[] methods2 &#x3D; System.class.getMethods();
“注意，三妹，如果你想反射访问私有字段和（构造）方法的话，需要使用 Constructor&#x2F;Field&#x2F;Method.setAccessible(true) 来绕开 Java 语言的访问限制。”我说。
“好的，二哥。还有资料可以参考吗？”三妹问。
“有的，有两篇文章写得非常不错，你在学习反射的时候可以作为参考。”我说。
第一篇：深入理解 Java 反射和动态代理

链接：https:&#x2F;&#x2F;dunwu.github.io&#x2F;javacore&#x2F;basics&#x2F;java-reflection.html

第二篇：大白话说Java反射：入门、使用、原理：

链接：https:&#x2F;&#x2F;www.cnblogs.com&#x2F;chanshuyi&#x2F;p&#x2F;head_first_of_reflection.html

这里简单总结下。
反射是 Java 中的一个强大特性，它允许在运行时检查和操作类、接口、字段和方法。反射是 Java 的核心组件，支持各种框架和库的实现，如 Spring、Hibernate 等。使用反射，可以在运行时动态地创建对象、调用方法和访问字段，而无需在编译时了解这些对象的具体实现。
反射的主要类位于 java.lang.reflect 包中，主要包括以下几个关键类：

Class：代表一个类或接口，包含了类的结构信息（如名称、构造函数、方法、字段等）。通过 Class 对象，可以获取类的元数据并操作类的实例。
Constructor：代表类的构造方法，用于创建类的实例。
Method：代表类的方法，可以通过它调用类的实例方法。
Field：代表类的字段，可以获取或修改字段的值。
Modifier：包含方法、字段和类的访问修饰符（如 public、private 等）。

使用反射时，需要注意以下几点：

性能：反射操作通常比直接操作对象的方法和字段慢，因为涉及到额外的间接调用和动态解析。因此，在关注性能的场景中，慎用反射。
安全性：通过反射，可以访问和操作类的私有字段和方法，这可能导致安全问题。因此，使用反射时要确保代码的安全性。
维护性：反射使代码变得更加复杂，可能导致难以维护。在使用反射时要确保代码的可读性和可维护性。

尽管反射存在上述问题，但在某些场景下（如框架开发、动态代理等），它仍然是非常有用的工具。
来一个完整的 demo 示例吧。
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Person {    private String name;    private int age;    public Person() {    }    public Person(String name, int age) {        this.name &#x3D; name;        this.age &#x3D; age;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name &#x3D; name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age &#x3D; age;    }    private void privateMethod() {        System.out.println(&quot;私有方法&quot;);    }}public class ReflectionDemo {    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException,            IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchFieldException {        &#x2F;&#x2F; 获取 Person 类的 Class 对象        Class&lt;?&gt; personClass &#x3D; Class.forName(&quot;com.github.paicoding.forum.test.javabetter.importance.Person&quot;);        &#x2F;&#x2F; 获取并打印类名        System.out.println(&quot;类名: &quot; + personClass.getName());        &#x2F;&#x2F; 获取构造函数        Constructor&lt;?&gt; constructor &#x3D; personClass.getConstructor(String.class, int.class);        &#x2F;&#x2F; 使用构造函数创建 Person 对象实例        Object personInstance &#x3D; constructor.newInstance(&quot;沉默王二&quot;, 30);        &#x2F;&#x2F; 获取并调用 getName 方法        Method getNameMethod &#x3D; personClass.getMethod(&quot;getName&quot;);        String name &#x3D; (String) getNameMethod.invoke(personInstance);        System.out.println(&quot;名字: &quot; + name);        &#x2F;&#x2F; 获取并调用 setAge 方法        Method setAgeMethod &#x3D; personClass.getMethod(&quot;setAge&quot;, int.class);        setAgeMethod.invoke(personInstance, 35);        &#x2F;&#x2F; 获取并访问 age 字段        Field ageField &#x3D; personClass.getDeclaredField(&quot;age&quot;);        ageField.setAccessible(true);        int age &#x3D; ageField.getInt(personInstance);        System.out.println(&quot;年纪: &quot; + age);        &#x2F;&#x2F; 获取并调用私有方法        Method privateMethod &#x3D; personClass.getDeclaredMethod(&quot;privateMethod&quot;);        privateMethod.setAccessible(true);        privateMethod.invoke(personInstance);    }}
在这个示例中，我们首先通过 Class.forName() 方法获取 Person 类的 Class 对象。接着，我们获取了 Person 类的构造方法、方法和字段，并使用这些反射对象来创建实例、调用方法和访问字段。注意，在访问私有方法和字段时，我们需要调用 setAccessible(true) 方法来允许访问。
“好了，三妹，关于反射，就先讲到这里吧。”
12 Java并发编程众所周知，Java 并发是 Java 程序员必须懂但又很难懂的一块知识点。一般来说，很少有人敢说自己精通 Java 并发的，一是容易被面试官吊打，二是并发编程涉及到操作系统、内存、CPU 等计算机专业比较核心的内容，比较考验一个程序员的内功。
这里就顺带给你盘点一下 Java 并发到底该如何从入门到精通，请及时用鸡毛掸子把收藏夹里的灰清理一下。在阅读过程中，如果有所帮助，麻烦默默收藏和主动转发，算是对我码字的这份坚持的亿点点鼓励。
一、为什么要学 Java 并发？ 
有句话不知道当讲不当讲，先讲了再说，就是“如果你只想 CURD，那么 Java 并发不学也罢！”但其实呢，大家都已经被教育的很有涵养了，工作中拧不拧螺丝不重要，重要的是面试一定要会造火箭，不然面试的机会都很难捞得到。
那作为 Java 体系中非常重要的一环，Java 并发自然是必须要掌握的，最起码也得会起个多线程吧？哈哈哈。高级点的，像平常开发中用到的 Tomcat 服务器、消息中间件、RPC 框架等等，它们的底层都涉及到了并发编程。
当然了，Java 并发涉及到东西实在是不少，包括操作系统的知识，Java 虚拟机的一些知识，Java 线程模型的知识，多线程相关的关键字，比如说 synchronized、volatile 等，还有锁的知识、JDK 提供的工具类等等，学起来还是非常容易令人头大的。
因此，我们需要一些高效的学习路线图，以及一些优质的学习资源，从而减少我们学习Java 并发编程所投入的时间和精力。
二、Java 并发学习路线图 
这是我最近整理的一张关于 Java 并发编程的思维导图，大的方向可以分为三个部分：线程基础、理论基础、工具类 JUC。

线程基础部分包括：

线程的创建方式
线程的状态切换
线程的基本操作
线程组和线程优先级

理论基础包括：

进程和线程的区别
多线程解决了什么问题，又带来了什么问题？
如何解决并发问题？包括 Java 内存模型，以及两个常见的关键字 volatile 和 synchronized

工具类 JUC 包括：

锁 Lock 系的 AQS、ReentrantLock、ReentrantReadWriteLock、Condition、LockSupport
并发容器系的 ConcurrentHashMap、ConcurrentLinkedQueue、CopyOnWriteArrayList、ThreadLocal、BlockingQueue
线程池系的 ThreadPoolExecutor、ScheduledThreadPoolExecutor
原子系的 AtomicInteger、AtomicIntegerArray、AtomicReference 等等
通信工具系的倒计时器 CountDownLatch、循环栅栏 CyclicBarrier、资源访问控制 Semaphore、数据交换 Exchanger、移相器Phaser
Fork&#x2F;Join框架

最后再来个经典的生产者消费者模式进行实践，整个 Java 并发体系就学得非常扎实了！
三、硬核 Java 并发学习资料
1）Java进阶之路 
学 Java，当然要找二哥的Java进阶之路，网址我贴下面了哈：

https:&#x2F;&#x2F;tobebetterjavaer.com&#x2F;home.html

进去直接找 Java 核心里面的 Java 并发编程就对了。我按照前面的思维导图整理了 29 篇文章，全部都是硬核级别的，跟着学就对了。 学Java，就认准二哥的Java进阶之路

2）视频  
懂的都懂，看视频到 B 站。黑马的《Java并发编程》评价还不错，300 多个小节，我觉得讲的比较好的有三部分：synchronized优化原理、AQS和线程池。


视频地址：https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV16J411h7Rd

还有尚硅谷宋红康老师讲的这个视频。


视频地址：https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1Kw411Z7dF&#x2F;

3）书籍 
纸质书只推荐一本《Java 并发编程实战》，豆瓣评分 9.0。不过这本书确实有点老了，基本上是按照 Java 6 来讲解的，希望出版社能早点出 2.0 版。

《Java 并发编程实战》这本书从总体上来看，分两条主线：

介绍 Java 并发包的重要组件和原理
如何利用这些组件来保证线程安全

到底该如何获得线程安全呢？背会并理解下面这段话：

Writing thread-safe code is, at its core, about managing access to state, and in particular to shared, mutable state.

如果发现不是很好懂，想从国内作者下手的话，可以尝试一下《Java并发编程的艺术》和《图解Java并发编程》这两本书，虽然豆瓣上评分一般，但对于构建 Java 并发的知识体系还是有很大帮助的。
之后，再去啃《Java 并发编程实战》就会发现没有以前那么费劲了，这本书之所以被誉为 Java 并发编程的圣经，确实可以看得出作者在并发编程方面有着丰富的经验。
4）开源电子书 
推荐 RedSpider社区的深入浅出 Java 多线程，比Java 并发编程实战更通俗易懂一些，因为里面穿插了很多精美的手绘图。


GitHub地址：https:&#x2F;&#x2F;github.com&#x2F;RedSpider1&#x2F;concurrent

再推荐一份 GitHub 上星标 3.6k+ 的 Java 并发知识点总结：

https:&#x2F;&#x2F;github.com&#x2F;CL0610&#x2F;Java-concurrency

仓库里有一句话我非常喜欢，也分享给各位小伙伴：
努力的意义，就是，在以后的日子里，放眼望去全是自己喜欢的人和事！
5）付费专栏 
王宝令老师在极客时间上开了一门《Java 并发编程实战》的付费专栏，质量还是挺高的，喜欢的小伙伴可以去购买。
四、优质八股文 
这里给大家推荐两份 Java 并发编程方面的八股文，一份来自三分恶滴滴的面渣逆袭，一份来自小牛，先截图给大家看一下 Java 并发方面都有哪些高频的面试题。
为了方便大家的阅读和背诵，我已经将其整理到了二哥的小破站《Java进阶之路》上，面渣逆袭 Java 并发篇：

https:&#x2F;&#x2F;tobebetterjavaer.com&#x2F;sidebar&#x2F;sanfene&#x2F;javathread.html

Java 并发编程八股文（背诵版）：

https:&#x2F;&#x2F;tobebetterjavaer.com&#x2F;baguwen&#x2F;java-thread.html

这两份八股文的质量都非常高，来看一下AQS了解多少小节下的内容，图文并茂，非常容易消化和吸收。’’
诚实点说，如果能把这两份八股文背会的话，简历上就真的敢写“精通”Java 并发了。
五、Java 并发学习心得 
Java 提供的并发组件，大致可以分为两类：

从预防阶段下手，防止错误发生，比如说 synchronized 关键字
一旦发生错误能及时重试，比如说 CAS

对于线程数量比较多的并发场景，采用预防的措施会比较合理，这样大部分线程就不会因为小概率时间的 CAS 重试浪费掉大量的 CPU 周期；在线程数量小的时候，CAS 的意义就比较大，因为预防措施带来的线程切换要比 CAS 等待的开销更大。
想要学好 Java 并发编程，就必须得对下图中提到的基础概念进行充分的理解。

在我看来，并发编程主要是用来解决这两个痛点的：

多个线程对同一变量造成的不一致问题；
为提高性能，计算机的很多执行单元都配备了缓存，那势必会影响并发编程的数据一致性。

需要提醒一点的是，多线程并发虽然是用来解决性能问题的，但并不意味着所有情况下都需要开启多线程，有时候反而会适得其反，那如果不是特别要求，尽量不要过早开启多线程。
并发编程是 Java 体系当中相对难掌握的一块知识点，比较考验一名程序员的内功，其实并发编程最早的应用领域就是操作系统的实现。
如果你已经有一定的编程经验，建议先学一下《计算机组成原理》，对操作系统、内存、CPU 先进行一些大致的了解，然后再来学习 Java 并发编程，可能就会感觉舒服多了！
结合我多年的工作经验来看，并发编程可以抽象成三个核心问题：分工、同步和互斥。
1）分工
分工指的是如何高效地拆解任务并分配给线程，像并发编程领域的一些设计模式，比如说生产者与消费者就是用来进行分工的。
2）同步
同步指的是线程之间如何协作，一个线程执行完了一个任务，要通知另外一个线程开工。还拿生产者-消费者模型来说吧，当队列满的时候，生产者线程等待，当队列不满的时候，生产者线程需要被唤醒重新执行；当队列空的时候，消费者线程开始等待，不空的时候，消费者线程被重新唤醒。
3）互斥
互斥指的是保证同一时刻只有一个线程访问共享资源，是解决线程安全问题的杀手锏。
当多个线程同时访问一个共享变量的时候，很容易出现“线程安全”问题，因为结果可能是不确定的——导致出现这个问题的根源就是可见性、有序性和原子性——为了解决它们，Java 引入了内存模型的概念，可以在一定程度上缓解“线程安全”的问题，但要想完全解决“线程安全”问题，还得靠互斥。
互斥的核心技术就是锁，比如说 synchronized，还有各种 Lock。
锁可以解决线程安全的问题，但同时也就意味着程序的性能要受到影响。
因此，Java 提供了针对不同场景下的锁，比如说读写锁 ReadWriteLock，可以解决多线程同时读，但只有一个线程能写的问题；但 ReadWriteLock 也有自己的问题，就是如果有线程正在读，写线程需要等待度线程释放锁后才能获得写锁，也就是读的过程中不允许写，属于一种悲观的读锁。
为了进一步提升并发执行的效率，Java 8 引入了一个新的读写锁 StampedLock，与ReadWriteLock 相比，StampedLock的优势在于读的过程中也允许获取写锁后写入，但带来的问题就是可能读的数据不一致，需要一点额外的代码来判断读的过程中是否有写入，本质上是一种乐观的锁。
乐观锁的意思就是估计读的过程中大概率不会有写入，而悲观锁则是读的过程中拒绝有写入，两者的区别就在于性能上会有差异，乐观锁需要针对小概率事件进行多一步的检测，但性能也会有所提升；悲观锁更能保证“线程安全性”。
听我这么一说，是不是一下子就清晰多了！
13 JVM（Java 虚拟机）2020 年的时候，通读了一遍周志明老师的《深入理解 Java 虚拟机：JVM 高级特性与最佳实践》第三版，读完之后受益匪浅，这让我对 Java 虚拟机有了一个更完整的认识。毫无疑问，《深入理解 Java 虚拟机》是 JVM 书籍中最好的一本书了，国产技术书的天花板。

在金三银四&#x2F;金九银十的跳槽季中，很多小伙伴都会忍不住蠢蠢欲动，其中 JVM 更是面试中不可或缺的一部分，所以我花了几天的时间整理了一条 JVM 的学习路线，希望能帮助到大家。
一、为什么要学习 JVM？ 
曾经我对 JVM 也是感到非常的头痛，完全搞不懂该怎么入门，只是听说《深入理解 Java 虚拟机》这本书很吊，但真读起来，却需要极大的耐心和定力，否则很快就会在读完第一章 JVM 的简史后放弃。
那首先，我们就要搞清楚，为什么要学习 JVM ？
第一，当然是面试要考，这一点毫无疑问，尤其是对于要参加校招的应届生来说，JVM 是绕不过去的，必须得学。
第二，如果你想成为公司不可或缺的顶梁柱，那 JVM 你得学，因为一般情况下，遇到的问题基本上 Google 下就能解决了，可一旦遇到 JVM 性能调优，就必须得有能查 OOM 的原因、能看懂字节码的老鸟出马了。
应用程序一旦上线，出问题是板上钉钉的事，除了数据库、网络、代码逻辑上的问题，剩下的就有内存溢出啊，频繁 GC 导致的性能瓶颈啊等棘手问题。
遇到这种问题，你就必须得能看懂 GC 日志，明白什么是老年代、永久代、元数据区等，这些都是 Java 虚拟机方面的知识。
明白了学习 JVM 的重要性，那我们就开搞吧！
二、JVM 学习路线图 
这是我最近整理的一张关于 JVM 的思维导图，大的方向可以分为三个部分：字节码与类的加载、内存与垃圾回收、性能监控和调优。


字节码与类的加载包括：

类的加载机制（类的加载过程、类加载器、双亲委派模型）
字节码（类文件结构、字节码指令、字节码执行引擎、实战字节码）

内存与垃圾回收包括：

JVM 内存结构
垃圾回收算法
垃圾回收机制
垃圾收集器

性能监控和调优包括：

调优指标
调优对象
调优工具
JIT 优化

有理论知识，有动手实战，基本上可以把 JVM 这块学的非常扎实了。
四、学习 JVM 的一点小心得 
和 C++ 相比，Java 的内存管理机制可以说是一大特色，Java 开发不再需要自己去写代码手动释放内存，甚至你想自己干，JVM 都不给你这个机会，虚拟机完全掌握了 Java 内存的控制权。
这看起来挺美好的，但并不意味着Java 开发就可以随意写代码，随意使用内存，从我多年的使用体验来看，内存溢出和内存泄露还是会时不时发生的，尤其是初学阶段，尤其在开启多线程的情况下。
一旦出现内存溢出或者内存泄露，排查问题还是挺困难的，所以知道逊尼基到底是怎么管理内存的就变得十分重要了。
JVM 的垃圾回收，其实就是收拾那些不再使用的 Java 对象，把他们曾经占用的内存重新释放出来。所以我们要搞清楚：
对象是如何创建的？对象是如何被访问的？到底哪些对象是废弃的？于是我们就需要搞清楚对象的生和死。
这些废弃了的对象到底放在哪？于是就需要了解JVM 的内存结构：方法区、堆、程序计数器、虚拟机栈和本地方法栈。
这些废弃了的对象会不会造成内存泄露（OOM，OutOfMemoryError）？于是我们就需要了解每个分区的 OOM。
这些废弃了对象什么时候被回收？于是我们就需要了解垃圾回收算法，比如说清除算法、复制算法、标记整理算法和分代收集算法。
知道了一个对象在内存中的生和死，我们还需要知道类是如何在内存中变成对象的？对象的方法是如何执行的？
于是我们开始学习 Java 虚拟机的执行过程，学习字节码文件（ .class 文件），学习类的加载机制，学习虚拟机栈的栈帧结构，学习方法的调用过程，学习字节码指令等等。
为了监控虚拟机和故障排查，我们需要学习常用的 JDK 命令行工具，掌握必要的线上问题排查方法；此外，还需要了解 JIT (Just In Time)并不是简单的将热点代码编译成机器码就收工的，它还会对代码的执行进行优化（方法内联和逃逸分析）。
JVM 相关的知识已经成为面试必考的科目了，但老实讲，JVM 相关的知识还真的不太好用在项目中，或者说不太好在项目中体现出来。
那这里给大家推荐一个实战项目，基于 Spring Boot 的在线 Java IDE，可以远程执行 Java 代码并将程序的运行结果反馈出来。涉及了 Java 类文件的结构、Java 类加载器和 Java 类的热替换等 JVM 相关的技术。

https:&#x2F;&#x2F;github.com&#x2F;TangBean&#x2F;OnlineExecutor

听我这么一说，是不是一下子就清晰多了！
Java 虚拟机虽然难学，但如果你能坚持学下去，内功自然而然就提升了一大截。
</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-Java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">1.3 Java数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-Java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">1.4 Java数据类型转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-Java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%BC%93%E5%AD%98%E6%B1%A0"><span class="toc-text">1.5 Java基本数据类型缓存池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-Java%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">1.6 Java运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7-Java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="toc-text">1.7 Java流程控制语句</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E6%95%B0%E7%BB%84-amp-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">2 数组&amp;字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E6%8E%8C%E6%8F%A1Java%E6%95%B0%E7%BB%84"><span class="toc-text">2.1 掌握Java数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E6%8E%8C%E6%8F%A1Java%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-text">2.2 掌握Java二维数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E6%89%93%E5%8D%B0Java%E6%95%B0%E7%BB%84"><span class="toc-text">2.3 打印Java数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-String%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%8F%AF%E5%8F%98"><span class="toc-text">2.5 String为什么不可变</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-%E8%AF%A6%E8%A7%A3-String-intern-%E6%96%B9%E6%B3%95"><span class="toc-text">2.7 详解 String.intern() 方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-8-String%E3%80%81StringBuilder%E3%80%81StringBuffer"><span class="toc-text">2.8 String、StringBuilder、StringBuffer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-9-String%E7%9B%B8%E7%AD%89%E5%88%A4%E6%96%AD"><span class="toc-text">2.9 String相等判断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-10-String%E6%8B%BC%E6%8E%A5"><span class="toc-text">2.10 String拼接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-11-String%E6%8B%86%E5%88%86"><span class="toc-text">2.11 String拆分</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B"><span class="toc-text">3 面向对象编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-Java%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-text">3.1 Java中的类和对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-Java%E4%B8%AD%E7%9A%84%E5%8C%85"><span class="toc-text">3.2 Java中的包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-Java%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F"><span class="toc-text">3.3 Java中的变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-Java%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">3.4 Java中的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-Java%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-text">3.5 Java可变参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-Java-native%E6%96%B9%E6%B3%95"><span class="toc-text">3.6 Java native方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-Java%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-text">3.7 Java构造方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-8-Java%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">3.8 Java访问权限修饰符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-9-Java%E4%BB%A3%E7%A0%81%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9D%97"><span class="toc-text">3.9 Java代码初始化块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-10-Java%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-text">3.10 Java抽象类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-11-Java%E6%8E%A5%E5%8F%A3"><span class="toc-text">3.11 Java接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-12-Java%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">3.12 Java内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-13-Java%E5%B0%81%E8%A3%85%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81"><span class="toc-text">3.13 Java封装继承多态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-14-Java-this%E5%92%8Csuper%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">3.14 Java this和super关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-15-Java-static%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">3.15 Java static关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-16-Java-final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">3.16 Java final关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-17-Java-instanceof%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">3.17 Java instanceof关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-18-Java%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1"><span class="toc-text">3.18 Java不可变对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-19-Java%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%E5%92%8C%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD"><span class="toc-text">3.19 Java方法重写和方法重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-20-Java%E6%B3%A8%E8%A7%A3"><span class="toc-text">3.20 Java注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-21-Java%E6%9E%9A%E4%B8%BE%EF%BC%88enum%EF%BC%89"><span class="toc-text">3.21 Java枚举（enum）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6"><span class="toc-text">4 Java 集合框架</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-List%E3%80%81Set%E3%80%81Map%E3%80%81%E9%98%9F%E5%88%97%EF%BC%8C%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90"><span class="toc-text">4.1 List、Set、Map、队列，全面解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%8C%E4%BA%86%E8%A7%A3%E4%B8%8B"><span class="toc-text">4.2 时间复杂度，了解下</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-ArrayList%E8%AF%A6%E8%A7%A3%EF%BC%88%E9%99%84%E6%BA%90%E7%A0%81%EF%BC%89"><span class="toc-text">4.3 ArrayList详解（附源码）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-LinkedList%E8%AF%A6%E8%A7%A3%EF%BC%88%E9%99%84%E6%BA%90%E7%A0%81%EF%BC%89"><span class="toc-text">4.4 LinkedList详解（附源码）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-ArrayList%E5%92%8CLinkedList%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">4.5 ArrayList和LinkedList的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-Java%E6%B3%9B%E5%9E%8B%EF%BC%8C%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90"><span class="toc-text">4.6 Java泛型，深入解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7-Iterator%E5%92%8CIterable%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">4.7 Iterator和Iterable的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-8-Java-foreach-%E5%BE%AA%E7%8E%AF%E9%99%B7%E9%98%B1"><span class="toc-text">4.8 Java foreach 循环陷阱</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-9-HashMap%E8%AF%A6%E8%A7%A3%EF%BC%88%E9%99%84%E6%BA%90%E7%A0%81%EF%BC%89"><span class="toc-text">4.9 HashMap详解（附源码）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-10-LinkedHashMap%E8%AF%A6%E8%A7%A3%EF%BC%88%E9%99%84%E6%BA%90%E7%A0%81%EF%BC%89"><span class="toc-text">4.10 LinkedHashMap详解（附源码）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-11-TreeMap%E8%AF%A6%E8%A7%A3%EF%BC%88%E9%99%84%E6%BA%90%E7%A0%81%EF%BC%89"><span class="toc-text">4.11 TreeMap详解（附源码）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-12-%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97ArrayDeque%E8%AF%A6%E8%A7%A3"><span class="toc-text">4.12 双端队列ArrayDeque详解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-13-%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97PriorityQueue%E8%AF%A6%E8%A7%A3"><span class="toc-text">4.13 优先级队列PriorityQueue详解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-14-Comparable%E5%92%8CComparator%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">4.14 Comparable和Comparator的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-Java-IO"><span class="toc-text">5 Java IO</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-IO-%E5%88%86%E7%B1%BB"><span class="toc-text">5.1 IO 分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E6%96%87%E4%BB%B6%E6%B5%81"><span class="toc-text">5.2 文件流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E5%AD%97%E8%8A%82%E6%B5%81"><span class="toc-text">5.3 字节流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="toc-text">5.4 字符流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-text">5.5 缓冲流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6-%E8%BD%AC%E6%8D%A2%E6%B5%81"><span class="toc-text">5.6 转换流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-7-%E6%89%93%E5%8D%B0%E6%B5%81"><span class="toc-text">5.7 打印流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-8-%E5%BA%8F%E5%88%97%E6%B5%81-%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">5.8 序列流(序列化和反序列化)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-9-%E5%BA%8F%E5%88%97%E6%8E%A5%E5%8F%A3Serializable"><span class="toc-text">5.9 序列接口Serializable</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-10-transient%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">5.10 transient关键字</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-text">6 异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90"><span class="toc-text">6.1 Java异常处理全面解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-try-with-resources"><span class="toc-text">6.2 try-with-resources</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%8420%E4%B8%AA%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-text">6.3 异常处理的20个最佳实践</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-%E7%A9%BA%E6%8C%87%E9%92%88%E7%9A%84%E4%BC%A0%E8%AF%B4"><span class="toc-text">6.4 空指针的传说</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5-try-catch%E4%BC%9A%E5%BD%B1%E5%93%8D%E6%80%A7%E8%83%BD%E5%90%97%EF%BC%9F"><span class="toc-text">6.5 try-catch会影响性能吗？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">7 常用工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-Scanner%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">7.1 Scanner工具类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-Arrays%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">7.2 Arrays工具类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-StringUtils%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">7.3 StringUtils工具类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-Objects%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">7.4 Objects工具类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5-Collections%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">7.5 Collections工具类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-6-Hutool%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%BA%93"><span class="toc-text">7.6 Hutool工具类库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-7-Guava%E5%B7%A5%E5%85%B7%E5%BA%93"><span class="toc-text">7.7 Guava工具库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-8-%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">7.8 其他常用工具类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-Java%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">8 Java新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-%E6%8E%8C%E6%8F%A1Stream%E6%B5%81"><span class="toc-text">8.1 掌握Stream流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-Optional%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97"><span class="toc-text">8.2 Optional最佳指南</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BALambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">8.3 深入浅出Lambda表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4-Java-14-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">8.4 Java 14 新特性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-Java-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-text">9 Java 网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-%E4%BA%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text">9.1 了解网络编程的基础知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E6%A0%B8%E5%BF%83%E5%A5%97%E6%8E%A5%E5%AD%97Socket"><span class="toc-text">9.2 网络编程的核心套接字Socket</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-%E7%94%A8Socket%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAHTTP%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-text">9.3 用Socket实现一个HTTP服务器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-Java-NIO"><span class="toc-text">10 Java NIO</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#10-1-NIO%E6%AF%94IO%E5%BC%BA%E5%9C%A8%E5%93%AA%EF%BC%9F"><span class="toc-text">10.1 NIO比IO强在哪？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-2-BIO%E3%80%81NIO-%E5%92%8C-AIO-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">10.2 BIO、NIO 和 AIO 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-3-Buffer%E5%92%8CChannel"><span class="toc-text">10.3 Buffer和Channel</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-4-Paths-%E5%92%8C-Files"><span class="toc-text">10.4 Paths 和 Files</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-5-NIO-%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E7%89%88%E8%81%8A%E5%A4%A9%E5%AE%A4"><span class="toc-text">10.5 NIO 实现简易版聊天室</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-6-Java-IO%E6%A8%A1%E5%9E%8B"><span class="toc-text">10.6 Java IO模型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-Java-%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-text">11 Java 重要知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-1-Java%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-text">11.1 Java命名规范</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-2-%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E5%8F%8A%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E5%85%A8%E6%94%BB%E7%95%A5"><span class="toc-text">11.2 中文乱码及字符编码全攻略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-3-%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Java%E4%B8%AD%E7%9A%84%E6%8B%86%E7%AE%B1%E5%92%8C%E8%A3%85%E7%AE%B1"><span class="toc-text">11.3 深入剖析Java中的拆箱和装箱</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-4-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-text">11.4 深入理解Java浅拷贝与深拷贝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-5-Java-hashCode%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90"><span class="toc-text">11.5 Java hashCode方法解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-6-Java%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%EF%BC%9F"><span class="toc-text">11.6 Java是值传递还是引用传递？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-7-Java%E4%B8%BA%E4%BB%80%E4%B9%88%E6%97%A0%E6%B3%95%E5%AE%9E%E7%8E%B0%E7%9C%9F%E6%AD%A3%E7%9A%84%E6%B3%9B%E5%9E%8B"><span class="toc-text">11.7 Java为什么无法实现真正的泛型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-8-%E6%8E%8C%E6%8F%A1-Java-%E5%8F%8D%E5%B0%84"><span class="toc-text">11.8 掌握 Java 反射</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="toc-text">12 Java并发编程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13-JVM%EF%BC%88Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%89"><span class="toc-text">13 JVM（Java 虚拟机）</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 By 鲸落</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">I wish you to become your own sun, no need to rely on who's light.</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async src="https://cdn1.tianli0.top/npm/vue@2.6.14/dist/vue.min.js"></script><script async src="https://cdn1.tianli0.top/npm/element-ui@2.15.6/lib/index.js"></script><script async src="https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script><script defer type="text/javascript" src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script defer src="https://cdn1.tianli0.top/gh/nextapps-de/winbox/dist/winbox.bundle.min.js"></script><script async src="//at.alicdn.com/t/c/font_4233300_xxm4hpxio1.js"></script><script async src="/js/fps.js"></script><script async src="https://cdn.wpon.cn/2022-sucai/Gold-ingot.js"></script><script defer data-pjax src="/js/cat.js"></script><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><canvas id="snow"></canvas><script defer src="/js/fomal.js"></script><script defer src="/js/cursor.js"></script><script defer src="/live2d-widget/autoload.js"></script><script async src="/js/title.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 190px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 160px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(http://p0.itc.cn/images03/20200525/332e1ea10c634cbfaf0dfc5b69d00a3c.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Docker/&quot;);" href="javascript:void(0);">Docker</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr">Docker</span></li><li class="categoryBar-list-item" style="background:url(http://p8.itc.cn/images03/20200525/377f4f7044fe49b0bb932f43ef4f4891.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Hexo魔改教程/&quot;);" href="javascript:void(0);">Hexo魔改教程</a><span class="categoryBar-list-count">12</span><span class="categoryBar-list-descr">Hexo魔改教程</span></li><li class="categoryBar-list-item" style="background:url(http://p8.itc.cn/images03/20200525/0ed549edde2c4d5eaecc2824e753ca74.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/面试题/&quot;);" href="javascript:void(0);">面试题</a><span class="categoryBar-list-count">10</span><span class="categoryBar-list-descr">MySQL</span></li><li class="categoryBar-list-item" style="background:url(http://p6.itc.cn/images03/20200525/8dedcdf6ace44a50a1deb6a9743821fe.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/MySQL/&quot;);" href="javascript:void(0);">MySQL</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr">面试题</span></li><li class="categoryBar-list-item" style="background:url(http://p8.itc.cn/images03/20200525/5f6cecf10ea04dec9a5d42bf9c4c3739.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/RabbitMQ/&quot;);" href="javascript:void(0);">RabbitMQ</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr">Redis</span></li><li class="categoryBar-list-item" style="background:url(http://p0.itc.cn/images03/20200525/332e1ea10c634cbfaf0dfc5b69d00a3c.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Redis/&quot;);" href="javascript:void(0);">Redis</a><span class="categoryBar-list-count">5</span><span class="categoryBar-list-descr">Java笔试编程真题</span></li><li class="categoryBar-list-item" style="background:url(http://p8.itc.cn/images03/20200525/377f4f7044fe49b0bb932f43ef4f4891.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Kafka/&quot;);" href="javascript:void(0);">Kafka</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">Java数据结构与算法</span></li><li class="categoryBar-list-item" style="background:url(http://p8.itc.cn/images03/20200525/0ed549edde2c4d5eaecc2824e753ca74.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Java笔试编程真题/&quot;);" href="javascript:void(0);">Java笔试编程真题</a><span class="categoryBar-list-count">51</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(http://p6.itc.cn/images03/20200525/8dedcdf6ace44a50a1deb6a9743821fe.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/面试/&quot;);" href="javascript:void(0);">面试</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/设计模式/&quot;);" href="javascript:void(0);">设计模式</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Java数据结构与算法/&quot;);" href="javascript:void(0);">Java数据结构与算法</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/面渣笔记/&quot;);" href="javascript:void(0);">面渣笔记</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var qweather_key = 'b16a1fa0e63c46a4b8f28abfb06ae3fe';
  var gaud_map_key = 'e2b04289e870b005374ee030148d64fd&s=rsv3';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '113.34532,23.15624';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v6.2.0" title=""><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.9.0" title=""><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="https://npm.elemecdn.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.js"></script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/7ec90956.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/7ec90956.html&quot;);" href="javascript:void(0);" alt="">Java进阶之路</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/7ec90956.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/a449f40d.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-22</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/a449f40d.html&quot;);" href="javascript:void(0);" alt="">美的校招笔试编程真题（2023.4.19）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/a449f40d.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/b2891dfd.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-14</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/b2891dfd.html&quot;);" href="javascript:void(0);" alt="">美团校招笔试编程真题（2023.3.11）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/b2891dfd.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/1b4308aa.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-17</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/1b4308aa.html&quot;);" href="javascript:void(0);" alt="">美团校招笔试编程真题（2023.4.8）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/1b4308aa.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/7b50e04c.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/7b50e04c.html&quot;);" href="javascript:void(0);" alt="">美团校招笔试编程真题（2023.5.13）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/7b50e04c.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/f53a714c.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/f53a714c.html&quot;);" href="javascript:void(0);" alt="">美团校招笔试编程真题（2023.4.29）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/f53a714c.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/9a879128.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/9a879128.html&quot;);" href="javascript:void(0);" alt="">美团校招笔试编程真题（2023.4.23）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/9a879128.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/f84cb424.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-17</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/f84cb424.html&quot;);" href="javascript:void(0);" alt="">美团校招笔试编程真题（2023.4.15）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/f84cb424.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/cf815277.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-15</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/cf815277.html&quot;);" href="javascript:void(0);" alt="">美团校招笔试编程真题（2023.3.18）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/cf815277.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/843d6f38.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/843d6f38.html&quot;);" href="javascript:void(0);" alt="">美团校招笔试编程真题及其解析（2023.3.4）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/843d6f38.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/6482affa.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/6482affa.html&quot;);" href="javascript:void(0);" alt="">美团校招笔试编程真题及其解析（2023.3.25）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/6482affa.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/7a556a2f.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-14</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/7a556a2f.html&quot;);" href="javascript:void(0);" alt="">美团2024届秋招笔试编程真题（2023.9.9）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/7a556a2f.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/61f68248.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/61f68248.html&quot;);" href="javascript:void(0);" alt="">美团2024届秋招笔试第四场编程真题（2023.9.2）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/61f68248.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/f51f72fb.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-06</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/f51f72fb.html&quot;);" href="javascript:void(0);" alt="">美团2024届秋招笔试第二场编程真题（2023.8.19）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/f51f72fb.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/5b7a3f2a.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-07</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/5b7a3f2a.html&quot;);" href="javascript:void(0);" alt="">美团2024届秋招笔试第三场编程真题（2023.8.26）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/5b7a3f2a.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/860131f4.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-04</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/860131f4.html&quot;);" href="javascript:void(0);" alt="">美团2024届秋招笔试第一场编程真题（2023.8.12）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/860131f4.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/9ed49519.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/9ed49519.html&quot;);" href="javascript:void(0);" alt="">网易有道校招笔试编程真题及其解析（2023.4.2）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/9ed49519.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/f766fbc2.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/f766fbc2.html&quot;);" href="javascript:void(0);" alt="">科大讯飞校招笔试编程真题（2023.8.31）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/f766fbc2.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/6da30861.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/6da30861.html&quot;);" href="javascript:void(0);" alt="">科大讯飞校招笔试编程真题（2023.7.8）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/6da30861.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/f9fa8a74.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/f9fa8a74.html&quot;);" href="javascript:void(0);" alt="">科大讯飞校招笔试编程真题（2023.7.29）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/f9fa8a74.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2efb0d75.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2efb0d75.html&quot;);" href="javascript:void(0);" alt="">科大讯飞校招笔试编程真题（2023.7.22）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2efb0d75.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/10ab47eb.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/10ab47eb.html&quot;);" href="javascript:void(0);" alt="">科大讯飞校招笔试编程真题（2023.7.1）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/10ab47eb.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/7641fb6a.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/7641fb6a.html&quot;);" href="javascript:void(0);" alt="">科大讯飞校招笔试编程真题（2022.10.14）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/7641fb6a.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/815405c2.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/815405c2.html&quot;);" href="javascript:void(0);" alt="">科大讯飞校招笔试编程真题及其解析（2023.8.13）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/815405c2.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/52772af7.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/52772af7.html&quot;);" href="javascript:void(0);" alt="">科大讯飞校招笔试编程真题及其解析（2023.7.15）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/52772af7.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/a135cfaa.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/a135cfaa.html&quot;);" href="javascript:void(0);" alt="">携程校招笔试编程真题及其解析（2023.9.7）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/a135cfaa.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/b264b8b5.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-26</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/b264b8b5.html&quot;);" href="javascript:void(0);" alt="">携程校招笔试编程真题及其解析（2023.9.21）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/b264b8b5.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/c442a03f.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-26</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/c442a03f.html&quot;);" href="javascript:void(0);" alt="">携程校招笔试编程真题及其解析（2023.5.4）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/c442a03f.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/faa64596.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/faa64596.html&quot;);" href="javascript:void(0);" alt="">携程校招笔试编程真题及其解析（2023.5.25）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/faa64596.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/1b7134f2.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/1b7134f2.html&quot;);" href="javascript:void(0);" alt="">携程校招笔试编程真题及其解析（2023.4.15）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/1b7134f2.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/aeeccc.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/aeeccc.html&quot;);" href="javascript:void(0);" alt="">携程校招笔试编程真题及其解析（2023.3.7）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/aeeccc.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/d3a0cf14.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-26</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/d3a0cf14.html&quot;);" href="javascript:void(0);" alt="">携程校招笔试编程真题及其解析（2023.3.29）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/d3a0cf14.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/cc63a592.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/cc63a592.html&quot;);" href="javascript:void(0);" alt="">携程校招笔试编程真题及其解析（2023.3.16）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/cc63a592.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2ec06a90.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-23</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2ec06a90.html&quot;);" href="javascript:void(0);" alt="">恒生电子校招笔试编程真题（2023.9.22）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2ec06a90.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/acdf6806.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-27</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/acdf6806.html&quot;);" href="javascript:void(0);" alt="">微众银行校招笔试编程真题及其解析（2023.9.3）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/acdf6806.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/7520a94a.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-27</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/7520a94a.html&quot;);" href="javascript:void(0);" alt="">微众银行校招笔试编程真题及其解析（2023.9.13）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/7520a94a.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/ac4bafef.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-27</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/ac4bafef.html&quot;);" href="javascript:void(0);" alt="">微众银行校招笔试编程真题及其解析（2023.4.12）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/ac4bafef.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/70a5bb78.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-11</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/70a5bb78.html&quot;);" href="javascript:void(0);" alt="">广联达校招笔试编程真题及其解析（2023.10.11）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/70a5bb78.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/5357b25a.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-27</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/5357b25a.html&quot;);" href="javascript:void(0);" alt="">微众银行校招笔试编程真题及其解析（2023.4.23）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/5357b25a.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/bad939ec.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-22</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/bad939ec.html&quot;);" href="javascript:void(0);" alt="">小红书校招笔试编程真题（2023.8.6）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/bad939ec.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/92b4cb69.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-22</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/92b4cb69.html&quot;);" href="javascript:void(0);" alt="">小红书校招笔试编程真题（2023.8.19）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/92b4cb69.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/4ce12134.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-22</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/4ce12134.html&quot;);" href="javascript:void(0);" alt="">小红书校招笔试编程真题（2023.7.23）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/4ce12134.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/9578e9c1.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-22</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/9578e9c1.html&quot;);" href="javascript:void(0);" alt="">小红书校招笔试编程真题（2023.4.9）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/9578e9c1.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/befb4d57.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-22</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/befb4d57.html&quot;);" href="javascript:void(0);" alt="">小红书校招笔试编程真题（2023.5.7）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/befb4d57.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/8f70f515.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-22</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/8f70f515.html&quot;);" href="javascript:void(0);" alt="">小红书校招笔试编程真题（2023.3.26）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/8f70f515.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/7d093ba9.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-22</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/7d093ba9.html&quot;);" href="javascript:void(0);" alt="">小红书校招笔试编程真题（2023.4.23）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/7d093ba9.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/68b410aa.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/68b410aa.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2022.9.23）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/68b410aa.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/c2bdd821.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/c2bdd821.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2022.9.21）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/c2bdd821.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/e1169d40.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-10</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/e1169d40.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2022.8.30）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/e1169d40.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/b477f365.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-10</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/b477f365.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2022.11.2）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/b477f365.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/82287452.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/82287452.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2022.10.12）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/82287452.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/3cbc845.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/3cbc845.html&quot;);" href="javascript:void(0);" alt="">Java数据结构与算法</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/3cbc845.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/f9c52cbb.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-19</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/f9c52cbb.html&quot;);" href="javascript:void(0);" alt="">设计模式面试篇-参考回答</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/f9c52cbb.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/eabb6106.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-12</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/eabb6106.html&quot;);" href="javascript:void(0);" alt="">消息中间件面试题-参考回答</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/eabb6106.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/27f853cc.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/27f853cc.html&quot;);" href="javascript:void(0);" alt="">框架篇面试题-参考回答</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/27f853cc.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/6ba374e2.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/6ba374e2.html&quot;);" href="javascript:void(0);" alt="">微服务面试篇-参考回答</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/6ba374e2.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/dbf9d5c9.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/dbf9d5c9.html&quot;);" href="javascript:void(0);" alt="">常见技术场景</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/dbf9d5c9.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/af15ea36.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/af15ea36.html&quot;);" href="javascript:void(0);" alt="">多线程相关面试题</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/af15ea36.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/258353ca.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/258353ca.html&quot;);" href="javascript:void(0);" alt="">kafka深入浅出，快速玩转分布式发布订阅消息系统</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/258353ca.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/6f83b1e4.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/6f83b1e4.html&quot;);" href="javascript:void(0);" alt="">Redis面试题-参考回答</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/6f83b1e4.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/37cf2cfd.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/37cf2cfd.html&quot;);" href="javascript:void(0);" alt="">Redis集群</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/37cf2cfd.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/d2ba1e3f.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/d2ba1e3f.html&quot;);" href="javascript:void(0);" alt="">Redis原理篇</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/d2ba1e3f.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/6bb2589.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-12</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/6bb2589.html&quot;);" href="javascript:void(0);" alt="">Rabbitmq消息中间件（二）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/6bb2589.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/6bb2589.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://source.fomal.cc/img/default_cover_14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-12</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/6bb2589.html&quot;);" href="javascript:void(0);" alt="">Rabbitmq消息中间件（一）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/6bb2589.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/18ab1f25.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/18ab1f25.html&quot;);" href="javascript:void(0);" alt="">MySQL面试篇-参考回答</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/18ab1f25.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/11f76754.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/11f76754.html&quot;);" href="javascript:void(0);" alt="">MySQL进阶篇</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/11f76754.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/337fcc87.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/337fcc87.html&quot;);" href="javascript:void(0);" alt="">MySQL基础篇</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/337fcc87.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/592cf81.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img2.baidu.com/it/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/592cf81.html&quot;);" href="javascript:void(0);" alt="">MySQL运维篇</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/592cf81.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/b481a8d6.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://img0.baidu.com/it/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=889&amp;h=500" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/b481a8d6.html&quot;);" href="javascript:void(0);" alt="">Java集合相关面试题</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/b481a8d6.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/c218eb30.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/c218eb30.html&quot;);" href="javascript:void(0);" alt="">JVM相关面试题</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/c218eb30.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/7eb663f5.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/7eb663f5.html&quot;);" href="javascript:void(0);" alt="">Docker安装OpenResty</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/7eb663f5.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/be6d66dc.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/be6d66dc.html&quot;);" href="javascript:void(0);" alt="">Docker安装Canal</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/be6d66dc.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/a6573b44.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/a6573b44.html&quot;);" href="javascript:void(0);" alt="">Centos7安装Docker</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/a6573b44.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/d3404069.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://pic2.zhimg.com/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/d3404069.html&quot;);" href="javascript:void(0);" alt="">Redis高级篇</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/d3404069.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/a6b15897.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/a6b15897.html&quot;);" href="javascript:void(0);" alt="">Redis实战篇</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/a6b15897.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/4604f75b.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://images.wallpaperscraft.com/image/single/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-01</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/4604f75b.html&quot;);" href="javascript:void(0);" alt="">Redis基础篇</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/4604f75b.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '1s');
    arr[i].setAttribute('data-wow-offset', '100');
    arr[i].setAttribute('data-wow-iteration', '2');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --></body></html>