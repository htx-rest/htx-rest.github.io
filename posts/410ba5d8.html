<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java进阶之路（二） | 鲸落</title><meta name="author" content="鲸落"><meta name="copyright" content="鲸落"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="4 Java 集合框架4.1 List、Set、Map、队列，全面解析眼瞅着三妹的王者荣耀杀得正嗨，我趁机喊到：“别打了，三妹，我们来一起学习 Java 的集合框架吧。” “才不要呢，等我打完这一局啊。”三妹倔强地说。 “好吧。”我只好摊摊手地说，“那我先画张集合框架的结构图等着你。”  “完了没？三妹。” “完了好一会儿了，二哥，你图画得真慢，让我瞧瞧怎么样？” “害，图要画得清晰明了，不容易的">
<meta property="og:type" content="article">
<meta property="og:title" content="Java进阶之路（二）">
<meta property="og:url" content="https://htx-rest.github.io/posts/410ba5d8.html">
<meta property="og:site_name" content="鲸落">
<meta property="og:description" content="4 Java 集合框架4.1 List、Set、Map、队列，全面解析眼瞅着三妹的王者荣耀杀得正嗨，我趁机喊到：“别打了，三妹，我们来一起学习 Java 的集合框架吧。” “才不要呢，等我打完这一局啊。”三妹倔强地说。 “好吧。”我只好摊摊手地说，“那我先画张集合框架的结构图等着你。”  “完了没？三妹。” “完了好一会儿了，二哥，你图画得真慢，让我瞧瞧怎么样？” “害，图要画得清晰明了，不容易的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://htx-rest.github.io/assets/u=595920241,2439700946&fm=253&fmt=auto&app=120&f=JPEG.webp">
<meta property="article:published_time" content="2023-10-13T12:18:01.000Z">
<meta property="article:modified_time" content="2023-10-16T02:50:57.428Z">
<meta property="article:author" content="鲸落">
<meta property="article:tag" content="Java集合框架">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://htx-rest.github.io/assets/u=595920241,2439700946&fm=253&fmt=auto&app=120&f=JPEG.webp"><link rel="shortcut icon" href="/"><link rel="canonical" href="https://htx-rest.github.io/posts/410ba5d8.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java进阶之路（二）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-10-16 10:50:57'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_4233300_xxm4hpxio1.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/element-ui@2.15.6/packages/theme-chalk/lib/index.css"><script src="https://npm.elemecdn.com/echarts@4.9.0/dist/echarts.min.js"></script><style id="themeColor"></style><style id="rightSide"></style><style id="transPercent"></style><style id="blurNum"></style><style id="settingStyle"></style><span id="fps"></span><style id="defineBg"></style><style id="menu_shadow"></style><div id="myscoll"></div><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/assets/mmexport1694508539292.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">138</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">171</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-youhuawenzhang"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-guidang"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei"></i><span> 分类</span></a></li><li><a class="site-page child" href="javascript:randomPost();"><i class="fa-fw iconfont icon-wode-zuji-copy"></i><span> 随便逛逛</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-xiuxianyinpin"></i><span> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/life/music/"><i class="fa-fw iconfont icon-tool"></i><span> 八音盒</span></a></li><li><a class="site-page child" href="/life/movies/"><i class="fa-fw iconfont icon-dianying"></i><span> 影院</span></a></li><li><a class="site-page child" href="/life/games/"><i class="fa-fw iconfont icon-youxi"></i><span> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-baoxiang21"></i><span> 八宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/box/gallery/"><i class="fa-fw iconfont icon-hualang"></i><span> 画廊</span></a></li><li><a class="site-page child" href="/box/animation/"><i class="fa-fw iconfont icon-donghua"></i><span> 动画</span></a></li><li><a class="site-page child" href="/box/nav/"><i class="fa-fw iconfont icon-a-06-wangzhidaohang"></i><span> 网址导航</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-tubiaozhizuomoban1"></i><span> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/social/fcircle/"><i class="fa-fw iconfont icon-iconfontzhizuobiaozhunbduan36"></i><span> 朋友圈</span></a></li><li><a class="site-page child" href="/comments/"><i class="fa-fw iconfont icon-liuyanban"></i><span> 留言板</span></a></li><li><a class="site-page child" href="/social/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-a-06-wangzhidaohang"></i><span> 网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/site/census/"><i class="fa-fw iconfont icon-a-06-wangzhidaohang"></i><span> 网站统计</span></a></li><li><a class="site-page child" href="/site/echarts/"><i class="fa-fw iconfont icon-tongji"></i><span> 文章统计</span></a></li><li><a class="site-page child" href="/site/time/"><i class="fa-fw iconfont icon-shalou"></i><span> 旧时光</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-geren"></i><span> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/personal/bb/"><i class="fa-fw iconfont icon-icon_liuyan"></i><span> 唠叨</span></a></li><li><a class="site-page child" href="/personal/love/"><i class="fa-fw iconfont icon-valentine_-email-love-message-send"></i><span> 恋爱小屋</span></a></li><li><a class="site-page child" href="/personal/about/"><i class="fa-fw iconfont icon-icon-lark-logo-old"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp')"><nav id="nav"><span id="blog-info"><a href="/" title="鲸落"><span class="site-name">鲸落</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-youhuawenzhang"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-guidang"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw iconfont icon-biaoqian"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei"></i><span> 分类</span></a></li><li><a class="site-page child" href="javascript:randomPost();"><i class="fa-fw iconfont icon-wode-zuji-copy"></i><span> 随便逛逛</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-xiuxianyinpin"></i><span> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/life/music/"><i class="fa-fw iconfont icon-tool"></i><span> 八音盒</span></a></li><li><a class="site-page child" href="/life/movies/"><i class="fa-fw iconfont icon-dianying"></i><span> 影院</span></a></li><li><a class="site-page child" href="/life/games/"><i class="fa-fw iconfont icon-youxi"></i><span> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-baoxiang21"></i><span> 八宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/box/gallery/"><i class="fa-fw iconfont icon-hualang"></i><span> 画廊</span></a></li><li><a class="site-page child" href="/box/animation/"><i class="fa-fw iconfont icon-donghua"></i><span> 动画</span></a></li><li><a class="site-page child" href="/box/nav/"><i class="fa-fw iconfont icon-a-06-wangzhidaohang"></i><span> 网址导航</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-tubiaozhizuomoban1"></i><span> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/social/fcircle/"><i class="fa-fw iconfont icon-iconfontzhizuobiaozhunbduan36"></i><span> 朋友圈</span></a></li><li><a class="site-page child" href="/comments/"><i class="fa-fw iconfont icon-liuyanban"></i><span> 留言板</span></a></li><li><a class="site-page child" href="/social/link/"><i class="fa-fw iconfont icon-lianjie"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-a-06-wangzhidaohang"></i><span> 网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/site/census/"><i class="fa-fw iconfont icon-a-06-wangzhidaohang"></i><span> 网站统计</span></a></li><li><a class="site-page child" href="/site/echarts/"><i class="fa-fw iconfont icon-tongji"></i><span> 文章统计</span></a></li><li><a class="site-page child" href="/site/time/"><i class="fa-fw iconfont icon-shalou"></i><span> 旧时光</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-geren"></i><span> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/personal/bb/"><i class="fa-fw iconfont icon-icon_liuyan"></i><span> 唠叨</span></a></li><li><a class="site-page child" href="/personal/love/"><i class="fa-fw iconfont icon-valentine_-email-love-message-send"></i><span> 恋爱小屋</span></a></li><li><a class="site-page child" href="/personal/about/"><i class="fa-fw iconfont icon-icon-lark-logo-old"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java进阶之路（二）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-10-13T12:18:01.000Z" title="发表于 2023-10-13 20:18:01">2023-10-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-10-16T02:50:57.428Z" title="更新于 2023-10-16 10:50:57">2023-10-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E6%B8%A3%E7%AC%94%E8%AE%B0/">面渣笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">65k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>238分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java进阶之路（二）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="4-Java-集合框架"><a href="#4-Java-集合框架" class="headerlink" title="4 Java 集合框架"></a>4 Java 集合框架</h1><h2 id="4-1-List、Set、Map、队列，全面解析"><a href="#4-1-List、Set、Map、队列，全面解析" class="headerlink" title="4.1 List、Set、Map、队列，全面解析"></a>4.1 List、Set、Map、队列，全面解析</h2><p>眼瞅着三妹的王者荣耀杀得正嗨，我趁机喊到：“别打了，三妹，我们来一起学习 Java 的集合框架吧。”</p>
<p>“才不要呢，等我打完这一局啊。”三妹倔强地说。</p>
<p>“好吧。”我只好摊摊手地说，“那我先画张集合框架的结构图等着你。”</p>
<p><img src="\assets\note\image-20231009161608357.png" alt="image-20231009161608357"></p>
<p>“完了没？三妹。”</p>
<p>“完了好一会儿了，二哥，你图画得真慢，让我瞧瞧怎么样？”</p>
<p>“害，图要画得清晰明了，不容易的。三妹，你瞧，不错吧。”</p>
<p>“哇，果然很棒，哥，你可真认真！”</p>
<p>“我来简单介绍一下吧，Java 集合框架可以分为两条大的支线：”</p>
<ul>
<li>Collection，主要由 List、Set、Queue 组成，List 代表有序、可重复的集合，典型代表就是封装了动态数组的 ArrayList 和封装了链表的 LinkedList；Set 代表无序、不可重复的集合，典型代表就是 HashSet 和 TreeSet；Queue 代表队列，典型代表就是双端队列 ArrayDeque，以及优先级队列 PriorityQueue。</li>
<li>Map，代表键值对的集合，典型代表就是 HashMap。</li>
</ul>
<p><strong>01、List </strong></p>
<p>List 的特点是存取有序，可以存放重复的元素，可以用下标对元素进行操作。</p>
<p><strong>1）ArrayList </strong></p>
<p>先来一段 ArrayList 的增删改查，学会用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个集合</span><br><span class="line">ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">// 添加元素</span><br><span class="line">list.add(&quot;王二&quot;);</span><br><span class="line">list.add(&quot;沉默&quot;);</span><br><span class="line">list.add(&quot;陈清扬&quot;);</span><br><span class="line">// 遍历集合 for 循环</span><br><span class="line">for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">    String s = list.get(i);</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line">// 遍历集合 for each</span><br><span class="line">for (String s : list) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line">// 删除元素</span><br><span class="line">list.remove(1);</span><br><span class="line">// 遍历集合</span><br><span class="line">for (String s : list) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line">// 修改元素</span><br><span class="line">list.set(1, &quot;王二狗&quot;);</span><br><span class="line">// 遍历集合</span><br><span class="line">for (String s : list) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单介绍一下 ArrayList 的特征，后面还会详细讲。</p>
<ul>
<li>ArrayList 是由数组实现的，支持随机存取，也就是可以通过下标直接存取元素；</li>
<li>从尾部插入和删除元素会比较快捷，从中间插入和删除元素会比较低效，因为涉及到数组元素的复制和移动；</li>
<li>如果内部数组的容量不足时会自动扩容，因此当元素非常庞大的时候，效率会比较低。</li>
</ul>
<p><strong>2）LinkedList </strong></p>
<p>同样先来一段 LinkedList 的增删改查，和 ArrayList 几乎没什么差别。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个集合</span><br><span class="line">LinkedList&lt;String&gt; list = new LinkedList&lt;String&gt;();</span><br><span class="line">// 添加元素</span><br><span class="line">list.add(&quot;王二&quot;);</span><br><span class="line">list.add(&quot;沉默&quot;);</span><br><span class="line">list.add(&quot;陈清扬&quot;);</span><br><span class="line">// 遍历集合 for 循环</span><br><span class="line">for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">    String s = list.get(i);</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line">// 遍历集合 for each</span><br><span class="line">for (String s : list) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line">// 删除元素</span><br><span class="line">list.remove(1);</span><br><span class="line">// 遍历集合</span><br><span class="line">for (String s : list) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line">// 修改元素</span><br><span class="line">list.set(1, &quot;王二狗&quot;);</span><br><span class="line">// 遍历集合</span><br><span class="line">for (String s : list) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过，LinkedList 和 ArrayList 仍然有较大的不同，后面也会详细地讲。</p>
<ul>
<li>LinkedList 是由双向链表实现的，不支持随机存取，只能从一端开始遍历，直到找到需要的元素后返回；</li>
<li>任意位置插入和删除元素都很方便，因为只需要改变前一个节点和后一个节点的引用即可，不像 ArrayList 那样需要复制和移动数组元素；</li>
<li>因为每个元素都存储了前一个和后一个节点的引用，所以相对来说，占用的内存空间会比 ArrayList 多一些。</li>
</ul>
<p><strong>3）Vector 和 Stack </strong></p>
<p>List 的实现类还有一个 Vector，是一个元老级的类，比 ArrayList 出现得更早。ArrayList 和 Vector 非常相似，只不过 Vector 是线程安全的，像 get、set、add 这些方法都加了 synchronized 关键字，就导致执行执行效率会比较低，所以现在已经很少用了。</p>
<p>我就不写太多代码了，只看一下 add 方法的源码就明白了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public synchronized boolean add(E e) &#123;</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种加了同步方法的类，注定会被淘汰掉，就像StringBuilder取代StringBuffer那样。JDK 源码也说了：</p>
<blockquote>
<p>如果不需要线程安全，建议使用ArrayList代替Vector。</p>
</blockquote>
<p><img src="\assets\note\image-20231009162149917.png" alt="image-20231009162149917"></p>
<p>Stack 是 Vector 的一个子类，本质上也是由动态数组实现的，只不过还实现了先进后出的功能（在 get、set、add 方法的基础上追加了 pop「返回并移除栈顶的元素」、peek「只返回栈顶元素」等方法），所以叫栈。</p>
<p>下面是这两个方法的源码，增删改查我就不写了，和 ArrayList 和 LinkedList 几乎一样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public synchronized E pop() &#123;</span><br><span class="line">    E       obj;</span><br><span class="line">    int     len = size();</span><br><span class="line">    obj = peek();</span><br><span class="line">    removeElementAt(len - 1);</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br><span class="line">public synchronized E peek() &#123;</span><br><span class="line">    int     len = size();</span><br><span class="line">    if (len == 0)</span><br><span class="line">        throw new EmptyStackException();</span><br><span class="line">    return elementAt(len - 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过，由于 Stack 执行效率比较低（方法上同样加了 synchronized 关键字），就被双端队列 ArrayDeque 取代了（下面会介绍）。</p>
<p><strong>02、Set </strong></p>
<p>Set 的特点是存取无序，不可以存放重复的元素，不可以用下标对元素进行操作，和 List 有很多不同。</p>
<p><strong>1）HashSet </strong></p>
<p>HashSet 其实是由 HashMap 实现的，只不过值由一个固定的 Object 对象填充，而键用于操作。来简单看一下它的源码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class HashSet&lt;E&gt;</span><br><span class="line">    extends AbstractSet&lt;E&gt;</span><br><span class="line">    implements Set&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    private transient HashMap&lt;E,Object&gt; map;</span><br><span class="line">    // Dummy value to associate with an Object in the backing Map</span><br><span class="line">    private static final Object PRESENT = new Object();</span><br><span class="line">    public HashSet() &#123;</span><br><span class="line">        map = new HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean add(E e) &#123;</span><br><span class="line">        return map.put(e, PRESENT)==null;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean remove(Object o) &#123;</span><br><span class="line">        return map.remove(o)==PRESENT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际开发中，HashSet 并不常用，比如，如果我们需要按照顺序存储一组元素，那么ArrayList和LinkedList可能更适合；如果我们需要存储键值对并根据键进行查找，那么HashMap可能更适合。</p>
<p>当然，在某些情况下，HashSet仍然是最好的选择。例如，当我们需要快速查找一个元素是否存在于某个集合中，并且我们不需要对元素进行排序时，HashSet可以提供高效的性能。</p>
<p>来一段增删改查体验一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个新的HashSet</span><br><span class="line">HashSet&lt;String&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">// 添加元素</span><br><span class="line">set.add(&quot;沉默&quot;);</span><br><span class="line">set.add(&quot;王二&quot;);</span><br><span class="line">set.add(&quot;陈清扬&quot;);</span><br><span class="line">// 输出HashSet的元素个数</span><br><span class="line">System.out.println(&quot;HashSet size: &quot; + set.size()); // output: 3</span><br><span class="line">// 判断元素是否存在于HashSet中</span><br><span class="line">boolean containsWanger = set.contains(&quot;王二&quot;);</span><br><span class="line">System.out.println(&quot;Does set contain &#x27;王二&#x27;? &quot; + containsWanger); // output: true</span><br><span class="line">// 删除元素</span><br><span class="line">boolean removeWanger = set.remove(&quot;王二&quot;);</span><br><span class="line">System.out.println(&quot;Removed &#x27;王二&#x27;? &quot; + removeWanger); // output: true</span><br><span class="line">// 修改元素，需要先删除后添加</span><br><span class="line">boolean removeChenmo = set.remove(&quot;沉默&quot;);</span><br><span class="line">boolean addBuChenmo = set.add(&quot;不沉默&quot;);</span><br><span class="line">System.out.println(&quot;Modified set? &quot; + (removeChenmo &amp;&amp; addBuChenmo)); // output: true</span><br><span class="line">// 输出修改后的HashSet</span><br><span class="line">System.out.println(&quot;HashSet after modification: &quot; + set); // output: [陈清扬, 不沉默]</span><br></pre></td></tr></table></figure>
<p><strong>2）LinkedHashSet </strong></p>
<p>LinkedHashSet 虽然继承自 HashSet，其实是由 LinkedHashMap 实现的。</p>
<p>这是 LinkedHashSet 的无参构造方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public LinkedHashSet() &#123;</span><br><span class="line">    super(16, .75f, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>super 的意思是它将调用父类的 HashSet 的一个有参构造方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123;</span><br><span class="line">    map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到 LinkedHashMap 了吧，这个我们后面会去讲。</p>
<p>好吧，来看一段 LinkedHashSet 的增删改查吧。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">LinkedHashSet&lt;String&gt; set = new LinkedHashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">// 添加元素</span><br><span class="line">set.add(&quot;沉默&quot;);</span><br><span class="line">set.add(&quot;王二&quot;);</span><br><span class="line">set.add(&quot;陈清扬&quot;);</span><br><span class="line"></span><br><span class="line">// 删除元素</span><br><span class="line">set.remove(&quot;王二&quot;);</span><br><span class="line"></span><br><span class="line">// 修改元素</span><br><span class="line">set.remove(&quot;沉默&quot;);</span><br><span class="line">set.add(&quot;沉默的力量&quot;);</span><br><span class="line"></span><br><span class="line">// 查找元素</span><br><span class="line">boolean hasChenQingYang = set.contains(&quot;陈清扬&quot;);</span><br><span class="line">System.out.println(&quot;set包含陈清扬吗？&quot; + hasChenQingYang);</span><br></pre></td></tr></table></figure>
<p>在以上代码中，我们首先创建了一个LinkedHashSet对象，然后使用add方法依次添加了三个元素：沉默、王二和陈清扬。接着，我们使用remove方法删除了王二这个元素，并使用remove和add方法修改了沉默这个元素。最后，我们使用contains方法查找了陈清扬这个元素是否存在于set中，并打印了结果。</p>
<p>LinkedHashSet是一种基于哈希表实现的Set接口，它继承自HashSet，并且使用链表维护了元素的插入顺序。因此，它既具有HashSet的快速查找、插入和删除操作的优点，又可以维护元素的插入顺序。</p>
<p><strong>3）TreeSet </strong></p>
<p>“二哥，不用你讲了，我能猜到，TreeSet 是由 TreeMap（后面会讲） 实现的，只不过同样操作的键位，值由一个固定的 Object 对象填充。”</p>
<p>哇，三妹都学会了推理。</p>
<p>是的，与 TreeMap 相似，TreeSet 是一种基于红黑树实现的有序集合，它实现了 SortedSet 接口，可以自动对集合中的元素进行排序。按照键的自然顺序或指定的比较器顺序进行排序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 TreeSet 对象</span><br><span class="line">TreeSet&lt;String&gt; set = new TreeSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">// 添加元素</span><br><span class="line">set.add(&quot;沉默&quot;);</span><br><span class="line">set.add(&quot;王二&quot;);</span><br><span class="line">set.add(&quot;陈清扬&quot;);</span><br><span class="line">System.out.println(set); // 输出 [沉默, 王二, 陈清扬]</span><br><span class="line"></span><br><span class="line">// 删除元素</span><br><span class="line">set.remove(&quot;王二&quot;);</span><br><span class="line">System.out.println(set); // 输出 [沉默, 陈清扬]</span><br><span class="line"></span><br><span class="line">// 修改元素：TreeSet 中的元素不支持直接修改，需要先删除再添加</span><br><span class="line">set.remove(&quot;陈清扬&quot;);</span><br><span class="line">set.add(&quot;陈青阳&quot;);</span><br><span class="line">System.out.println(set); // 输出 [沉默, 陈青阳]</span><br><span class="line"></span><br><span class="line">// 查找元素</span><br><span class="line">System.out.println(set.contains(&quot;沉默&quot;)); // 输出 true</span><br><span class="line">System.out.println(set.contains(&quot;王二&quot;)); // 输出 false</span><br></pre></td></tr></table></figure>
<p>需要注意的是，TreeSet 不允许插入 null 元素，否则会抛出 NullPointerException 异常。</p>
<p>“总体上来说，Set 集合不是关注的重点，因为底层都是由 Map 实现的，为什么要用 Map 实现呢？三妹你能猜到原因吗？”</p>
<p>“让我想想。”</p>
<p>“嗯？难道是因为 Map 的键不允许重复、无序吗？”老天，竟然被三妹猜到了。</p>
<p>“是的，你这水平长进了呀，三妹。”</p>
<p><strong>03、Queue </strong></p>
<p>Queue，也就是队列，通常遵循先进先出（FIFO）的原则，新元素插入到队列的尾部，访问元素返回队列的头部。</p>
<p><strong>1）ArrayDeque </strong></p>
<p>从名字上可以看得出，ArrayDeque 是一个基于数组实现的双端队列，为了满足可以同时在数组两端插入或删除元素的需求，数组必须是循环的，也就是说数组的任何一点都可以被看作是起点或者终点。</p>
<p>这是一个包含了 4 个元素的双端队列，和一个包含了 5 个元素的双端队列。</p>
<p><img src="\assets\note\image-20231010092447145.png" alt="image-20231010092447145"></p>
<p>head 指向队首的第一个有效的元素，tail 指向队尾第一个可以插入元素的空位，因为是循环数组，所以 head 不一定从是从 0 开始，tail 也不一定总是比 head 大。</p>
<p>来一段ArrayDeque的增删改查吧。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个ArrayDeque</span><br><span class="line">ArrayDeque&lt;String&gt; deque = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">// 添加元素</span><br><span class="line">deque.add(&quot;沉默&quot;);</span><br><span class="line">deque.add(&quot;王二&quot;);</span><br><span class="line">deque.add(&quot;陈清扬&quot;);</span><br><span class="line"></span><br><span class="line">// 删除元素</span><br><span class="line">deque.remove(&quot;王二&quot;);</span><br><span class="line"></span><br><span class="line">// 修改元素</span><br><span class="line">deque.remove(&quot;沉默&quot;);</span><br><span class="line">deque.add(&quot;沉默的力量&quot;);</span><br><span class="line"></span><br><span class="line">// 查找元素</span><br><span class="line">boolean hasChenQingYang = deque.contains(&quot;陈清扬&quot;);</span><br><span class="line">System.out.println(&quot;deque包含陈清扬吗？&quot; + hasChenQingYang);</span><br></pre></td></tr></table></figure>
<p><strong>2）LinkedList </strong></p>
<p>LinkedList 一般应该归在 List 下，只不过，它也实现了 Deque 接口，可以作为队列来使用。等于说，LinkedList 同时实现了 Stack、Queue、PriorityQueue 的所有功能。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedList&lt;E&gt;</span><br><span class="line">    extends AbstractSequentialList&lt;E&gt;</span><br><span class="line">    implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>换句话说，LinkedList 和 ArrayDeque 都是 Java 集合框架中的双向队列（deque），它们都支持在队列的两端进行元素的插入和删除操作。不过，LinkedList 和 ArrayDeque 在实现上有一些不同：</p>
<ul>
<li>底层实现方式不同：LinkedList 是基于链表实现的，而 ArrayDeque 是基于数组实现的。</li>
<li>随机访问的效率不同：由于底层实现方式的不同，LinkedList 对于随机访问的效率较低，时间复杂度为 O(n)，而 ArrayDeque 可以通过下标随机访问元素，时间复杂度为 O(1)。</li>
<li>迭代器的效率不同：LinkedList 对于迭代器的效率比较低，因为需要通过链表进行遍历，时间复杂度为 O(n)，而 ArrayDeque 的迭代器效率比较高，因为可以直接访问数组中的元素，时间复杂度为 O(1)。</li>
<li>内存占用不同：由于 LinkedList 是基于链表实现的，它在存储元素时需要额外的空间来存储链表节点，因此内存占用相对较高，而 ArrayDeque 是基于数组实现的，内存占用相对较低。</li>
</ul>
<p>因此，在选择使用 LinkedList 还是 ArrayDeque 时，需要根据具体的业务场景和需求来选择。如果需要在双向队列的两端进行频繁的插入和删除操作，并且需要随机访问元素，可以考虑使用 ArrayDeque；如果需要在队列中间进行频繁的插入和删除操作，可以考虑使用 LinkedList。</p>
<p>来一段 LinkedList 作为队列时候的增删改查吧，注意和它作为 List 的时候有很大的不同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 LinkedList 对象</span><br><span class="line">LinkedList&lt;String&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">// 添加元素</span><br><span class="line">queue.offer(&quot;沉默&quot;);</span><br><span class="line">queue.offer(&quot;王二&quot;);</span><br><span class="line">queue.offer(&quot;陈清扬&quot;);</span><br><span class="line">System.out.println(queue); // 输出 [沉默, 王二, 陈清扬]</span><br><span class="line"></span><br><span class="line">// 删除元素</span><br><span class="line">queue.poll();</span><br><span class="line">System.out.println(queue); // 输出 [王二, 陈清扬]</span><br><span class="line"></span><br><span class="line">// 修改元素：LinkedList 中的元素不支持直接修改，需要先删除再添加</span><br><span class="line">String first = queue.poll();</span><br><span class="line">queue.offer(&quot;王大二&quot;);</span><br><span class="line">System.out.println(queue); // 输出 [陈清扬, 王大二]</span><br><span class="line"></span><br><span class="line">// 查找元素：LinkedList 中的元素可以使用 get() 方法进行查找</span><br><span class="line">System.out.println(queue.get(0)); // 输出 陈清扬</span><br><span class="line">System.out.println(queue.contains(&quot;沉默&quot;)); // 输出 false</span><br><span class="line"></span><br><span class="line">// 查找元素：使用迭代器的方式查找陈清扬</span><br><span class="line">// 使用迭代器依次遍历元素并查找</span><br><span class="line">Iterator&lt;String&gt; iterator = queue.iterator();</span><br><span class="line">while (iterator.hasNext()) &#123;</span><br><span class="line">    String element = iterator.next();</span><br><span class="line">    if (element.equals(&quot;陈清扬&quot;)) &#123;</span><br><span class="line">        System.out.println(&quot;找到了：&quot; + element);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用 LinkedList 作为队列时，可以使用 offer() 方法将元素添加到队列的末尾，使用 poll() 方法从队列的头部删除元素。另外，由于 LinkedList 是链表结构，不支持随机访问元素，因此不能使用下标访问元素，需要使用迭代器或者 poll() 方法依次遍历元素。</p>
<p><strong>3）PriorityQueue </strong></p>
<p>PriorityQueue 是一种优先级队列，它的出队顺序与元素的优先级有关，执行 remove 或者 poll 方法，返回的总是优先级最高的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 PriorityQueue 对象</span><br><span class="line">PriorityQueue&lt;String&gt; queue = new PriorityQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">// 添加元素</span><br><span class="line">queue.offer(&quot;沉默&quot;);</span><br><span class="line">queue.offer(&quot;王二&quot;);</span><br><span class="line">queue.offer(&quot;陈清扬&quot;);</span><br><span class="line">System.out.println(queue); // 输出 [沉默, 王二, 陈清扬]</span><br><span class="line"></span><br><span class="line">// 删除元素</span><br><span class="line">queue.poll();</span><br><span class="line">System.out.println(queue); // 输出 [王二, 陈清扬]</span><br><span class="line"></span><br><span class="line">// 修改元素：PriorityQueue 不支持直接修改元素，需要先删除再添加</span><br><span class="line">String first = queue.poll();</span><br><span class="line">queue.offer(&quot;张三&quot;);</span><br><span class="line">System.out.println(queue); // 输出 [张三, 陈清扬]</span><br><span class="line"></span><br><span class="line">// 查找元素：PriorityQueue 不支持随机访问元素，只能访问队首元素</span><br><span class="line">System.out.println(queue.peek()); // 输出 张三</span><br><span class="line">System.out.println(queue.contains(&quot;陈清扬&quot;)); // 输出 true</span><br><span class="line"></span><br><span class="line">// 通过 for 循环的方式查找陈清扬</span><br><span class="line">for (String element : queue) &#123;</span><br><span class="line">    if (element.equals(&quot;陈清扬&quot;)) &#123;</span><br><span class="line">        System.out.println(&quot;找到了：&quot; + element);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要想有优先级，元素就需要实现 Comparable 接口或者 Comparator 接口（我们后面会讲）。</p>
<p>这里先来一段通过实现 Comparator 接口按照年龄姓名排序的优先级队列吧。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Comparator;</span><br><span class="line">import java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line">class Student &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int chineseScore;</span><br><span class="line">    private int mathScore;</span><br><span class="line">    </span><br><span class="line">    public Student(String name, int chineseScore, int mathScore) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.chineseScore = chineseScore;</span><br><span class="line">        this.mathScore = mathScore;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int getChineseScore() &#123;</span><br><span class="line">        return chineseScore;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int getMathScore() &#123;</span><br><span class="line">        return mathScore;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Student&#123;&quot; +</span><br><span class="line">                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, 总成绩=&quot; + (chineseScore + mathScore) +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class StudentComparator implements Comparator&lt;Student&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(Student s1, Student s2) &#123;</span><br><span class="line">        // 比较总成绩</span><br><span class="line">        return Integer.compare(s2.getChineseScore() + s2.getMathScore(),</span><br><span class="line">                s1.getChineseScore() + s1.getMathScore());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class PriorityQueueComparatorExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 创建一个按照总成绩排序的优先级队列</span><br><span class="line">        PriorityQueue&lt;Student&gt; queue = new PriorityQueue&lt;&gt;(new StudentComparator());</span><br><span class="line">        // 添加元素</span><br><span class="line">        queue.offer(new Student(&quot;王二&quot;, 80, 90));</span><br><span class="line">        System.out.println(queue);</span><br><span class="line">        queue.offer(new Student(&quot;陈清扬&quot;, 95, 95));</span><br><span class="line">        System.out.println(queue);</span><br><span class="line">        queue.offer(new Student(&quot;小驼铃&quot;, 90, 95));</span><br><span class="line">        System.out.println(queue);</span><br><span class="line">        queue.offer(new Student(&quot;沉默&quot;, 90, 80));</span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            System.out.print(queue.poll() + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Student 是一个学生对象，包含姓名、语文成绩和数学成绩。</p>
<p>StudentComparator 实现了 Comparator 接口，对总成绩做了一个排序。</p>
<p>PriorityQueue 是一个优先级队列，参数为 StudentComparator，然后我们添加了 4 个学生对象进去。</p>
<p>来看一下输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Student&#123;name=&#x27;王二&#x27;, 总成绩=170&#125;]</span><br><span class="line">[Student&#123;name=&#x27;陈清扬&#x27;, 总成绩=190&#125;, Student&#123;name=&#x27;王二&#x27;, 总成绩=170&#125;]</span><br><span class="line">[Student&#123;name=&#x27;陈清扬&#x27;, 总成绩=190&#125;, Student&#123;name=&#x27;王二&#x27;, 总成绩=170&#125;, Student&#123;name=&#x27;小</span><br><span class="line">驼铃&#x27;, 总成绩=185&#125;]</span><br><span class="line">Student&#123;name=&#x27;陈清扬&#x27;, 总成绩=190&#125; Student&#123;name=&#x27;小驼铃&#x27;, 总成绩=185&#125; Student&#123;name=&#x27;沉</span><br><span class="line">默&#x27;, 总成绩=170&#125; Student&#123;name=&#x27;王二&#x27;, 总成绩=170&#125; </span><br></pre></td></tr></table></figure>
<p>我们使用 offer 方法添加元素，最后用 while 循环遍历元素（通过 poll 方法取出元素），从结果可以看得出，PriorityQueue按照学生的总成绩由高到低进行了排序。</p>
<p><strong>04、Map </strong></p>
<p>Map 保存的是键值对，键要求保持唯一性，值可以重复。</p>
<p><strong>1）HashMap </strong></p>
<p>HashMap 实现了 Map 接口，可以根据键快速地查找对应的值——通过哈希函数将键映射到哈希表中的一个索引位置，从而实现快速访问。后面会详细聊到。</p>
<p>这里先大致了解一下 HashMap 的特点：</p>
<ul>
<li>HashMap 中的键和值都可以为 null。如果键为 null，则将该键映射到哈希表的第一个位置。</li>
<li>可以使用迭代器或者 forEach 方法遍历 HashMap 中的键值对。</li>
<li>HashMap 有一个初始容量和一个负载因子。初始容量是指哈希表的初始大小，负载因子是指哈希表在扩容之前可以存储的键值对数量与哈希表大小的比率。默认的初始容量是 16，负载因子是 0.75。</li>
</ul>
<p>来个简单的增删改查吧。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 HashMap 对象</span><br><span class="line">HashMap&lt;String, String&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">// 添加键值对</span><br><span class="line">hashMap.put(&quot;沉默&quot;, &quot;cenzhong&quot;);</span><br><span class="line">hashMap.put(&quot;王二&quot;, &quot;wanger&quot;);</span><br><span class="line">hashMap.put(&quot;陈清扬&quot;, &quot;chenqingyang&quot;);</span><br><span class="line"></span><br><span class="line">// 获取指定键的值</span><br><span class="line">String value1 = hashMap.get(&quot;沉默&quot;);</span><br><span class="line">System.out.println(&quot;沉默对应的值为：&quot; + value1);</span><br><span class="line"></span><br><span class="line">// 修改键对应的值</span><br><span class="line">hashMap.put(&quot;沉默&quot;, &quot;chenmo&quot;);</span><br><span class="line">String value2 = hashMap.get(&quot;沉默&quot;);</span><br><span class="line">System.out.println(&quot;修改后沉默对应的值为：&quot; + value2);</span><br><span class="line"></span><br><span class="line">// 删除指定键的键值对</span><br><span class="line">hashMap.remove(&quot;王二&quot;);</span><br><span class="line"></span><br><span class="line">// 遍历 HashMap</span><br><span class="line">for (String key : hashMap.keySet()) &#123;</span><br><span class="line">    String value = hashMap.get(key);</span><br><span class="line">    System.out.println(key + &quot; 对应的值为：&quot; + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2）LinkedHashMap </strong></p>
<p>HashMap 已经非常强大了，但它是无序的。如果我们需要一个有序的Map，就要用到 LinkedHashMap。</p>
<p>LinkedHashMap 是 HashMap 的子类，它使用链表来记录插入/访问元素的顺序。</p>
<p>LinkedHashMap 可以看作是 HashMap + LinkedList 的合体，它使用了哈希表来存储数据，又用了双向链表来维持顺序。</p>
<p>来一个简单的例子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 LinkedHashMap，插入的键值对为 沉默 王二 陈清扬</span><br><span class="line">LinkedHashMap&lt;String, String&gt; linkedHashMap = new LinkedHashMap&lt;&gt;();</span><br><span class="line">linkedHashMap.put(&quot;沉默&quot;, &quot;cenzhong&quot;);</span><br><span class="line">linkedHashMap.put(&quot;王二&quot;, &quot;wanger&quot;);</span><br><span class="line">linkedHashMap.put(&quot;陈清扬&quot;, &quot;chenqingyang&quot;);</span><br><span class="line"></span><br><span class="line">// 遍历 LinkedHashMap</span><br><span class="line">for (String key : linkedHashMap.keySet()) &#123;</span><br><span class="line">    String value = linkedHashMap.get(key);</span><br><span class="line">    System.out.println(key + &quot; 对应的值为：&quot; + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">沉默 对应的值为：cenzhong</span><br><span class="line">王二 对应的值为：wanger</span><br><span class="line">陈清扬 对应的值为：chenqingyang</span><br></pre></td></tr></table></figure>
<p>从结果中可以看得出来，LinkedHashMap 维持了键值对的插入顺序，对吧？为了和 LinkedHashMap 做对比，我们用同样的数据试验一下 HashMap。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个HashMap，插入的键值对为 沉默 王二 陈清扬</span><br><span class="line">HashMap&lt;String, String&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">hashMap.put(&quot;沉默&quot;, &quot;cenzhong&quot;);</span><br><span class="line">hashMap.put(&quot;王二&quot;, &quot;wanger&quot;);</span><br><span class="line">hashMap.put(&quot;陈清扬&quot;, &quot;chenqingyang&quot;);</span><br><span class="line"></span><br><span class="line">// 遍历 HashMap</span><br><span class="line">for (String key : hashMap.keySet()) &#123;</span><br><span class="line">    String value = hashMap.get(key);</span><br><span class="line">    System.out.println(key + &quot; 对应的值为：&quot; + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">沉默 对应的值为：cenzhong</span><br><span class="line">陈清扬 对应的值为：chenqingyang</span><br><span class="line">王二 对应的值为：wanger</span><br></pre></td></tr></table></figure>
<p>HashMap 没有维持键值对的插入顺序，对吧？</p>
<p><strong>3）TreeMap </strong></p>
<p>TreeMap 实现了 SortedMap 接口，可以自动将键按照自然顺序或指定的比较器顺序排序，并保证其元素的顺序。内部使用红黑树来实现键的排序和查找。</p>
<p>同样来一个增删改查的 demo：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 TreeMap 对象</span><br><span class="line">Map&lt;String, String&gt; treeMap = new TreeMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">// 向 TreeMap 中添加键值对</span><br><span class="line">treeMap.put(&quot;沉默&quot;, &quot;cenzhong&quot;);</span><br><span class="line">treeMap.put(&quot;王二&quot;, &quot;wanger&quot;);</span><br><span class="line">treeMap.put(&quot;陈清扬&quot;, &quot;chenqingyang&quot;);</span><br><span class="line"></span><br><span class="line">// 查找键值对</span><br><span class="line">String name = &quot;沉默&quot;;</span><br><span class="line">if (treeMap.containsKey(name)) &#123;</span><br><span class="line">    System.out.println(&quot;找到了 &quot; + name + &quot;: &quot; + treeMap.get(name));</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    System.out.println(&quot;没有找到 &quot; + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 修改键值对</span><br><span class="line">name = &quot;王二&quot;;</span><br><span class="line">if (treeMap.containsKey(name)) &#123;</span><br><span class="line">    System.out.println(&quot;修改前的 &quot; + name + &quot;: &quot; + treeMap.get(name));</span><br><span class="line">    treeMap.put(name, &quot;newWanger&quot;);</span><br><span class="line">    System.out.println(&quot;修改后的 &quot; + name + &quot;: &quot; + treeMap.get(name));</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    System.out.println(&quot;没有找到 &quot; + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除键值对</span><br><span class="line">name = &quot;陈清扬&quot;;</span><br><span class="line">if (treeMap.containsKey(name)) &#123;</span><br><span class="line">    System.out.println(&quot;删除前的 &quot; + name + &quot;: &quot; + treeMap.get(name));</span><br><span class="line">    treeMap.remove(name);</span><br><span class="line">    System.out.println(&quot;删除后的 &quot; + name + &quot;: &quot; + treeMap.get(name));</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    System.out.println(&quot;没有找到 &quot; + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 遍历 TreeMap</span><br><span class="line">for (Map.Entry&lt;String, String&gt; entry : treeMap.entrySet()) &#123;</span><br><span class="line">    System.out.println(entry.getKey() + &quot;: &quot; + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与 HashMap 不同的是，TreeMap 会按照键的顺序来进行排序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 TreeMap 对象</span><br><span class="line">Map&lt;String, String&gt; treeMap = new TreeMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">// 向 TreeMap 中添加键值对</span><br><span class="line">treeMap.put(&quot;c&quot;, &quot;cat&quot;);</span><br><span class="line">treeMap.put(&quot;a&quot;, &quot;apple&quot;);</span><br><span class="line">treeMap.put(&quot;b&quot;, &quot;banana&quot;);</span><br><span class="line"></span><br><span class="line">// 遍历 TreeMap</span><br><span class="line">for (Map.Entry&lt;String, String&gt; entry : treeMap.entrySet()) &#123;</span><br><span class="line">    System.out.println(entry.getKey() + &quot;: &quot; + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a: apple</span><br><span class="line">b: banana</span><br><span class="line">c: cat</span><br></pre></td></tr></table></figure>
<p>默认情况下，已经按照键的自然顺序排过了。</p>
<p>“好了，三妹，关于集合框架，我们就先聊到这，随后我们会针对常用的容器进行详细地讲解，比如说 ArrayList、LinkedList、HashMap 等。”</p>
<p>“哇，二哥，这篇讲的东西可真不少，虽然都是比较基础的，但对于我一个小白来说，还是需要花点时间去消化的。”三妹嘟嘟嘴说到。</p>
<h2 id="4-2-时间复杂度，了解下"><a href="#4-2-时间复杂度，了解下" class="headerlink" title="4.2 时间复杂度，了解下"></a>4.2 时间复杂度，了解下</h2><p>“二哥，为什么要讲时间复杂度呀？”三妹问。</p>
<p>“因为接下来要用到啊。后面我们学习 ArrayList、LinkedList 的时候，会比较两者在增删改查时的执行效率，而时间复杂度是衡量执行效率的一个重要标准。”我说。</p>
<p>“到时候跑一下代码，统计一下前后的时间差不更准确吗？”三妹反问道。</p>
<p>“实际上，你说的是另外一种评估方法，这种评估方法可以得出非常准确的数值，但也有很大的局限性。”我不急不慢地说。</p>
<p>第一，测试结果会受到测试环境的影响。你比如说，同样的代码，在我这台 iMac 上跑出来的时间和在你那台华为的 MacBook 上跑出的时间可能就差别很大。</p>
<p>第二，测试结果会受到测试数据的影响。你比如说，一个排序后的数组和一个没有排序后的数组，调用了同一个查询方法，得出来的结果可能会差别特别大。</p>
<p>“因此，我们需要这种不依赖于具体测试环境和测试数据就能粗略地估算出执行效率的方法，时间复杂度就是其中的一种，还有一种是空间复杂度。”我继续补充道，“如果你后面刷 LeetCode的话，对时间复杂度这个概念也会比较依赖。”</p>
<p>来看下面这段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static int sum(int n) &#123;</span><br><span class="line">    int sum = 0; // 第 1 行</span><br><span class="line">    for (int i=0;i&lt;n;i++) &#123; // 第 2 行</span><br><span class="line">        sum = sum + 1; // 第 3 行</span><br><span class="line">    &#125; // 第 4 行</span><br><span class="line">    return sum; // 第 5 行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码非常简单，方法体里总共 5 行代码，包括“}”那一行。每段代码的执行时间可能都不大一样，但假设我们认为每行代码的执行时间是一样的，比如说 unit_time，那么这段代码总的执行时间为多少呢？</p>
<p>“这个我知道呀！”三妹喊道，“第 1、5 行需要 2 个 unit_time，第 2、3 行需要 2nunit_time，总的时间就是 2(n+1)*unit_time。”</p>
<p>“对，一段代码的执行时间 T(n) 和总的执行次数成正比，也就是说，代码执行的次数越多，花费的时间就越多。”我总结道，“这个规律可以用一个公式来表达：”</p>
<blockquote>
<p>T(n) = O(f(n))</p>
</blockquote>
<p>f(n) 表示代码总的执行次数，大写 O 表示代码的执行时间 T(n) 和 f(n) 成正比。</p>
<p>这也就是大 O 表示法，它不关心代码具体的执行时间是多少，它关心的是代码执行时间的变化趋势，这也就是时间复杂度这个概念的由来。</p>
<p>对于上面那段代码 sum() 来说，影响时间复杂度的主要是第 2 行代码，其余的，像系数 2、常数 2 都是可以忽略不计的，我们只关心影响最大的那个，所以时间复杂度就表示为 O(n) 。</p>
<p>常见的时间复杂度有这么 3 个：</p>
<p><strong>1） O(1)</strong></p>
<p>代码的执行时间，和数据规模 n 没有多大关系。</p>
<p>括号中的 1 可以是 3，可以是 5，可以 100，我们习惯用 1 来表示，表示这段代码的执行时间是一个常数级别。比如说下面这段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int i = 0;</span><br><span class="line">int j = 0;</span><br><span class="line">int k = i + j;</span><br></pre></td></tr></table></figure>
<p>实际上执行了 3 次，但我们也认为这段代码的时间复杂度为 O(1) 。</p>
<p>再举一个简单的例子。当我们访问数组中的一个元素时，它的时间复杂度就是常数时间复杂度 O(1)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int[] nums = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">int x = nums[2]; // 访问数组中下标为2的元素，时间复杂度为 O(1)</span><br></pre></td></tr></table></figure>
<p><strong>2） O(n)</strong></p>
<p>时间复杂度和数据规模 n 是线性关系。换句话说，数据规模增大 K 倍，代码执行的时间就大致增加 K 倍。</p>
<p>当我们遍历一个数组时，它的时间复杂度就是线性时间复杂度 O(n)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int[] nums = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">for (int i = 0; i &lt; nums.length; i++) &#123; // 遍历整个数组，时间复杂度为 O(n)</span><br><span class="line">    System.out.println(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3） O(logn)</strong></p>
<p>时间复杂度和数据规模 n 是对数关系。换句话说，数据规模大幅增加时，代码执行的时间只有少量增加。</p>
<p>来看一下代码示例，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void logn(int n) &#123; </span><br><span class="line">    int i = 1;</span><br><span class="line">    while (i &lt; n) &#123;</span><br><span class="line">        i *= 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>换句话说，当数据量 n 从 2 增加到 2^64 时，代码执行的时间只增加了 64 倍。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">遍历次数 |   i</span><br><span class="line">----------+-------</span><br><span class="line">    0     |   i</span><br><span class="line">    1     |  i*2</span><br><span class="line">    2     |  i*4</span><br><span class="line">   ...    |  ...</span><br><span class="line">   ...    |  ...</span><br><span class="line">    k     |  i*2^k </span><br></pre></td></tr></table></figure>
<p>再举个例子。当我们对一个已排序的数组进行二分查找时，它的时间复杂度就是对数时间复杂度 O(log n)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int[] nums = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">int target = 3;</span><br><span class="line">int left = 0, right = nums.length - 1;</span><br><span class="line">while (left &lt;= right) &#123;</span><br><span class="line">    int mid = left + (right - left) / 2;</span><br><span class="line">    if (nums[mid] == target) &#123;</span><br><span class="line">        System.out.println(&quot;找到了，下标为&quot; + mid);</span><br><span class="line">        break;</span><br><span class="line">    &#125; else if (nums[mid] &lt; target) &#123;</span><br><span class="line">        left = mid + 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        right = mid - 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4）平方时间复杂度O(n^2)  </strong></p>
<p>当我们对一个数组进行嵌套循环时，它的时间复杂度就是平方时间复杂度 O(n^2)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int[] nums = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">    for (int j = 0; j &lt; nums.length; j++) &#123;</span><br><span class="line">        System.out.println(nums[i] + &quot; &quot; + nums[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>5）指数时间复杂度O(2^n)</strong>  </p>
<p>当我们递归求解一个问题时，每一次递归都会分成两个子问题，这种情况下，它的时间复杂度就是指数时间复杂度 O(2^n)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static int fib(int n) &#123;</span><br><span class="line">    if (n &lt;= 1) &#123;</span><br><span class="line">        return n;</span><br><span class="line">    &#125;</span><br><span class="line">    return fib(n - 1) + fib(n - 2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码是递归求解斐波那契数列的方法，它的时间复杂度是指数级别的。</p>
<p>“好了，三妹，这节就讲到这吧，理解了上面 5 个时间复杂度，后面我们学习 ArrayList、LinkedList 的时候，两者在增删改查时的执行效率就很容易对比清楚了。”我伸了个懒腰后对三妹说。</p>
<p>“好的，二哥。”三妹重新回答沙发上，一盘王者荣耀即将开始。</p>
<h2 id="4-3-ArrayList详解（附源码）"><a href="#4-3-ArrayList详解（附源码）" class="headerlink" title="4.3 ArrayList详解（附源码）"></a>4.3 ArrayList详解（附源码）</h2><p>“二哥，听说今天我们开讲 ArrayList 了？好期待哦！”三妹明知故问，这个托配合得依然天衣无缝。</p>
<p>“是的呀，三妹。”我肯定地点了点头，继续说道，“ArrayList 可以称得上是集合框架方面最常用的类了，可以和 HashMap 一较高下。”</p>
<p>从名字就可以看得出来，ArrayList 实现了 List 接口，并且是基于数组实现的。</p>
<p>数组的大小是固定的，一旦创建的时候指定了大小，就不能再调整了。也就是说，如果数组满了，就不能再添加任何元素了。ArrayList 在数组的基础上实现了自动扩容，并且提供了比数组更丰富的预定义方法（各种增删改查），非常灵活。</p>
<p>Java 这门编程语言和别的编程语言，比如说 C语言的不同之处就在这里，如果是 C语言的话，你就必须得动手实现自己的 ArrayList，原生的库函数里面是没有的。</p>
<p><strong>01、创建 ArrayList </strong></p>
<p>“二哥，如何创建一个 ArrayList 啊？”三妹问。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; alist = new ArrayList&lt;String&gt;();</span><br></pre></td></tr></table></figure>
<p>可以通过上面的语句来创建一个字符串类型的 ArrayList（通过尖括号来限定 ArrayList 中元素的类型，如果尝试添加其他类型的元素，将会产生编译错误），更简化的写法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; alist = new ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>由于 ArrayList 实现了 List 接口，所以 alist 变量的类型可以是 List 类型；new 关键字声明后的尖括号中可以不再指定元素的类型，因为编译器可以通过前面尖括号中的类型进行智能推断。</p>
<p>此时会调用无参构造方法（见下面的代码）创建一个空的数组，常量DEFAULTCAPACITY_EMPTY_ELEMENTDATA的值为 {} 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList() &#123;</span><br><span class="line">    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果非常确定 ArrayList 中元素的个数，在创建的时候还可以指定初始大小。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; alist = new ArrayList&lt;&gt;(20);</span><br></pre></td></tr></table></figure>
<p>这样做的好处是，可以有效地避免在添加新的元素时进行不必要的扩容。</p>
<p><strong>02、向 ArrayList 中添加元素 </strong></p>
<p>“二哥，那怎么向 ArrayList 中添加一个元素呢？”三妹继续问。</p>
<p>可以通过 add() 方法向 ArrayList 中添加一个元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alist.add(&quot;沉默王二&quot;);</span><br></pre></td></tr></table></figure>
<p>我们来跟一下源码，看看 add 方法到底执行了哪些操作。跟的过程中，我们也可以偷师到 Java 源码的作者（大师级程序员）是如何优雅地写代码的。</p>
<p>我先给个结论，全当抛砖引玉。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">堆栈过程图示：</span><br><span class="line">add(element)</span><br><span class="line">└── if (size == elementData.length) // 判断是否需要扩容</span><br><span class="line">    ├── grow(minCapacity) // 扩容</span><br><span class="line">    │   └── newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1) // 计算新的数组容量</span><br><span class="line">    │   └── Arrays.copyOf(elementData, newCapacity) // 创建新的数组</span><br><span class="line">    ├── elementData[size++] = element; // 添加新元素</span><br><span class="line">    └── return true; // 添加成功</span><br></pre></td></tr></table></figure>
<p>来具体看一下，先是 add() 方法的源码（已添加好详细地注释）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 将指定元素添加到 ArrayList 的末尾</span><br><span class="line"> * @param e 要添加的元素</span><br><span class="line"> * @return 添加成功返回 true</span><br><span class="line"> */</span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    ensureCapacityInternal(size + 1);  // 确保 ArrayList 能够容纳新的元素</span><br><span class="line">    elementData[size++] = e; // 在 ArrayList 的末尾添加指定元素</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数 e 为要添加的元素，此时的值为“沉默王二”，size 为 ArrayList 的长度，此时为 0。</p>
<p>继续跟下去，来看看 ensureCapacityInternal()方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 确保 ArrayList 能够容纳指定容量的元素</span><br><span class="line"> * @param minCapacity 指定容量的最小值</span><br><span class="line"> */</span><br><span class="line">private void ensureCapacityInternal(int minCapacity) &#123;</span><br><span class="line">    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; // 如果 elementData 还是默</span><br><span class="line">认的空数组</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); // 使用 </span><br><span class="line">DEFAULT_CAPACITY 和指定容量的最小值中的较大值</span><br><span class="line">    &#125;</span><br><span class="line">    ensureExplicitCapacity(minCapacity); // 确保容量能够容纳指定容量的元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 此时：</p>
<ul>
<li>参数 minCapacity 为 1（size+1 传过来的）</li>
<li>elementData 为存放 ArrayList 元素的底层数组，前面声明 ArrayList 的时候讲过了，此时为空 {}</li>
<li><p>DEFAULTCAPACITY_EMPTY_ELEMENTDATA 前面也讲过了，为 {}</p>
<p>所以，if 条件此时为 true，if 语句 minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity)要执行。</p>
<p>DEFAULT_CAPACITY 为 10（见下面的代码），所以执行完这行代码后，minCapacity 为 10， Math.max() 方法的作用是取两个当中最大的那个。</p>
<p>接下来执行 ensureExplicitCapacity() 方法，来看一下源码：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 检查并确保集合容量足够，如果需要则增加集合容量。</span><br><span class="line"> *</span><br><span class="line"> * @param minCapacity 所需最小容量</span><br><span class="line"> */</span><br><span class="line">private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class="line">    // 检查是否超出了数组范围，确保不会溢出</span><br><span class="line">    if (minCapacity - elementData.length &gt; 0)</span><br><span class="line">        // 如果需要增加容量，则调用 grow 方法</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 此时：</p>
<ul>
<li>参数 minCapacity 为 10</li>
<li><p>elementData.length 为 0（数组为空）</p>
<p>所以 10-0&gt;0，if 条件为 true，进入 if 语句执行 grow() 方法，来看源码：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 扩容 ArrayList 的方法，确保能够容纳指定容量的元素</span><br><span class="line"> * @param minCapacity 指定容量的最小值</span><br><span class="line"> */</span><br><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">    // 检查是否会导致溢出，oldCapacity 为当前数组长度</span><br><span class="line">    int oldCapacity = elementData.length;</span><br><span class="line">    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); // 扩容至原来的1.5倍</span><br><span class="line">    if (newCapacity - minCapacity &lt; 0) // 如果还是小于指定容量的最小值</span><br><span class="line">        newCapacity = minCapacity; // 直接扩容至指定容量的最小值</span><br><span class="line">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0) // 如果超出了数组的最大长度</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity); // 扩容至数组的最大长度</span><br><span class="line">    // 将当前数组复制到一个新数组中，长度为 newCapacity</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 此时：</p>
<ul>
<li>参数 minCapacity 为 10</li>
<li>变量 oldCapacity 为 0</li>
</ul>
<p>所以 newCapacity 也为 0，于是 newCapacity - minCapacity 等于 -10 小于 0，于是第一个 if 条件为 true，执行第一个 if 语句 newCapacity = minCapacity ，然后 newCapacity 为 10。</p>
<p>紧接着执行 elementData = Arrays.copyOf(elementData, newCapacity); ，也就是进行数组的第一次扩容，长度为 10。</p>
<p>回到 add() 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    ensureCapacityInternal(size + 1);</span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行 elementData[size++] = e 。</p>
<p>此时：</p>
<ul>
<li>size 为 0</li>
<li><p>e 为 “沉默王二”</p>
<p>所以数组的第一个元素（下标为 0） 被赋值为“沉默王二”，接着返回 true，第一次 add 方法执行完毕。</p>
<p>PS：add 过程中会遇到一个令新手感到困惑的右移操作符 &gt;&gt; ，借这个机会来解释一下。</p>
<p>ArrayList 在第一次执行 add 后会扩容为 10，那 ArrayList 第二次扩容发生在什么时候呢？</p>
<p>答案是添加第 11 个元素时，大家可以尝试分析一下这个过程。</p>
</li>
</ul>
<p><strong>03、右移操作符 </strong></p>
<p> “oldCapacity 等于 10， oldCapacity &gt;&gt; 1 这个表达式等于多少呢？三妹你知道吗？”我问三妹。</p>
<p> “不知道啊， &gt;&gt; 是什么意思呢？”三妹很疑惑。</p>
<p> “ &gt;&gt; 是右移运算符， oldCapacity &gt;&gt; 1 相当于 oldCapacity 除以 2。”我给三妹解释道，“在计算机内部，都是按照二进制存储的，10 的二进制就是 1010，也就是 $0<em>2^0 + 1</em>2^1 + 0<em>2^2 + 1</em>2^3 =0+2+0+8=10 $。”</p>
<p> 还没等我解释完，三妹就打断了我，“二哥，能再详细解释一下到底为什么吗？”</p>
<p> “当然可以啊。”我拍着胸脯对三妹说。</p>
<p> 先从位权的含义说起吧。</p>
<p> 平常我们使用的是十进制数，比如说 39，并不是简单的 3 和 9，3 表示的是 3*10 = 30 ，9 表示的是 9*1 = 9 ，和 3 相乘的 10，和 9 相乘的 1，就是位权。位数不同，位权就不同，第 1 位是 10 的 0 次方（也就是 $10^0=1$ ），第 2 位是 10 的 1 次方（ $10^1=10$ ），第 3 位是 10 的 2 次方（ $10^2=100$ ），最右边的是第一位，依次类推。</p>
<p> 位权这个概念同样适用于二进制，第 1 位是 2 的 0 次方（也就是 $2^0=1$ ），第 2 位是 2 的 1 次方（ $2^1=2$ ），第 3 位是 2 的 2 次方（ $2^2=4$ ），第 4 位是 2 的 3 次方（ $2^3=8$ ）。</p>
<p> 十进制的情况下，10 是基数，二进制的情况下，2 是基数。</p>
<p> 10 在十进制的表示法是 $0<em>10^0+1</em>10^1 =0+10=10$。</p>
<p> 10 的二进制数是 1010，也就是 $0<em>2^0 + 1</em>2^1 + 0<em>2^2 + 1</em>2^3 =0+2+0+8=10$。</p>
<p> 然后是移位运算，移位分为左移和右移，在 Java 中，左移的运算符是 &lt;&lt; ，右移的运算符 &gt;&gt; 。</p>
<p> 拿 oldCapacity &gt;&gt; 1 来说吧， &gt;&gt; 左边的是被移位的值，此时是 10，也就是二进制 1010 ； &gt;&gt; 右边的是要移位的位数，此时是 1。</p>
<p> 1010 向右移一位就是 101，空出来的最高位此时要补 0，也就是 0101。</p>
<p> “那为什么不补 1 呢？”三妹这个问题很尖锐。</p>
<p> “因为是算术右移，并且是正数，所以最高位补 0；如果表示的是负数，就需要补 1。”我慢吞吞地回答道，</p>
<p> “0101 的十进制就刚好是 $1<em>2^0 + 0</em>2^1 + 1<em>2^2 + 0</em>2^3 =1+0+4+0=5$，如果多移几个数来找规律的话，就会发现，右移1 位是原来的 1/2，右移 2 位是原来的 1/4，诸如此类。”</p>
<p> 也就是说，ArrayList 的大小会扩容为原来的大小+原来大小/2，也就是 1.5 倍。</p>
<p> 这下明白了吧？</p>
<p> 你可以通过在 ArrayList 中添加第 11 个元素来 debug 验证一下。</p>
<p><img src="\assets\note\image-20231010100257416.png" alt="image-20231010100257416"></p>
<p> <strong>04、向 ArrayList 的指定位置添加元素 </strong></p>
<p> 除了 add(E e) 方法，还可以通过 add(int index, E element) 方法把元素添加到 ArrayList 的指定位置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alist.add(0, &quot;沉默王三&quot;);</span><br></pre></td></tr></table></figure>
<p> add(int index, E element) 方法的源码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 在指定位置插入一个元素。</span><br><span class="line"> *</span><br><span class="line"> * @param index   要插入元素的位置</span><br><span class="line"> * @param element 要插入的元素</span><br><span class="line"> * @throws IndexOutOfBoundsException 如果索引超出范围，则抛出此异常</span><br><span class="line"> */</span><br><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">    rangeCheckForAdd(index); // 检查索引是否越界</span><br><span class="line">    ensureCapacityInternal(size + 1);  // 确保容量足够，如果需要扩容就扩容</span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + 1,</span><br><span class="line">            size - index); // 将 index 及其后面的元素向后移动一位</span><br><span class="line">    elementData[index] = element; // 将元素插入到指定位置</span><br><span class="line">    size++; // 元素个数加一</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> add(int index, E element)方法会调用到一个非常重要的本地方法 System.arraycopy() ，它会对数组进行复制（要插入位置上的元素往后复制）。</p>
<p> 来细品一下。</p>
<p> 这是 arraycopy() 的语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length);</span><br></pre></td></tr></table></figure>
<p> 在 ArrayList.add(int index, E element) 方法中，具体用法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.arraycopy(elementData, index, elementData, index + 1, size - index);</span><br></pre></td></tr></table></figure>
<ul>
<li>elementData：表示要复制的源数组，即 ArrayList 中的元素数组。</li>
<li>index：表示源数组中要复制的起始位置，即需要将 index 及其后面的元素向后移动一位。</li>
<li>elementData：表示要复制到的目标数组，即 ArrayList 中的元素数组。</li>
<li>index + 1：表示目标数组中复制的起始位置，即将 index 及其后面的元素向后移动一位后，应该插入到的位置。</li>
<li><p>size - index：表示要复制的元素个数，即需要将 index 及其后面的元素向后移动一位，需要移动的元素个数为 size - index。</p>
<p>“三妹，注意看，我画幅图来表示下。”我认真地做起了图。</p>
</li>
</ul>
<p><img src="\assets\note\image-20231010100551490.png" alt="image-20231010100551490"></p>
<p><strong>05、更新 ArrayList 中的元素 </strong></p>
<p> “二哥，那怎么更新 ArrayList 中的元素呢？”三妹继续问。</p>
<p> 可以使用 set() 方法来更改 ArrayList 中的元素，需要提供下标和新元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alist.set(0, &quot;沉默王四&quot;);</span><br></pre></td></tr></table></figure>
<p> 假设原来 0 位置上的元素为“沉默王三”，现在可以将其更新为“沉默王四”。</p>
<p> 来看一下 set() 方法的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 用指定元素替换指定位置的元素。</span><br><span class="line"> *</span><br><span class="line"> * @param index   要替换的元素的索引</span><br><span class="line"> * @param element 要存储在指定位置的元素</span><br><span class="line"> * @return 先前在指定位置的元素</span><br><span class="line"> * @throws IndexOutOfBoundsException 如果索引超出范围，则抛出此异常</span><br><span class="line"> */</span><br><span class="line">public E set(int index, E element) &#123;</span><br><span class="line">    rangeCheck(index); // 检查索引是否越界</span><br><span class="line">    E oldValue = elementData(index); // 获取原来在指定位置上的元素</span><br><span class="line">    elementData[index] = element; // 将新元素替换到指定位置上</span><br><span class="line">    return oldValue; // 返回原来在指定位置上的元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法会先对指定的下标进行检查，看是否越界，然后替换新值并返回旧值。</p>
<p><strong>06、删除 ArrayList 中的元素 </strong></p>
<p>“二哥，那怎么删除 ArrayList 中的元素呢？”三妹继续问。</p>
<p>remove(int index) 方法用于删除指定下标位置上的元素， remove(Object o) 方法用于删除指定值的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alist.remove(1);</span><br><span class="line">alist.remove(&quot;沉默王四&quot;);</span><br></pre></td></tr></table></figure>
<p>先来看 remove(int index) 方法的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 删除指定位置的元素。</span><br><span class="line"> *</span><br><span class="line"> * @param index 要删除的元素的索引</span><br><span class="line"> * @return 先前在指定位置的元素</span><br><span class="line"> * @throws IndexOutOfBoundsException 如果索引超出范围，则抛出此异常</span><br><span class="line"> */</span><br><span class="line">public E remove(int index) &#123;</span><br><span class="line">    rangeCheck(index); // 检查索引是否越界</span><br><span class="line">    E oldValue = elementData(index); // 获取要删除的元素</span><br><span class="line">    int numMoved = size - index - 1; // 计算需要移动的元素个数</span><br><span class="line">    if (numMoved &gt; 0) // 如果需要移动元素，就用 System.arraycopy 方法实现</span><br><span class="line">        System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                numMoved);</span><br><span class="line">    elementData[--size] = null; // 将数组末尾的元素置为 null，让 GC 回收该元素占用的空间</span><br><span class="line">    return oldValue; // 返回被删除的元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，在 ArrayList 中，删除元素时，需要将删除位置后面的元素向前移动一位，以填补删除位置留下的空缺。如果需要移动元素，则需要使用 System.arraycopy 方法将删除位置后面的元素向前移动一位。最后，将数组末尾的元素置为 null，以便让垃圾回收机制回收该元素占用的空间。</p>
<p>再来看 remove(Object o) 方法的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 删除列表中第一次出现的指定元素（如果存在）。</span><br><span class="line"> *</span><br><span class="line"> * @param o 要删除的元素</span><br><span class="line"> * @return 如果列表包含指定元素，则返回 true；否则返回 false</span><br><span class="line"> */</span><br><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    if (o == null) &#123; // 如果要删除的元素是 null</span><br><span class="line">        for (int index = 0; index &lt; size; index++) // 遍历列表</span><br><span class="line">            if (elementData[index] == null) &#123; // 如果找到了 null 元素</span><br><span class="line">                fastRemove(index); // 调用 fastRemove 方法快速删除元素</span><br><span class="line">                return true; // 返回 true，表示成功删除元素</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; else &#123; // 如果要删除的元素不是 null</span><br><span class="line">        for (int index = 0; index &lt; size; index++) // 遍历列表</span><br><span class="line">            if (o.equals(elementData[index])) &#123; // 如果找到了要删除的元素</span><br><span class="line">                fastRemove(index); // 调用 fastRemove 方法快速删除元素</span><br><span class="line">                return true; // 返回 true，表示成功删除元素</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false; // 如果找不到要删除的元素，则返回 false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 该方法通过遍历的方式找到要删除的元素，null 的时候使用 == 操作符判断，非 null 的时候使用 equals() 方法，然后调用fastRemove() 方法。</p>
<p> 注意：</p>
<ul>
<li>有相同元素时，只会删除第一个。</li>
<li><p>判断两个元素是否相等，可以参考Java如何判断两个字符串是否相等</p>
<p>继续往后面跟，来看一下 fastRemove() 方法：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 快速删除指定位置的元素。</span><br><span class="line"> *</span><br><span class="line"> * @param index 要删除的元素的索引</span><br><span class="line"> */</span><br><span class="line">private void fastRemove(int index) &#123;</span><br><span class="line">    int numMoved = size - index - 1; // 计算需要移动的元素个数</span><br><span class="line">    if (numMoved &gt; 0) // 如果需要移动元素，就用 System.arraycopy 方法实现</span><br><span class="line">        System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                numMoved);</span><br><span class="line">    elementData[--size] = null; // 将数组末尾的元素置为 null，让 GC 回收该元素占用的空间</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 同样是调用 System.arraycopy() 方法对数组进行复制和移动。</p>
<p> “三妹，注意看，我画幅图来表示下。”我认真地做起了图。</p>
<p><img src="\assets\note\image-20231010101038173.png" alt="image-20231010101038173"></p>
<p> <strong>07、查找 ArrayList 中的元素 </strong></p>
<p> “二哥，那怎么查找 ArrayList 中的元素呢？”三妹继续问。</p>
<p> 如果要正序查找一个元素，可以使用 indexOf() 方法；如果要倒序查找一个元素，可以使用 lastIndexOf() 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alist.indexOf(&quot;沉默王二&quot;);</span><br><span class="line">alist.lastIndexOf(&quot;沉默王二&quot;);</span><br></pre></td></tr></table></figure>
<p> 来看一下 indexOf() 方法的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 返回指定元素在列表中第一次出现的位置。</span><br><span class="line"> * 如果列表不包含该元素，则返回 -1。</span><br><span class="line"> *</span><br><span class="line"> * @param o 要查找的元素</span><br><span class="line"> * @return 指定元素在列表中第一次出现的位置；如果列表不包含该元素，则返回 -1</span><br><span class="line"> */</span><br><span class="line">public int indexOf(Object o) &#123;</span><br><span class="line">    if (o == null) &#123; // 如果要查找的元素是 null</span><br><span class="line">        for (int i = 0; i &lt; size; i++) // 遍历列表</span><br><span class="line">            if (elementData[i]==null) // 如果找到了 null 元素</span><br><span class="line">                return i; // 返回元素的索引</span><br><span class="line">    &#125; else &#123; // 如果要查找的元素不是 null</span><br><span class="line">        for (int i = 0; i &lt; size; i++) // 遍历列表</span><br><span class="line">            if (o.equals(elementData[i])) // 如果找到了要查找的元素</span><br><span class="line">                return i; // 返回元素的索引</span><br><span class="line">    &#125;</span><br><span class="line">    return -1; // 如果找不到要查找的元素，则返回 -1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 如果元素为 null 的时候使用“==”操作符，否则使用 equals() 方法。</p>
<p> lastIndexOf() 方法和 indexOf() 方法类似，不过遍历的时候从最后开始。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 返回指定元素在列表中最后一次出现的位置。</span><br><span class="line"> * 如果列表不包含该元素，则返回 -1。</span><br><span class="line"> *</span><br><span class="line"> * @param o 要查找的元素</span><br><span class="line"> * @return 指定元素在列表中最后一次出现的位置；如果列表不包含该元素，则返回 -1</span><br><span class="line"> */</span><br><span class="line">public int lastIndexOf(Object o) &#123;</span><br><span class="line">    if (o == null) &#123; // 如果要查找的元素是 null</span><br><span class="line">        for (int i = size-1; i &gt;= 0; i--) // 从后往前遍历列表</span><br><span class="line">            if (elementData[i]==null) // 如果找到了 null 元素</span><br><span class="line">                return i; // 返回元素的索引</span><br><span class="line">    &#125; else &#123; // 如果要查找的元素不是 null</span><br><span class="line">        for (int i = size-1; i &gt;= 0; i--) // 从后往前遍历列表</span><br><span class="line">            if (o.equals(elementData[i])) // 如果找到了要查找的元素</span><br><span class="line">                return i; // 返回元素的索引</span><br><span class="line">    &#125;</span><br><span class="line">    return -1; // 如果找不到要查找的元素，则返回 -1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> contains() 方法可以判断 ArrayList 中是否包含某个元素，其内部就是通过 indexOf() 方法实现的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean contains(Object o) &#123;</span><br><span class="line">    return indexOf(o) &gt;= 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>08、二分查找法 </strong></p>
<p> 如果 ArrayList 中的元素是经过排序的，就可以使用二分查找法，效率更快。</p>
<p> Collections 类的 sort() 方法可以对 ArrayList 进行排序，该方法会按照字母顺序对 String 类型的列表进行排序。如果是自定义类型的列表，还可以指定 Comparator 进行排序。</p>
<p> 这里先简单地了解一下，后面会详细地讲。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; copy = new ArrayList&lt;&gt;(alist);</span><br><span class="line">copy.add(&quot;a&quot;);</span><br><span class="line">copy.add(&quot;c&quot;);</span><br><span class="line">copy.add(&quot;b&quot;);</span><br><span class="line">copy.add(&quot;d&quot;);</span><br><span class="line">Collections.sort(copy);</span><br><span class="line">System.out.println(copy);</span><br></pre></td></tr></table></figure>
<p> 输出结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[a, b, c, d]</span><br></pre></td></tr></table></figure>
<p> 排序后就可以使用二分查找法了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int index = Collections.binarySearch(copy, &quot;b&quot;);</span><br></pre></td></tr></table></figure>
<p><strong>09、ArrayList增删改查时的时间复杂度 </strong></p>
<p> “最后，三妹，我们来简单总结一下 ArrayList 的时间复杂度吧，方便后面学习 LinkedList 时对比。”我喝了一口水后补充道。</p>
<p><strong>1）查询 </strong></p>
<p> 时间复杂度为 O(1)，因为 ArrayList 内部使用数组来存储元素，所以可以直接根据索引来访问元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 返回列表中指定位置的元素。</span><br><span class="line"> *</span><br><span class="line"> * @param index 要返回的元素的索引</span><br><span class="line"> * @return 列表中指定位置的元素</span><br><span class="line"> * @throws IndexOutOfBoundsException 如果索引超出范围（index &lt; 0 || index &gt;= size()）</span><br><span class="line"> */</span><br><span class="line">public E get(int index) &#123;</span><br><span class="line">    rangeCheck(index); // 检查索引是否合法</span><br><span class="line">    return elementData(index); // 调用 elementData 方法获取元素</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 返回列表中指定位置的元素。</span><br><span class="line"> * 此方法不进行边界检查，因此只应由内部方法和迭代器调用。</span><br><span class="line"> *</span><br><span class="line"> * @param index 要返回的元素的索引</span><br><span class="line"> * @return 列表中指定位置的元素</span><br><span class="line"> */</span><br><span class="line">E elementData(int index) &#123;</span><br><span class="line">    return (E) elementData[index]; // 返回指定索引位置上的元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>2）插入 </strong></p>
<p> 添加一个元素（调用 add() 方法时）的时间复杂度最好情况为 O(1)，最坏情况为 O(n)。</p>
<ul>
<li>如果在列表末尾添加元素，时间复杂度为 O(1)。</li>
<li>如果要在列表的中间或开头插入元素，则需要将插入位置之后的元素全部向后移动一位，时间复杂度为 O(n)。</li>
</ul>
<p><strong>3）删除 </strong></p>
<p> 删除一个元素（调用 remove(Object) 方法时）的时间复杂度最好情况 O(1)，最坏情况 O(n)。</p>
<ul>
<li>如果要删除列表末尾的元素，时间复杂度为 O(1)。</li>
<li><p>如果要删除列表中间或开头的元素，则需要将删除位置之后的元素全部向前移动一位，时间复杂度为 O(n)。</p>
<p><strong>4）修改 </strong></p>
<p>修改一个元素（调用 set()方法时）与查询操作类似，可以直接根据索引来访问元素，时间复杂度为 O(1)。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 用指定元素替换列表中指定位置的元素。</span><br><span class="line"> *</span><br><span class="line"> * @param index 要替换元素的索引</span><br><span class="line"> * @param element 要放入列表中的元素</span><br><span class="line"> * @return 原来在指定位置上的元素</span><br><span class="line"> * @throws IndexOutOfBoundsException 如果索引超出范围（index &lt; 0 || index &gt;= size()）</span><br><span class="line"> */</span><br><span class="line">public E set(int index, E element) &#123;</span><br><span class="line">    rangeCheck(index); // 检查索引是否合法</span><br><span class="line">    E oldValue = elementData(index); // 获取原来在指定位置上的元素</span><br><span class="line">    elementData[index] = element; // 将指定位置上的元素替换为新元素</span><br><span class="line">    return oldValue; // 返回原来在指定位置上的元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>10、总结 </strong></p>
<p> ArrayList，如果有个中文名的话，应该叫动态数组，也就是可增长的数组，可调整大小的数组。动态数组克服了静态数组的限制，静态数组的容量是固定的，只能在首次创建的时候指定。而动态数组会随着元素的增加自动调整大小，更符合实际的开发需求。</p>
<p> 学习集合框架，ArrayList 是第一课，也是新手进阶的重要一课。要想完全掌握 ArrayList，扩容这个机制是必须得掌握，也是面试中经常考察的一个点。</p>
<p> 要想掌握扩容机制，就必须得读源码，也就肯定会遇到 oldCapacity &gt;&gt; 1 ，有些初学者会选择跳过，虽然不影响整体上的学习，但也错过了一个精进的机会。</p>
<p> 计算机内部是如何表示十进制数的，右移时又发生了什么，静下心来去研究一下，你就会发现，哦，原来这么有趣呢？</p>
<p> “好了，三妹，这一节我们就学到这里，收工！”</p>
<h2 id="4-4-LinkedList详解（附源码）"><a href="#4-4-LinkedList详解（附源码）" class="headerlink" title="4.4 LinkedList详解（附源码）"></a>4.4 LinkedList详解（附源码）</h2><p> 这篇换个表达方式，一起来欣赏。</p>
<p> 大家好，我是 LinkedList，和 ArrayList 是同门师兄弟，但我俩练的内功却完全不同。师兄练的是动态数组，我练的是链表。</p>
<p> 问大家一个问题，知道我为什么要练链表这门内功吗？</p>
<p> 举个例子来讲吧，假如你们手头要管理一推票据，可能有一张，也可能有一亿张。</p>
<p> 该怎么办呢？</p>
<p> 申请一个 10G 的大数组等着？那万一票据只有 100 张呢？</p>
<p> 申请一个默认大小的数组，随着数据量的增大扩容？要知道扩容是需要重新复制数组的，很耗时间。</p>
<p> 关键是，数组还有一个弊端就是，假如现在有 500 万张票据，现在要从中间删除一个票据，就需要把 250 万张票据往前移动一格。</p>
<p> 遇到这种情况的时候，我师兄几乎情绪崩溃，难受的要命。师父不忍心看到师兄这样痛苦，于是打我进入师门那一天，就强迫我练链表这门内功，一开始我很不理解，害怕师父偏心，不把师门最厉害的内功教我。</p>
<p> 直到有一天，我亲眼目睹师兄差点因为移动数据而走火入魔，我才明白师父的良苦用心。从此以后，我苦练“链表”这门内功，取得了显著的进步，师父和师兄都夸我有天赋。</p>
<p> 链表这门内功大致分为三个层次：</p>
<ul>
<li>第一层叫做“单向链表”，我只有一个后指针，指向下一个数据；</li>
<li>第二层叫做“双向链表”，我有两个指针，后指针指向下一个数据，前指针指向上一个数据。</li>
<li><p>第三层叫做“二叉树”，把后指针去掉，换成左右指针。</p>
<p>但我现在的功力还达不到第三层，不过师父说我有这个潜力，练成神功是早晚的事。</p>
</li>
</ul>
<p><strong>01、LinkedList的内功心法 </strong></p>
<p> 好了，经过我这么样的一个剖白后，大家对我应该已经不陌生了。那么接下来，我给大家展示一下我的内功心法。</p>
<p> 我的内功心法主要是一个私有的静态内部类，叫 Node，也就是节点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 链表中的节点类。</span><br><span class="line"> */</span><br><span class="line">private static class Node&lt;E&gt; &#123;</span><br><span class="line">    E item; // 节点中存储的元素</span><br><span class="line">    Node&lt;E&gt; next; // 指向下一个节点的指针</span><br><span class="line">    Node&lt;E&gt; prev; // 指向上一个节点的指针</span><br><span class="line">    /**</span><br><span class="line">     * 构造一个新的节点。</span><br><span class="line">     *</span><br><span class="line">     * @param prev 前一个节点</span><br><span class="line">     * @param element 节点中要存储的元素</span><br><span class="line">     * @param next 后一个节点</span><br><span class="line">     */</span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        this.item = element; // 存储元素</span><br><span class="line">        this.next = next; // 设置下一个节点</span><br><span class="line">        this.prev = prev; // 设置上一个节点</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 它由三部分组成：</p>
<ul>
<li>节点上的元素</li>
<li>下一个节点</li>
<li><p>上一个节点</p>
<p>我画幅图给你们展示下吧。</p>
</li>
</ul>
<p><img src="\assets\note\image-20231010102138237.png" alt="image-20231010102138237"></p>
<ul>
<li>对于第一个节点来说，prev 为 null；</li>
<li>对于最后一个节点来说，next 为 null；</li>
<li><p>其余的节点呢，prev 指向前一个，next 指向后一个。</p>
<p>我的内功心法就这么简单，其实我早已经牢记在心了。但师父叮嘱我，每天早上醒来的时候，每天晚上睡觉的时候，一定要默默地背诵一遍。虽然我有些厌烦，但我对师父的教诲从来都是言听计从。</p>
<p><strong>02、LinkedList的招式 </strong></p>
<p>和师兄 ArrayList 一样，我的招式也无外乎“增删改查”这 4 种。在此之前，我们都必须得初始化。</p>
<p>师兄在初始化的时候可以指定大小，也可以不指定，等到添加第一个元素的时候进行第一次扩容。而我，没有大小，只要内存够大，我就可以无穷大。</p>
</li>
</ul>
<p><strong>1）招式一：增 </strong></p>
<p>  可以调用 add 方法添加元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list.add(&quot;沉默王二&quot;);</span><br><span class="line">list.add(&quot;沉默王三&quot;);</span><br><span class="line">list.add(&quot;沉默王四&quot;);</span><br></pre></td></tr></table></figure>
<p>  add 方法内部其实调用的是 linkLast 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 将指定的元素添加到列表的尾部。</span><br><span class="line"> *</span><br><span class="line"> * @param e 要添加到列表的元素</span><br><span class="line"> * @return 始终为 true（根据 Java 集合框架规范）</span><br><span class="line"> */</span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    linkLast(e); // 在列表的尾部添加元素</span><br><span class="line">    return true; // 添加元素成功，返回 true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  linkLast，顾名思义，就是在链表的尾部添加元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 在列表的尾部添加指定的元素。</span><br><span class="line"> *</span><br><span class="line"> * @param e 要添加到列表的元素</span><br><span class="line"> */</span><br><span class="line">void linkLast(E e) &#123;</span><br><span class="line">    final Node&lt;E&gt; l = last; // 获取链表的最后一个节点</span><br><span class="line">    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); // 创建一个新的节点，并将其设置为链表</span><br><span class="line">的最后一个节点</span><br><span class="line">    last = newNode; // 将新的节点设置为链表的最后一个节点</span><br><span class="line">    if (l == null) // 如果链表为空，则将新节点设置为头节点</span><br><span class="line">        first = newNode;</span><br><span class="line">    else</span><br><span class="line">        l.next = newNode; // 否则将新节点链接到链表的尾部</span><br><span class="line">    size++; // 增加链表的元素个数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>添加第一个元素的时候，first 和 last 都为 null。</li>
<li>然后新建一个节点 newNode，它的 prev 和 next 也为 null。</li>
<li><p>然后把 last 和 first 都赋值为 newNode。</p>
<p>此时还不能称之为链表，因为前后节点都是断裂的。</p>
</li>
</ul>
<p><img src="\assets\note\image-20231010102450377.png" alt="image-20231010102450377"></p>
<ul>
<li>添加第二个元素的时候，first 和 last 都指向的是第一个节点。</li>
<li>然后新建一个节点 newNode，它的 prev 指向的是第一个节点，next 为 null。</li>
<li><p>然后把第一个节点的 next 赋值为 newNode。</p>
<p>此时的链表还不完整。</p>
</li>
</ul>
<p><img src="\assets\note\image-20231010103006080.png" alt="image-20231010103006080"></p>
<ul>
<li>添加第三个元素的时候，first 指向的是第一个节点，last 指向的是最后一个节点。</li>
<li>然后新建一个节点 newNode，它的 prev 指向的是第二个节点，next 为 null。</li>
<li><p>然后把第二个节点的 next 赋值为 newNode。</p>
<p>此时的链表已经完整了。</p>
<p>我这个增的招式，还可以演化成另外两个版本：</p>
</li>
<li><p>addFirst() 方法将元素添加到第一位；</p>
</li>
<li><p>addLast() 方法将元素添加到末尾。</p>
<p>addFirst 内部其实调用的是 linkFirst：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 在列表的开头添加指定的元素。</span><br><span class="line"> *</span><br><span class="line"> * @param e 要添加到列表的元素</span><br><span class="line"> */</span><br><span class="line">public void addFirst(E e) &#123;</span><br><span class="line">    linkFirst(e); // 在列表的开头添加元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> linkFirst 负责把新的节点设为 first，并将新的 first 的 next 更新为之前的 first。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 在列表的开头添加指定的元素。</span><br><span class="line"> *</span><br><span class="line"> * @param e 要添加到列表的元素</span><br><span class="line"> */</span><br><span class="line">private void linkFirst(E e) &#123;</span><br><span class="line">    final Node&lt;E&gt; f = first; // 获取链表的第一个节点</span><br><span class="line">    final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f); // 创建一个新的节点，并将其设置为链表</span><br><span class="line">的第一个节点</span><br><span class="line">    first = newNode; // 将新的节点设置为链表的第一个节点</span><br><span class="line">    if (f == null) // 如果链表为空，则将新节点设置为尾节点</span><br><span class="line">        last = newNode;</span><br><span class="line">    else</span><br><span class="line">        f.prev = newNode; // 否则将新节点链接到链表的头部</span><br><span class="line">    size++; // 增加链表的元素个数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> addLast 的内核其实和 addFirst 差不多，内部调用的是 linkLast 方法，前面分析过了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 在列表的尾部添加指定的元素。</span><br><span class="line"> *</span><br><span class="line"> * @param e 要添加到列表的元素</span><br><span class="line"> * @return 始终为 true（根据 Java 集合框架规范）</span><br><span class="line"> */</span><br><span class="line">public boolean addLast(E e) &#123;</span><br><span class="line">    linkLast(e); // 在列表的尾部添加元素</span><br><span class="line">    return true; // 添加元素成功，返回 true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2）招式二：删 </strong></p>
<p> 我这个删的招式还挺多的：</p>
<ul>
<li>remove() ：删除第一个节点</li>
<li>remove(int) ：删除指定位置的节点</li>
<li>remove(Object) ：删除指定元素的节点</li>
<li>removeFirst() ：删除第一个节点</li>
<li><p>removeLast() ：删除最后一个节点</p>
<p>remove() 内部调用的是 removeFirst() ，所以这两个招式的功效一样。</p>
<p>remove(int) 内部其实调用的是 unlink 方法。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 删除指定位置上的元素。</span><br><span class="line"> *</span><br><span class="line"> * @param index 要删除的元素的索引</span><br><span class="line"> * @return 从列表中删除的元素</span><br><span class="line"> * @throws IndexOutOfBoundsException 如果索引越界（index &amp;lt; 0 || index &amp;gt;= size()）</span><br><span class="line"> */</span><br><span class="line">public E remove(int index) &#123;</span><br><span class="line">    checkElementIndex(index); // 检查索引是否越界</span><br><span class="line">    return unlink(node(index)); // 删除指定位置的节点，并返回节点的元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> unlink 方法其实很好理解，就是更新当前节点的 next 和 prev，然后把当前节点上的元素设为 null。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 从链表中删除指定节点。</span><br><span class="line"> *</span><br><span class="line"> * @param x 要删除的节点</span><br><span class="line"> * @return 从链表中删除的节点的元素</span><br><span class="line"> */</span><br><span class="line">E unlink(Node&lt;E&gt; x) &#123;</span><br><span class="line">    final E element = x.item; // 获取要删除节点的元素</span><br><span class="line">    final Node&lt;E&gt; next = x.next; // 获取要删除节点的下一个节点</span><br><span class="line">    final Node&lt;E&gt; prev = x.prev; // 获取要删除节点的上一个节点</span><br><span class="line">    if (prev == null) &#123; // 如果要删除节点是第一个节点</span><br><span class="line">        first = next; // 将链表的头节点设置为要删除节点的下一个节点</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        prev.next = next; // 将要删除节点的上一个节点指向要删除节点的下一个节点</span><br><span class="line">        x.prev = null; // 将要删除节点的上一个节点设置为空</span><br><span class="line">    &#125;</span><br><span class="line">    if (next == null) &#123; // 如果要删除节点是最后一个节点</span><br><span class="line">        last = prev; // 将链表的尾节点设置为要删除节点的上一个节点</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        next.prev = prev; // 将要删除节点的下一个节点指向要删除节点的上一个节点</span><br><span class="line">        x.next = null; // 将要删除节点的下一个节点设置为空</span><br><span class="line">    &#125;</span><br><span class="line">    x.item = null; // 将要删除节点的元素设置为空</span><br><span class="line">    size--; // 减少链表的元素个数</span><br><span class="line">    return element; // 返回被删除节点的元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> remove(Object) 内部也调用了 unlink 方法，只不过在此之前要先找到元素所在的节点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 从链表中删除指定元素。</span><br><span class="line"> *</span><br><span class="line"> * @param o 要从链表中删除的元素</span><br><span class="line"> * @return 如果链表包含指定元素，则返回 true；否则返回 false</span><br><span class="line"> */</span><br><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    if (o == null) &#123; // 如果要删除的元素为 null</span><br><span class="line">        for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; // 遍历链表</span><br><span class="line">            if (x.item == null) &#123; // 如果节点的元素为 null</span><br><span class="line">                unlink(x); // 删除节点</span><br><span class="line">                return true; // 返回 true 表示删除成功</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123; // 如果要删除的元素不为 null</span><br><span class="line">        for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; // 遍历链表</span><br><span class="line">            if (o.equals(x.item)) &#123; // 如果节点的元素等于要删除的元素</span><br><span class="line">                unlink(x); // 删除节点</span><br><span class="line">                return true; // 返回 true 表示删除成功</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false; // 如果链表中不包含要删除的元素，则返回 false 表示删除失败</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 元素为 null 的时候，必须使用 == 来判断；元素为非 null 的时候，要使用 equals 来判断。</p>
<p> removeFirst 内部调用的是 unlinkFirst 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 从链表中删除第一个元素并返回它。</span><br><span class="line"> * 如果链表为空，则抛出 NoSuchElementException 异常。</span><br><span class="line"> *</span><br><span class="line"> * @return 从链表中删除的第一个元素</span><br><span class="line"> * @throws NoSuchElementException 如果链表为空</span><br><span class="line"> */</span><br><span class="line">public E removeFirst() &#123;</span><br><span class="line">    final Node&lt;E&gt; f = first; // 获取链表的第一个节点</span><br><span class="line">    if (f == null) // 如果链表为空</span><br><span class="line">        throw new NoSuchElementException(); // 抛出 NoSuchElementException 异常</span><br><span class="line">    return unlinkFirst(f); // 调用 unlinkFirst 方法删除第一个节点并返回它的元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> unlinkFirst 负责的就是把第一个节点毁尸灭迹，并且捎带把后一个节点的 prev 设为 null。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 删除链表中的第一个节点并返回它的元素。</span><br><span class="line"> *</span><br><span class="line"> * @param f 要删除的第一个节点</span><br><span class="line"> * @return 被删除节点的元素</span><br><span class="line"> */</span><br><span class="line">private E unlinkFirst(Node&lt;E&gt; f) &#123;</span><br><span class="line">    final E element = f.item; // 获取要删除的节点的元素</span><br><span class="line">    final Node&lt;E&gt; next = f.next; // 获取要删除的节点的下一个节点</span><br><span class="line">    f.item = null; // 将要删除的节点的元素设置为 null</span><br><span class="line">    f.next = null; // 将要删除的节点的下一个节点设置为 null</span><br><span class="line">    first = next; // 将链表的头节点设置为要删除的节点的下一个节点</span><br><span class="line">    if (next == null) // 如果链表只有一个节点</span><br><span class="line">        last = null; // 将链表的尾节点设置为 null</span><br><span class="line">    else</span><br><span class="line">        next.prev = null; // 将要删除节点的下一个节点的前驱设置为 null</span><br><span class="line">    size--; // 减少链表的大小</span><br><span class="line">    return element; // 返回被删除节点的元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>3）招式三：改 </strong></p>
<p> 可以调用 set() 方法来更新元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.set(0, &quot;沉默王五&quot;);</span><br></pre></td></tr></table></figure>
<p> 来看一下 set() 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 将链表中指定位置的元素替换为指定元素，并返回原来的元素。</span><br><span class="line"> *</span><br><span class="line"> * @param index 要替换元素的位置（从 0 开始）</span><br><span class="line"> * @param element 要插入的元素</span><br><span class="line"> * @return 替换前的元素</span><br><span class="line"> * @throws IndexOutOfBoundsException 如果索引超出范围（index &lt; 0 || index &gt;= size()）</span><br><span class="line"> */</span><br><span class="line">public E set(int index, E element) &#123;</span><br><span class="line">    checkElementIndex(index); // 检查索引是否超出范围</span><br><span class="line">    Node&lt;E&gt; x = node(index); // 获取要替换的节点</span><br><span class="line">    E oldVal = x.item; // 获取要替换节点的元素</span><br><span class="line">    x.item = element; // 将要替换的节点的元素设置为指定元素</span><br><span class="line">    return oldVal; // 返回替换前的元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 来看一下node方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 获取链表中指定位置的节点。</span><br><span class="line"> *</span><br><span class="line"> * @param index 节点的位置（从 0 开始）</span><br><span class="line"> * @return 指定位置的节点</span><br><span class="line"> * @throws IndexOutOfBoundsException 如果索引超出范围（index &lt; 0 || index &gt;= size()）</span><br><span class="line"> */</span><br><span class="line">Node&lt;E&gt; node(int index) &#123;</span><br><span class="line">    if (index &lt; (size &gt;&gt; 1)) &#123; // 如果索引在链表的前半部分</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        for (int i = 0; i &lt; index; i++) // 从头节点开始向后遍历链表，直到找到指定位置的节点</span><br><span class="line">            x = x.next;</span><br><span class="line">        return x; // 返回指定位置的节点</span><br><span class="line">    &#125; else &#123; // 如果索引在链表的后半部分</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        for (int i = size - 1; i &gt; index; i--) // 从尾节点开始向前遍历链表，直到找到指定位</span><br><span class="line">置的节点</span><br><span class="line">            x = x.prev;</span><br><span class="line">        return x; // 返回指定位置的节点</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> size &gt;&gt; 1 ：也就是右移一位，相当于除以 2。对于计算机来说，移位比除法运算效率更高，因为数据在计算机内部都是以二进制存的。</p>
<p> 换句话说，node 方法会对下标进行一个初步判断，如果靠近前半截，就从下标 0 开始遍历；如果靠近后半截，就从末尾开始遍历，这样可以提高效率，最大能提高一半的效率。</p>
<p> 找到指定下标的节点就简单了，直接把原有节点的元素替换成新的节点就 OK 了，prev 和 next 都不用改动。</p>
<p><strong>4）招式四：查 </strong></p>
<p> 我这个查的招式可以分为两种：</p>
<ul>
<li>indexOf(Object)：查找某个元素所在的位置</li>
<li><p>get(int)：查找某个位置上的元素</p>
<p>来看一下 indexOf 方法的源码。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 返回链表中首次出现指定元素的位置，如果不存在该元素则返回 -1。</span><br><span class="line"> *</span><br><span class="line"> * @param o 要查找的元素</span><br><span class="line"> * @return 首次出现指定元素的位置，如果不存在该元素则返回 -1</span><br><span class="line"> */</span><br><span class="line">public int indexOf(Object o) &#123;</span><br><span class="line">    int index = 0; // 初始化索引为 0</span><br><span class="line">    if (o == null) &#123; // 如果要查找的元素为 null</span><br><span class="line">        for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; // 从头节点开始向后遍历链表</span><br><span class="line">            if (x.item == null) // 如果找到了要查找的元素</span><br><span class="line">                return index; // 返回该元素的索引</span><br><span class="line">            index++; // 索引加 1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123; // 如果要查找的元素不为 null</span><br><span class="line">        for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; // 从头节点开始向后遍历链表</span><br><span class="line">            if (o.equals(x.item)) // 如果找到了要查找的元素</span><br><span class="line">                return index; // 返回该元素的索引</span><br><span class="line">            index++; // 索引加 1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1; // 如果没有找到要查找的元素，则返回 -1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> get 方法的内核其实还是 node 方法，node 方法之前已经说明过了，这里略过。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public E get(int index) &#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    return node(index).item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 其实，查这个招式还可以演化为其他的一些，比如说：</p>
<ul>
<li>getFirst() 方法用于获取第一个元素；</li>
<li>getLast() 方法用于获取最后一个元素；</li>
<li>poll() 和 pollFirst() 方法用于删除并返回第一个元素（两个方法尽管名字不同，但方法体是完全相同的）；</li>
<li>pollLast() 方法用于删除并返回最后一个元素；</li>
<li>peekFirst() 方法用于返回但不删除第一个元素。</li>
</ul>
<p><strong>03、LinkedList 的挑战 </strong></p>
<p> 说句实在话，我不是很喜欢和师兄 ArrayList 拿来比较，因为我们各自修炼的内功不同，没有孰高孰低。虽然师兄经常喊我一声师弟，但我们之间其实挺和谐的。但我知道，在外人眼里，同门师兄弟，总要一较高下的。</p>
<p> 比如说，我们俩在增删改查时候的时间复杂度。</p>
<p> 也许这就是命运吧，从我进入师门的那天起，这种争论就一直没有停息过。</p>
<p> 无论外人怎么看待我们，在我眼里，师兄永远都是一哥，我敬重他，他也愿意保护我。</p>
<p> 好戏在后头，等着瞧吧。</p>
<p> 我这里先简单聊一下，权当抛砖引玉。</p>
<p> 想象一下，你在玩一款游戏，游戏中有一个道具栏，你需要不断地往里面添加、删除道具。如果你使用的是我的师兄 ArrayList，那么每次添加、删除道具时都需要将后面的道具向后移动或向前移动，这样就会非常耗费时间。但是如果你使用的是我 LinkedList，那么只需要将新道具插入到链表中的指定位置，或者将要删除的道具从链表中删除即可，这样就可以快速地完成道具栏的更新。</p>
<p> 除了游戏中的道具栏，我 LinkedList 还可以用于实现 LRU（Least Recently Used）缓存淘汰算法。LRU 缓存淘汰算法是一种常用的缓存淘汰策略，它的基本思想是，当缓存空间不够时，优先淘汰最近最少使用的缓存数据。在实现 LRU 缓存淘汰算法时，你可以使用我LinkedList 来存储缓存数据，每次访问缓存数据时，将该数据从链表中删除并移动到链表的头部，这样链表的尾部就是最近最少使用的缓存数据，当缓存空间不够时，只需要将链表尾部的缓存数据淘汰即可。</p>
<h2 id="4-5-ArrayList和LinkedList的区别"><a href="#4-5-ArrayList和LinkedList的区别" class="headerlink" title="4.5 ArrayList和LinkedList的区别"></a>4.5 ArrayList和LinkedList的区别</h2><p> “终于，二哥，我们要聊 LinkedList 和 ArrayList 之间的差别了，我期待了很久。”三妹嘟囔着说。</p>
<p> “其实经过前面两节的分析，差别已经很清晰了。”我喃喃道。</p>
<p> “哥，你再说点吧，深挖一下，OK？”</p>
<p> “好吧，那就让我们出发吧！”</p>
<blockquote>
<p>PS：为了和前面两节的源码做适当的区分，这里采用的是 Java 11 的源码，请务必注意。但整体上差别很小。</p>
</blockquote>
<p> <strong>01、ArrayList 是如何实现的？ </strong></p>
<p> ArrayList 实现了 List 接口，继承了 AbstractList 抽象类。</p>
<p><img src="\assets\note\image-20231010104643407.png" alt="image-20231010104643407"></p>
<p> 底层是基于数组实现的，并且实现了动态扩容（当需要添加新元素时，如果 elementData 数组已满，则会自动扩容，新的容量将是原来的 1.5 倍），来看一下 ArrayList 的部分源码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class="line">        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    private static final int DEFAULT_CAPACITY = 10; // 默认容量为 10</span><br><span class="line">    transient Object[] elementData; // 存储元素的数组，数组类型为 Object</span><br><span class="line">    private int size; // 列表的大小，即列表中元素的个数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> ArrayList 还实现了 RandomAccess 接口，这是一个标记接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public interface RandomAccess &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 内部是空的，标记“实现了这个接口的类支持快速（通常是固定时间）随机访问”。快速随机访问是什么意思呢？就是说不需要遍历，就可以通过下标（索引）直接访问到内存地址。而 LinkedList 没有实现该接口，表示它不支持高效的随机访问，需要通过遍历来访问元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 返回列表中指定位置的元素。</span><br><span class="line"> *</span><br><span class="line"> * @param index 要返回的元素的索引</span><br><span class="line"> * @return 列表中指定位置的元素</span><br><span class="line"> * @throws IndexOutOfBoundsException 如果索引越界（index &lt; 0 || index &gt;= size()）</span><br><span class="line"> */</span><br><span class="line">public E get(int index) &#123;</span><br><span class="line">    Objects.checkIndex(index, size); // 检查索引是否越界</span><br><span class="line">    return elementData(index); // 调用 elementData 方法获取元素</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 返回列表中指定位置的元素。</span><br><span class="line"> * 注意：该方法并没有检查索引是否越界，调用该方法前需要先检查索引是否越界。</span><br><span class="line"> *</span><br><span class="line"> * @param index 要返回的元素的索引</span><br><span class="line"> * @return 列表中指定位置的元素</span><br><span class="line"> */</span><br><span class="line">E elementData(int index) &#123;</span><br><span class="line">    return (E) elementData[index]; // 强制类型转换，将 Object 类型转换为 E 类型</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> ArrayList 还实现了 Cloneable 接口，这表明 ArrayList 是支持拷贝的。ArrayList 内部的确也重写了 Object 类的 clone() 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 返回该列表的浅表副本。</span><br><span class="line"> * （元素本身不会被复制。）</span><br><span class="line"> *</span><br><span class="line"> * @return 该列表的副本</span><br><span class="line"> */</span><br><span class="line">public Object clone() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone(); // 调用 Object 类的 clone 方法，得到一个浅表副本</span><br><span class="line">        v.elementData = Arrays.copyOf(elementData, size); // 复制 elementData 数组，创建一个新数组作为副本</span><br><span class="line">        v.modCount = 0; // 将 modCount 置为 0</span><br><span class="line">        return v; // 返回副本</span><br><span class="line">    &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">        // this shouldn&#x27;t happen, since we are Cloneable</span><br><span class="line">        throw new InternalError(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> ArrayList 还实现了 Serializable 接口，同样是一个标记接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public interface Serializable &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 内部也是空的，标记“实现了这个接口的类支持序列化”。序列化是什么意思呢？Java 的序列化是指，将对象转换成以字节序列的形式来表示，这些字节序中包含了对象的字段和方法。序列化后的对象可以被写到数据库、写到文件，也可用于网络传输。</p>
<p> 眼睛雪亮的小伙伴可能会注意到，ArrayList 中的关键字段 elementData 使用了 transient 关键字修饰，这个关键字的作用是，让它修饰的字段不被序列化。</p>
<p> 这不前后矛盾吗？一个类既然实现了 Serilizable 接口，肯定是想要被序列化的，对吧？那为什么保存关键数据的 elementData 又不想被序列化呢?</p>
<p> 这还得从 “ArrayList 是基于数组实现的”开始说起。大家都知道，数组是定长的，就是说，数组一旦声明了，长度（容量）就是固定的，不能像某些东西一样伸缩自如。这就很麻烦，数组一旦装满了，就不能添加新的元素进来了。</p>
<p> ArrayList 不想像数组这样活着，它想能屈能伸，所以它实现了动态扩容。一旦在添加元素的时候，发现容量用满了 s == elementData.length ，就按照原来数组的 1.5 倍（ oldCapacity &gt;&gt; 1 ）进行扩容。扩容之后，再将原有的数组复制到新分配的内存地址上 Arrays.copyOf(elementData, newCapacity) 。</p>
<p> 这部分源码我们在之前讲 ArrayList 的时候就已经讲的很清楚了，这里就一笔带过。</p>
<p> 动态扩容意味着什么？</p>
<p> 意味着数组的实际大小可能永远无法被填满的，总有多余出来空置的内存空间。</p>
<p> 比如说，默认的数组大小是 10，当添加第 11 个元素的时候，数组的长度扩容了 1.5 倍，也就是 15，意味着还有 4 个内存空间是闲置的，对吧？</p>
<p> 序列化的时候，如果把整个数组都序列化的话，是不是就多序列化了 4 个内存空间。当存储的元素数量非常非常多的时候，闲置的空间就非常非常大，序列化耗费的时间就会非常非常多。</p>
<p> 于是，ArrayList 做了一个愉快而又聪明的决定，内部提供了两个私有方法 writeObject 和 readObject 来完成序列化和反序列化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 将此列表实例的状态序列写入指定的 ObjectOutputStream。</span><br><span class="line"> * （即，保存这个列表实例到一个流中。）</span><br><span class="line"> *</span><br><span class="line"> * @param s 要写入的流</span><br><span class="line"> * @throws java.io.IOException 如果写入流时发生异常</span><br><span class="line"> */</span><br><span class="line">private void writeObject(java.io.ObjectOutputStream s)</span><br><span class="line">        throws java.io.IOException &#123;</span><br><span class="line">    s.defaultWriteObject(); // 写出对象的默认字段</span><br><span class="line">    // Write out size as capacity for behavioral compatibility with clone()</span><br><span class="line">    s.writeInt(size); // 写出 size</span><br><span class="line">    // Write out all elements in the proper order.</span><br><span class="line">    for (int i=0; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]); // 依次写出 elementData 数组中的元素</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 从 writeObject 方法的源码中可以看得出，它使用了 ArrayList 的实际大小 size 而不是数组的长度（ elementData.length ）来作为元素的上限进行序列化。</p>
<p> 此处应该有掌声啊！不是为我，为 Java 源码的作者们，他们真的是太厉害了，可以用两个词来形容他们——殚精竭虑、精益求精。</p>
<p> 666</p>
<p> 这是readObject方法的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 从指定的 ObjectInputStream 中读取此列表实例的状态序列。</span><br><span class="line"> * （即，从流中恢复这个列表实例。）</span><br><span class="line"> *</span><br><span class="line"> * @param s 从中读取此列表实例的状态序列的流</span><br><span class="line"> * @throws java.io.IOException 如果读取流时发生异常</span><br><span class="line"> * @throws ClassNotFoundException 如果在读取流时找不到类</span><br><span class="line"> */</span><br><span class="line">private void readObject(java.io.ObjectInputStream s)</span><br><span class="line">        throws java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">    elementData = EMPTY_ELEMENTDATA; // 初始化 elementData 数组为空数组</span><br><span class="line">    // 读取默认字段</span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    // 读取容量，这个值被忽略，因为在 ArrayList 中，容量和长度是两个不同的概念</span><br><span class="line">    s.readInt();</span><br><span class="line">    if (size &gt; 0) &#123;</span><br><span class="line">        // 分配一个新的 elementData 数组，大小为 size</span><br><span class="line">        ensureCapacityInternal(size);</span><br><span class="line">        Object[] a = elementData;</span><br><span class="line">        // 依次从输入流中读取元素，并将其存储在数组中</span><br><span class="line">        for (int i=0; i&lt;size; i++) &#123;</span><br><span class="line">            a[i] = s.readObject(); // 读取对象并存储在 elementData 数组中</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>02、LinkedList 是如何实现的？ </strong></p>
<p> LinkedList 是一个继承自 AbstractSequentialList 的双向链表，因此它也可以被当作堆栈、队列或双端队列进行操作。</p>
<p><img src="\assets\note\image-20231010105516540.png" alt="image-20231010105516540"></p>
<p> 来看一下部分源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedList&lt;E&gt;</span><br><span class="line">    extends AbstractSequentialList&lt;E&gt;</span><br><span class="line">    implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    transient int size = 0; // 非序列化字段，表示链表中的节点个数</span><br><span class="line">    transient Node&lt;E&gt; first; // 非序列化字段，指向链表中的第一个节点</span><br><span class="line">    transient Node&lt;E&gt; last; // 非序列化字段，指向链表中的最后一个节点</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  LinkedList 内部定义了一个 Node 节点，它包含 3 个部分：元素内容 item，前引用 prev 和后引用 next。</p>
<p> 这个在讲 LinkedList 的时候也讲过了，这里略过。</p>
<p> LinkedList 还实现了 Cloneable 接口，这表明 LinkedList 是支持拷贝的。</p>
<p> LinkedList 还实现了 Serializable 接口，这表明 LinkedList 是支持序列化的。眼睛雪亮的小伙伴可能又注意到了，LinkedList 中的关键字段 size、first、last 都使用了 transient 关键字修饰，这不又矛盾了吗？到底是想序列化还是不想序列化？</p>
<p> 答案是 LinkedList 想按照自己的方式序列化，来看它自己实现的 writeObject() 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void writeObject(java.io.ObjectOutputStream s)</span><br><span class="line">        throws java.io.IOException &#123;</span><br><span class="line">    // 写入默认的序列化标记</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line">    // 写入链表的节点个数</span><br><span class="line">    s.writeInt(size);</span><br><span class="line">    // 按正确的顺序写入所有元素</span><br><span class="line">    for (LinkedList.Node&lt;E&gt; x = first; x != null; x = x.next)</span><br><span class="line">        s.writeObject(x.item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 发现没？LinkedList 在序列化的时候只保留了元素的内容 item，并没有保留元素的前后引用。这样就节省了不少内存空间，对吧？</p>
<p> 那有些小伙伴可能就疑惑了，只保留元素内容，不保留前后引用，那反序列化的时候怎么办？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private void readObject(java.io.ObjectInputStream s)</span><br><span class="line">        throws java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">    // 读取默认的序列化标记</span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    // 读取链表的节点个数</span><br><span class="line">    int size = s.readInt();</span><br><span class="line">    // 按正确的顺序读取所有元素</span><br><span class="line">    for (int i = 0; i &lt; size; i++)</span><br><span class="line">        linkLast((E)s.readObject()); // 读取元素并将其添加到链表末尾</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void linkLast(E e) &#123;</span><br><span class="line">    final LinkedList.Node&lt;E&gt; l = last;</span><br><span class="line">    final LinkedList.Node&lt;E&gt; newNode = new LinkedList.Node&lt;&gt;(l, e, null);</span><br><span class="line">    last = newNode; // 将新节点作为链表尾节点</span><br><span class="line">    if (l == null)</span><br><span class="line">        first = newNode; // 如果链表为空，将新节点作为链表头节点</span><br><span class="line">    else</span><br><span class="line">        l.next = newNode; // 否则将新节点链接到链表尾部</span><br><span class="line">    size++; // 增加节点个数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 注意 for 循环中的 linkLast() 方法，它可以把链表重新链接起来，这样就恢复了链表序列化之前的顺序。</p>
<p> 很妙，对吧？</p>
<p> 和 ArrayList 相比，LinkedList 没有实现 RandomAccess 接口，这是因为 LinkedList 存储数据的内存地址是不连续的，所以不支持随机访问。</p>
<p><strong>03、新增元素时究竟谁快？ </strong></p>
<p> 前面我们已经从多个维度了解了 ArrayList 和 LinkedList 的实现原理和各自的特点。那接下来，我们就来聊聊 ArrayList 和 LinkedList 在新增元素时究竟谁快？</p>
<p><strong>1）ArrayList </strong></p>
<p> ArrayList 新增元素有两种情况，一种是直接将元素添加到数组末尾，一种是将元素插入到指定位置。</p>
<p> 添加到数组末尾的源码（这部分前面讲 ArrayList 的时候讲过了，这里再温故一下）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    add(e, elementData, size);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">private void add(E e, Object[] elementData, int s) &#123;</span><br><span class="line">    if (s == elementData.length)</span><br><span class="line">        elementData = grow(); // 扩容数组</span><br><span class="line">    elementData[s] = e; // 将元素添加到数组末尾</span><br><span class="line">    size = s + 1; // 增加元素个数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 很简单，先判断是否需要扩容，然后直接通过索引将元素添加到末尾。</p>
<p> 插入到指定位置的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> public void add(int index, E element) &#123;</span><br><span class="line">    rangeCheckForAdd(index); // 检查插入位置是否越界</span><br><span class="line">    final int s; // 当前元素个数</span><br><span class="line">    Object[] elementData; // 元素数组</span><br><span class="line">    if ((s = size) == (elementData = this.elementData).length) // 如果数组已满，则扩容</span><br><span class="line">        elementData = grow();</span><br><span class="line">    System.arraycopy(elementData, index,</span><br><span class="line">            elementData, index + 1,</span><br><span class="line">            s - index); // 将插入位置后的元素向右移动一位</span><br><span class="line">    elementData[index] = element; // 将新元素插入到指定位置</span><br><span class="line">    size = s + 1; // 增加元素个数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 先检查插入的位置是否在合理的范围之内，然后判断是否需要扩容，再把该位置以后的元素复制到新添加元素的位置之后，最后通过索引将元素添加到指定的位置。</p>
<p><strong>2）LinkedList </strong></p>
<p> LinkedList 新增元素也有两种情况，一种是直接将元素添加到队尾，一种是将元素插入到指定位置。</p>
<p> 添加到队尾的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    linkLast(e); // 将元素添加到链表末尾</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">void linkLast(E e) &#123;</span><br><span class="line">    final LinkedList.Node&lt;E&gt; l = last; // 获取链表的尾节点</span><br><span class="line">    final LinkedList.Node&lt;E&gt; newNode = new LinkedList.Node&lt;&gt;(l, e, null); // 创建新节点</span><br><span class="line">    last = newNode; // 将新节点作为链表的尾节点</span><br><span class="line">    if (l == null)</span><br><span class="line">        first = newNode; // 如果链表为空，则将新节点作为链表的头节点</span><br><span class="line">    else</span><br><span class="line">        l.next = newNode; // 否则将新节点链接到链表的尾部</span><br><span class="line">    size++; // 增加节点个数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 先将队尾的节点 last 存放到临时变量 l 中，然后生成新的 Node 节点，并赋给 last，如果 l  为 null，说明是第一次添加，所以 first 为新的节点；否则将新的节点赋给之前 last 的 next。</p>
<p> 插入到指定位置的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">    checkPositionIndex(index); // 检查插入位置是否越界</span><br><span class="line">    if (index == size)</span><br><span class="line">        linkLast(element); // 如果插入位置为链表末尾，则将元素添加到链表末尾</span><br><span class="line">    else</span><br><span class="line">        linkBefore(element, node(index)); // 否则将元素插入到指定位置的前面的节点后面</span><br><span class="line">&#125;</span><br><span class="line">LinkedList.Node&lt;E&gt; node(int index) &#123;</span><br><span class="line">    if (index &lt; (size &gt;&gt; 1)) &#123; // 如果插入位置在链表前半部分，则从头节点开始查找</span><br><span class="line">        LinkedList.Node&lt;E&gt; x = first;</span><br><span class="line">        for (int i = 0; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        return x;</span><br><span class="line">    &#125; else &#123; // 否则从尾节点开始查找</span><br><span class="line">        LinkedList.Node&lt;E&gt; x = last;</span><br><span class="line">        for (int i = size - 1; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void linkBefore(E e, LinkedList.Node&lt;E&gt; succ) &#123;</span><br><span class="line">    final LinkedList.Node&lt;E&gt; pred = succ.prev; // 获取插入位置的前驱节点</span><br><span class="line">    final LinkedList.Node&lt;E&gt; newNode = new LinkedList.Node&lt;&gt;(pred, e, succ); // 创建新节点</span><br><span class="line">    succ.prev = newNode; // 将新节点链接到后继节点</span><br><span class="line">    if (pred == null)</span><br><span class="line">        first = newNode; // 如果前驱节点为空，则将新节点作为头节点</span><br><span class="line">    else</span><br><span class="line">        pred.next = newNode; // 否则将新节点链接到前驱节点</span><br><span class="line">    size++; // 增加节点个数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 先检查插入的位置是否在合理的范围之内，然后判断插入的位置是否是队尾，如果是，添加到队尾；否则执行 linkBefore() 方法。</p>
<p> 在执行 linkBefore() 方法之前，会调用 node() 方法查找指定位置上的元素，这一步是需要遍历 LinkedList 的。如果插入的位置靠前前半段，就从队头开始往后找；否则从队尾往前找。也就是说，如果插入的位置越靠近 LinkedList 的中间位置，遍历所花费的时间就越多。</p>
<p> 找到指定位置上的元素（参数succ）之后，就开始执行 linkBefore() 方法，先将 succ 的前一个节点（prev）存放到临时变量 pred 中，然后生成新的 Node 节点（newNode），并将 succ 的前一个节点变更为 newNode，如果 pred 为 null，说明插入的是队头，所以 first 为新节点；否则将 pred 的后一个节点变更为 newNode。</p>
<p><img src="\assets\note\image-20231010110120018.png" alt="image-20231010110120018"></p>
<p> 经过源码分析以后，你是不是在想：“好像 ArrayList 在新增元素的时候效率并不一定比 LinkedList 低啊！”</p>
<p> 当两者的起始长度是一样的情况下：</p>
<ul>
<li><p>如果是从集合的头部新增元素，ArrayList 花费的时间应该比 LinkedList 多，因为需要对头部以后的元素进行复制。</p>
<p>我们来测试一下：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayListTest &#123;</span><br><span class="line">    public static void addFromHeaderTest(int num) &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(num);</span><br><span class="line">        int i = 0;</span><br><span class="line">        long timeStart = System.currentTimeMillis();</span><br><span class="line">        while (i &lt; num) &#123;</span><br><span class="line">            list.add(0, i + &quot;沉默王二&quot;);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        long timeEnd = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;ArrayList从集合头部位置新增元素花费的时间&quot; + (timeEnd - timeStart));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class LinkedListTest &#123;</span><br><span class="line">    public static void addFromHeaderTest(int num) &#123;</span><br><span class="line">        LinkedList&lt;String&gt; list = new LinkedList&lt;String&gt;();</span><br><span class="line">        int i = 0;</span><br><span class="line">        long timeStart = System.currentTimeMillis();</span><br><span class="line">        while (i &lt; num) &#123;</span><br><span class="line">            list.addFirst(i + &quot;沉默王二&quot;);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        long timeEnd = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;LinkedList从集合头部位置新增元素花费的时间&quot; + (timeEnd - timeStart));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> num 为 10000，代码实测后的时间如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList从集合头部位置新增元素花费的时间595</span><br><span class="line">LinkedList从集合头部位置新增元素花费的时间15</span><br></pre></td></tr></table></figure>
<p> 此时，ArrayList 花费的时间比 LinkedList 要多很多。</p>
<ul>
<li><p>如果是从集合的中间位置新增元素，ArrayList 花费的时间搞不好要比 LinkedList 少，因为 LinkedList 需要遍历。</p>
<p>来看测试代码。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayListTest &#123;</span><br><span class="line">    public static void addFromMidTest(int num) &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(num);</span><br><span class="line">        int i = 0;</span><br><span class="line">        long timeStart = System.currentTimeMillis();</span><br><span class="line">        while (i &lt; num) &#123;</span><br><span class="line">            int temp = list.size();</span><br><span class="line">            list.add(temp / 2, i + &quot;沉默王二&quot;);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        long timeEnd = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;ArrayList从集合中间位置新增元素花费的时间&quot; + (timeEnd - timeStart));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class LinkedListTest &#123;</span><br><span class="line">    public static void addFromMidTest(int num) &#123;</span><br><span class="line">        LinkedList&lt;String&gt; list = new LinkedList&lt;String&gt;();</span><br><span class="line">        int i = 0;</span><br><span class="line">        long timeStart = System.currentTimeMillis();</span><br><span class="line">        while (i &lt; num) &#123;</span><br><span class="line">            int temp = list.size();</span><br><span class="line">            list.add(temp / 2, i + &quot;沉默王二&quot;);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        long timeEnd = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;LinkedList从集合中间位置新增元素花费的时间&quot; + (timeEnd - timeStart));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>num 为 10000，代码实测后的时间如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList从集合中间位置新增元素花费的时间16</span><br><span class="line">LinkedList从集合中间位置新增元素花费的时间114</span><br></pre></td></tr></table></figure>
<p>ArrayList 花费的时间比 LinkedList 要少很多很多。</p>
<ul>
<li>如果是从集合的尾部新增元素，ArrayList 花费的时间应该比 LinkedList 少，因为数组是一段连续的内存空间，也不需要复制数组；而链表需要创建新的对象，前后引用也要重新排列。</li>
</ul>
<p>来看测试代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedListTest &#123;</span><br><span class="line">    public static void addFromTailTest(int num) &#123;</span><br><span class="line">        LinkedList&lt;String&gt; list = new LinkedList&lt;String&gt;();</span><br><span class="line">        int i = 0;</span><br><span class="line">        long timeStart = System.currentTimeMillis();</span><br><span class="line">        while (i &lt; num) &#123;</span><br><span class="line">            list.add(i + &quot;沉默王二&quot;);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        long timeEnd = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;LinkedList从集合尾部位置新增元素花费的时间&quot; + (timeEnd - timeStart));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ArrayListTest &#123;</span><br><span class="line">    public static void addFromTailTest(int num) &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(num);</span><br><span class="line">        int i = 0;</span><br><span class="line">        long timeStart = System.currentTimeMillis();</span><br><span class="line">        while (i &lt; num) &#123;</span><br><span class="line">            list.add(i + &quot;沉默王二&quot;);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        long timeEnd = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;ArrayList从集合尾部位置新增元素花费的时间&quot; + (timeEnd - timeStart));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>num 为 10000，代码实测后的时间如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList从集合尾部位置新增元素花费的时间69</span><br><span class="line">LinkedList从集合尾部位置新增元素花费的时间193</span><br></pre></td></tr></table></figure>
<p>ArrayList 花费的时间比 LinkedList 要少一些。</p>
<p>这样的结论和预期的是不是不太相符？ArrayList 在添加元素的时候如果不涉及到扩容，性能在两种情况下（中间位置新增元素、尾部新增元素）比 LinkedList 好很多，只有头部新增元素的时候比 LinkedList 差，因为数组复制的原因。</p>
<p>当然了，如果涉及到数组扩容的话，ArrayList 的性能就没那么可观了，因为扩容的时候也要复制数组。</p>
<p><strong>04、删除元素时究竟谁快？ </strong></p>
<p><strong>1）ArrayList </strong></p>
<p>ArrayList 删除元素的时候，有两种方式，一种是直接删除元素（ remove(Object) ），需要直先遍历数组，找到元素对应的索引；一种是按照索引删除元素（ remove(int) ）。</p>
<p>来看一下源码（其实前面也讲过了，这里温习一下）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    final Object[] es = elementData; // 获取数组元素</span><br><span class="line">    final int size = this.size; // 获取数组大小</span><br><span class="line">    int i = 0;</span><br><span class="line">    found: &#123;</span><br><span class="line">        if (o == null) &#123;</span><br><span class="line">            for (; i &lt; size; i++)</span><br><span class="line">                if (es[i] == null)</span><br><span class="line">                    break found;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (; i &lt; size; i++)</span><br><span class="line">                if (o.equals(es[i]))</span><br><span class="line">                    break found;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    fastRemove(es, i); // 调用 fastRemove 方法快速移除元素</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public E remove(int index) &#123;</span><br><span class="line">    Objects.checkIndex(index, size); // 检查索引是否越界</span><br><span class="line">    final Object[] es = elementData; // 获取数组元素</span><br><span class="line">    oldValue = (E) es[index]; // 获取要删除的元素</span><br><span class="line">    fastRemove(es, index); // 调用 fastRemove 方法快速移除元素</span><br><span class="line">    return oldValue; // 返回被删除的元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本质上讲，两个方法是一样的，它们最后调用的都是 fastRemove(Object, int) 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private void fastRemove(Object[] es, int i) &#123;</span><br><span class="line">    final int newSize;</span><br><span class="line">    if ((newSize = size - 1) &gt; i) // 如果要删除的不是最后一个元素</span><br><span class="line">        System.arraycopy(es, i + 1, es, i, newSize - i); // 将要删除元素后面的元素向前移动一位</span><br><span class="line">    es[size = newSize] = null; // 将最后一个元素置为 null，帮助垃圾回收</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从源码可以看得出，只要删除的不是最后一个元素，都需要重新移动数组。删除的元素位置越靠前，代价就越大。</p>
<p><strong>2）LinkedList </strong></p>
<p>LinkedList 删除元素的时候，有四种常用的方式：</p>
<ul>
<li>remove(int) ，删除指定位置上的元素</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public E remove(int index) &#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    return unlink(node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先检查索引，再调用 node(int) 方法（ 前后半段遍历，和新增元素操作一样）找到节点 Node，然后调用 unlink(Node) 解除节点的前后引用，同时更新前节点的后引用和后节点的前引用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">E unlink(Node&lt;E&gt; x) &#123;</span><br><span class="line">    final E element = x.item; // 获取要删除的节点的元素</span><br><span class="line">    final Node&lt;E&gt; next = x.next; // 获取要删除的节点的后继节点</span><br><span class="line">    final Node&lt;E&gt; prev = x.prev; // 获取要删除的节点的前驱节点</span><br><span class="line">    if (prev == null) &#123; // 如果要删除的节点是第一个节点</span><br><span class="line">        first = next; // 将头节点更新为要删除的节点的后继节点</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        prev.next = next; // 将要删除的节点的前驱节点的后继节点指向要删除的节点的后继节点</span><br><span class="line">        x.prev = null; // 将要删除的节点的前驱节点置为 null，帮助垃圾回收</span><br><span class="line">    &#125;</span><br><span class="line">    if (next == null) &#123; // 如果要删除的节点是最后一个节点</span><br><span class="line">        last = prev; // 将尾节点更新为要删除的节点的前驱节点</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        next.prev = prev; // 将要删除的节点的后继节点的前驱节点指向要删除的节点的前驱节点</span><br><span class="line">        x.next = null; // 将要删除的节点的后继节点置为 null，帮助垃圾回收</span><br><span class="line">    &#125;</span><br><span class="line">    x.item = null; // 将要删除的节点的元素置为 null，帮助垃圾回收</span><br><span class="line">    size--; // 将链表的长度减一</span><br><span class="line">    return element; // 返回被删除的元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>remove(Object) ，直接删除元素</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    if (o == null) &#123; // 如果要删除的元素为 null</span><br><span class="line">        for (LinkedList.Node&lt;E&gt; x = first; x != null; x = x.next) &#123;</span><br><span class="line">            if (x.item == null) &#123; // 如果找到了要删除的节点</span><br><span class="line">                unlink(x); // 调用 unlink 方法删除指定节点</span><br><span class="line">                return true; // 返回删除成功</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (LinkedList.Node&lt;E&gt; x = first; x != null; x = x.next) &#123;</span><br><span class="line">            if (o.equals(x.item)) &#123; // 如果找到了要删除的节点</span><br><span class="line">                unlink(x); // 调用 unlink 方法删除指定节点</span><br><span class="line">                return true; // 返回删除成功</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false; // 没有找到要删除的节点，返回删除失败</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也是先前后半段遍历，找到要删除的元素后调用 unlink(Node) 。</p>
<ul>
<li>removeFirst() ，删除第一个节点</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public E removeFirst() &#123;</span><br><span class="line">    final LinkedList.Node&lt;E&gt; f = first;</span><br><span class="line">    if (f == null)</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    return unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line">private E unlinkFirst(LinkedList.Node&lt;E&gt; f) &#123;</span><br><span class="line">    final E element = f.item; // 获取要删除的节点的元素</span><br><span class="line">    final LinkedList.Node&lt;E&gt; next = f.next; // 获取要删除的节点的后继节点</span><br><span class="line">    f.item = null; // 将要删除的节点的元素置为 null，帮助垃圾回收</span><br><span class="line">    f.next = null; // 将要删除的节点的后继节点置为 null，帮助垃圾回收</span><br><span class="line">    first = next; // 将头节点更新为要删除的节点的后继节点</span><br><span class="line">    if (next == null) // 如果链表已经为空</span><br><span class="line">        last = null; // 将尾节点置为 null</span><br><span class="line">    else</span><br><span class="line">        next.prev = null; // 将要删除的节点的后继节点的前驱节点置为 null，帮助垃圾回收</span><br><span class="line">    size--; // 将链表的长度减一</span><br><span class="line">    return element; // 返回被删除的元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除第一个节点就不需要遍历了，只需要把第二个节点更新为第一个节点即可。</p>
<ul>
<li>removeLast() ，删除最后一个节点</li>
</ul>
<p>删除最后一个节点和删除第一个节点类似，只需要把倒数第二个节点更新为最后一个节点即可。</p>
<p>可以看得出，LinkedList 在删除比较靠前和比较靠后的元素时，非常高效，但如果删除的是中间位置的元素，效率就比较低了。</p>
<p>这里就不再做代码测试了，感兴趣的话可以自己试试，结果和新增元素保持一致：</p>
<ul>
<li>从集合头部删除元素时，ArrayList 花费的时间比 LinkedList 多很多；</li>
<li>从集合中间位置删除元素时，ArrayList 花费的时间比 LinkedList 少很多；</li>
<li>从集合尾部删除元素时，ArrayList 花费的时间比 LinkedList 少一点。</li>
</ul>
<p>我本地的统计结果如下所示，可以作为参考：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ArrayList从集合头部位置删除元素花费的时间380</span><br><span class="line">LinkedList从集合头部位置删除元素花费的时间4</span><br><span class="line">ArrayList从集合中间位置删除元素花费的时间381</span><br><span class="line">LinkedList从集合中间位置删除元素花费的时间5922</span><br><span class="line">ArrayList从集合尾部位置删除元素花费的时间8</span><br><span class="line">LinkedList从集合尾部位置删除元素花费的时间12</span><br></pre></td></tr></table></figure>
<p><strong>05、遍历元素时究竟谁快？ </strong></p>
<p><strong>1）ArrayList </strong></p>
<p>遍历 ArrayList 找到某个元素的话，通常有两种形式：</p>
<ul>
<li>get(int) ，根据索引找元素</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public E get(int index) &#123;</span><br><span class="line">    Objects.checkIndex(index, size);</span><br><span class="line">    return elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 ArrayList 是由数组实现的，所以根据索引找元素非常的快，一步到位。</p>
<ul>
<li>indexOf(Object) ，根据元素找索引</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public int indexOf(Object o) &#123;</span><br><span class="line">    return indexOfRange(o, 0, size);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int indexOfRange(Object o, int start, int end) &#123;</span><br><span class="line">    Object[] es = elementData; // 获取 ArrayList 中的元素数组</span><br><span class="line">    if (o == null) &#123; // 如果要查找的元素为 null</span><br><span class="line">        for (int i = start; i &lt; end; i++) &#123;</span><br><span class="line">            if (es[i] == null) &#123; // 如果找到了要查找的元素</span><br><span class="line">                return i; // 返回元素在 ArrayList 中的索引</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (int i = start; i &lt; end; i++) &#123;</span><br><span class="line">            if (o.equals(es[i])) &#123; // 如果找到了要查找的元素</span><br><span class="line">                return i; // 返回元素在 ArrayList 中的索引</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1; // 没有找到要查找的元素，返回 -1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据元素找索引的话，就需要遍历整个数组了，从头到尾依次找。</p>
<p><strong>2）LinkedList </strong></p>
<p>遍历 LinkedList 找到某个元素的话，通常也有两种形式：</p>
<ul>
<li>get(int) ，找指定位置上的元素</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public E get(int index) &#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    return node(index).item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>既然需要调用 node(int) 方法，就意味着需要前后半段遍历了。</p>
<ul>
<li>indexOf(Object) ，找元素所在的位置</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public int indexOf(Object o) &#123;</span><br><span class="line">    int index = 0; // 初始化索引为 0</span><br><span class="line">    if (o == null) &#123; // 如果要查找的元素为 null</span><br><span class="line">        for (LinkedList.Node&lt;E&gt; x = first; x != null; x = x.next) &#123; // 从头节点开始遍历链表</span><br><span class="line">            if (x.item == null) // 如果找到了要查找的元素</span><br><span class="line">                return index; // 返回元素在 LinkedList 中的索引</span><br><span class="line">            index++; // 索引加一</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (LinkedList.Node&lt;E&gt; x = first; x != null; x = x.next) &#123; // 从头节点开始遍历链表</span><br><span class="line">            if (o.equals(x.item)) // 如果找到了要查找的元素</span><br><span class="line">                return index; // 返回元素在 LinkedList 中的索引</span><br><span class="line">            index++; // 索引加一</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1; // 没有找到要查找的元素，返回 -1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要遍历整个链表，和 ArrayList 的 indexOf() 类似。</p>
<p>那在我们对集合遍历的时候，通常有两种做法，一种是使用 for 循环，一种是使用迭代器（Iterator）。</p>
<p>如果使用的是 for 循环，可想而知 LinkedList 在 get 的时候性能会非常差，因为每一次外层的 for 循环，都要执行一次 node(int) 方法进行前后半段的遍历。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">LinkedList.Node&lt;E&gt; node(int index) &#123;</span><br><span class="line">    // assert isElementIndex(index);</span><br><span class="line">    if (index &lt; (size &gt;&gt; 1)) &#123; // 如果要查找的元素在链表的前半部分</span><br><span class="line">        LinkedList.Node&lt;E&gt; x = first; // 从头节点开始遍历链表</span><br><span class="line">        for (int i = 0; i &lt; index; i++) // 循环查找元素</span><br><span class="line">            x = x.next;</span><br><span class="line">        return x; // 返回要查找的元素节点</span><br><span class="line">    &#125; else &#123; // 如果要查找的元素在链表的后半部分</span><br><span class="line">        LinkedList.Node&lt;E&gt; x = last; // 从尾节点开始遍历链表</span><br><span class="line">        for (int i = size - 1; i &gt; index; i--) // 循环查找元素</span><br><span class="line">            x = x.prev;</span><br><span class="line">        return x; // 返回要查找的元素节点</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那如果使用的是迭代器呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;String&gt; list = new LinkedList&lt;String&gt;();</span><br><span class="line">for (Iterator&lt;String&gt; it = list.iterator(); it.hasNext();) &#123;</span><br><span class="line">    it.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代器只会调用一次 node(int) 方法，在执行 list.iterator() 的时候：先调用 AbstractSequentialList 类的 iterator() 方法，再调用 AbstractList 类的 listIterator() 方法，再调用 LinkedList 类的 listIterator(int) 方法，如下图所示。</p>
<p><img src="\assets\note\image-20231010111515822.png" alt="image-20231010111515822"></p>
<p>最后返回的是 LinkedList 类的内部私有类 ListItr 对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public ListIterator&lt;E&gt; listIterator(int index) &#123;</span><br><span class="line">    checkPositionIndex(index); // 检查索引是否在有效范围内</span><br><span class="line">    return new LinkedList.ListItr(index); // 创建一个新的 ListItr 对象并返回</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private class ListItr implements ListIterator&lt;E&gt; &#123;</span><br><span class="line">    private LinkedList.Node&lt;E&gt; lastReturned; // 上一个已返回的节点</span><br><span class="line">    private LinkedList.Node&lt;E&gt; next; // 下一个节点</span><br><span class="line">    private int nextIndex; // 下一个节点的索引</span><br><span class="line">    private int expectedModCount = modCount; // 链表被修改的次数</span><br><span class="line">    ListItr(int index) &#123;</span><br><span class="line">        // assert isPositionIndex(index);</span><br><span class="line">        next = (index == size) ? null : node(index); // 如果 index 等于 size，next 为 null，否则返回 node(index)</span><br><span class="line">        nextIndex = index; // 设置 nextIndex 为 index</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean hasNext() &#123;</span><br><span class="line">        return nextIndex &lt; size; // 如果下一个节点的索引小于链表的长度，返回 true，否则返回 false</span><br><span class="line">    &#125;</span><br><span class="line">    public E next() &#123;</span><br><span class="line">        checkForComodification(); // 检查链表是否已经被修改</span><br><span class="line">        if (!hasNext()) // 如果没有下一个节点，抛出 NoSuchElementException 异常</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">        lastReturned = next; // 将下一个节点设置为上一个已返回节点</span><br><span class="line">        next = next.next; // 将下一个节点设置为当前节点的下一个节点</span><br><span class="line">        nextIndex++; // 将下一个节点的索引增加 1</span><br><span class="line">        return lastReturned.item; // 返回上一个已返回节点的元素</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行 ListItr 的构造方法时调用了一次 node(int) 方法，返回第一个节点。在此之后，迭代器就执行 hasNext() 判断有没有下一个，执行 next() 方法下一个节点。</p>
<p>由此，可以得出这样的结论：遍历 LinkedList 的时候，千万不要使用 for 循环，要使用迭代器。</p>
<p>也就是说，for 循环遍历的时候，ArrayList 花费的时间远小于 LinkedList；迭代器遍历的时候，两者性能差不多。</p>
<p><strong>06、两者的使用场景 </strong></p>
<p>当需要频繁随机访问元素的时候，例如读取大量数据并进行处理或者需要对数据进行排序或查找的场景，可以使用 ArrayList。例如一个学生管理系统，需要对学生列表进行排序或查找操作，可以使用 ArrayList 存储学生信息，以便快速访问和处理。</p>
<p>当需要频繁插入和删除元素的时候，例如实现队列或栈，或者需要在中间插入或删除元素的场景，可以使用 LinkedList。例如一个实时聊天系统，需要实现一个消息队列，可以使用 LinkedList 存储消息，以便快速插入和删除消息。</p>
<p>在一些特殊场景下，可能需要同时支持随机访问和插入/删除操作。例如一个在线游戏系统，需要实现一个玩家列表，需要支持快速查找和遍历玩家，同时也需要支持玩家的加入和离开。在这种情况下，可以使用 LinkedList 和 ArrayList 的组合，例如使用 LinkedList 存储玩家，以便快速插入和删除玩家，同时使用 ArrayList 存储玩家列表，以便快速查找和遍历玩家。</p>
<p>“好了，三妹，关于 LinkedList 和 ArrayList 的差别，我们就先聊到这，你也不用太去扣细节，直到其中的差别就好了。”</p>
<p>“好的，二哥。”</p>
<h2 id="4-6-Java泛型，深入解析"><a href="#4-6-Java泛型，深入解析" class="headerlink" title="4.6 Java泛型，深入解析"></a>4.6 Java泛型，深入解析</h2><p>“二哥，为什么要设计泛型啊？”三妹开门见山地问。</p>
<p>“三妹啊，听哥慢慢给你讲啊。”我说。</p>
<p>Java 在 1.5 时增加了泛型机制，据说专家们为此花费了 5 年左右的时间（听起来是相当不容易）。有了泛型之后，尤其是对集合类的使用，就变得更规范了。</p>
<p>看下面这段简单的代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">list.add(&quot;沉默王二&quot;);</span><br><span class="line">String str = list.get(0);</span><br></pre></td></tr></table></figure>
<p>“三妹，你能想象到在没有泛型之前该怎么办吗？”</p>
<p>“嗯，想不到，还是二哥你说吧。”</p>
<p>嗯，我们可以使用 Object 数组来设计 Arraylist 类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Arraylist &#123;</span><br><span class="line">    private Object[] objs;</span><br><span class="line">    private int i = 0;</span><br><span class="line">    public void add(Object obj) &#123;</span><br><span class="line">        objs[i++] = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Object get(int i) &#123;</span><br><span class="line">        return objs[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我们向 Arraylist 中存取数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Arraylist list = new Arraylist();</span><br><span class="line">list.add(&quot;沉默王二&quot;);</span><br><span class="line">list.add(new Date());</span><br><span class="line">String str = (String)list.get(0);</span><br></pre></td></tr></table></figure>
<p>“三妹，你有没有发现这两个问题？”</p>
<ul>
<li>Arraylist 可以存放任何类型的数据（既可以存字符串，也可以混入日期），因为所有类都继承自 Object 类。</li>
<li>从 Arraylist 取出数据的时候需要强制类型转换，因为编译器并不能确定你取的是字符串还是日期。</li>
</ul>
<p>“嗯嗯，是的呢。”三妹说。</p>
<p>对比一下，你就能明显地感受到泛型的优秀之处：使用类型参数解决了元素的不确定性——参数类型为 String 的集合中是不允许存放其他类型元素的，取出数据的时候也不需要强制类型转换了。</p>
<p><strong>动手设计一个泛型 </strong></p>
<p>“二哥，那怎么才能设计一个泛型呢？”</p>
<p>“三妹啊，你一个小白只要会用泛型就行了，还想设计泛型啊？！不过，既然你想了解，哥义不容辞。”</p>
<p>首先，我们来按照泛型的标准重新设计一下 Arraylist 类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Arraylist&lt;E&gt; &#123;</span><br><span class="line">    private Object[] elementData;</span><br><span class="line">    private int size = 0;</span><br><span class="line">    public Arraylist(int initialCapacity) &#123;</span><br><span class="line">        this.elementData = new Object[initialCapacity];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean add(E e) &#123;</span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    E elementData(int index) &#123;</span><br><span class="line">        return (E) elementData[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个泛型类就是具有一个或多个类型变量的类。Arraylist 类引入的类型变量为 E（Element，元素的首字母），使用尖括号 &lt;&gt; 括起来，放在类名的后面。</p>
<p>然后，我们可以用具体的类型（比如字符串）替换类型变量来实例化泛型类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Arraylist&lt;String&gt; list = new Arraylist&lt;String&gt;();</span><br><span class="line">list.add(&quot;沉默王三&quot;);</span><br><span class="line">String str = list.get(0);</span><br></pre></td></tr></table></figure>
<p>Date 类型也可以的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Arraylist&lt;Date&gt; list = new Arraylist&lt;Date&gt;();</span><br><span class="line">list.add(new Date());</span><br><span class="line">Date date = list.get(0);</span><br></pre></td></tr></table></figure>
<p>其次，我们还可以在一个非泛型的类（或者泛型类）中定义泛型方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Arraylist&lt;E&gt; &#123;</span><br><span class="line">    public &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">        return (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过，说实话，泛型方法的定义看起来略显晦涩。来一副图吧（注意：方法返回类型和方法参数类型至少需要一个）。</p>
<p><img src="\image-20231010112138716.png" alt="image-20231010112138716"></p>
<p>现在，我们来调用一下泛型方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Arraylist&lt;String&gt; list = new Arraylist&lt;&gt;(4);</span><br><span class="line">list.add(&quot;沉&quot;);</span><br><span class="line">list.add(&quot;默&quot;);</span><br><span class="line">list.add(&quot;王&quot;);</span><br><span class="line">list.add(&quot;二&quot;);</span><br><span class="line">String [] strs = new String [4];</span><br><span class="line">strs = list.toArray(strs);</span><br><span class="line">for (String str : strs) &#123;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>泛型限定符 </strong></p>
<p>然后，我们再来说说泛型变量的限定符 extends 。</p>
<p>在解释这个限定符之前，我们假设有三个类，它们之间的定义是这样的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Wanglaoer &#123;</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;王老二&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Wanger extends Wanglaoer&#123;</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;王二&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Wangxiaoer extends Wanger&#123;</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;王小二&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们使用限定符 extends 来重新设计一下 Arraylist 类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Arraylist&lt;E extends Wanger&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们向 Arraylist 中添加 Wanglaoer 元素的时候，编译器会提示错误： Arraylist 只允许添加 Wanger 及其子类 Wangxiaoer 对象，不允许添加其父类 Wanglaoer 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Arraylist&lt;Wanger&gt; list = new Arraylist&lt;&gt;(3);</span><br><span class="line">list.add(new Wanger());</span><br><span class="line">list.add(new Wanglaoer());</span><br><span class="line">// The method add(Wanger) in the type Arraylist&lt;Wanger&gt; is not applicable for the </span><br><span class="line">arguments </span><br><span class="line">// (Wanglaoer)</span><br><span class="line">list.add(new Wangxiaoer());</span><br></pre></td></tr></table></figure>
<p>也就是说，限定符 extends 可以缩小泛型的类型范围。</p>
<p><strong>类型擦除 </strong></p>
<p>“哦，明白了。”三妹若有所思的点点头，“二哥，听说虚拟机没有泛型？”</p>
<p>“三妹，你功课做得可以啊。哥可以肯定地回答你，虚拟机是没有泛型的。”</p>
<p>“怎么确定虚拟机有没有泛型呢？”三妹问。</p>
<p>“只要我们把泛型类的字节码进行反编译就看到了！”用反编译工具（我写这篇文章的时候用的是 jad，你也可以用其他的工具）将 class 文件反编译后，我说，“三妹，你看。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.</span><br><span class="line">// Jad home page: http://www.kpdus.com/jad.html</span><br><span class="line">// Decompiler options: packimports(3) </span><br><span class="line">// Source File Name:   Arraylist.java</span><br><span class="line">package com.cmower.java_demo.fanxing;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">class Arraylist</span><br><span class="line">&#123;</span><br><span class="line">    public Arraylist(int initialCapacity)</span><br><span class="line">    &#123;</span><br><span class="line">        size = 0;</span><br><span class="line">        elementData = new Object[initialCapacity];</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean add(Object e)</span><br><span class="line">    &#123;</span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    Object elementData(int index)</span><br><span class="line">    &#123;</span><br><span class="line">        return elementData[index];</span><br><span class="line">    &#125;</span><br><span class="line">    private Object elementData[];</span><br><span class="line">    private int size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类型变量 <E> 消失了，取而代之的是 Object ！</p>
<p>“既然如此，那如果泛型类使用了限定符 extends ，结果会怎么样呢？”三妹这个问题问的很巧妙。</p>
<p>来看这段代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Arraylist2&lt;E extends Wanger&gt; &#123;</span><br><span class="line">    private Object[] elementData;</span><br><span class="line">    private int size = 0;</span><br><span class="line">    public Arraylist2(int initialCapacity) &#123;</span><br><span class="line">        this.elementData = new Object[initialCapacity];</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean add(E e) &#123;</span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    E elementData(int index) &#123;</span><br><span class="line">        return (E) elementData[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反编译后的结果如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.</span><br><span class="line">// Jad home page: http://www.kpdus.com/jad.html</span><br><span class="line">// Decompiler options: packimports(3) </span><br><span class="line">// Source File Name:   Arraylist2.java</span><br><span class="line">package com.cmower.java_demo.fanxing;</span><br><span class="line">// Referenced classes of package com.cmower.java_demo.fanxing:</span><br><span class="line">//            Wanger</span><br><span class="line">class Arraylist2</span><br><span class="line">&#123;</span><br><span class="line">    public Arraylist2(int initialCapacity)</span><br><span class="line">    &#123;</span><br><span class="line">        size = 0;</span><br><span class="line">        elementData = new Object[initialCapacity];</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean add(Wanger e)</span><br><span class="line">    &#123;</span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    Wanger elementData(int index)</span><br><span class="line">    &#123;</span><br><span class="line">        return (Wanger)elementData[index];</span><br><span class="line">    &#125;</span><br><span class="line">    private Object elementData[];</span><br><span class="line">    private int size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“你看，类型变量 <E extends Wanger> 不见了，E 被替换成了 Wanger ”，我说，“通过以上两个例子说明，Java 虚拟机会将泛型的类型变量擦除，并替换为限定类型（没有限定的话，就用 Object ）”</p>
<p>“二哥，类型擦除会有什么问题吗？”三妹又问了一个很有水平的问题。</p>
<p>“三妹啊，你还别说，类型擦除真的会有一些问题。”我说，“来看一下这段代码。”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Cmower &#123;</span><br><span class="line">    </span><br><span class="line">    public static void method(Arraylist&lt;String&gt; list) &#123;</span><br><span class="line">        System.out.println(&quot;Arraylist&lt;String&gt; list&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void method(Arraylist&lt;Date&gt; list) &#123;</span><br><span class="line">        System.out.println(&quot;Arraylist&lt;Date&gt; list&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在浅层的意识上，我们会想当然地认为 Arraylist<String> list 和 Arraylist<Date> list 是两种不同的类型，因为 String 和 Date 是不同的类。</p>
<p>但由于类型擦除的原因，以上代码是不会通过编译的——编译器会提示一个错误（这正是类型擦除引发的那些“问题”）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;Erasure of method method(Arraylist&lt;String&gt;) is the same as another method in type </span><br><span class="line"> Cmower</span><br><span class="line">&gt;</span><br><span class="line">&gt;Erasure of method method(Arraylist&lt;Date&gt;) is the same as another method in type </span><br><span class="line"> Cmower</span><br></pre></td></tr></table></figure>
<p>大致的意思就是，这两个方法的参数类型在擦除后是相同的。</p>
<p>也就是说， method(Arraylist<String> list) 和 method(Arraylist<Date> list) 是同一种参数类型的方法，不能同时存在。类型变量 String 和 Date 在擦除后会自动消失，method 方法的实际参数是 Arraylist list 。</p>
<p>有句俗话叫做：“百闻不如一见”，但即使见到了也未必为真——泛型的擦除问题就可以很好地佐证这个观点。<br>      <strong>泛型通配符 </strong></p>
<p>“哦，明白了。二哥，听说泛型还有通配符？”</p>
<p>“三妹啊，哥突然觉得你很适合作一枚可爱的程序媛啊！你这预习的功课做得可真到家啊，连通配符都知道！”</p>
<p>通配符使用英文的问号 （?）来表示。在我们创建一个泛型对象时，可以使用关键字 extends 限定子类，也可以使用关键字 super 限定父类。</p>
<p>我们来看下面这段代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个泛型类 Arraylist&lt;E&gt;，E 表示元素类型</span><br><span class="line">class Arraylist&lt;E&gt; &#123;</span><br><span class="line">    // 私有成员变量，存储元素数组和元素数量</span><br><span class="line">    private Object[] elementData;</span><br><span class="line">    private int size = 0;</span><br><span class="line">    // 构造函数，传入初始容量 initialCapacity，创建一个指定容量的 Object 数组</span><br><span class="line">    public Arraylist(int initialCapacity) &#123;</span><br><span class="line">        this.elementData = new Object[initialCapacity];</span><br><span class="line">    &#125;</span><br><span class="line">    // 添加元素到数组末尾，返回添加成功与否</span><br><span class="line">    public boolean add(E e) &#123;</span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取指定下标的元素</span><br><span class="line">    public E get(int index) &#123;</span><br><span class="line">        return (E) elementData[index];</span><br><span class="line">    &#125;</span><br><span class="line">    // 查找指定元素第一次出现的下标，如果找不到则返回 -1</span><br><span class="line">    public int indexOf(Object o) &#123;</span><br><span class="line">        if (o == null) &#123;</span><br><span class="line">            for (int i = 0; i &lt; size; i++)</span><br><span class="line">                if (elementData[i]==null)</span><br><span class="line">                    return i;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (int i = 0; i &lt; size; i++)</span><br><span class="line">                if (o.equals(elementData[i]))</span><br><span class="line">                    return i;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    // 判断指定元素是否在数组中出现</span><br><span class="line">    public boolean contains(Object o) &#123;</span><br><span class="line">        return indexOf(o) &gt;= 0;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 将数组中的元素转化成字符串输出</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        </span><br><span class="line">        for (Object o : elementData) &#123;</span><br><span class="line">            if (o != null) &#123;</span><br><span class="line">                E e = (E)o;</span><br><span class="line">                sb.append(e.toString());</span><br><span class="line">                sb.append(&#x27;,&#x27;).append(&#x27; &#x27;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    // 返回数组中元素的数量</span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br><span class="line">    // 修改指定下标的元素，返回修改前的元素</span><br><span class="line">    public E set(int index, E element) &#123;</span><br><span class="line">        E oldValue = (E) elementData[index];</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1）新增 indexOf(Object o) 方法，判断元素在 Arraylist 中的位置。注意参数为 Object 而不是泛型 E 。</p>
<p>2）新增 contains(Object o) 方法，判断元素是否在 Arraylist 中。注意参数为 Object 而不是泛型 E 。</p>
<p>3）新增 toString() 方法，方便对 Arraylist 进行打印。</p>
<p>4）新增 set(int index, E element) 方法，方便对 Arraylist 元素的更改。</p>
<p>因为泛型擦除的原因， Arraylist<Wanger> list = new Arraylist<Wangxiaoer>(); 这样的语句是无法通过编译的，尽管 Wangxiaoer 是 Wanger 的子类。但如果我们确实需要这种 “向上转型” 的关系，该怎么办呢？这时候就需要通配符来发挥作用了。</p>
<p>利用 &lt;? extends Wanger&gt; 形式的通配符，可以实现泛型的向上转型，来看例子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Arraylist&lt;? extends Wanger&gt; list2 = new Arraylist&lt;&gt;(4);</span><br><span class="line">list2.add(null);</span><br><span class="line">// list2.add(new Wanger());</span><br><span class="line">// list2.add(new Wangxiaoer());</span><br><span class="line">Wanger w2 = list2.get(0);</span><br><span class="line">// Wangxiaoer w3 = list2.get(1);</span><br></pre></td></tr></table></figure>
<p>list2 的类型是 Arraylist&lt;? extends Wanger&gt; ，翻译一下就是，list2 是一个 Arraylist ，其类型是 Wanger 及其子类。</p>
<p>注意，“关键”来了！list2 并不允许通过 add(E e) 方法向其添加 Wanger 或者 Wangxiaoer 的对象，唯一例外的是 null 。</p>
<p>“那就奇了怪了，既然不让存放元素，那要 Arraylist&lt;? extends Wanger&gt; 这样的 list2 有什么用呢？”三妹好奇地问。</p>
<p>虽然不能通过 add(E e) 方法往 list2 中添加元素，但可以给它赋值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Arraylist&lt;Wanger&gt; list = new Arraylist&lt;&gt;(4);</span><br><span class="line">Wanger wanger = new Wanger();</span><br><span class="line">list.add(wanger);</span><br><span class="line">Wangxiaoer wangxiaoer = new Wangxiaoer();</span><br><span class="line">list.add(wangxiaoer);</span><br><span class="line">Arraylist&lt;? extends Wanger&gt; list2 = list;</span><br><span class="line">Wanger w2 = list2.get(1);</span><br><span class="line">System.out.println(w2);</span><br><span class="line">System.out.println(list2.indexOf(wanger));</span><br><span class="line">System.out.println(list2.contains(new Wangxiaoer()));</span><br></pre></td></tr></table></figure>
<p>Arraylist&lt;? extends Wanger&gt; list2 = list; 语句把 list 的值赋予了 list2，此时 list2 == list 。</p>
<p>由于 list2 不允许往其添加其他元素，所以此时它是安全的——我们可以从容地对 list2 进行 get() 、indexOf() 和 contains() 。想一想，如果可以向 list2 添加元素的话，这 3 个方法反而变得不太安全，它们的值可能就会变。</p>
<p>利用 &lt;? super Wanger&gt; 形式的通配符，可以向 Arraylist 中存入父类是 Wanger 的元素，来看例子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Arraylist&lt;? super Wanger&gt; list3 = new Arraylist&lt;&gt;(4);</span><br><span class="line">list3.add(new Wanger());</span><br><span class="line">list3.add(new Wangxiaoer());</span><br><span class="line">// Wanger w3 = list3.get(0);</span><br></pre></td></tr></table></figure>
<p>需要注意的是，无法从 Arraylist&lt;? super Wanger&gt; 这样类型的 list3 中取出数据。</p>
<p><strong>小结 </strong></p>
<p>好了，三妹，关于泛型，我们再来做一个简单的总结。</p>
<p>在 Java 中，泛型是一种强类型约束机制，可以在编译期间检查类型安全性，并且可以提高代码的复用性和可读性。</p>
<p><strong>1）类型参数化 </strong></p>
<p>泛型的本质是参数化类型，也就是说，在定义类、接口或方法时，可以使用一个或多个类型参数来表示参数化类型。</p>
<p>例如这样可以定义一个泛型类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Box&lt;T&gt; &#123;</span><br><span class="line">    private T value;</span><br><span class="line">    public Box(T value) &#123;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    public T getValue() &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setValue(T value) &#123;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中， <T> 表示类型参数，可以在类中任何需要使用类型的地方使用 T 代替具体的类型。通过使用泛型，我们可以创建一个可以存储任何类型对象的盒子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Box&lt;Integer&gt; intBox = new Box&lt;&gt;(123);</span><br><span class="line">Box&lt;String&gt; strBox = new Box&lt;&gt;(&quot;Hello, world!&quot;);</span><br></pre></td></tr></table></figure>
<p>泛型在实际开发中的应用非常广泛，例如集合框架中的 List、Set、Map 等容器类，以及并发框架中的 Future、Callable 等工具类都使用了泛型。</p>
<p><strong>2）类型擦除 </strong></p>
<p>在 Java 的泛型机制中，有两个重要的概念：类型擦除和通配符。</p>
<p>泛型在编译时会将泛型类型擦除，将泛型类型替换成 Object 类型。这是为了向后兼容，避免对原有的 Java 代码造成影响。</p>
<p>例如，对于下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; intList = new ArrayList&lt;&gt;();</span><br><span class="line">intList.add(123);</span><br><span class="line">int value = intList.get(0);</span><br></pre></td></tr></table></figure>
<p>在编译时，Java 编译器会将泛型类型 List<Integer> 替换成 List<Object> ，将 get 方法的返回值类型 Integer 替换成 Object，生成的字节码与下面的代码等价：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List intList = new ArrayList();</span><br><span class="line">intList.add(Integer.valueOf(123));</span><br><span class="line">int value = (Integer) intList.get(0);</span><br></pre></td></tr></table></figure>
<p>Java 泛型只在编译时起作用，运行时并不会保留泛型类型信息。</p>
<p><strong>3）通配符 </strong></p>
<p>通配符用于表示某种未知的类型，例如 List&lt;?&gt; 表示一个可以存储任何类型对象的 List，但是不能对其中的元素进行添加操作。通配符可以用来解决类型不确定的情况，例如在方法参数或返回值中使用。</p>
<p>使用通配符可以使方法更加通用，同时保证类型安全。</p>
<p>例如，定义一个泛型方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void printList(List&lt;?&gt; list) &#123;</span><br><span class="line">    for (Object obj : list) &#123;</span><br><span class="line">        System.out.print(obj + &quot; &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法可以接受任意类型的 List，例如 List<Integer> 、 List<String> 等等。</p>
<p><strong>上限通配符 </strong></p>
<p>泛型还提供了上限通配符 &lt;? extends T&gt; ，表示通配符只能接受 T 或 T 的子类。使用上限通配符可以提高程序的类型安全性。</p>
<p>例如，定义一个方法，只接受 Number 及其子类的 List：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void printNumberList(List&lt;? extends Number&gt; list) &#123;</span><br><span class="line">    for (Number num : list) &#123;</span><br><span class="line">        System.out.print(num + &quot; &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法可以接受 List<Integer> 、 List<Double> 等等。</p>
<p><strong>下限通配符 </strong></p>
<p>下限通配符（Lower Bounded Wildcards）用 super 关键字来声明，其语法形式为 &lt;? super T&gt; ，其中 T 表示类型参数。它表示的是该类型参数必须是某个指定类的超类（包括该类本身）。</p>
<p>当我们需要往一个泛型集合中添加元素时，如果使用的是上限通配符，集合中的元素类型可能会被限制，从而无法添加某些类型的元素。但是，如果我们使用下限通配符，可以将指定类型的子类型添加到集合中，保证了元素的完整性。</p>
<p>举个例子，假设有一个类 Animal，以及两个子类 Dog 和 Cat。现在我们有一个 List&lt;? super Dog&gt; 集合，它的类型参数必须是 Dog 或其父类类型。我们可以向该集合中添加 Dog 类型的元素，也可以添加它的子类。但是，不能向其中添加 Cat 类型的元素，因为 Cat 不是 Dog 的子类。</p>
<p>下面是一个使用下限通配符的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? super Dog&gt; animals = new ArrayList&lt;&gt;();</span><br><span class="line">// 可以添加 Dog 类型的元素和其子类型元素</span><br><span class="line">animals.add(new Dog());</span><br><span class="line">animals.add(new Bulldog());</span><br><span class="line">// 不能添加 Cat 类型的元素</span><br><span class="line">animals.add(new Cat()); // 编译报错</span><br></pre></td></tr></table></figure>
<p>需要注意的是，虽然使用下限通配符可以添加某些子类型元素，但是在读取元素时，我们只能确保其是 Object 类型的，无法确保其是指定类型或其父类型。因此，在读取元素时需要进行类型转换，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? super Dog&gt; animals = new ArrayList&lt;&gt;();</span><br><span class="line">animals.add(new Dog());</span><br><span class="line">// 读取元素时需要进行类型转换</span><br><span class="line">Object animal = animals.get(0);</span><br><span class="line">Dog dog = (Dog) animal;</span><br></pre></td></tr></table></figure>
<p>总的来说，Java 的泛型机制是一种非常强大的类型约束机制，可以在编译时检查类型安全性，并提高代码的复用性和可读性。但是，在使用泛型时也需要注意类型擦除和通配符等问题，以确保代码的正确性。</p>
<h2 id="4-7-Iterator和Iterable的区别"><a href="#4-7-Iterator和Iterable的区别" class="headerlink" title="4.7 Iterator和Iterable的区别"></a>4.7 Iterator和Iterable的区别</h2><p>PS: 这篇同样来换一个风格，一起来欣赏。</p>
<p>那天，小二去海康威视面试，面试官老王一上来就甩给了他一道面试题：请问 Iterator与Iterable有什么区别？</p>
<p>小二表示很开心，因为他3 天前刚好在《二哥的Java进阶之路》上读过这篇文章，所以回答得胸有成竹。</p>
<p>以下是小二当时读过的文章内容，他印象深刻。</p>
<p>在 Java 中，我们对 List 进行遍历的时候，主要有这么三种方式。</p>
<p>第一种：for 循环。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">    System.out.print(list.get(i) + &quot;，&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种：迭代器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Iterator it = list.iterator();</span><br><span class="line">while (it.hasNext()) &#123;</span><br><span class="line">    System.out.print(it.next() + &quot;，&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三种：for-each。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (String str : list) &#123;</span><br><span class="line">    System.out.print(str + &quot;，&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一种我们略过，第二种用的是 Iterator，第三种看起来是 for-each，其实背后也是 Iterator，看一下反编译后的代码（如下所示）就明白了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator var3 = list.iterator();</span><br><span class="line">while(var3.hasNext()) &#123;</span><br><span class="line">    String str = (String)var3.next();</span><br><span class="line">    System.out.print(str + &quot;，&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>for-each 只不过是个语法糖，让我们开发者在遍历 List 的时候可以写更少的代码，更简洁明了。</p>
<p>Iterator 是个接口，JDK 1.2 的时候就有了，用来改进 Enumeration 接口：</p>
<ul>
<li>允许删除元素（增加了 remove 方法）</li>
<li>优化了方法名（Enumeration 中是 hasMoreElements 和 nextElement，不简洁）</li>
</ul>
<p>来看一下 Iterator 的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public interface Iterator&lt;E&gt; &#123;</span><br><span class="line">    // 判断集合中是否存在下一个对象</span><br><span class="line">    boolean hasNext();</span><br><span class="line">    // 返回集合中的下一个对象，并将访问指针移动一位</span><br><span class="line">    E next();</span><br><span class="line">    // 删除集合中调用next()方法返回的对象</span><br><span class="line">    default void remove() &#123;</span><br><span class="line">        throw new UnsupportedOperationException(&quot;remove&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JDK 1.8 时，Iterable 接口中新增了 forEach 方法。该方法接受一个 Consumer 对象作为参数，用于对集合中的每个元素执行指定的操作。该方法的实现方式是使用 for-each 循环遍历集合中的元素，对于每个元素，调用 Consumer 对象的 accept 方法执行指定的操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">default void forEach(Consumer&lt;? super T&gt; action) &#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    for (T t : this) &#123;</span><br><span class="line">        action.accept(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法实现时首先会对 action 参数进行非空检查，如果为 null 则抛出 NullPointerException 异常。然后使用 for-each 循环遍历集合中的元素，并对每个元素调用 action.accept(t) 方法执行指定的操作。由于 Iterable 接口是 Java 集合框架中所有集合类型的基本接口，因此该方法可以被所有实现了 Iterable 接口的集合类型使用。</p>
<p>它对 Iterable 的每个元素执行给定操作，具体指定的操作需要自己写Consumer接口通过accept方法回调出来。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = new ArrayList&lt;&gt;(Arrays.asList(1, 2, 3));</span><br><span class="line">list.forEach(integer -&gt; System.out.println(integer));</span><br></pre></td></tr></table></figure>
<p>写得更浅显易懂点，就是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = new ArrayList&lt;&gt;(Arrays.asList(1, 2, 3));</span><br><span class="line">list.forEach(new Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void accept(Integer integer) &#123;</span><br><span class="line">        System.out.println(integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果我们仔细观察ArrayList 或者 LinkedList 的“户口本”就会发现，并没有直接找到 Iterator 的影子。</p>
<p><img src="\assets\note\image-20231010114038331.png" alt="image-20231010114038331"></p>
<p>反而找到了 Iterable！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Iterable&lt;T&gt; &#123;</span><br><span class="line">    Iterator&lt;T&gt; iterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，List 的关系图谱中并没有直接使用 Iterator，而是使用 Iterable 做了过渡。</p>
<p>回头再来看一下第二种遍历 List 的方式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Iterator it = list.iterator();</span><br><span class="line">while (it.hasNext()) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现刚好呼应上了。拿 ArrayList 来说吧，它重写了 Iterable 接口的 iterator 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">    return new Itr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回的对象 Itr 是个内部类，实现了 Iterator 接口，并且按照自己的方式重写了 hasNext、next、remove 等方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * ArrayList 迭代器的实现，内部类。</span><br><span class="line"> */</span><br><span class="line">private class Itr implements Iterator&lt;E&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 游标位置，即下一个元素的索引。</span><br><span class="line">     */</span><br><span class="line">    int cursor;</span><br><span class="line">    /**</span><br><span class="line">     * 上一个元素的索引。</span><br><span class="line">     */</span><br><span class="line">    int lastRet = -1;</span><br><span class="line">    /**</span><br><span class="line">     * 预期的结构性修改次数。</span><br><span class="line">     */</span><br><span class="line">    int expectedModCount = modCount;</span><br><span class="line">    /**</span><br><span class="line">     * 判断是否还有下一个元素。</span><br><span class="line">     *</span><br><span class="line">     * @return 如果还有下一个元素，则返回 true，否则返回 false。</span><br><span class="line">     */</span><br><span class="line">    public boolean hasNext() &#123;</span><br><span class="line">        return cursor != size;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 获取下一个元素。</span><br><span class="line">     *</span><br><span class="line">     * @return 列表中的下一个元素。</span><br><span class="line">     * @throws NoSuchElementException 如果没有下一个元素，则抛出 NoSuchElementException 异常。</span><br><span class="line">     */</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public E next() &#123;</span><br><span class="line">        // 获取 ArrayList 对象的内部数组</span><br><span class="line">        Object[] elementData = ArrayList.this.elementData;</span><br><span class="line">        // 记录当前迭代器的位置</span><br><span class="line">        int i = cursor;</span><br><span class="line">        if (i &gt;= size) &#123;</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">        &#125;</span><br><span class="line">        // 将游标位置加 1，为下一次迭代做准备</span><br><span class="line">        cursor = i + 1;</span><br><span class="line">        // 记录上一个元素的索引</span><br><span class="line">        return (E) elementData[lastRet = i];</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 删除最后一个返回的元素。</span><br><span class="line">     * 迭代器只能删除最后一次调用 next 方法返回的元素。</span><br><span class="line">     *</span><br><span class="line">     * @throws ConcurrentModificationException 如果在最后一次调用 next 方法之后列表结构被修改，则抛出 ConcurrentModificationException 异常。</span><br><span class="line">     * @throws IllegalStateException         如果在调用 next 方法之前没有调用 remove 方法，或者在同一次迭代中多次调用 remove 方法，则抛出 IllegalStateException 异常。</span><br><span class="line">     */</span><br><span class="line">    public void remove() &#123;</span><br><span class="line">        // 检查在最后一次调用 next 方法之后是否进行了结构性修改</span><br><span class="line">        if (expectedModCount != modCount) &#123;</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果上一次调用 next 方法之前没有调用 remove 方法，则抛出 IllegalStateException 异常</span><br><span class="line">        if (lastRet &lt; 0) &#123;</span><br><span class="line">            throw new IllegalStateException();</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 调用 ArrayList 对象的 remove(int index) 方法删除上一个元素</span><br><span class="line">            ArrayList.this.remove(lastRet);</span><br><span class="line">            // 将游标位置设置为上一个元素的位置</span><br><span class="line">            cursor = lastRet;</span><br><span class="line">            // 将上一个元素的索引设置为 -1，表示没有上一个元素</span><br><span class="line">            lastRet = -1;</span><br><span class="line">            // 更新预期的结构性修改次数</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125; catch (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 那可能有些小伙伴会问：为什么不直接将 Iterator 中的核心方法 hasNext、next 放到 Iterable 接口中呢？</p>
<p> 直接像下面这样使用不是更方便？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Iterable it = list.iterator();</span><br><span class="line">while (it.hasNext()) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 从英文单词的后缀语法上来看，（Iterable）able 表示这个 List 是支持迭代的，而 （Iterator）tor 表示这个 List 是如何迭代的。</p>
<p> 支持迭代与具体怎么迭代显然不能混在一起，否则就乱的一笔。还是各司其职的好。</p>
<p> 想一下，如果把 Iterator 和 Iterable 合并，for-each 这种遍历 List 的方式是不是就不好办了？</p>
<p> 原则上，只要一个 List 实现了 Iterable 接口，那么它就可以使用 for-each 这种方式来遍历，那具体该怎么遍历，还是要看它自己是怎么实现 Iterator 接口的。</p>
<p> Map 就没办法直接使用 for-each，因为 Map 没有实现 Iterable 接口，只有通过 map.entrySet() 、map.keySet() 、 map.values() 这种返回一个  Collection 的方式才能 使用 for-each。</p>
<p> 如果我们仔细研究 LinkedList 的源码就会发现，LinkedList 并没有直接重写 Iterable 接口的 iterator 方法，而是由它的父类 AbstractSequentialList 来完成。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">    return listIterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> LinkedList 重写了 listIterator 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public ListIterator&lt;E&gt; listIterator(int index) &#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line">    return new ListItr(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 这里我们发现了一个新的迭代器 ListIterator，它继承了 Iterator 接口，在遍历List 时可以从任意下标开始遍历，而且支持双向遍历。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface ListIterator&lt;E&gt; extends Iterator&lt;E&gt; &#123;</span><br><span class="line">    boolean hasNext();</span><br><span class="line">    E next();</span><br><span class="line">    boolean hasPrevious();</span><br><span class="line">    E previous();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 我们知道，集合（Collection）不仅有 List，还有 Set，那 Iterator 不仅支持 List，还支持 Set，但 ListIterator 就只支持 List。</p>
<p> 那可能有些小伙伴会问：为什么不直接让 List 实现 Iterator 接口，而是要用内部类来实现呢？</p>
<p> 这是因为有些 List 可能会有多种遍历方式，比如说 LinkedList，除了支持正序的遍历方式，还支持逆序的遍历方式——DescendingIterator：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line"> * ArrayList 逆向迭代器的实现，内部类。</span><br><span class="line"> */</span><br><span class="line">private class DescendingIterator implements Iterator&lt;E&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 使用 ListItr 对象进行逆向遍历。</span><br><span class="line">     */</span><br><span class="line">    private final ListItr itr = new ListItr(size());</span><br><span class="line">    /**</span><br><span class="line">     * 判断是否还有下一个元素。</span><br><span class="line">     *</span><br><span class="line">     * @return 如果还有下一个元素，则返回 true，否则返回 false。</span><br><span class="line">     */</span><br><span class="line">    public boolean hasNext() &#123;</span><br><span class="line">        return itr.hasPrevious();</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 获取下一个元素。</span><br><span class="line">     *</span><br><span class="line">     * @return 列表中的下一个元素。</span><br><span class="line">     * @throws NoSuchElementException 如果没有下一个元素，则抛出 NoSuchElementException 异常。</span><br><span class="line">     */</span><br><span class="line">    public E next() &#123;</span><br><span class="line">        return itr.previous();</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 删除最后一个返回的元素。</span><br><span class="line">     * 迭代器只能删除最后一次调用 next 方法返回的元素。</span><br><span class="line">     *</span><br><span class="line">     * @throws UnsupportedOperationException 如果列表不支持删除操作，则抛出 UnsupportedOperationException 异常。</span><br><span class="line">     * @throws IllegalStateException         如果在调用 next 方法之前没有调用 remove 方法，或者在同一次迭代中多次调用 remove 方法，则抛出 IllegalStateException 异常。</span><br><span class="line">     */</span><br><span class="line">    public void remove() &#123;</span><br><span class="line">        itr.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  可以看得到，DescendingIterator 刚好利用了 ListIterator 向前遍历的方式。可以通过以下的方式来使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Iterator it = list.descendingIterator();</span><br><span class="line">while (it.hasNext()) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  好了，关于Iterator与Iterable我们就先聊这么多，总结两点：</p>
<ul>
<li>学会深入思考，一点点抽丝剥茧，多想想为什么这样实现，很多问题没有自己想象中的那么复杂。</li>
<li>遇到疑惑不放弃，这是提升自己最好的机会，遇到某个疑难的点，解决的过程中会挖掘出很多相关的东西。</li>
</ul>
<h2 id="4-8-Java-foreach-循环陷阱"><a href="#4-8-Java-foreach-循环陷阱" class="headerlink" title="4.8 Java foreach 循环陷阱"></a>4.8 Java foreach 循环陷阱</h2><p> 这篇文章同样采用小二去面试的形式，给大家换个胃口。</p>
<p> 那天，小二去阿里面试，面试官老王一上来就甩给了他一道面试题：为什么阿里的 Java 开发手册里会强制不要在 foreach 里进行元素的删除操作？</p>
<p><img src="\assets\note\image-20231010114955252.png" alt="image-20231010114955252"></p>
<p> 小二听完这句话就乐了。为什么呢？因为一天前他刚在《Java进阶之路》上看到过这道题的答案。</p>
<p> 以下是整篇文章的内容。</p>
<p> 关于fail-fast </p>
<p> 为了镇楼，先搬一段英文来解释一下 fail-fast。</p>
<blockquote>
<p>In systems design, a fail-fast system is one which immediately reports at its interface any condition that is likely to indicate a failure. Fail-fast systems are usually designed to stop normal operation rather than attempt to continue a possibly flawed process. Such designs often check the system’s state at several points in an operation, so any failures can be detected early. The responsibility of a fail-fast module is detecting errors, then letting the next-highest level of the system handle them.</p>
</blockquote>
<p> 这段话的大致意思就是，fail-fast 是一种通用的系统设计思想，一旦检测到可能会发生错误，就立马抛出异常，程序将不再往下执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void test(Wanger wanger) &#123;   </span><br><span class="line">    if (wanger == null) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;wanger 不能为空&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    System.out.println(wanger.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 一旦检测到 wanger 为 null，就立马抛出异常，让调用者来决定这种情况下该怎么处理，下一步 wanger.toString() 就不会执行了——避免更严重的错误出现。</p>
<p> 很多时候，我们会把 fail-fast 归类为 Java 集合框架的一种错误检测机制，但其实 fail-fast 并不是 Java 集合框架特有的机制。</p>
<p> <strong>for-each 删除元素报错 </strong></p>
<p> 之所以我们把 fail-fast 放在集合框架篇里介绍，是因为问题比较容易再现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list.add(&quot;沉默王二&quot;);</span><br><span class="line">list.add(&quot;沉默王三&quot;);</span><br><span class="line">list.add(&quot;一个文章真特么有趣的程序员&quot;);</span><br><span class="line">for (String str : list) &#123;</span><br><span class="line">    if (&quot;沉默王二&quot;.equals(str)) &#123;</span><br><span class="line">        list.remove(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>
<p> 这段代码看起来没有任何问题，但运行起来就报错了。</p>
<p><img src="\assets\note\image-20231010115215172.png" alt="image-20231010115215172"></p>
<p> 根据错误的堆栈信息，我们可以定位到 ArrayList 的第 901 行代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">final void checkForComodification() &#123;</span><br><span class="line">    if (modCount != expectedModCount)</span><br><span class="line">        throw new ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 也就是说，remove 的时候触发执行了 checkForComodification 方法，该方法对 modCount 和 expectedModCount 进行了比较，发现两者不等，就抛出了 ConcurrentModificationException 异常。</p>
<p> 为什么会执行 checkForComodification 方法呢？</p>
<p> 是因为 for-each 本质上是个语法糖，底层是通过迭代器 Iterator 配合 while 循环实现的，来看一下反编译后的字节码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList();</span><br><span class="line">list.add(&quot;沉默王二&quot;);</span><br><span class="line">list.add(&quot;沉默王三&quot;);</span><br><span class="line">list.add(&quot;一个文章真特么有趣的程序员&quot;);</span><br><span class="line">Iterator var2 = list.iterator();</span><br><span class="line">while(var2.hasNext()) &#123;</span><br><span class="line">    String str = (String)var2.next();</span><br><span class="line">    if (&quot;沉默王二&quot;.equals(str)) &#123;</span><br><span class="line">        list.remove(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>
<p> 来看一下 ArrayList 的 iterator 方法吧：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">    return new Itr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 内部类 Itr 实现了 Iterator 接口，这是 Itr 的源码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> private class Itr implements Iterator&lt;E&gt; &#123;</span><br><span class="line">    int cursor;             // 下一个元素的索引</span><br><span class="line">    int lastRet = -1;       // 上一个返回元素的索引；如果没有则为 -1</span><br><span class="line">    int expectedModCount = modCount; // ArrayList 的修改次数</span><br><span class="line">    Itr() &#123; &#125;  // 构造函数</span><br><span class="line"></span><br><span class="line">    public boolean hasNext() &#123; // 判断是否还有下一个元素</span><br><span class="line">        return cursor != size;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public E next() &#123; // 返回下一个元素</span><br><span class="line">        checkForComodification(); // 检查 ArrayList 是否被修改过</span><br><span class="line">        int i = cursor; // 当前索引</span><br><span class="line">        Object[] elementData = ArrayList.this.elementData; // ArrayList 中的元素数组</span><br><span class="line">        if (i &gt;= elementData.length) // 超出数组范围</span><br><span class="line">            throw new ConcurrentModificationException(); // 抛出异常</span><br><span class="line">        cursor = i + 1; // 更新下一个元素的索引</span><br><span class="line">        return (E) elementData[lastRet = i]; // 返回下一个元素</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 也就是说 new Itr() 的时候 expectedModCount 被赋值为 modCount，而 modCount 是 ArrayList 中的一个计数器，用于记录 ArrayList 对象被修改的次数。ArrayList 的修改操作包括添加、删除、设置元素值等。每次对 ArrayList 进行修改操作时，modCount 的值会自增 1。</p>
<p> 在迭代 ArrayList 时，如果迭代过程中发现 modCount 的值与迭代器的 expectedModCount 不一致，则说明 ArrayList 已被修改过，此时会抛出 ConcurrentModificationException 异常。这种机制可以保证迭代器在遍历 ArrayList 时，不会遗漏或重复元素，同时也可以在多线程环境下检测到并发修改问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected transient int modCount = 0;</span><br></pre></td></tr></table></figure>
<p> <strong>分析代码执行的逻辑 </strong></p>
<p> 我们来继续定位之前报错的错误堆栈。这是之前的代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list.add(&quot;沉默王二&quot;);</span><br><span class="line">list.add(&quot;沉默王三&quot;);</span><br><span class="line">list.add(&quot;一个文章真特么有趣的程序员&quot;);</span><br><span class="line">for (String str : list) &#123;</span><br><span class="line">    if (&quot;沉默王二&quot;.equals(str)) &#123;</span><br><span class="line">        list.remove(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>
<p> 由于 list 此前执行了 3 次 add 方法。</p>
<ul>
<li>add 方法调用 ensureCapacityInternal 方法</li>
<li>ensureCapacityInternal 方法调用 ensureExplicitCapacity 方法</li>
<li>ensureExplicitCapacity 方法中会执行 modCount++</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 所以 modCount 的值在经过三次 add 后为 3，于是 new Itr() 后 expectedModCount 的值也为 3（回到前面去看一下 Itr 的源码）。</p>
<p> 接着来执行 for-each 的循环遍历。</p>
<p> 执行第一次循环时，发现“沉默王二”等于 str，于是执行 list.remove(str) 。</p>
<ul>
<li>remove 方法调用 fastRemove 方法</li>
<li>fastRemove 方法中会执行 modCount++</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private void fastRemove(int index) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> modCount 的值变成了 4。</p>
<p> 第二次遍历时，会执行 Itr 的 next 方法（ String str = (String) var3.next(); ），next 方法就会调用 checkForComodification 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">final void checkForComodification() &#123;</span><br><span class="line">    if (modCount != expectedModCount)</span><br><span class="line">        throw new ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 此时 expectedModCount 为 3，modCount 为 4，就只好抛出 ConcurrentModificationException 异常了。</p>
<p> 那其实在阿里巴巴的 Java 开发手册里也提到了，不要在 for-each 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterator 方式。</p>
<p><img src="\assets\note\image-20231010115730076.png" alt="image-20231010115730076"></p>
<p> 那原因其实就是我们上面分析的这些，出于 fail-fast 保护机制。</p>
<p><strong>那该如何正确地删除元素呢？ </strong></p>
<p><strong>1）remove 后 break </strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list.add(&quot;沉默王二&quot;);</span><br><span class="line">list.add(&quot;沉默王三&quot;);</span><br><span class="line">list.add(&quot;一个文章真特么有趣的程序员&quot;);</span><br><span class="line">for (String str : list) &#123;</span><br><span class="line">    if (&quot;沉默王二&quot;.equals(str)) &#123;</span><br><span class="line">        list.remove(str);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> break 后循环就不再遍历了，意味着 Iterator 的 next 方法不再执行了，也就意味着 checkForComodification 方法不再执行了，所以异常也就不会抛出了。</p>
<p> 但是呢，当 List 中有重复元素要删除的时候，break 就不合适了。</p>
<p><strong>2）for 循环 </strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list.add(&quot;沉默王二&quot;);</span><br><span class="line">list.add(&quot;沉默王三&quot;);</span><br><span class="line">list.add(&quot;一个文章真特么有趣的程序员&quot;);</span><br><span class="line">for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">    String str = list.get(i);</span><br><span class="line">    if (&quot;沉默王二&quot;.equals(str)) &#123;</span><br><span class="line">        list.remove(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> for 循环虽然可以避开 fail-fast 保护机制，也就说 remove 元素后不再抛出异常；但是呢，这段程序在原则上是有问题的。为什么呢？</p>
<p> 第一次循环的时候，i 为 0， list.size() 为 3，当执行完 remove 方法后，i 为 1， list.size() 却变成了 2，因为 list 的大小在 remove 后发生了变化，也就意味着“沉默王三”这个元素被跳过了。能明白吗？</p>
<p> remove 之前 list.get(1) 为“沉默王三”；但 remove 之后 list.get(1) 变成了“一个文章真特么有趣的程序员”，而 list.get(0) 变成了“沉默王三”。</p>
<p><strong>3）使用 Iterator </strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list.add(&quot;沉默王二&quot;);</span><br><span class="line">list.add(&quot;沉默王三&quot;);</span><br><span class="line">list.add(&quot;一个文章真特么有趣的程序员&quot;);</span><br><span class="line">Iterator&lt;String&gt; itr = list.iterator();</span><br><span class="line">while (itr.hasNext()) &#123;</span><br><span class="line">    String str = itr.next();</span><br><span class="line">    if (&quot;沉默王二&quot;.equals(str)) &#123;</span><br><span class="line">        itr.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 为什么使用 Iterator 的 remove 方法就可以避开 fail-fast 保护机制呢？看一下 remove 的源码就明白了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void remove() &#123;</span><br><span class="line">    if (lastRet &lt; 0) // 如果没有上一个返回元素的索引，则抛出异常</span><br><span class="line">        throw new IllegalStateException();</span><br><span class="line">    checkForComodification(); // 检查 ArrayList 是否被修改过</span><br><span class="line">    try &#123;</span><br><span class="line">        ArrayList.this.remove(lastRet); // 删除上一个返回元素</span><br><span class="line">        cursor = lastRet; // 更新下一个元素的索引</span><br><span class="line">        lastRet = -1; // 清空上一个返回元素的索引</span><br><span class="line">        expectedModCount = modCount; // 更新 ArrayList 的修改次数</span><br><span class="line">    &#125; catch (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">        throw new ConcurrentModificationException(); // 抛出异常</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 删除完会执行 expectedModCount = modCount ，保证了 expectedModCount 与 modCount 的同步。</p>
<p><strong>小结 </strong></p>
<p> 为什么不能在foreach里执行删除操作？</p>
<p> 因为 foreach 循环是基于迭代器实现的，而迭代器在遍历集合时会维护一个 expectedModCount 属性来记录集合被修改的次数。如果在 foreach 循环中执行删除操作会导致 expectedModCount 属性值与实际的 modCount 属性值不一致，从而导致迭代器的 hasNext() 和 next() 方法抛出 ConcurrentModificationException 异常。</p>
<p> 为了避免这种情况，应该使用迭代器的 remove() 方法来删除元素，该方法会在删除元素后更新迭代器状态，确保循环的正确性。如果需要在循环中删除元素，应该使用迭代器的 remove() 方法，而不是集合自身的 remove() 方法。</p>
<p> 就像这样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list.add(&quot;沉默王二&quot;);</span><br><span class="line">list.add(&quot;沉默王三&quot;);</span><br><span class="line">list.add(&quot;一个文章真特么有趣的程序员&quot;);</span><br><span class="line">Iterator&lt;String&gt; itr = list.iterator();</span><br><span class="line">while (itr.hasNext()) &#123;</span><br><span class="line">    String str = itr.next();</span><br><span class="line">    if (&quot;沉默王二&quot;.equals(str)) &#123;</span><br><span class="line">        itr.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 除此之外，我们还可以采用 Stream 流的filter() 方法来过滤集合中的元素，然后再通过 collect() 方法将过滤后的元素收集到一个新的集合中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(&quot;沉默&quot;, &quot;王二&quot;, &quot;陈清扬&quot;));</span><br><span class="line">list = list.stream().filter(s -&gt; !s.equals(&quot;陈清扬&quot;)).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<p> 好了，关于这个问题，就聊到这里吧，希望能帮助到你。</p>
<h2 id="4-9-HashMap详解（附源码）"><a href="#4-9-HashMap详解（附源码）" class="headerlink" title="4.9 HashMap详解（附源码）"></a>4.9 HashMap详解（附源码）</h2><p> 这篇文章将通过源码的方式，详细透彻地讲清楚 Java 的 HashMap，包括 hash 方法的原理、HashMap 的扩容机制、HashMap的加载因子为什么是 0.75 而不是 0.6、0.8，以及 HashMap 为什么是线程不安全的，基本上 HashMap 的常见面试题，都会在这一篇文章里讲明白。</p>
<p> HashMap 是 Java 中常用的数据结构之一，用于存储键值对。在 HashMap 中，每个键都映射到一个唯一的值，可以通过键来快速访问对应的值。</p>
<p> HashMap 不仅在日常开发中经常用到，在面试中也是重点考察的对象。</p>
<p> 以下是 HashMap 增删改查的简单例子：</p>
<p><strong>1）增加元素：</strong></p>
<p> 将一个键值对（元素）添加到 HashMap 中，可以使用 put() 方法。例如，将名字和年龄作为键值对添加到 HashMap 中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">map.put(&quot;沉默&quot;, 20);</span><br><span class="line">map.put(&quot;王二&quot;, 25);</span><br></pre></td></tr></table></figure>
<p><strong>2）删除元素：</strong></p>
<p> 从 HashMap 中删除一个键值对，可以使用 remove() 方法。例如，删除名字为 “沉默” 的键值对：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.remove(&quot;沉默&quot;);</span><br></pre></td></tr></table></figure>
<p> <strong>3）修改元素：</strong></p>
<p> 修改 HashMap 中的一个键值对，可以使用 put() 方法。例如，将名字为 “沉默” 的年龄修改为 30：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.put(&quot;沉默&quot;, 30);</span><br></pre></td></tr></table></figure>
<p> 为什么和添加元素的方法一样呢？这个我们后面会讲，先简单说一下，是因为 HashMap 的键是唯一的，所以再次 put 的时候会覆盖掉之前的键值对。</p>
<p><strong>4）查找元素：</strong></p>
<p> 从 HashMap 中查找一个键对应的值，可以使用 get() 方法。例如，查找名字为 “沉默” 的年龄：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int age = map.get(&quot;沉默&quot;);</span><br></pre></td></tr></table></figure>
<p> 在实际应用中，HashMap 可以用于缓存、索引等场景。例如，可以将用户 ID 作为键，用户信息作为值，将用户信息缓存到 HashMap 中，以便快速查找。又如，可以将关键字作为键，文档 ID 列表作为值，将文档索引缓存到 HashMap 中，以便快速搜索文档。</p>
<p> HashMap 的实现原理是基于哈希表的，它的底层是一个数组，数组的每个位置可能是一个链表或红黑树，也可能只是一个键值对（后面会讲）。当添加一个键值对时，HashMap 会根据键的哈希值计算出该键对应的数组下标（索引），然后将键值对插入到对应的位置。</p>
<p>当通过键查找值时，HashMap 也会根据键的哈希值计算出数组下标，并查找对应的值。</p>
<p><strong>01、hash方法的原理 </strong></p>
<p> 简单了解 HashMap 后，我们来讨论第一个问题：hash 方法的原理，对吃透 HashMap 会大有帮助。</p>
<p> 来看一下 hash 方法的源码（JDK 8 中的 HashMap）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 这段代码究竟是用来干嘛的呢？</p>
<p> 将 key 的 hashCode 值进行处理，得到最终的哈希值。</p>
<p> 怎么理解这句话呢？不要着急。</p>
<p> 我们来 new 一个 HashMap，并通过 put 方法添加一个元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">map.put(&quot;chenmo&quot;, &quot;沉默&quot;);</span><br></pre></td></tr></table></figure>
<p> 来看一下 put 方法的源码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 看到 hash 方法的身影了吧？</p>
<p><strong>hash 方法的作用 </strong></p>
<p> 前面也说了，HashMap 的底层是通过数组的形式实现的，初始大小是 16（这个后面会讲），先记住。</p>
<p> 也就是说，HashMap 在添加第一个元素的时候，需要通过键的哈希码在大小为 16 的数组中确定一个位置（索引），怎么确定呢？</p>
<p> 为了方便大家直观的感受，我这里画了一副图，16 个方格子（可以把它想象成一个一个桶），每个格子都有一个编号，对应大小为 16 的数组下标（索引）。</p>
<p><img src="\assets\note\image-20231010142503420.png" alt="image-20231010142503420"></p>
<p> 现在，我们要把 key 为 “chenmo”，value 为“沉默”的键值对放到这 16 个格子中的一个。</p>
<p> 怎么确定位置（索引）呢？</p>
<p> 我先告诉大家结论，通过这个与运算 (n - 1) &amp; hash ，其中变量 n 为数组的长度，变量 hash 就是通过 hash() 方法计算后的结果。</p>
<p> 那“chenmo”这个 key 计算后的位置（索引）是多少呢？</p>
<p> 答案是 8，也就是说 map.put(“chenmo”, “沉默”) 会把key 为 “chenmo”，value 为“沉默”的键值对放到下标为 8 的位置上（也就是索引为 8 的桶上）。</p>
<p><img src="\assets\note\image-20231010142547756.png" alt="image-20231010142547756"></p>
<p> 这样大家就会对 HashMap 存放键值对（元素）的时候有一个大致的印象。其中的一点是，hash 方法对计算键值对的位置起到了至关重要的作用。</p>
<p> 回到 hash 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 下面是对该方法的一些解释：</p>
<ul>
<li>参数 key：需要计算哈希码的键值。</li>
<li>key == null ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16) ：这是一个三目运算符，如果键值为null，则哈希码为0（依旧是说如果键为 null，则存放在第一个位置）；否则，通过调用 hashCode()方法获取键的哈希码，并将其与右移16位的哈希码进行异或运算。</li>
<li>^ 运算符：异或运算符是Java中的一种位运算符，它用于将两个数的二进制位进行比较，如果相同则为0，不同则为1。</li>
<li>h &gt;&gt;&gt; 16 ：将哈希码向右移动16位，相当于将原来的哈希码分成了两个16位的部分。</li>
<li><p>最终返回的是经过异或运算后得到的哈希码值。</p>
<p>这短短的一行代码，汇聚不少计算机巨佬们的聪明才智。</p>
<p>理论上，哈希值（哈希码）是一个 int 类型，范围从-2147483648 到 2147483648。前后加起来大概 40 亿的映射空间，只要哈希值映射得比较均匀松散，一般是不会出现哈希碰撞（哈希冲突会降低 HashMap 的效率）。</p>
<p>但问题是一个 40 亿长度的数组，内存是放不下的。HashMap 扩容之前的数组初始大小只有 16，所以这个哈希值是不能直接拿来用的，用之前要和数组的长度做取模运算（前文提到的 (n - 1) &amp; hash ），用得到的余数来访问数组下标才行。</p>
<p><strong>取模运算 </strong></p>
<p>取模运算（（“Modulo Operation”））和取余运算（（“Remainder Operation ”））是两种不同的运算方式，它们在计算机中的实现也不同。</p>
<p>在数学中，取模运算和取余运算是等价的，都是计算一个数除以另一个数的余数。例如，10 mod 3 和 10 % 3 都等于 1，因为 10 除以 3 的余数是 1。</p>
<p>在计算机中，取模运算和取余运算的差别在于，当被除数为负数时，<strong>取模运算的结果符号与被除数相同，取余运算的结果符号与除数相同</strong>。</p>
<p>例如，-10 mod 3 的结果是 -1，而 -10 % 3 的结果是 2，因为 -10 除以 3 的余数是 -1，所以 -10 取模 3 的结果应该是 -1；而 -10 对 3 取余的结果是 2，因为：-10 ÷ 3 = -3 余 -1，由于除数为正数 3，余数的符号应与被除数的符号相同，因此余数应为正数 2，而不是 -1。</p>
<p>在 Java 中，取模运算使用 % 运算符，取余运算使用 Math.floorMod() 方法。例如，计算 -10 mod 3 和 -10 % 3 的结果：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a = -10 % 3; // a = -1</span><br><span class="line">int b = Math.floorMod(-10, 3); // b = 2</span><br></pre></td></tr></table></figure>
<p> 需要注意的是，在数学中，取模运算和取余运算都有定义域的限制，即除数不能为 0。在计算机中，除数为 0 会抛出异常或返回 NaN（Not a Number）。</p>
<p> HashMap 的取模运算有两处。</p>
<p> 一处是往 HashMap 中 put 的时候（会调用私有的 putVal 方法）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123;</span><br><span class="line">    // 数组</span><br><span class="line">    HashMap.Node&lt;K,V&gt;[] tab; </span><br><span class="line">    // 元素</span><br><span class="line">    HashMap.Node&lt;K,V&gt; p; </span><br><span class="line">    // n 为数组的长度 i 为下标</span><br><span class="line">    int n, i;</span><br><span class="line">    // 数组为空的时候</span><br><span class="line">    if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">        // 第一次扩容后的数组长度</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    // 计算节点的插入位置，如果该位置为空，则新建一个节点插入</span><br><span class="line">    if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">        tab[i] = newNode(hash, key, value, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 其中 (n - 1) &amp; hash 为取模运算，为什么没用 % ，我们随后解释。</p>
<p> 一处是从 HashMap 中 get 的时候（会调用 getNode 方法）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">    // 获取当前的数组和长度，以及当前节点链表的第一个节点（根据索引直接从数组中找）</span><br><span class="line">    Node&lt;K,V&gt;[] tab; </span><br><span class="line">    Node&lt;K,V&gt; first, e; </span><br><span class="line">    int n; </span><br><span class="line">    K k;</span><br><span class="line">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">            (first = tab[(n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">        // 如果第一个节点就是要查找的节点，则直接返回</span><br><span class="line">        if (first.hash == hash &amp;&amp; ((k = first.key) == key || (key != null &amp;&amp; </span><br><span class="line">key.equals(k))))</span><br><span class="line">            return first;</span><br><span class="line">        // 如果第一个节点不是要查找的节点，则遍历节点链表查找</span><br><span class="line">        if ((e = first.next) != null) &#123;</span><br><span class="line">            do &#123;</span><br><span class="line">                if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; </span><br><span class="line">key.equals(k))))</span><br><span class="line">                    return e;</span><br><span class="line">            &#125; while ((e = e.next) != null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果节点链表中没有找到对应的节点，则返回 null</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 看到没，取模运算 (n - 1) &amp; hash 再次出现，说简单点，就是把键的哈希码经过 hash() 方法计算后，再和（数组长度-1）做了一个“与”运算。</p>
<p> <strong>取模运算%和位运算&amp; </strong></p>
<p> 可能大家在疑惑：<strong>取模运算难道不该用 %吗？为什么要用位运算 &amp;呢？</strong></p>
<p> 这是因为 &amp; 运算比 % 更加高效，并且当 b 为 2 的 n 次方时，存在下面这样一个公式。</p>
<blockquote>
<p>a % b = a &amp; (b-1)</p>
</blockquote>
<p> 用 $2^n$ 替换下 b 就是：</p>
<blockquote>
<p>a % $2^n$ = a &amp; ($2^n$-1)</p>
</blockquote>
<p> 我们来验证一下，假如 a = 14，b = 8，也就是 $2^3$，n=3。</p>
<p> 14%8（余数为 6）。</p>
<p> 14 的二进制为 1110，8 的二进制 1000，8-1 = 7，7 的二进制为 0111，1110&amp;0111=0110，也就是 0 <em> $2^0$+1 </em> $2^1$+1 <em> $2^2$+0 </em> $2^3$=0+2+4+0=6，14%8 刚好也等于 6。</p>
<p> 害，计算机就是这么讲道理，没办法</p>
<p> 这也正好解释了为什么 HashMap 的数组长度要取 2 的整次方。</p>
<p> 为什么会这样巧呢？</p>
<p> 因为（数组长度-1）正好相当于一个“低位掩码”——这个掩码的低位最好全是 1，这样 &amp; 操作才有意义，否则结果就肯定是 0，那么 &amp; 操作就没有意义了。</p>
<blockquote>
<p>a&amp;b 操作的结果是：a、b 中对应位同时为 1，则对应结果位为 1，否则为 0</p>
</blockquote>
<p> 2 的整次幂刚好是偶数，偶数-1 是奇数，奇数的二进制最后一位是 1，保证了 hash &amp;(length-1) 的最后一位可能为 0，也可能为 1（这取决于 h 的值），即 &amp; 运算后的结果可能为偶数，也可能为奇数，这样便可以保证哈希值的均匀性。</p>
<p> &amp; 操作的结果就是将哈希值的高位全部归零，只保留低位值，用来做数组下标访问。</p>
<p> 假设某哈希值为 10100101 11000100 00100101 ，用它来做取模运算，我们来看一下结果。HashMap 的初始长度为 16（内部是数组），16-1=15，二进制是 00000000 00000000 00001111 （高位用 0 来补齐）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    10100101 11000100 00100101</span><br><span class="line">&amp;   00000000 00000000 00001111</span><br><span class="line">----------------------------------</span><br><span class="line">    00000000 00000000 00000101</span><br></pre></td></tr></table></figure>
<p> 因为 15 的高位全部是 0，所以 &amp; 运算后的高位结果肯定是 0，只剩下 4 个低位 0101 ，也就是十进制的 5，也就是将哈希值为 10100101 11000100 00100101 的键放在数组的第 5 位。</p>
<p> 当然了，如果你是新手，上面这些 01 串没看懂，也没关系，记住取模运算就行了，记不住取模运算也没关系，记住<strong>取模运算是为了计算数组的下标就可以了。</strong></p>
<ul>
<li>put 的时候计算下标，把键值对放到对应的桶上。</li>
<li><p>get 的时候通过下标，把键值对从对应的桶上取出来。</p>
<p><strong>为什么取模运算之前要调用 hash 方法呢？ </strong></p>
<p>看下面这个图。</p>
</li>
</ul>
<p><img src="\assets\note\image-20231010143331295.png" alt="image-20231010143331295"></p>
<p>某哈希值为 11111111 11111111 11110000 1110 1010 ，将它右移 16 位（h &gt;&gt;&gt; 16），刚好是 00000000 00000000 11111111 11111111 ，再进行异或操作（h ^ (h &gt;&gt;&gt; 16)），结果是 11111111 11111111 00001111 00010101</p>
<blockquote>
<p>异或（ ^ ）运算是基于二进制的位运算，采用符号 XOR 或者 ^来表示，运算规则是：如果是同值取 0、异值取 1</p>
</blockquote>
<p>由于混合了原来哈希值的高位和低位，所以低位的随机性加大了（掺杂了部分高位的特征，高位的信息也得到了保留）。</p>
<p>结果再与数组长度-1（ 00000000 00000000 00000000 00001111 ）做取模运算，得到的下标就是 00000000 00000000 00000000 00000101 ，也就是 5。</p>
<p>还记得之前我们假设的某哈希值 10100101 11000100 00100101 吗？在没有调用 hash 方法之前，与 15 做取模运算后的结果也是 5，我们不妨来看看调用 hash 之后的取模运算结果是多少。</p>
<p>某哈希值 00000000 10100101 11000100 00100101 （补齐 32 位），将它右移 16 位（h &gt;&gt;&gt; 16），刚好是 00000000 00000000 00000000 10100101 ，再进行异或操作（h ^ (h &gt;&gt;&gt; 16)），结果是 00000000 10100101 00111011 10000000</p>
<p>结果再与数组长度-1（ 00000000 00000000 00000000 00001111 ）做取模运算，得到的下标就是 00000000 00000000 00000000 00000000 ，也就是 0。</p>
<p>综上所述，<strong>hash 方法是用来做哈希值优化的</strong>，把哈希值右移 16 位，也就正好是自己长度的一半，之后与原哈希值做异或运算，这样就混合了原哈希值中的高位和低位，增大了随机性。</p>
<p>说白了，<strong>hash 方法就是为了增加随机性，让数据元素更加均衡的分布，减少碰撞。</strong></p>
<p>我这里写了一段测试代码，假如 HashMap 的容量就是第一次扩容时候的 16，我在里面放了五个键值对，来看一下键的 hash 值（经过 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">map.put(&quot;chenmo&quot;, &quot;沉默&quot;);</span><br><span class="line">map.put(&quot;wanger&quot;, &quot;王二&quot;);</span><br><span class="line">map.put(&quot;chenqingyang&quot;, &quot;陈清扬&quot;);</span><br><span class="line">map.put(&quot;xiaozhuanling&quot;, &quot;小转铃&quot;);</span><br><span class="line">map.put(&quot;fangxiaowan&quot;, &quot;方小婉&quot;);</span><br><span class="line">// 遍历 HashMap</span><br><span class="line">for (String key : map.keySet()) &#123;</span><br><span class="line">    int h, n = 16;</span><br><span class="line">    int hash = (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">    int i = (n - 1) &amp; hash;</span><br><span class="line">    // 打印 key 的 hash 值 和 索引 i</span><br><span class="line">    System.out.println(key + &quot;的hash值 : &quot; + hash +&quot; 的索引 : &quot; + i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xiaozhuanling的hash值 : 14597045 的索引 : 5</span><br><span class="line">fangxiaowan的hash值 : -392727066 的索引 : 6</span><br><span class="line">chenmo的hash值 : -1361556696 的索引 : 8</span><br><span class="line">chenqingyang的hash值 : -613818743 的索引 : 9</span><br><span class="line">wanger的hash值 : -795084437 的索引 : 11</span><br></pre></td></tr></table></figure>
<p>也就是说，此时还没有发生哈希冲突，索引值都是比较均匀分布的，5、6、8、9、11，这其中的很大一部分功劳，就来自于 hash 方法。</p>
<p><strong>小结 </strong></p>
<p>hash 方法的主要作用是将 key 的 hashCode 值进行处理，得到最终的哈希值。由于 key 的 hashCode 值是不确定的，可能会出现哈希冲突，因此需要将哈希值通过一定的算法映射到 HashMap 的实际存储位置上。</p>
<p>hash 方法的原理是，先获取 key 对象的 hashCode 值，然后将其高位与低位进行异或操作，得到一个新的哈希值。为什么要进行异或操作呢？因为对于 hashCode 的高位和低位，它们的分布是比较均匀的，如果只是简单地将它们加起来或者进行位运算，容易出现哈希冲突，而异或操作可以避免这个问题。</p>
<p>然后将新的哈希值取模（mod），得到一个实际的存储位置。这个取模操作的目的是将哈希值映射到桶（Bucket）的索引上，桶是 HashMap 中的一个数组，每个桶中会存储着一个链表（或者红黑树），装载哈希值相同的键值对（没有相同哈希值的话就只存储一个键值对）。</p>
<p>总的来说，HashMap 的 hash 方法就是将 key 对象的 hashCode 值进行处理，得到最终的哈希值，并通过一定的算法映射到实际的存储位置上。这个过程决定了 HashMap 内部键值对的查找效率。</p>
<p><strong>02、HashMap的扩容机制 </strong></p>
<p>好，理解了 hash 方法后我们来看第二个问题，HashMap 的扩容机制。</p>
<p>大家都知道，数组一旦初始化后大小就无法改变了，所以就有了 ArrayList这种“动态数组”，可以自动扩容。</p>
<p>HashMap 的底层用的也是数组。向 HashMap 里不停地添加元素，当数组无法装载更多元素时，就需要对数组进行扩容，以便装入更多的元素；除此之外，容量的提升也会相应地提高查询效率，因为“桶（坑）”更多了嘛，原来需要通过链表存储的（查询的时候需要遍历），扩容后可能就有自己专属的“坑位”了（直接就能查出来）。</p>
<p>来看这个例子，容量我们定位 16：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">map.put(&quot;chenmo&quot;, &quot;沉默&quot;);</span><br><span class="line">map.put(&quot;wanger&quot;, &quot;王二&quot;);</span><br><span class="line">map.put(&quot;chenqingyang&quot;, &quot;陈清扬&quot;);</span><br><span class="line">map.put(&quot;xiaozhuanling&quot;, &quot;小转铃&quot;);</span><br><span class="line">map.put(&quot;fangxiaowan&quot;, &quot;方小婉&quot;);</span><br><span class="line">map.put(&quot;yexin&quot;, &quot;叶辛&quot;);</span><br><span class="line">map.put(&quot;liuting&quot;,&quot;刘婷&quot;);</span><br><span class="line">map.put(&quot;yaoxiaojuan&quot;,&quot;姚小娟&quot;);</span><br><span class="line">// 遍历 HashMap</span><br><span class="line">for (String key : map.keySet()) &#123;</span><br><span class="line">    int h, n = 16;</span><br><span class="line">    int hash = (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">    int i = (n - 1) &amp; hash;</span><br><span class="line">    // 打印 key 的 hash 值 和 索引 i</span><br><span class="line">    System.out.println(key + &quot;的hash值 : &quot; + hash +&quot; 的索引 : &quot; + i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">liuting的hash值 : 183821170 的索引 : 2</span><br><span class="line">xiaozhuanling的hash值 : 14597045 的索引 : 5</span><br><span class="line">fangxiaowan的hash值 : -392727066 的索引 : 6</span><br><span class="line">yaoxiaojuan的hash值 : 1231568918 的索引 : 6</span><br><span class="line">chenmo的hash值 : -1361556696 的索引 : 8</span><br><span class="line">chenqingyang的hash值 : -613818743 的索引 : 9</span><br><span class="line">yexin的hash值 : 114873289 的索引 : 9</span><br><span class="line">wanger的hash值 : -795084437 的索引 : 11</span><br></pre></td></tr></table></figure>
<p>看到没？</p>
<ul>
<li>fangxiaowan（方小婉）和 yaoxiaojuan（姚小娟）的索引都是 6；</li>
<li>chenqingyang（陈清扬）和yexin（叶辛）的索引都是 9</li>
</ul>
<p>这就意味着，要采用拉链法（后面会讲）将他们放在同一个索引的链表上。查询的时候，就不能直接通过索引的方式直接拿到（时间复杂度为 O(1)），而要通过遍历的方式（时间复杂度为 O(n)）。</p>
<p>那假如把数组的长度由 16 扩容为 32 呢？</p>
<p>将之前示例中的 n 由 16 改为 32 即可得到如下的答案：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">liuting的hash值 : 183821170 的索引 : 18</span><br><span class="line">xiaozhuanling的hash值 : 14597045 的索引 : 21</span><br><span class="line">fangxiaowan的hash值 : -392727066 的索引 : 6</span><br><span class="line">yaoxiaojuan的hash值 : 1231568918 的索引 : 22</span><br><span class="line">chenmo的hash值 : -1361556696 的索引 : 8</span><br><span class="line">chenqingyang的hash值 : -613818743 的索引 : 9</span><br><span class="line">yexin的hash值 : 114873289 的索引 : 9</span><br><span class="line">wanger的hash值 : -795084437 的索引 : 11</span><br></pre></td></tr></table></figure>
<p>可以看到：</p>
<ul>
<li>虽然chenqingyang（陈清扬）和yexin（叶辛）的索引仍然是 9。</li>
<li>但 fangxiaowan（方小婉）的索引为 6，yaoxiaojuan（姚小娟）的索引由 6 变为 22，各自都有坑了。</li>
</ul>
<p>当然了，数组是无法自动扩容的，所以如果要扩容的话，就需要新建一个大的数组，然后把之前小的数组的元素复制过去，并且要重新计算哈希值和重新分配桶（重新散列），这个过程也是挺耗时的。</p>
<p><strong>resize方法 </strong></p>
<p>HashMap 的扩容是通过 resize 方法来实现的，JDK 8 中融入了红黑树（链表长度超过 8 的时候，会将链表转化为红黑树来提高查询效率），对于新手来说，可能比较难理解。</p>
<p>为了减轻大家的学习压力，就还使用 JDK 7 的源码，搞清楚了 JDK 7 的，再看 JDK 8 的就会轻松很多。</p>
<p>来看 Java7 的 resize 方法源码，我加了注释：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// newCapacity为新的容量</span><br><span class="line">void resize(int newCapacity) &#123;</span><br><span class="line">    // 小数组，临时过度下</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    // 扩容前的容量</span><br><span class="line">    int oldCapacity = oldTable.length;</span><br><span class="line">    // MAXIMUM_CAPACITY 为最大容量，2 的 30 次方 = 1&lt;&lt;30</span><br><span class="line">    if (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        // 容量调整为 Integer 的最大值 0x7fffffff（十六进制）=2 的 31 次方-1</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 初始化一个新的数组（大容量）</span><br><span class="line">    Entry[] newTable = new Entry[newCapacity];</span><br><span class="line">    // 把小数组的元素转移到大数组中</span><br><span class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">    // 引用新的大数组</span><br><span class="line">    table = newTable;</span><br><span class="line">    // 重新计算阈值</span><br><span class="line">    threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法接收一个新的容量 newCapacity，然后将 HashMap 的容量扩大到 newCapacity。</p>
<p>首先，方法获取当前 HashMap 的旧数组 oldTable 和旧容量 oldCapacity。如果旧容量已经达到 HashMap 支持的最大容量 MAXIMUM_CAPACITY（ 2 的 30 次方），就将新的阈值 threshold 调整为 Integer.MAX_VALUE（2 的 31 次方 - 1），这是因为 HashMap 的容量不能超过 MAXIMUM_CAPACITY。</p>
<p>因为 2,147,483,647（Integer.MAX_VALUE） - 1,073,741,824（MAXIMUM_CAPACITY） = 1,073,741,823，刚好相差一倍（HashMap 每次扩容都是之前的一倍）。</p>
<p>接着，方法创建一个新的数组 newTable，并将旧数组 oldTable 中的元素转移到新数组 newTable 中。转移过程是通过调用 transfer 方法来实现的。该方法遍历旧数组中的每个桶，并将每个桶中的键值对重新计算哈希值后，将其插入到新数组对应的桶中。</p>
<p>转移完成后，方法将 HashMap 内部的数组引用 table 指向新数组 newTable，并重新计算阈值 threshold。新的阈值是新容量 newCapacity 乘以负载因子 loadFactor 的结果，但如果计算结果超过了 HashMap 支持的最大容量 MAXIMUM_CAPACITY，则将阈值设置为 MAXIMUM_CAPACITY + 1，这是因为 HashMap 的元素数量不能超过 MAXIMUM_CAPACITY。</p>
<p><strong>新容量newCapacity </strong></p>
<p>那 newCapacity 是如何计算的呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int newCapacity = oldCapacity * 2;</span><br><span class="line">if (newCapacity &lt; 0 || newCapacity &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">    newCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">&#125; else if (newCapacity &lt; DEFAULT_INITIAL_CAPACITY) &#123;</span><br><span class="line">    newCapacity = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新容量 newCapacity 被初始化为原容量 oldCapacity 的两倍。然后，如果 newCapacity 超过了 HashMap 的容量限制 MAXIMUM_CAPACITY（2^30），就将 newCapacity 设置为 MAXIMUM_CAPACITY。如果 newCapacity 小于默认初始容量 DEFAULT_INITIAL_CAPACITY（16），就将 newCapacity 设置为 DEFAULT_INITIAL_CAPACITY。这样可以避免新容量太小或太大导致哈希冲突过多或者浪费空间。</p>
<p>Java 8 的时候，newCapacity 的计算方式发生了一些细微的变化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int newCapacity = oldCapacity &lt;&lt; 1;</span><br><span class="line">if (newCapacity &gt;= DEFAULT_INITIAL_CAPACITY &amp;&amp; oldCapacity &gt;= </span><br><span class="line">DEFAULT_INITIAL_CAPACITY) &#123;</span><br><span class="line">    if (newCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        newCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    if (newCapacity &lt; DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">        newCapacity = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意， oldCapacity * 2 变成了 oldCapacity &lt;&lt; 1 ，出现了左移（ &lt;&lt; ），这里简单介绍一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=39</span><br><span class="line">b = a &lt;&lt; 2</span><br></pre></td></tr></table></figure>
<p>十进制 39 用 8 位的二进制来表示，就是 00100111，左移两位后是 10011100（低位用 0 补上），再转成十进制数就是 156。</p>
<p>移位运算通常可以用来代替乘法运算和除法运算。例如，将 0010011（39）左移两位就是 10011100（156），刚好变成了原来的 4 倍。</p>
<p>实际上呢，二进制数左移后会变成原来的 2 倍、4 倍、8 倍，记住这个就好。</p>
<p><strong>transfer方法 </strong></p>
<p>接下来，来说 transfer 方法，该方法用来转移，将旧的小数组元素拷贝到新的大数组中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void transfer(Entry[] newTable, boolean rehash) &#123;</span><br><span class="line">    // 新的容量</span><br><span class="line">    int newCapacity = newTable.length;</span><br><span class="line">    // 遍历小数组</span><br><span class="line">    for (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        while(null != e) &#123;</span><br><span class="line">            // 拉链法，相同 key 上的不同值</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            // 是否需要重新计算 hash</span><br><span class="line">            if (rehash) &#123;</span><br><span class="line">                e.hash = null == e.key ? 0 : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            // 根据大数组的容量，和键的 hash 计算元素在数组中的下标</span><br><span class="line">            int i = indexFor(e.hash, newCapacity);</span><br><span class="line">            // 同一位置上的新元素被放在链表的头部</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            // 放在新的数组上</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            // 链表上的下一个元素</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法接受一个新的 Entry 数组 newTable 和一个布尔值 rehash 作为参数，其中 newTable 表示新的哈希表，rehash 表示是否需要重新计算键的哈希值。</p>
<p>在方法中，首先获取新哈希表（数组）的长度 newCapacity，然后遍历旧哈希表中的每个 Entry。对于每个 Entry，使用拉链法将相同 key 值的不同 value 值存储在同一个链表中。如果 rehash 为 true，则需要重新计算键的哈希值，并将新的哈希值存储在 Entry 的 hash 属性中。</p>
<p>接着，根据新哈希表的长度和键的哈希值，计算 Entry 在新数组中的位置 i，然后将该 Entry 添加到新数组的 i 位置上。由于新元素需要被放在链表的头部，因此将新元素的下一个元素设置为当前数组位置上的元素。</p>
<p>最后，遍历完旧哈希表中的所有元素后，转移工作完成，新的哈希表 newTable 已经包含了旧哈希表中的所有元素。</p>
<p><strong>拉链法 </strong></p>
<p>注意， e.next = newTable[i] ，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素最终会被放到链表的尾部，这就会导致<strong>在旧数组中同一个链表上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。</strong></p>
<p>就这点上，Java 8 做了很大的优化（下面会讲）。</p>
<p>现在假设 hash 算法就是简单的用键的哈希值（一个 int 值）和数组大小取模（也就是 hashCode % table.length ）。</p>
<p>继续假设：</p>
<ul>
<li>数组 table 的长度为 2</li>
<li>键的哈希值为 3、7、5</li>
</ul>
<p>取模运算后，哈希冲突都到 table[1] 上了，因为余数为 1。那么扩容前的样子如下图所示。</p>
<p><img src="\assets\note\image-20231010144428407.png" alt="image-20231010144428407"></p>
<p>数组的容量为 2， key 3、7、5 都在 table[1] 的链表上。</p>
<p>假设负载因子（后面会细讲） loadFactor 为 1，也就是当元素的个数大于 table 的长度时进行扩容。</p>
<p>扩容后的数组容量为 4。</p>
<ul>
<li>key 3 取模（3%4）后是 3，放在 table[3] 上。</li>
<li>key 7 取模（7%4）后是 3，放在 table[3] 上的链表头部。</li>
<li>key 5 取模（5%4）后是 1，放在 table[1] 上。</li>
</ul>
<p><img src="\assets\note\image-20231010144506517.png" alt="image-20231010144506517"></p>
<p>按照我们的预期，扩容后的 7 仍然应该在 3 这条链表的后面，但实际上呢？ 7 跑到 3 这条链表的头部了。</p>
<p>针对 JDK 7 中的这个情况，JDK 8 做了哪些优化呢？</p>
<p>看下面这张图。</p>
<p><img src="\assets\note\image-20231010144539682.png" alt="image-20231010144539682"></p>
<p>n 为 table 的长度，默认值为 16。</p>
<ul>
<li>n-1 也就是二进制的 0000 1111（1X$2^0$+1X$2^1$+1X$2^2$+1X$2^3$=1+2+4+8=15）；</li>
<li>key1 哈希值的最后 8 位为 0000 0101</li>
<li>key2 哈希值的最后 8 位为 0001 0101（和 key1 不同）</li>
<li>做与运算后发生了哈希冲突，索引都在（0000 0101）上。</li>
</ul>
<p>扩容后为 32。</p>
<ul>
<li>n-1 也就是二进制的 0001 1111（1X$2^0$+1X$2^1$+1X$2^2$+1X$2^3$+1X$2^4$=1+2+4+8+16=31），扩容前是 0000 1111。</li>
<li>key1 哈希值的低位为 0000 0101</li>
<li>key2 哈希值的低位为 0001 0101（和 key1 不同）</li>
<li>key1 做与运算后，索引为 0000 0101。</li>
<li>key2 做与运算后，索引为 0001 0101。</li>
</ul>
<p>新的索引就会发生这样的变化：</p>
<ul>
<li>原来的索引是 5（0 0101）</li>
<li>原来的容量是 16</li>
<li>扩容后的容量是 32</li>
<li>扩容后的索引是 21（1 0101），也就是 5+16，也就是原来的索引+原来的容量</li>
</ul>
<p><img src="\assets\note\image-20231010144658763.png" alt="image-20231010144658763"></p>
<p>也就是说，JDK 8 不需要像 JDK 7 那样重新计算 hash，只需要看原来的hash值新增的那个bit是1还是0就好了，是0的话就表示索引没变，是1的话，索引就变成了“原索引+原来的容量”。</p>
<p><img src="\assets\note\image-20231010144735415.png" alt="image-20231010144735415"></p>
<p>JDK 8 的这个设计非常巧妙，既省去了重新计算hash的时间，同时，由于新增的1 bit是0还是1是随机的，因此扩容的过程，可以均匀地把之前的节点分散到新的位置上。</p>
<p>woc，只能说 HashMap 的作者 Doug Lea、Josh Bloch、Arthur van Hoff、Neal Gafter 真的强——的一笔。</p>
<p><strong>Java 8 扩容 </strong></p>
<p>JDK 8 的扩容源代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table; // 获取原来的数组 table</span><br><span class="line">    int oldCap = (oldTab == null) ? 0 : oldTab.length; // 获取数组长度 oldCap</span><br><span class="line">    int oldThr = threshold; // 获取阈值 oldThr</span><br><span class="line">    int newCap, newThr = 0;</span><br><span class="line">    if (oldCap &gt; 0) &#123; // 如果原来的数组 table 不为空</span><br><span class="line">        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; // 超过最大值就不再扩充了，就只好随你碰撞去吧</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            return oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; // 没超过最大值，就扩充为原来的2倍</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line">    &#125;</span><br><span class="line">    else if (oldThr &gt; 0) // initial capacity was placed in threshold</span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    else &#123; // zero initial threshold signifies using defaults</span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    // 计算新的 resize 上限</span><br><span class="line">    if (newThr == 0) &#123;</span><br><span class="line">        float ft = (float)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (int)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr; // 将新阈值赋值给成员变量 threshold</span><br><span class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; // 创建新数组 newTab</span><br><span class="line">    table = newTab; // 将新数组 newTab 赋值给成员变量 table</span><br><span class="line">    if (oldTab != null) &#123; // 如果旧数组 oldTab 不为空</span><br><span class="line">        for (int j = 0; j &lt; oldCap; ++j) &#123; // 遍历旧数组的每个元素</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            if ((e = oldTab[j]) != null) &#123; // 如果该元素不为空</span><br><span class="line">                oldTab[j] = null; // 将旧数组中该位置的元素置为 null，以便垃圾回收</span><br><span class="line">                if (e.next == null) // 如果该元素没有冲突</span><br><span class="line">                    newTab[e.hash &amp; (newCap - 1)] = e; // 直接将该元素放入新数组</span><br><span class="line">                else if (e instanceof TreeNode) // 如果该元素是树节点</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); // 将该树节点分裂成两个链表</span><br><span class="line">                else &#123; // 如果该元素是链表</span><br><span class="line">                    Node&lt;K,V&gt; loHead = null, loTail = null; // 低位链表的头结点和尾结点</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = null, hiTail = null; // 高位链表的头结点和尾结点</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    do &#123; // 遍历该链表</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        if ((e.hash &amp; oldCap) == 0) &#123; // 如果该元素在低位链表中</span><br><span class="line">                            if (loTail == null) // 如果低位链表还没有结点</span><br><span class="line">                                loHead = e; // 将该元素作为低位链表的头结点</span><br><span class="line">                            else</span><br><span class="line">                                loTail.next = e; // 如果低位链表已经有结点，将该元素加入低位链表的尾部</span><br><span class="line">                            loTail = e; // 更新低位链表的尾结点</span><br><span class="line">                        &#125;</span><br><span class="line">                        else &#123; // 如果该元素在高位链表中</span><br><span class="line">                            if (hiTail == null) // 如果高位链表还没有结点</span><br><span class="line">                                hiHead = e; // 将该元素作为高位链表的头结点</span><br><span class="line">                            else</span><br><span class="line">                                hiTail.next = e; // 如果高位链表已经有结点，将该元素加入高位链表的尾部</span><br><span class="line">                            hiTail = e; // 更新高位链表的尾结点</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; while ((e = next) != null); //</span><br><span class="line">                    if (loTail != null) &#123; // 如果低位链表不为空</span><br><span class="line">                        loTail.next = null; // 将低位链表的尾结点指向 null，以便垃圾回收</span><br><span class="line">                        newTab[j] = loHead; // 将低位链表作为新数组对应位置的元素</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (hiTail != null) &#123; // 如果高位链表不为空</span><br><span class="line">                        hiTail.next = null; // 将高位链表的尾结点指向 null，以便垃圾回收</span><br><span class="line">                        newTab[j + oldCap] = hiHead; // 将高位链表作为新数组对应位置的元素</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newTab; // 返回新数组</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1、获取原来的数组 table、数组长度 oldCap 和阈值 oldThr。</p>
<p>2、如果原来的数组 table 不为空，则根据扩容规则计算新数组长度 newCap 和新阈值 newThr，然后将原数组中的元素复制到新数组中。</p>
<p>3、如果原来的数组 table 为空但阈值 oldThr 不为零，则说明是通过带参数构造函数创建的 HashMap，此时将阈值作为新数组长度 newCap。</p>
<p>4、如果原来的数组 table 和阈值 oldThr 都为零，则说明是通过无参数构造函数创建的 HashMap，此时将默认初始容量 DEFAULT_INITIAL_CAPACITY（16）和默认负载因子 DEFAULT_LOAD_FACTOR（0.75）计算出新数组长度 newCap 和新阈值 newThr。</p>
<p>5、计算新阈值 threshold，并将其赋值给成员变量 threshold。</p>
<p>6、创建新数组 newTab，并将其赋值给成员变量 table。</p>
<p>7、如果旧数组 oldTab 不为空，则遍历旧数组的每个元素，将其复制到新数组中。</p>
<p>8、返回新数组 newTab。</p>
<p><strong>小结 </strong></p>
<p>HashMap 的内部实现是通过一个数组和链表或红黑树的组合来实现的。当我们往 HashMap 中不断添加元素时，HashMap 会自动进行扩容操作（条件是元素数量达到负载因子（load factor）乘以数组长度时），以保证其存储的元素数量不会超出其容量限制。下面是 HashMap 的扩容机制：</p>
<p>1、在进行扩容操作时，HashMap 会先将数组的长度扩大一倍，然后将原来的元素重新散列（这个词还是挺贴切的）到新的数组中。由于元素的散列位置是通过 key 的 hashcode 和数组长度取模得到的，因此在数组长度扩大后，元素的散列位置也会发生一些改变。</p>
<p>2、在重新散列元素时，如果一个元素的散列位置发生了改变，那么它需要被移动到新的位置。如果新的位置上已经有元素了，那么这个元素就会被添加到链表的末尾，如果链表的长度超过了阈值（8个），那么它将会被转换成红黑树。</p>
<p>总之，HashMap 的扩容机制是通过增加数组长度和重新散列元素来实现的，它可以保证 HashMap 的存储容量足够大，同时也可以保证 HashMap 的存储效率和检索效率。但是，由于扩容操作需要耗费一定的时间和空间，因此我们需要在使用 HashMap 时，合理地设置初始容量和负载因子，以避免过多的扩容操作。</p>
<p><strong>03、加载因子为什么是0.75 </strong></p>
<p>上一个问题提到了加载因子（或者叫负载因子），那么这个问题我们来讨论为什么加载因子是 0.75 而不是 0.6、0.8。</p>
<p>我们知道，HashMap 是用数组+链表/红黑树实现的，我们要想往 HashMap 中添加数据（元素/键值对）或者取数据，就需要确定数据在数组中的下标（索引）。</p>
<p>先把数据的键进行一次 hash：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再做一次取模运算确定下标：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = (n - 1) &amp; hash</span><br></pre></td></tr></table></figure>
<p>那这样的过程容易产生两个问题：</p>
<ul>
<li>数组的容量过小，经过哈希计算后的下标，容易出现冲突；</li>
<li>数组的容量过大，导致空间利用率不高。</li>
</ul>
<p>加载因子是用来表示 HashMap 中数据的填满程度：</p>
<blockquote>
<p>加载因子 = 填入哈希表中的数据个数 / 哈希表的长度</p>
</blockquote>
<p>这就意味着：</p>
<ul>
<li>加载因子越小，填满的数据就越少，哈希冲突的几率就减少了，但浪费了空间，而且还会提高扩容的触发几率；</li>
<li>加载因子越大，填满的数据就越多，空间利用率就高，但哈希冲突的几率就变大了。</li>
</ul>
<p>好难！！！！</p>
<p>这就必须在“哈希冲突”与“空间利用率”两者之间有所取舍，尽量保持平衡，谁也不碍着谁。</p>
<p>我们知道，HashMap 是通过拉链法来解决哈希冲突的。</p>
<p>为了减少哈希冲突发生的概率，当 HashMap 的数组长度达到一个临界值的时候，就会触发扩容，扩容后会将之前小数组中的元素转移到大数组中，这是一个相当耗时的操作。</p>
<p>这个临界值由什么来确定呢？</p>
<blockquote>
<p>临界值 = 初始容量 * 加载因子</p>
</blockquote>
<p>一开始，HashMap 的容量是 16：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16</span><br></pre></td></tr></table></figure>
<p>加载因子是 0.75：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static final float DEFAULT_LOAD_FACTOR = 0.75f;</span><br></pre></td></tr></table></figure>
<p>也就是说，当 16*0.75=12 时，会触发扩容机制。</p>
<p><strong>为什么加载因子会选择 0.75 呢？为什么不是0.8、0.6呢？</strong></p>
<p>这跟统计学里的一个很重要的原理——泊松分布有关。</p>
<p>是时候上维基百科了：</p>
<blockquote>
<p>泊松分布，是一种统计与概率学里常见到的离散概率分布，由法国数学家西莫恩·德尼·泊松在1838年时提出。它会对随机事件的发生次数进行建模，适用于涉及计算在给定的时间段、距离、面积等范围内发生随机事件的次数的应用情形。</p>
</blockquote>
<p>阮一峰老师曾在一篇博文中详细的介绍了泊松分布和指数分布，大家可以去看一下。</p>
<blockquote>
<p>链接：<a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2015/06/poisson-distribution.html">https://www.ruanyifeng.com/blog/2015/06/poisson-distribution.html</a></p>
</blockquote>
<p>具体是用这么一个公式来表示的。</p>
<script type="math/tex; mode=display">
P(N(t)=n)=\frac{(\lambda t)^ne^{-\lambda t}}{n!}</script><p>等号的左边，P 表示概率，N表示某种函数关系，t 表示时间，n 表示数量。</p>
<p>在 HashMap 的 doc 文档里，曾有这么一段描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Because TreeNodes are about twice the size of regular nodes, we</span><br><span class="line">use them only when bins contain enough nodes to warrant use</span><br><span class="line">(see TREEIFY_THRESHOLD). And when they become too small (due to</span><br><span class="line">removal or resizing) they are converted back to plain bins.  In</span><br><span class="line">usages with well-distributed user hashCodes, tree bins are</span><br><span class="line">rarely used.  Ideally, under random hashCodes, the frequency of</span><br><span class="line">nodes in bins follows a Poisson distribution</span><br><span class="line">(http://en.wikipedia.org/wiki/Poisson_distribution) with a</span><br><span class="line">parameter of about 0.5 on average for the default resizing</span><br><span class="line">threshold of 0.75, although with a large variance because of</span><br><span class="line">resizing granularity. Ignoring variance, the expected</span><br><span class="line">occurrences of list size k are (exp(-0.5) * pow(0.5, k) /</span><br><span class="line">factorial(k)). The first values are:</span><br><span class="line">0:    0.60653066</span><br><span class="line">1:    0.30326533</span><br><span class="line">2:    0.07581633</span><br><span class="line">3:    0.01263606</span><br><span class="line">4:    0.00157952</span><br><span class="line">5:    0.00015795</span><br><span class="line">6:    0.00001316</span><br><span class="line">7:    0.00000094</span><br><span class="line">8:    0.00000006</span><br><span class="line">more: less than 1 in ten million</span><br></pre></td></tr></table></figure>
<p>为了便于大家的理解，这里来重温一下 HashMap 的拉链法和红黑树结构。</p>
<p>Java 8 之前，HashMap 使用链表来解决冲突，即当两个或者多个键映射到同一个桶时，它们被放在同一个桶的链表上。当链表上的节点（Node）过多时，链表会变得很长，查找的效率（LinkedList 的查找效率为 O（n））就会受到影响。</p>
<p>Java 8 中，当链表的节点数超过一个阈值（8）时，链表将转为红黑树（节点为TreeNode），红黑树（在讲TreeMap时会细说）是一种高效的平衡树结构，能够在 O(log n) 的时间内完成插入、删除和查找等操作。这种结构在节点数很多时，可以提高 HashMap 的性能和可伸缩性。好，有了这个背景，我们来把上面的 doc 文档翻译为中文：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">因为TreeNode（红黑树的节点）的大小大约是常规节点（链表的节点 Node）的两倍，所以只有当桶内包含足够多</span><br><span class="line">的节点时才使用红黑树（参见TREEIFY_THRESHOLD「阈值，值为8」，节点数量较多时，红黑树可以提高查询效</span><br><span class="line">率）。</span><br><span class="line">由于删除元素或者调整数组大小（扩容）时（再次散列），红黑树可能会被转换为链表（节点数量小于 8 时），节</span><br><span class="line">点数量较少时，链表的效率比红黑树更高，因为红黑树需要更多的内存空间来存储节点。</span><br><span class="line">在具有良好分布的hashCode使用中，很少使用红黑树。</span><br><span class="line">理想情况下，在随机hashCode下，节点在桶中的频率遵循泊松分布（https://zh.wikipedia.org/wiki/卜瓦</span><br><span class="line">松分布），平均缩放阈值为0.75，忽略方差，列表大小k的预期出现次数为（exp（-0.5）* pow（0.5，k）/ </span><br><span class="line">factorial（k））。</span><br><span class="line">前几个值是：</span><br><span class="line">0: 0.60653066</span><br><span class="line">1: 0.30326533</span><br><span class="line">2: 0.07581633</span><br><span class="line">3: 0.01263606</span><br><span class="line">4: 0.00157952</span><br><span class="line">5: 0.00015795</span><br><span class="line">6: 0.00001316</span><br><span class="line">7: 0.00000094</span><br><span class="line">8: 0.00000006</span><br><span class="line">更多：小于一千万分之一</span><br></pre></td></tr></table></figure>
<p>虽然这段话的本意更多的是表示 jdk 8中为什么拉链长度超过8的时候进行了红黑树转换，但提到了 0.75 这个加载因子，但没提到底为什么。</p>
<p>为了搞清楚到底为什么，我看到了这篇文章：</p>
<blockquote>
<p>参考链接：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000023308658">https://segmentfault.com/a/1190000023308658</a></p>
</blockquote>
<p>里面提到了一个概念：二项分布（Binomial Distribution）。</p>
<p>在做一件事情的时候，其结果的概率只有2种情况，和抛硬币一样，不是正面就是反面。</p>
<p>假如，我们做了 N 次实验，那么在每次试验中只有两种可能的结果，并且每次实验是独立的，不同实验之间互不影响，每次实验成功的概率都是一样的。</p>
<p>以此理论为基础：我们往哈希表中扔数据，如果发生哈希冲突就为失败，否则为成功。</p>
<p>我们可以设想，实验的hash值是随机的，并且经过hash运算的键都会映射到hash表的地址空间上，那么这个结果也是随机的。所以，每次put的时候就相当于我们在扔一个16面（HashMap 第一次扩容后的数组默认长度为16）的骰子，扔骰子实验那肯定是相互独立的。碰撞发生即扔了n次有出现重复数字。</p>
<p>然后，我们的目的是啥呢？</p>
<p>就是掷了k次骰子，没有一次是相同的概率，需要尽可能的大些，一般意义上我们肯定要大于0.5（这个数是个理想数）。</p>
<p>于是，n次事件里面，碰撞为0的概率，由上面公式得：</p>
<script type="math/tex; mode=display">
binom(n,0)=C_{n}^{0} \times (\frac{1}{s} )^0 \times (1-\frac{1}{s})^{n-0}=(1-\frac{1}{s})^n</script><p>这个概率值需要大于0.5，我们认为这样的hashmap可以提供很低的碰撞率。所以：</p>
<p>这时候，我们对于该公式其实最想求的时候长度s的时候，n为多少次就应该进行扩容了？而负载因子则是$n/s$的值。所以推导如下：</p>
<script type="math/tex; mode=display">
\begin{align*}
&nln(1-\frac{1}{s} )\ge -ln2...两边取对数\\
&n\le \frac{-ln2}{ln(1-\frac{1}{s} )} \to n\le \frac{ln2}{ln\frac{s}{s-1} } ...提取n\\
&\frac{n}{s} \le \frac{ln2}{sln\frac{s}{s-1} } ...两边除以s\\
\end{align*}</script><p>所以可以得到</p>
<script type="math/tex; mode=display">
loadFactor=\lim_{s \to \infty} \frac{ln2}{sln\frac{s}{s-1} }</script><p>其中</p>
<script type="math/tex; mode=display">
\lim_{s \to \infty} \frac{ln2}{sln\frac{s}{s-1} }</script><p>这就是一个求 ∞⋅0函数极限问题，这里我们先令$s = m+1（m \to \infty）$则转化为</p>
<script type="math/tex; mode=display">
\lim_{m \to \infty} (m+1)ln(1+\frac{1}{m} )</script><p>我们再令 $x = \frac{1}{m} （x \to 0）$ 则有，</p>
<script type="math/tex; mode=display">
\begin{align*}
&\lim_{s \to \infty} sln\frac{s}{s-1} =\lim_{x \to 0} (\frac{1}{x} +1)ln(1+x)\\
&=\lim_{x \to 0} (\frac{1}{x} +1)x...无穷小等价替换有ln(1+x)\sim x\\
&=\lim_{x \to 0} (1+x)\\
&\sim1\\
\end{align*}</script><p>所以</p>
<script type="math/tex; mode=display">
\begin{align*}
&loadFactor=\lim_{s \to \infty} \frac{ln2}{sln\frac{s}{s-1} } \\
&\sim ln2\\
&\sim 0.693\\
\end{align*}</script><p>考虑到 HashMap的容量有一个要求：它必须是2的n 次幂。当加载因子选择了0.75就可以保证它与容量的乘积为整数。</p>
<p>除了 0.75，0.5~1 之间还有 0.625（5/8）、0.875（7/8）可选，从中位数的角度，挑 0.75 比较完美。另外，维基百科上说，拉链法（解决哈希冲突的一种）的加载因子最好限制在 0.7-0.8以下，超过0.8，查表时的CPU缓存不命中（cache missing）会按照指数曲线上升。</p>
<p>综上，0.75 是个比较完美的选择。</p>
<p><strong>小结 </strong></p>
<p>HashMap 的加载因子（load factor，直译为加载因子，意译为负载因子）是指哈希表中填充元素的个数与桶的数量的比值，当元素个数达到负载因子与桶的数量的乘积时，就需要进行扩容。这个值一般选择 0.75，是因为这个值可以在时间和空间成本之间做到一个折中，使得哈希表的性能达到较好的表现。</p>
<p>如果负载因子过大，填充因子较多，那么哈希表中的元素就会越来越多地聚集在少数的桶中，这就导致了冲突的增加，这些冲突会导致查找、插入和删除操作的效率下降。同时，这也会导致需要更频繁地进行扩容，进一步降低了性能。</p>
<p>如果负载因子过小，那么桶的数量会很多，虽然可以减少冲突，但是在空间利用上面也会有浪费，因此选择 0.75 是为了取得一个平衡点，即在时间和空间成本之间取得一个比较好的平衡点。</p>
<p>总之，选择 0.75 这个值是为了在时间和空间成本之间达到一个较好的平衡点，既可以保证哈希表的性能表现，又能够充分利用空间。</p>
<p><strong>04、线程不安全 </strong></p>
<p>其实这个问题也不用说太多，但考虑到面试的时候有些面试官会问，那就简单说一下。</p>
<p>三方面原因：</p>
<ul>
<li>多线程下扩容会死循环</li>
<li>多线程下 put 会导致元素丢失</li>
<li>put 和 get 并发时会导致 get 到 null</li>
</ul>
<p><strong>1）多线程下扩容会死循环 </strong></p>
<p>众所周知，HashMap 是通过拉链法来解决哈希冲突的，也就是当哈希冲突时，会将相同哈希值的键值对通过链表的形式存放起来。</p>
<p>JDK 7 时，采用的是头部插入的方式来存放链表的，也就是下一个冲突的键值对会放在上一个键值对的前面（讲扩容的时候讲过了）。扩容的时候就有可能导致出现环形链表，造成死循环。</p>
<p>resize 方法的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// newCapacity为新的容量</span><br><span class="line">void resize(int newCapacity) &#123;</span><br><span class="line">    // 小数组，临时过度下</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    // 扩容前的容量</span><br><span class="line">    int oldCapacity = oldTable.length;</span><br><span class="line">    // MAXIMUM_CAPACITY 为最大容量，2 的 30 次方 = 1&lt;&lt;30</span><br><span class="line">    if (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        // 容量调整为 Integer 的最大值 0x7fffffff（十六进制）=2 的 31 次方-1</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 初始化一个新的数组（大容量）</span><br><span class="line">    Entry[] newTable = new Entry[newCapacity];</span><br><span class="line">    // 把小数组的元素转移到大数组中</span><br><span class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">    // 引用新的大数组</span><br><span class="line">    table = newTable;</span><br><span class="line">    // 重新计算阈值</span><br><span class="line">    threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>transfer 方法用来转移，将小数组的元素拷贝到新的数组中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void transfer(Entry[] newTable, boolean rehash) &#123;</span><br><span class="line">    // 新的容量</span><br><span class="line">    int newCapacity = newTable.length;</span><br><span class="line">    // 遍历小数组</span><br><span class="line">    for (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        while(null != e) &#123;</span><br><span class="line">            // 拉链法，相同 key 上的不同值</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            // 是否需要重新计算 hash</span><br><span class="line">            if (rehash) &#123;</span><br><span class="line">                e.hash = null == e.key ? 0 : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            // 根据大数组的容量，和键的 hash 计算元素在数组中的下标</span><br><span class="line">            int i = indexFor(e.hash, newCapacity);</span><br><span class="line">            // 同一位置上的新元素被放在链表的头部</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            // 放在新的数组上</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            // 链表上的下一个元素</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意 e.next = newTable[i] 和 newTable[i] = e 这两行代码，就会将同一位置上的新元素被放在链表的头部。</p>
<p>扩容前的样子假如是下面这样子。</p>
<p> <img src="\assets\note\image-20231010152210618.png" alt="image-20231010152210618"></p>
<p>那么正常扩容后就是下面这样子。</p>
<p><img src="\assets\note\image-20231010152226084.png" alt="image-20231010152226084"></p>
<p>假设现在有两个线程同时进行扩容，线程 A 在执行到 newTable[i] = e; 被挂起，此时线程 A 中：e=3、next=7、e.next=null</p>
<p><img src="\assets\note\image-20231010152248252.png" alt="image-20231010152248252"></p>
<p>线程 B 开始执行，并且完成了数据转移。</p>
<p><img src="\assets\note\image-20231010152308768.png" alt="image-20231010152308768"></p>
<p>此时，7 的 next 为 3，3 的 next 为 null。</p>
<p>随后线程A获得CPU时间片继续执行 newTable[i] = e ，将3放入新数组对应的位置，执行完此轮循环后线程A的情况如下：</p>
<p><img src="\assets\note\image-20231010152329436.png" alt="image-20231010152329436"></p>
<p>执行下一轮循环，此时 e=7，原本线程 A 中 7 的 next 为 5，但由于 table 是线程 A 和线程 B 共享的，而线程 B 顺利执行完后，7 的 next 变成了 3，那么此时线程 A 中，7 的 next 也为 3 了。</p>
<p>采用头部插入的方式，变成了下面这样子：</p>
<p><img src="\assets\note\image-20231010152352419.png" alt="image-20231010152352419"></p>
<p>好像也没什么问题，此时 next = 3，e = 3。</p>
<p>进行下一轮循环，但此时，由于线程 B 将 3 的 next 变为了 null，所以此轮循环应该是最后一轮了。</p>
<p>接下来当执行完 e.next=newTable[i] 即 3.next=7 后，3 和 7 之间就相互链接了，执行完 newTable[i]=e 后，3 被头插法重新插入到链表中，执行结果如下图所示：</p>
<p><img src="\assets\note\image-20231010152425560.png" alt="image-20231010152425560"></p>
<p>套娃开始，元素 5 也就成了弃婴，惨~~~</p>
<p>不过，JDK 8 时已经修复了这个问题，扩容时会保持链表原来的顺序（嗯，等于说了半天白说了，哈哈，这个面试题确实是这样，很水，但有些面试官又确实比较装逼）。</p>
<p>**2）多线程下 put 会导致元素丢失 </p>
<p>正常情况下，当发生哈希冲突时，HashMap 是这样的：</p>
<p><img src="\assets\note\image-20231010152459546.png" alt="image-20231010152459546"></p>
<p>但多线程同时执行 put 操作时，如果计算出来的索引位置是相同的，那会造成前一个 key 被后一个 key 覆盖，从而导致元素的丢失。</p>
<p>put 的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">               boolean evict) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">    // 步骤①：tab为空则创建</span><br><span class="line">    if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    // 步骤②：计算index，并对null做处理 </span><br><span class="line">    if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">        tab[i] = newNode(hash, key, value, null);</span><br><span class="line">    else &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        // 步骤③：节点key存在，直接覆盖value</span><br><span class="line">        if (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        // 步骤④：判断该链为红黑树</span><br><span class="line">        else if (p instanceof TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">        // 步骤⑤：该链为链表</span><br><span class="line">        else &#123;</span><br><span class="line">            for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">                if ((e = p.next) == null) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, null);</span><br><span class="line">                    //链表长度大于8转换为红黑树进行处理</span><br><span class="line">                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                // key已经存在直接覆盖value</span><br><span class="line">                if (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    break;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 步骤⑥、直接覆盖</span><br><span class="line">        if (e != null) &#123; // existing mapping for key</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    // 步骤⑦：超过最大容量 就扩容</span><br><span class="line">    if (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题发生在步骤 ② 这里：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">    tab[i] = newNode(hash, key, value, null);</span><br></pre></td></tr></table></figure>
<p>两个线程都执行了 if 语句，假设线程 A 先执行了 tab[i] = newNode(hash, key, value, null) ，那 table 是这样的：<br>      <img src="\assets\note\image-20231010152638506.png" alt="image-20231010152638506">    </p>
<p>接着，线程 B 执行了 tab[i] = newNode(hash, key, value, null) ，那 table 是这样的：</p>
<p><img src="\assets\note\image-20231010152655351.png" alt="image-20231010152655351"></p>
<p>3 被干掉了。</p>
<p><strong>3）put 和 get 并发时会导致 get 到 null </strong></p>
<p>线程 A 执行put时，因为元素个数超出阈值而出现扩容，线程B 此时执行get，有可能导致这个问题。</p>
<p>注意来看 resize 源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">    int oldThr = threshold;</span><br><span class="line">    int newCap, newThr = 0;</span><br><span class="line">    if (oldCap &gt; 0) &#123;</span><br><span class="line">        // 超过最大值就不再扩充了，就只好随你碰撞去吧</span><br><span class="line">        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            return oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        // 没超过最大值，就扩充为原来的2倍</span><br><span class="line">        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line">    &#125;</span><br><span class="line">    else if (oldThr &gt; 0) // initial capacity was placed in threshold</span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    else &#123;               // zero initial threshold signifies using defaults</span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    // 计算新的resize上限</span><br><span class="line">    if (newThr == 0) &#123;</span><br><span class="line">        float ft = (float)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (int)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程 A 执行完 table = newTab 之后，线程 B 中的 table 此时也发生了变化，此时去 get 的时候当然会 get 到 null 了，因为元素还没有转移。</p>
<p>参考链接：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lonyw/article/details/80519652">https://blog.csdn.net/lonyw/article/details/80519652</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/91636401">https://zhuanlan.zhihu.com/p/91636401</a></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20733617">https://www.zhihu.com/question/20733617</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/21673805">https://zhuanlan.zhihu.com/p/21673805</a></p>
</blockquote>
<p><strong>4）小结 </strong></p>
<p>HashMap 是线程不安全的主要是因为它在进行插入、删除和扩容等操作时可能会导致链表的结构发生变化，从而破坏了 HashMap 的不变性。具体来说，如果在一个线程正在遍历 HashMap 的链表时，另外一个线程对该链表进行了修改（比如添加了一个节点），那么就会导致链表的结构发生变化，从而破坏了当前线程正在进行的遍历操作，可能导致遍历失败或者出现死循环等问题。</p>
<p>为了解决这个问题，Java 提供了线程安全的 HashMap 实现类 ConcurrentHashMap。ConcurrentHashMap 内部采用了分段锁（Segment），将整个 Map 拆分为多个小的 HashMap，每个小的 HashMap 都有自己的锁，不同的线程可以同时访问不同的小 Map，从而实现了线程安全。在进行插入、删除和扩容等操作时，只需要锁住当前小 Map，不会对整个 Map 进行锁定，提高了并发访问的效率。</p>
<p><strong>05、总结 </strong></p>
<p>HashMap是Java中最常用的集合之一，它是一种键值对存储的数据结构，可以根据键来快速访问对应的值。</p>
<p>以下是对HashMap的总结：</p>
<ul>
<li>HashMap采用数组+链表/红黑树的存储结构，能够在O(1)的时间复杂度内实现元素的添加、删除、查找等操作。</li>
<li>HashMap是线程不安全的，因此在多线程环境下需要使用ConcurrentHashMap来保证线程安全。</li>
<li>HashMap的扩容机制是通过扩大数组容量和重新计算hash值来实现的，扩容时需要重新计算所有元素的hash值，因此在元素较多时扩容会影响性能。</li>
<li>在Java 8中，HashMap的实现引入了拉链法、树化等机制来优化大量元素存储的情况，进一步提升了性能。</li>
<li>HashMap中的key是唯一的，如果要存储重复的key，则后面的值会覆盖前面的值。</li>
<li>HashMap的初始容量和加载因子都可以设置，初始容量表示数组的初始大小，加载因子表示数组的填充因子。一般情况下，初始容量为16，加载因子为0.75。</li>
<li>HashMap在遍历时是无序的，因此如果需要有序遍历，可以使用TreeMap。</li>
</ul>
<p>综上所述，HashMap是一种高效的数据结构，具有快速查找和插入元素的能力，但需要注意线程安全和性能问题。</p>
<h2 id="4-10-LinkedHashMap详解（附源码）"><a href="#4-10-LinkedHashMap详解（附源码）" class="headerlink" title="4.10 LinkedHashMap详解（附源码）"></a>4.10 LinkedHashMap详解（附源码）</h2><p>这篇继续换个文风来写，给大家一点新鲜的空气。</p>
<p>俗话说了，“金无足赤人无完人”，HashMap 也不例外，有一种需求它就满足不了，假如我们需要一个按照插入顺序来排列的键值对集合，那 HashMap 就无能为力了。那该怎么办呢？必须得上今天这篇文章的主角：LinkedHashMap。</p>
<p>同学们好啊，还记得 HashMap 那篇吗？我自己感觉写得非常棒啊，既通俗易懂，又深入源码，真的是分析得透透彻彻、清清楚楚、明明白白的。（一不小心又甩了三个成语，有文化吧？）HashMap 哪哪都好，真的，只要你想用键值对，第一时间就应该想到它。</p>
<p>为了提高查找效率，HashMap 在插入的时候对键做了一次哈希算法，这就导致插入的元素是无序的。</p>
<p>对这一点还不太明白的同学，可以再回到 HashMap 那一篇，看看 hash 方法，再看看我对 put() 方法的讲解，就能明白了，我们这里再来回顾一下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">               boolean evict) &#123;</span><br><span class="line">    HashMap.Node&lt;K,V&gt;[] tab; HashMap.Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">    // ①、数组 table 为 null 时，调用 resize 方法创建默认大小的数组</span><br><span class="line">    if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    // ②、计算下标，如果该位置上没有值，则填充</span><br><span class="line">    if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">        tab[i] = newNode(hash, key, value, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中这个公式 i = (n - 1) &amp; hash 计算后的值就是键位在数组（桶）中的索引（下标/位置），但这它并不是按照 0、1、2、3、4、5 这样有序的下标将键值对插入到数组当中的，而是有一定的随机性。</p>
<p>比如说默认大小为 16 的 HashMap，如果 put 了 4 个键值对，可能下标是 0、4、9、11，那这样的话，在遍历 HashMap 的时候，就不一定能按照插入顺序来了。</p>
<p>看下面的例子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 创建 HashMap 对象，键类型为 String，值类型为 String</span><br><span class="line">Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">// 使用 put() 方法向 HashMap 中添加数据</span><br><span class="line">map.put(&quot;chenmo&quot;, &quot;沉默&quot;);</span><br><span class="line">map.put(&quot;wanger&quot;, &quot;王二&quot;);</span><br><span class="line">map.put(&quot;chenqingyang&quot;, &quot;陈清扬&quot;);</span><br><span class="line">// 遍历 HashMap，输出所有键值对</span><br><span class="line">for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    String key = entry.getKey();</span><br><span class="line">    String value = entry.getValue();</span><br><span class="line">    System.out.println(&quot;Key: &quot; + key + &quot;, Value: &quot; + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看输出结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Key: chenmo, Value: 沉默</span><br><span class="line">Key: chenqingyang, Value: 陈清扬</span><br><span class="line">Key: wanger, Value: 王二</span><br></pre></td></tr></table></figure>
<p>对比一下输出结果就可以看得出来，put 的时候是 沉默、王二、陈清扬的顺序，但遍历的时候就没有按照这个顺序来：沉默、陈清扬、王二，因为 HashMap 是无序的。</p>
<p>那怎么保证键值对的插入顺序呢？</p>
<p>LinkedHashMap 就是为这个需求应运而生的。LinkedHashMap 继承了 HashMap，所以 HashMap 有的关于键值对的功能，它也有了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedHashMap&lt;K,V&gt;</span><br><span class="line">    extends HashMap&lt;K,V&gt;</span><br><span class="line">    implements Map&lt;K,V&gt;&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>在此基础上，LinkedHashMap 内部追加了双向链表，来维护元素的插入顺序。注意下面代码中的 before 和 after，它俩就是用来维护当前元素的前一个元素和后一个元素的顺序的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        super(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于双向链表，同学们可以回头看一遍我写的 LinkedList 那篇文章，会对理解本篇的 LinkedHashMap 有很大的帮助。</p>
<p>用 LinkedHashMap 替换 HashMap，再来对比一下输出结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 创建 LinkedHashMap 对象，键类型为 String，值类型为 String</span><br><span class="line">Map&lt;String, String&gt; map = new LinkedHashMap&lt;&gt;();</span><br><span class="line">// 使用 put() 方法向 LinkedHashMap 中添加数据</span><br><span class="line">map.put(&quot;chenmo&quot;, &quot;沉默&quot;);</span><br><span class="line">map.put(&quot;wanger&quot;, &quot;王二&quot;);</span><br><span class="line">map.put(&quot;chenqingyang&quot;, &quot;陈清扬&quot;);</span><br><span class="line">// 遍历 LinkedHashMap，输出所有键值对</span><br><span class="line">for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    String key = entry.getKey();</span><br><span class="line">    String value = entry.getValue();</span><br><span class="line">    System.out.println(&quot;Key: &quot; + key + &quot;, Value: &quot; + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Key: chenmo, Value: 沉默</span><br><span class="line">Key: wanger, Value: 王二</span><br><span class="line">Key: chenqingyang, Value: 陈清扬</span><br></pre></td></tr></table></figure>
<p>看，LinkedHashMap 是不是保持了插入顺序？这就对了。</p>
<p><strong>01、插入顺序 </strong></p>
<p>在 HashMap 那篇文章里，我有讲解到一点，不知道同学们记不记得，就是 null 会插入到 HashMap 的第一位。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line">hashMap.put(&quot;沉&quot;, &quot;沉默王二&quot;);</span><br><span class="line">hashMap.put(&quot;默&quot;, &quot;沉默王二&quot;);</span><br><span class="line">hashMap.put(&quot;王&quot;, &quot;沉默王二&quot;);</span><br><span class="line">hashMap.put(&quot;二&quot;, &quot;沉默王二&quot;);</span><br><span class="line">hashMap.put(null, null);</span><br><span class="line">for (String key : hashMap.keySet()) &#123;</span><br><span class="line">    System.out.println(key + &quot; : &quot; + hashMap.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出的结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">null : null</span><br><span class="line">默 : 沉默王二</span><br><span class="line">沉 : 沉默王二</span><br><span class="line">王 : 沉默王二</span><br><span class="line">二 : 沉默王二</span><br></pre></td></tr></table></figure>
<p>虽然 null 最后一位 put 进去的，但在遍历输出的时候，跑到了第一位。</p>
<p>那再来对比看一下 LinkedHashMap。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; linkedHashMap = new LinkedHashMap&lt;&gt;();</span><br><span class="line">linkedHashMap.put(&quot;沉&quot;, &quot;沉默王二&quot;);</span><br><span class="line">linkedHashMap.put(&quot;默&quot;, &quot;沉默王二&quot;);</span><br><span class="line">linkedHashMap.put(&quot;王&quot;, &quot;沉默王二&quot;);</span><br><span class="line">linkedHashMap.put(&quot;二&quot;, &quot;沉默王二&quot;);</span><br><span class="line">linkedHashMap.put(null, null);</span><br><span class="line">for (String key : linkedHashMap.keySet()) &#123;</span><br><span class="line">    System.out.println(key + &quot; : &quot; + linkedHashMap.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">沉 : 沉默王二</span><br><span class="line">默 : 沉默王二</span><br><span class="line">王 : 沉默王二</span><br><span class="line">二 : 沉默王二</span><br><span class="line">null : null</span><br></pre></td></tr></table></figure>
<p>null 在最后一位插入，在最后一位输出。</p>
<p>输出结果可以再次证明，<strong>HashMap 是无序的，LinkedHashMap 是可以维持插入顺序的。</strong></p>
<p>那 LinkedHashMap 是如何做到这一点呢？我相信同学们和我一样，非常希望知道原因。</p>
<p>要想搞清楚，就需要深入研究一下 LinkedHashMap 的源码。LinkedHashMap 并未重写 HashMap 的 put() 方法，而是重写了 put() 方法需要调用的内部方法 newNode() 。</p>
<p>这是 HashMap 的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">    return new Node&lt;&gt;(hash, key, value, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是 LinkedHashMap 的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HashMap.Node&lt;K,V&gt; newNode(int hash, K key, V value, HashMap.Node&lt;K,V&gt; e) &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            new LinkedHashMap.Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面曾提到 LinkedHashMap.Entry 继承了 HashMap.Node，并且追加了两个字段 before 和 after，用来维持键值对的关系。</p>
<p>在 LinkedHashMap 中，链表中的节点顺序是按照插入顺序维护的。当使用 put() 方法向 LinkedHashMap 中添加键值对时，会将新节点插入到链表的尾部，并更新 before 和 after 属性，以保证链表的顺序关系——由 linkNodeLast() 方法来完成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 将指定节点插入到链表的尾部</span><br><span class="line"> *</span><br><span class="line"> * @param p 要插入的节点</span><br><span class="line"> */</span><br><span class="line">private void linkNodeLast(LinkedHashMap.Entry&lt;K,V&gt; p) &#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail; // 获取链表的尾节点</span><br><span class="line">    tail = p; // 将 p 设为尾节点</span><br><span class="line">    if (last == null)</span><br><span class="line">        head = p; // 如果链表为空，则将 p 设为头节点</span><br><span class="line">    else &#123;</span><br><span class="line">        p.before = last; // 将 p 的前驱节点设为链表的尾节点</span><br><span class="line">        last.after = p; // 将链表的尾节点的后继节点设为 p</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到了吧，LinkedHashMap 在添加第一个元素的时候，会把 head 赋值为第一个元素，等到第二个元素添加进来的时候，会把第二个元素的 before 赋值为第一个元素，第一个元素的 afer 赋值为第二个元素。</p>
<p>这就保证了键值对是按照插入顺序排列的，明白了吧？</p>
<p><strong>02、访问顺序 </strong></p>
<p>LinkedHashMap 不仅能够维持插入顺序，还能够维持访问顺序。访问包括调用 get() 方法、 remove() 方法和 put() 方法。</p>
<p>要维护访问顺序，需要我们在声明 LinkedHashMap 的时候指定三个参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LinkedHashMap&lt;String, String&gt; map = new LinkedHashMap&lt;&gt;(16, .75f, true);</span><br></pre></td></tr></table></figure>
<p>第一个参数和第二个参数，看过 HashMap 的同学们应该很熟悉了，指的是初始容量和负载因子。</p>
<p>第三个参数如果为 true 的话，就表示 LinkedHashMap 要维护访问顺序；否则，维护插入顺序。默认是 false。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; linkedHashMap = new LinkedHashMap&lt;&gt;(16, .75f, true);</span><br><span class="line">linkedHashMap.put(&quot;沉&quot;, &quot;沉默王二&quot;);</span><br><span class="line">linkedHashMap.put(&quot;默&quot;, &quot;沉默王二&quot;);</span><br><span class="line">linkedHashMap.put(&quot;王&quot;, &quot;沉默王二&quot;);</span><br><span class="line">linkedHashMap.put(&quot;二&quot;, &quot;沉默王二&quot;);</span><br><span class="line">System.out.println(linkedHashMap);</span><br><span class="line">linkedHashMap.get(&quot;默&quot;);</span><br><span class="line">System.out.println(linkedHashMap);</span><br><span class="line">linkedHashMap.get(&quot;王&quot;);</span><br><span class="line">System.out.println(linkedHashMap);</span><br></pre></td></tr></table></figure>
<p>输出的结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;沉=沉默王二, 默=沉默王二, 王=沉默王二, 二=沉默王二&#125;</span><br><span class="line">&#123;沉=沉默王二, 王=沉默王二, 二=沉默王二, 默=沉默王二&#125;</span><br><span class="line">&#123;沉=沉默王二, 二=沉默王二, 默=沉默王二, 王=沉默王二&#125;</span><br></pre></td></tr></table></figure>
<p>当我们使用 get() 方法访问键位“默”的元素后，输出结果中，默=沉默王二 在最后；当我们访问键位“王”的元素后，输出结果中，王=沉默王二 在最后，默=沉默王二 在倒数第二位。</p>
<p>也就是说，最不经常访问的放在头部，这就有意思了。有意思在哪呢？</p>
<p>我们可以使用 LinkedHashMap 来实现 LRU 缓存，LRU 是 Least Recently Used 的缩写，即最近最少使用，是一种常用的页面置换算法，选择最近最久未使用的页面予以淘汰。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 自定义的 MyLinkedHashMap 类，继承了 Java 中内置的 LinkedHashMap&lt;K, V&gt; 类。</span><br><span class="line"> * 用于实现一个具有固定大小的缓存，当缓存达到最大容量时，会自动移除最早加入的元素，以腾出空间给新的元素。</span><br><span class="line"> *</span><br><span class="line"> * @param &lt;K&gt; 键的类型</span><br><span class="line"> * @param &lt;V&gt; 值的类型</span><br><span class="line"> */</span><br><span class="line">public class MyLinkedHashMap&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; &#123;</span><br><span class="line">    private static final int MAX_ENTRIES = 5; // 表示 MyLinkedHashMap 中最多存储的键值对数量</span><br><span class="line">    /**</span><br><span class="line">     * 构造方法，使用 super() 调用了父类的构造函数，并传递了三个参数：initialCapacity、loadFactor 和 accessOrder。</span><br><span class="line">     *</span><br><span class="line">     * @param initialCapacity 初始容量</span><br><span class="line">     * @param loadFactor      负载因子</span><br><span class="line">     * @param accessOrder     访问顺序</span><br><span class="line">     */</span><br><span class="line">    public MyLinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) &#123;</span><br><span class="line">        super(initialCapacity, loadFactor, accessOrder);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 重写父类的 removeEldestEntry() 方法，用于指示是否应该移除最早加入的元素。</span><br><span class="line">     * 如果返回 true，那么将删除最早加入的元素。</span><br><span class="line">     *</span><br><span class="line">     * @param eldest 最早加入的元素</span><br><span class="line">     * @return 如果当前 MyLinkedHashMap 中元素的数量大于 MAX_ENTRIES，返回 true，否则返回 false。</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected boolean removeEldestEntry(Map.Entry eldest) &#123;</span><br><span class="line">        return size() &gt; MAX_ENTRIES;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MyLinkedHashMap 是一个自定义类，它继承了 LinkedHashMap，并且重写了 removeEldestEntry() 方<br>法——使 Map 最多可容纳 5 个元素，超出后就淘汰。</p>
<p>我们来测试一下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MyLinkedHashMap&lt;String,String&gt; map = new MyLinkedHashMap&lt;&gt;(16,0.75f,true);</span><br><span class="line">map.put(&quot;沉&quot;, &quot;沉默王二&quot;);</span><br><span class="line">map.put(&quot;默&quot;, &quot;沉默王二&quot;);</span><br><span class="line">map.put(&quot;王&quot;, &quot;沉默王二&quot;);</span><br><span class="line">map.put(&quot;二&quot;, &quot;沉默王二&quot;);</span><br><span class="line">map.put(&quot;一枚有趣的程序员&quot;, &quot;一枚有趣的程序员&quot;);</span><br><span class="line">System.out.println(map);</span><br><span class="line">map.put(&quot;一枚有颜值的程序员&quot;, &quot;一枚有颜值的程序员&quot;);</span><br><span class="line">System.out.println(map);</span><br><span class="line">map.put(&quot;一枚有才华的程序员&quot;,&quot;一枚有才华的程序员&quot;);</span><br><span class="line">System.out.println(map);</span><br></pre></td></tr></table></figure>
<p>输出结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;沉=沉默王二, 默=沉默王二, 王=沉默王二, 二=沉默王二, 一枚有趣的程序员=一枚有趣的程序员&#125;</span><br><span class="line">&#123;默=沉默王二, 王=沉默王二, 二=沉默王二, 一枚有趣的程序员=一枚有趣的程序员, 一枚有颜值的程序员=一枚</span><br><span class="line">有颜值的程序员&#125;</span><br><span class="line">&#123;王=沉默王二, 二=沉默王二, 一枚有趣的程序员=一枚有趣的程序员, 一枚有颜值的程序员=一枚有颜值的程序</span><br><span class="line">员, 一枚有才华的程序员=一枚有才华的程序员&#125;</span><br></pre></td></tr></table></figure>
<p>沉=沉默王二 和 默=沉默王二 依次被淘汰出局。</p>
<p>假如在 put “一枚有才华的程序员”之前 get 了键位为“默”的元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">MyLinkedHashMap&lt;String,String&gt; map = new MyLinkedHashMap&lt;&gt;(16,0.75f,true);</span><br><span class="line">map.put(&quot;沉&quot;, &quot;沉默王二&quot;);</span><br><span class="line">map.put(&quot;默&quot;, &quot;沉默王二&quot;);</span><br><span class="line">map.put(&quot;王&quot;, &quot;沉默王二&quot;);</span><br><span class="line">map.put(&quot;二&quot;, &quot;沉默王二&quot;);</span><br><span class="line">map.put(&quot;一枚有趣的程序员&quot;, &quot;一枚有趣的程序员&quot;);</span><br><span class="line">System.out.println(map);</span><br><span class="line">map.put(&quot;一枚有颜值的程序员&quot;, &quot;一枚有颜值的程序员&quot;);</span><br><span class="line">System.out.println(map);</span><br><span class="line">map.get(&quot;默&quot;);</span><br><span class="line">map.put(&quot;一枚有才华的程序员&quot;,&quot;一枚有才华的程序员&quot;);</span><br><span class="line">System.out.println(map);</span><br></pre></td></tr></table></figure>
<p>那输出结果就变了，对吧？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;沉=沉默王二, 默=沉默王二, 王=沉默王二, 二=沉默王二, 一枚有趣的程序员=一枚有趣的程序员&#125;</span><br><span class="line">&#123;默=沉默王二, 王=沉默王二, 二=沉默王二, 一枚有趣的程序员=一枚有趣的程序员, 一枚有颜值的程序员=一枚</span><br><span class="line">有颜值的程序员&#125;</span><br><span class="line">&#123;二=沉默王二, 一枚有趣的程序员=一枚有趣的程序员, 一枚有颜值的程序员=一枚有颜值的程序员, 默=沉默王</span><br><span class="line">二, 一枚有才华的程序员=一枚有才华的程序员&#125;</span><br></pre></td></tr></table></figure>
<p>沉=沉默王二 和 王=沉默王二 被淘汰出局了。</p>
<p>那 LinkedHashMap 是如何来维持访问顺序呢？同学们感兴趣的话，可以研究一下下面这三个方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void afterNodeAccess(Node&lt;K,V&gt; p) &#123; &#125;</span><br><span class="line">void afterNodeInsertion(boolean evict) &#123; &#125;</span><br><span class="line">void afterNodeRemoval(Node&lt;K,V&gt; p) &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>afterNodeAccess() 会在调用 get() 方法的时候被调用， afterNodeInsertion() 会在调用 put() 方法的时候被调用， afterNodeRemoval() 会在调用 remove() 方法的时候被调用。</p>
<p>我来以 afterNodeAccess() 为例来讲解一下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 在访问节点后，将节点移动到链表的尾部</span><br><span class="line"> *</span><br><span class="line"> * @param e 要移动的节点</span><br><span class="line"> */</span><br><span class="line">void afterNodeAccess(HashMap.Node&lt;K,V&gt; e) &#123; // move node to last</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    if (accessOrder &amp;&amp; (last = tail) != e) &#123; // 如果按访问顺序排序，并且访问的节点不是尾节点</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = </span><br><span class="line">p.after;</span><br><span class="line">        p.after = null; // 将要移动的节点的后继节点设为 null</span><br><span class="line">        if (b == null)</span><br><span class="line">            head = a; // 如果要移动的节点没有前驱节点，则将要移动的节点设为头节点</span><br><span class="line">        else</span><br><span class="line">            b.after = a; // 将要移动的节点的前驱节点的后继节点设为要移动的节点的后继节点</span><br><span class="line">        if (a != null)</span><br><span class="line">            a.before = b; // 如果要移动的节点有后继节点，则将要移动的节点的后继节点的前驱节点设</span><br><span class="line">为要移动的节点的前驱节点</span><br><span class="line">        else</span><br><span class="line">            last = b; // 如果要移动的节点没有后继节点，则将要移动的节点的前驱节点设为尾节点</span><br><span class="line">        if (last == null)</span><br><span class="line">            head = p; // 如果尾节点为空，则将要移动的节点设为头节点</span><br><span class="line">        else &#123;</span><br><span class="line">            p.before = last; // 将要移动的节点的前驱节点设为尾节点</span><br><span class="line">            last.after = p; // 将尾节点的后继节点设为要移动的节点</span><br><span class="line">        &#125;</span><br><span class="line">        tail = p; // 将要移动的节点设为尾节点</span><br><span class="line">        ++modCount; // 修改计数器</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>哪个元素被 get 就把哪个元素放在最后。了解了吧？</p>
<p>那同学们可能还想知道，为什么 LinkedHashMap 能实现 LRU 缓存，把最不经常访问的那个元素淘汰？</p>
<p>在插入元素的时候，需要调用 put() 方法，该方法最后会调用 afterNodeInsertion() 方法，这个方法被 LinkedHashMap 重写了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 在插入节点后，如果需要，可能会删除最早加入的元素</span><br><span class="line"> *</span><br><span class="line"> * @param evict 是否需要删除最早加入的元素</span><br><span class="line"> */</span><br><span class="line">void afterNodeInsertion(boolean evict) &#123; // possibly remove eldest</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) &#123; // 如果需要删除</span><br><span class="line">最早加入的元素</span><br><span class="line">        K key = first.key; // 获取要删除元素的键</span><br><span class="line">        removeNode(hash(key), key, null, false, true); // 调用 removeNode() 方法删除元</span><br><span class="line">素</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>removeEldestEntry() 方法会判断第一个元素是否超出了可容纳的最大范围，如果超出，那就会调用 removeNode() 方法对最不经常访问的那个元素进行删除。</p>
<p><strong>03、小结 </strong></p>
<p>由于 LinkedHashMap 要维护双向链表，所以 LinkedHashMap 在插入、删除操作的时候，花费的时间要比 HashMap 多一些。</p>
<p>这也是没办法的事，对吧，欲戴皇冠必承其重嘛。既然想要维护元素的顺序，总要付出点代价才行。</p>
<p>简单总结一下吧。</p>
<p>首先，我们知道 HashMap 是一种常用的哈希表数据结构，它可以快速地进行键值对的查找和插入操作。但是，HashMap 本身并不保证键值对的顺序，如果我们需要按照插入顺序或访问顺序来遍历键值对，就需要使用 LinkedHashMap 了。</p>
<p>LinkedHashMap 继承自 HashMap，它在 HashMap 的基础上，增加了一个双向链表来维护键值对的顺序。这个链表可以按照插入顺序或访问顺序排序，它的头节点表示最早插入或访问的元素，尾节点表示最晚插入或访问的元素。这个链表的作用就是让 LinkedHashMap 可以保持键值对的顺序，并且可以按照顺序遍历键值对。</p>
<p>LinkedHashMap 还提供了两个构造方法来指定排序方式，分别是按照插入顺序排序和按照访问顺序排序。在按照访问顺序排序的情况下，每次访问一个键值对，都会将该键值对移到链表的尾部，以保证最近访问的元素在最后面。如果需要删除最早加入的元素，可以通过重写 removeEldestEntry() 方法来实现。</p>
<p>总之，LinkedHashMap 通过维护一个双向链表来保持键值对的顺序，可以按照插入顺序或访问顺序来遍历键值对。如果你需要按照顺序来遍历键值对，那么 LinkedHashMap 就是你的不二选择了！</p>
<h2 id="4-11-TreeMap详解（附源码）"><a href="#4-11-TreeMap详解（附源码）" class="headerlink" title="4.11 TreeMap详解（附源码）"></a>4.11 TreeMap详解（附源码）</h2><p>下面有请王老师上台，来给大家讲一讲 TreeMap，鼓掌了！</p>
<p>之前 LinkedHashMap 那篇文章里提到过了，HashMap 是无序的，所以有了 LinkedHashMap，加上了双向链表后，就可以保持元素的插入顺序和访问顺序，那 TreeMap 呢？</p>
<p>TreeMap 由红黑树实现，可以保持元素的自然顺序，或者实现了 Comparator 接口的自定义顺序。</p>
<p>可能有些同学不了解红黑树，我这里来普及一下：</p>
<blockquote>
<p>红黑树（英语：Red–black tree）是一种自平衡的二叉查找树（Binary Search Tree），结构复杂，但却有着良好的性能，完成查找、插入和删除的时间复杂度均为 log(n)。</p>
</blockquote>
<p>二叉查找树是一种常见的树形结构，它的每个节点都包含一个键值对。每个节点的左子树节点的键值小于该节点的键值，右子树节点的键值大于该节点的键值，这个特性使得二叉查找树非常适合进行数据的查找和排序操作。</p>
<p>下面是一个简单的手绘图，展示了一个二叉查找树的结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     8</span><br><span class="line">   /   \</span><br><span class="line">  3     10</span><br><span class="line"> / \      \</span><br><span class="line">1   6     14</span><br><span class="line">   / \    /</span><br><span class="line">  4   7  13</span><br></pre></td></tr></table></figure>
<p>在上面这个二叉查找树中，根节点是 8，左子树节点包括 3、1、6、4 和 7，右子树节点包括 10、14 和 13。</p>
<ul>
<li>3&lt;8&lt;10</li>
<li>1&lt;3&lt;6</li>
<li>4&lt;6&lt;7</li>
<li>10&lt;14</li>
<li>13&lt;14</li>
</ul>
<p>这是一颗典型的二叉查找树：</p>
<p>1）左子树上所有节点的值均小于或等于它的根结点的值。</p>
<p>2）右子树上所有节点的值均大于或等于它的根结点的值。</p>
<p>3）左、右子树也分别为二叉查找树。</p>
<p>二叉查找树用来查找非常方面，从根节点开始遍历，如果当前节点的键值等于要查找的键值，则查找成功；如果要查找的键值小于当前节点的键值，则继续遍历左子树；如果要查找的键值大于当前节点的键值，则继续遍历右子树。如果遍历到叶子节点仍然没有找到，则查找失败。</p>
<p>插入操作也非常简单，从根节点开始遍历，如果要插入的键值小于当前节点的键值，则将其插入到左子树中；如果要插入的键值大于当前节点的键值，则将其插入到右子树中。如果要插入的键值已经存在于树中，则更新该节点的值。</p>
<p>删除操作稍微复杂一些，需要考虑多种情况，包括要删除的节点是叶子节点、要删除的节点只有一个子节点、要删除的节点有两个子节点等等。</p>
<p>总之，二叉查找树是一种非常常用的数据结构，它可以帮助我们实现数据的查找、排序和删除等操作。</p>
<p>理解二叉查找树了吧？</p>
<p>不过，二叉查找树有一个明显的不足，就是容易变成瘸子，就是一侧多，一侧少，比如说这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">       6</span><br><span class="line">     /   \</span><br><span class="line">    4     8</span><br><span class="line">   /     / \</span><br><span class="line">  3     7   9</span><br><span class="line"> /</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>在上面这个不平衡的二叉查找树中，左子树比右子树高。根节点是 6，左子树节点包括 4、3 和 1，右子树节点包括 8、7 和 9。</p>
<p>由于左子树比右子树高，这个不平衡的二叉查找树可能会导致查找、插入和删除操作的效率下降。</p>
<p>来一个更极端的情况。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line">   \</span><br><span class="line">    3</span><br><span class="line">     \</span><br><span class="line">      4</span><br><span class="line">       \</span><br><span class="line">        5</span><br><span class="line">         \</span><br><span class="line">          6</span><br></pre></td></tr></table></figure>
<p>在上面这个极度不平衡的二叉查找树中，所有节点都只有一个右子节点，根节点是 1，右子树节点包括 2、3、4、5 和 6。</p>
<p>这种极度不平衡的二叉查找树会导致查找、插入和删除操作的效率急剧下降，因为每次操作都只能在右子树中进行，而左子树几乎没有被利用到。</p>
<p>查找的效率就要从 log(n) 变成 o(n) 了（戳这里了解时间复杂度），对吧？</p>
<p>必须要平衡一下，对吧？于是就有了平衡二叉树，左右两个子树的高度差的绝对值不超过 1，就像下图这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     8</span><br><span class="line">   /   \</span><br><span class="line">  4     12</span><br><span class="line"> / \    / \</span><br><span class="line">2   6  10  14</span><br><span class="line">   / \    / \</span><br><span class="line">  5   7  13  15</span><br></pre></td></tr></table></figure>
<p>根节点是 8，左子树节点包括 4、2、6、5 和 7，右子树节点包括 12、10、14、13 和 15。左子树和右子树的高度差不超过1，因此它是一个平衡二叉查找树。</p>
<p>平衡二叉树就像是一棵树形秤，它的左右两边的重量要尽可能的平衡。当我们往平衡二叉树中插入一个节点时，平衡二叉树会自动调整节点的位置，以保证树的左右两边的高度差不超过1。类似地，当我们删除一个节点时，平衡二叉树也会自动调整节点的位置，以保证树的左右两边的高度差不超过1。</p>
<p>常见的平衡二叉树包括AVL树、红黑树等等，它们都是通过旋转操作来调整树的平衡，使得左子树和右子树的高度尽可能接近。</p>
<p>AVL树的示意图：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     8</span><br><span class="line">   /   \</span><br><span class="line">  4     12</span><br><span class="line"> / \   /  \</span><br><span class="line">2   6 10  14</span><br><span class="line">   / \</span><br><span class="line">  5   7</span><br></pre></td></tr></table></figure>
<p>AVL树是一种高度平衡的二叉查找树，它要求左子树和右子树的高度差不超过1。由于AVL树的平衡度比较高，因此在进行插入和删除操作时需要进行更多的旋转操作来保持平衡，但是在查找操作时效率较高。AVL树适用于读操作比较多的场景。</p>
<p>例如，对于一个需要频繁进行查找操作的场景，如字典树、哈希表等数据结构，可以使用AVL树来进行优化。另外，AVL树也适用于需要保证数据有序性的场景，如数据库中的索引。</p>
<p>AVL树最初由两位苏联的计算机科学家，Adelson-Velskii和Landis，于1962年提出。因此，AVL树就以他们两人名字的首字母缩写命名了。</p>
<p>AVL树的发明对计算机科学的发展有着重要的影响，不仅为后来的平衡二叉树提供了基础，而且为其他领域的数据结构和算法提供了启示。</p>
<p>红黑树的示意图（R 即 Red「红」、B 即 Black「黑」）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     8B</span><br><span class="line">   /   \</span><br><span class="line">  4R    12R</span><br><span class="line"> / \   /  \</span><br><span class="line">2B 6B 10B 14B</span><br><span class="line">   / \</span><br><span class="line">  5R 7R</span><br></pre></td></tr></table></figure>
<p>红黑树，顾名思义，就是节点是红色或者黑色的平衡二叉树，它通过颜色的约束来维持二叉树的平衡，它要求任意一条路径上的黑色节点数目相同，同时还需要满足一些其他特定的条件，如红色节点的父节点必须为黑色节点等。</p>
<p>1）每个节点都只能是红色或者黑色</p>
<p>2）根节点是黑色</p>
<p>3）每个叶节点（NIL 节点，空节点）是黑色的。</p>
<p>4）如果一个节点是红色的，则它两个子节点都是黑色的。也就是说在一条路径上不能出现相邻的两个红色节点。</p>
<p>5）从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</p>
<p>由于红黑树的平衡度比AVL树稍低，因此在进行插入和删除操作时需要进行的旋转操作较少，但是在查找操作时效率仍然较高。红黑树适用于读写操作比较均衡的场景。</p>
<p>那，关于红黑树，同学们就先了解到这，脑子里有个大概的印象，知道 TreeMap 是个什么玩意。</p>
<p><strong>01、自然顺序 </strong></p>
<p>默认情况下，TreeMap 是根据 key 的自然顺序排列的。比如说整数，就是升序，1、2、3、4、5。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TreeMap&lt;Integer,String&gt; mapInt = new TreeMap&lt;&gt;();</span><br><span class="line">mapInt.put(3, &quot;沉默王二&quot;);</span><br><span class="line">mapInt.put(2, &quot;沉默王二&quot;);</span><br><span class="line">mapInt.put(1, &quot;沉默王二&quot;);</span><br><span class="line">mapInt.put(5, &quot;沉默王二&quot;);</span><br><span class="line">mapInt.put(4, &quot;沉默王二&quot;);</span><br><span class="line">System.out.println(mapInt);</span><br></pre></td></tr></table></figure>
<p>输出结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;1=沉默王二, 2=沉默王二, 3=沉默王二, 4=沉默王二, 5=沉默王二&#125;</span><br></pre></td></tr></table></figure>
<p>TreeMap 是怎么做到的呢？想一探究竟，就得上源码了，来看 TreeMap 的 put() 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    Entry&lt;K,V&gt; t = root; // 将根节点赋值给变量t</span><br><span class="line">    if (t == null) &#123; // 如果根节点为null，说明TreeMap为空</span><br><span class="line">        compare(key, key); // type (and possibly null) check，检查key的类型是否合法</span><br><span class="line">        root = new Entry&lt;&gt;(key, value, null); // 创建一个新节点作为根节点</span><br><span class="line">        size = 1; // size设置为1</span><br><span class="line">        return null; // 返回null，表示插入成功</span><br><span class="line">    &#125;</span><br><span class="line">    int cmp;</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    // split comparator and comparable paths，根据使用的比较方法进行查找</span><br><span class="line">    Comparator&lt;? super K&gt; cpr = comparator; // 获取比较器</span><br><span class="line">    if (cpr != null) &#123; // 如果使用了Comparator</span><br><span class="line">        do &#123;</span><br><span class="line">            parent = t; // 将当前节点赋值给parent</span><br><span class="line">            cmp = cpr.compare(key, t.key); // 使用Comparator比较key和t的键的大小</span><br><span class="line">            if (cmp &lt; 0) // 如果key小于t的键</span><br><span class="line">                t = t.left; // 在t的左子树中查找</span><br><span class="line">            else if (cmp &gt; 0) // 如果key大于t的键</span><br><span class="line">                t = t.right; // 在t的右子树中查找</span><br><span class="line">            else // 如果key等于t的键</span><br><span class="line">                return t.setValue(value); // 直接更新t的值</span><br><span class="line">        &#125; while (t != null);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123; // 如果没有使用Comparator</span><br><span class="line">        if (key == null) // 如果key为null</span><br><span class="line">            throw new NullPointerException(); // 抛出NullPointerException异常</span><br><span class="line">            Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; // 将key强制转换为Comparable类型</span><br><span class="line">        do &#123;</span><br><span class="line">            parent = t; // 将当前节点赋值给parent</span><br><span class="line">            cmp = k.compareTo(t.key); // 使用Comparable比较key和t的键的大小</span><br><span class="line">            if (cmp &lt; 0) // 如果key小于t的键</span><br><span class="line">                t = t.left; // 在t的左子树中查找</span><br><span class="line">            else if (cmp &gt; 0) // 如果key大于t的键</span><br><span class="line">                t = t.right; // 在t的右子树中查找</span><br><span class="line">            else // 如果key等于t的键</span><br><span class="line">                return t.setValue(value); // 直接更新t的值</span><br><span class="line">        &#125; while (t != null);</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果没有找到相同的键，需要创建一个新节点插入到TreeMap中</span><br><span class="line">    Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent); // 创建一个新节点</span><br><span class="line">    if (cmp &lt; 0) // 如果key小于parent的键</span><br><span class="line">        parent.left = e; // 将e作为parent的左子节点</span><br><span class="line">    else</span><br><span class="line">        parent.right = e; // 将e作为parent的右子节点</span><br><span class="line">    fixAfterInsertion(e); // 插入节点后需要进行平衡操作</span><br><span class="line">    size++; // size加1</span><br><span class="line">    return null; // 返回null，表示插入成功</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>首先定义一个Entry类型的变量t，用于表示当前的根节点；</li>
<li>如果t为null，说明TreeMap为空，直接创建一个新的节点作为根节点，并将size设置为1；</li>
<li>如果t不为null，说明需要在TreeMap中查找键所对应的节点。因为TreeMap中的元素是有序的，所以可以使用二分查找的方式来查找节点；</li>
<li>如果TreeMap中使用了Comparator来进行排序，则使用Comparator进行比较，否则使用Comparable进行比较。如果查找到了相同的键，则直接更新键所对应的值；</li>
<li>如果没有查找到相同的键，则创建一个新的节点，并将其插入到TreeMap中。然后使用fixAfterInsertion()方法来修正插入节点后的平衡状态；</li>
<li>最后将TreeMap的size加1，然后返回null。如果更新了键所对应的值，则返回原先的值。</li>
</ul>
<p>注意 cmp = k.compareTo(t.key) 这行代码，就是用来进行 key 比较的，由于此时 key 是 String，所以就会调用 String 类的compareTo() 方法进行比较。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public int compareTo(String anotherString) &#123;</span><br><span class="line">    // 获取当前字符串和另一个字符串的长度</span><br><span class="line">    int len1 = value.length;</span><br><span class="line">    int len2 = anotherString.value.length;</span><br><span class="line">    // 取两个字符串长度的较短者作为比较的上限</span><br><span class="line">    int lim = Math.min(len1, len2);</span><br><span class="line">    // 获取当前字符串和另一个字符串的字符数组</span><br><span class="line">    char v1[] = value;</span><br><span class="line">    char v2[] = anotherString.value;</span><br><span class="line">    int k = 0;</span><br><span class="line">    // 对两个字符串的每个字符进行比较</span><br><span class="line">    while (k &lt; lim) &#123;</span><br><span class="line">        char c1 = v1[k];</span><br><span class="line">        char c2 = v2[k];</span><br><span class="line">        // 如果两个字符不相等，返回它们的差值</span><br><span class="line">        if (c1 != c2) &#123;</span><br><span class="line">            return c1 - c2;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果两个字符串前面的字符都相等，返回它们长度的差值</span><br><span class="line">    return len1 - len2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看下面的示例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TreeMap&lt;String,String&gt; mapString = new TreeMap&lt;&gt;();</span><br><span class="line">mapString.put(&quot;c&quot;, &quot;沉默王二&quot;);</span><br><span class="line">mapString.put(&quot;b&quot;, &quot;沉默王二&quot;);</span><br><span class="line">mapString.put(&quot;a&quot;, &quot;沉默王二&quot;);</span><br><span class="line">mapString.put(&quot;e&quot;, &quot;沉默王二&quot;);</span><br><span class="line">mapString.put(&quot;d&quot;, &quot;沉默王二&quot;);</span><br><span class="line">System.out.println(mapString);</span><br></pre></td></tr></table></figure>
<p>输出结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;a=沉默王二, b=沉默王二, c=沉默王二, d=沉默王二, e=沉默王二&#125;</span><br></pre></td></tr></table></figure>
<p>从结果可以看得出，是按照字母的升序进行排序的。</p>
<p><strong>02、自定义排序 </strong></p>
<p>如果自然顺序不满足，那就可以在声明 TreeMap 对象的时候指定排序规则。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TreeMap&lt;Integer,String&gt; mapIntReverse = new TreeMap&lt;&gt;(Comparator.reverseOrder());</span><br><span class="line">mapIntReverse.put(3, &quot;沉默王二&quot;);</span><br><span class="line">mapIntReverse.put(2, &quot;沉默王二&quot;);</span><br><span class="line">mapIntReverse.put(1, &quot;沉默王二&quot;);</span><br><span class="line">mapIntReverse.put(5, &quot;沉默王二&quot;);</span><br><span class="line">mapIntReverse.put(4, &quot;沉默王二&quot;);</span><br><span class="line">System.out.println(mapIntReverse);</span><br></pre></td></tr></table></figure>
<p>TreeMap 提供了可以指定排序规则的构造方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public TreeMap(Comparator&lt;? super K&gt; comparator) &#123;</span><br><span class="line">    this.comparator = comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Comparator.reverseOrder() 返回的是 Collections.ReverseComparator 对象，就是用来反转顺序的，非常方便。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private static class ReverseComparator</span><br><span class="line">        implements Comparator&lt;Comparable&lt;Object&gt;&gt;, Serializable &#123;</span><br><span class="line">    // 单例模式，用于表示逆序比较器</span><br><span class="line">    static final ReverseComparator REVERSE_ORDER</span><br><span class="line">            = new ReverseComparator();</span><br><span class="line">    // 实现比较方法，对两个实现了Comparable接口的对象进行逆序比较</span><br><span class="line">    public int compare(Comparable&lt;Object&gt; c1, Comparable&lt;Object&gt; c2) &#123;</span><br><span class="line">        return c2.compareTo(c1); // 调用c2的compareTo()方法，以c1为参数，实现逆序比较</span><br><span class="line">    &#125;</span><br><span class="line">    // 反序列化时，返回Collections.reverseOrder()，保证单例模式</span><br><span class="line">    private Object readResolve() &#123;</span><br><span class="line">        return Collections.reverseOrder();</span><br><span class="line">    &#125;</span><br><span class="line">    // 返回正序比较器</span><br><span class="line">    @Override</span><br><span class="line">    public Comparator&lt;Comparable&lt;Object&gt;&gt; reversed() &#123;</span><br><span class="line">        return Comparator.naturalOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，输出结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;5=沉默王二, 4=沉默王二, 3=沉默王二, 2=沉默王二, 1=沉默王二&#125;</span><br></pre></td></tr></table></figure>
<p>HashMap 是无序的，插入的顺序随着元素的增加会不停地变动。但 TreeMap 能够至始至终按照指定的顺序排列，这对于需要自定义排序的场景，实在是太有用了！</p>
<p><strong>03、排序的好处 </strong></p>
<p>既然 TreeMap 的元素是经过排序的，那找出最大的那个，最小的那个，或者找出所有大于或者小于某个值的键来说，就方便多了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Integer highestKey = mapInt.lastKey();</span><br><span class="line">Integer lowestKey = mapInt.firstKey();</span><br><span class="line">Set&lt;Integer&gt; keysLessThan3 = mapInt.headMap(3).keySet();</span><br><span class="line">Set&lt;Integer&gt; keysGreaterThanEqTo3 = mapInt.tailMap(3).keySet();</span><br><span class="line">System.out.println(highestKey);</span><br><span class="line">System.out.println(lowestKey);</span><br><span class="line">System.out.println(keysLessThan3);</span><br><span class="line">System.out.println(keysGreaterThanEqTo3);</span><br></pre></td></tr></table></figure>
<p>TreeMap 考虑得很周全，恰好就提供了 lastKey() 、 firstKey() 这样获取最后一个 key 和第一个 key 的方法。</p>
<p>headMap() 获取的是到指定 key 之前的 key； tailMap() 获取的是指定 key 之后的 key（包括指定 key）。</p>
<p>来看一下输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1</span><br><span class="line">[1, 2]</span><br><span class="line">[3, 4, </span><br></pre></td></tr></table></figure>
<p>再来看一下例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">TreeMap&lt;Integer, String&gt; treeMap = new TreeMap&lt;&gt;();</span><br><span class="line">treeMap.put(1, &quot;value1&quot;);</span><br><span class="line">treeMap.put(2, &quot;value2&quot;);</span><br><span class="line">treeMap.put(3, &quot;value3&quot;);</span><br><span class="line">treeMap.put(4, &quot;value4&quot;);</span><br><span class="line">treeMap.put(5, &quot;value5&quot;);</span><br><span class="line">// headMap示例，获取小于3的键值对</span><br><span class="line">Map&lt;Integer, String&gt; headMap = treeMap.headMap(3);</span><br><span class="line">System.out.println(headMap); // 输出 &#123;1=value1, 2=value2&#125;</span><br><span class="line">// tailMap示例，获取大于等于4的键值对</span><br><span class="line">Map&lt;Integer, String&gt; tailMap = treeMap.tailMap(4);</span><br><span class="line">System.out.println(tailMap); // 输出 &#123;4=value4, 5=value5&#125;</span><br><span class="line">// subMap示例，获取大于等于2且小于4的键值对</span><br><span class="line">Map&lt;Integer, String&gt; subMap = treeMap.subMap(2, 4);</span><br><span class="line">System.out.println(subMap); // 输出 &#123;2=value2, 3=value3&#125;</span><br></pre></td></tr></table></figure>
<p>headMap、tailMap、subMap方法分别获取了小于3、大于等于4、大于等于2且小于4的键值对。</p>
<p><strong>04、如何选择 Map </strong></p>
<p>在学习 TreeMap 之前，我们已经学习了 HashMap 和 LinkedHashMap ，那如何从它们三个中间选择呢？</p>
<p>需要考虑以下因素：</p>
<ul>
<li>是否需要按照键的自然顺序或者自定义顺序进行排序。如果需要按照键排序，则可以使用 TreeMap；如果不需要排序，则可以使用 HashMap 或 LinkedHashMap。</li>
<li>是否需要保持插入顺序。如果需要保持插入顺序，则可以使用 LinkedHashMap；如果不需要保持插入顺序，则可以使用 TreeMap 或 HashMap。</li>
<li>是否需要高效的查找。如果需要高效的查找，则可以使用 LinkedHashMap 或 HashMap，因为它们的查找操作的时间复杂度为 O(1)，而是 TreeMap 是 O(log n)。</li>
<li>LinkedHashMap 内部使用哈希表来存储键值对，并使用一个双向链表来维护插入顺序，但查找操作只需要在哈希表中进行，与链表无关，所以时间复杂度为 O(1)</li>
</ul>
<p>来个表格吧，一目了然。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">特性</th>
<th style="text-align:center">TreeMap</th>
<th style="text-align:center">HashMap</th>
<th style="text-align:center">LinkedHashMap</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">排序</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">不支持</td>
<td style="text-align:center">不支持</td>
</tr>
<tr>
<td style="text-align:center">插入顺序</td>
<td style="text-align:center">不保证</td>
<td style="text-align:center">不保证</td>
<td style="text-align:center">保证</td>
</tr>
<tr>
<td style="text-align:center">查找效率</td>
<td style="text-align:center">O(log n)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">O(1)</td>
</tr>
<tr>
<td style="text-align:center">空间占用</td>
<td style="text-align:center">通常较大</td>
<td style="text-align:center">通常较小</td>
<td style="text-align:center">通常较大</td>
</tr>
<tr>
<td style="text-align:center">适用场景</td>
<td style="text-align:center">需要排序的场景</td>
<td style="text-align:center">无需排序的场景</td>
<td style="text-align:center">需要保持插入顺</td>
</tr>
</tbody>
</table>
</div>
<p>好了，下课，关于 TreeMap 我们就讲到这里吧，希望同学们都能对 TreeMap 有一个清晰的认识。我们下节课见~</p>
<h2 id="4-12-双端队列ArrayDeque详解"><a href="#4-12-双端队列ArrayDeque详解" class="headerlink" title="4.12 双端队列ArrayDeque详解"></a>4.12 双端队列ArrayDeque详解</h2><p>好，我们这节继续有请王老师上台来给大家讲 ArrayDeque，鼓掌欢迎了 。</p>
<p>Java 里有一个叫做Stack的类，却没有叫做Queue的类（它只是个接口名字，和类还不一样）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public interface Queue&lt;E&gt; extends Collection&lt;E&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>当需要使用栈时，Java 已不推荐使用Stack，而是推荐使用更高效的ArrayDeque（双端队列），原因我们第一次讲集合框架的时候，其实已经聊过了，Stack 是一个“原始”类，它的核心方法上都加了 synchronized 关键字以确保线程安全，当我们不需要线程安全（比如说单线程环境下）性能就会比较差。</p>
<p><img src="\assets\note\image-20231010160805462.png" alt="image-20231010160805462"></p>
<p>也就是说，当需要使用栈时候，请首选ArrayDeque。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 声明一个双端队列</span><br><span class="line">ArrayDeque&lt;String&gt; stack = new ArrayDeque&lt;&gt;();</span><br><span class="line">// 增加元素</span><br><span class="line">stack.push(&quot;沉默&quot;);</span><br><span class="line">stack.push(&quot;王二&quot;);</span><br><span class="line">stack.push(&quot;陈清扬&quot;);</span><br><span class="line">// 获取栈顶元素</span><br><span class="line">String top = stack.peek();</span><br><span class="line">System.out.println(&quot;栈顶元素为：&quot; + top); // 陈清扬</span><br><span class="line">// 弹出栈顶元素</span><br><span class="line">String pop = stack.pop();</span><br><span class="line">System.out.println(&quot;弹出的元素为：&quot; + pop); // 陈清扬</span><br><span class="line">// 修改栈顶元素</span><br><span class="line">stack.pop();</span><br><span class="line">stack.push(&quot;小明&quot;);</span><br><span class="line">System.out.println(&quot;修改后的栈为：&quot; + stack); // [沉默, 小明]</span><br><span class="line">// 遍历队列查找元素</span><br><span class="line">Iterator&lt;String&gt; iterator = stack.iterator();</span><br><span class="line">int index = -1;</span><br><span class="line">String target = &quot;王二&quot;;</span><br><span class="line">while (iterator.hasNext()) &#123;</span><br><span class="line">    String element = iterator.next();</span><br><span class="line">    index++;</span><br><span class="line">    if (element.equals(target)) &#123;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">if (index == -1) &#123;</span><br><span class="line">    System.out.println(&quot;元素 &quot; + target + &quot; 不存在于队列中&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    System.out.println(&quot;元素 &quot; + target + &quot; 在队列中的位置为：&quot; + index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们先创建了一个 ArrayDeque 对象，然后使用 push 方法向栈中添加了三个元素。接着使用 peek 方法获取栈顶元素，使用 pop 方法弹出栈顶元素，使用 pop 和 push 方法修改栈顶元素，使用迭代器查找元素在栈中的位置。</p>
<p>ArrayDeque 又实现了 Deque 接口（Deque 又实现了 Queue 接口）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayDeque&lt;E&gt; extends AbstractCollection&lt;E&gt;</span><br><span class="line">                           implements Deque&lt;E&gt;, Cloneable, Serializable</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>因此，当我们需要使用队列的时候，也可以选择 ArrayDeque。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ArrayDeque&lt;String&gt; queue = new ArrayDeque&lt;&gt;();</span><br><span class="line">// 增加元素</span><br><span class="line">queue.offer(&quot;沉默&quot;);</span><br><span class="line">queue.offer(&quot;王二&quot;);</span><br><span class="line">queue.offer(&quot;陈清扬&quot;);</span><br><span class="line">// 获取队首元素</span><br><span class="line">String front = queue.peek();</span><br><span class="line">System.out.println(&quot;队首元素为：&quot; + front); // 沉默</span><br><span class="line">// 弹出队首元素</span><br><span class="line">String poll = queue.poll();</span><br><span class="line">System.out.println(&quot;弹出的元素为：&quot; + poll); // 沉默</span><br><span class="line">// 修改队列中的元素</span><br><span class="line">queue.poll();</span><br><span class="line">queue.offer(&quot;小明&quot;);</span><br><span class="line">System.out.println(&quot;修改后的队列为：&quot; + queue); // [陈清扬, 小明]</span><br><span class="line">// 查找元素</span><br><span class="line">Iterator&lt;String&gt; iterator = queue.iterator();</span><br><span class="line">int index = 0;</span><br><span class="line">while (iterator.hasNext()) &#123;</span><br><span class="line">    String element = iterator.next();</span><br><span class="line">    if (element.equals(&quot;王二&quot;)) &#123;</span><br><span class="line">        System.out.println(&quot;元素在队列中的位置为：&quot; + index); // 0</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    index++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们先创建了一个 ArrayDeque 对象，然后使用 offer 方法向队列中添加了三个元素。接着使用 peek 方法获取队首元素，使用 poll 方法弹出队首元素，使用 poll 和 offer 方法修改队列中的元素，使用迭代器查找元素在队列中的位置。</p>
<p>我们前面讲了，LinkedList不只是个 List，还是一个 Queue，它也实现了 Deque 接口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedList&lt;E&gt;</span><br><span class="line">    extends AbstractSequentialList&lt;E&gt;</span><br><span class="line">    implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>所以，当我们需要使用队列时，还可以选择LinkedList。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 LinkedList 对象</span><br><span class="line">LinkedList&lt;String&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">// 添加元素</span><br><span class="line">queue.offer(&quot;沉默&quot;);</span><br><span class="line">queue.offer(&quot;王二&quot;);</span><br><span class="line">queue.offer(&quot;陈清扬&quot;);</span><br><span class="line">System.out.println(queue); // 输出 [沉默, 王二, 陈清扬]</span><br><span class="line">// 删除元素</span><br><span class="line">queue.poll();</span><br><span class="line">System.out.println(queue); // 输出 [王二, 陈清扬]</span><br><span class="line">// 修改元素：LinkedList 中的元素不支持直接修改，需要先删除再添加</span><br><span class="line">String first = queue.poll();</span><br><span class="line">queue.offer(&quot;王大二&quot;);</span><br><span class="line">System.out.println(queue); // 输出 [陈清扬, 王大二]</span><br><span class="line">// 查找元素：LinkedList 中的元素可以使用 get() 方法进行查找</span><br><span class="line">System.out.println(queue.get(0)); // 输出 陈清扬</span><br><span class="line">System.out.println(queue.contains(&quot;沉默&quot;)); // 输出 false</span><br><span class="line">// 查找元素：使用迭代器的方式查找陈清扬</span><br><span class="line">// 使用迭代器依次遍历元素并查找</span><br><span class="line">Iterator&lt;String&gt; iterator = queue.iterator();</span><br><span class="line">while (iterator.hasNext()) &#123;</span><br><span class="line">    String element = iterator.next();</span><br><span class="line">    if (element.equals(&quot;陈清扬&quot;)) &#123;</span><br><span class="line">        System.out.println(&quot;找到了：&quot; + element);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用 LinkedList 作为队列时，可以使用 offer() 方法将元素添加到队列的末尾，使用 poll() 方法从队列的头部删除元素，使用迭代器或者 poll() 方法依次遍历元素。</p>
<p><strong>栈和队列 </strong></p>
<p>要讲栈和队列，首先要讲Deque接口。Deque的含义是“double ended queue”，即双端队列，它既可以当作栈使用，也可以当作队列使用。下表列出了Deque与Queue相对应的接口：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Queue Method</th>
<th style="text-align:center">Equivalent Deque Method</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">add(e)</td>
<td style="text-align:center">addLast(e)</td>
<td style="text-align:center">向队尾插入元素，失败则抛出异常</td>
</tr>
<tr>
<td style="text-align:center">offer(e)</td>
<td style="text-align:center">offerLast(e)</td>
<td style="text-align:center">向队尾插入元素，失败则返回 false</td>
</tr>
<tr>
<td style="text-align:center">remove()</td>
<td style="text-align:center">removeFirst()</td>
<td style="text-align:center">获取并删除队首元素，失败则抛出异常</td>
</tr>
<tr>
<td style="text-align:center">poll()</td>
<td style="text-align:center">pollFirst()</td>
<td style="text-align:center">获取并删除队首元素，失败则返回 null</td>
</tr>
<tr>
<td style="text-align:center">element()</td>
<td style="text-align:center">getFirst()</td>
<td style="text-align:center">获取但不删除队首元素，失败则抛出异常</td>
</tr>
<tr>
<td style="text-align:center">peek()</td>
<td style="text-align:center">peekFirst()</td>
<td style="text-align:center">获取但不删除队首元素，失败则返回 null</td>
</tr>
</tbody>
</table>
</div>
<p>下表列出了Deque与Stack对应的接口：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Stack Method</th>
<th style="text-align:center">Equivalent Deque Method</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">push(e)</td>
<td style="text-align:center">addFirst(e)</td>
<td style="text-align:center">向栈顶插入元素，失败则抛出异常</td>
</tr>
<tr>
<td style="text-align:center">无</td>
<td style="text-align:center">offerFirst(e)</td>
<td style="text-align:center">向栈顶插入元素，失败则返回 false</td>
</tr>
<tr>
<td style="text-align:center">pop()</td>
<td style="text-align:center">removeFirst()</td>
<td style="text-align:center">获取并删除栈顶元素，失败则抛出异常</td>
</tr>
<tr>
<td style="text-align:center">无</td>
<td style="text-align:center">pollFirst()</td>
<td style="text-align:center">获取并删除栈顶元素，失败则返回 null</td>
</tr>
<tr>
<td style="text-align:center">peek()</td>
<td style="text-align:center">getFirst()</td>
<td style="text-align:center">获取但不删除栈顶元素，失败则抛出异常</td>
</tr>
<tr>
<td style="text-align:center">无</td>
<td style="text-align:center">peekFirst()</td>
<td style="text-align:center">获取但不删除栈顶元素，失败则返回 null</td>
</tr>
</tbody>
</table>
</div>
<p>上面两个表共定义了Deque的 12 个接口。</p>
<p>添加，删除，取值都有两套接口，它们功能相同，区别是对失败情况的处理不同。</p>
<p><strong>一套接口遇到失败就会抛出异常，另一套遇到失败会返回特殊值（ 或 ）</strong>。除非某种实现对容量有限制，大多数情况下，添加操作是不会失败的。</p>
<p><strong>虽然Deque的接口有 12 个之多，但无非就是对容器的两端进行操作，或添加，或删除，或查看</strong>。明白了这一点讲解起来就会非常简单。</p>
<p>ArrayDeque和LinkedList是Deque的两个通用实现，由于官方更推荐使用ArrayDeque用作栈和队列，加之上一篇已经讲解过LinkedList，本文将着重讲解ArrayDeque的具体实现。</p>
<p>从名字可以看出ArrayDeque底层通过数组实现，为了满足可以同时在数组两端插入或删除元素的需求，该数组还必须是循环的，即循环数组（circular array），也就是说数组的任何一点都可能被看作起点或者终点。</p>
<p><strong>ArrayDeque是非线程安全的</strong>（not thread-safe），当多个线程同时使用的时候，需要手动同步；另外，该容器不允许放入 null元素。</p>
<p><img src="\assets\note\image-20231010161808695.png" alt="image-20231010161808695"></p>
<p>上图中我们看到， <strong>head指向首端第一个有效元素， tail指向尾端第一个可以插入元素的空位</strong>。因为是循环数组，所以 head不一定总等于 0， tail也不一定总是比 head大。</p>
<p><strong>方法剖析 </strong></p>
<p><strong>addFirst() </strong></p>
<p>addFirst(E e)的作用是在Deque的首端插入元素，也就是在 head的前面插入元素，在空间足够且下标没有越界的情况下，只需要将 elements[—head] = e即可。</p>
<p><img src="\assets\note\image-20231010161947212.png" alt="image-20231010161947212"></p>
<p>实际需要考虑：</p>
<ol>
<li>空间是否够用，以及 </li>
<li>下标是否越界的问题。</li>
</ol>
<p>上图中，如果 head为 0之后接着调用 addFirst() ，虽然空余空间还够用，但 head为 -1 ，下标越界了。</p>
<p>下列代码很好的解决了这两个问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//addFirst(E e)</span><br><span class="line">public void addFirst(E e) &#123;</span><br><span class="line">    if (e == null)//不允许放入null</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    elements[head = (head - 1) &amp; (elements.length - 1)] = e;//2.下标是否越界</span><br><span class="line">    if (head == tail)//1.空间是否够用</span><br><span class="line">        doubleCapacity();//扩容</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码我们看到，<strong>空间问题是在插入之后解决的</strong>，因为 tail总是指向下一个可插入的空位，也就意味着elements数组至少有一个空位，所以插入元素的时候不用考虑空间问题。</p>
<p>下标越界的处理解决起来非常简单， head = (head - 1) &amp; (elements.length - 1)就可以了，<strong>这段代码相当于取余，同时解决了 head为负值的情况</strong>。因为 elements.length必需是 2的指数倍， elements - 1就是二进制低位全 1 ，跟 head - 1相与之后就起到了取模的作用，如果 head - 1为负数（其实只可能是-1），则相当于对其取相对于 elements.length的补码。</p>
<p>下面再说说扩容函数 doubleCapacity() ，其逻辑是申请一个更大的数组（原数组的两倍），然后将原数组复制过去。过程如下图所示：</p>
<p><img src="\assets\note\image-20231010162150336.png" alt="image-20231010162150336"></p>
<p>图中我们看到，复制分两次进行，第一次复制 head右边的元素，第二次复制 head左边的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//doubleCapacity()</span><br><span class="line">private void doubleCapacity() &#123;</span><br><span class="line">    assert head == tail;</span><br><span class="line">    int p = head;</span><br><span class="line">    int n = elements.length;</span><br><span class="line">    int r = n - p; // head右边元素的个数</span><br><span class="line">    int newCapacity = n &lt;&lt; 1;//原空间的2倍</span><br><span class="line">    if (newCapacity &lt; 0)</span><br><span class="line">        throw new IllegalStateException(&quot;Sorry, deque too big&quot;);</span><br><span class="line">    Object[] a = new Object[newCapacity];</span><br><span class="line">    System.arraycopy(elements, p, a, 0, r);//复制右半部分，对应上图中绿色部分</span><br><span class="line">    System.arraycopy(elements, 0, a, r, p);//复制左半部分，对应上图中灰色部分</span><br><span class="line">    elements = (E[])a;</span><br><span class="line">    head = 0;</span><br><span class="line">    tail = n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法的实现中，首先检查 head 和 tail 是否相等，如果不相等则抛出异常。然后计算出 head 右边的元素个数 r，以及新的容量 newCapacity，如果 newCapacity 太大则抛出异常。</p>
<p>接下来创建一个新的 Object 数组 a，将原有 ArrayDeque 中 head 右边的元素复制到 a 的前面（即图中绿色部分），将 head 左边的元素复制到 a 的后面（即图中灰色部分）。最后将 elements 数组替换为 a，head 设置为 0，tail 设置为 n（即新容量的长度）。</p>
<p>需要注意的是，由于 elements 数组被替换为 a 数组，因此在方法调用结束后，原有的 elements 数组将不再被引用，会被垃圾回收器回收。</p>
<p><strong>addLast() </strong></p>
<p>addLast(E e)的作用是在Deque的尾端插入元素，也就是在 tail的位置插入元素，由于 tail总是指向下一个可以插入的空位，因此只需要 elements[tail] = e;即可。插入完成后再检查空间，如果空间已经用光，则调用 doubleCapacity()进行扩容。</p>
<p><img src="\assets\note\image-20231010162257399.png" alt="image-20231010162257399"></p>
<p>下标越界处理方式 addFirt()中已经讲过，不再赘述。</p>
<p><strong>pollFirst() </strong></p>
<p>pollFirst()的作用是删除并返回Deque首端元素，也即是 head位置处的元素。如果容器不空，只需要直接返回 elements[head]即可，当然还需要处理下标的问题。由于 ArrayDeque中不允许放入 null ，当elements[head] == null时，意味着容器为空。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public E pollFirst() &#123;</span><br><span class="line">    E result = elements[head];</span><br><span class="line">    if (result == null)//null值意味着deque为空</span><br><span class="line">        return null;</span><br><span class="line">    elements[h] = null;//let GC work</span><br><span class="line">    head = (head + 1) &amp; (elements.length - 1);//下标越界处理</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>pollLast() </strong></p>
<p>pollLast()的作用是删除并返回Deque尾端元素，也即是 tail位置前面的那个元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public E pollLast() &#123;</span><br><span class="line">    int t = (tail - 1) &amp; (elements.length - 1);//tail的上一个位置是最后一个元素</span><br><span class="line">    E result = elements[t];</span><br><span class="line">    if (result == null)//null值意味着deque为空</span><br><span class="line">        return null;</span><br><span class="line">    elements[t] = null;//let GC work</span><br><span class="line">    tail = t;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>peekFirst() </strong></p>
<p>peekFirst()的作用是返回但不删除Deque首端元素，也即是 head位置处的元素，直接返回elements[head]即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public E peekFirst() &#123;</span><br><span class="line">    return elements[head]; // elements[head] is null if deque empty</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>peekLast() </strong></p>
<p>peekLast()的作用是返回但不删除Deque尾端元素，也即是 tail位置前面的那个元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public E peekLast() &#123;</span><br><span class="line">    return elements[(tail - 1) &amp; (elements.length - 1)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>小结 </strong></p>
<p>当需要实现先进先出(FIFO)或者先进后出(LIFO)的数据结构时，可以考虑使用 ArrayDeque。以下是一些使用 ArrayDeque 的场景：</p>
<ul>
<li>管理任务队列：如果需要实现一个任务队列，可以使用 ArrayDeque 来存储任务元素。在队列头部添加新任务元素，从队列尾部取出任务进行处理，可以保证任务按照先进先出的顺序执行。</li>
<li>实现栈：ArrayDeque 可以作为栈的实现方式，支持 push、pop、peek 等操作，可以用于需要后进先出的场景。</li>
<li>实现缓存：在需要缓存一定数量的数据时，可以使用 ArrayDeque。当缓存的数据量超过容量时，可以从队列头部删除最老的数据，从队列尾部添加新的数据。</li>
<li>实现事件处理器：ArrayDeque 可以作为事件处理器的实现方式，支持从队列头部获取事件进行处理，从队列尾部添加新的事件。</li>
</ul>
<p>简单总结一下吧。</p>
<p>ArrayDeque 是 Java 标准库中的一种双端队列实现，底层基于数组实现。与 LinkedList 相比，ArrayDeque 的性能更优，因为它使用连续的内存空间存储元素，可以更好地利用 CPU 缓存，在大多数情况下也更快。</p>
<p>为什么这么说呢？</p>
<p>因为ArrayDeque 的底层实现是数组，而 LinkedList 的底层实现是链表。数组是一段连续的内存空间，而链表是由多个节点组成的，每个节点存储数据和指向下一个节点的指针。因此，在使用 LinkedList 时，需要频繁进行内存分配和释放，而 ArrayDeque 在创建时就一次性分配了连续的内存空间，不需要频繁进行内存分配和释放，这样可以更好地利用 CPU 缓存，提高访问效率。</p>
<p>现代计算机CPU对于数据的局部性有很强的依赖，如果需要访问的数据在内存中是连续存储的，那么就可以利用CPU的缓存机制，提高访问效率。而当数据存储在不同的内存块里时，每次访问都需要从内存中读取，效率会受到影响。</p>
<p>当然了，使用 ArrayDeque 时，数组复制操作也是需要考虑的性能消耗之一。</p>
<p>当 ArrayDeque 的元素数量超过了初始容量时，会触发扩容操作。扩容操作会创建一个新的数组，并将原有元素复制到新数组中。扩容操作的时间复杂度为 O(n)。</p>
<p>不过，ArrayDeque 的扩容策略（当 ArrayDeque 中的元素数量达到数组容量时，就需要进行扩容操作，扩容时会将数组容量扩大为原来的两倍）可以在一定程度上减少数组复制的次数和时间消耗，同时保证 ArrayDeque 的性能和空间利用率。</p>
<p>ArrayDeque 不仅支持常见的队列操作，如添加元素、删除元素、获取队列头部元素、获取队列尾部元素等。同时，它还支持栈操作，如 push、pop、peek 等。这使得 ArrayDeque 成为一种非常灵活的数据结构，可以用于各种场景的数据存储和处理。</p>
<h2 id="4-13-优先级队列PriorityQueue详解"><a href="#4-13-优先级队列PriorityQueue详解" class="headerlink" title="4.13 优先级队列PriorityQueue详解"></a>4.13 优先级队列PriorityQueue详解</h2><p>继续有请王老师，来上台给大家讲讲优先级队列 PriorityQueue。</p>
<p>PriorityQueue 是 Java 中的一个基于优先级堆的优先队列实现，它能够在 O(log n) 的时间复杂度内实现元素的插入和删除操作，并且能够自动维护队列中元素的优先级顺序。</p>
<p>通俗来说，PriorityQueue 就是一个队列，但是它不是先进先出的，而是按照元素优先级进行排序的。当你往 PriorityQueue 中插入一个元素时，它会自动根据元素的优先级将其插入到合适的位置。当你从 PriorityQueue 中删除一个元素时，它会自动将优先级最高的元素出队。</p>
<p>下面 是一个简单的PriorityQueue示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 创建 PriorityQueue 对象</span><br><span class="line">PriorityQueue&lt;String&gt; priorityQueue = new PriorityQueue&lt;&gt;();</span><br><span class="line">// 添加元素到 PriorityQueue</span><br><span class="line">priorityQueue.offer(&quot;沉默王二&quot;);</span><br><span class="line">priorityQueue.offer(&quot;陈清扬&quot;);</span><br><span class="line">priorityQueue.offer(&quot;小转铃&quot;);</span><br><span class="line">// 打印 PriorityQueue 中的元素</span><br><span class="line">System.out.println(&quot;PriorityQueue 中的元素：&quot;);</span><br><span class="line">while (!priorityQueue.isEmpty()) &#123;</span><br><span class="line">    System.out.print(priorityQueue.poll() + &quot; &quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，我们首先创建了一个 PriorityQueue 对象，并向其中添加了三个元素。然后，我们使用 while 循环遍历 PriorityQueue 中的元素，并打印出来。来看输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue 中的元素：</span><br><span class="line">小转铃 沉默王二 陈清扬 </span><br></pre></td></tr></table></figure>
<p>再来看一下示例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 创建 PriorityQueue 对象，并指定优先级顺序</span><br><span class="line">PriorityQueue&lt;String&gt; priorityQueue = new PriorityQueue&lt;&gt;</span><br><span class="line">(Comparator.reverseOrder());</span><br><span class="line">// 添加元素到 PriorityQueue</span><br><span class="line">priorityQueue.offer(&quot;沉默王二&quot;);</span><br><span class="line">priorityQueue.offer(&quot;陈清扬&quot;);</span><br><span class="line">priorityQueue.offer(&quot;小转铃&quot;);</span><br><span class="line">// 打印 PriorityQueue 中的元素</span><br><span class="line">System.out.println(&quot;PriorityQueue 中的元素：&quot;);</span><br><span class="line">while (!priorityQueue.isEmpty()) &#123;</span><br><span class="line">    System.out.print(priorityQueue.poll() + &quot; &quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，我们使用了 Comparator.reverseOrder() 方法指定了 PriorityQueue 的优先级顺序为降序。</p>
<p>也就是说，PriorityQueue 中的元素会按照从大到小的顺序排序。</p>
<p>其他部分的代码与之前的例子相同，我们再来看一下输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue 中的元素：</span><br><span class="line">陈清扬 沉默王二 小转铃</span><br></pre></td></tr></table></figure>
<p>对比一下两个例子的输出结果，不难发现，顺序正好相反。</p>
<p><strong>PriorityQueue的作用 </strong></p>
<p>PriorityQueue 的主要作用是维护一组数据的排序，使得取出数据时可以按照一定的优先级顺序进行，当我们调用 poll() 方法时，它会从队列的顶部弹出最高优先级的元素。它在很多场景下都有广泛的应用，例如任务调度、事件处理等场景，以及一些算法中需要对数据进行排序的场景。</p>
<p>在实际应用中，PriorityQueue 也经常用于实现 Dijkstra 算法、Prim 算法、Huffman 编码等算法。这里简单说一下这几种算法的作用，理解不了也没关系哈。</p>
<p>Dijkstra算法是一种用于计算带权图中的最短路径的算法。该算法采用贪心的策略，在遍历图的过程中，每次选取当前到源点距离最短的一个顶点，并以它为中心进行扩展，更新其他顶点的距离值。经过多次扩展，可以得到源点到其它所有顶点的最短路径。</p>
<p>Prim算法是一种用于求解最小生成树的算法，可以在加权连通图中找到一棵生成树，使得这棵生成树的所有边的权值之和最小。该算法从任意一个顶点开始，逐渐扩展生成树的规模，每次选择一个距离已生成树最近的顶点加入到生成树中。</p>
<p>Huffman编码是一种基于霍夫曼树的压缩算法，用于将一个字符串转换为二进制编码以进行压缩。该算法的主要思想是通过建立霍夫曼树，将出现频率较高的字符用较短的编码表示，而出现频率较低的字符用较长的编码表示，从而实现对字符串的压缩。在解压缩时，根据编码逐步解析出原字符串。</p>
<p>由于 PriorityQueue 的底层是基于堆实现的，因此在数据量比较大时，使用 PriorityQueue 可以获得较好的时间复杂度。</p>
<p>这里牵涉到了大小关系，<strong>元素大小的评判可以通过元素本身的自然顺序（natural ordering），也可以通过构造时传入的比较器（Comparator，或者元素自身实现 Comparable 接口）来决定。</strong></p>
<p>在 PriorityQueue 中，每个元素都有一个优先级，这个优先级决定了元素在队列中的位置。队列内部通过小顶堆（也可以是大顶堆）的方式来维护元素的优先级关系。具体来说，小顶堆是一个完全二叉树，任何一个非叶子节点的权值，都不大于其左右子节点的权值，这样保证了队列的顶部元素（堆顶）一定是优先级最高的元素。</p>
<p>完全二叉树（Complete Binary Tree）是一种二叉树，其中除了最后一层，其他层的节点数都是满的，最后<br>一层的节点都靠左对齐。下面是一个完全二叉树的示意图：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     1</span><br><span class="line">   /   \</span><br><span class="line">  2     3</span><br><span class="line"> / \   /</span><br><span class="line">4   5 6</span><br></pre></td></tr></table></figure>
<p>堆是一种完全二叉树，堆的特点是根节点的值最小（小顶堆）或最大（大顶堆），并且任意非根节点i的值都不大于（或不小于）其父节点的值。</p>
<p>这是一颗包含整数 1, 2, 3, 4, 5, 6, 7 的小顶堆：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \ / \</span><br><span class="line">4  5 6  7</span><br></pre></td></tr></table></figure>
<p>这是一颗大顶堆。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     8</span><br><span class="line">   /   \</span><br><span class="line">  7     5</span><br><span class="line"> / \   / \</span><br><span class="line">6   4 2   1</span><br></pre></td></tr></table></figure>
<p>因为完全二叉树的结构比较规则，所以可以使用数组来存储堆的元素，而不需要使用指针等额外的空间。</p>
<p>在堆中，每个节点的下标和其在数组中的下标是一一对应的，假设节点下标为i，则其父节点下标为i/2，其左子节点下标为2i，其右子节点下标为2i+1。</p>
<p>假设有一个数组arr=[10, 20, 15, 30, 40]，现在要将其转化为一个小顶堆。</p>
<p>首先，我们将数组按照完全二叉树的形式排列，如下图所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">      10</span><br><span class="line">     /  \</span><br><span class="line">   20    15</span><br><span class="line">  /  \</span><br><span class="line">30   40</span><br></pre></td></tr></table></figure>
<p>从上往下、从左往右依次给每个节点编号，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \</span><br><span class="line">4   5</span><br></pre></td></tr></table></figure>
<p>接下来，我们按照上述公式，依次确定每个节点在数组中的位置。例如，节点1的父节点下标为1/2=0，左子节点下标为2<em>1=2，右子节点下标为2</em>1+1=3，因此节点1在数组中的位置为0，节点2在数组中的位置为2，节点3在数组中的位置为3。</p>
<p>对应的数组为[10, 20, 15, 30, 40]，符合小顶堆的定义，即每个节点的值都小于或等于其子节点的值。</p>
<p>好，我们画幅图再来理解一下。</p>
<p><img src="\assets\note\image-20231010163222552.png" alt="image-20231010163222552"></p>
<p>上图中我们给每个元素按照层序遍历的方式进行了编号，如果你足够细心，会发现父节点和子节点的编号是有联系的，更确切的说父子节点的编号之间有如下关系：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">leftNo = parentNo\*2+1</span><br><span class="line">rightNo = parentNo\*2+2</span><br><span class="line">parentNo = (nodeNo-1)/2</span><br></pre></td></tr></table></figure>
<p>通过上述三个公式，可以轻易计算出某个节点的父节点以及子节点的下标。这也就是为什么可以直接用数组来存储堆的原因。</p>
<p><strong>方法剖析 </strong></p>
<p><strong>add()和 offer() </strong></p>
<p>add(E e)和 offer(E e)的语义相同，都是向优先队列中插入元素，只是 Queue接口规定二者对插入失败时的处理不同，前者在插入失败时抛出异常，后则则会返回 false 。对于PriorityQueue这两个方法其实没什么差别。</p>
<p><img src="\assets\note\image-20231010163320807.png" alt="image-20231010163320807"></p>
<p>新加入的元素可能会破坏小顶堆的性质，因此需要进行必要的调整。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//offer(E e)</span><br><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">    if (e == null)//不允许放入null元素</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    modCount++;</span><br><span class="line">    int i = size;</span><br><span class="line">    if (i &gt;= queue.length)</span><br><span class="line">        grow(i + 1);//自动扩容</span><br><span class="line">    size = i + 1;</span><br><span class="line">    if (i == 0)//队列原来为空，这是插入的第一个元素</span><br><span class="line">        queue[0] = e;</span><br><span class="line">    else</span><br><span class="line">        siftUp(i, e);//调整</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中，扩容函数 grow()类似于 ArrayList里的 grow()函数，就是再申请一个更大的数组，并将原数组的元素复制过去，这里不再赘述。需要注意的是 siftUp(int k, E x)方法，该方法用于插入元素 x并维持堆的特性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//siftUp()</span><br><span class="line">private void siftUp(int k, E x) &#123;</span><br><span class="line">    while (k &gt; 0) &#123;</span><br><span class="line">        int parent = (k - 1) &gt;&gt;&gt; 1;//parentNo = (nodeNo-1)/2</span><br><span class="line">        Object e = queue[parent];</span><br><span class="line">        if (comparator.compare(x, (E) e) &gt;= 0)//调用比较器的比较方法</span><br><span class="line">            break;</span><br><span class="line">        queue[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调整的过程为：<strong>从k指定的位置开始，将x逐层与当前点的parent进行比较并交换，直到满足x &gt;= queue[parent]为止</strong>。注意这里的比较可以是元素的自然顺序，也可以是依靠比较器的顺序。</p>
<p><strong>element()和 peek() </strong></p>
<p>element()和 peek()的语义完全相同，都是获取但不删除队首元素，也就是队列中权值最小的那个元素，二者唯一的区别是当方法失败时前者抛出异常，后者返回 null 。根据小顶堆的性质，堆顶那个元素就是全局最小的那个；由于堆用数组表示，根据下标关系， 0下标处的那个元素既是堆顶元素。所以<strong>直接返回数组0下标处的那个元素即可。</strong></p>
<p><img src="\assets\note\image-20231010163540087.png" alt="image-20231010163540087"></p>
<p>代码也就非常简洁：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//peek()</span><br><span class="line">public E peek() &#123;</span><br><span class="line">    if (size == 0)</span><br><span class="line">        return null;</span><br><span class="line">    return (E) queue[0];//0下标处的那个元素就是最小的那个</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>remove()和 poll() </strong></p>
<p>remove()和 poll()方法的语义也完全相同，都是获取并删除队首元素，区别是当方法失败时前者抛出异常，后者返回 null 。由于删除操作会改变队列的结构，为维护小顶堆的性质，需要进行必要的调整。</p>
<p><img src="\assets\note\image-20231010163619147.png" alt="image-20231010163619147"></p>
<p>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public E poll() &#123;</span><br><span class="line">    if (size == 0)</span><br><span class="line">        return null;</span><br><span class="line">    int s = --size;</span><br><span class="line">    modCount++;</span><br><span class="line">    E result = (E) queue[0];//0下标处的那个元素就是最小的那个</span><br><span class="line">    E x = (E) queue[s];</span><br><span class="line">    queue[s] = null;</span><br><span class="line">    if (s != 0)</span><br><span class="line">        siftDown(0, x);//调整</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码首先记录 0下标处的元素，并用最后一个元素替换 0下标位置的元素，之后调用 siftDown()方法对堆进行调整，最后返回原来 0下标处的那个元素（也就是最小的那个元素）。重点是 siftDown(int k, E x)方法，该方法的作用是<strong>从 k指定的位置开始，将 x逐层向下与当前点的左右孩子中较小的那个交换，直到 小于或等于左右孩子中的任何一个为止。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//siftDown()</span><br><span class="line">private void siftDown(int k, E x) &#123;</span><br><span class="line">    int half = size &gt;&gt;&gt; 1;</span><br><span class="line">    while (k &lt; half) &#123;</span><br><span class="line">      //首先找到左右孩子中较小的那个，记录到c里，并用child记录其下标</span><br><span class="line">        int child = (k &lt;&lt; 1) + 1;//leftNo = parentNo*2+1</span><br><span class="line">        Object c = queue[child];</span><br><span class="line">        int right = child + 1;</span><br><span class="line">        if (right &lt; size &amp;&amp;</span><br><span class="line">            comparator.compare((E) c, (E) queue[right]) &gt; 0)</span><br><span class="line">            c = queue[child = right];</span><br><span class="line">        if (comparator.compare(x, (E) c) &lt;= 0)</span><br><span class="line">            break;</span><br><span class="line">        queue[k] = c;//然后用c取代原来的值</span><br><span class="line">        k = child;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>remove(Object o) </strong></p>
<p>remove(Object o)方法用于删除队列中跟 o相等的某一个元素（如果有多个相等，只删除一个），该方法不是Queue接口内的方法，而是Collection接口的方法。由于删除操作会改变队列结构，所以要进行调整；又由于删除元素的位置可能是任意的，所以调整过程比其它方法稍加繁琐。</p>
<p>具体来说， remove(Object o)可以分为 2 种情况：</p>
<ol>
<li>删除的是最后一个元素。直接删除即可，不需要调整。</li>
<li>删除的不是最后一个元素，从删除点开始以最后一个元素为参照调用一次 siftDown()即可。此处不再赘述。</li>
</ol>
<p><img src="\assets\note\image-20231010163808582.png" alt="image-20231010163808582"></p>
<p>具体代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//remove(Object o)</span><br><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">  //通过遍历数组的方式找到第一个满足o.equals(queue[i])元素的下标</span><br><span class="line">    int i = indexOf(o);</span><br><span class="line">    if (i == -1)</span><br><span class="line">        return false;</span><br><span class="line">    int s = --size;</span><br><span class="line">    if (s == i) //情况1</span><br><span class="line">        queue[i] = null;</span><br><span class="line">    else &#123;</span><br><span class="line">        E moved = (E) queue[s];</span><br><span class="line">        queue[s] = null;</span><br><span class="line">        siftDown(i, moved);//情况2</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>小结 </strong></p>
<p>PriorityQueue 是一个非常常用的数据结构，它是一种特殊的堆（Heap）实现，可以用来高效地维护一个有序的集合。</p>
<ul>
<li>它的底层实现是一个数组，通过堆的性质来维护元素的顺序。</li>
<li>取出元素时按照优先级顺序（从小到大或者从大到小）进行取出。</li>
<li>如果需要指定排序，元素必须实现 Comparable 接口或者传入一个 Comparator 来进行比较。</li>
</ul>
<h2 id="4-14-Comparable和Comparator的区别"><a href="#4-14-Comparable和Comparator的区别" class="headerlink" title="4.14 Comparable和Comparator的区别"></a>4.14 Comparable和Comparator的区别</h2><p>在前面学习优先级队列的时候，我们曾提到过 Comparable和Comparator，那这篇继续以面试官的角度去切入，一起来看。</p>
<p>那天，小二去马蜂窝面试，面试官老王一上来就甩给了他一道面试题：请问Comparable和Comparator有什么区别？小二差点笑出声，因为他在《Java进阶之路》上看到过这题 。</p>
<p>Comparable 和 Comparator 是 Java 的两个接口，从名字上我们就能够读出来它们俩的相似性：以某种方式来比较两个对象。<br>但它们之间到底有什么区别呢？请随我来，打怪进阶喽！</p>
<p><strong>01、Comparable </strong></p>
<p>Comparable 接口的定义非常简单，源码如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Comparable&lt;T&gt; &#123;</span><br><span class="line">    int compareTo(T t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果一个类实现了 Comparable 接口（只需要干一件事，重写 compareTo() 方法），就可以按照自己制定的规则将由它创建的对象进行比较。下面给出一个例子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Cmower implements Comparable&lt;Cmower&gt; &#123;</span><br><span class="line">    private int age;</span><br><span class="line">    private String name;</span><br><span class="line">    public Cmower(int age, String name) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(Cmower o) &#123;</span><br><span class="line">        return this.getAge() - o.getAge();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Cmower wanger = new Cmower(19,&quot;沉默王二&quot;);</span><br><span class="line">        Cmower wangsan = new Cmower(16,&quot;沉默王三&quot;);</span><br><span class="line">        if (wanger.compareTo(wangsan) &lt; 0) &#123;</span><br><span class="line">            System.out.println(wanger.getName() + &quot;比较年轻有为&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(wangsan.getName() + &quot;比较年轻有为&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我创建了一个 Cmower 类，它有两个字段：age 和 name。Cmower 类实现了 Comparable 接口，并重写了 compareTo() 方法。</p>
<p>程序输出的结果是“沉默王三比较年轻有为”，因为他比沉默王二小三岁。这个结果有什么凭证吗？</p>
<p>凭证就在于 compareTo() 方法，该方法的返回值可能为负数，零或者正数，代表的意思是该对象按照排序的规则小于、等于或者大于要比较的对象。如果指定对象的类型与此对象不能进行比较，则引发 ClassCastException 异常（自从有了泛型，这种情况就少有发生了）。</p>
<p><strong>02、Comparator </strong></p>
<p>Comparator 接口的定义相比较于 Comparable 就复杂的多了，不过，核心的方法只有两个，来看一下源码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Comparator&lt;T&gt; &#123;</span><br><span class="line">    int compare(T o1, T o2);</span><br><span class="line">    boolean equals(Object obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个方法 compare(T o1, T o2) 的返回值可能为负数，零或者正数，代表的意思是第一个对象小于、等于或者大于第二个对象。</p>
<p>第二个方法 equals(Object obj) 需要传入一个 Object 作为参数，并判断该 Object 是否和 Comparator 保持一致。</p>
<p>有时候，我们想让类保持它的原貌，不想主动实现 Comparable 接口，但我们又需要它们之间进行比较，该怎么办呢？</p>
<p>Comparator 就派上用场了，来看一下示例。</p>
<p><strong>1）原封不动的 Cmower 类。 </strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Cmower  &#123;</span><br><span class="line">    private int age;</span><br><span class="line">    private String name;</span><br><span class="line">    public Cmower(int age, String name) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Cmower 类有两个字段：age 和 name，意味着该类可以按照 age 或者 name 进行排序。</p>
<p><strong>2）再来看 Comparator 接口的实现类。 </strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class CmowerComparator implements Comparator&lt;Cmower&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(Cmower o1, Cmower o2) &#123;</span><br><span class="line">        return o1.getAge() - o2.getAge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照 age 进行比较。当然也可以再实现一个比较器，按照 name 进行自然排序，示例如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class CmowerNameComparator implements Comparator&lt;Cmower&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(Cmower o1, Cmower o2) &#123;</span><br><span class="line">        if (o1.getName().hashCode() &lt; o2.getName().hashCode()) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125; else if (o1.getName().hashCode() == o2.getName().hashCode()) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3）再来看测试类。 </strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Cmower wanger = new Cmower(19,&quot;沉默王二&quot;);</span><br><span class="line">Cmower wangsan = new Cmower(16,&quot;沉默王三&quot;);</span><br><span class="line">Cmower wangyi = new Cmower(28,&quot;沉默王一&quot;);</span><br><span class="line">List&lt;Cmower&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list.add(wanger);</span><br><span class="line">list.add(wangsan);</span><br><span class="line">list.add(wangyi);</span><br><span class="line">list.sort(new CmowerComparator());</span><br><span class="line">for (Cmower c : list) &#123;</span><br><span class="line">    System.out.println(c.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建了三个对象，age 不同，name 不同，并把它们加入到了 List 当中。然后使用 List 的 sort() 方法进行排序，来看一下输出的结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">沉默王三</span><br><span class="line">沉默王二</span><br><span class="line">沉默王一</span><br></pre></td></tr></table></figure>
<p>这意味着沉默王三的年纪比沉默王二小，排在第一位；沉默王一的年纪比沉默王二大，排在第三位。和我们的预期完全符合。</p>
<p>借此机会，再来看一下 sort 方法的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void sort(Comparator&lt;? super E&gt; c) &#123;</span><br><span class="line">    // 保存当前队列的 modCount 值，用于检测 sort 操作是否非法</span><br><span class="line">    final int expectedModCount = modCount;</span><br><span class="line">    // 调用 Arrays.sort 对 elementData 数组进行排序，使用传入的比较器 c</span><br><span class="line">    Arrays.sort((E[]) elementData, 0, size, c);</span><br><span class="line">    // 检查操作期间 modCount 是否被修改，如果被修改则抛出并发修改异常</span><br><span class="line">    if (modCount != expectedModCount) &#123;</span><br><span class="line">        throw new ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">    // 增加 modCount 值，表示队列已经被修改过</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，参数就是一个 Comparator 接口，并且使用了泛型 Comparator&lt;? super E&gt; c 。</p>
<p><strong>03、到底该用哪一个？ </strong></p>
<p>通过上面的两个例子可以比较出 Comparable 和 Comparator 两者之间的区别：</p>
<ul>
<li>一个类实现了 Comparable 接口，意味着该类的对象可以直接进行比较（排序），但比较（排序）的方式只有一种，很单一。</li>
<li>一个类如果想要保持原样，又需要进行不同方式的比较（排序），就可以定制比较器（实现 Comparator 接口）。</li>
<li>Comparable 接口在 java.lang 包下，而 Comparator 接口在 java.util 包下，算不上是亲兄弟，但可以称得上是表（堂）兄弟。</li>
</ul>
<p>举个不恰当的例子。我想从洛阳出发去北京看长城，体验一下好汉的感觉，要么坐飞机，要么坐高铁；但如果是孙悟空的话，翻个筋斗就到了。我和孙悟空之间有什么区别呢？</p>
<p>孙悟空自己实现了 Comparable 接口（他那年代也没有飞机和高铁，没得选），而我可以借助 Comparator 接口（现代化的交通工具）。</p>
<p>好了，关于 Comparable 和 Comparator 我们就先聊这么多。总而言之，如果对象的排序需要基于自然顺序，请选择 Comparable ，如果需要按照对象的不同属性进行排序，请选择 Comparator 。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://htx-rest.github.io">鲸落</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://htx-rest.github.io/posts/410ba5d8.html">https://htx-rest.github.io/posts/410ba5d8.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://htx-rest.github.io" target="_blank">鲸落</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/">Java集合框架</a></div><div class="post_share"><div class="social-share" data-image="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/assets/weplay.png" target="_blank"><img class="post-qr-code-img" src="/assets/weplay.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/assets/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/assets/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/c15068a.html" title="Java进阶之路（三）"><img class="cover" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java进阶之路（三）</div></div></a></div><div class="next-post pull-right"><a href="/posts/6dea1f6c.html" title="华为校招笔试编程真题及其解析（2023.10.12）"><img class="cover" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">华为校招笔试编程真题及其解析（2023.10.12）</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/assets/mmexport1694508539292.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">鲸落</div><div class="author-info__description">随波不逐流</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">138</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">171</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/htx-rest"><i class="fab fa-github"></i><span>前往小窝</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="/assets/wenxin.jpg" target="_blank" title="微信"><i class="iconfont icon-weixin" style="color: #24292e;"></i></a><a class="social-icon" href="/assets/weixingongzhonghao.jpg" target="_blank" title="微信公众号"><i class="iconfont icon-weixingongzhonghao" style="color: #24292e;"></i></a><a class="social-icon" href="https://res.abeim.cn/api/qq/?qq=1656855152" target="_blank" title="QQ"><i class="iconfont icon-QQ" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:1656855152@qq.com" target="_blank" title="QQ邮箱"><i class="iconfont icon-youxiang" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">摸鱼中！！！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#4-Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6"><span class="toc-text">4 Java 集合框架</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-List%E3%80%81Set%E3%80%81Map%E3%80%81%E9%98%9F%E5%88%97%EF%BC%8C%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90"><span class="toc-text">4.1 List、Set、Map、队列，全面解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%8C%E4%BA%86%E8%A7%A3%E4%B8%8B"><span class="toc-text">4.2 时间复杂度，了解下</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-ArrayList%E8%AF%A6%E8%A7%A3%EF%BC%88%E9%99%84%E6%BA%90%E7%A0%81%EF%BC%89"><span class="toc-text">4.3 ArrayList详解（附源码）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-LinkedList%E8%AF%A6%E8%A7%A3%EF%BC%88%E9%99%84%E6%BA%90%E7%A0%81%EF%BC%89"><span class="toc-text">4.4 LinkedList详解（附源码）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-ArrayList%E5%92%8CLinkedList%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">4.5 ArrayList和LinkedList的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-Java%E6%B3%9B%E5%9E%8B%EF%BC%8C%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90"><span class="toc-text">4.6 Java泛型，深入解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7-Iterator%E5%92%8CIterable%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">4.7 Iterator和Iterable的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-8-Java-foreach-%E5%BE%AA%E7%8E%AF%E9%99%B7%E9%98%B1"><span class="toc-text">4.8 Java foreach 循环陷阱</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-9-HashMap%E8%AF%A6%E8%A7%A3%EF%BC%88%E9%99%84%E6%BA%90%E7%A0%81%EF%BC%89"><span class="toc-text">4.9 HashMap详解（附源码）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-10-LinkedHashMap%E8%AF%A6%E8%A7%A3%EF%BC%88%E9%99%84%E6%BA%90%E7%A0%81%EF%BC%89"><span class="toc-text">4.10 LinkedHashMap详解（附源码）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-11-TreeMap%E8%AF%A6%E8%A7%A3%EF%BC%88%E9%99%84%E6%BA%90%E7%A0%81%EF%BC%89"><span class="toc-text">4.11 TreeMap详解（附源码）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-12-%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97ArrayDeque%E8%AF%A6%E8%A7%A3"><span class="toc-text">4.12 双端队列ArrayDeque详解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-13-%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97PriorityQueue%E8%AF%A6%E8%A7%A3"><span class="toc-text">4.13 优先级队列PriorityQueue详解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-14-Comparable%E5%92%8CComparator%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">4.14 Comparable和Comparator的区别</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 By 鲸落</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">I wish you to become your own sun, no need to rely on who's light.</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async src="https://cdn1.tianli0.top/npm/vue@2.6.14/dist/vue.min.js"></script><script async src="https://cdn1.tianli0.top/npm/element-ui@2.15.6/lib/index.js"></script><script async src="https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script><script defer type="text/javascript" src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script defer src="https://cdn1.tianli0.top/gh/nextapps-de/winbox/dist/winbox.bundle.min.js"></script><script async src="//at.alicdn.com/t/c/font_4233300_xxm4hpxio1.js"></script><script async src="/js/fps.js"></script><script async src="https://cdn.wpon.cn/2022-sucai/Gold-ingot.js"></script><script defer data-pjax src="/js/cat.js"></script><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><canvas id="snow"></canvas><script defer src="/js/fomal.js"></script><script defer src="/js/cursor.js"></script><script defer src="/live2d-widget/autoload.js"></script><script async src="/js/title.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 190px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 160px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(http://p0.itc.cn/images03/20200525/332e1ea10c634cbfaf0dfc5b69d00a3c.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Docker/&quot;);" href="javascript:void(0);">Docker</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr">Docker</span></li><li class="categoryBar-list-item" style="background:url(http://p8.itc.cn/images03/20200525/377f4f7044fe49b0bb932f43ef4f4891.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Hexo魔改教程/&quot;);" href="javascript:void(0);">Hexo魔改教程</a><span class="categoryBar-list-count">12</span><span class="categoryBar-list-descr">Hexo魔改教程</span></li><li class="categoryBar-list-item" style="background:url(http://p8.itc.cn/images03/20200525/0ed549edde2c4d5eaecc2824e753ca74.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/面试题/&quot;);" href="javascript:void(0);">面试题</a><span class="categoryBar-list-count">10</span><span class="categoryBar-list-descr">MySQL</span></li><li class="categoryBar-list-item" style="background:url(http://p6.itc.cn/images03/20200525/8dedcdf6ace44a50a1deb6a9743821fe.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/面渣笔记/&quot;);" href="javascript:void(0);">面渣笔记</a><span class="categoryBar-list-count">9</span><span class="categoryBar-list-descr">面试题</span></li><li class="categoryBar-list-item" style="background:url(http://p8.itc.cn/images03/20200525/5f6cecf10ea04dec9a5d42bf9c4c3739.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/MySQL/&quot;);" href="javascript:void(0);">MySQL</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr">Redis</span></li><li class="categoryBar-list-item" style="background:url(http://p0.itc.cn/images03/20200525/332e1ea10c634cbfaf0dfc5b69d00a3c.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/RabbitMQ/&quot;);" href="javascript:void(0);">RabbitMQ</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr">Java笔试编程真题</span></li><li class="categoryBar-list-item" style="background:url(http://p8.itc.cn/images03/20200525/377f4f7044fe49b0bb932f43ef4f4891.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Redis/&quot;);" href="javascript:void(0);">Redis</a><span class="categoryBar-list-count">5</span><span class="categoryBar-list-descr">Java数据结构与算法</span></li><li class="categoryBar-list-item" style="background:url(http://p8.itc.cn/images03/20200525/0ed549edde2c4d5eaecc2824e753ca74.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Kafka/&quot;);" href="javascript:void(0);">Kafka</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(http://p6.itc.cn/images03/20200525/8dedcdf6ace44a50a1deb6a9743821fe.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Java笔试编程真题/&quot;);" href="javascript:void(0);">Java笔试编程真题</a><span class="categoryBar-list-count">87</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/leetcode/&quot;);" href="javascript:void(0);">leetcode</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/面试/&quot;);" href="javascript:void(0);">面试</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/设计模式/&quot;);" href="javascript:void(0);">设计模式</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Java数据结构与算法/&quot;);" href="javascript:void(0);">Java数据结构与算法</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var qweather_key = 'b16a1fa0e63c46a4b8f28abfb06ae3fe';
  var gaud_map_key = 'e2b04289e870b005374ee030148d64fd&s=rsv3';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '113.34532,23.15624';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v6.2.0" title=""><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.9.0" title=""><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="https://npm.elemecdn.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.js"></script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/a449f40d.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-22</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/a449f40d.html&quot;);" href="javascript:void(0);" alt="">美的校招笔试编程真题（2023.4.19）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/a449f40d.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/b2891dfd.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-14</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/b2891dfd.html&quot;);" href="javascript:void(0);" alt="">美团校招笔试编程真题（2023.3.11）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/b2891dfd.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/1b4308aa.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-17</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/1b4308aa.html&quot;);" href="javascript:void(0);" alt="">美团校招笔试编程真题（2023.4.8）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/1b4308aa.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/7b50e04c.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/7b50e04c.html&quot;);" href="javascript:void(0);" alt="">美团校招笔试编程真题（2023.5.13）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/7b50e04c.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/f53a714c.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/f53a714c.html&quot;);" href="javascript:void(0);" alt="">美团校招笔试编程真题（2023.4.29）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/f53a714c.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/9a879128.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/9a879128.html&quot;);" href="javascript:void(0);" alt="">美团校招笔试编程真题（2023.4.23）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/9a879128.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/f84cb424.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-17</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/f84cb424.html&quot;);" href="javascript:void(0);" alt="">美团校招笔试编程真题（2023.4.15）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/f84cb424.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/cf815277.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-15</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/cf815277.html&quot;);" href="javascript:void(0);" alt="">美团校招笔试编程真题（2023.3.18）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/cf815277.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/843d6f38.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/843d6f38.html&quot;);" href="javascript:void(0);" alt="">美团校招笔试编程真题及其解析（2023.3.4）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/843d6f38.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/6482affa.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/6482affa.html&quot;);" href="javascript:void(0);" alt="">美团校招笔试编程真题及其解析（2023.3.25）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/6482affa.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/7a556a2f.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-14</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/7a556a2f.html&quot;);" href="javascript:void(0);" alt="">美团2024届秋招笔试编程真题（2023.9.9）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/7a556a2f.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/61f68248.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/61f68248.html&quot;);" href="javascript:void(0);" alt="">美团2024届秋招笔试第四场编程真题（2023.9.2）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/61f68248.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/f51f72fb.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-06</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/f51f72fb.html&quot;);" href="javascript:void(0);" alt="">美团2024届秋招笔试第二场编程真题（2023.8.19）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/f51f72fb.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/5b7a3f2a.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-07</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/5b7a3f2a.html&quot;);" href="javascript:void(0);" alt="">美团2024届秋招笔试第三场编程真题（2023.8.26）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/5b7a3f2a.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/860131f4.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-04</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/860131f4.html&quot;);" href="javascript:void(0);" alt="">美团2024届秋招笔试第一场编程真题（2023.8.12）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/860131f4.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/9ed49519.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/9ed49519.html&quot;);" href="javascript:void(0);" alt="">网易有道校招笔试编程真题及其解析（2023.4.2）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/9ed49519.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/f766fbc2.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/f766fbc2.html&quot;);" href="javascript:void(0);" alt="">科大讯飞校招笔试编程真题（2023.8.31）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/f766fbc2.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/6da30861.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/6da30861.html&quot;);" href="javascript:void(0);" alt="">科大讯飞校招笔试编程真题（2023.7.8）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/6da30861.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/f9fa8a74.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/f9fa8a74.html&quot;);" href="javascript:void(0);" alt="">科大讯飞校招笔试编程真题（2023.7.29）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/f9fa8a74.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2efb0d75.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2efb0d75.html&quot;);" href="javascript:void(0);" alt="">科大讯飞校招笔试编程真题（2023.7.22）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2efb0d75.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/10ab47eb.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/10ab47eb.html&quot;);" href="javascript:void(0);" alt="">科大讯飞校招笔试编程真题（2023.7.1）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/10ab47eb.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/7641fb6a.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/7641fb6a.html&quot;);" href="javascript:void(0);" alt="">科大讯飞校招笔试编程真题（2022.10.14）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/7641fb6a.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/815405c2.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/815405c2.html&quot;);" href="javascript:void(0);" alt="">科大讯飞校招笔试编程真题及其解析（2023.8.13）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/815405c2.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/52772af7.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/52772af7.html&quot;);" href="javascript:void(0);" alt="">科大讯飞校招笔试编程真题及其解析（2023.7.15）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/52772af7.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/19d99df0.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-19</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/19d99df0.html&quot;);" href="javascript:void(0);" alt="">操作系统OS面试题八股文</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/19d99df0.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/a135cfaa.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/a135cfaa.html&quot;);" href="javascript:void(0);" alt="">携程校招笔试编程真题及其解析（2023.9.7）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/a135cfaa.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/b264b8b5.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-26</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/b264b8b5.html&quot;);" href="javascript:void(0);" alt="">携程校招笔试编程真题及其解析（2023.9.21）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/b264b8b5.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/1b7134f2.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/1b7134f2.html&quot;);" href="javascript:void(0);" alt="">携程校招笔试编程真题及其解析（2023.4.15）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/1b7134f2.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/c442a03f.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-26</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/c442a03f.html&quot;);" href="javascript:void(0);" alt="">携程校招笔试编程真题及其解析（2023.5.4）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/c442a03f.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/aeeccc.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/aeeccc.html&quot;);" href="javascript:void(0);" alt="">携程校招笔试编程真题及其解析（2023.3.7）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/aeeccc.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/faa64596.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/faa64596.html&quot;);" href="javascript:void(0);" alt="">携程校招笔试编程真题及其解析（2023.5.25）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/faa64596.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/d3a0cf14.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-26</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/d3a0cf14.html&quot;);" href="javascript:void(0);" alt="">携程校招笔试编程真题及其解析（2023.3.29）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/d3a0cf14.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/cc63a592.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/cc63a592.html&quot;);" href="javascript:void(0);" alt="">携程校招笔试编程真题及其解析（2023.3.16）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/cc63a592.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2ec06a90.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-23</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2ec06a90.html&quot;);" href="javascript:void(0);" alt="">恒生电子校招笔试编程真题（2023.9.22）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2ec06a90.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/acdf6806.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-27</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/acdf6806.html&quot;);" href="javascript:void(0);" alt="">微众银行校招笔试编程真题及其解析（2023.9.3）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/acdf6806.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/7520a94a.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-27</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/7520a94a.html&quot;);" href="javascript:void(0);" alt="">微众银行校招笔试编程真题及其解析（2023.9.13）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/7520a94a.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/ac4bafef.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-27</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/ac4bafef.html&quot;);" href="javascript:void(0);" alt="">微众银行校招笔试编程真题及其解析（2023.4.12）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/ac4bafef.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/5357b25a.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-27</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/5357b25a.html&quot;);" href="javascript:void(0);" alt="">微众银行校招笔试编程真题及其解析（2023.4.23）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/5357b25a.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/70a5bb78.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-11</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/70a5bb78.html&quot;);" href="javascript:void(0);" alt="">广联达校招笔试编程真题及其解析（2023.10.11）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/70a5bb78.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/bad939ec.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-22</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/bad939ec.html&quot;);" href="javascript:void(0);" alt="">小红书校招笔试编程真题（2023.8.6）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/bad939ec.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/92b4cb69.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-22</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/92b4cb69.html&quot;);" href="javascript:void(0);" alt="">小红书校招笔试编程真题（2023.8.19）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/92b4cb69.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/4ce12134.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-22</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/4ce12134.html&quot;);" href="javascript:void(0);" alt="">小红书校招笔试编程真题（2023.7.23）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/4ce12134.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/befb4d57.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-22</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/befb4d57.html&quot;);" href="javascript:void(0);" alt="">小红书校招笔试编程真题（2023.5.7）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/befb4d57.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/9578e9c1.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-22</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/9578e9c1.html&quot;);" href="javascript:void(0);" alt="">小红书校招笔试编程真题（2023.4.9）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/9578e9c1.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/7d093ba9.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-22</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/7d093ba9.html&quot;);" href="javascript:void(0);" alt="">小红书校招笔试编程真题（2023.4.23）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/7d093ba9.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/8f70f515.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-22</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/8f70f515.html&quot;);" href="javascript:void(0);" alt="">小红书校招笔试编程真题（2023.3.26）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/8f70f515.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/7dc0b3d9.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/7dc0b3d9.html&quot;);" href="javascript:void(0);" alt="">字节跳动校招笔试编程真题及其解析（2023.9.3）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/7dc0b3d9.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/ecffee83.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/ecffee83.html&quot;);" href="javascript:void(0);" alt="">字节跳动校招笔试编程真题及其解析（2023.9.17）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/ecffee83.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/d289fe7.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/d289fe7.html&quot;);" href="javascript:void(0);" alt="">字节跳动校招笔试编程真题及其解析（2023.8.27）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/d289fe7.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/90ffa75e.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/90ffa75e.html&quot;);" href="javascript:void(0);" alt="">字节跳动校招笔试编程真题及其解析（2023.8.20）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/90ffa75e.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/62a18d75.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/62a18d75.html&quot;);" href="javascript:void(0);" alt="">字节跳动校招笔试编程真题及其解析（2023.7.5）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/62a18d75.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/1c8174c5.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/1c8174c5.html&quot;);" href="javascript:void(0);" alt="">字节跳动校招笔试编程真题及其解析（2023.5.12）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/1c8174c5.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/1d9a64f3.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/1d9a64f3.html&quot;);" href="javascript:void(0);" alt="">字节跳动校招笔试编程真题及其解析（2023.3.24）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/1d9a64f3.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/66b7b354.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/66b7b354.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.9.6）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/66b7b354.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/f0ad93be.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/f0ad93be.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.9.27）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/f0ad93be.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/7fcf04e9.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/7fcf04e9.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.9.23）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/7fcf04e9.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/d5c6cc62.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/d5c6cc62.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.9.21）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/d5c6cc62.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/6d7aab07.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/6d7aab07.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.9.20）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/6d7aab07.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/386f7e39.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/386f7e39.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.9.13）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/386f7e39.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/f66d8903.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/f66d8903.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.8.30）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/f66d8903.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/d9b80f5d.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/d9b80f5d.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.8.23）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/d9b80f5d.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/1175732f.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/1175732f.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.5.6）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/1175732f.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2f068fa6.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2f068fa6.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.5.31）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2f068fa6.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/25b85624.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/25b85624.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.5.24）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/25b85624.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/70ad831a.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/70ad831a.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.5.17）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/70ad831a.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/3605ff9d.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/3605ff9d.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.4.19）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/3605ff9d.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/ed7abba3.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/ed7abba3.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.5.10）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/ed7abba3.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/29c6951b.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/29c6951b.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.4.26）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/29c6951b.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/e104789c.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/e104789c.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.4.12）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/e104789c.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/257ff08.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/257ff08.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.10.18）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/257ff08.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/6dea1f6c.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/6dea1f6c.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.10.12）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/6dea1f6c.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/7f5fb082.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/7f5fb082.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2023.10.11）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/7f5fb082.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/68b410aa.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/68b410aa.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2022.9.23）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/68b410aa.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/e1169d40.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-10</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/e1169d40.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2022.8.30）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/e1169d40.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/c2bdd821.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/c2bdd821.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2022.9.21）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/c2bdd821.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/b477f365.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-10</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/b477f365.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2022.11.2）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/b477f365.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/82287452.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/82287452.html&quot;);" href="javascript:void(0);" alt="">华为校招笔试编程真题及其解析（2022.10.12）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/82287452.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/c13307dc.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/c13307dc.html&quot;);" href="javascript:void(0);" alt="">java进阶之路（一）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/c13307dc.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/247ce45c.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/247ce45c.html&quot;);" href="javascript:void(0);" alt="">华为od校招笔试编程真题及其解析（2023.5.3）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/247ce45c.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/541f7aa7.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/541f7aa7.html&quot;);" href="javascript:void(0);" alt="">华为od校招笔试编程真题及其解析（2023.5.11）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/541f7aa7.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/3821b0f8.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/3821b0f8.html&quot;);" href="javascript:void(0);" alt="">华为od校招笔试编程真题及其解析（2023.4.8）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/3821b0f8.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/c8c04449.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/c8c04449.html&quot;);" href="javascript:void(0);" alt="">华为od校招笔试编程真题及其解析（2023.4.28）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/c8c04449.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/d746ca6.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/d746ca6.html&quot;);" href="javascript:void(0);" alt="">华为od校招笔试编程真题及其解析（2023.4.20）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/d746ca6.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/c5b68121.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/c5b68121.html&quot;);" href="javascript:void(0);" alt="">华为od校招笔试编程真题及其解析（2023.4.14）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/c5b68121.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/8f7328f8.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/8f7328f8.html&quot;);" href="javascript:void(0);" alt="">华为od校招笔试编程真题及其解析（2023.3.10）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/8f7328f8.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/d123261.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/d123261.html&quot;);" href="javascript:void(0);" alt="">华为od校招笔试编程真题及其解析（2022.11.3）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/d123261.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/9df7a3e6.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-25</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/9df7a3e6.html&quot;);" href="javascript:void(0);" alt="">华为od校招笔试编程真题及其解析（2022.10.14）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/9df7a3e6.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/bb381fef.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/bb381fef.html&quot;);" href="javascript:void(0);" alt="">Java进阶之路（四）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/bb381fef.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/410ba5d8.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/410ba5d8.html&quot;);" href="javascript:void(0);" alt="">Java进阶之路（二）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/410ba5d8.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/c15068a.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-10-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/c15068a.html&quot;);" href="javascript:void(0);" alt="">Java进阶之路（三）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/c15068a.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/3cbc845.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/3cbc845.html&quot;);" href="javascript:void(0);" alt="">Java数据结构与算法</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/3cbc845.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/f9c52cbb.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-19</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/f9c52cbb.html&quot;);" href="javascript:void(0);" alt="">设计模式面试篇-参考回答</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/f9c52cbb.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/eabb6106.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-12</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/eabb6106.html&quot;);" href="javascript:void(0);" alt="">消息中间件面试题-参考回答</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/eabb6106.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/27f853cc.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/27f853cc.html&quot;);" href="javascript:void(0);" alt="">框架篇面试题-参考回答</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/27f853cc.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/6ba374e2.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/6ba374e2.html&quot;);" href="javascript:void(0);" alt="">微服务面试篇-参考回答</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/6ba374e2.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/dbf9d5c9.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/dbf9d5c9.html&quot;);" href="javascript:void(0);" alt="">常见技术场景</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/dbf9d5c9.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/af15ea36.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/af15ea36.html&quot;);" href="javascript:void(0);" alt="">多线程相关面试题</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/af15ea36.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/258353ca.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/258353ca.html&quot;);" href="javascript:void(0);" alt="">kafka深入浅出，快速玩转分布式发布订阅消息系统</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/258353ca.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/6f83b1e4.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/6f83b1e4.html&quot;);" href="javascript:void(0);" alt="">Redis面试题-参考回答</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/6f83b1e4.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/37cf2cfd.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/37cf2cfd.html&quot;);" href="javascript:void(0);" alt="">Redis集群</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/37cf2cfd.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/6bb2589.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-12</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/6bb2589.html&quot;);" href="javascript:void(0);" alt="">Rabbitmq消息中间件（一）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/6bb2589.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/d2ba1e3f.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/d2ba1e3f.html&quot;);" href="javascript:void(0);" alt="">Redis原理篇</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/d2ba1e3f.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/6bb2589.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-12</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/6bb2589.html&quot;);" href="javascript:void(0);" alt="">Rabbitmq消息中间件（二）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/6bb2589.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/337fcc87.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=595920241,2439700946&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/337fcc87.html&quot;);" href="javascript:void(0);" alt="">MySQL基础篇</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/337fcc87.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/18ab1f25.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/18ab1f25.html&quot;);" href="javascript:void(0);" alt="">MySQL面试篇-参考回答</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/18ab1f25.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/11f76754.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/11f76754.html&quot;);" href="javascript:void(0);" alt="">MySQL进阶篇</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/11f76754.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/592cf81.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/592cf81.html&quot;);" href="javascript:void(0);" alt="">MySQL运维篇</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/592cf81.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/b481a8d6.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/b481a8d6.html&quot;);" href="javascript:void(0);" alt="">Java集合相关面试题</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/b481a8d6.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/c218eb30.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-20</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/c218eb30.html&quot;);" href="javascript:void(0);" alt="">JVM相关面试题</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/c218eb30.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/7eb663f5.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/7eb663f5.html&quot;);" href="javascript:void(0);" alt="">Docker安装OpenResty</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/7eb663f5.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/be6d66dc.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/be6d66dc.html&quot;);" href="javascript:void(0);" alt="">Docker安装Canal</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/be6d66dc.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/a6573b44.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/u=4155835667,974645702&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/a6573b44.html&quot;);" href="javascript:void(0);" alt="">Centos7安装Docker</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/a6573b44.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/d3404069.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/d3404069.html&quot;);" href="javascript:void(0);" alt="">Redis高级篇</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/d3404069.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/a6b15897.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/silhouette_night_starry_sky_137292_300x168.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/a6b15897.html&quot;);" href="javascript:void(0);" alt="">Redis实战篇</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/a6b15897.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/4604f75b.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/assets/v2-d0a0172a71b6bc4ff18cd1f11bfa6b3b_r.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-09-01</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/4604f75b.html&quot;);" href="javascript:void(0);" alt="">Redis基础篇</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/4604f75b.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '1s');
    arr[i].setAttribute('data-wow-offset', '100');
    arr[i].setAttribute('data-wow-iteration', '2');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>